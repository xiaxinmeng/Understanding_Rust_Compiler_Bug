{"sha": "16f01cc13f6a092873096c44eed546561b88d245", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZjAxY2MxM2Y2YTA5Mjg3MzA5NmM0NGVlZDU0NjU2MWI4OGQyNDU=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-12-22T21:50:57Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-12-23T12:42:09Z"}, "message": "Rename and namespace `FPCategory`\n\nRename `FPCategory` to `FpCategory` and `Fp* to `*` in order to adhere to the\nnaming convention\n\nThis is a [breaking-change].\n\nExisting code like this:\n```\nuse std::num::{FPCategory, FPNaN};\n```\nshould be adjusted to this:\n```\nuse std::num::FpCategory as Fp\n```\n\nIn the following code you can use the constants `Fp::Nan`, `Fp::Normal`, etc.", "tree": {"sha": "878df21a28ad63754019346cf9a390bb0bb9eabe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/878df21a28ad63754019346cf9a390bb0bb9eabe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16f01cc13f6a092873096c44eed546561b88d245", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16f01cc13f6a092873096c44eed546561b88d245", "html_url": "https://github.com/rust-lang/rust/commit/16f01cc13f6a092873096c44eed546561b88d245", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16f01cc13f6a092873096c44eed546561b88d245/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "658529467d9d69ac9e09cacf98a6d61d781c2c76", "url": "https://api.github.com/repos/rust-lang/rust/commits/658529467d9d69ac9e09cacf98a6d61d781c2c76", "html_url": "https://github.com/rust-lang/rust/commit/658529467d9d69ac9e09cacf98a6d61d781c2c76"}], "stats": {"total": 115, "additions": 59, "deletions": 56}, "files": [{"sha": "55a87973e0f5c2d7767182e80f727d9e4a11aa3d", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=16f01cc13f6a092873096c44eed546561b88d245", "patch": "@@ -18,8 +18,8 @@ use char;\n use char::Char;\n use fmt;\n use iter::{range, DoubleEndedIteratorExt};\n-use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n-use num::cast;\n+use num::{cast, Float, ToPrimitive};\n+use num::FpCategory as Fp;\n use ops::FnOnce;\n use result::Result::Ok;\n use slice::{mod, SliceExt};\n@@ -109,11 +109,11 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     let _1: T = Float::one();\n \n     match num.classify() {\n-        FPNaN => return f(\"NaN\".as_bytes()),\n-        FPInfinite if num > _0 => {\n+        Fp::Nan => return f(\"NaN\".as_bytes()),\n+        Fp::Infinite if num > _0 => {\n             return f(\"inf\".as_bytes());\n         }\n-        FPInfinite if num < _0 => {\n+        Fp::Infinite if num < _0 => {\n             return f(\"-inf\".as_bytes());\n         }\n         _ => {}"}, {"sha": "d8b22a085aa94da348aa26ead942c511cb1d335c", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=16f01cc13f6a092873096c44eed546561b88d245", "patch": "@@ -18,7 +18,8 @@\n \n use intrinsics;\n use mem;\n-use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::Float;\n+use num::FpCategory as Fp;\n use num::from_str_radix;\n use option::Option;\n \n@@ -156,23 +157,23 @@ impl Float for f32 {\n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n     #[inline]\n     fn is_normal(self) -> bool {\n-        self.classify() == FPNormal\n+        self.classify() == Fp::Normal\n     }\n \n     /// Returns the floating point category of the number. If only one property\n     /// is going to be tested, it is generally faster to use the specific\n     /// predicate instead.\n-    fn classify(self) -> FPCategory {\n+    fn classify(self) -> Fp {\n         const EXP_MASK: u32 = 0x7f800000;\n         const MAN_MASK: u32 = 0x007fffff;\n \n         let bits: u32 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n+            (0, 0)        => Fp::Zero,\n+            (_, 0)        => Fp::Subnormal,\n+            (0, EXP_MASK) => Fp::Infinite,\n+            (_, EXP_MASK) => Fp::Nan,\n+            _             => Fp::Normal,\n         }\n     }\n "}, {"sha": "a3f5c2df91fac8e839cdca30e7d6a4487c1c646e", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=16f01cc13f6a092873096c44eed546561b88d245", "patch": "@@ -18,7 +18,8 @@\n \n use intrinsics;\n use mem;\n-use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::Float;\n+use num::FpCategory as Fp;\n use num::from_str_radix;\n use option::Option;\n \n@@ -164,23 +165,23 @@ impl Float for f64 {\n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n     #[inline]\n     fn is_normal(self) -> bool {\n-        self.classify() == FPNormal\n+        self.classify() == Fp::Normal\n     }\n \n     /// Returns the floating point category of the number. If only one property\n     /// is going to be tested, it is generally faster to use the specific\n     /// predicate instead.\n-    fn classify(self) -> FPCategory {\n+    fn classify(self) -> Fp {\n         const EXP_MASK: u64 = 0x7ff0000000000000;\n         const MAN_MASK: u64 = 0x000fffffffffffff;\n \n         let bits: u64 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n+            (0, 0)        => Fp::Zero,\n+            (_, 0)        => Fp::Subnormal,\n+            (0, EXP_MASK) => Fp::Infinite,\n+            (_, EXP_MASK) => Fp::Nan,\n+            _             => Fp::Normal,\n         }\n     }\n "}, {"sha": "0d2ce4f60718f8faba2e1a961c3e0c9cf8dc2fae", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=16f01cc13f6a092873096c44eed546561b88d245", "patch": "@@ -15,8 +15,6 @@\n #![stable]\n #![allow(missing_docs)]\n \n-pub use self::FPCategory::*;\n-\n use {int, i8, i16, i32, i64};\n use {uint, u8, u16, u32, u64};\n use {f32, f64};\n@@ -1222,17 +1220,17 @@ impl_num_cast! { f64,   to_f64 }\n /// Used for representing the classification of floating point numbers\n #[deriving(Copy, PartialEq, Show)]\n #[unstable = \"may be renamed\"]\n-pub enum FPCategory {\n+pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n-    FPNaN,\n+    Nan,\n     /// Positive or negative infinity\n-    FPInfinite ,\n+    Infinite ,\n     /// Positive or negative zero\n-    FPZero,\n-    /// De-normalized floating point representation (less precise than `FPNormal`)\n-    FPSubnormal,\n+    Zero,\n+    /// De-normalized floating point representation (less precise than `Normal`)\n+    Subnormal,\n     /// A regular floating point number\n-    FPNormal,\n+    Normal,\n }\n \n /// A built-in floating point number.\n@@ -1277,7 +1275,7 @@ pub trait Float\n     /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n     fn is_normal(self) -> bool;\n     /// Returns the category that this number falls into.\n-    fn classify(self) -> FPCategory;\n+    fn classify(self) -> FpCategory;\n \n     // FIXME (#5527): These should be associated constants\n "}, {"sha": "830d96fe172bcb5a8688006b24fd68f70d85ad2a", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=16f01cc13f6a092873096c44eed546561b88d245", "patch": "@@ -201,8 +201,9 @@ use std;\n use std::collections::{HashMap, BTreeMap};\n use std::{char, f64, fmt, io, num, str};\n use std::mem::{swap, transmute};\n-use std::num::{Float, FPNaN, FPInfinite, Int};\n-use std::str::{FromStr};\n+use std::num::{Float, Int};\n+use std::num::FpCategory as Fp;\n+use std::str::FromStr;\n use std::string;\n use std::ops;\n use unicode::str as unicode_str;\n@@ -414,7 +415,7 @@ fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n \n fn fmt_number_or_null(v: f64) -> string::String {\n     match v.classify() {\n-        FPNaN | FPInfinite => string::String::from_str(\"null\"),\n+        Fp::Nan | Fp::Infinite => string::String::from_str(\"null\"),\n         _ if v.fract() != 0f64 => f64::to_str_digits(v, 6u),\n         _ => f64::to_str_digits(v, 6u) + \".0\",\n     }\n@@ -2332,7 +2333,7 @@ impl ToJson for f32 {\n impl ToJson for f64 {\n     fn to_json(&self) -> Json {\n         match self.classify() {\n-            FPNaN | FPInfinite => Json::Null,\n+            Fp::Nan | Fp::Infinite => Json::Null,\n             _                  => Json::F64(*self)\n         }\n     }"}, {"sha": "1f76382ce8a41c153b5d6983e8f142a39d717c84", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=16f01cc13f6a092873096c44eed546561b88d245", "patch": "@@ -351,6 +351,7 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n mod tests {\n     use f32::*;\n     use num::*;\n+    use num::FpCategory as Fp;\n \n     #[test]\n     fn test_min_nan() {\n@@ -620,14 +621,14 @@ mod tests {\n         let neg_inf: f32 = Float::neg_infinity();\n         let zero: f32 = Float::zero();\n         let neg_zero: f32 = Float::neg_zero();\n-        assert_eq!(nan.classify(), FPNaN);\n-        assert_eq!(inf.classify(), FPInfinite);\n-        assert_eq!(neg_inf.classify(), FPInfinite);\n-        assert_eq!(zero.classify(), FPZero);\n-        assert_eq!(neg_zero.classify(), FPZero);\n-        assert_eq!(1f32.classify(), FPNormal);\n-        assert_eq!(1e-37f32.classify(), FPNormal);\n-        assert_eq!(1e-38f32.classify(), FPSubnormal);\n+        assert_eq!(nan.classify(), Fp::Nan);\n+        assert_eq!(inf.classify(), Fp::Infinite);\n+        assert_eq!(neg_inf.classify(), Fp::Infinite);\n+        assert_eq!(zero.classify(), Fp::Zero);\n+        assert_eq!(neg_zero.classify(), Fp::Zero);\n+        assert_eq!(1f32.classify(), Fp::Normal);\n+        assert_eq!(1e-37f32.classify(), Fp::Normal);\n+        assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n     }\n \n     #[test]"}, {"sha": "221ecf62c058d999a589e30f9c4c312a37f16892", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=16f01cc13f6a092873096c44eed546561b88d245", "patch": "@@ -359,6 +359,7 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n mod tests {\n     use f64::*;\n     use num::*;\n+    use num::FpCategory as Fp;\n \n     #[test]\n     fn test_min_nan() {\n@@ -623,13 +624,13 @@ mod tests {\n         let neg_inf: f64 = Float::neg_infinity();\n         let zero: f64 = Float::zero();\n         let neg_zero: f64 = Float::neg_zero();\n-        assert_eq!(nan.classify(), FPNaN);\n-        assert_eq!(inf.classify(), FPInfinite);\n-        assert_eq!(neg_inf.classify(), FPInfinite);\n-        assert_eq!(zero.classify(), FPZero);\n-        assert_eq!(neg_zero.classify(), FPZero);\n-        assert_eq!(1e-307f64.classify(), FPNormal);\n-        assert_eq!(1e-308f64.classify(), FPSubnormal);\n+        assert_eq!(nan.classify(), Fp::Nan);\n+        assert_eq!(inf.classify(), Fp::Infinite);\n+        assert_eq!(neg_inf.classify(), Fp::Infinite);\n+        assert_eq!(zero.classify(), Fp::Zero);\n+        assert_eq!(neg_zero.classify(), Fp::Zero);\n+        assert_eq!(1e-307f64.classify(), Fp::Normal);\n+        assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n     }\n \n     #[test]"}, {"sha": "7c8763979bb36e3840491c1ce849f5439a44b41a", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=16f01cc13f6a092873096c44eed546561b88d245", "patch": "@@ -31,8 +31,7 @@ pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n pub use core::num::{FromStrRadix, from_str_radix};\n-pub use core::num::{FPCategory, FPNaN, FPInfinite, FPZero, FPSubnormal};\n-pub use core::num::{FPNormal, Float};\n+pub use core::num::{FpCategory, Float};\n \n #[experimental = \"may be removed or relocated\"]\n pub mod strconv;"}, {"sha": "b1f4e5acb93f4d28119c24f2974e59ed2a5dbb2f", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f01cc13f6a092873096c44eed546561b88d245/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=16f01cc13f6a092873096c44eed546561b88d245", "patch": "@@ -17,7 +17,8 @@ use self::SignificantDigits::*;\n use self::SignFormat::*;\n \n use char::{mod, Char};\n-use num::{mod, Int, Float, FPNaN, FPInfinite, ToPrimitive};\n+use num::{mod, Int, Float, ToPrimitive};\n+use num::FpCategory as Fp;\n use ops::FnMut;\n use slice::{SliceExt, CloneSliceExt};\n use str::StrExt;\n@@ -199,14 +200,14 @@ pub fn float_to_str_bytes_common<T: Float>(\n     let _1: T = Float::one();\n \n     match num.classify() {\n-        FPNaN => { return (b\"NaN\".to_vec(), true); }\n-        FPInfinite if num > _0 => {\n+        Fp::Nan => { return (b\"NaN\".to_vec(), true); }\n+        Fp::Infinite if num > _0 => {\n             return match sign {\n                 SignAll => (b\"+inf\".to_vec(), true),\n                 _       => (b\"inf\".to_vec(), true)\n             };\n         }\n-        FPInfinite if num < _0 => {\n+        Fp::Infinite if num < _0 => {\n             return match sign {\n                 SignNone => (b\"inf\".to_vec(), true),\n                 _        => (b\"-inf\".to_vec(), true),"}]}