{"sha": "5359879fb6d51a97c2b830f41b41d75e0c393e5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNTk4NzlmYjZkNTFhOTdjMmI4MzBmNDFiNDFkNzVlMGMzOTNlNWY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-15T21:24:24Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-18T20:02:27Z"}, "message": "libcore: convert unop traits to by value", "tree": {"sha": "63de8f439145cec8d41837e3a8cae256e467f514", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63de8f439145cec8d41837e3a8cae256e467f514"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5359879fb6d51a97c2b830f41b41d75e0c393e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5359879fb6d51a97c2b830f41b41d75e0c393e5f", "html_url": "https://github.com/rust-lang/rust/commit/5359879fb6d51a97c2b830f41b41d75e0c393e5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5359879fb6d51a97c2b830f41b41d75e0c393e5f/comments", "author": null, "committer": null, "parents": [{"sha": "5caebb23cd3b2c4c8519cc94759a7bc0a377f959", "url": "https://api.github.com/repos/rust-lang/rust/commits/5caebb23cd3b2c4c8519cc94759a7bc0a377f959", "html_url": "https://github.com/rust-lang/rust/commit/5caebb23cd3b2c4c8519cc94759a7bc0a377f959"}], "stats": {"total": 100, "additions": 100, "deletions": 0}, "files": [{"sha": "0090da3cdad6edfc9ebbf4764f566702c28b5998", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5359879fb6d51a97c2b830f41b41d75e0c393e5f/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5359879fb6d51a97c2b830f41b41d75e0c393e5f/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=5359879fb6d51a97c2b830f41b41d75e0c393e5f", "patch": "@@ -542,12 +542,16 @@ rem_float_impl! { f64, fmod }\n ///     -Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"neg\"]\n pub trait Neg<Result> for Sized? {\n     /// The method for the unary `-` operator\n     fn neg(&self) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n         impl Neg<$t> for $t {\n@@ -557,6 +561,8 @@ macro_rules! neg_impl {\n     )*)\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n         impl Neg<$t> for $t {\n@@ -566,6 +572,56 @@ macro_rules! neg_uint_impl {\n     }\n }\n \n+/// The `Neg` trait is used to specify the functionality of unary `-`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Neg`. When `-Foo` happens, it ends up calling\n+/// `neg`, and therefore, `main` prints `Negating!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Copy for Foo {}\n+///\n+/// impl Neg<Foo> for Foo {\n+///     fn neg(self) -> Foo {\n+///         println!(\"Negating!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     -Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"neg\"]\n+pub trait Neg<Result> {\n+    /// The method for the unary `-` operator\n+    fn neg(self) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! neg_impl {\n+    ($($t:ty)*) => ($(\n+        impl Neg<$t> for $t {\n+            #[inline]\n+            fn neg(self) -> $t { -self }\n+        }\n+    )*)\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! neg_uint_impl {\n+    ($t:ty, $t_signed:ty) => {\n+        impl Neg<$t> for $t {\n+            #[inline]\n+            fn neg(self) -> $t { -(self as $t_signed) as $t }\n+        }\n+    }\n+}\n+\n neg_impl! { int i8 i16 i32 i64 f32 f64 }\n \n neg_uint_impl! { uint, int }\n@@ -598,13 +654,17 @@ neg_uint_impl! { u64, i64 }\n ///     !Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n #[lang=\"not\"]\n pub trait Not<Result> for Sized? {\n     /// The method for the unary `!` operator\n     fn not(&self) -> Result;\n }\n \n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n         impl Not<$t> for $t {\n@@ -614,6 +674,46 @@ macro_rules! not_impl {\n     )*)\n }\n \n+/// The `Not` trait is used to specify the functionality of unary `!`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Not`. When `!Foo` happens, it ends up calling\n+/// `not`, and therefore, `main` prints `Not-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Copy for Foo {}\n+///\n+/// impl Not<Foo> for Foo {\n+///     fn not(self) -> Foo {\n+///         println!(\"Not-ing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     !Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"not\"]\n+pub trait Not<Result> {\n+    /// The method for the unary `!` operator\n+    fn not(self) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! not_impl {\n+    ($($t:ty)*) => ($(\n+        impl Not<$t> for $t {\n+            #[inline]\n+            fn not(self) -> $t { !self }\n+        }\n+    )*)\n+}\n+\n not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n /// The `BitAnd` trait is used to specify the functionality of `&`."}]}