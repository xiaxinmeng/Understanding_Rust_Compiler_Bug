{"sha": "ea4db3521ebc776d68cfa6752e50cc066439f5bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNGRiMzUyMWViYzc3NmQ2OGNmYTY3NTJlNTBjYzA2NjQzOWY1YmQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-28T19:08:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-02T21:46:45Z"}, "message": "move `ty_of_closure` into `check/closure.rs`, its only caller", "tree": {"sha": "c7cdd49e61b4679943ca8fe1881e625fd7baa467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7cdd49e61b4679943ca8fe1881e625fd7baa467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea4db3521ebc776d68cfa6752e50cc066439f5bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea4db3521ebc776d68cfa6752e50cc066439f5bd", "html_url": "https://github.com/rust-lang/rust/commit/ea4db3521ebc776d68cfa6752e50cc066439f5bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea4db3521ebc776d68cfa6752e50cc066439f5bd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11118dcf19a3c13c197345402a41c280bd329309", "url": "https://api.github.com/repos/rust-lang/rust/commits/11118dcf19a3c13c197345402a41c280bd329309", "html_url": "https://github.com/rust-lang/rust/commit/11118dcf19a3c13c197345402a41c280bd329309"}], "stats": {"total": 133, "additions": 69, "deletions": 64}, "files": [{"sha": "1471e235156eb8ade6a050fe0668ceb92e75565a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ea4db3521ebc776d68cfa6752e50cc066439f5bd/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea4db3521ebc776d68cfa6752e50cc066439f5bd/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ea4db3521ebc776d68cfa6752e50cc066439f5bd", "patch": "@@ -1206,65 +1206,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         bare_fn_ty\n     }\n \n-    pub fn ty_of_closure(&self,\n-        unsafety: hir::Unsafety,\n-        decl: &hir::FnDecl,\n-        abi: abi::Abi,\n-        expected_sig: Option<ty::FnSig<'tcx>>)\n-        -> ty::PolyFnSig<'tcx>\n-    {\n-        debug!(\"ty_of_closure(expected_sig={:?})\",\n-               expected_sig);\n-\n-        let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n-            let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n-                // no guarantee that the correct number of expected args\n-                // were supplied\n-                if i < e.inputs().len() {\n-                    Some(e.inputs()[i])\n-                } else {\n-                    None\n-                }\n-            });\n-\n-            let input_ty = self.ty_of_arg(a, expected_arg_ty);\n-            debug!(\"ty_of_closure: i={} input_ty={:?} expected_arg_ty={:?}\",\n-                   i, input_ty, expected_arg_ty);\n-\n-            input_ty\n-        });\n-\n-        let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n-\n-        let output_ty = match decl.output {\n-            hir::Return(ref output) => {\n-                if let (&hir::TyInfer, Some(expected_ret_ty)) = (&output.node, expected_ret_ty) {\n-                    self.record_ty(output.hir_id, expected_ret_ty, output.span);\n-                    expected_ret_ty\n-                } else {\n-                    self.ast_ty_to_ty(&output)\n-                }\n-            }\n-            hir::DefaultReturn(span) => {\n-                if let Some(expected_ret_ty) = expected_ret_ty {\n-                    expected_ret_ty\n-                } else {\n-                    self.ty_infer(span)\n-                }\n-            }\n-        };\n-\n-        debug!(\"ty_of_closure: output_ty={:?}\", output_ty);\n-\n-        ty::Binder(self.tcx().mk_fn_sig(\n-            input_tys,\n-            output_ty,\n-            decl.variadic,\n-            unsafety,\n-            abi\n-        ))\n-    }\n-\n     /// Given the bounds on an object, determines what single region bound (if any) we can\n     /// use to summarize this type. The basic idea is that we will use the bound the user\n     /// provided, if they provided one, and otherwise search the supertypes of trait bounds"}, {"sha": "fac2119cb44d6357f3417d34f14ecf42dda589b6", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ea4db3521ebc776d68cfa6752e50cc066439f5bd/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea4db3521ebc776d68cfa6752e50cc066439f5bd/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ea4db3521ebc776d68cfa6752e50cc066439f5bd", "patch": "@@ -56,11 +56,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected_sig);\n \n         let expr_def_id = self.tcx.hir.local_def_id(expr.id);\n-        let sig = AstConv::ty_of_closure(self,\n-                                         hir::Unsafety::Normal,\n-                                         decl,\n-                                         Abi::RustCall,\n-                                         expected_sig);\n+        let sig = self.ty_of_closure(decl, expected_sig);\n \n         debug!(\"check_closure: ty_of_closure returns {:?}\", sig);\n \n@@ -274,4 +270,72 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => None,\n         }\n     }\n+\n+    /// Invoked to compute the signature of a closure expression. This\n+    /// combines any user-provided type annotations (e.g., `|x: u32|\n+    /// -> u32 { .. }`) with the expected signature.\n+    ///\n+    /// The arguments here are a bit odd-ball:\n+    ///\n+    /// - `decl`: the HIR declaration of the closure\n+    /// - `expected_sig`: the expected signature (if any). Note that\n+    ///   this is missing a binder: that is, there may be late-bound\n+    ///   regions with depth 1, which are bound then by the closure.\n+    fn ty_of_closure(&self,\n+                     decl: &hir::FnDecl,\n+                     expected_sig: Option<ty::FnSig<'tcx>>)\n+                     -> ty::PolyFnSig<'tcx>\n+    {\n+        let astconv: &AstConv = self;\n+\n+        debug!(\"ty_of_closure(expected_sig={:?})\",\n+               expected_sig);\n+\n+        let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n+            let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n+                // no guarantee that the correct number of expected args\n+                // were supplied\n+                if i < e.inputs().len() {\n+                    Some(e.inputs()[i])\n+                } else {\n+                    None\n+                }\n+            });\n+\n+            let input_ty = astconv.ty_of_arg(a, expected_arg_ty);\n+            debug!(\"ty_of_closure: i={} input_ty={:?} expected_arg_ty={:?}\",\n+                   i, input_ty, expected_arg_ty);\n+\n+            input_ty\n+        });\n+\n+        let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n+\n+        let output_ty = match decl.output {\n+            hir::Return(ref output) => {\n+                if let (&hir::TyInfer, Some(expected_ret_ty)) = (&output.node, expected_ret_ty) {\n+                    astconv.record_ty(output.hir_id, expected_ret_ty, output.span);\n+                    expected_ret_ty\n+                } else {\n+                    astconv.ast_ty_to_ty(&output)\n+                }\n+            }\n+            hir::DefaultReturn(span) => {\n+                if let Some(expected_ret_ty) = expected_ret_ty {\n+                    expected_ret_ty\n+                } else {\n+                    astconv.ty_infer(span)\n+                }\n+            }\n+        };\n+\n+        debug!(\"ty_of_closure: output_ty={:?}\", output_ty);\n+\n+        ty::Binder(self.tcx.mk_fn_sig(\n+            input_tys,\n+            output_ty,\n+            decl.variadic,\n+            hir::Unsafety::Normal,\n+            Abi::RustCall))\n+    }\n }"}]}