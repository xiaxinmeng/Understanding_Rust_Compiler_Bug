{"sha": "ddc7fd983736bef0e610e02f5ef08955ecd562bb", "node_id": "C_kwDOAAsO6NoAKGRkYzdmZDk4MzczNmJlZjBlNjEwZTAyZjVlZjA4OTU1ZWNkNTYyYmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-15T22:49:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-15T22:49:30Z"}, "message": "Auto merge of #100579 - joboet:sync_mutex_everywhere, r=thomcc\n\nstd: use `sync::Mutex` for internal statics\n\nSince `sync::Mutex` is now `const`-constructible, it can be used for internal statics, removing the need for `sys_common::StaticMutex`. This adds some extra allocations on platforms which need to box their mutexes (currently SGX and some UNIX), but these will become unnecessary with the lock improvements tracked in #93740.\n\nI changed the program argument implementation on Hermit, it does not need `Mutex` but can use atomics like some UNIX systems (ping `@mkroening` `@stlankes).`", "tree": {"sha": "3576fb11f3b5836059c8081fb43f5caffe13c8cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3576fb11f3b5836059c8081fb43f5caffe13c8cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddc7fd983736bef0e610e02f5ef08955ecd562bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc7fd983736bef0e610e02f5ef08955ecd562bb", "html_url": "https://github.com/rust-lang/rust/commit/ddc7fd983736bef0e610e02f5ef08955ecd562bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddc7fd983736bef0e610e02f5ef08955ecd562bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8c35ca26b191bb9a9ac669a4b3f4d3d52d97fb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c35ca26b191bb9a9ac669a4b3f4d3d52d97fb1", "html_url": "https://github.com/rust-lang/rust/commit/b8c35ca26b191bb9a9ac669a4b3f4d3d52d97fb1"}, {"sha": "2d2c9e44939d44e03bd6b9922b584ff09fb513e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2c9e44939d44e03bd6b9922b584ff09fb513e6", "html_url": "https://github.com/rust-lang/rust/commit/2d2c9e44939d44e03bd6b9922b584ff09fb513e6"}], "stats": {"total": 170, "additions": 47, "deletions": 123}, "files": [{"sha": "9cb74f951dd3721df31b3e74086bbe7a3f3e9e91", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=ddc7fd983736bef0e610e02f5ef08955ecd562bb", "patch": "@@ -325,8 +325,7 @@ impl Backtrace {\n     // Capture a backtrace which start just before the function addressed by\n     // `ip`\n     fn create(ip: usize) -> Backtrace {\n-        // SAFETY: We don't attempt to lock this reentrantly.\n-        let _lock = unsafe { lock() };\n+        let _lock = lock();\n         let mut frames = Vec::new();\n         let mut actual_start = None;\n         unsafe {\n@@ -469,8 +468,7 @@ impl Capture {\n         // Use the global backtrace lock to synchronize this as it's a\n         // requirement of the `backtrace` crate, and then actually resolve\n         // everything.\n-        // SAFETY: We don't attempt to lock this reentrantly.\n-        let _lock = unsafe { lock() };\n+        let _lock = lock();\n         for frame in self.frames.iter_mut() {\n             let symbols = &mut frame.symbols;\n             let frame = match &frame.frame {"}, {"sha": "afcae6c90ee02ffad8839d69688ac3ee2c859324", "filename": "library/std/src/sys/hermit/args.rs", "status": "modified", "additions": 25, "deletions": 49, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs?ref=ddc7fd983736bef0e610e02f5ef08955ecd562bb", "patch": "@@ -1,20 +1,37 @@\n-use crate::ffi::OsString;\n+use crate::ffi::{c_char, CStr, OsString};\n use crate::fmt;\n+use crate::os::unix::ffi::OsStringExt;\n+use crate::ptr;\n+use crate::sync::atomic::{\n+    AtomicIsize, AtomicPtr,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n use crate::vec;\n \n+static ARGC: AtomicIsize = AtomicIsize::new(0);\n+static ARGV: AtomicPtr<*const u8> = AtomicPtr::new(ptr::null_mut());\n+\n /// One-time global initialization.\n pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-    imp::init(argc, argv)\n-}\n-\n-/// One-time global cleanup.\n-pub unsafe fn cleanup() {\n-    imp::cleanup()\n+    ARGC.store(argc, Relaxed);\n+    // Use release ordering here to broadcast writes by the OS.\n+    ARGV.store(argv as *mut *const u8, Release);\n }\n \n /// Returns the command line arguments\n pub fn args() -> Args {\n-    imp::args()\n+    // Synchronize with the store above.\n+    let argv = ARGV.load(Acquire);\n+    // If argv has not been initialized yet, do not return any arguments.\n+    let argc = if argv.is_null() { 0 } else { ARGC.load(Relaxed) };\n+    let args: Vec<OsString> = (0..argc)\n+        .map(|i| unsafe {\n+            let cstr = CStr::from_ptr(*argv.offset(i) as *const c_char);\n+            OsStringExt::from_vec(cstr.to_bytes().to_vec())\n+        })\n+        .collect();\n+\n+    Args { iter: args.into_iter() }\n }\n \n pub struct Args {\n@@ -51,44 +68,3 @@ impl DoubleEndedIterator for Args {\n         self.iter.next_back()\n     }\n }\n-\n-mod imp {\n-    use super::Args;\n-    use crate::ffi::{CStr, OsString};\n-    use crate::os::unix::ffi::OsStringExt;\n-    use crate::ptr;\n-\n-    use crate::sys_common::mutex::StaticMutex;\n-\n-    static mut ARGC: isize = 0;\n-    static mut ARGV: *const *const u8 = ptr::null();\n-    static LOCK: StaticMutex = StaticMutex::new();\n-\n-    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-        let _guard = LOCK.lock();\n-        ARGC = argc;\n-        ARGV = argv;\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        let _guard = LOCK.lock();\n-        ARGC = 0;\n-        ARGV = ptr::null();\n-    }\n-\n-    pub fn args() -> Args {\n-        Args { iter: clone().into_iter() }\n-    }\n-\n-    fn clone() -> Vec<OsString> {\n-        unsafe {\n-            let _guard = LOCK.lock();\n-            (0..ARGC)\n-                .map(|i| {\n-                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const i8);\n-                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n-                })\n-                .collect()\n-        }\n-    }\n-}"}, {"sha": "e6534df8938eb531e4ba148dda1f12f600b974ce", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=ddc7fd983736bef0e610e02f5ef08955ecd562bb", "patch": "@@ -106,9 +106,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, _sigpipe: u8) {\n \n // SAFETY: must be called only once during runtime cleanup.\n // NOTE: this is not guaranteed to run, for example when the program aborts.\n-pub unsafe fn cleanup() {\n-    args::cleanup();\n-}\n+pub unsafe fn cleanup() {}\n \n #[cfg(not(test))]\n #[no_mangle]"}, {"sha": "9cbb4ef19e9b7a80dff8732c8e318dc2051b1c72", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=ddc7fd983736bef0e610e02f5ef08955ecd562bb", "patch": "@@ -16,6 +16,7 @@ use crate::os::windows::ffi::{OsStrExt, OsStringExt};\n use crate::os::windows::io::{AsHandle, AsRawHandle, BorrowedHandle, FromRawHandle, IntoRawHandle};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n+use crate::sync::Mutex;\n use crate::sys::args::{self, Arg};\n use crate::sys::c;\n use crate::sys::c::NonZeroDWORD;\n@@ -25,7 +26,6 @@ use crate::sys::handle::Handle;\n use crate::sys::path;\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n-use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n use crate::sys_common::IntoInner;\n \n@@ -301,9 +301,9 @@ impl Command {\n         //\n         // For more information, msdn also has an article about this race:\n         // https://support.microsoft.com/kb/315939\n-        static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n+        static CREATE_PROCESS_LOCK: Mutex<()> = Mutex::new(());\n \n-        let _guard = unsafe { CREATE_PROCESS_LOCK.lock() };\n+        let _guard = CREATE_PROCESS_LOCK.lock();\n \n         let mut pipes = StdioPipes { stdin: None, stdout: None, stderr: None };\n         let null = Stdio::Null;"}, {"sha": "8807077cb49271d4fba61ca74420c002cbb1cf10", "filename": "library/std/src/sys_common/backtrace.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs?ref=ddc7fd983736bef0e610e02f5ef08955ecd562bb", "patch": "@@ -7,15 +7,14 @@ use crate::fmt;\n use crate::io;\n use crate::io::prelude::*;\n use crate::path::{self, Path, PathBuf};\n-use crate::sys_common::mutex::StaticMutex;\n+use crate::sync::{Mutex, PoisonError};\n \n /// Max number of frames to print.\n const MAX_NB_FRAMES: usize = 100;\n \n-// SAFETY: Don't attempt to lock this reentrantly.\n-pub unsafe fn lock() -> impl Drop {\n-    static LOCK: StaticMutex = StaticMutex::new();\n-    LOCK.lock()\n+pub fn lock() -> impl Drop {\n+    static LOCK: Mutex<()> = Mutex::new(());\n+    LOCK.lock().unwrap_or_else(PoisonError::into_inner)\n }\n \n /// Prints the current backtrace."}, {"sha": "98046f20f896a9e48c4e12b235520aeeaccc3049", "filename": "library/std/src/sys_common/mutex.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs?ref=ddc7fd983736bef0e610e02f5ef08955ecd562bb", "patch": "@@ -1,49 +1,5 @@\n use crate::sys::locks as imp;\n \n-/// An OS-based mutual exclusion lock, meant for use in static variables.\n-///\n-/// This mutex has a const constructor ([`StaticMutex::new`]), does not\n-/// implement `Drop` to cleanup resources, and causes UB when used reentrantly.\n-///\n-/// This mutex does not implement poisoning.\n-///\n-/// This is a wrapper around `imp::Mutex` that does *not* call `init()` and\n-/// `destroy()`.\n-pub struct StaticMutex(imp::Mutex);\n-\n-unsafe impl Sync for StaticMutex {}\n-\n-impl StaticMutex {\n-    /// Creates a new mutex for use.\n-    #[inline]\n-    pub const fn new() -> Self {\n-        Self(imp::Mutex::new())\n-    }\n-\n-    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n-    /// will be unlocked.\n-    ///\n-    /// It is undefined behaviour to call this function while locked by the\n-    /// same thread.\n-    #[inline]\n-    pub unsafe fn lock(&'static self) -> StaticMutexGuard {\n-        self.0.lock();\n-        StaticMutexGuard(&self.0)\n-    }\n-}\n-\n-#[must_use]\n-pub struct StaticMutexGuard(&'static imp::Mutex);\n-\n-impl Drop for StaticMutexGuard {\n-    #[inline]\n-    fn drop(&mut self) {\n-        unsafe {\n-            self.0.unlock();\n-        }\n-    }\n-}\n-\n /// An OS-based mutual exclusion lock.\n ///\n /// This mutex cleans up its resources in its `Drop` implementation, may safely"}, {"sha": "05023df1bb24b19e1cc1820b6345baa85f1ffdfc", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc7fd983736bef0e610e02f5ef08955ecd562bb/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=ddc7fd983736bef0e610e02f5ef08955ecd562bb", "patch": "@@ -1128,24 +1128,21 @@ impl ThreadId {\n                     }\n                 }\n             } else {\n-                use crate::sys_common::mutex::StaticMutex;\n+                use crate::sync::{Mutex, PoisonError};\n \n-                // It is UB to attempt to acquire this mutex reentrantly!\n-                static GUARD: StaticMutex = StaticMutex::new();\n-                static mut COUNTER: u64 = 0;\n+                static COUNTER: Mutex<u64> = Mutex::new(0);\n \n-                unsafe {\n-                    let guard = GUARD.lock();\n+                let mut counter = COUNTER.lock().unwrap_or_else(PoisonError::into_inner);\n+                let Some(id) = counter.checked_add(1) else {\n+                    // in case the panic handler ends up calling `ThreadId::new()`,\n+                    // avoid reentrant lock acquire.\n+                    drop(counter);\n+                    exhausted();\n+                };\n \n-                    let Some(id) = COUNTER.checked_add(1) else {\n-                        drop(guard); // in case the panic handler ends up calling `ThreadId::new()`, avoid reentrant lock acquire.\n-                        exhausted();\n-                    };\n-\n-                    COUNTER = id;\n-                    drop(guard);\n-                    ThreadId(NonZeroU64::new(id).unwrap())\n-                }\n+                *counter = id;\n+                drop(counter);\n+                ThreadId(NonZeroU64::new(id).unwrap())\n             }\n         }\n     }"}]}