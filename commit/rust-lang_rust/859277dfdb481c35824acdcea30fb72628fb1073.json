{"sha": "859277dfdb481c35824acdcea30fb72628fb1073", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OTI3N2RmZGI0ODFjMzU4MjRhY2RjZWEzMGZiNzI2MjhmYjEwNzM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-27T07:33:03Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-28T13:11:56Z"}, "message": "rustc: implement a lint for publicly visible private types.\n\nThese are types that are in exported type signatures, but are not\nexported themselves, e.g.\n\n    struct Foo { ... }\n\n    pub fn bar() -> Foo { ... }\n\nwill warn about the Foo.\n\nSuch types are not listed in documentation, and cannot be named outside\nthe crate in which they are declared, which is very user-unfriendly.\n\ncc #10573", "tree": {"sha": "e47d1d54549d38cb08c7da3b8c2d7da02ef05993", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e47d1d54549d38cb08c7da3b8c2d7da02ef05993"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/859277dfdb481c35824acdcea30fb72628fb1073", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/859277dfdb481c35824acdcea30fb72628fb1073", "html_url": "https://github.com/rust-lang/rust/commit/859277dfdb481c35824acdcea30fb72628fb1073", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/859277dfdb481c35824acdcea30fb72628fb1073/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31e9c947a3303b4b785f9a7f130b00c625456326", "url": "https://api.github.com/repos/rust-lang/rust/commits/31e9c947a3303b4b785f9a7f130b00c625456326", "html_url": "https://github.com/rust-lang/rust/commit/31e9c947a3303b4b785f9a7f130b00c625456326"}], "stats": {"total": 405, "additions": 400, "deletions": 5}, "files": [{"sha": "693f6fb35f4fce56a570cf7459bb8c10ac209bfe", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/859277dfdb481c35824acdcea30fb72628fb1073/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859277dfdb481c35824acdcea30fb72628fb1073/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=859277dfdb481c35824acdcea30fb72628fb1073", "patch": "@@ -98,6 +98,7 @@ pub enum Lint {\n     UnusedMut,\n     UnnecessaryAllocation,\n     DeadCode,\n+    VisiblePrivateTypes,\n     UnnecessaryTypecast,\n \n     MissingDoc,\n@@ -312,6 +313,12 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         desc: \"detect piece of code that will never be used\",\n         default: warn\n     }),\n+    (\"visible_private_types\",\n+     LintSpec {\n+        lint: VisiblePrivateTypes,\n+        desc: \"detect use of private types in exported type signatures\",\n+        default: warn\n+    }),\n \n     (\"missing_doc\",\n      LintSpec {"}, {"sha": "afe4d00103618e40a0c7f61a23bd7582ce84afa9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/859277dfdb481c35824acdcea30fb72628fb1073/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859277dfdb481c35824acdcea30fb72628fb1073/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=859277dfdb481c35824acdcea30fb72628fb1073", "patch": "@@ -16,6 +16,7 @@ use std::mem::replace;\n use collections::{HashSet, HashMap};\n \n use metadata::csearch;\n+use middle::lint;\n use middle::resolve;\n use middle::ty;\n use middle::typeck::{MethodMap, MethodOrigin, MethodParam};\n@@ -1169,6 +1170,251 @@ impl SanePrivacyVisitor {\n     }\n }\n \n+struct VisiblePrivateTypesVisitor<'a> {\n+    tcx: ty::ctxt,\n+    exported_items: &'a ExportedItems,\n+    public_items: &'a PublicItems,\n+}\n+\n+struct CheckTypeForPrivatenessVisitor<'a, 'b> {\n+    inner: &'b VisiblePrivateTypesVisitor<'a>,\n+    /// whether the type refers to private types.\n+    contains_private: bool,\n+    /// whether we've recurred at all (i.e. if we're pointing at the\n+    /// first type on which visit_ty was called).\n+    at_outer_type: bool,\n+    // whether that first type is a public path.\n+    outer_type_is_public_path: bool,\n+}\n+\n+impl<'a> VisiblePrivateTypesVisitor<'a> {\n+    fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n+        let did = match self.tcx.def_map.borrow().get().find_copy(&path_id) {\n+            // `int` etc. (None doesn't seem to occur.)\n+            None | Some(ast::DefPrimTy(..)) => return false,\n+            Some(def) => def_id_of_def(def)\n+        };\n+        // A path can only be private if:\n+        // it's in this crate...\n+        is_local(did) &&\n+            // ... it's not exported (obviously) ...\n+            !self.exported_items.contains(&did.node) &&\n+            // .. and it corresponds to a type in the AST (this returns None for\n+            // type parameters)\n+            self.tcx.map.find(did.node).is_some()\n+    }\n+\n+    fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n+        // FIXME: this would preferably be using `exported_items`, but all\n+        // traits are exported currently (see `EmbargoVisitor.exported_trait`)\n+        self.public_items.contains(&trait_id)\n+    }\n+}\n+\n+impl<'a, 'b> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b> {\n+    fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n+        match ty.node {\n+            ast::TyPath(_, _, path_id) => {\n+                if self.inner.path_is_private_type(path_id) {\n+                    self.contains_private = true;\n+                    // found what we're looking for so let's stop\n+                    // working.\n+                    return\n+                } else if self.at_outer_type {\n+                    self.outer_type_is_public_path = true;\n+                }\n+            }\n+            _ => {}\n+        }\n+        self.at_outer_type = false;\n+        visit::walk_ty(self, ty, ())\n+    }\n+\n+    // don't want to recurse into [, .. expr]\n+    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n+}\n+\n+impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+        match item.node {\n+            // contents of a private mod can be reexported, so we need\n+            // to check internals.\n+            ast::ItemMod(_) => {}\n+\n+            // An `extern {}` doesn't introduce a new privacy\n+            // namespace (the contents have their own privacies).\n+            ast::ItemForeignMod(_) => {}\n+\n+            ast::ItemTrait(..) if !self.trait_is_public(item.id) => return,\n+\n+            // impls need some special handling to try to offer useful\n+            // error messages without (too many) false positives\n+            // (i.e. we could just return here to not check them at\n+            // all, or some worse estimation of whether an impl is\n+            // publically visible.\n+            ast::ItemImpl(ref g, ref trait_ref, self_, ref methods) => {\n+                // `impl [... for] Private` is never visible.\n+                let self_contains_private;\n+                // impl [... for] Public<...>, but not `impl [... for]\n+                // ~[Public]` or `(Public,)` etc.\n+                let self_is_public_path;\n+\n+                // check the properties of the Self type:\n+                {\n+                    let mut visitor = CheckTypeForPrivatenessVisitor {\n+                        inner: self,\n+                        contains_private: false,\n+                        at_outer_type: true,\n+                        outer_type_is_public_path: false,\n+                    };\n+                    visitor.visit_ty(self_, ());\n+                    self_contains_private = visitor.contains_private;\n+                    self_is_public_path = visitor.outer_type_is_public_path;\n+                }\n+\n+                // miscellanous info about the impl\n+\n+                // `true` iff this is `impl Private for ...`.\n+                let not_private_trait =\n+                    trait_ref.as_ref().map_or(true, // no trait counts as public trait\n+                                              |tr| {\n+                        let did = ty::trait_ref_to_def_id(self.tcx, tr);\n+\n+                        !is_local(did) || self.trait_is_public(did.node)\n+                    });\n+\n+                // `true` iff this is a trait impl or at least one method is public.\n+                //\n+                // `impl Public { $( fn ...() {} )* }` is not visible.\n+                //\n+                // This is required over just using the methods' privacy\n+                // directly because we might have `impl<T: Foo<Private>> ...`,\n+                // and we shouldn't warn about the generics if all the methods\n+                // are private (because `T` won't be visible externally).\n+                let trait_or_some_public_method =\n+                    trait_ref.is_some() ||\n+                    methods.iter().any(|m| self.exported_items.contains(&m.id));\n+\n+                if !self_contains_private &&\n+                        not_private_trait &&\n+                        trait_or_some_public_method {\n+\n+                    visit::walk_generics(self, g, ());\n+\n+                    match *trait_ref {\n+                        None => {\n+                            for method in methods.iter() {\n+                                visit::walk_method_helper(self, *method, ())\n+                            }\n+                        }\n+                        Some(ref tr) => {\n+                            // Any private types in a trait impl fall into two\n+                            // categories.\n+                            // 1. mentioned in the trait definition\n+                            // 2. mentioned in the type params/generics\n+                            //\n+                            // Those in 1. can only occur if the trait is in\n+                            // this crate and will've been warned about on the\n+                            // trait definition (there's no need to warn twice\n+                            // so we don't check the methods).\n+                            //\n+                            // Those in 2. are warned via walk_generics and this\n+                            // call here.\n+                            visit::walk_trait_ref_helper(self, tr, ())\n+                        }\n+                    }\n+                } else if trait_ref.is_none() && self_is_public_path {\n+                    // impl Public<Private> { ... }. Any public static\n+                    // methods will be visible as `Public::foo`.\n+                    let mut found_pub_static = false;\n+                    for method in methods.iter() {\n+                        if method.explicit_self.node == ast::SelfStatic &&\n+                            self.exported_items.contains(&method.id) {\n+                            found_pub_static = true;\n+                            visit::walk_method_helper(self, *method, ());\n+                        }\n+                    }\n+                    if found_pub_static {\n+                        visit::walk_generics(self, g, ())\n+                    }\n+                }\n+                return\n+            }\n+\n+            // `type ... = ...;` can contain private types, because\n+            // we're introducing a new name.\n+            ast::ItemTy(..) => return,\n+\n+            // not at all public, so we don't care\n+            _ if !self.exported_items.contains(&item.id) => return,\n+\n+            _ => {}\n+        }\n+\n+        // we've carefully constructed it so that if we're here, then\n+        // any `visit_ty`'s will be called on things that are in\n+        // public signatures, i.e. things that we're interested in for\n+        // this visitor.\n+        visit::walk_item(self, item, ());\n+    }\n+\n+    fn visit_foreign_item(&mut self, item: &ast::ForeignItem, _: ()) {\n+        if self.exported_items.contains(&item.id) {\n+            visit::walk_foreign_item(self, item, ())\n+        }\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: &visit::FnKind, fd: &ast::FnDecl, b: &ast::Block, s: Span, id: ast::NodeId,\n+                _: ()) {\n+        // needs special handling for methods.\n+        if self.exported_items.contains(&id) {\n+            visit::walk_fn(self, fk, fd, b, s, id, ());\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+        match t.node {\n+            ast::TyPath(ref p, _, path_id) => {\n+                if self.path_is_private_type(path_id) {\n+                    self.tcx.sess.add_lint(lint::VisiblePrivateTypes,\n+                                           path_id, p.span,\n+                                           ~\"private type in exported type signature\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_ty(self, t, ())\n+    }\n+\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n+        if self.exported_items.contains(&v.node.id) {\n+            visit::walk_variant(self, v, g, ());\n+        }\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n+        match s.node.kind {\n+            // the only way to get here is by being inside a public\n+            // struct/enum variant, so the only way to have a private\n+            // field is with an explicit `priv`.\n+            ast::NamedField(_, ast::Private) => {}\n+\n+            _ => visit::walk_struct_field(self, s, ())\n+        }\n+    }\n+\n+\n+    // we don't need to introspect into these at all: an\n+    // expression/block context can't possibly contain exported\n+    // things, and neither do view_items. (Making them no-ops stops us\n+    // from traversing the whole AST without having to be super\n+    // careful about our `walk_...` calls above.)\n+    fn visit_view_item(&mut self, _: &ast::ViewItem, _: ()) {}\n+    fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n+    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n+}\n+\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: &MethodMap,\n                    exp_map2: &resolve::ExportMap2,\n@@ -1225,5 +1471,14 @@ pub fn check_crate(tcx: ty::ctxt,\n     }\n \n     let EmbargoVisitor { exported_items, public_items, .. } = visitor;\n+\n+    {\n+        let mut visitor = VisiblePrivateTypesVisitor {\n+            tcx: tcx,\n+            exported_items: &exported_items,\n+            public_items: &public_items\n+        };\n+        visit::walk_crate(&mut visitor, krate, ());\n+    }\n     return (exported_items, public_items);\n }"}, {"sha": "39989977d69faa5e213ced72beeffd4666f24566", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/859277dfdb481c35824acdcea30fb72628fb1073/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859277dfdb481c35824acdcea30fb72628fb1073/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=859277dfdb481c35824acdcea30fb72628fb1073", "patch": "@@ -193,9 +193,11 @@ fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     }\n }\n \n-fn walk_trait_ref<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                           trait_ref: &TraitRef,\n-                                           env: E) {\n+/// Like with walk_method_helper this doesn't correspond to a method\n+/// in Visitor, and so it gets a _helper suffix.\n+pub fn walk_trait_ref_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                      trait_ref: &TraitRef,\n+                                                      env: E) {\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id, env)\n }\n \n@@ -239,7 +241,8 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                  ref methods) => {\n             visitor.visit_generics(type_parameters, env.clone());\n             match *trait_reference {\n-                Some(ref trait_reference) => walk_trait_ref(visitor, trait_reference, env.clone()),\n+                Some(ref trait_reference) => walk_trait_ref_helper(visitor,\n+                                                                   trait_reference, env.clone()),\n                 None => ()\n             }\n             visitor.visit_ty(typ, env.clone());\n@@ -459,7 +462,7 @@ pub fn walk_ty_param_bounds<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     for bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref typ) => {\n-                walk_trait_ref(visitor, typ, env.clone())\n+                walk_trait_ref_helper(visitor, typ, env.clone())\n             }\n             RegionTyParamBound => {}\n         }"}, {"sha": "629a203fcbb6c8d30b7323c73ce292f945036fdc", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/859277dfdb481c35824acdcea30fb72628fb1073/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859277dfdb481c35824acdcea30fb72628fb1073/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=859277dfdb481c35824acdcea30fb72628fb1073", "patch": "@@ -11,6 +11,7 @@\n #[no_std];\n #[allow(unused_variable)];\n #[allow(non_camel_case_types)];\n+#[allow(visible_private_types)];\n #[deny(dead_code)];\n \n #[crate_type=\"lib\"];"}, {"sha": "6d77f8b324c524a6f4d27ba51afb8961f894d382", "filename": "src/test/compile-fail/lint-visible-private-types.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/859277dfdb481c35824acdcea30fb72628fb1073/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859277dfdb481c35824acdcea30fb72628fb1073/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs?ref=859277dfdb481c35824acdcea30fb72628fb1073", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(struct_variant)];\n+#[deny(visible_private_types)];\n+#[allow(dead_code)];\n+#[crate_type=\"lib\"];\n+\n+struct Private<T>;\n+pub struct Public<T>;\n+\n+impl Private<Public<int>> {\n+    pub fn a(&self) -> Private<int> { fail!() }\n+    fn b(&self) -> Private<int> { fail!() }\n+\n+    pub fn c() -> Private<int> { fail!() }\n+    fn d() -> Private<int> { fail!() }\n+}\n+impl Private<int> {\n+    pub fn e(&self) -> Private<int> { fail!() }\n+    fn f(&self) -> Private<int> { fail!() }\n+}\n+\n+impl Public<Private<int>> {\n+    pub fn a(&self) -> Private<int> { fail!() }\n+    fn b(&self) -> Private<int> { fail!() }\n+\n+    pub fn c() -> Private<int> { fail!() } //~ ERROR private type in exported type signature\n+    fn d() -> Private<int> { fail!() }\n+}\n+impl Public<int> {\n+    pub fn e(&self) -> Private<int> { fail!() } //~ ERROR private type in exported type signature\n+    fn f(&self) -> Private<int> { fail!() }\n+}\n+\n+pub fn x(_: Private<int>) {} //~ ERROR private type in exported type signature\n+\n+fn y(_: Private<int>) {}\n+\n+\n+pub struct Foo {\n+    x: Private<int>, //~ ERROR private type in exported type signature\n+    priv y: Private<int>\n+}\n+\n+struct Bar {\n+    x: Private<int>,\n+}\n+\n+pub enum Baz {\n+    Baz1(Private<int>), //~ ERROR private type in exported type signature\n+    Baz2 {\n+        x: Private<int>, //~ ERROR private type in exported type signature\n+        priv y: Private<int>\n+    },\n+\n+    priv Baz3(Private<int>),\n+    priv Baz4 {\n+        x: Private<int>,\n+    }\n+}\n+\n+enum Qux {\n+    Qux1(Private<int>),\n+    Qux2 {\n+        x: Private<int>,\n+    }\n+}\n+\n+pub trait PubTrait {\n+    fn foo(&self) -> Private<int> { fail!( )} //~ ERROR private type in exported type signature\n+    fn bar(&self) -> Private<int>; //~ ERROR private type in exported type signature\n+    fn baz() -> Private<int>; //~ ERROR private type in exported type signature\n+}\n+\n+impl PubTrait for Public<int> {\n+    fn bar(&self) -> Private<int> { fail!() }\n+    fn baz() -> Private<int> { fail!() }\n+}\n+impl PubTrait for Public<Private<int>> {\n+    fn bar(&self) -> Private<int> { fail!() }\n+    fn baz() -> Private<int> { fail!() }\n+}\n+\n+impl PubTrait for Private<int> {\n+    fn bar(&self) -> Private<int> { fail!() }\n+    fn baz() -> Private<int> { fail!() }\n+}\n+impl PubTrait for (Private<int>,) {\n+    fn bar(&self) -> Private<int> { fail!() }\n+    fn baz() -> Private<int> { fail!() }\n+}\n+\n+\n+trait PrivTrait {\n+    fn foo(&self) -> Private<int> { fail!( )}\n+    fn bar(&self) -> Private<int>;\n+}\n+impl PrivTrait for Private<int> {\n+    fn bar(&self) -> Private<int> { fail!() }\n+}\n+impl PrivTrait for (Private<int>,) {\n+    fn bar(&self) -> Private<int> { fail!() }\n+}\n+\n+pub trait ParamTrait<T> {\n+    fn foo() -> T;\n+}\n+\n+impl ParamTrait<Private<int>> //~ ERROR private type in exported type signature\n+   for Public<int> {\n+    fn foo() -> Private<int> { fail!() }\n+}\n+\n+impl ParamTrait<Private<int>> for Private<int> {\n+    fn foo() -> Private<int> { fail!( )}\n+}\n+\n+impl<T: ParamTrait<Private<int>>>  //~ ERROR private type in exported type signature\n+     ParamTrait<T> for Public<i8> {\n+    fn foo() -> T { fail!() }\n+}"}]}