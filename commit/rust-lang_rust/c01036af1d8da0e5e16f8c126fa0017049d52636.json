{"sha": "c01036af1d8da0e5e16f8c126fa0017049d52636", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMTAzNmFmMWQ4ZGEwZTVlMTZmOGMxMjZmYTAwMTcwNDlkNTI2MzY=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-27T06:13:51Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-09T07:53:58Z"}, "message": "Implement the precise analysis pass for lint `disjoint_capture_drop_reorder`", "tree": {"sha": "d50e1c2a59664dbdf5d7f4a2f77a5ec4ac5eb724", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d50e1c2a59664dbdf5d7f4a2f77a5ec4ac5eb724"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c01036af1d8da0e5e16f8c126fa0017049d52636", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c01036af1d8da0e5e16f8c126fa0017049d52636", "html_url": "https://github.com/rust-lang/rust/commit/c01036af1d8da0e5e16f8c126fa0017049d52636", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c01036af1d8da0e5e16f8c126fa0017049d52636/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36931ce3d90e1927e8589d973cc8d18103ede460", "url": "https://api.github.com/repos/rust-lang/rust/commits/36931ce3d90e1927e8589d973cc8d18103ede460", "html_url": "https://github.com/rust-lang/rust/commit/36931ce3d90e1927e8589d973cc8d18103ede460"}], "stats": {"total": 322, "additions": 317, "deletions": 5}, "files": [{"sha": "4d21629cd69fcb2f2df176eb915d5cb0c0e9c42b", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 317, "deletions": 5, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/c01036af1d8da0e5e16f8c126fa0017049d52636/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01036af1d8da0e5e16f8c126fa0017049d52636/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=c01036af1d8da0e5e16f8c126fa0017049d52636", "patch": "@@ -40,13 +40,16 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n-use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n+use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection, ProjectionKind};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n use rustc_session::lint;\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n \n+use rustc_index::vec::Idx;\n+use rustc_target::abi::VariantIdx;\n+\n /// Describe the relationship between the paths of two places\n /// eg:\n /// - `foo` is ancestor of `foo.bar.baz`\n@@ -537,18 +540,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         body: &'tcx hir::Body<'tcx>,\n     ) {\n-        let need_migrations = self.compute_2229_migrations_first_pass(\n+        let need_migrations_first_pass = self.compute_2229_migrations_first_pass(\n             closure_def_id,\n             span,\n             capture_clause,\n             body,\n             self.typeck_results.borrow().closure_min_captures.get(&closure_def_id),\n         );\n \n-        if !need_migrations.is_empty() {\n-            let need_migrations_hir_id = need_migrations.iter().map(|m| m.0).collect::<Vec<_>>();\n+        let need_migrations = self.compute_2229_migrations_precise_pass(\n+            closure_def_id,\n+            span,\n+            self.typeck_results.borrow().closure_min_captures.get(&closure_def_id),\n+            &need_migrations_first_pass,\n+        );\n \n-            let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations_hir_id);\n+        if !need_migrations.is_empty() {\n+            let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations);\n \n             let local_def_id = closure_def_id.expect_local();\n             let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n@@ -642,6 +650,310 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         need_migrations\n     }\n \n+    fn compute_2229_migrations_precise_pass(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_span: Span,\n+        min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n+        need_migrations: &[(hir::HirId, Ty<'tcx>)],\n+    ) -> Vec<hir::HirId> {\n+        // Need migrations -- second pass\n+        let mut need_migrations_2 = Vec::new();\n+\n+        for (hir_id, ty) in need_migrations {\n+            let projections_list = min_captures\n+                .and_then(|m| m.get(hir_id))\n+                .into_iter()\n+                .flatten()\n+                .filter_map(|captured_place| match captured_place.info.capture_kind {\n+                    // Only care about captures that are moved into the closure\n+                    ty::UpvarCapture::ByValue(..) => {\n+                        Some(captured_place.place.projections.as_slice())\n+                    }\n+                    ty::UpvarCapture::ByRef(..) => None,\n+                })\n+                .collect();\n+\n+            if self.has_significant_drop_outside_of_captures(\n+                closure_def_id,\n+                closure_span,\n+                ty,\n+                projections_list,\n+            ) {\n+                need_migrations_2.push(*hir_id);\n+            }\n+        }\n+\n+        need_migrations_2\n+    }\n+\n+    /// This is a helper function to `compute_2229_migrations_precise_pass`. Provided the type\n+    /// of a root variable and a list of captured paths starting at this root variable (expressed\n+    /// using list of `Projection` slices), it returns true if there is a path that is not\n+    /// captured starting at this root variable that implements Drop.\n+    ///\n+    /// FIXME(project-rfc-2229#35): This should return true only for significant drops.\n+    ///                             A drop is significant if it's implemented by the user or does\n+    ///                             anything that will have any observable behavior (other than\n+    ///                             freeing up memory).\n+    ///\n+    /// The way this function works is at a given call it looks at type `base_path_ty` of some base\n+    /// path say P and then vector of projection slices which represent the different captures\n+    /// starting off of P.\n+    ///\n+    /// This will make more sense with an example:\n+    ///\n+    /// ```rust\n+    /// #![feature(capture_disjoint_fields)]\n+    ///\n+    /// struct FancyInteger(i32); // This implements Drop\n+    ///\n+    /// struct Point { x: FancyInteger, y: FancyInteger }\n+    /// struct Color;\n+    ///\n+    /// struct Wrapper { p: Point, c: Color }\n+    ///\n+    /// fn f(w: Wrapper) {\n+    ///   let c = || {\n+    ///       // Closure captures w.p.x and w.c by move.\n+    ///   };\n+    ///\n+    ///   c();\n+    /// }\n+    /// ```\n+    ///\n+    /// If `capture_disjoint_fields` wasn't enabled the closure would've moved `w` instead of the\n+    /// precise paths. If we look closely `w.p.y` isn't captured which implements Drop and\n+    /// therefore Drop ordering would change and we want this function to return true.\n+    ///\n+    /// Call stack to figure out if we need to migrate for `w` would look as follows:\n+    ///\n+    /// Our initial base path is just `w`, and the paths captured from it are `w[p, x]` and\n+    /// `w[c]`.\n+    /// Notation:\n+    /// - Ty(place): Type of place\n+    /// - `(a, b)`: Represents the function parameters `base_path_ty` and `captured_projs`\n+    /// respectively.\n+    /// ```\n+    ///                  (Ty(w), [ &[p, x], &[c] ])\n+    ///                                 |\n+    ///                    ----------------------------\n+    ///                    |                          |\n+    ///                    v                          v\n+    ///        (Ty(w.p), [ &[x] ])          (Ty(w.c), [ &[] ]) // I(1)\n+    ///                    |                          |\n+    ///                    v                          v\n+    ///        (Ty(w.p), [ &[x] ])                 false\n+    ///                    |\n+    ///                    |\n+    ///          -------------------------------\n+    ///          |                             |\n+    ///          v                             v\n+    ///     (Ty((w.p).x), [ &[] ])     (Ty((w.p).y), []) // IMP 2\n+    ///          |                             |\n+    ///          v                             v\n+    ///        false                     NeedsDrop(Ty(w.p.y))\n+    ///                                        |\n+    ///                                        v\n+    ///                                      true\n+    /// ```\n+    ///\n+    /// IMP 1 `(Ty(w.c), [ &[] ])`: Notice the single empty slice inside `captured_projs`.\n+    ///                             This implies that the `w.c` is completely captured by the closure.\n+    ///                             Since drop for this path will be called when the closure is\n+    ///                             dropped we don't need to migrate for it.\n+    ///\n+    /// IMP 2 `(Ty((w.p).y), [])`: Notice that `captured_projs` is empty. This implies that this\n+    ///                             path wasn't captured by the closure. Also note that even\n+    ///                             though we didn't capture this path, the function visits it,\n+    ///                             which is kind of the point of this function. We then return\n+    ///                             if the type of `w.p.y` implements Drop, which in this case is\n+    ///                             true.\n+    ///\n+    /// Consider another example:\n+    ///\n+    /// ```rust\n+    /// struct X;\n+    /// impl Drop for X {}\n+    ///\n+    /// struct Y(X);\n+    /// impl Drop for Y {}\n+    ///\n+    /// fn foo() {\n+    ///     let y = Y(X);\n+    ///     let c = || move(y.0);\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that `y.0` is captured by the closure. When this function is called for `y`, it will\n+    /// return true, because even though all paths starting at `y` are captured, `y` itself\n+    /// implements Drop which will be affected since `y` isn't completely captured.\n+    fn has_significant_drop_outside_of_captures(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_span: Span,\n+        base_path_ty: Ty<'tcx>,\n+        captured_projs: Vec<&[Projection<'tcx>]>,\n+    ) -> bool {\n+        let needs_drop = |ty: Ty<'tcx>| {\n+            ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local()))\n+        };\n+\n+        let is_drop_defined_for_ty = |ty: Ty<'tcx>| {\n+            let drop_trait = self.tcx.require_lang_item(hir::LangItem::Drop, Some(closure_span));\n+            let ty_params = self.tcx.mk_substs_trait(base_path_ty, &[]);\n+            self.tcx.type_implements_trait((\n+                drop_trait,\n+                ty,\n+                ty_params,\n+                self.tcx.param_env(closure_def_id.expect_local()),\n+            ))\n+        };\n+\n+        let is_drop_defined_for_ty = is_drop_defined_for_ty(base_path_ty);\n+\n+        // If there is a case where no projection is applied on top of current place\n+        // then there must be exactly one capture corresponding to such a case. Note that this\n+        // represents the case of the path being completely captured by the variable.\n+        //\n+        // eg. If `a.b` is captured and we are processing `a.b`, then we can't have the closure also\n+        //     capture `a.b.c`, because that voilates min capture.\n+        let is_completely_captured = captured_projs.iter().any(|projs| projs.is_empty());\n+\n+        assert!(!is_completely_captured || (captured_projs.len() == 1));\n+\n+        if is_drop_defined_for_ty {\n+            // If drop is implemented for this type then we need it to be fully captured, or\n+            // it will require migration.\n+            return !is_completely_captured;\n+        }\n+\n+        if is_completely_captured {\n+            // The place is captured entirely, so doesn't matter if needs dtor, it will be drop\n+            // when the closure is dropped.\n+            return false;\n+        }\n+\n+        match base_path_ty.kind() {\n+            _ if captured_projs.is_empty() => needs_drop(base_path_ty),\n+\n+            // Observations:\n+            // - `captured_projs` is not empty. Therefore we can call\n+            //   `captured_projs.first().unwrap()` safely.\n+            // - All entries in `captured_projs` have atleast one projection.\n+            //   Therefore we can call `captured_projs.first().unwrap().first().unwrap()` safely.\n+            ty::Adt(def, _) if def.is_box() => {\n+                // We must deref to access paths on top of a Box.\n+                assert!(\n+                    captured_projs\n+                        .iter()\n+                        .all(|projs| matches!(projs.first().unwrap().kind, ProjectionKind::Deref))\n+                );\n+\n+                let next_ty = captured_projs.first().unwrap().first().unwrap().ty;\n+                let captured_projs = captured_projs.iter().map(|projs| &projs[1..]).collect();\n+                self.has_significant_drop_outside_of_captures(\n+                    closure_def_id,\n+                    closure_span,\n+                    next_ty,\n+                    captured_projs,\n+                )\n+            }\n+\n+            ty::Adt(def, substs) => {\n+                // Multi-varaint enums are captured in entirety,\n+                // which would've been handled in the case of single empty slice in `captured_projs`.\n+                assert_eq!(def.variants.len(), 1);\n+\n+                // Only Field projections can be applied to a non-box Adt.\n+                assert!(\n+                    captured_projs.iter().all(|projs| matches!(\n+                        projs.first().unwrap().kind,\n+                        ProjectionKind::Field(..)\n+                    ))\n+                );\n+                def.variants.get(VariantIdx::new(0)).unwrap().fields.iter().enumerate().any(\n+                    |(i, field)| {\n+                        let paths_using_field = captured_projs\n+                            .iter()\n+                            .filter_map(|projs| {\n+                                if let ProjectionKind::Field(field_idx, _) =\n+                                    projs.first().unwrap().kind\n+                                {\n+                                    if (field_idx as usize) == i { Some(&projs[1..]) } else { None }\n+                                } else {\n+                                    unreachable!();\n+                                }\n+                            })\n+                            .collect();\n+\n+                        let after_field_ty = field.ty(self.tcx, substs);\n+                        self.has_significant_drop_outside_of_captures(\n+                            closure_def_id,\n+                            closure_span,\n+                            after_field_ty,\n+                            paths_using_field,\n+                        )\n+                    },\n+                )\n+            }\n+\n+            ty::Tuple(..) => {\n+                // Only Field projections can be applied to a tuple.\n+                assert!(\n+                    captured_projs.iter().all(|projs| matches!(\n+                        projs.first().unwrap().kind,\n+                        ProjectionKind::Field(..)\n+                    ))\n+                );\n+\n+                base_path_ty.tuple_fields().enumerate().any(|(i, element_ty)| {\n+                    let paths_using_field = captured_projs\n+                        .iter()\n+                        .filter_map(|projs| {\n+                            if let ProjectionKind::Field(field_idx, _) = projs.first().unwrap().kind\n+                            {\n+                                if (field_idx as usize) == i { Some(&projs[1..]) } else { None }\n+                            } else {\n+                                unreachable!();\n+                            }\n+                        })\n+                        .collect();\n+\n+                    self.has_significant_drop_outside_of_captures(\n+                        closure_def_id,\n+                        closure_span,\n+                        element_ty,\n+                        paths_using_field,\n+                    )\n+                })\n+            }\n+\n+            ty::Ref(_, deref_ty, _) => {\n+                // Only Derefs can be applied to a Ref\n+                assert!(\n+                    captured_projs\n+                        .iter()\n+                        .all(|projs| matches!(projs.first().unwrap().kind, ProjectionKind::Deref))\n+                );\n+\n+                let captured_projs = captured_projs.iter().map(|projs| &projs[1..]).collect();\n+                self.has_significant_drop_outside_of_captures(\n+                    closure_def_id,\n+                    closure_span,\n+                    deref_ty,\n+                    captured_projs,\n+                )\n+            }\n+\n+            // Unsafe Ptrs are captured in their entirety, which would've have been handled in\n+            // the case of single empty slice in `captured_projs`.\n+            ty::RawPtr(..) => unreachable!(),\n+\n+            _ => unreachable!(),\n+        }\n+    }\n+\n     fn init_capture_kind(\n         &self,\n         capture_clause: hir::CaptureBy,"}]}