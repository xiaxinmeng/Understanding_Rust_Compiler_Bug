{"sha": "3d6f276ca71060a189fdbcb61b93750c2cb8c5a7", "node_id": "C_kwDOAAsO6NoAKDNkNmYyNzZjYTcxMDYwYTE4OWZkYmNiNjFiOTM3NTBjMmNiOGM1YTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-25T04:51:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-25T04:51:12Z"}, "message": "Rollup merge of #93175 - spastorino:negative-traits-coherence-new, r=nikomatsakis\n\nImplement stable overlap check considering negative traits\n\nThis PR implement the new disjointness rules for overlap check described in https://rust-lang.github.io/negative-impls-initiative/explainer/coherence-check.html#new-disjointness-rules\n\nr? ``@nikomatsakis``", "tree": {"sha": "7b24930eb1022d56d387f25502e21cc2e7f09055", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b24930eb1022d56d387f25502e21cc2e7f09055"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh74HBCRBK7hj4Ov3rIwAAnQIIAEdmIG4TL/hVYCmLoZ0KX4Rw\nLkpsZXbLY7EHbDXk5+nbPxhO0vZb5q2t8YnKkK5P+1oAUagR4y8l9NAag8vXy/hO\nZ2MlmQr3NP+Vop4vR5eiQ8aoDwI7JDB4VLvXqW4rNz3Rwc8BCAnIUvaK7zsFFA05\nYOHW1er/JpSXl7jii9JNAPsO6ZgN7eSqeqH0ciDdiWskj3NH3CH0ZOhrTKAtW2hB\nguNfBewzC+NhcuQQpb/X7sUWWYNHaTCXOFRbqoS4TmxqpdRVeZmZcxfnLtG2ZwGN\n+ImLo+W0MtPtsJmIUpqJF/yTDhQvdRr7nnTBp31CAw9Z7CO4VL7oWPyL/gAomYk=\n=TNGZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 7b24930eb1022d56d387f25502e21cc2e7f09055\nparent 677126cac0d59c44d7448cc1e41b1e855380c6b3\nparent 8189bac9636930155768150886e28e221523d6ac\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643086272 +0100\ncommitter GitHub <noreply@github.com> 1643086272 +0100\n\nRollup merge of #93175 - spastorino:negative-traits-coherence-new, r=nikomatsakis\n\nImplement stable overlap check considering negative traits\n\nThis PR implement the new disjointness rules for overlap check described in https://rust-lang.github.io/negative-impls-initiative/explainer/coherence-check.html#new-disjointness-rules\n\nr? ``@nikomatsakis``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7", "html_url": "https://github.com/rust-lang/rust/commit/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "677126cac0d59c44d7448cc1e41b1e855380c6b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/677126cac0d59c44d7448cc1e41b1e855380c6b3", "html_url": "https://github.com/rust-lang/rust/commit/677126cac0d59c44d7448cc1e41b1e855380c6b3"}, {"sha": "8189bac9636930155768150886e28e221523d6ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/8189bac9636930155768150886e28e221523d6ac", "html_url": "https://github.com/rust-lang/rust/commit/8189bac9636930155768150886e28e221523d6ac"}], "stats": {"total": 290, "additions": 229, "deletions": 61}, "files": [{"sha": "0e643ff59983497d18f48db28dc9d12ca0cdc72d", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=3d6f276ca71060a189fdbcb61b93750c2cb8c5a7", "patch": "@@ -697,6 +697,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_strict_coherence, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_with_negative_coherence, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_variance, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\"), WarnFollowing),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word), WarnFollowing),"}, {"sha": "52d52752b158326e5501701076e11e54fde27ab0", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3d6f276ca71060a189fdbcb61b93750c2cb8c5a7", "patch": "@@ -1204,6 +1204,7 @@ symbols! {\n         rustc_trivial_field_reads,\n         rustc_unsafe_specialization_marker,\n         rustc_variance,\n+        rustc_with_negative_coherence,\n         rustdoc,\n         rustdoc_internals,\n         rustfmt,"}, {"sha": "80ed9023d9694ca0a01847bcf5e6a236c4249c2e", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 201, "deletions": 61, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=3d6f276ca71060a189fdbcb61b93750c2cb8c5a7", "patch": "@@ -7,9 +7,11 @@\n use crate::infer::{CombinedSnapshot, InferOk, TyCtxtInferExt};\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::select::IntercrateAmbiguityCause;\n+use crate::traits::util::impl_trait_ref_and_oblig;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{\n-    self, Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext,\n+    self, FulfillmentContext, Normalized, Obligation, ObligationCause, PredicateObligation,\n+    PredicateObligations, SelectionContext,\n };\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n@@ -135,45 +137,83 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n     header\n }\n \n+/// What kind of overlap check are we doing -- this exists just for testing and feature-gating\n+/// purposes.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+enum OverlapMode {\n+    /// The 1.0 rules (either types fail to unify, or where clauses are not implemented for crate-local types)\n+    Stable,\n+    /// Feature-gated test: Stable, *or* there is an explicit negative impl that rules out one of the where-clauses.\n+    WithNegative,\n+    /// Just check for negative impls, not for \"where clause not implemented\": used for testing.\n+    Strict,\n+}\n+\n+impl OverlapMode {\n+    fn use_negative_impl(&self) -> bool {\n+        *self == OverlapMode::Strict || *self == OverlapMode::WithNegative\n+    }\n+\n+    fn use_implicit_negative(&self) -> bool {\n+        *self == OverlapMode::Stable || *self == OverlapMode::WithNegative\n+    }\n+}\n+\n+fn overlap_mode<'tcx>(tcx: TyCtxt<'tcx>, impl1_def_id: DefId, impl2_def_id: DefId) -> OverlapMode {\n+    if tcx.has_attr(impl1_def_id, sym::rustc_strict_coherence)\n+        != tcx.has_attr(impl2_def_id, sym::rustc_strict_coherence)\n+    {\n+        bug!(\"Use strict coherence on both impls\",);\n+    }\n+\n+    if tcx.has_attr(impl1_def_id, sym::rustc_with_negative_coherence)\n+        != tcx.has_attr(impl2_def_id, sym::rustc_with_negative_coherence)\n+    {\n+        bug!(\"Use with negative coherence on both impls\",);\n+    }\n+\n+    if tcx.has_attr(impl1_def_id, sym::rustc_strict_coherence) {\n+        OverlapMode::Strict\n+    } else if tcx.has_attr(impl1_def_id, sym::rustc_with_negative_coherence) {\n+        OverlapMode::WithNegative\n+    } else {\n+        OverlapMode::Stable\n+    }\n+}\n+\n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     skip_leak_check: SkipLeakCheck,\n-    a_def_id: DefId,\n-    b_def_id: DefId,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n ) -> Option<OverlapResult<'tcx>> {\n-    debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\", a_def_id, b_def_id);\n+    debug!(\"overlap(impl1_def_id={:?}, impl2_def_id={:?})\", impl1_def_id, impl2_def_id);\n \n     selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n-        overlap_within_probe(selcx, skip_leak_check, a_def_id, b_def_id, snapshot)\n+        overlap_within_probe(selcx, skip_leak_check, impl1_def_id, impl2_def_id, snapshot)\n     })\n }\n \n fn overlap_within_probe<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     skip_leak_check: SkipLeakCheck,\n-    a_def_id: DefId,\n-    b_def_id: DefId,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n     snapshot: &CombinedSnapshot<'_, 'tcx>,\n ) -> Option<OverlapResult<'tcx>> {\n-    fn loose_check<'cx, 'tcx>(\n-        selcx: &mut SelectionContext<'cx, 'tcx>,\n-        o: &PredicateObligation<'tcx>,\n-    ) -> bool {\n-        !selcx.predicate_may_hold_fatal(o)\n-    }\n+    let infcx = selcx.infcx();\n+    let tcx = infcx.tcx;\n \n-    fn strict_check<'cx, 'tcx>(\n-        selcx: &SelectionContext<'cx, 'tcx>,\n-        o: &PredicateObligation<'tcx>,\n-    ) -> bool {\n-        let infcx = selcx.infcx();\n-        let tcx = infcx.tcx;\n-        o.flip_polarity(tcx)\n-            .as_ref()\n-            .map(|o| selcx.infcx().predicate_must_hold_modulo_regions(o))\n-            .unwrap_or(false)\n+    let overlap_mode = overlap_mode(tcx, impl1_def_id, impl2_def_id);\n+\n+    if overlap_mode.use_negative_impl() {\n+        if negative_impl(selcx, impl1_def_id, impl2_def_id)\n+            || negative_impl(selcx, impl2_def_id, impl1_def_id)\n+        {\n+            return None;\n+        }\n     }\n \n     // For the purposes of this check, we don't bring any placeholder\n@@ -182,26 +222,61 @@ fn overlap_within_probe<'cx, 'tcx>(\n     // empty environment.\n     let param_env = ty::ParamEnv::empty();\n \n-    let a_impl_header = with_fresh_ty_vars(selcx, param_env, a_def_id);\n-    let b_impl_header = with_fresh_ty_vars(selcx, param_env, b_def_id);\n+    let impl1_header = with_fresh_ty_vars(selcx, param_env, impl1_def_id);\n+    let impl2_header = with_fresh_ty_vars(selcx, param_env, impl2_def_id);\n \n-    debug!(\"overlap: a_impl_header={:?}\", a_impl_header);\n-    debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n+    debug!(\"overlap: impl1_header={:?}\", impl1_header);\n+    debug!(\"overlap: impl2_header={:?}\", impl2_header);\n \n-    // Do `a` and `b` unify? If not, no overlap.\n-    let obligations = match selcx\n-        .infcx()\n-        .at(&ObligationCause::dummy(), param_env)\n-        .eq_impl_headers(&a_impl_header, &b_impl_header)\n-    {\n-        Ok(InferOk { obligations, value: () }) => obligations,\n-        Err(_) => {\n+    let obligations = equate_impl_headers(selcx, &impl1_header, &impl2_header)?;\n+    debug!(\"overlap: unification check succeeded\");\n+\n+    if overlap_mode.use_implicit_negative() {\n+        if implicit_negative(selcx, param_env, &impl1_header, impl2_header, obligations) {\n             return None;\n         }\n-    };\n+    }\n \n-    debug!(\"overlap: unification check succeeded\");\n+    if !skip_leak_check.is_yes() {\n+        if infcx.leak_check(true, snapshot).is_err() {\n+            debug!(\"overlap: leak check failed\");\n+            return None;\n+        }\n+    }\n+\n+    let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n+    debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n+\n+    let involves_placeholder =\n+        matches!(selcx.infcx().region_constraints_added_in_snapshot(snapshot), Some(true));\n+\n+    let impl_header = selcx.infcx().resolve_vars_if_possible(impl1_header);\n+    Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n+}\n+\n+fn equate_impl_headers<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    impl1_header: &ty::ImplHeader<'tcx>,\n+    impl2_header: &ty::ImplHeader<'tcx>,\n+) -> Option<PredicateObligations<'tcx>> {\n+    // Do `a` and `b` unify? If not, no overlap.\n+    selcx\n+        .infcx()\n+        .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+        .eq_impl_headers(impl1_header, impl2_header)\n+        .map(|infer_ok| infer_ok.obligations)\n+        .ok()\n+}\n \n+/// Given impl1 and impl2 check if both impls can be satisfied by a common type (including\n+/// where-clauses) If so, return false, otherwise return true, they are disjoint.\n+fn implicit_negative<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl1_header: &ty::ImplHeader<'tcx>,\n+    impl2_header: ty::ImplHeader<'tcx>,\n+    obligations: PredicateObligations<'tcx>,\n+) -> bool {\n     // There's no overlap if obligations are unsatisfiable or if the obligation negated is\n     // satisfied.\n     //\n@@ -225,11 +300,11 @@ fn overlap_within_probe<'cx, 'tcx>(\n     // at some point an impl for `&'?a str: Error` could be added.\n     let infcx = selcx.infcx();\n     let tcx = infcx.tcx;\n-    let opt_failing_obligation = a_impl_header\n+    let opt_failing_obligation = impl1_header\n         .predicates\n         .iter()\n         .copied()\n-        .chain(b_impl_header.predicates)\n+        .chain(impl2_header.predicates)\n         .map(|p| infcx.resolve_vars_if_possible(p))\n         .map(|p| Obligation {\n             cause: ObligationCause::dummy(),\n@@ -239,40 +314,105 @@ fn overlap_within_probe<'cx, 'tcx>(\n         })\n         .chain(obligations)\n         .find(|o| {\n-            // if both impl headers are set to strict coherence it means that this will be accepted\n-            // only if it's stated that T: !Trait. So only prove that the negated obligation holds.\n-            if tcx.has_attr(a_def_id, sym::rustc_strict_coherence)\n-                && tcx.has_attr(b_def_id, sym::rustc_strict_coherence)\n-            {\n-                strict_check(selcx, o)\n-            } else {\n-                loose_check(selcx, o) || tcx.features().negative_impls && strict_check(selcx, o)\n-            }\n+            loose_check(selcx, o) || tcx.features().negative_impls && negative_impl_exists(selcx, o)\n         });\n     // FIXME: the call to `selcx.predicate_may_hold_fatal` above should be ported\n     // to the canonical trait query form, `infcx.predicate_may_hold`, once\n     // the new system supports intercrate mode (which coherence needs).\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n-        return None;\n+        true\n+    } else {\n+        false\n     }\n+}\n \n-    if !skip_leak_check.is_yes() {\n-        if infcx.leak_check(true, snapshot).is_err() {\n-            debug!(\"overlap: leak check failed\");\n-            return None;\n-        }\n-    }\n+/// Given impl1 and impl2 check if both impls are never satisfied by a common type (including\n+/// where-clauses) If so, return true, they are disjoint and false otherwise.\n+fn negative_impl<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n+) -> bool {\n+    let tcx = selcx.infcx().tcx;\n \n-    let impl_header = selcx.infcx().resolve_vars_if_possible(a_impl_header);\n-    let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n-    debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n+    // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n+    let impl1_env = tcx.param_env(impl1_def_id);\n+    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n-    let involves_placeholder =\n-        matches!(selcx.infcx().region_constraints_added_in_snapshot(snapshot), Some(true));\n+    // Create an infcx, taking the predicates of impl1 as assumptions:\n+    tcx.infer_ctxt().enter(|infcx| {\n+        // Normalize the trait reference. The WF rules ought to ensure\n+        // that this always succeeds.\n+        let impl1_trait_ref = match traits::fully_normalize(\n+            &infcx,\n+            FulfillmentContext::new(),\n+            ObligationCause::dummy(),\n+            impl1_env,\n+            impl1_trait_ref,\n+        ) {\n+            Ok(impl1_trait_ref) => impl1_trait_ref,\n+            Err(err) => {\n+                bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n+            }\n+        };\n+\n+        // Attempt to prove that impl2 applies, given all of the above.\n+        let selcx = &mut SelectionContext::new(&infcx);\n+        let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n+        let (impl2_trait_ref, obligations) =\n+            impl_trait_ref_and_oblig(selcx, impl1_env, impl2_def_id, impl2_substs);\n+\n+        // do the impls unify? If not, not disjoint.\n+        let more_obligations = match infcx\n+            .at(&ObligationCause::dummy(), impl1_env)\n+            .eq(impl1_trait_ref, impl2_trait_ref)\n+        {\n+            Ok(InferOk { obligations, .. }) => obligations,\n+            Err(_) => {\n+                debug!(\n+                    \"explicit_disjoint: {:?} does not unify with {:?}\",\n+                    impl1_trait_ref, impl2_trait_ref\n+                );\n+                return false;\n+            }\n+        };\n \n-    Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n+        let opt_failing_obligation = obligations\n+            .into_iter()\n+            .chain(more_obligations)\n+            .find(|o| negative_impl_exists(selcx, o));\n+\n+        if let Some(failing_obligation) = opt_failing_obligation {\n+            debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n+            true\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+fn loose_check<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    o: &PredicateObligation<'tcx>,\n+) -> bool {\n+    !selcx.predicate_may_hold_fatal(o)\n+}\n+\n+fn negative_impl_exists<'cx, 'tcx>(\n+    selcx: &SelectionContext<'cx, 'tcx>,\n+    o: &PredicateObligation<'tcx>,\n+) -> bool {\n+    let infcx = selcx.infcx();\n+    let tcx = infcx.tcx;\n+    o.flip_polarity(tcx)\n+        .as_ref()\n+        .map(|o| {\n+            // FIXME This isn't quite correct, regions should be included\n+            selcx.infcx().predicate_must_hold_modulo_regions(o)\n+        })\n+        .unwrap_or(false)\n }\n \n pub fn trait_ref_is_knowable<'tcx>("}, {"sha": "f71df1b87fcda367ca59e71e60106e48cb6d9a0f", "filename": "src/test/ui/coherence/auxiliary/option_future.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs?ref=3d6f276ca71060a189fdbcb61b93750c2cb8c5a7", "patch": "@@ -0,0 +1,8 @@\n+#![crate_type = \"lib\"]\n+#![feature(negative_impls)]\n+#![feature(rustc_attrs)]\n+\n+pub trait Future {}\n+\n+#[rustc_with_negative_coherence]\n+impl<E> !Future for Option<E> where E: Sized {}"}, {"sha": "1f47b5ba46e411158d39814bf710cf03b55d1f32", "filename": "src/test/ui/coherence/coherence-overlap-negative-trait2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6f276ca71060a189fdbcb61b93750c2cb8c5a7/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs?ref=3d6f276ca71060a189fdbcb61b93750c2cb8c5a7", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// aux-build:option_future.rs\n+//\n+// Check that if we promise to not impl what would overlap it doesn't actually overlap\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate option_future as lib;\n+use lib::Future;\n+\n+trait Termination {}\n+\n+#[rustc_with_negative_coherence]\n+impl<E> Termination for Option<E> where E: Sized {}\n+#[rustc_with_negative_coherence]\n+impl<F> Termination for F where F: Future + Sized {}\n+\n+fn main() {}"}]}