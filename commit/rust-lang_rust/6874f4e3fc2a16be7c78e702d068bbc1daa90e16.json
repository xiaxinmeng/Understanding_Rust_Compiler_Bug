{"sha": "6874f4e3fc2a16be7c78e702d068bbc1daa90e16", "node_id": "C_kwDOAAsO6NoAKDY4NzRmNGUzZmMyYTE2YmU3Yzc4ZTcwMmQwNjhiYmMxZGFhOTBlMTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-27T09:01:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-27T09:01:05Z"}, "message": "Auto merge of #107054 - petrochenkov:effvisdoc3, r=GuillaumeGomez\n\nrustdoc: Collect \"rustdoc-reachable\" items during early doc link resolution\n\nThis pass only needs to know about visibilities, attributes and reexports, so it can be run early, similarly to `compute_effective_visibilities` in rustc.\nResults of this pass can be used to prune the list of extern impls early thus improving performance of https://github.com/rust-lang/rust/pull/94857.", "tree": {"sha": "144fcf07feb76150987171cd362c2a8a48f2c1e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/144fcf07feb76150987171cd362c2a8a48f2c1e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6874f4e3fc2a16be7c78e702d068bbc1daa90e16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6874f4e3fc2a16be7c78e702d068bbc1daa90e16", "html_url": "https://github.com/rust-lang/rust/commit/6874f4e3fc2a16be7c78e702d068bbc1daa90e16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "url": "https://api.github.com/repos/rust-lang/rust/commits/18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "html_url": "https://github.com/rust-lang/rust/commit/18890f05f6cea40fd25bb4bb9aa6f7372b69f641"}, {"sha": "398225842cbff0cdd45021bfe91712d407a900b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/398225842cbff0cdd45021bfe91712d407a900b8", "html_url": "https://github.com/rust-lang/rust/commit/398225842cbff0cdd45021bfe91712d407a900b8"}], "stats": {"total": 107, "additions": 93, "deletions": 14}, "files": [{"sha": "e5d0bb87edf66f4baffbff184a50c95aac40d3d5", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=6874f4e3fc2a16be7c78e702d068bbc1daa90e16", "patch": "@@ -632,6 +632,12 @@ impl CStore {\n             .get_attr_flags(def_id.index)\n             .contains(AttrFlags::MAY_HAVE_DOC_LINKS)\n     }\n+\n+    pub fn is_doc_hidden_untracked(&self, def_id: DefId) -> bool {\n+        self.get_crate_data(def_id.krate)\n+            .get_attr_flags(def_id.index)\n+            .contains(AttrFlags::IS_DOC_HIDDEN)\n+    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "ca3a70c7236feb2a617527c19712bb65b81882c5", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=6874f4e3fc2a16be7c78e702d068bbc1daa90e16", "patch": "@@ -29,11 +29,6 @@ mod tests;\n pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n     let module = crate::visit_ast::RustdocVisitor::new(cx).visit();\n \n-    for &cnum in cx.tcx.crates(()) {\n-        // Analyze doc-reachability for extern items\n-        crate::visit_lib::lib_embargo_visit_item(cx, cnum.as_def_id());\n-    }\n-\n     // Clean the crate, translating the entire librustc_ast AST to one that is\n     // understood by rustdoc.\n     let mut module = clean_doc_module(&module, cx);"}, {"sha": "0ce43f7db8e8b0d9d8fb5cd768141da3a27cd023", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6874f4e3fc2a16be7c78e702d068bbc1daa90e16", "patch": "@@ -41,6 +41,7 @@ pub(crate) struct ResolverCaches {\n     pub(crate) traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     pub(crate) all_trait_impls: Option<Vec<DefId>>,\n     pub(crate) all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n+    pub(crate) extern_doc_reachable: DefIdSet,\n }\n \n pub(crate) struct DocContext<'tcx> {\n@@ -363,6 +364,10 @@ pub(crate) fn run_global_ctxt(\n         show_coverage,\n     };\n \n+    ctxt.cache\n+        .effective_visibilities\n+        .init(mem::take(&mut ctxt.resolver_caches.extern_doc_reachable));\n+\n     // Small hack to force the Sized trait to be present.\n     //\n     // Note that in case of `#![no_core]`, the trait is not available."}, {"sha": "f690c49005d9c70e455805f791d2d6bef49757aa", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=6874f4e3fc2a16be7c78e702d068bbc1daa90e16", "patch": "@@ -2,6 +2,7 @@ use crate::clean::Attributes;\n use crate::core::ResolverCaches;\n use crate::passes::collect_intra_doc_links::preprocessed_markdown_links;\n use crate::passes::collect_intra_doc_links::{Disambiguator, PreprocessedMarkdownLink};\n+use crate::visit_lib::early_lib_embargo_visit_item;\n \n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, ItemKind};\n@@ -34,6 +35,8 @@ pub(crate) fn early_resolve_intra_doc_links(\n         traits_in_scope: Default::default(),\n         all_trait_impls: Default::default(),\n         all_macro_rules: Default::default(),\n+        extern_doc_reachable: Default::default(),\n+        local_doc_reachable: Default::default(),\n         document_private_items,\n     };\n \n@@ -61,6 +64,7 @@ pub(crate) fn early_resolve_intra_doc_links(\n         traits_in_scope: link_resolver.traits_in_scope,\n         all_trait_impls: Some(link_resolver.all_trait_impls),\n         all_macro_rules: link_resolver.all_macro_rules,\n+        extern_doc_reachable: link_resolver.extern_doc_reachable,\n     }\n }\n \n@@ -77,6 +81,15 @@ struct EarlyDocLinkResolver<'r, 'ra> {\n     traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     all_trait_impls: Vec<DefId>,\n     all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n+    /// This set is used as a seed for `effective_visibilities`, which are then extended by some\n+    /// more items using `lib_embargo_visit_item` during doc inlining.\n+    extern_doc_reachable: DefIdSet,\n+    /// This is an easily identifiable superset of items added to `effective_visibilities`\n+    /// using `lib_embargo_visit_item` during doc inlining.\n+    /// The union of `(extern,local)_doc_reachable` is therefore a superset of\n+    /// `effective_visibilities` and can be used for pruning extern impls here\n+    /// in early doc link resolution.\n+    local_doc_reachable: DefIdSet,\n     document_private_items: bool,\n }\n \n@@ -105,6 +118,10 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n         }\n     }\n \n+    fn is_doc_reachable(&self, def_id: DefId) -> bool {\n+        self.extern_doc_reachable.contains(&def_id) || self.local_doc_reachable.contains(&def_id)\n+    }\n+\n     /// Add traits in scope for links in impls collected by the `collect-intra-doc-links` pass.\n     /// That pass filters impls using type-based information, but we don't yet have such\n     /// information here, so we just conservatively calculate traits in scope for *all* modules\n@@ -114,6 +131,14 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n         let mut start_cnum = 0;\n         loop {\n             let crates = Vec::from_iter(self.resolver.cstore().crates_untracked());\n+            for cnum in &crates[start_cnum..] {\n+                early_lib_embargo_visit_item(\n+                    self.resolver,\n+                    &mut self.extern_doc_reachable,\n+                    cnum.as_def_id(),\n+                    true,\n+                );\n+            }\n             for &cnum in &crates[start_cnum..] {\n                 let all_trait_impls =\n                     Vec::from_iter(self.resolver.cstore().trait_impls_in_crate_untracked(cnum));\n@@ -127,28 +152,26 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                 // privacy, private traits and impls from other crates are never documented in\n                 // the current crate, and links in their doc comments are not resolved.\n                 for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n-                    if self.resolver.cstore().visibility_untracked(trait_def_id).is_public()\n-                        && simplified_self_ty.and_then(|ty| ty.def()).map_or(true, |ty_def_id| {\n-                            self.resolver.cstore().visibility_untracked(ty_def_id).is_public()\n-                        })\n+                    if self.is_doc_reachable(trait_def_id)\n+                        && simplified_self_ty\n+                            .and_then(|ty| ty.def())\n+                            .map_or(true, |ty_def_id| self.is_doc_reachable(ty_def_id))\n                     {\n                         if self.visited_mods.insert(trait_def_id) {\n                             self.resolve_doc_links_extern_impl(trait_def_id, false);\n                         }\n                         self.resolve_doc_links_extern_impl(impl_def_id, false);\n                     }\n+                    self.all_trait_impls.push(impl_def_id);\n                 }\n                 for (ty_def_id, impl_def_id) in all_inherent_impls {\n-                    if self.resolver.cstore().visibility_untracked(ty_def_id).is_public() {\n+                    if self.is_doc_reachable(ty_def_id) {\n                         self.resolve_doc_links_extern_impl(impl_def_id, true);\n                     }\n                 }\n                 for impl_def_id in all_incoherent_impls {\n                     self.resolve_doc_links_extern_impl(impl_def_id, true);\n                 }\n-\n-                self.all_trait_impls\n-                    .extend(all_trait_impls.into_iter().map(|(_, def_id, _)| def_id));\n             }\n \n             if crates.len() > start_cnum {\n@@ -298,6 +321,7 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                     && module_id.is_local()\n             {\n                 if let Some(def_id) = child.res.opt_def_id() && !def_id.is_local() {\n+                    self.local_doc_reachable.insert(def_id);\n                     let scope_id = match child.res {\n                         Res::Def(\n                             DefKind::Variant"}, {"sha": "07d8b78d767dbb956994588c01ea194007ec06f0", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6874f4e3fc2a16be7c78e702d068bbc1daa90e16/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=6874f4e3fc2a16be7c78e702d068bbc1daa90e16", "patch": "@@ -1,7 +1,8 @@\n use crate::core::DocContext;\n-use rustc_hir::def::DefKind;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_middle::ty::TyCtxt;\n+use rustc_resolve::Resolver;\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n@@ -25,6 +26,10 @@ impl RustdocEffectiveVisibilities {\n     define_method!(is_directly_public);\n     define_method!(is_exported);\n     define_method!(is_reachable);\n+\n+    pub(crate) fn init(&mut self, extern_public: DefIdSet) {\n+        self.extern_public = extern_public;\n+    }\n }\n \n pub(crate) fn lib_embargo_visit_item(cx: &mut DocContext<'_>, def_id: DefId) {\n@@ -37,6 +42,17 @@ pub(crate) fn lib_embargo_visit_item(cx: &mut DocContext<'_>, def_id: DefId) {\n     .visit_item(def_id)\n }\n \n+pub(crate) fn early_lib_embargo_visit_item(\n+    resolver: &Resolver<'_>,\n+    extern_public: &mut DefIdSet,\n+    def_id: DefId,\n+    is_mod: bool,\n+) {\n+    assert!(!def_id.is_local());\n+    EarlyLibEmbargoVisitor { resolver, extern_public, visited_mods: Default::default() }\n+        .visit_item(def_id, is_mod)\n+}\n+\n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n struct LibEmbargoVisitor<'a, 'tcx> {\n@@ -47,6 +63,14 @@ struct LibEmbargoVisitor<'a, 'tcx> {\n     visited_mods: DefIdSet,\n }\n \n+struct EarlyLibEmbargoVisitor<'r, 'ra> {\n+    resolver: &'r Resolver<'ra>,\n+    // Effective visibilities for reachable nodes\n+    extern_public: &'r mut DefIdSet,\n+    // Keeps track of already visited modules, in case a module re-exports its parent\n+    visited_mods: DefIdSet,\n+}\n+\n impl LibEmbargoVisitor<'_, '_> {\n     fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n@@ -71,3 +95,28 @@ impl LibEmbargoVisitor<'_, '_> {\n         }\n     }\n }\n+\n+impl EarlyLibEmbargoVisitor<'_, '_> {\n+    fn visit_mod(&mut self, def_id: DefId) {\n+        if !self.visited_mods.insert(def_id) {\n+            return;\n+        }\n+\n+        for item in self.resolver.cstore().module_children_untracked(def_id, self.resolver.sess()) {\n+            if let Some(def_id) = item.res.opt_def_id() {\n+                if item.vis.is_public() {\n+                    self.visit_item(def_id, matches!(item.res, Res::Def(DefKind::Mod, _)));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_item(&mut self, def_id: DefId, is_mod: bool) {\n+        if !self.resolver.cstore().is_doc_hidden_untracked(def_id) {\n+            self.extern_public.insert(def_id);\n+            if is_mod {\n+                self.visit_mod(def_id);\n+            }\n+        }\n+    }\n+}"}]}