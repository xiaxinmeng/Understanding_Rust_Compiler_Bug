{"sha": "e11d13f3de084fe73d754ca206ad70737bb5957d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMWQxM2YzZGUwODRmZTczZDc1NGNhMjA2YWQ3MDczN2JiNTk1N2Q=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-21T01:28:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-26T19:16:58Z"}, "message": "Rip out old code that still structured method calls as a\nexpr_call(expr_field(...)) rather than an expr_method_call.\nThere is probably more such code in trans that should be removed.", "tree": {"sha": "2214105e99cd6fc25054ac291a702e0ae460fd8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2214105e99cd6fc25054ac291a702e0ae460fd8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e11d13f3de084fe73d754ca206ad70737bb5957d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e11d13f3de084fe73d754ca206ad70737bb5957d", "html_url": "https://github.com/rust-lang/rust/commit/e11d13f3de084fe73d754ca206ad70737bb5957d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e11d13f3de084fe73d754ca206ad70737bb5957d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d96bbb907edf803dc2917b3e69d387f5b6657100", "url": "https://api.github.com/repos/rust-lang/rust/commits/d96bbb907edf803dc2917b3e69d387f5b6657100", "html_url": "https://github.com/rust-lang/rust/commit/d96bbb907edf803dc2917b3e69d387f5b6657100"}], "stats": {"total": 274, "additions": 114, "deletions": 160}, "files": [{"sha": "ea5301af9b298202e15c14e66ee2067b1d89f2dd", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 41, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e11d13f3de084fe73d754ca206ad70737bb5957d", "patch": "@@ -1321,13 +1321,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   sugar: ast::CallSugar) {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n-        match f.node {\n-            ast::expr_field(ref base, ref field, ref tys) => {\n-                check_field(fcx, f, true, *base, *field, *tys)\n-            }\n-            _ => check_expr(fcx, f)\n-        };\n-\n+        let mut bot = check_expr(fcx, f);\n         check_call_or_method(fcx,\n                              sp,\n                              call_expr_id,\n@@ -1689,7 +1683,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // Check field access expressions\n     fn check_field(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n-                   is_callee: bool,\n                    base: @ast::expr,\n                    field: ast::ident,\n                    tys: &[@ast::Ty]) {\n@@ -1723,7 +1716,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n \n         let tps = vec::map(tys, |ty| fcx.to_ty(*ty));\n-\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -1734,34 +1726,30 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              DontDerefArgs,\n                              CheckTraitsAndInherentMethods,\n                              AutoderefReceiver) {\n-            Some(ref entry) => {\n-                let method_map = fcx.ccx.method_map;\n-                method_map.insert(expr.id, (*entry));\n-\n-                // If we have resolved to a method but this is not in\n-                // a callee position, error\n-                if !is_callee {\n-                    tcx.sess.span_err(\n-                        expr.span,\n-                        ~\"attempted to take value of method \\\n-                          (try writing an anonymous function)\");\n-                    // Add error type for the result\n-                    fcx.write_error(expr.id);\n-                }\n+            Some(_) => {\n+                fcx.type_error_message(\n+                    expr.span,\n+                    |actual| {\n+                        fmt!(\"attempted to take value of method `%s` on type `%s` \\\n+                              (try writing an anonymous function)\",\n+                             *tcx.sess.str_of(field), actual)\n+                    },\n+                    expr_t, None);\n             }\n+\n             None => {\n-                fcx.type_error_message(expr.span,\n-                  |actual| {\n-                      fmt!(\"attempted access of field `%s` on type `%s`, but \\\n-                            no field or method with that name was found\",\n-                           *tcx.sess.str_of(field), actual)\n-                  },\n-                  expr_t, None);\n-                // Add error type for the result\n-                fcx.write_error(expr.id);\n+                fcx.type_error_message(\n+                    expr.span,\n+                    |actual| {\n+                        fmt!(\"attempted access of field `%s` on type `%s`, \\\n+                              but no field with that name was found\",\n+                             *tcx.sess.str_of(field), actual)\n+                    },\n+                    expr_t, None);\n             }\n         }\n \n+        fcx.write_error(expr.id);\n     }\n \n     fn check_struct_or_variant_fields(fcx: @mut FnCtxt,\n@@ -2750,15 +2738,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::expr_field(base, field, ref tys) => {\n-          check_field(fcx, expr, false, base, field, * tys);\n-          let base_t = fcx.expr_ty(base);\n-          if ty::type_is_error(base_t) {\n-              fcx.write_error(id);\n-          }\n-          else if ty::type_is_bot(base_t) {\n-              fcx.write_bot(id);\n-          }\n-          // Otherwise, type already got written\n+        check_field(fcx, expr, base, field, *tys);\n       }\n       ast::expr_index(base, idx) => {\n           check_expr(fcx, base);"}, {"sha": "e81e460e832e4a0904605db170a172319e30cf62", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 44, "deletions": 67, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=e11d13f3de084fe73d754ca206ad70737bb5957d", "patch": "@@ -416,6 +416,16 @@ priv impl @ext_ctxt {\n         self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n     }\n \n+    fn expr_method_call(\n+        &self,\n+        span: span,\n+        expr: @ast::expr,\n+        ident: ast::ident,\n+        +args: ~[@ast::expr]\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+    }\n+\n     fn lambda_expr(&self, expr: @ast::expr) -> @ast::expr {\n         self.lambda(self.expr_blk(expr))\n     }\n@@ -712,30 +722,24 @@ fn mk_struct_ser_impl(\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n         // ast for `|| self.$(name).encode(__s)`\n         let expr_lambda = cx.lambda_expr(\n-            cx.expr_call(\n+            cx.expr_method_call(\n                 span,\n                 cx.expr_field(\n                     span,\n-                    cx.expr_field(\n-                        span,\n-                        cx.expr_var(span, ~\"self\"),\n-                        field.ident\n-                    ),\n-                    cx.ident_of(~\"encode\")\n+                    cx.expr_var(span, ~\"self\"),\n+                    field.ident\n                 ),\n+                cx.ident_of(~\"encode\"),\n                 ~[cx.expr_var(span, ~\"__s\")]\n             )\n         );\n \n         // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n         cx.stmt(\n-            cx.expr_call(\n+            cx.expr_method_call(\n                 span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_var(span, ~\"__s\"),\n-                    cx.ident_of(~\"emit_field\")\n-                ),\n+                cx.expr_var(span, ~\"__s\"),\n+                cx.ident_of(~\"emit_field\"),\n                 ~[\n                     cx.lit_str(span, @cx.str_of(field.ident)),\n                     cx.lit_uint(span, idx),\n@@ -746,13 +750,10 @@ fn mk_struct_ser_impl(\n     };\n \n     // ast for `__s.emit_struct($(name), || $(fields))`\n-    let ser_body = cx.expr_call(\n+    let ser_body = cx.expr_method_call(\n         span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_struct\")\n-        ),\n+        cx.expr_var(span, ~\"__s\"),\n+        cx.ident_of(~\"emit_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n@@ -788,13 +789,10 @@ fn mk_struct_deser_impl(\n         );\n \n         // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n-        let expr: @ast::expr = cx.expr_call(\n+        let expr: @ast::expr = cx.expr_method_call(\n             span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_field\")\n-            ),\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_field\"),\n             ~[\n                 cx.lit_str(span, @cx.str_of(field.ident)),\n                 cx.lit_uint(span, idx),\n@@ -813,13 +811,10 @@ fn mk_struct_deser_impl(\n     };\n \n     // ast for `read_struct($(name), || $(fields))`\n-    let body = cx.expr_call(\n+    let body = cx.expr_method_call(\n         span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_struct\")\n-        ),\n+        cx.expr_var(span, ~\"__d\"),\n+        cx.ident_of(~\"read_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n@@ -943,13 +938,10 @@ fn ser_variant(\n \n         // ast for `|| $(v).encode(__s)`\n         let expr_encode = cx.lambda_expr(\n-             cx.expr_call(\n+             cx.expr_method_call(\n                 span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_path(span, ~[names[a_idx]]),\n-                    cx.ident_of(~\"encode\")\n-                ),\n+                 cx.expr_path(span, ~[names[a_idx]]),\n+                 cx.ident_of(~\"encode\"),\n                 ~[cx.expr_var(span, ~\"__s\")]\n             )\n         );\n@@ -965,13 +957,10 @@ fn ser_variant(\n     };\n \n     // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n-    let body = cx.expr_call(\n+    let body = cx.expr_method_call(\n         span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum_variant\")\n-        ),\n+        cx.expr_var(span, ~\"__s\"),\n+        cx.ident_of(~\"emit_enum_variant\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(v_name)),\n             cx.lit_uint(span, v_idx),\n@@ -1019,13 +1008,10 @@ fn mk_enum_ser_body(\n     );\n \n     // ast for `__s.emit_enum($(name), || $(match_expr))`\n-    cx.expr_call(\n+    cx.expr_method_call(\n         span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum\")\n-        ),\n+        cx.expr_var(span, ~\"__s\"),\n+        cx.ident_of(~\"emit_enum\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(name)),\n             cx.lambda_expr(match_expr),\n@@ -1055,13 +1041,10 @@ fn mk_enum_deser_variant_nary(\n         );\n \n         // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n-        cx.expr_call(\n+        cx.expr_method_call(\n             span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_enum_variant_arg\")\n-            ),\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_enum_variant_arg\"),\n             ~[cx.lit_uint(span, idx), expr_lambda]\n         )\n     };\n@@ -1171,25 +1154,19 @@ fn mk_enum_deser_body(\n \n     // ast for `__d.read_enum_variant($(expr_lambda))`\n     let expr_lambda = ext_cx.lambda_expr(\n-        ext_cx.expr_call(\n+        ext_cx.expr_method_call(\n             span,\n-            ext_cx.expr_field(\n-                span,\n-                ext_cx.expr_var(span, ~\"__d\"),\n-                ext_cx.ident_of(~\"read_enum_variant\")\n-            ),\n+            ext_cx.expr_var(span, ~\"__d\"),\n+            ext_cx.ident_of(~\"read_enum_variant\"),\n             ~[expr_lambda]\n         )\n     );\n \n     // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n-    ext_cx.expr_call(\n+    ext_cx.expr_method_call(\n         span,\n-        ext_cx.expr_field(\n-            span,\n-            ext_cx.expr_var(span, ~\"__d\"),\n-            ext_cx.ident_of(~\"read_enum\")\n-        ),\n+        ext_cx.expr_var(span, ~\"__d\"),\n+        ext_cx.ident_of(~\"read_enum\"),\n         ~[\n             ext_cx.lit_str(span, @ext_cx.str_of(name)),\n             expr_lambda"}, {"sha": "ad71441e0466fbc462601b0b623dc4eff30a357e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e11d13f3de084fe73d754ca206ad70737bb5957d", "patch": "@@ -111,6 +111,13 @@ pub fn mk_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n pub fn mk_mut_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_mutbl, e));\n }\n+pub fn mk_method_call(cx: @ext_ctxt,\n+                      sp: span,\n+                      rcvr_expr: @ast::expr,\n+                      method_ident: ast::ident,\n+                      +args: ~[@ast::expr]) -> @ast::expr {\n+    mk_expr(cx, sp, ast::expr_method_call(rcvr_expr, method_ident, ~[], args, ast::NoSugar))\n+}\n pub fn mk_call_(cx: @ext_ctxt, sp: span, fn_expr: @ast::expr,\n                 +args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))"}, {"sha": "68458bd516eedd122debeda0bf6e2800d8675867", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=e11d13f3de084fe73d754ca206ad70737bb5957d", "patch": "@@ -120,8 +120,9 @@ fn call_substructure_clone_method(cx: @ext_ctxt,\n                                -> @expr {\n     // Call the substructure method.\n     let clone_ident = cx.ident_of(~\"clone\");\n-    let self_method = build::mk_access_(cx, span, self_field, clone_ident);\n-    build::mk_call_(cx, span, self_method, ~[])\n+    build::mk_method_call(cx, span,\n+                          self_field, clone_ident,\n+                          ~[])\n }\n \n fn expand_deriving_clone_struct_def(cx: @ext_ctxt,"}, {"sha": "8cee6bd7290b46fee7898ec15e8f0eb3f7a72f6a", "filename": "src/libsyntax/ext/deriving/eq.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs?ref=e11d13f3de084fe73d754ca206ad70737bb5957d", "patch": "@@ -147,11 +147,9 @@ fn call_substructure_eq_method(cx: @ext_ctxt,\n                                junction: Junction,\n                                chain_expr: &mut Option<@expr>) {\n     // Call the substructure method.\n-    let self_method = build::mk_access_(cx, span, self_field, method_ident);\n-    let self_call = build::mk_call_(cx,\n-                                    span,\n-                                    self_method,\n-                                    ~[ other_field_ref ]);\n+    let self_call = build::mk_method_call(cx, span,\n+                                          self_field, method_ident,\n+                                          ~[ other_field_ref ]);\n \n     // Connect to the outer expression if necessary.\n     *chain_expr = match *chain_expr {"}, {"sha": "3c1ee7e0296448ea8833c9691799555ff2558a59", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=e11d13f3de084fe73d754ca206ad70737bb5957d", "patch": "@@ -125,14 +125,11 @@ fn call_substructure_iter_bytes_method(cx: @ext_ctxt,\n \n     // Call the substructure method.\n     let iter_bytes_ident = cx.ident_of(~\"iter_bytes\");\n-    let self_method = build::mk_access_(cx,\n-                                        span,\n-                                        self_field,\n-                                        iter_bytes_ident);\n-    let self_call = build::mk_call_(cx,\n-                                    span,\n-                                    self_method,\n-                                    ~[ lsb0_expr, f_expr ]);\n+    let self_call = build::mk_method_call(cx,\n+                                          span,\n+                                          self_field,\n+                                          iter_bytes_ident,\n+                                          ~[ lsb0_expr, f_expr ]);\n \n     // Create a statement out of this expression.\n     build::mk_stmt(cx, span, self_call)"}, {"sha": "6044c3ad3d24ba6f689c10b0f325eb1f91ef0b87", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11d13f3de084fe73d754ca206ad70737bb5957d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=e11d13f3de084fe73d754ca206ad70737bb5957d", "patch": "@@ -270,11 +270,11 @@ fn id_ext(cx: @ext_ctxt, +str: ~str) -> ast::ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: @ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n-    let e_meth = build::mk_access(cx, sp,\n-                                  ids_ext(cx, ~[~\"ext_cx\"]),\n-                                  id_ext(cx, ~\"ident_of\"));\n     let e_str = build::mk_uniq_str(cx, sp, cx.str_of(ident));\n-    build::mk_call_(cx, sp, e_meth, ~[e_str])\n+    build::mk_method_call(cx, sp,\n+                          build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+                          id_ext(cx, ~\"ident_of\"),\n+                          ~[e_str])\n }\n \n fn mk_bytepos(cx: @ext_ctxt, sp: span, bpos: BytePos) -> @ast::expr {\n@@ -462,11 +462,10 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n                                ids_ext(cx, ~[~\"tt_tok\"]),\n                                ~[e_sp, mk_token(cx, sp, *tok)]);\n             let e_push =\n-                build::mk_call_(cx, sp,\n-                                build::mk_access(cx, sp,\n-                                                 ids_ext(cx, ~[~\"tt\"]),\n-                                                 id_ext(cx, ~\"push\")),\n-                                ~[e_tok]);\n+                build::mk_method_call(cx, sp,\n+                                      build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n+                                      id_ext(cx, ~\"push\"),\n+                                      ~[e_tok]);\n             ~[build::mk_stmt(cx, sp, e_push)]\n \n         }\n@@ -479,21 +478,17 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n             // tt.push_all_move($ident.to_tokens(ext_cx))\n \n             let e_to_toks =\n-                build::mk_call_(cx, sp,\n-                                build::mk_access\n-                                (cx, sp,\n-                                 ~[ident],\n-                                 id_ext(cx, ~\"to_tokens\")),\n-                                ~[build::mk_path(cx, sp,\n-                                        ids_ext(cx, ~[~\"ext_cx\"]))]);\n+                build::mk_method_call(cx, sp,\n+                                      build::mk_path(cx, sp, ~[ident]),\n+                                      id_ext(cx, ~\"to_tokens\"),\n+                                      ~[build::mk_path(cx, sp,\n+                                                       ids_ext(cx, ~[~\"ext_cx\"]))]);\n \n             let e_push =\n-                build::mk_call_(cx, sp,\n-                                build::mk_access\n-                                (cx, sp,\n-                                 ids_ext(cx, ~[~\"tt\"]),\n-                                 id_ext(cx, ~\"push_all_move\")),\n-                                ~[e_to_toks]);\n+                build::mk_method_call(cx, sp,\n+                                      build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n+                                      id_ext(cx, ~\"push_all_move\"),\n+                                      ~[e_to_toks]);\n \n             ~[build::mk_stmt(cx, sp, e_push)]\n         }\n@@ -562,11 +557,10 @@ fn expand_tts(cx: @ext_ctxt,\n     // of quotes, for example) but at this point it seems not likely to be\n     // worth the hassle.\n \n-    let e_sp = build::mk_call_(cx, sp,\n-                               build::mk_access(cx, sp,\n-                                                ids_ext(cx, ~[~\"ext_cx\"]),\n-                                                id_ext(cx, ~\"call_site\")),\n-                               ~[]);\n+    let e_sp = build::mk_method_call(cx, sp,\n+                                     build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+                                     id_ext(cx, ~\"call_site\"),\n+                                     ~[]);\n \n     let stmt_let_sp = build::mk_local(cx, sp, false,\n                                       id_ext(cx, ~\"sp\"),\n@@ -590,13 +584,13 @@ fn expand_parse_call(cx: @ext_ctxt,\n                      tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n \n-    let cfg_call = || build::mk_call_(\n-        cx, sp, build::mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n-                                 id_ext(cx, ~\"cfg\")), ~[]);\n+    let cfg_call = || build::mk_method_call(\n+        cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+        id_ext(cx, ~\"cfg\"), ~[]);\n \n-    let parse_sess_call = || build::mk_call_(\n-        cx, sp, build::mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n-                                 id_ext(cx, ~\"parse_sess\")), ~[]);\n+    let parse_sess_call = || build::mk_method_call(\n+        cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+        id_ext(cx, ~\"parse_sess\"), ~[]);\n \n     let new_parser_call =\n         build::mk_call_global(cx, sp,\n@@ -609,9 +603,9 @@ fn expand_parse_call(cx: @ext_ctxt,\n                                 cfg_call(),\n                                 tts_expr]);\n \n-    build::mk_call_(cx, sp,\n-                    build::mk_access_(cx, sp, new_parser_call,\n-                                      id_ext(cx, parse_method)),\n-                    arg_exprs)\n+    build::mk_method_call(cx, sp,\n+                          new_parser_call,\n+                          id_ext(cx, parse_method),\n+                          arg_exprs)\n }\n "}]}