{"sha": "bdae618418abc58a1da5e565f2b124cdfebb5682", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYWU2MTg0MThhYmM1OGExZGE1ZTU2NWYyYjEyNGNkZmViYjU2ODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-16T09:12:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-16T09:12:04Z"}, "message": "Auto merge of #46722 - arielb1:single-self, r=eddyb\n\nfix broken assertion in type_param\n\nNested generics (aka method generics) in trait methods don't have an\n*additional* Self parameter in their own type parameter list (they have\na Self parameter in the parent generics), so don't try to check we're\ncorrectly adjusting for it.\n\nFixes #46568.\n\nr? @eddyb", "tree": {"sha": "10a38e8bb89b1a584a78b45131f992e40730fe4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10a38e8bb89b1a584a78b45131f992e40730fe4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdae618418abc58a1da5e565f2b124cdfebb5682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdae618418abc58a1da5e565f2b124cdfebb5682", "html_url": "https://github.com/rust-lang/rust/commit/bdae618418abc58a1da5e565f2b124cdfebb5682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdae618418abc58a1da5e565f2b124cdfebb5682/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00fbfcce961c9e2acb82473234140a376e093a7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/00fbfcce961c9e2acb82473234140a376e093a7a", "html_url": "https://github.com/rust-lang/rust/commit/00fbfcce961c9e2acb82473234140a376e093a7a"}, {"sha": "2679944653bb7ef1690840cc177da9896daa2963", "url": "https://api.github.com/repos/rust-lang/rust/commits/2679944653bb7ef1690840cc177da9896daa2963", "html_url": "https://github.com/rust-lang/rust/commit/2679944653bb7ef1690840cc177da9896daa2963"}], "stats": {"total": 99, "additions": 71, "deletions": 28}, "files": [{"sha": "220e1e971accd5362f019987f7993b9521e69f47", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bdae618418abc58a1da5e565f2b124cdfebb5682/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdae618418abc58a1da5e565f2b124cdfebb5682/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bdae618418abc58a1da5e565f2b124cdfebb5682", "patch": "@@ -787,25 +787,41 @@ impl<'a, 'gcx, 'tcx> Generics {\n         if let Some(idx) = param.idx.checked_sub(self.parent_count() as u32) {\n             // non-Self type parameters are always offset by exactly\n             // `self.regions.len()`. In the absence of a Self, this is obvious,\n-            // but even in the absence of a `Self` we just have to \"compensate\"\n+            // but even in the presence of a `Self` we just have to \"compensate\"\n             // for the regions:\n             //\n-            // For example, for `trait Foo<'a, 'b, T1, T2>`, the\n+            // Without a `Self` (or in a nested generics that doesn't have\n+            // a `Self` in itself, even through it parent does), for example\n+            // for `fn foo<'a, T1, T2>()`, the situation is:\n+            //     Substs:\n+            //         0  1  2\n+            //         'a T1 T2\n+            //     generics.types:\n+            //         0  1\n+            //         T1 T2\n+            //\n+            // And with a `Self`, for example for `trait Foo<'a, 'b, T1, T2>`, the\n             // situation is:\n             //     Substs:\n             //         0   1  2  3  4\n             //       Self 'a 'b  T1 T2\n             //     generics.types:\n             //         0  1  2\n             //       Self T1 T2\n-            // And it can be seen that to move from a substs offset to a\n-            // generics offset you just have to offset by the number of regions.\n+            //\n+            // And it can be seen that in both cases, to move from a substs\n+            // offset to a generics offset you just have to offset by the\n+            // number of regions.\n             let type_param_offset = self.regions.len();\n+\n+            let has_self = self.has_self && self.parent.is_none();\n+            let is_separated_self = type_param_offset != 0 && idx == 0 && has_self;\n+\n             if let Some(idx) = (idx as usize).checked_sub(type_param_offset) {\n-                assert!(!(self.has_self && idx == 0));\n+                assert!(!is_separated_self, \"found a Self after type_param_offset\");\n                 &self.types[idx]\n             } else {\n-                assert!(self.has_self && idx == 0);\n+                assert!(is_separated_self, \"non-Self param before type_param_offset\");\n                 &self.types[0]\n             }\n         } else {"}, {"sha": "0099a8bc10f5a2a2682174a5fdd5e911a288664b", "filename": "src/test/ui/lifetimes/lifetime-doesnt-live-long-enough.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdae618418abc58a1da5e565f2b124cdfebb5682/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdae618418abc58a1da5e565f2b124cdfebb5682/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.rs?ref=bdae618418abc58a1da5e565f2b124cdfebb5682", "patch": "@@ -33,11 +33,19 @@ struct Foo<T> {\n trait X<K>: Sized {\n     fn foo<'a, L: X<&'a Nested<K>>>();\n     //~^ ERROR may not live long enough\n+\n     // check that we give a sane error for `Self`\n     fn bar<'a, L: X<&'a Nested<Self>>>();\n     //~^ ERROR may not live long enough\n+\n+    // check that we give a sane error for nested generics\n+    fn baz<'a, L, M: X<&'a Nested<L>>>() {\n+        //~^ ERROR may not live long enough\n+    }\n }\n \n+trait TraitB {}\n+\n struct Nested<K>(K);\n impl<K> Nested<K> {\n     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {"}, {"sha": "05908606da77bb017c8bab396d623dcd25dfbc4e", "filename": "src/test/ui/lifetimes/lifetime-doesnt-live-long-enough.stderr", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bdae618418abc58a1da5e565f2b124cdfebb5682/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bdae618418abc58a1da5e565f2b124cdfebb5682/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr?ref=bdae618418abc58a1da5e565f2b124cdfebb5682", "patch": "@@ -41,54 +41,73 @@ note: ...so that the reference type `&'a Nested<K>` does not outlive the data it\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0309]: the parameter type `Self` may not live long enough\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:37:5\n+  --> $DIR/lifetime-doesnt-live-long-enough.rs:38:5\n    |\n-37 |     fn bar<'a, L: X<&'a Nested<Self>>>();\n+38 |     fn bar<'a, L: X<&'a Nested<Self>>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `Self: 'a`...\n note: ...so that the reference type `&'a Nested<Self>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:37:5\n+  --> $DIR/lifetime-doesnt-live-long-enough.rs:38:5\n    |\n-37 |     fn bar<'a, L: X<&'a Nested<Self>>>();\n+38 |     fn bar<'a, L: X<&'a Nested<Self>>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error[E0309]: the parameter type `L` may not live long enough\n+  --> $DIR/lifetime-doesnt-live-long-enough.rs:42:5\n+   |\n+42 |       fn baz<'a, L, M: X<&'a Nested<L>>>() {\n+   |       ^          - help: consider adding an explicit lifetime bound `L: 'a`...\n+   |  _____|\n+   | |\n+43 | |         //~^ ERROR may not live long enough\n+44 | |     }\n+   | |_____^\n+   |\n+note: ...so that the reference type `&'a Nested<L>` does not outlive the data it points at\n+  --> $DIR/lifetime-doesnt-live-long-enough.rs:42:5\n+   |\n+42 | /     fn baz<'a, L, M: X<&'a Nested<L>>>() {\n+43 | |         //~^ ERROR may not live long enough\n+44 | |     }\n+   | |_____^\n+\n error[E0309]: the parameter type `K` may not live long enough\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:43:5\n+  --> $DIR/lifetime-doesnt-live-long-enough.rs:51:5\n    |\n-42 |   impl<K> Nested<K> {\n+50 |   impl<K> Nested<K> {\n    |        - help: consider adding an explicit lifetime bound `K: 'a`...\n-43 | /     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n-44 | |         //~^ ERROR may not live long enough\n-45 | |     }\n+51 | /     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n+52 | |         //~^ ERROR may not live long enough\n+53 | |     }\n    | |_____^\n    |\n note: ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:43:5\n+  --> $DIR/lifetime-doesnt-live-long-enough.rs:51:5\n    |\n-43 | /     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n-44 | |         //~^ ERROR may not live long enough\n-45 | |     }\n+51 | /     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n+52 | |         //~^ ERROR may not live long enough\n+53 | |     }\n    | |_____^\n \n error[E0309]: the parameter type `M` may not live long enough\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:46:5\n+  --> $DIR/lifetime-doesnt-live-long-enough.rs:54:5\n    |\n-46 |       fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n+54 |       fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n    |       ^                                                -- help: consider adding an explicit lifetime bound `M: 'a`...\n    |  _____|\n    | |\n-47 | |         //~^ ERROR may not live long enough\n-48 | |     }\n+55 | |         //~^ ERROR may not live long enough\n+56 | |     }\n    | |_____^\n    |\n note: ...so that the reference type `&'a Nested<M>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:46:5\n+  --> $DIR/lifetime-doesnt-live-long-enough.rs:54:5\n    |\n-46 | /     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n-47 | |         //~^ ERROR may not live long enough\n-48 | |     }\n+54 | /     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n+55 | |         //~^ ERROR may not live long enough\n+56 | |     }\n    | |_____^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n "}]}