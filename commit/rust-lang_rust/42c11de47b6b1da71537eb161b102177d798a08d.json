{"sha": "42c11de47b6b1da71537eb161b102177d798a08d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYzExZGU0N2I2YjFkYTcxNTM3ZWIxNjFiMTAyMTc3ZDc5OGEwOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-27T07:12:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-27T07:12:11Z"}, "message": "Auto merge of #55053 - Emerentius:test_all_again, r=alexcrichton\n\nAdd option to run all tests, again\n\nThis is a repeat of https://github.com/rust-lang/rust/pull/53527, which had to be reverted to land https://github.com/rust-lang/rust/pull/54116. It will break clippy until `compiletest-rs` can be updated and I believe we're closing on a new release date, so this may need to be delayed again until after 1.30 is out (?)\n\nCloses #50363 again", "tree": {"sha": "00bcda90d5cd28cadfa3a14489cce58cf195e04d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00bcda90d5cd28cadfa3a14489cce58cf195e04d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42c11de47b6b1da71537eb161b102177d798a08d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42c11de47b6b1da71537eb161b102177d798a08d", "html_url": "https://github.com/rust-lang/rust/commit/42c11de47b6b1da71537eb161b102177d798a08d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42c11de47b6b1da71537eb161b102177d798a08d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f42cbde015c44a019e8b6dceca472a1532f36a", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f42cbde015c44a019e8b6dceca472a1532f36a", "html_url": "https://github.com/rust-lang/rust/commit/10f42cbde015c44a019e8b6dceca472a1532f36a"}, {"sha": "420541bc78e4d1157f0143680505d54e6f053a26", "url": "https://api.github.com/repos/rust-lang/rust/commits/420541bc78e4d1157f0143680505d54e6f053a26", "html_url": "https://github.com/rust-lang/rust/commit/420541bc78e4d1157f0143680505d54e6f053a26"}], "stats": {"total": 200, "additions": 119, "deletions": 81}, "files": [{"sha": "7c26d042a7ccfbed2c13de0a306848b1bca9d2fe", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 119, "deletions": 81, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/42c11de47b6b1da71537eb161b102177d798a08d/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c11de47b6b1da71537eb161b102177d798a08d/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=42c11de47b6b1da71537eb161b102177d798a08d", "patch": "@@ -89,7 +89,7 @@ const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in qu\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use {assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, ShouldPanic,\n+             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n              StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n              TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk};\n }\n@@ -357,12 +357,19 @@ pub enum OutputFormat {\n     Json,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum RunIgnored {\n+    Yes,\n+    No,\n+    Only,\n+}\n+\n #[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n     pub filter: Option<String>,\n     pub filter_exact: bool,\n-    pub run_ignored: bool,\n+    pub run_ignored: RunIgnored,\n     pub run_tests: bool,\n     pub bench_benchmarks: bool,\n     pub logfile: Option<PathBuf>,\n@@ -381,7 +388,7 @@ impl TestOpts {\n             list: false,\n             filter: None,\n             filter_exact: false,\n-            run_ignored: false,\n+            run_ignored: RunIgnored::No,\n             run_tests: false,\n             bench_benchmarks: false,\n             logfile: None,\n@@ -400,7 +407,8 @@ pub type OptRes = Result<TestOpts, String>;\n \n fn optgroups() -> getopts::Options {\n     let mut opts = getopts::Options::new();\n-    opts.optflag(\"\", \"ignored\", \"Run ignored tests\")\n+    opts.optflag(\"\", \"include-ignored\", \"Run ignored and not ignored tests\")\n+        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n         .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n         .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n         .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n@@ -499,8 +507,8 @@ Test Attributes:\n                      contain: #[should_panic(expected = \"foo\")].\n     #[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n-                     normal test runs. Running with --ignored will run these\n-                     tests.\"#,\n+                     normal test runs. Running with --ignored or --include-ignored will run\n+                     these tests.\"#,\n         usage = options.usage(&message)\n     );\n }\n@@ -553,7 +561,21 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         None\n     };\n \n-    let run_ignored = matches.opt_present(\"ignored\");\n+    let include_ignored = matches.opt_present(\"include-ignored\");\n+    if !allow_unstable && include_ignored {\n+        return Some(Err(\n+            \"The \\\"include-ignored\\\" flag is only accepted on the nightly compiler\".into()\n+        ));\n+    }\n+\n+    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n+        (true, true) => return Some(Err(\n+            \"the options --include-ignored and --ignored are mutually exclusive\".into()\n+        )),\n+        (true, false) => RunIgnored::Yes,\n+        (false, true) => RunIgnored::Only,\n+        (false, false) => RunIgnored::No,\n+    };\n     let quiet = matches.opt_present(\"quiet\");\n     let exact = matches.opt_present(\"exact\");\n     let list = matches.opt_present(\"list\");\n@@ -1305,55 +1327,36 @@ fn get_concurrency() -> usize {\n \n pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     let mut filtered = tests;\n-    // Remove tests that don't match the test filter\n-    filtered = match opts.filter {\n-        None => filtered,\n-        Some(ref filter) => filtered\n-            .into_iter()\n-            .filter(|test| {\n-                if opts.filter_exact {\n-                    test.desc.name.as_slice() == &filter[..]\n-                } else {\n-                    test.desc.name.as_slice().contains(&filter[..])\n-                }\n-            })\n-            .collect(),\n+    let matches_filter = |test: &TestDescAndFn, filter: &str| {\n+        let test_name = test.desc.name.as_slice();\n+\n+        match opts.filter_exact {\n+            true => test_name == filter,\n+            false => test_name.contains(filter),\n+        }\n     };\n \n-    // Skip tests that match any of the skip filters\n-    filtered = filtered\n-        .into_iter()\n-        .filter(|t| {\n-            !opts.skip.iter().any(|sf| {\n-                if opts.filter_exact {\n-                    t.desc.name.as_slice() == &sf[..]\n-                } else {\n-                    t.desc.name.as_slice().contains(&sf[..])\n-                }\n-            })\n-        })\n-        .collect();\n+    // Remove tests that don't match the test filter\n+    if let Some(ref filter) = opts.filter {\n+        filtered.retain(|test| matches_filter(test, filter));\n+    }\n \n-    // Maybe pull out the ignored test and unignore them\n-    filtered = if !opts.run_ignored {\n-        filtered\n-    } else {\n-        fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n-            if test.desc.ignore {\n-                let TestDescAndFn { desc, testfn } = test;\n-                Some(TestDescAndFn {\n-                    desc: TestDesc {\n-                        ignore: false,\n-                        ..desc\n-                    },\n-                    testfn,\n-                })\n-            } else {\n-                None\n-            }\n+    // Skip tests that match any of the skip filters\n+    filtered.retain(|test| {\n+        !opts.skip.iter().any(|sf| matches_filter(test, sf))\n+    });\n+\n+    // maybe unignore tests\n+    match opts.run_ignored {\n+        RunIgnored::Yes => {\n+            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n+        },\n+        RunIgnored::Only => {\n+            filtered.retain(|test| test.desc.ignore);\n+            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n         }\n-        filtered.into_iter().filter_map(filter).collect()\n-    };\n+        RunIgnored::No => {}\n+    }\n \n     // Sort the tests alphabetically\n     filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n@@ -1742,13 +1745,37 @@ pub mod bench {\n \n #[cfg(test)]\n mod tests {\n-    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, ShouldPanic,\n-               StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n-               TrIgnored, TrOk};\n+    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+               ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n+               TrFailedMsg, TrIgnored, TrOk};\n     use std::sync::mpsc::channel;\n     use bench;\n     use Bencher;\n \n+\n+    fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n+        vec![\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"1\"),\n+                    ignore: true,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"2\"),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+        ]\n+    }\n+\n     #[test]\n     pub fn do_not_run_ignored_tests() {\n         fn f() {\n@@ -1874,11 +1901,20 @@ mod tests {\n             \"filter\".to_string(),\n             \"--ignored\".to_string(),\n         ];\n-        let opts = match parse_opts(&args) {\n-            Some(Ok(o)) => o,\n-            _ => panic!(\"Malformed arg in parse_ignored_flag\"),\n-        };\n-        assert!((opts.run_ignored));\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Only);\n+    }\n+\n+    #[test]\n+    fn parse_include_ignored_flag() {\n+        let args = vec![\n+            \"progname\".to_string(),\n+            \"filter\".to_string(),\n+            \"-Zunstable-options\".to_string(),\n+            \"--include-ignored\".to_string(),\n+        ];\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Yes);\n     }\n \n     #[test]\n@@ -1888,35 +1924,33 @@ mod tests {\n \n         let mut opts = TestOpts::new();\n         opts.run_tests = true;\n-        opts.run_ignored = true;\n+        opts.run_ignored = RunIgnored::Only;\n \n-        let tests = vec![\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"1\"),\n-                    ignore: true,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"2\"),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-        ];\n+        let tests = one_ignored_one_unignored_test();\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n         assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n         assert!(!filtered[0].desc.ignore);\n     }\n \n+    #[test]\n+    pub fn run_include_ignored_option() {\n+        // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n+        // all tests and no test filtered out\n+\n+        let mut opts = TestOpts::new();\n+        opts.run_tests = true;\n+        opts.run_ignored = RunIgnored::Yes;\n+\n+        let tests = one_ignored_one_unignored_test();\n+        let filtered = filter_tests(&opts, tests);\n+\n+        assert_eq!(filtered.len(), 2);\n+        assert!(!filtered[0].desc.ignore);\n+        assert!(!filtered[1].desc.ignore);\n+    }\n+\n     #[test]\n     pub fn exact_filter_match() {\n         fn tests() -> Vec<TestDescAndFn> {\n@@ -2024,7 +2058,9 @@ mod tests {\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n+            \"test::parse_include_ignored_flag\".to_string(),\n             \"test::filter_for_ignored_option\".to_string(),\n+            \"test::run_include_ignored_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n         let tests = {\n@@ -2055,6 +2091,8 @@ mod tests {\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n+            \"test::parse_include_ignored_flag\".to_string(),\n+            \"test::run_include_ignored_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n "}]}