{"sha": "4497196ba56e5839bf4ef674851fd06d942c5544", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0OTcxOTZiYTU2ZTU4MzliZjRlZjY3NDg1MWZkMDZkOTQyYzU1NDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-31T06:37:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-31T06:37:18Z"}, "message": "Auto merge of #37439 - michaelwoerister:remove-sha256, r=alexcrichton\n\nReplace all uses of SHA-256 with BLAKE2b.\n\nRemoves the SHA-256 implementation and replaces all uses of it with BLAKE2b, which we already use for debuginfo type guids and incremental compilation hashes. It doesn't make much sense to have two different cryptographic hash implementations in the compiler and Blake has a few advantages over SHA-2 (computationally less expensive, hashes of up to 512 bits).", "tree": {"sha": "9d76606c57a2ce8b6b2f71be48e26ffbf7228ee3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d76606c57a2ce8b6b2f71be48e26ffbf7228ee3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4497196ba56e5839bf4ef674851fd06d942c5544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4497196ba56e5839bf4ef674851fd06d942c5544", "html_url": "https://github.com/rust-lang/rust/commit/4497196ba56e5839bf4ef674851fd06d942c5544", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4497196ba56e5839bf4ef674851fd06d942c5544/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f1fc865333482e709e96ec578135eb8bfbee930", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f1fc865333482e709e96ec578135eb8bfbee930", "html_url": "https://github.com/rust-lang/rust/commit/8f1fc865333482e709e96ec578135eb8bfbee930"}, {"sha": "9ef91945281fc8e3cd54685c3a46c7187b3a09f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef91945281fc8e3cd54685c3a46c7187b3a09f3", "html_url": "https://github.com/rust-lang/rust/commit/9ef91945281fc8e3cd54685c3a46c7187b3a09f3"}], "stats": {"total": 966, "additions": 154, "deletions": 812}, "files": [{"sha": "25192bfd27a440ef26e1c92bc5f8ab2ea4e2063a", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -121,7 +121,7 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n                      rustc_trans rustc_privacy rustc_lint rustc_plugin \\\n                      rustc_metadata syntax_ext proc_macro_plugin \\\n                      rustc_passes rustc_save_analysis rustc_const_eval \\\n-                     rustc_incremental syntax_pos rustc_errors proc_macro\n+                     rustc_incremental syntax_pos rustc_errors proc_macro rustc_data_structures\n DEPS_rustc_errors := log libc serialize syntax_pos\n DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags"}, {"sha": "5826995cc3cfc65da9a24a5b2678359f9853ce15", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -383,6 +383,7 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_lint 0.0.0\","}, {"sha": "d17402d21342b196338e5d80dab67da0431843fe", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -111,8 +111,6 @@ pub mod traits;\n pub mod ty;\n \n pub mod util {\n-    pub use rustc_back::sha2;\n-\n     pub mod common;\n     pub mod ppaux;\n     pub mod nodemap;"}, {"sha": "cca4069ba5a1799255be43dfd653e6d6b2f63ff5", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -405,6 +405,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n ///\n /// The same goes for endianess: We always convert multi-byte integers to little\n /// endian before hashing.\n+#[derive(Debug)]\n pub struct ArchIndependentHasher<H> {\n     inner: H,\n }\n@@ -413,6 +414,10 @@ impl<H> ArchIndependentHasher<H> {\n     pub fn new(inner: H) -> ArchIndependentHasher<H> {\n         ArchIndependentHasher { inner: inner }\n     }\n+\n+    pub fn into_inner(self) -> H {\n+        self.inner\n+    }\n }\n \n impl<H: Hasher> Hasher for ArchIndependentHasher<H> {"}, {"sha": "da5f787bdf31e3d9be859acdef4e83e178722215", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -36,9 +36,8 @@\n #![feature(rand)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(step_by)]\n #![cfg_attr(stage0, feature(question_mark))]\n-#![cfg_attr(test, feature(test, rand))]\n+#![cfg_attr(test, feature(rand))]\n \n extern crate syntax;\n extern crate libc;\n@@ -48,7 +47,6 @@ extern crate serialize;\n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod tempdir;\n-pub mod sha2;\n pub mod target;\n pub mod slice;\n pub mod dynamic_lib;"}, {"sha": "97fb39c17ea0e58e77aec4bdca3a9ca5cefdd58f", "filename": "src/librustc_back/sha2.rs", "status": "removed", "additions": 0, "deletions": 679, "changes": 679, "blob_url": "https://github.com/rust-lang/rust/blob/8f1fc865333482e709e96ec578135eb8bfbee930/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1fc865333482e709e96ec578135eb8bfbee930/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=8f1fc865333482e709e96ec578135eb8bfbee930", "patch": "@@ -1,679 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This module implements only the Sha256 function since that is all that is needed for internal\n-//! use. This implementation is not intended for external use or for any use where security is\n-//! important.\n-\n-use serialize::hex::ToHex;\n-\n-/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n-/// format.\n-fn write_u32_be(dst: &mut[u8], input: u32) {\n-    dst[0] = (input >> 24) as u8;\n-    dst[1] = (input >> 16) as u8;\n-    dst[2] = (input >> 8) as u8;\n-    dst[3] = input as u8;\n-}\n-\n-/// Read the value of a vector of bytes as a u32 value in big-endian format.\n-fn read_u32_be(input: &[u8]) -> u32 {\n-    (input[0] as u32) << 24 |\n-        (input[1] as u32) << 16 |\n-        (input[2] as u32) << 8 |\n-        (input[3] as u32)\n-}\n-\n-/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n-fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n-    assert!(dst.len() * 4 == input.len());\n-    let mut pos = 0;\n-    for chunk in input.chunks(4) {\n-        dst[pos] = read_u32_be(chunk);\n-        pos += 1;\n-    }\n-}\n-\n-trait ToBits: Sized {\n-    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n-    /// high-order value and the 2nd item is the low order value.\n-    fn to_bits(self) -> (Self, Self);\n-}\n-\n-impl ToBits for u64 {\n-    fn to_bits(self) -> (u64, u64) {\n-        (self >> 61, self << 3)\n-    }\n-}\n-\n-/// Adds the specified number of bytes to the bit count. panic!() if this would cause numeric\n-/// overflow.\n-fn add_bytes_to_bits(bits: u64, bytes: u64) -> u64 {\n-    let (new_high_bits, new_low_bits) = bytes.to_bits();\n-\n-    if new_high_bits > 0 {\n-        panic!(\"numeric overflow occurred.\")\n-    }\n-\n-    match bits.checked_add(new_low_bits) {\n-        Some(x) => x,\n-        None => panic!(\"numeric overflow occurred.\")\n-    }\n-}\n-\n-/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n-/// must be processed. The input() method takes care of processing and then clearing the buffer\n-/// automatically. However, other methods do not and require the caller to process the buffer. Any\n-/// method that modifies the buffer directory or provides the caller with bytes that can be modified\n-/// results in those bytes being marked as used by the buffer.\n-trait FixedBuffer {\n-    /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n-    /// function and then clear the buffer.\n-    fn input<F>(&mut self, input: &[u8], func: F) where\n-        F: FnMut(&[u8]);\n-\n-    /// Reset the buffer.\n-    fn reset(&mut self);\n-\n-    /// Zero the buffer up until the specified index. The buffer position currently must not be\n-    /// greater than that index.\n-    fn zero_until(&mut self, idx: usize);\n-\n-    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n-    /// remaining in the buffer.\n-    fn next<'s>(&'s mut self, len: usize) -> &'s mut [u8];\n-\n-    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n-    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n-\n-    /// Get the current position of the buffer.\n-    fn position(&self) -> usize;\n-\n-    /// Get the number of bytes remaining in the buffer until it is full.\n-    fn remaining(&self) -> usize;\n-\n-    /// Get the size of the buffer\n-    fn size(&self) -> usize;\n-}\n-\n-/// A FixedBuffer of 64 bytes useful for implementing Sha256 which has a 64 byte blocksize.\n-struct FixedBuffer64 {\n-    buffer: [u8; 64],\n-    buffer_idx: usize,\n-}\n-\n-impl FixedBuffer64 {\n-    /// Create a new FixedBuffer64\n-    fn new() -> FixedBuffer64 {\n-        FixedBuffer64 {\n-            buffer: [0; 64],\n-            buffer_idx: 0\n-        }\n-    }\n-}\n-\n-impl FixedBuffer for FixedBuffer64 {\n-    fn input<F>(&mut self, input: &[u8], mut func: F) where\n-        F: FnMut(&[u8]),\n-    {\n-        let mut i = 0;\n-\n-        let size = self.size();\n-\n-        // If there is already data in the buffer, copy as much as we can into it and process\n-        // the data if the buffer becomes full.\n-        if self.buffer_idx != 0 {\n-            let buffer_remaining = size - self.buffer_idx;\n-            if input.len() >= buffer_remaining {\n-                self.buffer[self.buffer_idx..size]\n-                    .copy_from_slice(&input[..buffer_remaining]);\n-                self.buffer_idx = 0;\n-                func(&self.buffer);\n-                i += buffer_remaining;\n-            } else {\n-                self.buffer[self.buffer_idx..self.buffer_idx + input.len()]\n-                    .copy_from_slice(input);\n-                self.buffer_idx += input.len();\n-                return;\n-            }\n-        }\n-\n-        // While we have at least a full buffer size chunk's worth of data, process that data\n-        // without copying it into the buffer\n-        while input.len() - i >= size {\n-            func(&input[i..i + size]);\n-            i += size;\n-        }\n-\n-        // Copy any input data into the buffer. At this point in the method, the amount of\n-        // data left in the input vector will be less than the buffer size and the buffer will\n-        // be empty.\n-        let input_remaining = input.len() - i;\n-        self.buffer[..input_remaining].copy_from_slice(&input[i..]);\n-        self.buffer_idx += input_remaining;\n-    }\n-\n-    fn reset(&mut self) {\n-        self.buffer_idx = 0;\n-    }\n-\n-    fn zero_until(&mut self, idx: usize) {\n-        assert!(idx >= self.buffer_idx);\n-        for slot in self.buffer[self.buffer_idx..idx].iter_mut() {\n-            *slot = 0;\n-        }\n-        self.buffer_idx = idx;\n-    }\n-\n-    fn next<'s>(&'s mut self, len: usize) -> &'s mut [u8] {\n-        self.buffer_idx += len;\n-        &mut self.buffer[self.buffer_idx - len..self.buffer_idx]\n-    }\n-\n-    fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n-        assert!(self.buffer_idx == 64);\n-        self.buffer_idx = 0;\n-        &self.buffer[..64]\n-    }\n-\n-    fn position(&self) -> usize { self.buffer_idx }\n-\n-    fn remaining(&self) -> usize { 64 - self.buffer_idx }\n-\n-    fn size(&self) -> usize { 64 }\n-}\n-\n-/// The StandardPadding trait adds a method useful for Sha256 to a FixedBuffer struct.\n-trait StandardPadding {\n-    /// Add padding to the buffer. The buffer must not be full when this method is called and is\n-    /// guaranteed to have exactly rem remaining bytes when it returns. If there are not at least\n-    /// rem bytes available, the buffer will be zero padded, processed, cleared, and then filled\n-    /// with zeros again until only rem bytes are remaining.\n-    fn standard_padding<F>(&mut self, rem: usize, func: F) where F: FnMut(&[u8]);\n-}\n-\n-impl <T: FixedBuffer> StandardPadding for T {\n-    fn standard_padding<F>(&mut self, rem: usize, mut func: F) where F: FnMut(&[u8]) {\n-        let size = self.size();\n-\n-        self.next(1)[0] = 128;\n-\n-        if self.remaining() < rem {\n-            self.zero_until(size);\n-            func(self.full_buffer());\n-        }\n-\n-        self.zero_until(size - rem);\n-    }\n-}\n-\n-/// The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n-/// family of digest functions.\n-pub trait Digest {\n-    /// Provide message data.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * input - A vector of message data\n-    fn input(&mut self, input: &[u8]);\n-\n-    /// Retrieve the digest result. This method may be called multiple times.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * out - the vector to hold the result. Must be large enough to contain output_bits().\n-    fn result(&mut self, out: &mut [u8]);\n-\n-    /// Reset the digest. This method must be called after result() and before supplying more\n-    /// data.\n-    fn reset(&mut self);\n-\n-    /// Get the output size in bits.\n-    fn output_bits(&self) -> usize;\n-\n-    /// Convenience function that feeds a string into a digest.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `input` The string to feed into the digest\n-    fn input_str(&mut self, input: &str) {\n-        self.input(input.as_bytes());\n-    }\n-\n-    /// Convenience function that retrieves the result of a digest as a\n-    /// newly allocated vec of bytes.\n-    fn result_bytes(&mut self) -> Vec<u8> {\n-        let mut buf = vec![0; (self.output_bits()+7)/8];\n-        self.result(&mut buf);\n-        buf\n-    }\n-\n-    /// Convenience function that retrieves the result of a digest as a\n-    /// String in hexadecimal format.\n-    fn result_str(&mut self) -> String {\n-        self.result_bytes().to_hex().to_string()\n-    }\n-}\n-\n-// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n-// functions\n-struct Engine256State {\n-    h0: u32,\n-    h1: u32,\n-    h2: u32,\n-    h3: u32,\n-    h4: u32,\n-    h5: u32,\n-    h6: u32,\n-    h7: u32,\n-}\n-\n-impl Engine256State {\n-    fn new(h: &[u32; 8]) -> Engine256State {\n-        Engine256State {\n-            h0: h[0],\n-            h1: h[1],\n-            h2: h[2],\n-            h3: h[3],\n-            h4: h[4],\n-            h5: h[5],\n-            h6: h[6],\n-            h7: h[7]\n-        }\n-    }\n-\n-    fn reset(&mut self, h: &[u32; 8]) {\n-        self.h0 = h[0];\n-        self.h1 = h[1];\n-        self.h2 = h[2];\n-        self.h3 = h[3];\n-        self.h4 = h[4];\n-        self.h5 = h[5];\n-        self.h6 = h[6];\n-        self.h7 = h[7];\n-    }\n-\n-    fn process_block(&mut self, data: &[u8]) {\n-        fn ch(x: u32, y: u32, z: u32) -> u32 {\n-            ((x & y) ^ ((!x) & z))\n-        }\n-\n-        fn maj(x: u32, y: u32, z: u32) -> u32 {\n-            ((x & y) ^ (x & z) ^ (y & z))\n-        }\n-\n-        fn sum0(x: u32) -> u32 {\n-            ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))\n-        }\n-\n-        fn sum1(x: u32) -> u32 {\n-            ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))\n-        }\n-\n-        fn sigma0(x: u32) -> u32 {\n-            ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3)\n-        }\n-\n-        fn sigma1(x: u32) -> u32 {\n-            ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n-        }\n-\n-        let mut a = self.h0;\n-        let mut b = self.h1;\n-        let mut c = self.h2;\n-        let mut d = self.h3;\n-        let mut e = self.h4;\n-        let mut f = self.h5;\n-        let mut g = self.h6;\n-        let mut h = self.h7;\n-\n-        let mut w = [0; 64];\n-\n-        // Sha-512 and Sha-256 use basically the same calculations which are implemented\n-        // by these macros. Inlining the calculations seems to result in better generated code.\n-        macro_rules! schedule_round { ($t:expr) => (\n-            w[$t] = sigma1(w[$t - 2]).wrapping_add(w[$t - 7])\n-                .wrapping_add(sigma0(w[$t - 15])).wrapping_add(w[$t - 16]);\n-            )\n-        }\n-\n-        macro_rules! sha2_round {\n-            ($A:ident, $B:ident, $C:ident, $D:ident,\n-             $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n-                {\n-                    $H = $H.wrapping_add(sum1($E)).wrapping_add(ch($E, $F, $G))\n-                        .wrapping_add($K[$t]).wrapping_add(w[$t]);\n-                    $D = $D.wrapping_add($H);\n-                    $H = $H.wrapping_add(sum0($A)).wrapping_add(maj($A, $B, $C));\n-                }\n-             )\n-        }\n-\n-        read_u32v_be(&mut w[0..16], data);\n-\n-        // Putting the message schedule inside the same loop as the round calculations allows for\n-        // the compiler to generate better code.\n-        for t in (0..48).step_by(8) {\n-            schedule_round!(t + 16);\n-            schedule_round!(t + 17);\n-            schedule_round!(t + 18);\n-            schedule_round!(t + 19);\n-            schedule_round!(t + 20);\n-            schedule_round!(t + 21);\n-            schedule_round!(t + 22);\n-            schedule_round!(t + 23);\n-\n-            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n-\n-        for t in (48..64).step_by(8) {\n-            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n-\n-        self.h0 = self.h0.wrapping_add(a);\n-        self.h1 = self.h1.wrapping_add(b);\n-        self.h2 = self.h2.wrapping_add(c);\n-        self.h3 = self.h3.wrapping_add(d);\n-        self.h4 = self.h4.wrapping_add(e);\n-        self.h5 = self.h5.wrapping_add(f);\n-        self.h6 = self.h6.wrapping_add(g);\n-        self.h7 = self.h7.wrapping_add(h);\n-    }\n-}\n-\n-static K32: [u32; 64] = [\n-    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n-    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n-    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n-    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n-    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n-    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n-    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n-    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n-    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n-    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n-    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n-    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n-    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n-    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n-    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n-    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n-];\n-\n-// A structure that keeps track of the state of the Sha-256 operation and contains the logic\n-// necessary to perform the final calculations.\n-struct Engine256 {\n-    length_bits: u64,\n-    buffer: FixedBuffer64,\n-    state: Engine256State,\n-    finished: bool,\n-}\n-\n-impl Engine256 {\n-    fn new(h: &[u32; 8]) -> Engine256 {\n-        Engine256 {\n-            length_bits: 0,\n-            buffer: FixedBuffer64::new(),\n-            state: Engine256State::new(h),\n-            finished: false\n-        }\n-    }\n-\n-    fn reset(&mut self, h: &[u32; 8]) {\n-        self.length_bits = 0;\n-        self.buffer.reset();\n-        self.state.reset(h);\n-        self.finished = false;\n-    }\n-\n-    fn input(&mut self, input: &[u8]) {\n-        assert!(!self.finished);\n-        // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = add_bytes_to_bits(self.length_bits, input.len() as u64);\n-        let self_state = &mut self.state;\n-        self.buffer.input(input, |input: &[u8]| { self_state.process_block(input) });\n-    }\n-\n-    fn finish(&mut self) {\n-        if !self.finished {\n-            let self_state = &mut self.state;\n-            self.buffer.standard_padding(8, |input: &[u8]| { self_state.process_block(input) });\n-            write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n-            write_u32_be(self.buffer.next(4), self.length_bits as u32);\n-            self_state.process_block(self.buffer.full_buffer());\n-\n-            self.finished = true;\n-        }\n-    }\n-}\n-\n-/// The SHA-256 hash algorithm\n-pub struct Sha256 {\n-    engine: Engine256\n-}\n-\n-impl Sha256 {\n-    /// Construct a new instance of a SHA-256 digest.\n-    /// Do not \u2013 under any circumstances \u2013 use this where timing attacks might be possible!\n-    pub fn new() -> Sha256 {\n-        Sha256 {\n-            engine: Engine256::new(&H256)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha256 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u32_be(&mut out[0..4], self.engine.state.h0);\n-        write_u32_be(&mut out[4..8], self.engine.state.h1);\n-        write_u32_be(&mut out[8..12], self.engine.state.h2);\n-        write_u32_be(&mut out[12..16], self.engine.state.h3);\n-        write_u32_be(&mut out[16..20], self.engine.state.h4);\n-        write_u32_be(&mut out[20..24], self.engine.state.h5);\n-        write_u32_be(&mut out[24..28], self.engine.state.h6);\n-        write_u32_be(&mut out[28..32], self.engine.state.h7);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H256);\n-    }\n-\n-    fn output_bits(&self) -> usize { 256 }\n-}\n-\n-static H256: [u32; 8] = [\n-    0x6a09e667,\n-    0xbb67ae85,\n-    0x3c6ef372,\n-    0xa54ff53a,\n-    0x510e527f,\n-    0x9b05688c,\n-    0x1f83d9ab,\n-    0x5be0cd19\n-];\n-\n-#[cfg(test)]\n-mod tests {\n-    #![allow(deprecated)]\n-    extern crate rand;\n-\n-    use self::rand::Rng;\n-    use self::rand::isaac::IsaacRng;\n-    use serialize::hex::FromHex;\n-    use std::u64;\n-    use super::{Digest, Sha256};\n-\n-    // A normal addition - no overflow occurs\n-    #[test]\n-    fn test_add_bytes_to_bits_ok() {\n-        assert!(super::add_bytes_to_bits(100, 10) == 180);\n-    }\n-\n-    // A simple failure case - adding 1 to the max value\n-    #[test]\n-    #[should_panic]\n-    fn test_add_bytes_to_bits_overflow() {\n-        super::add_bytes_to_bits(u64::MAX, 1);\n-    }\n-\n-    struct Test {\n-        input: String,\n-        output_str: String,\n-    }\n-\n-    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n-        // Test that it works when accepting the message all at once\n-        for t in tests {\n-            sh.reset();\n-            sh.input_str(&t.input);\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-        }\n-\n-        // Test that it works when accepting the message in pieces\n-        for t in tests {\n-            sh.reset();\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0 {\n-                let take = (left + 1) / 2;\n-                sh.input_str(&t.input[len - left..take + len - left]);\n-                left = left - take;\n-            }\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_sha256() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = vec!(\n-            Test {\n-                input: \"\".to_string(),\n-                output_str: \"e3b0c44298fc1c149afb\\\n-            f4c8996fb92427ae41e4649b934ca495991b7852b855\".to_string()\n-            },\n-            Test {\n-                input: \"The quick brown fox jumps over the lazy \\\n-                        dog\".to_string(),\n-                output_str: \"d7a8fbb307d7809469ca\\\n-            9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\".to_string()\n-            },\n-            Test {\n-                input: \"The quick brown fox jumps over the lazy \\\n-                        dog.\".to_string(),\n-                output_str: \"ef537f25c895bfa78252\\\n-            6529a9b63d97aa631564d5d789c2b765448c8635fb6c\".to_string()\n-            });\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh: Box<_> = box Sha256::new();\n-\n-        test_hash(&mut *sh, &tests);\n-    }\n-\n-    /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n-    /// correct.\n-    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: usize, expected: &str) {\n-        let total_size = 1000000;\n-        let buffer = vec![b'a'; blocksize * 2];\n-        let mut rng = IsaacRng::new_unseeded();\n-        let mut count = 0;\n-\n-        digest.reset();\n-\n-        while count < total_size {\n-            let next: usize = rng.gen_range(0, 2 * blocksize + 1);\n-            let remaining = total_size - count;\n-            let size = if next > remaining { remaining } else { next };\n-            digest.input(&buffer[..size]);\n-            count += size;\n-        }\n-\n-        let result_str = digest.result_str();\n-        let result_bytes = digest.result_bytes();\n-\n-        assert_eq!(expected, result_str);\n-\n-        let expected_vec: Vec<u8> = expected.from_hex()\n-                                            .unwrap()\n-                                            .into_iter()\n-                                            .collect();\n-        assert_eq!(expected_vec, result_bytes);\n-    }\n-\n-    #[test]\n-    fn test_1million_random_sha256() {\n-        let mut sh = Sha256::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            64,\n-            \"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0\");\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use super::{Sha256, Digest};\n-\n-    #[bench]\n-    pub fn sha256_10(b: &mut Bencher) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1; 10];\n-        b.iter(|| {\n-            sh.input(&bytes);\n-        });\n-        b.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha256_1k(b: &mut Bencher) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1; 1024];\n-        b.iter(|| {\n-            sh.input(&bytes);\n-        });\n-        b.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha256_64k(b: &mut Bencher) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1; 65536];\n-        b.iter(|| {\n-            sh.input(&bytes);\n-        });\n-        b.bytes = bytes.len() as u64;\n-    }\n-}"}, {"sha": "8c82c135dc426b5a30cac5f4c5bf5d3d6b5bf096", "filename": "src/librustc_data_structures/blake2b.rs", "status": "modified", "additions": 68, "deletions": 16, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -20,17 +20,25 @@\n // implementation. If you have the luxury of being able to use crates from\n // crates.io, you can go there and find still faster implementations.\n \n+use std::mem;\n+use std::slice;\n+\n pub struct Blake2bCtx {\n     b: [u8; 128],\n     h: [u64; 8],\n     t: [u64; 2],\n     c: usize,\n-    outlen: usize,\n+    outlen: u16,\n+    finalized: bool\n }\n \n impl ::std::fmt::Debug for Blake2bCtx {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        write!(fmt, \"{:?}\", self.h)\n+        try!(write!(fmt, \"hash: \"));\n+        for v in &self.h[..] {\n+            try!(write!(fmt, \"{:x}\", v));\n+        }\n+        Ok(())\n     }\n }\n \n@@ -136,15 +144,16 @@ fn blake2b_compress(ctx: &mut Blake2bCtx, last: bool) {\n     }\n }\n \n-pub fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n+fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n     assert!(outlen > 0 && outlen <= 64 && key.len() <= 64);\n \n     let mut ctx = Blake2bCtx {\n         b: [0; 128],\n         h: BLAKE2B_IV,\n         t: [0; 2],\n         c: 0,\n-        outlen: outlen,\n+        outlen: outlen as u16,\n+        finalized: false,\n     };\n \n     ctx.h[0] ^= 0x01010000 ^ ((key.len() << 8) as u64) ^ (outlen as u64);\n@@ -157,8 +166,9 @@ pub fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n     ctx\n }\n \n-pub fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8])\n-{\n+fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8]) {\n+    assert!(!ctx.finalized, \"Blake2bCtx already finalized\");\n+\n     let mut bytes_to_copy = data.len();\n     let mut space_in_buffer = ctx.b.len() - ctx.c;\n \n@@ -183,8 +193,10 @@ pub fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8])\n     }\n }\n \n-pub fn blake2b_final(mut ctx: Blake2bCtx, out: &mut [u8])\n+fn blake2b_final(ctx: &mut Blake2bCtx)\n {\n+    assert!(!ctx.finalized, \"Blake2bCtx already finalized\");\n+\n     ctx.t[0] = ctx.t[0].wrapping_add(ctx.c as u64);\n     if ctx.t[0] < ctx.c as u64 {\n         ctx.t[1] += 1;\n@@ -195,7 +207,7 @@ pub fn blake2b_final(mut ctx: Blake2bCtx, out: &mut [u8])\n         ctx.c += 1;\n     }\n \n-    blake2b_compress(&mut ctx, true);\n+    blake2b_compress(ctx, true);\n \n     if cfg!(target_endian = \"big\") {\n         // Make sure that the data is in memory in little endian format, as is\n@@ -205,13 +217,13 @@ pub fn blake2b_final(mut ctx: Blake2bCtx, out: &mut [u8])\n         }\n     }\n \n-    checked_mem_copy(&ctx.h, out, ctx.outlen);\n+    ctx.finalized = true;\n }\n \n #[inline(always)]\n fn checked_mem_copy<T1, T2>(from: &[T1], to: &mut [T2], byte_count: usize) {\n-    let from_size = from.len() * ::std::mem::size_of::<T1>();\n-    let to_size = to.len() * ::std::mem::size_of::<T2>();\n+    let from_size = from.len() * mem::size_of::<T1>();\n+    let to_size = to.len() * mem::size_of::<T2>();\n     assert!(from_size >= byte_count);\n     assert!(to_size >= byte_count);\n     let from_byte_ptr = from.as_ptr() as * const u8;\n@@ -225,7 +237,45 @@ pub fn blake2b(out: &mut [u8], key: &[u8],  data: &[u8])\n {\n     let mut ctx = blake2b_new(out.len(), key);\n     blake2b_update(&mut ctx, data);\n-    blake2b_final(ctx, out);\n+    blake2b_final(&mut ctx);\n+    checked_mem_copy(&ctx.h, out, ctx.outlen as usize);\n+}\n+\n+pub struct Blake2bHasher(Blake2bCtx);\n+\n+impl ::std::hash::Hasher for Blake2bHasher {\n+    fn write(&mut self, bytes: &[u8]) {\n+        blake2b_update(&mut self.0, bytes);\n+    }\n+\n+    fn finish(&self) -> u64 {\n+        assert!(self.0.outlen == 8,\n+                \"Hasher initialized with incompatible output length\");\n+        u64::from_le(self.0.h[0])\n+    }\n+}\n+\n+impl Blake2bHasher {\n+    pub fn new(outlen: usize, key: &[u8]) -> Blake2bHasher {\n+        Blake2bHasher(blake2b_new(outlen, key))\n+    }\n+\n+    pub fn finalize(&mut self) -> &[u8] {\n+        if !self.0.finalized {\n+            blake2b_final(&mut self.0);\n+        }\n+        debug_assert!(mem::size_of_val(&self.0.h) >= self.0.outlen as usize);\n+        let raw_ptr = (&self.0.h[..]).as_ptr() as * const u8;\n+        unsafe {\n+            slice::from_raw_parts(raw_ptr, self.0.outlen as usize)\n+        }\n+    }\n+}\n+\n+impl ::std::fmt::Debug for Blake2bHasher {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{:?}\", self.0)\n+    }\n }\n \n #[cfg(test)]\n@@ -245,6 +295,8 @@ fn selftest_seq(out: &mut [u8], seed: u32)\n #[test]\n fn blake2b_selftest()\n {\n+    use std::hash::Hasher;\n+\n     // grand hash of hash results\n     const BLAKE2B_RES: [u8; 32] = [\n         0xC2, 0x3A, 0x78, 0x00, 0xD9, 0x81, 0x23, 0xBD,\n@@ -261,7 +313,7 @@ fn blake2b_selftest()\n     let mut md = [0u8; 64];\n     let mut key = [0u8; 64];\n \n-    let mut ctx = blake2b_new(32, &[]);\n+    let mut hasher = Blake2bHasher::new(32, &[]);\n \n     for i in 0 .. 4 {\n        let outlen = B2B_MD_LEN[i];\n@@ -270,16 +322,16 @@ fn blake2b_selftest()\n \n             selftest_seq(&mut data[.. inlen], inlen as u32); // unkeyed hash\n             blake2b(&mut md[.. outlen], &[], &data[.. inlen]);\n-            blake2b_update(&mut ctx, &md[.. outlen]); // hash the hash\n+            hasher.write(&md[.. outlen]); // hash the hash\n \n             selftest_seq(&mut key[0 .. outlen], outlen as u32); // keyed hash\n             blake2b(&mut md[.. outlen], &key[.. outlen], &data[.. inlen]);\n-            blake2b_update(&mut ctx, &md[.. outlen]); // hash the hash\n+            hasher.write(&md[.. outlen]); // hash the hash\n        }\n     }\n \n     // compute and compare the hash of hashes\n-    blake2b_final(ctx, &mut md[..]);\n+    let md = hasher.finalize();\n     for i in 0 .. 32 {\n         assert_eq!(md[i], BLAKE2B_RES[i]);\n     }"}, {"sha": "50fd1d802b7ffe8e44ee6b8b148fb9d35f638e1c", "filename": "src/librustc_data_structures/fmt_wrap.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffmt_wrap.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+// Provide some more formatting options for some data types (at the moment\n+// that's just `{:x}` for slices of u8).\n+\n+pub struct FmtWrap<T>(pub T);\n+\n+impl<'a> fmt::LowerHex for FmtWrap<&'a [u8]> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        for byte in self.0.iter() {\n+            try!(write!(formatter, \"{:02x}\", byte));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_lower_hex() {\n+    let bytes: &[u8] = &[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n+    assert_eq!(\"0123456789abcdef\", &format!(\"{:x}\", FmtWrap(bytes)));\n+}"}, {"sha": "fc963dac9495fc1b95d0350d05d99c5024281843", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -49,6 +49,7 @@ pub mod accumulate_vec;\n pub mod bitslice;\n pub mod blake2b;\n pub mod bitvec;\n+pub mod fmt_wrap;\n pub mod graph;\n pub mod ivar;\n pub mod indexed_set;"}, {"sha": "99d3e155e89365b2b4a504fc8d839be54bc82653", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -18,6 +18,7 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_borrowck = { path = \"../librustc_borrowck\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_lint = { path = \"../librustc_lint\" }"}, {"sha": "da1d5ad2c4a9b95ed5c8c6816545336d3bcf8f5f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -12,6 +12,9 @@ use rustc::hir;\n use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n use rustc::hir::def::DefMap;\n use rustc::hir::lowering::lower_crate;\n+use rustc_data_structures::blake2b::Blake2bHasher;\n+use rustc_data_structures::fmt_wrap::FmtWrap;\n+use rustc::ty::util::ArchIndependentHasher;\n use rustc_mir as mir;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n use rustc::session::config::{self, Input, OutputFilenames, OutputType,\n@@ -23,7 +26,6 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n-use rustc_back::sha2::{Sha256, Digest};\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n@@ -1221,7 +1223,16 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n }\n \n pub fn compute_crate_disambiguator(session: &Session) -> String {\n-    let mut hasher = Sha256::new();\n+    use std::hash::Hasher;\n+\n+    // The crate_disambiguator is a 128 bit hash. The disambiguator is fed\n+    // into various other hashes quite a bit (symbol hashes, incr. comp. hashes,\n+    // debuginfo type IDs, etc), so we don't want it to be too wide. 128 bits\n+    // should still be safe enough to avoid collisions in practice.\n+    // FIXME(mw): It seems that the crate_disambiguator is used everywhere as\n+    //            a hex-string instead of raw bytes. We should really use the\n+    //            smaller representation.\n+    let mut hasher = ArchIndependentHasher::new(Blake2bHasher::new(128 / 8, &[]));\n \n     let mut metadata = session.opts.cg.metadata.clone();\n     // We don't want the crate_disambiguator to dependent on the order\n@@ -1230,24 +1241,23 @@ pub fn compute_crate_disambiguator(session: &Session) -> String {\n     // Every distinct -C metadata value is only incorporated once:\n     metadata.dedup();\n \n-    hasher.input_str(\"metadata\");\n+    hasher.write(b\"metadata\");\n     for s in &metadata {\n         // Also incorporate the length of a metadata string, so that we generate\n         // different values for `-Cmetadata=ab -Cmetadata=c` and\n         // `-Cmetadata=a -Cmetadata=bc`\n-        hasher.input_str(&format!(\"{}\", s.len())[..]);\n-        hasher.input_str(&s[..]);\n+        hasher.write_usize(s.len());\n+        hasher.write(s.as_bytes());\n     }\n \n-    let mut hash = hasher.result_str();\n+    let mut hash_state = hasher.into_inner();\n+    let hash_bytes = hash_state.finalize();\n \n     // If this is an executable, add a special suffix, so that we don't get\n     // symbol conflicts when linking against a library of the same name.\n-    if session.crate_types.borrow().contains(&config::CrateTypeExecutable) {\n-       hash.push_str(\"-exe\");\n-    }\n+    let is_exe = session.crate_types.borrow().contains(&config::CrateTypeExecutable);\n \n-    hash\n+    format!(\"{:x}{}\", FmtWrap(hash_bytes), if is_exe { \"-exe\" } else {\"\"})\n }\n \n pub fn build_output_filenames(input: &Input,"}, {"sha": "cb78baa12a6ad052f5c08170eef8c119fe4412ca", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -42,6 +42,7 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n extern crate rustc_const_eval;\n+extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n extern crate rustc_passes;\n extern crate rustc_lint;"}, {"sha": "49683a81227b1ebfb2636d73cbdee54a7ff5b534", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -8,21 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::Hasher;\n use std::mem;\n-use rustc_data_structures::blake2b;\n+use rustc_data_structures::blake2b::Blake2bHasher;\n+use rustc::ty::util::ArchIndependentHasher;\n use ich::Fingerprint;\n \n #[derive(Debug)]\n pub struct IchHasher {\n-    state: blake2b::Blake2bCtx,\n+    state: ArchIndependentHasher<Blake2bHasher>,\n     bytes_hashed: u64,\n }\n \n impl IchHasher {\n     pub fn new() -> IchHasher {\n+        let hash_size = mem::size_of::<Fingerprint>();\n         IchHasher {\n-            state: blake2b::blake2b_new(mem::size_of::<Fingerprint>(), &[]),\n+            state: ArchIndependentHasher::new(Blake2bHasher::new(hash_size, &[])),\n             bytes_hashed: 0\n         }\n     }\n@@ -33,40 +34,19 @@ impl IchHasher {\n \n     pub fn finish(self) -> Fingerprint {\n         let mut fingerprint = Fingerprint::zero();\n-        blake2b::blake2b_final(self.state, &mut fingerprint.0);\n+        fingerprint.0.copy_from_slice(self.state.into_inner().finalize());\n         fingerprint\n     }\n }\n \n-impl Hasher for IchHasher {\n+impl ::std::hash::Hasher for IchHasher {\n     fn finish(&self) -> u64 {\n         bug!(\"Use other finish() implementation to get the full 128-bit hash.\");\n     }\n \n     #[inline]\n     fn write(&mut self, bytes: &[u8]) {\n-        blake2b::blake2b_update(&mut self.state, bytes);\n+        self.state.write(bytes);\n         self.bytes_hashed += bytes.len() as u64;\n     }\n-\n-    #[inline]\n-    fn write_u16(&mut self, i: u16) {\n-        self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i.to_le()) })\n-    }\n-\n-    #[inline]\n-    fn write_u32(&mut self, i: u32) {\n-        self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i.to_le()) })\n-    }\n-\n-    #[inline]\n-    fn write_u64(&mut self, i: u64) {\n-        self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i.to_le()) })\n-    }\n-\n-    #[inline]\n-    fn write_usize(&mut self, i: usize) {\n-        // always hash as u64, so we don't depend on the size of `usize`\n-        self.write_u64(i as u64);\n-    }\n }"}, {"sha": "bf2a5d76c10d493f27b645bce243b5e323ae2e19", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -99,7 +99,8 @@\n \n use common::SharedCrateContext;\n use monomorphize::Instance;\n-use util::sha2::{Digest, Sha256};\n+use rustc_data_structures::fmt_wrap::FmtWrap;\n+use rustc_data_structures::blake2b::Blake2bHasher;\n \n use rustc::middle::weak_lang_items;\n use rustc::hir::def_id::LOCAL_CRATE;\n@@ -113,21 +114,6 @@ use rustc::util::common::record_time;\n \n use syntax::attr;\n use syntax::parse::token::{self, InternedString};\n-use serialize::hex::ToHex;\n-\n-use std::hash::Hasher;\n-\n-struct Sha256Hasher<'a>(&'a mut Sha256);\n-\n-impl<'a> Hasher for Sha256Hasher<'a> {\n-    fn write(&mut self, msg: &[u8]) {\n-        self.0.input(msg)\n-    }\n-\n-    fn finish(&self) -> u64 {\n-        bug!(\"Sha256Hasher::finish should not be called\");\n-    }\n-}\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n@@ -149,12 +135,9 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     let tcx = scx.tcx();\n \n-    let mut hash_state = scx.symbol_hasher().borrow_mut();\n-    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n-        hash_state.reset();\n-        let hasher = Sha256Hasher(&mut hash_state);\n-        let mut hasher = ty::util::TypeIdHasher::new(tcx, hasher);\n+    let mut hasher = ty::util::TypeIdHasher::new(tcx, Blake2bHasher::new(8, &[]));\n \n+    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n@@ -175,8 +158,9 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     });\n \n     // 64 bits should be enough to avoid collisions.\n-    let output = hash_state.result_bytes();\n-    format!(\"h{}\", output[..8].to_hex())\n+    let mut hasher = hasher.into_inner();\n+    let hash_bytes = hasher.finalize();\n+    format!(\"h{:x}\", FmtWrap(hash_bytes))\n }\n \n impl<'a, 'tcx> Instance<'tcx> {"}, {"sha": "977ababbf56883c5b4f83386e2b52b82c4372f4d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -79,7 +79,6 @@ use type_::Type;\n use type_of;\n use value::Value;\n use Disr;\n-use util::sha2::Sha256;\n use util::nodemap::{NodeSet, FnvHashMap, FnvHashSet};\n \n use arena::TypedArena;\n@@ -1550,7 +1549,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n                                              export_map,\n-                                             Sha256::new(),\n                                              link_meta.clone(),\n                                              reachable,\n                                              check_overflow);"}, {"sha": "fc75b1018ec35ef4bdd73b5e3718eac19879a3f5", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -32,7 +32,6 @@ use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n use symbol_map::SymbolMap;\n-use util::sha2::Sha256;\n use util::nodemap::{NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n use std::ffi::{CStr, CString};\n@@ -69,7 +68,6 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     export_map: ExportMap,\n     reachable: NodeSet,\n     link_meta: LinkMeta,\n-    symbol_hasher: RefCell<Sha256>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n@@ -436,7 +434,6 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                export_map: ExportMap,\n-               symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet,\n                check_overflow: bool)\n@@ -496,7 +493,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             export_map: export_map,\n             reachable: reachable,\n             link_meta: link_meta,\n-            symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n             stats: Stats {\n                 n_glues_created: Cell::new(0),\n@@ -575,10 +571,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         })\n     }\n \n-    pub fn symbol_hasher(&self) -> &RefCell<Sha256> {\n-        &self.symbol_hasher\n-    }\n-\n     pub fn metadata_symbol_name(&self) -> String {\n         format!(\"rust_metadata_{}_{}\",\n                 self.link_meta().crate_name,\n@@ -877,10 +869,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().llsizingtypes\n     }\n \n-    pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n-        &self.shared.symbol_hasher\n-    }\n-\n     pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n         &self.local().type_hashcodes\n     }"}, {"sha": "863aecc824433f4954f5847d340d4caad28b827b", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4497196ba56e5839bf4ef674851fd06d942c5544/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=4497196ba56e5839bf4ef674851fd06d942c5544", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n-use rustc_data_structures::blake2b;\n+use rustc_data_structures::blake2b::Blake2bHasher;\n use {type_of, machine, monomorphize};\n use common::CrateContext;\n use type_::Type;\n@@ -149,10 +149,16 @@ impl<'tcx> TypeMap<'tcx> {\n             None => { /* generate one */}\n         };\n \n+        // The hasher we are using to generate the UniqueTypeId. We want\n+        // something that provides more than the 64 bits of the DefaultHasher.\n+        const TYPE_ID_HASH_LENGTH: usize = 20;\n+\n         let mut type_id_hasher = TypeIdHasher::new(cx.tcx(),\n-                                                   DebugInfoTypeIdHasher::new());\n+                                                   Blake2bHasher::new(TYPE_ID_HASH_LENGTH, &[]));\n         type_id_hasher.visit_ty(type_);\n-        let hash = type_id_hasher.into_inner().into_hash();\n+        let mut hash_state = type_id_hasher.into_inner();\n+        let hash: &[u8] = hash_state.finalize();\n+        debug_assert!(hash.len() == TYPE_ID_HASH_LENGTH);\n \n         let mut unique_type_id = String::with_capacity(TYPE_ID_HASH_LENGTH * 2);\n \n@@ -164,39 +170,6 @@ impl<'tcx> TypeMap<'tcx> {\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n         return UniqueTypeId(key);\n-\n-        // The hasher we are using to generate the UniqueTypeId. We want\n-        // something that provides more than the 64 bits of the DefaultHasher.\n-        const TYPE_ID_HASH_LENGTH: usize = 20;\n-\n-        struct DebugInfoTypeIdHasher {\n-            state: blake2b::Blake2bCtx\n-        }\n-\n-        impl ::std::hash::Hasher for DebugInfoTypeIdHasher {\n-            fn finish(&self) -> u64 {\n-                unimplemented!()\n-            }\n-\n-            #[inline]\n-            fn write(&mut self, bytes: &[u8]) {\n-                blake2b::blake2b_update(&mut self.state, bytes);\n-            }\n-        }\n-\n-        impl DebugInfoTypeIdHasher {\n-            fn new() -> DebugInfoTypeIdHasher {\n-                DebugInfoTypeIdHasher {\n-                    state: blake2b::blake2b_new(TYPE_ID_HASH_LENGTH, &[])\n-                }\n-            }\n-\n-            fn into_hash(self) -> [u8; TYPE_ID_HASH_LENGTH] {\n-                let mut hash = [0u8; TYPE_ID_HASH_LENGTH];\n-                blake2b::blake2b_final(self.state, &mut hash);\n-                hash\n-            }\n-        }\n     }\n \n     // Get the UniqueTypeId for an enum variant. Enum variants are not really"}]}