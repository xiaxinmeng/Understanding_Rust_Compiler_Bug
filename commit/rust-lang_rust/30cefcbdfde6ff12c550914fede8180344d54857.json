{"sha": "30cefcbdfde6ff12c550914fede8180344d54857", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwY2VmY2JkZmRlNmZmMTJjNTUwOTE0ZmVkZTgxODAzNDRkNTQ4NTc=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-15T03:35:22Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-19T15:43:23Z"}, "message": "libcore: use `#[deriving(Copy)]`", "tree": {"sha": "a4f3d842e7003034b703dda751aceda67287e22b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4f3d842e7003034b703dda751aceda67287e22b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30cefcbdfde6ff12c550914fede8180344d54857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30cefcbdfde6ff12c550914fede8180344d54857", "html_url": "https://github.com/rust-lang/rust/commit/30cefcbdfde6ff12c550914fede8180344d54857", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30cefcbdfde6ff12c550914fede8180344d54857/comments", "author": null, "committer": null, "parents": [{"sha": "c32a48293aab01133ed9e131fe452fd8c88ff9de", "url": "https://api.github.com/repos/rust-lang/rust/commits/c32a48293aab01133ed9e131fe452fd8c88ff9de", "html_url": "https://github.com/rust-lang/rust/commit/c32a48293aab01133ed9e131fe452fd8c88ff9de"}], "stats": {"total": 208, "additions": 57, "deletions": 151}, "files": [{"sha": "f6bc4dbde387ae35a13bcf88ee1439ef8f2b9077", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -16,7 +16,6 @@ pub use self::Ordering::*;\n \n use intrinsics;\n use cell::UnsafeCell;\n-use kinds::Copy;\n \n /// A boolean type which can be safely shared between threads.\n #[stable]\n@@ -53,6 +52,7 @@ pub struct AtomicPtr<T> {\n /// Rust's memory orderings are [the same as\n /// C++'s](http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync).\n #[stable]\n+#[deriving(Copy)]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations.\n     #[stable]\n@@ -77,8 +77,6 @@ pub enum Ordering {\n     SeqCst,\n }\n \n-impl Copy for Ordering {}\n-\n /// An `AtomicBool` initialized to `false`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_BOOL: AtomicBool ="}, {"sha": "6e793be67e2505823258257d69854316c3aa8106", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -43,7 +43,7 @@\n \n pub use self::Ordering::*;\n \n-use kinds::{Copy, Sized};\n+use kinds::Sized;\n use option::Option::{mod, Some, None};\n \n /// Trait for values that can be compared for equality and inequality.\n@@ -94,7 +94,7 @@ pub trait Eq<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n }\n \n /// An ordering is, e.g, a result of a comparison between two values.\n-#[deriving(Clone, PartialEq, Show)]\n+#[deriving(Clone, Copy, PartialEq, Show)]\n #[stable]\n pub enum Ordering {\n    /// An ordering where a compared value is less [than another].\n@@ -105,8 +105,6 @@ pub enum Ordering {\n    Greater = 1i,\n }\n \n-impl Copy for Ordering {}\n-\n impl Ordering {\n     /// Reverse the `Ordering`, so that `Less` becomes `Greater` and\n     /// vice versa."}, {"sha": "79fb11f385433e6d873ba04d5c4b4e4fb92ff831", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -44,10 +44,9 @@ pub type Result = result::Result<(), Error>;\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n #[experimental = \"core and I/O reconciliation may alter this definition\"]\n+#[deriving(Copy)]\n pub struct Error;\n \n-impl Copy for Error {}\n-\n /// A collection of methods that are required to format a message into a stream.\n ///\n /// This trait is the type which this modules requires when formatting\n@@ -104,6 +103,7 @@ enum Void {}\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[experimental = \"implementation detail of the `format_args!` macro\"]\n+#[deriving(Copy)]\n pub struct Argument<'a> {\n     value: &'a Void,\n     formatter: fn(&Void, &mut Formatter) -> Result,\n@@ -137,8 +137,6 @@ impl<'a> Argument<'a> {\n     }\n }\n \n-impl<'a> Copy for Argument<'a> {}\n-\n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure."}, {"sha": "cd8f226172a66e49ecbd1b0b3d398dbf29f992cb", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -16,7 +16,6 @@\n \n use fmt;\n use iter::DoubleEndedIteratorExt;\n-use kinds::Copy;\n use num::{Int, cast};\n use slice::SliceExt;\n \n@@ -109,14 +108,12 @@ radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n                              x @ 10 ... 15 => b'A' + (x - 10) }\n \n /// A radix with in the range of `2..36`.\n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, Copy, PartialEq)]\n #[unstable = \"may be renamed or move to a different module\"]\n pub struct Radix {\n     base: u8,\n }\n \n-impl Copy for Radix {}\n-\n impl Radix {\n     fn new(base: u8) -> Radix {\n         assert!(2 <= base && base <= 36, \"the base must be in the range of 2..36: {}\", base);\n@@ -137,10 +134,9 @@ impl GenericRadix for Radix {\n \n /// A helper type for formatting radixes.\n #[unstable = \"may be renamed or move to a different module\"]\n+#[deriving(Copy)]\n pub struct RadixFmt<T, R>(T, R);\n \n-impl<T,R> Copy for RadixFmt<T,R> where T: Copy, R: Copy {}\n-\n /// Constructs a radix formatter in the range of `2..36`.\n ///\n /// # Example"}, {"sha": "35dd0390f30872bb64709c3a0ec882e127434e9d", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -20,17 +20,16 @@ pub use self::Alignment::*;\n pub use self::Count::*;\n pub use self::Position::*;\n pub use self::Flag::*;\n-use kinds::Copy;\n \n #[doc(hidden)]\n+#[deriving(Copy)]\n pub struct Argument<'a> {\n     pub position: Position,\n     pub format: FormatSpec,\n }\n \n-impl<'a> Copy for Argument<'a> {}\n-\n #[doc(hidden)]\n+#[deriving(Copy)]\n pub struct FormatSpec {\n     pub fill: char,\n     pub align: Alignment,\n@@ -39,10 +38,8 @@ pub struct FormatSpec {\n     pub width: Count,\n }\n \n-impl Copy for FormatSpec {}\n-\n /// Possible alignments that can be requested as part of a formatting directive.\n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n pub enum Alignment {\n     /// Indication that contents should be left-aligned.\n     AlignLeft,\n@@ -54,27 +51,24 @@ pub enum Alignment {\n     AlignUnknown,\n }\n \n-impl Copy for Alignment {}\n-\n #[doc(hidden)]\n+#[deriving(Copy)]\n pub enum Count {\n     CountIs(uint), CountIsParam(uint), CountIsNextParam, CountImplied,\n }\n \n-impl Copy for Count {}\n-\n #[doc(hidden)]\n+#[deriving(Copy)]\n pub enum Position {\n     ArgumentNext, ArgumentIs(uint)\n }\n \n-impl Copy for Position {}\n-\n /// Flags which can be passed to formatting via a directive.\n ///\n /// These flags are discovered through the `flags` field of the `Formatter`\n /// structure. The flag in that structure is a union of these flags into a\n /// `uint` where each flag's discriminant is the corresponding bit.\n+#[deriving(Copy)]\n pub enum Flag {\n     /// A flag which enables number formatting to always print the sign of a\n     /// number.\n@@ -89,5 +83,3 @@ pub enum Flag {\n     /// being aware of the sign to be printed.\n     FlagSignAwareZeroPad,\n }\n-\n-impl Copy for Flag {}"}, {"sha": "d8f103fa0f3dcd03b4bcdf4593a37aa9ab15be16", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -42,11 +42,10 @@\n #![experimental]\n #![allow(missing_docs)]\n \n-use kinds::Copy;\n-\n pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n #[lang=\"ty_desc\"]\n+#[deriving(Copy)]\n pub struct TyDesc {\n     // sizeof(T)\n     pub size: uint,\n@@ -61,8 +60,6 @@ pub struct TyDesc {\n     pub name: &'static str,\n }\n \n-impl Copy for TyDesc {}\n-\n extern \"rust-intrinsic\" {\n \n     // NB: These intrinsics take unsafe pointers because they mutate aliased\n@@ -540,13 +537,11 @@ extern \"rust-intrinsic\" {\n /// `TypeId` represents a globally unique identifier for a type\n #[lang=\"type_id\"] // This needs to be kept in lockstep with the code in trans/intrinsic.rs and\n                   // middle/lang_items.rs\n-#[deriving(Clone, PartialEq, Eq, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Show)]\n pub struct TypeId {\n     t: u64,\n }\n \n-impl Copy for TypeId {}\n-\n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been instantiated with\n     pub fn of<T: 'static>() -> TypeId {"}, {"sha": "1f83aad9c7cdca21768788d3bbf9a6e02c7938d3", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -59,7 +59,6 @@ pub use self::MinMaxResult::*;\n use clone::Clone;\n use cmp;\n use cmp::Ord;\n-use kinds::Copy;\n use mem;\n use num::{ToPrimitive, Int};\n use ops::{Add, Deref, FnMut};\n@@ -1168,16 +1167,14 @@ impl<A, I> CloneIteratorExt for I where I: Iterator<A> + Clone {\n }\n \n /// An iterator that repeats endlessly\n-#[deriving(Clone)]\n+#[deriving(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct Cycle<T> {\n     orig: T,\n     iter: T,\n }\n \n-impl<T:Copy> Copy for Cycle<T> {}\n-\n impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1635,13 +1632,12 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerat\n /// An iterator with a `peek()` that returns an optional reference to the next element.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n+#[deriving(Copy)]\n pub struct Peekable<A, T> {\n     iter: T,\n     peeked: Option<A>,\n }\n \n-impl<T:Copy,A:Copy> Copy for Peekable<A,T> {}\n-\n impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -2267,7 +2263,7 @@ impl<A, St, F> Iterator<A> for Unfold<A, St, F> where F: FnMut(&mut St) -> Optio\n \n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n-#[deriving(Clone)]\n+#[deriving(Clone, Copy)]\n #[unstable = \"may be renamed\"]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n@@ -2276,8 +2272,6 @@ pub struct Counter<A> {\n     step: A,\n }\n \n-impl<A:Copy> Copy for Counter<A> {}\n-\n /// Creates a new counter with the specified start/step\n #[inline]\n #[unstable = \"may be renamed\"]\n@@ -2301,16 +2295,14 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n }\n \n /// An iterator over the range [start, stop)\n-#[deriving(Clone)]\n+#[deriving(Clone, Copy)]\n #[unstable = \"may be refactored due to numerics reform or ops reform\"]\n pub struct Range<A> {\n     state: A,\n     stop: A,\n     one: A,\n }\n \n-impl<A:Copy> Copy for Range<A> {}\n-\n /// Returns an iterator over the given range [start, stop) (that is, starting\n /// at start (inclusive), and ending at stop (exclusive)).\n ///"}, {"sha": "93fd3f1b9f16ff186b8a4e4d4f7c9c131ec58f05", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -225,11 +225,9 @@ pub mod marker {\n     /// For more information about variance, refer to this Wikipedia\n     /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n     #[lang=\"covariant_lifetime\"]\n-    #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    #[deriving(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n     pub struct CovariantLifetime<'a>;\n \n-    impl<'a> Copy for CovariantLifetime<'a> {}\n-\n     /// As `ContravariantType`, but for lifetime parameters. Using\n     /// `ContravariantLifetime<'a>` indicates that it is ok to\n     /// substitute a *shorter* lifetime for `'a` than the one you\n@@ -243,11 +241,9 @@ pub mod marker {\n     /// For more information about variance, refer to this Wikipedia\n     /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n     #[lang=\"contravariant_lifetime\"]\n-    #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    #[deriving(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n     pub struct ContravariantLifetime<'a>;\n \n-    impl<'a> Copy for ContravariantLifetime<'a> {}\n-\n     /// As `InvariantType`, but for lifetime parameters. Using\n     /// `InvariantLifetime<'a>` indicates that it is not ok to\n     /// substitute any other lifetime for `'a` besides its original"}, {"sha": "b4f867b4bb4175c4ba8bd411713073b5560f34b9", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -1225,7 +1225,7 @@ impl_num_cast! { f32,   to_f32 }\n impl_num_cast! { f64,   to_f64 }\n \n /// Used for representing the classification of floating point numbers\n-#[deriving(PartialEq, Show)]\n+#[deriving(Copy, PartialEq, Show)]\n #[unstable = \"may be renamed\"]\n pub enum FPCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n@@ -1240,8 +1240,6 @@ pub enum FPCategory {\n     FPNormal,\n }\n \n-impl Copy for FPCategory {}\n-\n /// A built-in floating point number.\n // FIXME(#5527): In a future version of Rust, many of these functions will\n //               become constants."}, {"sha": "6e4beb2356e8f49a0049c8b309f5ca27dec9d3a0", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -88,10 +88,9 @@ pub trait Drop {\n /// calling `add`, and therefore, `main` prints `Adding!`.\n ///\n /// ```rust\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Add<Foo, Foo> for Foo {\n ///     fn add(&self, _rhs: &Foo) -> Foo {\n ///       println!(\"Adding!\");\n@@ -170,10 +169,9 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `sub`, and therefore, `main` prints `Subtracting!`.\n ///\n /// ```rust\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Sub<Foo, Foo> for Foo {\n ///     fn sub(&self, _rhs: &Foo) -> Foo {\n ///         println!(\"Subtracting!\");\n@@ -252,10 +250,9 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `mul`, and therefore, `main` prints `Multiplying!`.\n ///\n /// ```rust\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Mul<Foo, Foo> for Foo {\n ///     fn mul(&self, _rhs: &Foo) -> Foo {\n ///         println!(\"Multiplying!\");\n@@ -334,10 +331,9 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `div`, and therefore, `main` prints `Dividing!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Div<Foo, Foo> for Foo {\n ///     fn div(&self, _rhs: &Foo) -> Foo {\n ///         println!(\"Dividing!\");\n@@ -416,10 +412,9 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Rem<Foo, Foo> for Foo {\n ///     fn rem(&self, _rhs: &Foo) -> Foo {\n ///         println!(\"Remainder-ing!\");\n@@ -527,10 +522,9 @@ rem_float_impl! { f64, fmod }\n /// `neg`, and therefore, `main` prints `Negating!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Neg<Foo> for Foo {\n ///     fn neg(&self) -> Foo {\n ///         println!(\"Negating!\");\n@@ -639,10 +633,9 @@ neg_uint_impl! { u64, i64 }\n /// `not`, and therefore, `main` prints `Not-ing!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Not<Foo> for Foo {\n ///     fn not(&self) -> Foo {\n ///         println!(\"Not-ing!\");\n@@ -724,10 +717,9 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl BitAnd<Foo, Foo> for Foo {\n ///     fn bitand(&self, _rhs: &Foo) -> Foo {\n ///         println!(\"Bitwise And-ing!\");\n@@ -806,10 +798,9 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl BitOr<Foo, Foo> for Foo {\n ///     fn bitor(&self, _rhs: &Foo) -> Foo {\n ///         println!(\"Bitwise Or-ing!\");\n@@ -888,10 +879,9 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl BitXor<Foo, Foo> for Foo {\n ///     fn bitxor(&self, _rhs: &Foo) -> Foo {\n ///         println!(\"Bitwise Xor-ing!\");\n@@ -970,10 +960,9 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `shl`, and therefore, `main` prints `Shifting left!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Shl<Foo, Foo> for Foo {\n ///     fn shl(&self, _rhs: &Foo) -> Foo {\n ///         println!(\"Shifting left!\");\n@@ -1056,10 +1045,9 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `shr`, and therefore, `main` prints `Shifting right!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Shr<Foo, Foo> for Foo {\n ///     fn shr(&self, _rhs: &Foo) -> Foo {\n ///         println!(\"Shifting right!\");\n@@ -1139,10 +1127,9 @@ shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `index`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Index<Foo, Foo> for Foo {\n ///     fn index<'a>(&'a self, _index: &Foo) -> &'a Foo {\n ///         println!(\"Indexing!\");\n@@ -1169,10 +1156,9 @@ pub trait Index<Sized? Index, Sized? Result> for Sized? {\n /// calling `index_mut`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl IndexMut<Foo, Foo> for Foo {\n ///     fn index_mut<'a>(&'a mut self, _index: &Foo) -> &'a mut Foo {\n ///         println!(\"Indexing!\");\n@@ -1199,10 +1185,9 @@ pub trait IndexMut<Sized? Index, Sized? Result> for Sized? {\n /// calling `slice_to`, and therefore, `main` prints `Slicing!`.\n ///\n /// ```ignore\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Slice<Foo, Foo> for Foo {\n ///     fn as_slice_<'a>(&'a self) -> &'a Foo {\n ///         println!(\"Slicing!\");\n@@ -1247,10 +1232,9 @@ pub trait Slice<Sized? Idx, Sized? Result> for Sized? {\n /// calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n ///\n /// ```ignore\n+/// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl SliceMut<Foo, Foo> for Foo {\n ///     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n ///         println!(\"Slicing!\");"}, {"sha": "314b47fc6476becb56a2a59cf473988def0cad10", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -149,7 +149,6 @@ use cmp::{Eq, Ord};\n use default::Default;\n use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator};\n use iter::{ExactSizeIterator};\n-use kinds::Copy;\n use mem;\n use result::Result;\n use result::Result::{Ok, Err};\n@@ -164,7 +163,7 @@ use ops::{Deref, FnOnce};\n // which basically means it must be `Option`.\n \n /// The `Option` type.\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n+#[deriving(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n #[stable]\n pub enum Option<T> {\n     /// No value\n@@ -920,7 +919,3 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n         }\n     }\n }\n-\n-#[stable]\n-impl<T:Copy> Copy for Option<T> {}\n-"}, {"sha": "d70c96d8c16623cee38642b472bc447ae3a2aa1a", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -33,25 +33,23 @@ impl<T> Copy for Slice<T> {}\n \n /// The representation of a Rust closure\n #[repr(C)]\n+#[deriving(Copy)]\n pub struct Closure {\n     pub code: *mut (),\n     pub env: *mut (),\n }\n \n-impl Copy for Closure {}\n-\n /// The representation of a Rust trait object.\n ///\n /// This struct does not have a `Repr` implementation\n /// because there is no way to refer to all trait objects generically.\n #[repr(C)]\n+#[deriving(Copy)]\n pub struct TraitObject {\n     pub data: *mut (),\n     pub vtable: *mut (),\n }\n \n-impl Copy for TraitObject {}\n-\n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values.\n pub trait Repr<T> for Sized? {"}, {"sha": "00a2a3d5854d879fa60ed9a048652ac84be36c26", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -232,7 +232,6 @@\n \n use self::Result::*;\n \n-use kinds::Copy;\n use std::fmt::Show;\n use slice;\n use slice::AsSlice;\n@@ -244,7 +243,7 @@ use ops::{FnMut, FnOnce};\n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n+#[deriving(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n #[must_use]\n #[stable]\n pub enum Result<T, E> {\n@@ -919,6 +918,3 @@ pub fn fold<T,\n     }\n     Ok(init)\n }\n-\n-impl<T:Copy,U:Copy> Copy for Result<T,U> {}\n-"}, {"sha": "0b0e6ff95c6599925c4823328d05913039d9d52b", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -37,93 +37,70 @@\n #![allow(non_camel_case_types)]\n #![allow(missing_docs)]\n \n-use kinds::Copy;\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8);\n \n-impl Copy for i8x16 {}\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n-impl Copy for i16x8 {}\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n-impl Copy for i32x4 {}\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n-impl Copy for i64x2 {}\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8);\n \n-impl Copy for u8x16 {}\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n-impl Copy for u16x8 {}\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n-impl Copy for u32x4 {}\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n-impl Copy for u64x2 {}\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n-impl Copy for f32x4 {}\n-\n #[experimental]\n #[simd]\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n #[repr(C)]\n pub struct f64x2(pub f64, pub f64);\n-\n-impl Copy for f64x2 {}\n-"}, {"sha": "f5d117bca9fc8f45fd250b5cf4113f090e45e6c1", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -1229,7 +1229,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n /// index of the matching element. `NotFound` means the search\n /// succeeded, and the contained value is an index where a matching\n /// value could be inserted while maintaining sort order.\n-#[deriving(PartialEq, Show)]\n+#[deriving(Copy, PartialEq, Show)]\n #[experimental = \"needs review\"]\n pub enum BinarySearchResult {\n     /// The index of the found value.\n@@ -1238,8 +1238,6 @@ pub enum BinarySearchResult {\n     NotFound(uint)\n }\n \n-impl Copy for BinarySearchResult {}\n-\n #[experimental = \"needs review\"]\n impl BinarySearchResult {\n     /// Converts a `Found` to `Some`, `NotFound` to `None`."}, {"sha": "a89a7970ae9c43eaeba429fc3cb500806771cdf6", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30cefcbdfde6ff12c550914fede8180344d54857/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=30cefcbdfde6ff12c550914fede8180344d54857", "patch": "@@ -27,7 +27,7 @@ use default::Default;\n use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use iter::{DoubleEndedIteratorExt, ExactSizeIterator};\n use iter::range;\n-use kinds::{Copy, Sized};\n+use kinds::Sized;\n use mem;\n use num::Int;\n use option::Option;\n@@ -165,13 +165,11 @@ Section: Iterators\n /// Iterator for the char (representing *Unicode Scalar Values*) of a string\n ///\n /// Created with the method `.chars()`.\n-#[deriving(Clone)]\n+#[deriving(Clone, Copy)]\n pub struct Chars<'a> {\n     iter: slice::Items<'a, u8>\n }\n \n-impl<'a> Copy for Chars<'a> {}\n-\n // Return the initial codepoint accumulator for the first byte.\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n@@ -998,16 +996,14 @@ pub struct Utf16Items<'a> {\n     iter: slice::Items<'a, u16>\n }\n /// The possibilities for values decoded from a `u16` stream.\n-#[deriving(PartialEq, Eq, Clone, Show)]\n+#[deriving(Copy, PartialEq, Eq, Clone, Show)]\n pub enum Utf16Item {\n     /// A valid codepoint.\n     ScalarValue(char),\n     /// An invalid surrogate without its pair.\n     LoneSurrogate(u16)\n }\n \n-impl Copy for Utf16Item {}\n-\n impl Utf16Item {\n     /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n     /// replacement character (U+FFFD).\n@@ -1144,15 +1140,14 @@ pub fn utf8_char_width(b: u8) -> uint {\n /// Struct that contains a `char` and the index of the first byte of\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n+#[deriving(Copy)]\n pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n     /// Index of the first byte of the next `char`\n     pub next: uint,\n }\n \n-impl Copy for CharRange {}\n-\n /// Mask of the value bits of a continuation byte\n const CONT_MASK: u8 = 0b0011_1111u8;\n /// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte"}]}