{"sha": "4b51c92feeda0078033508ceee7345c6ac1a97e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNTFjOTJmZWVkYTAwNzgwMzM1MDhjZWVlNzM0NWM2YWMxYTk3ZTY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-03T06:40:34Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-03T06:41:21Z"}, "message": "slightly simplify expr lowering flow", "tree": {"sha": "652969521ed93d8b30d80bfd47f35f60d0a3d2a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/652969521ed93d8b30d80bfd47f35f60d0a3d2a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b51c92feeda0078033508ceee7345c6ac1a97e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b51c92feeda0078033508ceee7345c6ac1a97e6", "html_url": "https://github.com/rust-lang/rust/commit/4b51c92feeda0078033508ceee7345c6ac1a97e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b51c92feeda0078033508ceee7345c6ac1a97e6/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da850361ba22c78ed3579c33d6748735dcd2885c", "url": "https://api.github.com/repos/rust-lang/rust/commits/da850361ba22c78ed3579c33d6748735dcd2885c", "html_url": "https://github.com/rust-lang/rust/commit/da850361ba22c78ed3579c33d6748735dcd2885c"}], "stats": {"total": 265, "additions": 136, "deletions": 129}, "files": [{"sha": "7b7974f5bbef3cbfa124f00fa0b3f3a5b35f5de9", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b51c92feeda0078033508ceee7345c6ac1a97e6/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b51c92feeda0078033508ceee7345c6ac1a97e6/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=4b51c92feeda0078033508ceee7345c6ac1a97e6", "patch": "@@ -169,13 +169,13 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::generic_defaults_query)]\n     fn generic_defaults(&self, def: GenericDef) -> Substs;\n \n-    #[salsa::invoke(crate::expr::lower::body_with_source_map_query)]\n+    #[salsa::invoke(crate::expr::body_with_source_map_query)]\n     fn body_with_source_map(\n         &self,\n         def: DefWithBody,\n     ) -> (Arc<crate::expr::Body>, Arc<crate::expr::BodySourceMap>);\n \n-    #[salsa::invoke(crate::expr::lower::body_hir_query)]\n+    #[salsa::invoke(crate::expr::body_hir_query)]\n     fn body_hir(&self, def: DefWithBody) -> Arc<crate::expr::Body>;\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]"}, {"sha": "5f6a4b3202a7ecd0e4699a548ec7ed793bbd4938", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4b51c92feeda0078033508ceee7345c6ac1a97e6/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b51c92feeda0078033508ceee7345c6ac1a97e6/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=4b51c92feeda0078033508ceee7345c6ac1a97e6", "patch": "@@ -12,7 +12,7 @@ use crate::{\n     path::GenericArgs,\n     ty::primitive::{UncertainFloatTy, UncertainIntTy},\n     type_ref::{Mutability, TypeRef},\n-    DefWithBody, Either, HirDatabase, Name, Path, Resolver,\n+    DefWithBody, Either, HasSource, HirDatabase, Name, Path, Resolver,\n };\n \n pub use self::scope::ExprScopes;\n@@ -524,3 +524,34 @@ impl Pat {\n         }\n     }\n }\n+\n+// Queries\n+pub(crate) fn body_with_source_map_query(\n+    db: &impl HirDatabase,\n+    def: DefWithBody,\n+) -> (Arc<Body>, Arc<BodySourceMap>) {\n+    let mut params = None;\n+\n+    let (file_id, body) = match def {\n+        DefWithBody::Function(f) => {\n+            let src = f.source(db);\n+            params = src.ast.param_list();\n+            (src.file_id, src.ast.body().map(ast::Expr::from))\n+        }\n+        DefWithBody::Const(c) => {\n+            let src = c.source(db);\n+            (src.file_id, src.ast.body())\n+        }\n+        DefWithBody::Static(s) => {\n+            let src = s.source(db);\n+            (src.file_id, src.ast.body())\n+        }\n+    };\n+\n+    let (body, source_map) = lower::lower(db, def.resolver(db), file_id, def, params, body);\n+    (Arc::new(body), Arc::new(source_map))\n+}\n+\n+pub(crate) fn body_hir_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n+    db.body_with_source_map(def).0\n+}"}, {"sha": "7b3e55b7ec435b559f523c4c852ede2c64620695", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "modified", "additions": 102, "deletions": 126, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/4b51c92feeda0078033508ceee7345c6ac1a97e6/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b51c92feeda0078033508ceee7345c6ac1a97e6/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=4b51c92feeda0078033508ceee7345c6ac1a97e6", "patch": "@@ -1,5 +1,3 @@\n-use std::sync::Arc;\n-\n use ra_arena::Arena;\n use ra_syntax::{\n     ast::{\n@@ -15,62 +13,116 @@ use crate::{\n     path::GenericArgs,\n     ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n     type_ref::TypeRef,\n-    DefWithBody, Either, HasSource, HirDatabase, HirFileId, MacroCallLoc, MacroFileKind,\n-    Mutability, Path, Resolver,\n+    DefWithBody, Either, HirDatabase, HirFileId, MacroCallLoc, MacroFileKind, Mutability, Path,\n+    Resolver,\n };\n \n use super::{\n     ArithOp, Array, BinaryOp, BindingAnnotation, Body, BodySourceMap, CmpOp, Expr, ExprId, Literal,\n     LogicOp, MatchArm, Ordering, Pat, PatId, PatPtr, RecordFieldPat, RecordLitField, Statement,\n };\n \n-pub(crate) struct ExprCollector<DB> {\n-    db: DB,\n+pub(super) fn lower(\n+    db: &impl HirDatabase,\n+    resolver: Resolver,\n+    file_id: HirFileId,\n     owner: DefWithBody,\n-    exprs: Arena<ExprId, Expr>,\n-    pats: Arena<PatId, Pat>,\n-    source_map: BodySourceMap,\n-    params: Vec<PatId>,\n-    body_expr: Option<ExprId>,\n+    params: Option<ast::ParamList>,\n+    body: Option<ast::Expr>,\n+) -> (Body, BodySourceMap) {\n+    ExprCollector {\n+        resolver,\n+        db,\n+        original_file_id: file_id,\n+        current_file_id: file_id,\n+        source_map: BodySourceMap::default(),\n+        body: Body {\n+            owner,\n+            exprs: Arena::default(),\n+            pats: Arena::default(),\n+            params: Vec::new(),\n+            body_expr: ExprId((!0).into()),\n+        },\n+    }\n+    .collect(params, body)\n+}\n+\n+struct ExprCollector<DB> {\n+    db: DB,\n     resolver: Resolver,\n     // Expr collector expands macros along the way. original points to the file\n     // we started with, current points to the current macro expansion. source\n     // maps don't support macros yet, so we only record info into source map if\n     // current == original (see #1196)\n     original_file_id: HirFileId,\n     current_file_id: HirFileId,\n+\n+    body: Body,\n+    source_map: BodySourceMap,\n }\n \n impl<'a, DB> ExprCollector<&'a DB>\n where\n     DB: HirDatabase,\n {\n-    fn new(owner: DefWithBody, file_id: HirFileId, resolver: Resolver, db: &'a DB) -> Self {\n-        ExprCollector {\n-            owner,\n-            resolver,\n-            db,\n-            exprs: Arena::default(),\n-            pats: Arena::default(),\n-            source_map: BodySourceMap::default(),\n-            params: Vec::new(),\n-            body_expr: None,\n-            original_file_id: file_id,\n-            current_file_id: file_id,\n-        }\n+    fn collect(\n+        mut self,\n+        param_list: Option<ast::ParamList>,\n+        body: Option<ast::Expr>,\n+    ) -> (Body, BodySourceMap) {\n+        if let Some(param_list) = param_list {\n+            if let Some(self_param) = param_list.self_param() {\n+                let ptr = AstPtr::new(&self_param);\n+                let param_pat = self.alloc_pat(\n+                    Pat::Bind {\n+                        name: SELF_PARAM,\n+                        mode: BindingAnnotation::Unannotated,\n+                        subpat: None,\n+                    },\n+                    Either::B(ptr),\n+                );\n+                self.body.params.push(param_pat);\n+            }\n+\n+            for param in param_list.params() {\n+                let pat = match param.pat() {\n+                    None => continue,\n+                    Some(pat) => pat,\n+                };\n+                let param_pat = self.collect_pat(pat);\n+                self.body.params.push(param_pat);\n+            }\n+        };\n+\n+        self.body.body_expr = self.collect_expr_opt(body);\n+        (self.body, self.source_map)\n     }\n+\n     fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n         let ptr = Either::A(ptr);\n-        let id = self.exprs.alloc(expr);\n+        let id = self.body.exprs.alloc(expr);\n+        if self.current_file_id == self.original_file_id {\n+            self.source_map.expr_map.insert(ptr, id);\n+            self.source_map.expr_map_back.insert(id, ptr);\n+        }\n+        id\n+    }\n+    // deshugared exprs don't have ptr, that's wrong and should be fixed\n+    // somehow.\n+    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n+        self.body.exprs.alloc(expr)\n+    }\n+    fn alloc_expr_field_shorthand(&mut self, expr: Expr, ptr: AstPtr<ast::RecordField>) -> ExprId {\n+        let ptr = Either::B(ptr);\n+        let id = self.body.exprs.alloc(expr);\n         if self.current_file_id == self.original_file_id {\n             self.source_map.expr_map.insert(ptr, id);\n             self.source_map.expr_map_back.insert(id, ptr);\n         }\n         id\n     }\n-\n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n-        let id = self.pats.alloc(pat);\n+        let id = self.body.pats.alloc(pat);\n \n         if self.current_file_id == self.original_file_id {\n             self.source_map.pat_map.insert(ptr, id);\n@@ -82,7 +134,15 @@ where\n \n     fn empty_block(&mut self) -> ExprId {\n         let block = Expr::Block { statements: Vec::new(), tail: None };\n-        self.exprs.alloc(block)\n+        self.body.exprs.alloc(block)\n+    }\n+\n+    fn missing_expr(&mut self) -> ExprId {\n+        self.body.exprs.alloc(Expr::Missing)\n+    }\n+\n+    fn missing_pat(&mut self) -> PatId {\n+        self.body.pats.alloc(Pat::Missing)\n     }\n \n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n@@ -100,14 +160,14 @@ where\n                 });\n \n                 let condition = match e.condition() {\n-                    None => self.exprs.alloc(Expr::Missing),\n+                    None => self.missing_expr(),\n                     Some(condition) => match condition.pat() {\n                         None => self.collect_expr_opt(condition.expr()),\n                         // if let -- desugar to match\n                         Some(pat) => {\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n-                            let placeholder_pat = self.pats.alloc(Pat::Missing);\n+                            let placeholder_pat = self.missing_pat();\n                             let arms = vec![\n                                 MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n                                 MatchArm {\n@@ -137,22 +197,22 @@ where\n                 let body = self.collect_block_opt(e.loop_body());\n \n                 let condition = match e.condition() {\n-                    None => self.exprs.alloc(Expr::Missing),\n+                    None => self.missing_expr(),\n                     Some(condition) => match condition.pat() {\n                         None => self.collect_expr_opt(condition.expr()),\n                         // if let -- desugar to match\n                         Some(pat) => {\n                             tested_by!(infer_while_let);\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n-                            let placeholder_pat = self.pats.alloc(Pat::Missing);\n-                            let break_ = self.exprs.alloc(Expr::Break { expr: None });\n+                            let placeholder_pat = self.missing_pat();\n+                            let break_ = self.alloc_expr_desugared(Expr::Break { expr: None });\n                             let arms = vec![\n                                 MatchArm { pats: vec![pat], expr: body, guard: None },\n                                 MatchArm { pats: vec![placeholder_pat], expr: break_, guard: None },\n                             ];\n                             let match_expr =\n-                                self.exprs.alloc(Expr::Match { expr: match_expr, arms });\n+                                self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n                             return self.alloc_expr(Expr::Loop { body: match_expr }, syntax_ptr);\n                         }\n                     },\n@@ -247,13 +307,12 @@ where\n                                 self.collect_expr(e)\n                             } else if let Some(nr) = field.name_ref() {\n                                 // field shorthand\n-                                let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(&nr)));\n-                                let ptr = Either::B(AstPtr::new(&field));\n-                                self.source_map.expr_map.insert(ptr, id);\n-                                self.source_map.expr_map_back.insert(id, ptr);\n-                                id\n+                                self.alloc_expr_field_shorthand(\n+                                    Expr::Path(Path::from_name_ref(&nr)),\n+                                    AstPtr::new(&field),\n+                                )\n                             } else {\n-                                self.exprs.alloc(Expr::Missing)\n+                                self.missing_expr()\n                             },\n                         })\n                         .collect();\n@@ -420,7 +479,7 @@ where\n         if let Some(expr) = expr {\n             self.collect_expr(expr)\n         } else {\n-            self.exprs.alloc(Expr::Missing)\n+            self.missing_expr()\n         }\n     }\n \n@@ -450,7 +509,7 @@ where\n         if let Some(block) = expr {\n             self.collect_block(block)\n         } else {\n-            self.exprs.alloc(Expr::Missing)\n+            self.missing_expr()\n         }\n     }\n \n@@ -519,60 +578,9 @@ where\n         if let Some(pat) = pat {\n             self.collect_pat(pat)\n         } else {\n-            self.pats.alloc(Pat::Missing)\n+            self.missing_pat()\n         }\n     }\n-\n-    fn collect_const_body(&mut self, node: ast::ConstDef) {\n-        let body = self.collect_expr_opt(node.body());\n-        self.body_expr = Some(body);\n-    }\n-\n-    fn collect_static_body(&mut self, node: ast::StaticDef) {\n-        let body = self.collect_expr_opt(node.body());\n-        self.body_expr = Some(body);\n-    }\n-\n-    fn collect_fn_body(&mut self, node: ast::FnDef) {\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let ptr = AstPtr::new(&self_param);\n-                let param_pat = self.alloc_pat(\n-                    Pat::Bind {\n-                        name: SELF_PARAM,\n-                        mode: BindingAnnotation::Unannotated,\n-                        subpat: None,\n-                    },\n-                    Either::B(ptr),\n-                );\n-                self.params.push(param_pat);\n-            }\n-\n-            for param in param_list.params() {\n-                let pat = if let Some(pat) = param.pat() {\n-                    pat\n-                } else {\n-                    continue;\n-                };\n-                let param_pat = self.collect_pat(pat);\n-                self.params.push(param_pat);\n-            }\n-        };\n-\n-        let body = self.collect_block_opt(node.body());\n-        self.body_expr = Some(body);\n-    }\n-\n-    fn finish(self) -> (Body, BodySourceMap) {\n-        let body = Body {\n-            owner: self.owner,\n-            exprs: self.exprs,\n-            pats: self.pats,\n-            params: self.params,\n-            body_expr: self.body_expr.expect(\"A body should have been collected\"),\n-        };\n-        (body, self.source_map)\n-    }\n }\n \n impl From<ast::BinOp> for BinaryOp {\n@@ -618,35 +626,3 @@ impl From<ast::BinOp> for BinaryOp {\n         }\n     }\n }\n-\n-pub(crate) fn body_with_source_map_query(\n-    db: &impl HirDatabase,\n-    def: DefWithBody,\n-) -> (Arc<Body>, Arc<BodySourceMap>) {\n-    let mut collector;\n-\n-    match def {\n-        DefWithBody::Const(ref c) => {\n-            let src = c.source(db);\n-            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_const_body(src.ast)\n-        }\n-        DefWithBody::Function(ref f) => {\n-            let src = f.source(db);\n-            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_fn_body(src.ast)\n-        }\n-        DefWithBody::Static(ref s) => {\n-            let src = s.source(db);\n-            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_static_body(src.ast)\n-        }\n-    }\n-\n-    let (body, source_map) = collector.finish();\n-    (Arc::new(body), Arc::new(source_map))\n-}\n-\n-pub(crate) fn body_hir_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n-    db.body_with_source_map(def).0\n-}"}]}