{"sha": "bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjN2NlZTdiYmY4MTZiZTdhNzEyYzA2YTkzMDE1ZGMzYzZmZDU2MTE=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-31T01:38:44Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-31T18:37:22Z"}, "message": "Move atomically to unstable::sync, and document what it actually does. Close #7872.", "tree": {"sha": "2d4052b11459f0f8a2f4e8ccf98e3112c824b39b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d4052b11459f0f8a2f4e8ccf98e3112c824b39b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "html_url": "https://github.com/rust-lang/rust/commit/bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e6dc161b6efac1ce2709ab4e1c05c55c01e3abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6dc161b6efac1ce2709ab4e1c05c55c01e3abf", "html_url": "https://github.com/rust-lang/rust/commit/2e6dc161b6efac1ce2709ab4e1c05c55c01e3abf"}], "stats": {"total": 119, "additions": 57, "deletions": 62}, "files": [{"sha": "c2571f171a17257a09d0539875eb4aa3ac850edf", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "patch": "@@ -84,7 +84,7 @@ pub struct Death {\n     on_exit:         Option<~fn(bool)>,\n     // nesting level counter for task::unkillable calls (0 == killable).\n     unkillable:      int,\n-    // nesting level counter for task::atomically calls (0 == can yield).\n+    // nesting level counter for unstable::atomically calls (0 == can yield).\n     wont_sleep:      int,\n     // A \"spare\" handle to the kill flag inside the kill handle. Used during\n     // blocking/waking as an optimization to avoid two xadds on the refcount."}, {"sha": "aff4bc12039fcaa10d59cd14615ce5888c7c2163", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "patch": "@@ -655,44 +655,6 @@ pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n     }\n }\n \n-/**\n- * A stronger version of unkillable that also inhibits scheduling operations.\n- * For use with exclusive Arcs, which use pthread mutexes directly.\n- */\n-pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n-    use rt::task::Task;\n-\n-    match context() {\n-        OldTaskContext => {\n-            let t = rt::rust_get_task();\n-            do (|| {\n-                rt::rust_task_inhibit_kill(t);\n-                rt::rust_task_inhibit_yield(t);\n-                f()\n-            }).finally {\n-                rt::rust_task_allow_yield(t);\n-                rt::rust_task_allow_kill(t);\n-            }\n-        }\n-        TaskContext => {\n-            let t = Local::unsafe_borrow::<Task>();\n-            do (|| {\n-                // It's important to inhibit kill after inhibiting yield, because\n-                // inhibit-kill might fail if we were already killed, and the\n-                // inhibit-yield must happen to match the finally's allow-yield.\n-                (*t).death.inhibit_yield();\n-                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n-                f()\n-            }).finally {\n-                (*t).death.allow_kill((*t).unwinder.unwinding);\n-                (*t).death.allow_yield();\n-            }\n-        }\n-        // FIXME(#3095): As in unkillable().\n-        _ => f()\n-    }\n-}\n-\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_cant_dup_task_builder() {\n     let mut builder = task();\n@@ -1177,21 +1139,6 @@ fn test_unkillable_nested() {\n     po.recv();\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_atomically() {\n-    unsafe { do atomically { yield(); } }\n-}\n-\n-#[test]\n-fn test_atomically2() {\n-    unsafe { do atomically { } } yield(); // shouldn't fail\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_atomically_nested() {\n-    unsafe { do atomically { do atomically { } yield(); } }\n-}\n-\n #[test]\n fn test_child_doesnt_ref_parent() {\n     // If the child refcounts the parent task, this will stack overflow when"}, {"sha": "ab44520454d62220a65915c1fec7f98d247c4245", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "patch": "@@ -105,7 +105,7 @@ mod dl {\n     use path;\n     use ptr;\n     use str;\n-    use task;\n+    use unstable::sync::atomically;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -120,7 +120,7 @@ mod dl {\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n         unsafe {\n-            do task::atomically {\n+            do atomically {\n                 let _old_error = dlerror();\n \n                 let result = f();\n@@ -164,7 +164,7 @@ mod dl {\n     use libc;\n     use path;\n     use ptr;\n-    use task;\n+    use unstable::sync::atomically;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -181,7 +181,7 @@ mod dl {\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n         unsafe {\n-            do task::atomically {\n+            do atomically {\n                 SetLastError(0);\n \n                 let result = f();"}, {"sha": "f721dd47a66a0f826027eb27fd3a7934c179d47e", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "patch": "@@ -85,15 +85,15 @@ fn test_run_in_bare_thread_exchange() {\n pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n     use os;\n     use os::change_dir;\n-    use task;\n+    use unstable::sync::atomically;\n     use unstable::finally::Finally;\n \n     unsafe {\n         // This is really sketchy. Using a pthread mutex so descheduling\n         // in the `action` callback can cause deadlock. Doing it in\n         // `task::atomically` to try to avoid that, but ... I don't know\n         // this is all bogus.\n-        return do task::atomically {\n+        return do atomically {\n             rust_take_change_dir_lock();\n \n             do (||{"}, {"sha": "c52e4739edd9fbcf7ab32b752186b4f7c0320db2", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7cee7bbf816be7a712c06a93015dc3c6fd5611/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=bc7cee7bbf816be7a712c06a93015dc3c6fd5611", "patch": "@@ -16,7 +16,6 @@ use ptr;\n use option::*;\n use either::{Either, Left, Right};\n use task;\n-use task::atomically;\n use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,SeqCst};\n use unstable::finally::Finally;\n use ops::Drop;\n@@ -271,6 +270,48 @@ impl<T> Drop for UnsafeAtomicRcBox<T>{\n \n /****************************************************************************/\n \n+/**\n+ * Enables a runtime assertion that no operation in the argument closure shall\n+ * use scheduler operations (yield, recv, spawn, etc). This is for use with\n+ * pthread mutexes, which may block the entire scheduler thread, rather than\n+ * just one task, and is hence prone to deadlocks if mixed with yielding.\n+ *\n+ * NOTE: THIS DOES NOT PROVIDE LOCKING, or any sort of critical-section\n+ * synchronization whatsoever. It only makes sense to use for CPU-local issues.\n+ */\n+// FIXME(#8140) should not be pub\n+pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n+    use rt::task::Task;\n+    use task::rt;\n+    use rt::local::Local;\n+    use rt::{context, OldTaskContext, TaskContext};\n+\n+    match context() {\n+        OldTaskContext => {\n+            let t = rt::rust_get_task();\n+            do (|| {\n+                rt::rust_task_inhibit_kill(t);\n+                rt::rust_task_inhibit_yield(t);\n+                f()\n+            }).finally {\n+                rt::rust_task_allow_yield(t);\n+                rt::rust_task_allow_kill(t);\n+            }\n+        }\n+        TaskContext => {\n+            let t = Local::unsafe_borrow::<Task>();\n+            do (|| {\n+                (*t).death.inhibit_yield();\n+                f()\n+            }).finally {\n+                (*t).death.allow_yield();\n+            }\n+        }\n+        // FIXME(#3095): As in unkillable().\n+        _ => f()\n+    }\n+}\n+\n #[allow(non_camel_case_types)] // runtime type\n type rust_little_lock = *libc::c_void;\n \n@@ -395,11 +436,18 @@ mod tests {\n     use cell::Cell;\n     use comm;\n     use option::*;\n-    use super::{Exclusive, UnsafeAtomicRcBox};\n+    use super::{Exclusive, UnsafeAtomicRcBox, atomically};\n     use task;\n     use uint;\n     use util;\n \n+    #[test]\n+    fn test_atomically() {\n+        // NB. The whole runtime will abort on an 'atomic-sleep' violation,\n+        // so we can't really test for the converse behaviour.\n+        unsafe { do atomically { } } task::yield(); // oughtn't fail\n+    }\n+\n     #[test]\n     fn exclusive_new_arc() {\n         unsafe {"}]}