{"sha": "945f007c0d305c3ec069b5e5d911ef783f6d70e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NWYwMDdjMGQzMDVjM2VjMDY5YjVlNWQ5MTFlZjc4M2Y2ZDcwZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-26T14:52:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-26T14:52:03Z"}, "message": "Auto merge of #779 - christianpoveda:intptrcast-model, r=RalfJung,oli-obk\n\nImplement intptrcast methods\n\ncc https://github.com/rust-lang/miri/issues/224", "tree": {"sha": "45e48f69b4b20bf1aab34cb8bb339c788a47c214", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45e48f69b4b20bf1aab34cb8bb339c788a47c214"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/945f007c0d305c3ec069b5e5d911ef783f6d70e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/945f007c0d305c3ec069b5e5d911ef783f6d70e7", "html_url": "https://github.com/rust-lang/rust/commit/945f007c0d305c3ec069b5e5d911ef783f6d70e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/945f007c0d305c3ec069b5e5d911ef783f6d70e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1873b689d4834284db9db92ab1beee48c6928c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1873b689d4834284db9db92ab1beee48c6928c7", "html_url": "https://github.com/rust-lang/rust/commit/d1873b689d4834284db9db92ab1beee48c6928c7"}, {"sha": "7fbf8e53a22925a5ff865b3546f881f7542c4f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fbf8e53a22925a5ff865b3546f881f7542c4f9e", "html_url": "https://github.com/rust-lang/rust/commit/7fbf8e53a22925a5ff865b3546f881f7542c4f9e"}], "stats": {"total": 301, "additions": 262, "deletions": 39}, "files": [{"sha": "e2a4daa6f385353757dbcfa7b5838d03fb4d0c32", "filename": "src/fn_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -980,7 +980,7 @@ fn gen_random<'mir, 'tcx>(\n     }\n     let ptr = dest.to_ptr()?;\n \n-    let data = match &mut this.machine.rng {\n+    let data = match &mut this.memory_mut().extra.rng {\n         Some(rng) => {\n             let mut data = vec![0; len];\n             rng.fill_bytes(&mut data);"}, {"sha": "ad0489fa7de860918635caba838441246e8368da", "filename": "src/intptrcast.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -0,0 +1,100 @@\n+use std::cell::{Cell, RefCell};\n+\n+use rustc::mir::interpret::{AllocId, Pointer, InterpResult};\n+use rustc_mir::interpret::Memory;\n+use rustc_target::abi::Size;\n+\n+use crate::stacked_borrows::Tag;\n+use crate::Evaluator;\n+\n+pub type MemoryExtra = RefCell<GlobalState>;\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct AllocExtra {\n+    base_addr: Cell<Option<u64>>\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct GlobalState {\n+    /// This is used as a map between the address of each allocation and its `AllocId`.\n+    /// It is always sorted\n+    pub int_to_ptr_map: Vec<(u64, AllocId)>,\n+    /// This is used as a memory address when a new pointer is casted to an integer. It\n+    /// is always larger than any address that was previously made part of a block.\n+    pub next_base_addr: u64,\n+}\n+\n+impl Default for GlobalState {\n+    // FIXME: Query the page size in the future\n+    fn default() -> Self {\n+        GlobalState {\n+            int_to_ptr_map: Vec::default(),\n+            next_base_addr: 2u64.pow(16)\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx> GlobalState {\n+    pub fn int_to_ptr(\n+        int: u64,\n+        memory: &Memory<'mir, 'tcx, Evaluator<'tcx>>,\n+    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+        let global_state = memory.extra.intptrcast.borrow();\n+        \n+        match global_state.int_to_ptr_map.binary_search_by_key(&int, |(addr, _)| *addr) {\n+            Ok(pos) => {\n+                let (_, alloc_id) = global_state.int_to_ptr_map[pos];\n+                // `int` is equal to the starting address for an allocation, the offset should be\n+                // zero. The pointer is untagged because it was created from a cast\n+                Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged))\n+            },\n+            Err(0) => err!(DanglingPointerDeref), \n+            Err(pos) => {\n+                // This is the largest of the adresses smaller than `int`,\n+                // i.e. the greatest lower bound (glb)\n+                let (glb, alloc_id) = global_state.int_to_ptr_map[pos - 1];\n+                // This never overflows because `int >= glb`\n+                let offset = int - glb;\n+                // If the offset exceeds the size of the allocation, this access is illegal\n+                if offset <= memory.get(alloc_id)?.bytes.len() as u64 {\n+                    // This pointer is untagged because it was created from a cast\n+                    Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged))\n+                } else {\n+                    err!(DanglingPointerDeref)\n+                } \n+            }\n+        }\n+    }\n+\n+    pub fn ptr_to_int(\n+        ptr: Pointer<Tag>,\n+        memory: &Memory<'mir, 'tcx, Evaluator<'tcx>>,\n+    ) -> InterpResult<'tcx, u64> {\n+        let mut global_state = memory.extra.intptrcast.borrow_mut();\n+\n+        let alloc = memory.get(ptr.alloc_id)?;\n+\n+        let base_addr = match alloc.extra.intptrcast.base_addr.get() { \n+            Some(base_addr) => base_addr,\n+            None => {\n+                // This allocation does not have a base address yet, pick one.\n+                let base_addr = Self::align_addr(global_state.next_base_addr, alloc.align.bytes());\n+                global_state.next_base_addr = base_addr + alloc.bytes.len() as u64;\n+                alloc.extra.intptrcast.base_addr.set(Some(base_addr));\n+                // Given that `next_base_addr` increases in each allocation, pushing the\n+                // corresponding tuple keeps `int_to_ptr_map` sorted\n+                global_state.int_to_ptr_map.push((base_addr, ptr.alloc_id)); \n+\n+                base_addr\n+            }\n+        };\n+\n+        Ok(base_addr + ptr.offset.bytes())\n+    }\n+\n+    /// Shifts `addr` to make it aligned with `align` by rounding `addr` to the smallest multiple\n+    /// of `align` that is strictly larger to `addr`\n+    fn align_addr(addr: u64, align: u64) -> u64 {\n+        addr + align - addr % align\n+    }\n+}"}, {"sha": "6b1ada69d3975dfc38e9e8e8e6acd833a1699f55", "filename": "src/lib.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -20,6 +20,8 @@ mod tls;\n mod range_map;\n mod mono_hash_map;\n mod stacked_borrows;\n+mod intptrcast;\n+mod memory;\n \n use std::collections::HashMap;\n use std::borrow::Cow;\n@@ -48,6 +50,7 @@ use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};\n use crate::mono_hash_map::MonoHashMap;\n pub use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n+use crate::memory::AllocExtra;\n \n // Used by priroda.\n pub use crate::stacked_borrows::{Tag, Permission, Stack, Stacks, Item};\n@@ -79,9 +82,12 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let mut ecx = InterpretCx::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.validate, config.seed),\n+        Evaluator::new(config.validate),\n     );\n \n+    // FIXME: InterpretCx::new should take an initial MemoryExtra\n+    ecx.memory_mut().extra.rng = config.seed.map(StdRng::seed_from_u64);\n+    \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n     let main_mir = ecx.load_mir(main_instance.def)?;\n \n@@ -205,7 +211,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             cur_ptr = cur_ptr.offset(char_size, tcx)?;\n         }\n     }\n-\n+ \n     assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n \n     Ok(ecx)\n@@ -341,14 +347,10 @@ pub struct Evaluator<'tcx> {\n \n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n-\n-    /// The random number generator to use if Miri\n-    /// is running in non-deterministic mode\n-    pub(crate) rng: Option<StdRng>\n }\n \n impl<'tcx> Evaluator<'tcx> {\n-    fn new(validate: bool, seed: Option<u64>) -> Self {\n+    fn new(validate: bool) -> Self {\n         Evaluator {\n             env_vars: HashMap::default(),\n             argc: None,\n@@ -357,7 +359,6 @@ impl<'tcx> Evaluator<'tcx> {\n             last_error: 0,\n             tls: TlsData::default(),\n             validate,\n-            rng: seed.map(|s| StdRng::seed_from_u64(s))\n         }\n     }\n }\n@@ -386,8 +387,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryKinds = MiriMemoryKind;\n \n     type FrameExtra = stacked_borrows::CallId;\n-    type MemoryExtra = stacked_borrows::MemoryState;\n-    type AllocExtra = stacked_borrows::Stacks;\n+    type MemoryExtra = memory::MemoryExtra;\n+    type AllocExtra = memory::AllocExtra;\n     type PointerTag = Tag;\n \n     type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n@@ -512,17 +513,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n-        let (extra, base_tag) = Stacks::new_allocation(\n+        let (stacks, base_tag) = Stacks::new_allocation(\n             id,\n             Size::from_bytes(alloc.bytes.len() as u64),\n-            Rc::clone(&memory.extra),\n+            Rc::clone(&memory.extra.stacked_borrows),\n             kind,\n         );\n         if kind != MiriMemoryKind::Static.into() {\n             assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n             // Now we can rely on the inner pointers being static, too.\n         }\n-        let mut memory_extra = memory.extra.borrow_mut();\n+        let mut memory_extra = memory.extra.stacked_borrows.borrow_mut();\n         let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n             bytes: alloc.bytes,\n             relocations: Relocations::from_presorted(\n@@ -535,7 +536,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n             undef_mask: alloc.undef_mask,\n             align: alloc.align,\n             mutability: alloc.mutability,\n-            extra,\n+            extra: AllocExtra {\n+                stacked_borrows: stacks,\n+                intptrcast: Default::default(),\n+            },\n         };\n         (Cow::Owned(alloc), base_tag)\n     }\n@@ -545,7 +549,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         id: AllocId,\n         memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag {\n-        memory.extra.borrow_mut().static_base_ptr(id)\n+        memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n     }\n \n     #[inline(always)]\n@@ -570,14 +574,38 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     fn stack_push(\n         ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n-        Ok(ecx.memory().extra.borrow_mut().new_call())\n+        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().new_call())\n     }\n \n     #[inline(always)]\n     fn stack_pop(\n         ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         extra: stacked_borrows::CallId,\n     ) -> InterpResult<'tcx> {\n-        Ok(ecx.memory().extra.borrow_mut().end_call(extra))\n+        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n+    }\n+\n+    fn int_to_ptr(\n+        int: u64,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n+        if int == 0 {\n+            err!(InvalidNullPointerUsage)\n+        } else if memory.extra.rng.is_none() {\n+            err!(ReadBytesAsPointer)\n+        } else {\n+           intptrcast::GlobalState::int_to_ptr(int, memory)\n+        }\n+    }\n+ \n+    fn ptr_to_int(\n+        ptr: Pointer<Self::PointerTag>,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, u64> {\n+        if memory.extra.rng.is_none() {\n+            err!(ReadPointerAsBytes)\n+        } else {\n+            intptrcast::GlobalState::ptr_to_int(ptr, memory)\n+        }\n     }\n }"}, {"sha": "ea8f01a808c0434e5697acda9c5bdbdc38976f96", "filename": "src/memory.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -0,0 +1,51 @@\n+use rand::rngs::StdRng;\n+\n+use rustc_mir::interpret::{Pointer, Allocation, AllocationExtra, InterpResult};\n+use rustc_target::abi::Size;\n+\n+use crate::{stacked_borrows, intptrcast};\n+use crate::stacked_borrows::Tag;\n+\n+#[derive(Default, Clone, Debug)]\n+pub struct MemoryExtra {\n+    pub stacked_borrows: stacked_borrows::MemoryExtra,\n+    pub intptrcast: intptrcast::MemoryExtra,\n+    /// The random number generator to use if Miri is running in non-deterministic mode and to\n+    /// enable intptrcast\n+    pub(crate) rng: Option<StdRng>\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct AllocExtra {\n+    pub stacked_borrows: stacked_borrows::AllocExtra,\n+    pub intptrcast: intptrcast::AllocExtra,\n+}\n+\n+impl AllocationExtra<Tag> for AllocExtra {\n+    #[inline(always)]\n+    fn memory_read<'tcx>(\n+        alloc: &Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        alloc.extra.stacked_borrows.memory_read(ptr, size)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_written<'tcx>(\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        alloc.extra.stacked_borrows.memory_written(ptr, size)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_deallocated<'tcx>(\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        alloc.extra.stacked_borrows.memory_deallocated(ptr, size)\n+    }\n+}"}, {"sha": "572794a44add4604126d6929f6129a5c7647092c", "filename": "src/operator.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -56,6 +56,19 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n+        // If intptrcast is enabled and the operation is not an offset\n+        // we can force the cast from pointers to integer addresses and\n+        // then dispatch to rustc binary operation method\n+        if self.memory().extra.rng.is_some() && bin_op != Offset {\n+            let l_bits = self.force_bits(left.imm.to_scalar()?, left.layout.size)?;\n+            let r_bits = self.force_bits(right.imm.to_scalar()?, right.layout.size)?;\n+            \n+            let left = ImmTy::from_scalar(Scalar::from_uint(l_bits, left.layout.size), left.layout);\n+            let right = ImmTy::from_scalar(Scalar::from_uint(r_bits, left.layout.size), right.layout);\n+\n+            return self.binary_op(bin_op, left, right);\n+        } \n+\n         // Operations that support fat pointers\n         match bin_op {\n             Eq | Ne => {"}, {"sha": "524ad2b47af0e0147a1fd7254d70aeb2ccdbf4fe", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -10,12 +10,12 @@ use rustc::mir::RetagKind;\n \n use crate::{\n     InterpResult, InterpError, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n-    MemoryKind, MiriMemoryKind, RangeMap, Allocation, AllocationExtra, AllocId,\n-    Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n+    MemoryKind, MiriMemoryKind, RangeMap, AllocId, Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n+pub type AllocExtra = Stacks;\n \n /// Tracking pointer provenance\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n@@ -86,7 +86,7 @@ pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n     stacks: RefCell<RangeMap<Stack>>,\n     // Pointer to global state\n-    global: MemoryState,\n+    global: MemoryExtra,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -104,7 +104,7 @@ pub struct GlobalState {\n     active_calls: HashSet<CallId>,\n }\n /// Memory extra state gives us interior mutable access to the global state.\n-pub type MemoryState = Rc<RefCell<GlobalState>>;\n+pub type MemoryExtra = Rc<RefCell<GlobalState>>;\n \n /// Indicates which kind of access is being performed.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n@@ -423,15 +423,16 @@ impl<'tcx> Stacks {\n         size: Size,\n         perm: Permission,\n         tag: Tag,\n-        extra: MemoryState,\n+        extra: MemoryExtra,\n     ) -> Self {\n         let item = Item { perm, tag, protector: None };\n         let stack = Stack {\n             borrows: vec![item],\n         };\n+\n         Stacks {\n             stacks: RefCell::new(RangeMap::new(size, stack)),\n-            global: extra,\n+            global: extra, \n         }\n     }\n \n@@ -456,7 +457,7 @@ impl Stacks {\n     pub fn new_allocation(\n         id: AllocId,\n         size: Size,\n-        extra: MemoryState,\n+        extra: MemoryExtra, \n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> (Self, Tag) {\n         let (tag, perm) = match kind {\n@@ -475,43 +476,41 @@ impl Stacks {\n         let stack = Stacks::new(size, perm, tag, extra);\n         (stack, tag)\n     }\n-}\n \n-impl AllocationExtra<Tag> for Stacks {\n     #[inline(always)]\n-    fn memory_read<'tcx>(\n-        alloc: &Allocation<Tag, Stacks>,\n+    pub fn memory_read<'tcx>(\n+        &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        alloc.extra.for_each(ptr, size, |stack, global| {\n+        self.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Read, ptr.tag, global)?;\n             Ok(())\n         })\n     }\n \n     #[inline(always)]\n-    fn memory_written<'tcx>(\n-        alloc: &mut Allocation<Tag, Stacks>,\n+    pub fn memory_written<'tcx>(\n+        &mut self,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        alloc.extra.for_each(ptr, size, |stack, global| {\n+        self.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Write, ptr.tag, global)?;\n             Ok(())\n         })\n     }\n \n     #[inline(always)]\n-    fn memory_deallocated<'tcx>(\n-        alloc: &mut Allocation<Tag, Stacks>,\n+    pub fn memory_deallocated<'tcx>(\n+        &mut self,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        alloc.extra.for_each(ptr, size, |stack, global| {\n+        self.for_each(ptr, size, |stack, global| {\n             stack.dealloc(ptr.tag, global)\n         })\n     }\n@@ -554,14 +553,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    alloc.extra.for_each(cur_ptr, size, |stack, global| {\n+                    alloc.extra.stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n                         stack.grant(cur_ptr.tag, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        alloc.extra.for_each(ptr, size, |stack, global| {\n+        alloc.extra.stacked_borrows.for_each(ptr, size, |stack, global| {\n             stack.grant(ptr.tag, item, global)\n         })\n     }\n@@ -588,7 +587,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Compute new borrow.\n         let new_tag = match kind {\n             RefKind::Raw { .. } => Tag::Untagged,\n-            _ => Tag::Tagged(this.memory().extra.borrow_mut().new_ptr()),\n+            _ => Tag::Tagged(this.memory().extra.stacked_borrows.borrow_mut().new_ptr()),\n         };\n \n         // Reborrow."}, {"sha": "f4064cf92e2ca47f89214a821e86bb54ec51817d", "filename": "tests/compile-fail/intptrcast_cast_int_to_fn_ptr.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/tests%2Fcompile-fail%2Fintptrcast_cast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/tests%2Fcompile-fail%2Fintptrcast_cast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintptrcast_cast_int_to_fn_ptr.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -0,0 +1,10 @@\n+// Validation makes this fail in the wrong place\n+// compile-flags: -Zmiri-disable-validation -Zmiri-seed=0000000000000000\n+\n+fn main() {\n+    let g = unsafe {\n+        std::mem::transmute::<usize, fn(i32)>(42)\n+    };\n+\n+    g(42) //~ ERROR dangling pointer was dereferenced\n+}"}, {"sha": "0c5d46609cf83ac71ac4277a5365b3d82ab87e99", "filename": "tests/compile-fail/intptrcast_null_pointer_deref.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/tests%2Fcompile-fail%2Fintptrcast_null_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/tests%2Fcompile-fail%2Fintptrcast_null_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintptrcast_null_pointer_deref.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -0,0 +1,6 @@\n+// compile-flags: -Zmiri-seed=0000000000000000\n+\n+fn main() {\n+    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR invalid use of NULL pointer\n+    panic!(\"this should never print: {}\", x);\n+}"}, {"sha": "2ee664eb68bd3da356da1fbecce54d0bdb94b15f", "filename": "tests/compile-fail/intptrcast_wild_pointer_deref.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/tests%2Fcompile-fail%2Fintptrcast_wild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/tests%2Fcompile-fail%2Fintptrcast_wild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintptrcast_wild_pointer_deref.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: -Zmiri-seed=0000000000000000\n+\n+fn main() {\n+    let p = 44 as *const i32;\n+    let x = unsafe { *p }; //~ ERROR dangling pointer was dereferenced\n+    panic!(\"this should never print: {}\", x);\n+}"}, {"sha": "4ff57caf95c27755f9890b15fef98339620e3e05", "filename": "tests/run-pass/intptrcast.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/945f007c0d305c3ec069b5e5d911ef783f6d70e7/tests%2Frun-pass%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945f007c0d305c3ec069b5e5d911ef783f6d70e7/tests%2Frun-pass%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintptrcast.rs?ref=945f007c0d305c3ec069b5e5d911ef783f6d70e7", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: -Zmiri-seed=0000000000000000\n+\n+fn main() {\n+    let x = &42 as *const i32 as usize; \n+    let y = x * 2;\n+    assert_eq!(y, x + x);\n+    let z = y as u8 as usize;\n+    assert_eq!(z, y % 256);\n+}"}]}