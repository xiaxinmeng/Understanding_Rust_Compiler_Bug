{"sha": "d9e9fedfe579b0062645e3be06284a9246228b8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZTlmZWRmZTU3OWIwMDYyNjQ1ZTNiZTA2Mjg0YTkyNDYyMjhiOGU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-04-08T20:01:39Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-04-14T12:57:02Z"}, "message": "Remove CodegenCx::finalize and pass Module separately from CodegenCx", "tree": {"sha": "e0e4a638f30bc6425b384045c79e4c10a380231a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0e4a638f30bc6425b384045c79e4c10a380231a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9e9fedfe579b0062645e3be06284a9246228b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e9fedfe579b0062645e3be06284a9246228b8e", "html_url": "https://github.com/rust-lang/rust/commit/d9e9fedfe579b0062645e3be06284a9246228b8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9e9fedfe579b0062645e3be06284a9246228b8e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e2bdb94ec0a87ed3a2c711c6aaffb1447b06dbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e2bdb94ec0a87ed3a2c711c6aaffb1447b06dbf", "html_url": "https://github.com/rust-lang/rust/commit/3e2bdb94ec0a87ed3a2c711c6aaffb1447b06dbf"}], "stats": {"total": 213, "additions": 102, "deletions": 111}, "files": [{"sha": "f450f366787136ff1896ebc78bef58a66596299f", "filename": "src/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -71,8 +71,8 @@ pub(crate) fn import_function<'tcx>(\n impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(self.tcx, self.cx.module, inst);\n-        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = import_function(self.tcx, self.module, inst);\n+        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n         if self.clif_comments.enabled() {\n             self.add_comment(func_ref, format!(\"{:?}\", inst));\n@@ -89,8 +89,8 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         args: &[Value],\n     ) -> &[Value] {\n         let sig = Signature { params, returns, call_conv: CallConv::triple_default(self.triple()) };\n-        let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n-        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = self.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n+        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         if self.clif_comments.enabled() {\n             self.add_comment(call_inst, format!(\"easy_call {}\", name));"}, {"sha": "069166f7b68a015dbe8263c22cf75a1be139e2e6", "filename": "src/base.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -9,7 +9,11 @@ use rustc_target::abi::call::FnAbi;\n use crate::constant::ConstantCx;\n use crate::prelude::*;\n \n-pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: Instance<'tcx>) {\n+pub(crate) fn codegen_fn<'tcx>(\n+    cx: &mut crate::CodegenCx<'tcx>,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+) {\n     let tcx = cx.tcx;\n \n     let _inst_guard =\n@@ -20,8 +24,8 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n \n     // Declare function\n     let symbol_name = tcx.symbol_name(instance);\n-    let sig = get_function_sig(tcx, cx.module.isa().triple(), instance);\n-    let func_id = cx.module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n+    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n+    let func_id = module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n \n     cx.cached_context.clear();\n \n@@ -40,11 +44,12 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n         (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n-    let pointer_type = cx.module.target_config().pointer_type();\n+    let pointer_type = module.target_config().pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n     let mut fx = FunctionCx {\n         cx,\n+        module,\n         tcx,\n         pointer_type,\n         vtables: FxHashMap::default(),\n@@ -94,7 +99,7 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     let source_info_set = fx.source_info_set;\n     let local_map = fx.local_map;\n \n-    fx.constants_cx.finalize(fx.tcx, &mut *fx.cx.module);\n+    fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n     // Store function in context\n     let context = &mut cx.cached_context;\n@@ -114,16 +119,15 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     // instruction, which doesn't have an encoding.\n     context.compute_cfg();\n     context.compute_domtree();\n-    context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n-    context.dce(cx.module.isa()).unwrap();\n+    context.eliminate_unreachable_code(module.isa()).unwrap();\n+    context.dce(module.isa()).unwrap();\n     // Some Cranelift optimizations expect the domtree to not yet be computed and as such don't\n     // invalidate it when it would change.\n     context.domtree.clear();\n \n     context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n \n     // Define function\n-    let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n         module\n             .define_function(func_id, context, &mut NullTrapSink {}, &mut NullStackMapSink {})\n@@ -134,7 +138,7 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     crate::pretty_clif::write_clif_file(\n         tcx,\n         \"opt\",\n-        Some(cx.module.isa()),\n+        Some(module.isa()),\n         instance,\n         &context,\n         &clif_comments,\n@@ -149,7 +153,7 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     }\n \n     // Define debuginfo for function\n-    let isa = cx.module.isa();\n+    let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n     tcx.sess.time(\"generate debug info\", || {\n@@ -654,7 +658,7 @@ fn codegen_stmt<'tcx>(\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n                         let val = operand.load_scalar(fx);\n-                        fx.bcx.call_memset(fx.cx.module.target_config(), addr, val, times);\n+                        fx.bcx.call_memset(fx.module.target_config(), addr, val, times);\n                     } else {\n                         let loop_block = fx.bcx.create_block();\n                         let loop_block2 = fx.bcx.create_block();\n@@ -834,7 +838,7 @@ fn codegen_stmt<'tcx>(\n             let elem_size: u64 = pointee.size.bytes();\n             let bytes =\n                 if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n-            fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, bytes);\n+            fx.bcx.call_memcpy(fx.module.target_config(), dst, src, bytes);\n         }\n     }\n }"}, {"sha": "92e4435565ee7575d0e77e8756f1f8040b7de0ce", "filename": "src/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -228,8 +228,9 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n-pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'m, 'tcx>,\n+pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx>,\n+    pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n     pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n@@ -341,7 +342,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     }\n \n     pub(crate) fn triple(&self) -> &target_lexicon::Triple {\n-        self.cx.module.isa().triple()\n+        self.module.isa().triple()\n     }\n \n     pub(crate) fn anonymous_str(&mut self, prefix: &str, msg: &str) -> Value {\n@@ -354,15 +355,14 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let mut data_ctx = DataContext::new();\n         data_ctx.define(msg.as_bytes().to_vec().into_boxed_slice());\n         let msg_id = self\n-            .cx\n             .module\n             .declare_data(&format!(\"__{}_{:08x}\", prefix, msg_hash), Linkage::Local, false, false)\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n-        let _ = self.cx.module.define_data(msg_id, &data_ctx);\n+        let _ = self.module.define_data(msg_id, &data_ctx);\n \n-        let local_msg_id = self.cx.module.declare_data_in_func(msg_id, self.bcx.func);\n+        let local_msg_id = self.module.declare_data_in_func(msg_id, self.bcx.func);\n         if self.clif_comments.enabled() {\n             self.add_comment(local_msg_id, msg);\n         }"}, {"sha": "0a0e02d26394e7fee322ae991fe41e915a9e34b9", "filename": "src/constant.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::ConstKind;\n use cranelift_codegen::ir::GlobalValueData;\n use cranelift_module::*;\n \n-use crate::{prelude::*, CodegenCx};\n+use crate::prelude::*;\n \n pub(crate) struct ConstantCx {\n     todo: Vec<TodoItem>,\n@@ -78,19 +78,19 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     all_constants_ok\n }\n \n-pub(crate) fn codegen_static(cx: &mut CodegenCx<'_, '_>, def_id: DefId) {\n+pub(crate) fn codegen_static(tcx: TyCtxt<'_>, module: &mut dyn Module, def_id: DefId) {\n     let mut constants_cx = ConstantCx::new();\n     constants_cx.todo.push(TodoItem::Static(def_id));\n-    constants_cx.finalize(cx.tcx, &mut *cx.module);\n+    constants_cx.finalize(tcx, module);\n }\n \n pub(crate) fn codegen_tls_ref<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n     }\n@@ -103,8 +103,8 @@ fn codegen_static_ref<'tcx>(\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n     }\n@@ -191,29 +191,28 @@ pub(crate) fn codegen_const_value<'tcx>(\n                             fx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n                             let data_id = data_id_for_alloc_id(\n                                 &mut fx.constants_cx,\n-                                fx.cx.module,\n+                                fx.module,\n                                 ptr.alloc_id,\n                                 alloc.mutability,\n                             );\n                             let local_data_id =\n-                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                                fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             if fx.clif_comments.enabled() {\n                                 fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n                             }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n-                            let func_id =\n-                                crate::abi::import_function(fx.tcx, fx.cx.module, instance);\n+                            let func_id = crate::abi::import_function(fx.tcx, fx.module, instance);\n                             let local_func_id =\n-                                fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n+                                fx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n+                            let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n                             let local_data_id =\n-                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                                fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             if fx.clif_comments.enabled() {\n                                 fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n                             }\n@@ -255,9 +254,9 @@ fn pointer_for_allocation<'tcx>(\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n     fx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n     let data_id =\n-        data_id_for_alloc_id(&mut fx.constants_cx, &mut *fx.cx.module, alloc_id, alloc.mutability);\n+        data_id_for_alloc_id(&mut fx.constants_cx, &mut *fx.module, alloc_id, alloc.mutability);\n \n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n     }"}, {"sha": "fc1dd558603802f827c0456da26504a228ef6107", "filename": "src/driver/aot.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -112,16 +112,18 @@ fn module_codegen(\n     let mut cx = crate::CodegenCx::new(\n         tcx,\n         backend_config.clone(),\n-        &mut module,\n+        module.isa(),\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n     );\n-    super::predefine_mono_items(&mut cx, &mono_items);\n+    super::predefine_mono_items(tcx, &mut module, &mono_items);\n     for (mono_item, _) in mono_items {\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n+                cx.tcx\n+                    .sess\n+                    .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, &mut module, inst));\n             }\n-            MonoItem::Static(def_id) => crate::constant::codegen_static(&mut cx, def_id),\n+            MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n             MonoItem::GlobalAsm(item_id) => {\n                 let item = cx.tcx.hir().item(item_id);\n                 if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n@@ -133,21 +135,19 @@ fn module_codegen(\n             }\n         }\n     }\n-    let (global_asm, debug, mut unwind_context) =\n-        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut cx.unwind_context);\n \n     let codegen_result = emit_module(\n         tcx,\n         &backend_config,\n         cgu.name().as_str().to_string(),\n         ModuleKind::Regular,\n         module,\n-        debug,\n-        unwind_context,\n+        cx.debug_context,\n+        cx.unwind_context,\n     );\n \n-    codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n+    codegen_global_asm(tcx, &cgu.name().as_str(), &cx.global_asm);\n \n     codegen_result\n }"}, {"sha": "13cfad8df2e22965b85fc02e0709371743a520f0", "filename": "src/driver/jit.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -44,44 +44,44 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, backend_config.clone(), &mut jit_module, false);\n+    let mut cx = crate::CodegenCx::new(tcx, backend_config.clone(), jit_module.isa(), false);\n \n     super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n-        super::predefine_mono_items(&mut cx, &mono_items);\n+        super::predefine_mono_items(tcx, &mut jit_module, &mono_items);\n         for (mono_item, _) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n+                        cx.tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_fn(&mut cx, &mut jit_module, inst)\n+                        });\n                     }\n-                    CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n+                    CodegenMode::JitLazy => codegen_shim(&mut cx, &mut jit_module, inst),\n                 },\n                 MonoItem::Static(def_id) => {\n-                    crate::constant::codegen_static(&mut cx, def_id);\n+                    crate::constant::codegen_static(tcx, &mut jit_module, def_id);\n                 }\n                 MonoItem::GlobalAsm(item_id) => {\n-                    let item = cx.tcx.hir().item(item_id);\n+                    let item = tcx.hir().item(item_id);\n                     tcx.sess.span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n                 }\n             }\n         }\n     });\n \n-    let (global_asm, _debug, mut unwind_context) =\n-        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n     jit_module.finalize_definitions();\n \n-    if !global_asm.is_empty() {\n+    if !cx.global_asm.is_empty() {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n+    crate::allocator::codegen(tcx, &mut jit_module, &mut cx.unwind_context);\n \n     tcx.sess.abort_if_errors();\n \n     jit_module.finalize_definitions();\n-    let _unwind_register_guard = unsafe { unwind_context.register_jit(&jit_module) };\n+    let _unwind_register_guard = unsafe { cx.unwind_context.register_jit(&jit_module) };\n \n     println!(\n         \"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\"\n@@ -171,13 +171,12 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n             let func_id = jit_module.declare_function(&name, Linkage::Export, &sig).unwrap();\n             jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n-            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n-            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance));\n+            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module.isa(), false);\n+            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, jit_module, instance));\n \n-            let (global_asm, _debug_context, unwind_context) = cx.finalize();\n-            assert!(global_asm.is_empty());\n+            assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions();\n-            std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n+            std::mem::forget(unsafe { cx.unwind_context.register_jit(&jit_module) });\n             jit_module.get_finalized_function(func_id)\n         })\n     })\n@@ -247,24 +246,23 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     imported_symbols\n }\n \n-fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n+fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n-    let pointer_type = cx.module.target_config().pointer_type();\n+    let pointer_type = module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name.to_string();\n-    let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n-    let func_id = cx.module.declare_function(&name, Linkage::Export, &sig).unwrap();\n+    let sig = crate::abi::get_function_sig(tcx, module.isa().triple(), inst);\n+    let func_id = module.declare_function(&name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));\n \n-    let jit_fn = cx\n-        .module\n+    let jit_fn = module\n         .declare_function(\n             \"__clif_jit_fn\",\n             Linkage::Import,\n             &Signature {\n-                call_conv: cx.module.target_config().default_call_conv,\n+                call_conv: module.target_config().default_call_conv,\n                 params: vec![AbiParam::new(pointer_type)],\n                 returns: vec![AbiParam::new(pointer_type)],\n             },\n@@ -278,7 +276,7 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n     let mut builder_ctx = FunctionBuilderContext::new();\n     let mut trampoline_builder = FunctionBuilder::new(trampoline, &mut builder_ctx);\n \n-    let jit_fn = cx.module.declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let jit_fn = module.declare_func_in_func(jit_fn, trampoline_builder.func);\n     let sig_ref = trampoline_builder.func.import_signature(sig);\n \n     let entry_block = trampoline_builder.create_block();\n@@ -293,7 +291,7 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n-    cx.module\n+    module\n         .define_function(\n             func_id,\n             &mut cx.cached_context,"}, {"sha": "27fd7a2f2d8866b73248b3fc610845fea937ff67", "filename": "src/driver/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -40,24 +40,25 @@ pub(crate) fn codegen_crate(\n }\n \n fn predefine_mono_items<'tcx>(\n-    cx: &mut crate::CodegenCx<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    module: &mut dyn Module,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n-    cx.tcx.sess.time(\"predefine functions\", || {\n-        let is_compiler_builtins = cx.tcx.is_compiler_builtins(LOCAL_CRATE);\n+    tcx.sess.time(\"predefine functions\", || {\n+        let is_compiler_builtins = tcx.is_compiler_builtins(LOCAL_CRATE);\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n-                    let name = cx.tcx.symbol_name(instance).name.to_string();\n+                    let name = tcx.symbol_name(instance).name.to_string();\n                     let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n-                    let sig = get_function_sig(cx.tcx, cx.module.isa().triple(), instance);\n+                    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n                     let linkage = crate::linkage::get_clif_linkage(\n                         mono_item,\n                         linkage,\n                         visibility,\n                         is_compiler_builtins,\n                     );\n-                    cx.module.declare_function(&name, linkage, &sig).unwrap();\n+                    module.declare_function(&name, linkage, &sig).unwrap();\n                 }\n                 MonoItem::Static(_) | MonoItem::GlobalAsm(_) => {}\n             }"}, {"sha": "669a6d35075b4fed74ac79cafb35a9108e6ee47f", "filename": "src/inline_asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -201,7 +201,6 @@ fn call_inline_asm<'tcx>(\n     }\n \n     let inline_asm_func = fx\n-        .cx\n         .module\n         .declare_function(\n             asm_name,\n@@ -213,7 +212,7 @@ fn call_inline_asm<'tcx>(\n             },\n         )\n         .unwrap();\n-    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    let inline_asm_func = fx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(inline_asm_func, asm_name);\n     }"}, {"sha": "d08271f853b50eb62d63e2ab4de882ce53d7ec25", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -498,10 +498,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             if intrinsic.contains(\"nonoverlapping\") {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         // NOTE: the volatile variants have src and dst swapped\n@@ -517,10 +517,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // FIXME make the copy actually volatile when using emit_small_mem{cpy,move}\n             if intrinsic.contains(\"nonoverlapping\") {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         size_of_val, <T> (c ptr) {\n@@ -670,7 +670,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let dst_ptr = dst.load_scalar(fx);\n             // FIXME make the memset actually volatile when switching to emit_small_memset\n             // FIXME use emit_small_memset\n-            fx.bcx.call_memset(fx.cx.module.target_config(), dst_ptr, val, count);\n+            fx.bcx.call_memset(fx.module.target_config(), dst_ptr, val, count);\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n             // FIXME trap on `ctlz_nonzero` with zero arg."}, {"sha": "1afd35af352eb207a23664b7fc02f82eec9c558c", "filename": "src/lib.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -33,6 +33,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_session::config::OutputFilenames;\n use rustc_session::Session;\n \n+use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::settings::{self, Configurable};\n \n pub use crate::config::*;\n@@ -118,42 +119,32 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n     }\n }\n \n-struct CodegenCx<'m, 'tcx: 'm> {\n+struct CodegenCx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    module: &'m mut dyn Module,\n     global_asm: String,\n     cached_context: Context,\n     debug_context: Option<DebugContext<'tcx>>,\n     unwind_context: UnwindContext,\n }\n \n-impl<'m, 'tcx> CodegenCx<'m, 'tcx> {\n+impl<'tcx> CodegenCx<'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n         backend_config: BackendConfig,\n-        module: &'m mut dyn Module,\n+        isa: &dyn TargetIsa,\n         debug_info: bool,\n     ) -> Self {\n-        let unwind_context = UnwindContext::new(\n-            tcx,\n-            module.isa(),\n-            matches!(backend_config.codegen_mode, CodegenMode::Aot),\n-        );\n-        let debug_context =\n-            if debug_info { Some(DebugContext::new(tcx, module.isa())) } else { None };\n+        let unwind_context =\n+            UnwindContext::new(tcx, isa, matches!(backend_config.codegen_mode, CodegenMode::Aot));\n+        let debug_context = if debug_info { Some(DebugContext::new(tcx, isa)) } else { None };\n         CodegenCx {\n             tcx,\n-            module,\n             global_asm: String::new(),\n             cached_context: Context::new(),\n             debug_context,\n             unwind_context,\n         }\n     }\n-\n-    fn finalize(self) -> (String, Option<DebugContext<'tcx>>, UnwindContext) {\n-        (self.global_asm, self.debug_context, self.unwind_context)\n-    }\n }\n \n pub struct CraneliftCodegenBackend {"}, {"sha": "819c8b51558a051321ef9f1670c2771f6937b301", "filename": "src/trap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -4,7 +4,6 @@ use crate::prelude::*;\n \n fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     let puts = fx\n-        .cx\n         .module\n         .declare_function(\n             \"puts\",\n@@ -16,7 +15,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n             },\n         )\n         .unwrap();\n-    let puts = fx.cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n+    let puts = fx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(puts, \"puts\");\n     }"}, {"sha": "9a572c3501f925b7adc726c64e30755e9ade2fef", "filename": "src/value_and_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -554,7 +554,7 @@ impl<'tcx> CPlace<'tcx> {\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n                 fx.bcx.emit_small_memory_copy(\n-                    fx.cx.module.target_config(),\n+                    fx.module.target_config(),\n                     to_addr,\n                     from_addr,\n                     size,"}, {"sha": "29e960bb84db7b260fa841c4475c7314189951c6", "filename": "src/vtable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e9fedfe579b0062645e3be06284a9246228b8e/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=d9e9fedfe579b0062645e3be06284a9246228b8e", "patch": "@@ -80,7 +80,7 @@ pub(crate) fn get_vtable<'tcx>(\n         data_id\n     };\n \n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n }\n \n@@ -94,7 +94,7 @@ fn build_vtable<'tcx>(\n \n     let drop_in_place_fn = import_function(\n         tcx,\n-        fx.cx.module,\n+        fx.module,\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n@@ -111,7 +111,7 @@ fn build_vtable<'tcx>(\n         opt_mth.map(|(def_id, substs)| {\n             import_function(\n                 tcx,\n-                fx.cx.module,\n+                fx.module,\n                 Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n                     .unwrap()\n                     .polymorphize(fx.tcx),\n@@ -132,16 +132,16 @@ fn build_vtable<'tcx>(\n \n     for (i, component) in components.into_iter().enumerate() {\n         if let Some(func_id) = component {\n-            let func_ref = fx.cx.module.declare_func_in_data(func_id, &mut data_ctx);\n+            let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n             data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n         }\n     }\n \n     data_ctx.set_align(fx.tcx.data_layout.pointer_align.pref.bytes());\n \n-    let data_id = fx.cx.module.declare_anonymous_data(false, false).unwrap();\n+    let data_id = fx.module.declare_anonymous_data(false, false).unwrap();\n \n-    fx.cx.module.define_data(data_id, &data_ctx).unwrap();\n+    fx.module.define_data(data_id, &data_ctx).unwrap();\n \n     data_id\n }"}]}