{"sha": "cfafc1b7377d34d8c60db7cd386836d39b80af41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYWZjMWI3Mzc3ZDM0ZDhjNjBkYjdjZDM4NjgzNmQzOWI4MGFmNDE=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-03T01:04:32Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-06T16:03:18Z"}, "message": "Prelude: rename and consolidate extension traits\n\nThis commit renames a number of extension traits for slices and string\nslices, now that they have been refactored for DST. In many cases,\nmultiple extension traits could now be consolidated. Further\nconsolidation will be possible with generalized where clauses.\n\nThe renamings are consistent with the [new `-Prelude`\nsuffix](https://github.com/rust-lang/rfcs/pull/344). There are probably\na few more candidates for being renamed this way, but that is left for\nAPI stabilization of the relevant modules.\n\nBecause this renames traits, it is a:\n\n[breaking-change]\n\nHowever, I do not expect any code that currently uses the standard\nlibrary to actually break.\n\nCloses #17917", "tree": {"sha": "fc5490eb766f91db85f6fa6061a48efd23f0457e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc5490eb766f91db85f6fa6061a48efd23f0457e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfafc1b7377d34d8c60db7cd386836d39b80af41", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfafc1b7377d34d8c60db7cd386836d39b80af41", "html_url": "https://github.com/rust-lang/rust/commit/cfafc1b7377d34d8c60db7cd386836d39b80af41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfafc1b7377d34d8c60db7cd386836d39b80af41/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e84e7a00ddec76570bbaa9afea385d544f616814", "url": "https://api.github.com/repos/rust-lang/rust/commits/e84e7a00ddec76570bbaa9afea385d544f616814", "html_url": "https://github.com/rust-lang/rust/commit/e84e7a00ddec76570bbaa9afea385d544f616814"}], "stats": {"total": 970, "additions": 483, "deletions": 487}, "files": [{"sha": "fb003f47c3e43200d32fa9bbbddd49433154e959", "filename": "src/etc/unicode.py", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -293,7 +293,7 @@ def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableSlice;\n+    use core::slice::SlicePrelude;\n     r.binary_search(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n@@ -351,7 +351,7 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     f.write(\"pub mod conversions {\")\n     f.write(\"\"\"\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableSlice;\n+    use core::slice::SlicePrelude;\n     use core::tuple::Tuple2;\n     use core::option::{Option, Some, None};\n     use core::slice;\n@@ -390,7 +390,7 @@ def emit_conversions_module(f, lowerupper, upperlower):\n \n def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n     f.write(\"\"\"pub mod grapheme {\n-    use core::slice::ImmutableSlice;\n+    use core::slice::SlicePrelude;\n     use core::slice;\n \n     #[allow(non_camel_case_types)]\n@@ -430,7 +430,7 @@ def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n def emit_charwidth_module(f, width_table):\n     f.write(\"pub mod charwidth {\\n\")\n     f.write(\"    use core::option::{Option, Some, None};\\n\")\n-    f.write(\"    use core::slice::ImmutableSlice;\\n\")\n+    f.write(\"    use core::slice::SlicePrelude;\\n\")\n     f.write(\"    use core::slice;\\n\")\n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n@@ -530,7 +530,7 @@ def comp_pfun(char):\n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n         use core::cmp::{Equal, Less, Greater};\n-        use core::slice::ImmutableSlice;\n+        use core::slice::SlicePrelude;\n         use core::slice;\n         match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }"}, {"sha": "43faaac39523c8bef109e21d787cb246b7bebfb0", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -290,7 +290,7 @@ mod tests {\n     use core::kinds::Sized;\n     use std::mem;\n \n-    use slice::ImmutableSlice;\n+    use slice::SlicePrelude;\n     use super::{Hash, Hasher, Writer};\n \n     struct MyWriterHasher;"}, {"sha": "788ea13678f31004711fe1a706301de65da975ba", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -273,7 +273,7 @@ mod tests {\n \n     use str::Str;\n     use string::String;\n-    use slice::{AsSlice, ImmutableSlice};\n+    use slice::{AsSlice, SlicePrelude};\n     use vec::Vec;\n \n     use super::super::{Hash, Writer};"}, {"sha": "0d9a166c7ff96d2e8ed1ca9e4307cdd440dd63b4", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 56, "deletions": 154, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -42,10 +42,10 @@\n //!\n //! ## Traits\n //!\n-//! A number of traits add methods that allow you to accomplish tasks with slices.\n-//! These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n-//! `MutableSlice`, defined for `&mut [T]` types, and `Slice` and `SliceMut`\n-//! which are defined for `[T]`.\n+//! A number of traits add methods that allow you to accomplish tasks\n+//! with slices, the most important being `SlicePrelude`. Other traits\n+//! apply only to slices of elements satisfying certain bounds (like\n+//! `Ord`).\n //!\n //! An example is the `slice` method which enables slicing syntax `[a..b]` that\n //! returns an immutable \"view\" into a `Vec` or another slice from the index\n@@ -99,11 +99,11 @@ use core::iter::{range_step, MultiplicativeIterator};\n \n use vec::Vec;\n \n-pub use core::slice::{Chunks, AsSlice, ImmutableSlice, ImmutablePartialEqSlice};\n-pub use core::slice::{ImmutableOrdSlice, MutableSlice, Items, MutItems};\n+pub use core::slice::{Chunks, AsSlice, SlicePrelude, PartialEqSlicePrelude};\n+pub use core::slice::{OrdSlicePrelude, SlicePrelude, Items, MutItems};\n pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n pub use core::slice::{MutSplits, MutChunks, Splits};\n-pub use core::slice::{bytes, mut_ref_slice, ref_slice, MutableCloneableSlice};\n+pub use core::slice::{bytes, mut_ref_slice, ref_slice, CloneSlicePrelude};\n pub use core::slice::{Found, NotFound};\n \n // Functional utilities\n@@ -266,29 +266,13 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n     }\n }\n \n-/// Extension methods for vector slices with cloneable elements\n-pub trait CloneableVector<T> for Sized? {\n-    /// Copies `self` into a new `Vec`.\n-    fn to_vec(&self) -> Vec<T>;\n-}\n-\n-impl<T: Clone> CloneableVector<T> for [T] {\n-    /// Returns a copy of `v`.\n-    #[inline]\n-    fn to_vec(&self) -> Vec<T> {\n-        let mut vector = Vec::with_capacity(self.len());\n-        vector.push_all(self);\n-        vector\n-    }\n-}\n-\n-#[experimental]\n-pub trait BoxedSlice<T> {\n+/// Extension methods for boxed slices.\n+pub trait BoxedSlicePrelude<T> {\n     /// Convert `self` into a vector without clones or allocation.\n     fn into_vec(self) -> Vec<T>;\n }\n \n-impl<T> BoxedSlice<T> for Box<[T]> {\n+impl<T> BoxedSlicePrelude<T> for Box<[T]> {\n     #[experimental]\n     fn into_vec(mut self) -> Vec<T> {\n         unsafe {\n@@ -299,8 +283,11 @@ impl<T> BoxedSlice<T> for Box<[T]> {\n     }\n }\n \n-/// Extension methods for vectors containing `Clone` elements.\n-pub trait ImmutableCloneableVector<T> for Sized? {\n+/// Allocating extension methods for slices containing `Clone` elements.\n+pub trait CloneSliceAllocPrelude<T> for Sized? {\n+    /// Copies `self` into a new `Vec`.\n+    fn to_vec(&self) -> Vec<T>;\n+\n     /// Partitions the vector into two vectors `(a, b)`, where all\n     /// elements of `a` satisfy `f` and all elements of `b` do not.\n     fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n@@ -332,7 +319,16 @@ pub trait ImmutableCloneableVector<T> for Sized? {\n     fn permutations(&self) -> Permutations<T>;\n }\n \n-impl<T: Clone> ImmutableCloneableVector<T> for [T] {\n+impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n+    /// Returns a copy of `v`.\n+    #[inline]\n+    fn to_vec(&self) -> Vec<T> {\n+        let mut vector = Vec::with_capacity(self.len());\n+        vector.push_all(self);\n+        vector\n+    }\n+\n+\n     #[inline]\n     fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts  = Vec::new();\n@@ -562,9 +558,36 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     }\n }\n \n-/// Extension methods for vectors such that their elements are\n-/// mutable.\n-pub trait MutableSliceAllocating<T> for Sized? {\n+/// Allocating extension methods for slices on Ord values.\n+#[experimental = \"likely to merge with other traits\"]\n+pub trait OrdSliceAllocPrelude<T> for Sized? {\n+    /// Sorts the slice, in place.\n+    ///\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [-5i, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert!(v == [-5i, -3, 1, 2, 4]);\n+    /// ```\n+    #[experimental]\n+    fn sort(&mut self);\n+}\n+\n+impl<T: Ord> OrdSliceAllocPrelude<T> for [T] {\n+    #[experimental]\n+    #[inline]\n+    fn sort(&mut self) {\n+        self.sort_by(|a, b| a.cmp(b))\n+    }\n+}\n+\n+/// Allocating extension methods for slices.\n+#[experimental = \"likely to merge with other traits\"]\n+pub trait SliceAllocPrelude<T> for Sized? {\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -608,7 +631,7 @@ pub trait MutableSliceAllocating<T> for Sized? {\n     fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n }\n \n-impl<T> MutableSliceAllocating<T> for [T] {\n+impl<T> SliceAllocPrelude<T> for [T] {\n     #[inline]\n     fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n         merge_sort(self, compare)\n@@ -623,127 +646,6 @@ impl<T> MutableSliceAllocating<T> for [T] {\n     }\n }\n \n-/// Methods for mutable vectors with orderable elements, such as\n-/// in-place sorting.\n-pub trait MutableOrdSlice<T> for Sized? {\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [-5i, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5i, -3, 1, 2, 4]);\n-    /// ```\n-    fn sort(&mut self);\n-\n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    fn next_permutation(&mut self) -> bool;\n-\n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    fn prev_permutation(&mut self) -> bool;\n-}\n-\n-impl<T: Ord> MutableOrdSlice<T> for [T] {\n-    #[inline]\n-    fn sort(&mut self) {\n-        self.sort_by(|a, b| a.cmp(b))\n-    }\n-\n-    fn next_permutation(&mut self) -> bool {\n-        // These cases only have 1 permutation each, so we can't do anything.\n-        if self.len() < 2 { return false; }\n-\n-        // Step 1: Identify the longest, rightmost weakly decreasing part of the vector\n-        let mut i = self.len() - 1;\n-        while i > 0 && self[i-1] >= self[i] {\n-            i -= 1;\n-        }\n-\n-        // If that is the entire vector, this is the last-ordered permutation.\n-        if i == 0 {\n-            return false;\n-        }\n-\n-        // Step 2: Find the rightmost element larger than the pivot (i-1)\n-        let mut j = self.len() - 1;\n-        while j >= i && self[j] <= self[i-1]  {\n-            j -= 1;\n-        }\n-\n-        // Step 3: Swap that element with the pivot\n-        self.swap(j, i-1);\n-\n-        // Step 4: Reverse the (previously) weakly decreasing part\n-        self[mut i..].reverse();\n-\n-        true\n-    }\n-\n-    fn prev_permutation(&mut self) -> bool {\n-        // These cases only have 1 permutation each, so we can't do anything.\n-        if self.len() < 2 { return false; }\n-\n-        // Step 1: Identify the longest, rightmost weakly increasing part of the vector\n-        let mut i = self.len() - 1;\n-        while i > 0 && self[i-1] <= self[i] {\n-            i -= 1;\n-        }\n-\n-        // If that is the entire vector, this is the first-ordered permutation.\n-        if i == 0 {\n-            return false;\n-        }\n-\n-        // Step 2: Reverse the weakly increasing part\n-        self[mut i..].reverse();\n-\n-        // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n-        let mut j = self.len() - 1;\n-        while j >= i && self[j-1] < self[i-1]  {\n-            j -= 1;\n-        }\n-\n-        // Step 4: Swap that element with the pivot\n-        self.swap(i-1, j);\n-\n-        true\n-    }\n-}\n-\n /// Unsafe operations\n pub mod raw {\n     pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};"}, {"sha": "ac840503aa2af717175944ca012ea725e6c63003", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -56,8 +56,8 @@ use core::fmt;\n use core::cmp;\n use core::iter::AdditiveIterator;\n use core::kinds::Sized;\n-use core::prelude::{Char, Clone, Eq, Equiv, ImmutableSlice};\n-use core::prelude::{Iterator, MutableSlice, None, Option, Ord, Ordering};\n+use core::prelude::{Char, Clone, Eq, Equiv};\n+use core::prelude::{Iterator, SlicePrelude, None, Option, Ord, Ordering};\n use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some, Tuple2};\n use core::prelude::{range};\n \n@@ -73,8 +73,8 @@ pub use core::str::{CharSplitsN, AnyLines, MatchIndices, StrSplits};\n pub use core::str::{Utf16CodeUnits, eq_slice, is_utf8, is_utf16, Utf16Items};\n pub use core::str::{Utf16Item, ScalarValue, LoneSurrogate, utf16_items};\n pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n-pub use core::str::{Str, StrSlice};\n-pub use unicode::str::{UnicodeStrSlice, Words, Graphemes, GraphemeIndices};\n+pub use core::str::{Str, StrPrelude};\n+pub use unicode::str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n \n /*\n Section: Creating a string\n@@ -790,10 +790,10 @@ mod tests {\n     use std::iter::{Iterator, DoubleEndedIterator};\n \n     use super::*;\n-    use std::slice::{AsSlice, ImmutableSlice};\n+    use std::slice::{AsSlice, SlicePrelude};\n     use string::String;\n     use vec::Vec;\n-    use slice::CloneableVector;\n+    use slice::CloneSliceAllocPrelude;\n \n     use unicode::char::UnicodeChar;\n \n@@ -2240,8 +2240,8 @@ mod bench {\n     use test::black_box;\n     use super::*;\n     use std::iter::{Iterator, DoubleEndedIterator};\n-    use std::str::StrSlice;\n-    use std::slice::ImmutableSlice;\n+    use std::str::StrPrelude;\n+    use std::slice::SlicePrelude;\n \n     #[bench]\n     fn char_iterator(b: &mut Bencher) {"}, {"sha": "b32760818b7c2fc381a9ce1b50169076dcd75a13", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -23,7 +23,7 @@ use core::ops;\n use core::raw::Slice as RawSlice;\n \n use hash;\n-use slice::CloneableVector;\n+use slice::CloneSliceAllocPrelude;\n use str;\n use str::{CharRange, StrAllocating, MaybeOwned, Owned};\n use str::Slice as MaybeOwnedSlice; // So many `Slice`s...\n@@ -815,7 +815,7 @@ pub mod raw {\n     /// * A raw pointer is dereferenced and transmuted to `&[u8]`;\n     /// * The slice is not checked to see whether it contains valid UTF-8.\n     pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n-        use slice::CloneableVector;\n+        use slice::CloneSliceAllocPrelude;\n         let slice: &[u8] = mem::transmute(Slice {\n             data: buf,\n             len: len,\n@@ -851,10 +851,10 @@ mod tests {\n     use test::Bencher;\n \n     use str;\n-    use str::{Str, StrSlice, Owned};\n+    use str::{Str, StrPrelude, Owned};\n     use super::{as_string, String};\n     use vec::Vec;\n-    use slice::CloneableVector;\n+    use slice::CloneSliceAllocPrelude;\n \n     #[test]\n     fn test_as_string() {"}, {"sha": "39f636a2438aa32ddaa20f19996296cfeda23a66", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -27,7 +27,7 @@ use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n-use slice::{CloneableVector};\n+use slice::{CloneSliceAllocPrelude};\n \n /// An owned, growable vector.\n ///\n@@ -1389,7 +1389,7 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n pub mod raw {\n     use super::Vec;\n     use core::ptr;\n-    use core::slice::MutableSlice;\n+    use core::slice::SlicePrelude;\n \n     /// Constructs a vector from an unsafe pointer to a buffer.\n     ///"}, {"sha": "f769eea377a1878154e095dfb44d9d46b1741ac2", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -18,7 +18,7 @@\n use mem::transmute;\n use option::{None, Option, Some};\n use iter::range_step;\n-use slice::ImmutableSlice;\n+use slice::SlicePrelude;\n \n // UTF-8 ranges and tags for encoding characters\n static TAG_CONT: u8    = 0b1000_0000u8;"}, {"sha": "a6e5b0cff5592da670bf674400d69d8284571241", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -16,8 +16,8 @@ use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n use num::{Zero, One, cast};\n use result::Ok;\n-use slice::{mod, ImmutableSlice, MutableSlice};\n-use str::StrSlice;\n+use slice::{mod, SlicePrelude};\n+use str::StrPrelude;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {"}, {"sha": "081f373b8310c1742d61205978d4aee6e126ec45", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -21,9 +21,9 @@ use option::{Option, Some, None};\n use ops::Deref;\n use result::{Ok, Err};\n use result;\n-use slice::{AsSlice, ImmutableSlice};\n+use slice::{AsSlice, SlicePrelude};\n use slice;\n-use str::StrSlice;\n+use str::StrPrelude;\n use str;\n \n pub use self::num::radix;"}, {"sha": "e4a6c1a97584fe249d69f5845a732f8ef83d1cc3", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -17,7 +17,7 @@\n use fmt;\n use iter::DoubleEndedIterator;\n use num::{Int, cast, zero};\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::SlicePrelude;\n \n /// A type that represents a specific radix\n #[doc(hidden)]"}, {"sha": "996f2e56ad35eb3b79926419ee0a4d6506a174e6", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -57,9 +57,9 @@ pub use num::{Primitive, Int, ToPrimitive, FromPrimitive};\n pub use option::{Option, Some, None};\n pub use ptr::RawPtr;\n pub use result::{Result, Ok, Err};\n-pub use str::{Str, StrSlice};\n+pub use str::{Str, StrPrelude};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-pub use slice::{ImmutablePartialEqSlice, ImmutableOrdSlice};\n-pub use slice::{AsSlice, ImmutableSlice, MutableSlice};\n+pub use slice::{PartialEqSlicePrelude, OrdSlicePrelude};\n+pub use slice::{AsSlice, SlicePrelude};"}, {"sha": "eaa52c99c4a2379b53eb670d9ce309ed8dbf893d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 310, "deletions": 219, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -57,9 +57,9 @@ use raw::Slice as RawSlice;\n // Extension traits\n //\n \n-/// Extension methods for immutable slices.\n-#[unstable = \"may merge with other traits; region parameter may disappear\"]\n-pub trait ImmutableSlice<T> for Sized? {\n+/// Extension methods for slices.\n+#[unstable = \"may merge with other traits\"]\n+pub trait SlicePrelude<T> for Sized? {\n     /// Returns a subslice spanning the interval [`start`, `end`).\n     ///\n     /// Fails when the end of the new slice lies beyond the end of the\n@@ -256,216 +256,12 @@ pub trait ImmutableSlice<T> for Sized? {\n     #[inline]\n     #[experimental = \"not triaged yet\"]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-#[unstable]\n-impl<T> ImmutableSlice<T> for [T] {\n-    #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &[T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                data: self.as_ptr().offset(start as int),\n-                len: (end - start)\n-            })\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, start: uint) -> &[T] {\n-        self.slice(start, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &[T] {\n-        self.slice(0, end)\n-    }\n-\n-    #[inline]\n-    fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n-        (self[..mid], self[mid..])\n-    }\n-\n-    #[inline]\n-    fn iter<'a>(&'a self) -> Items<'a, T> {\n-        unsafe {\n-            let p = self.as_ptr();\n-            if mem::size_of::<T>() == 0 {\n-                Items{ptr: p,\n-                      end: (p as uint + self.len()) as *const T,\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            } else {\n-                Items{ptr: p,\n-                      end: p.offset(self.len() as int),\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn split<'a>(&'a self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n-        Splits {\n-            v: self,\n-            pred: pred,\n-            finished: false\n-        }\n-    }\n \n-    #[inline]\n-    fn splitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: false\n-        }\n-    }\n-\n-    #[inline]\n-    fn rsplitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: true\n-        }\n-    }\n-\n-    #[inline]\n-    fn windows(&self, size: uint) -> Windows<T> {\n-        assert!(size != 0);\n-        Windows { v: self, size: size }\n-    }\n-\n-    #[inline]\n-    fn chunks(&self, size: uint) -> Chunks<T> {\n-        assert!(size != 0);\n-        Chunks { v: self, size: size }\n-    }\n-\n-    #[inline]\n-    fn get(&self, index: uint) -> Option<&T> {\n-        if index < self.len() { Some(&self[index]) } else { None }\n-    }\n-\n-    #[inline]\n-    fn head(&self) -> Option<&T> {\n-        if self.len() == 0 { None } else { Some(&self[0]) }\n-    }\n-\n-    #[inline]\n-    fn tail(&self) -> &[T] { self[1..] }\n-\n-    #[inline]\n-    fn init(&self) -> &[T] {\n-        self[..self.len() - 1]\n-    }\n-\n-    #[inline]\n-    fn last(&self) -> Option<&T> {\n-        if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n-    }\n-\n-    #[inline]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T {\n-        transmute(self.repr().data.offset(index as int))\n-    }\n-\n-    #[inline]\n-    fn as_ptr(&self) -> *const T {\n-        self.repr().data\n-    }\n-\n-    #[unstable]\n-    fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult {\n-        let mut base : uint = 0;\n-        let mut lim : uint = self.len();\n-\n-        while lim != 0 {\n-            let ix = base + (lim >> 1);\n-            match f(&self[ix]) {\n-                Equal => return Found(ix),\n-                Less => {\n-                    base = ix + 1;\n-                    lim -= 1;\n-                }\n-                Greater => ()\n-            }\n-            lim >>= 1;\n-        }\n-        return NotFound(base);\n-    }\n-\n-    #[inline]\n-    fn len(&self) -> uint { self.repr().len }\n-}\n-\n-\n-\n-impl<T> ops::Slice<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.slice_or_fail(start, &self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.slice_or_fail(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-\n-impl<T> ops::SliceMut<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        let len = &self.len();\n-        self.slice_or_fail_mut(start, len)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.slice_or_fail_mut(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-\n-/// Extension methods for slices such that their elements are\n-/// mutable.\n-#[experimental = \"may merge with other traits; may lose region param; needs review\"]\n-pub trait MutableSlice<T> for Sized? {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n     #[unstable = \"waiting on final error conventions\"]\n     fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n+\n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T];\n@@ -626,8 +422,146 @@ pub trait MutableSlice<T> for Sized? {\n     fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n-#[experimental = \"trait is experimental\"]\n-impl<T> MutableSlice<T> for [T] {\n+#[unstable]\n+impl<T> SlicePrelude<T> for [T] {\n+    #[inline]\n+    fn slice(&self, start: uint, end: uint) -> &[T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                data: self.as_ptr().offset(start as int),\n+                len: (end - start)\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    fn slice_from(&self, start: uint) -> &[T] {\n+        self.slice(start, self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to(&self, end: uint) -> &[T] {\n+        self.slice(0, end)\n+    }\n+\n+    #[inline]\n+    fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n+        (self[..mid], self[mid..])\n+    }\n+\n+    #[inline]\n+    fn iter<'a>(&'a self) -> Items<'a, T> {\n+        unsafe {\n+            let p = self.as_ptr();\n+            if mem::size_of::<T>() == 0 {\n+                Items{ptr: p,\n+                      end: (p as uint + self.len()) as *const T,\n+                      marker: marker::ContravariantLifetime::<'a>}\n+            } else {\n+                Items{ptr: p,\n+                      end: p.offset(self.len() as int),\n+                      marker: marker::ContravariantLifetime::<'a>}\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn split<'a>(&'a self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n+        Splits {\n+            v: self,\n+            pred: pred,\n+            finished: false\n+        }\n+    }\n+\n+    #[inline]\n+    fn splitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: false\n+        }\n+    }\n+\n+    #[inline]\n+    fn rsplitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: true\n+        }\n+    }\n+\n+    #[inline]\n+    fn windows(&self, size: uint) -> Windows<T> {\n+        assert!(size != 0);\n+        Windows { v: self, size: size }\n+    }\n+\n+    #[inline]\n+    fn chunks(&self, size: uint) -> Chunks<T> {\n+        assert!(size != 0);\n+        Chunks { v: self, size: size }\n+    }\n+\n+    #[inline]\n+    fn get(&self, index: uint) -> Option<&T> {\n+        if index < self.len() { Some(&self[index]) } else { None }\n+    }\n+\n+    #[inline]\n+    fn head(&self) -> Option<&T> {\n+        if self.len() == 0 { None } else { Some(&self[0]) }\n+    }\n+\n+    #[inline]\n+    fn tail(&self) -> &[T] { self[1..] }\n+\n+    #[inline]\n+    fn init(&self) -> &[T] {\n+        self[..self.len() - 1]\n+    }\n+\n+    #[inline]\n+    fn last(&self) -> Option<&T> {\n+        if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+        transmute(self.repr().data.offset(index as int))\n+    }\n+\n+    #[inline]\n+    fn as_ptr(&self) -> *const T {\n+        self.repr().data\n+    }\n+\n+    #[unstable]\n+    fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult {\n+        let mut base : uint = 0;\n+        let mut lim : uint = self.len();\n+\n+        while lim != 0 {\n+            let ix = base + (lim >> 1);\n+            match f(&self[ix]) {\n+                Equal => return Found(ix),\n+                Less => {\n+                    base = ix + 1;\n+                    lim -= 1;\n+                }\n+                Greater => ()\n+            }\n+            lim >>= 1;\n+        }\n+        return NotFound(base);\n+    }\n+\n+    #[inline]\n+    fn len(&self) -> uint { self.repr().len }\n+\n     #[inline]\n     fn get_mut(&mut self, index: uint) -> Option<&mut T> {\n         if index < self.len() { Some(&mut self[index]) } else { None }\n@@ -764,9 +698,66 @@ impl<T> MutableSlice<T> for [T] {\n     }\n }\n \n+impl<T> ops::Slice<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.slice_or_fail(start, &self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.slice_or_fail(&0, end)\n+    }\n+    #[inline]\n+    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        let len = &self.len();\n+        self.slice_or_fail_mut(start, len)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.slice_or_fail_mut(&0, end)\n+    }\n+    #[inline]\n+    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n /// Extension methods for slices containing `PartialEq` elements.\n #[unstable = \"may merge with other traits\"]\n-pub trait ImmutablePartialEqSlice<T: PartialEq> for Sized? {\n+pub trait PartialEqSlicePrelude<T: PartialEq> for Sized? {\n     /// Find the first index containing a matching value.\n     fn position_elem(&self, t: &T) -> Option<uint>;\n \n@@ -784,7 +775,7 @@ pub trait ImmutablePartialEqSlice<T: PartialEq> for Sized? {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T: PartialEq> ImmutablePartialEqSlice<T> for [T] {\n+impl<T: PartialEq> PartialEqSlicePrelude<T> for [T] {\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n         self.iter().position(|y| *x == *y)\n@@ -815,7 +806,7 @@ impl<T: PartialEq> ImmutablePartialEqSlice<T> for [T] {\n \n /// Extension methods for slices containing `Ord` elements.\n #[unstable = \"may merge with other traits\"]\n-pub trait ImmutableOrdSlice<T: Ord> for Sized? {\n+pub trait OrdSlicePrelude<T: Ord> for Sized? {\n     /// Binary search a sorted slice for a given element.\n     ///\n     /// If the value is found then `Found` is returned, containing the\n@@ -842,27 +833,127 @@ pub trait ImmutableOrdSlice<T: Ord> for Sized? {\n     /// ```\n     #[unstable = \"name likely to change\"]\n     fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[experimental]\n+    fn next_permutation(&mut self) -> bool;\n+\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[experimental]\n+    fn prev_permutation(&mut self) -> bool;\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T: Ord> ImmutableOrdSlice<T> for [T] {\n+impl<T: Ord> OrdSlicePrelude<T> for [T] {\n     #[unstable]\n     fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n         self.binary_search(|p| p.cmp(x))\n     }\n+\n+    #[experimental]\n+    fn next_permutation(&mut self) -> bool {\n+        // These cases only have 1 permutation each, so we can't do anything.\n+        if self.len() < 2 { return false; }\n+\n+        // Step 1: Identify the longest, rightmost weakly decreasing part of the vector\n+        let mut i = self.len() - 1;\n+        while i > 0 && self[i-1] >= self[i] {\n+            i -= 1;\n+        }\n+\n+        // If that is the entire vector, this is the last-ordered permutation.\n+        if i == 0 {\n+            return false;\n+        }\n+\n+        // Step 2: Find the rightmost element larger than the pivot (i-1)\n+        let mut j = self.len() - 1;\n+        while j >= i && self[j] <= self[i-1]  {\n+            j -= 1;\n+        }\n+\n+        // Step 3: Swap that element with the pivot\n+        self.swap(j, i-1);\n+\n+        // Step 4: Reverse the (previously) weakly decreasing part\n+        self[mut i..].reverse();\n+\n+        true\n+    }\n+\n+    #[experimental]\n+    fn prev_permutation(&mut self) -> bool {\n+        // These cases only have 1 permutation each, so we can't do anything.\n+        if self.len() < 2 { return false; }\n+\n+        // Step 1: Identify the longest, rightmost weakly increasing part of the vector\n+        let mut i = self.len() - 1;\n+        while i > 0 && self[i-1] <= self[i] {\n+            i -= 1;\n+        }\n+\n+        // If that is the entire vector, this is the first-ordered permutation.\n+        if i == 0 {\n+            return false;\n+        }\n+\n+        // Step 2: Reverse the weakly increasing part\n+        self[mut i..].reverse();\n+\n+        // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n+        let mut j = self.len() - 1;\n+        while j >= i && self[j-1] < self[i-1]  {\n+            j -= 1;\n+        }\n+\n+        // Step 4: Swap that element with the pivot\n+        self.swap(i-1, j);\n+\n+        true\n+    }\n }\n \n-/// Trait for &[T] where T is Cloneable\n+/// Extension methods for slices on Clone elements\n #[unstable = \"may merge with other traits\"]\n-pub trait MutableCloneableSlice<T> for Sized? {\n+pub trait CloneSlicePrelude<T> for Sized? {\n     /// Copies as many elements from `src` as it can into `self` (the\n     /// shorter of `self.len()` and `src.len()`). Returns the number\n     /// of elements copied.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::slice::MutableCloneableSlice;\n+    /// use std::slice::CloneSlicePrelude;\n     ///\n     /// let mut dst = [0i, 0, 0];\n     /// let src = [1i, 2];\n@@ -878,7 +969,7 @@ pub trait MutableCloneableSlice<T> for Sized? {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T: Clone> MutableCloneableSlice<T> for [T] {\n+impl<T: Clone> CloneSlicePrelude<T> for [T] {\n     #[inline]\n     fn clone_from_slice(&mut self, src: &[T]) -> uint {\n         let min = cmp::min(self.len(), src.len());\n@@ -1517,7 +1608,7 @@ pub mod raw {\n pub mod bytes {\n     use kinds::Sized;\n     use ptr;\n-    use slice::{ImmutableSlice, MutableSlice};\n+    use slice::SlicePrelude;\n \n     /// A trait for operations on mutable `[u8]`s.\n     pub trait MutableByteVector for Sized? {"}, {"sha": "4c1bfb61709078f4f4f56b0b412b199020b2a39b", "filename": "src/libcore/str.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -28,8 +28,7 @@ use kinds::Sized;\n use num::{CheckedMul, Saturating};\n use option::{Option, None, Some};\n use raw::Repr;\n-use slice::ImmutableSlice;\n-use slice;\n+use slice::{mod, SlicePrelude};\n use uint;\n \n /*\n@@ -1056,8 +1055,8 @@ pub mod raw {\n     use mem;\n     use ptr::RawPtr;\n     use raw::Slice;\n-    use slice::{ImmutableSlice};\n-    use str::{is_utf8, StrSlice};\n+    use slice::SlicePrelude;\n+    use str::{is_utf8, StrPrelude};\n \n     /// Converts a slice of bytes to a string slice without checking\n     /// that the string contains valid UTF-8.\n@@ -1120,7 +1119,7 @@ pub mod traits {\n     use iter::Iterator;\n     use option::{Option, Some};\n     use ops;\n-    use str::{Str, StrSlice, eq_slice};\n+    use str::{Str, StrPrelude, eq_slice};\n \n     // NOTE(stage0): remove impl after a snapshot\n     #[cfg(stage0)]\n@@ -1240,7 +1239,7 @@ impl<'a> Str for &'a str {\n }\n \n /// Methods for string slices\n-pub trait StrSlice for Sized? {\n+pub trait StrPrelude for Sized? {\n     /// Returns true if one string contains another\n     ///\n     /// # Arguments\n@@ -1891,7 +1890,7 @@ fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n           begin, end, s);\n }\n \n-impl StrSlice for str {\n+impl StrPrelude for str {\n     #[inline]\n     fn contains(&self, needle: &str) -> bool {\n         self.find_str(needle).is_some()"}, {"sha": "2c516affeb27436928e8337eaa351281dfa6cf47", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -12,7 +12,7 @@ use std::default::Default;\n use std::fmt;\n use std::iter::FromIterator;\n use std::path::BytesContainer;\n-use std::slice;\n+use std::slice::{mod, Permutations};\n \n // Note 1: It is not clear whether the flexibility of providing both\n // the `Growable` and `FixedLen` variants is sufficiently useful.\n@@ -137,11 +137,19 @@ impl<'a,T:fmt::Show> fmt::Show for MaybeOwnedVector<'a,T> {\n     }\n }\n \n-impl<'a,T:Clone> CloneableVector<T> for MaybeOwnedVector<'a,T> {\n+impl<'a,T:Clone> CloneSliceAllocPrelude<T> for MaybeOwnedVector<'a,T> {\n     /// Returns a copy of `self`.\n     fn to_vec(&self) -> Vec<T> {\n         self.as_slice().to_vec()\n     }\n+\n+    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n+        self.as_slice().partitioned(f)\n+    }\n+\n+    fn permutations(&self) -> Permutations<T> {\n+        self.as_slice().permutations()\n+    }\n }\n \n impl<'a, T: Clone> Clone for MaybeOwnedVector<'a, T> {\n@@ -153,7 +161,6 @@ impl<'a, T: Clone> Clone for MaybeOwnedVector<'a, T> {\n     }\n }\n \n-\n impl<'a, T> Default for MaybeOwnedVector<'a, T> {\n     fn default() -> MaybeOwnedVector<'a, T> {\n         Growable(Vec::new())"}, {"sha": "30c916f3303464c024a311e8f8df85ede0862005", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -296,7 +296,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n \n     use std::mem;\n     use std::iter::Iterator;\n-    use std::str::StrSlice;\n+    use std::str::StrPrelude;\n \n     if cfg.gid.is_some() || cfg.uid.is_some() {\n         return Err(IoError {"}, {"sha": "aa18a65dc58bb6b591790f65f718cddb815c9c0f", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -35,7 +35,7 @@\n \n use std::cmp;\n use std::mem;\n-use std::slice::MutableSlice;\n+use std::slice::SlicePrelude;\n use compile::{\n     Program,\n     Match, OneChar, CharClass, Any, EmptyBegin, EmptyEnd, EmptyWordBoundary,"}, {"sha": "128243187757aa9bd8443e93061d14712b94fd2c", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -108,8 +108,8 @@ pub unsafe extern \"C\" fn memcmp(s1: *const u8, s2: *const u8, n: uint) -> i32 {\n \n #[cfg(test)]\n mod test {\n-    use core::str::StrSlice;\n-    use core::slice::{MutableSlice, ImmutableSlice};\n+    use core::str::StrPrelude;\n+    use core::slice::{SlicePrelude};\n \n     use super::{memcmp, memset, memcpy, memmove};\n "}, {"sha": "5eecc0a53e0485de8ef830bb1b13ed45e7ba2a6a", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -47,7 +47,7 @@ mod imp {\n     use core::prelude::*;\n \n     use alloc::boxed::Box;\n-    use collections::slice::CloneableVector;\n+    use collections::slice::CloneSliceAllocPrelude;\n     use collections::vec::Vec;\n     use core::mem;\n     use core::slice;"}, {"sha": "68c2d2031c48dfa3fbbaa48f59c3cb4131eee27d", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -76,9 +76,9 @@ use collections::hash;\n use core::fmt;\n use core::kinds::{Sized, marker};\n use core::mem;\n-use core::prelude::{Clone, Drop, Eq, ImmutableSlice, Iterator};\n-use core::prelude::{MutableSlice, None, Option, Ordering, PartialEq};\n-use core::prelude::{PartialOrd, RawPtr, Some, StrSlice, range};\n+use core::prelude::{Clone, Drop, Eq, Iterator};\n+use core::prelude::{SlicePrelude, None, Option, Ordering, PartialEq};\n+use core::prelude::{PartialOrd, RawPtr, Some, StrPrelude, range};\n use core::ptr;\n use core::raw::Slice;\n use core::slice;"}, {"sha": "ff83027d28008594e8b7d2141578f4a1a626d691", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -19,8 +19,8 @@ use fmt;\n use iter::Iterator;\n use mem;\n use option::{Option, Some, None};\n-use slice::{ImmutableSlice, MutableSlice, AsSlice};\n-use str::{Str, StrSlice};\n+use slice::{SlicePrelude, AsSlice};\n+use str::{Str, StrPrelude};\n use string::{mod, String};\n use to_string::IntoStr;\n use vec::Vec;\n@@ -578,7 +578,7 @@ mod tests {\n     use prelude::*;\n     use super::*;\n     use char::from_u32;\n-    use str::StrSlice;\n+    use str::StrPrelude;\n \n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);"}, {"sha": "cde862a1d1741f9c5624b028336bffeec70fea94", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -594,7 +594,7 @@ mod test_set {\n     use prelude::*;\n \n     use super::HashSet;\n-    use slice::ImmutablePartialEqSlice;\n+    use slice::PartialEqSlicePrelude;\n \n     #[test]\n     fn test_disjoint() {"}, {"sha": "e3dfa8cabee3f4a77e2e8dd6098ebabc8c2ae0fb", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -28,7 +28,7 @@ use option::*;\n use os;\n use path::{Path,GenericPath};\n use result::*;\n-use slice::{AsSlice,ImmutableSlice};\n+use slice::{AsSlice,SlicePrelude};\n use str;\n use string::String;\n use vec::Vec;\n@@ -284,8 +284,8 @@ pub mod dl {\n     use os;\n     use ptr;\n     use result::{Ok, Err, Result};\n-    use slice::ImmutableSlice;\n-    use str::StrSlice;\n+    use slice::SlicePrelude;\n+    use str::StrPrelude;\n     use str;\n     use string::String;\n     use vec::Vec;"}, {"sha": "f5c6c15857aec57b40ab886aecdd9e6bef23cc53", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -18,7 +18,7 @@ use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::{SlicePrelude};\n use slice;\n use vec::Vec;\n \n@@ -376,7 +376,7 @@ mod test {\n     use super::super::{IoResult, EndOfFile};\n     use super::super::mem::{MemReader, MemWriter, BufReader};\n     use self::test::Bencher;\n-    use str::StrSlice;\n+    use str::StrPrelude;\n \n     /// A type, free to create, primarily intended for benchmarking creation of\n     /// wrappers that, just for construction, don't need a Reader/Writer that"}, {"sha": "6b4a952f9094269245d88a2726a6c56beb633529", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -14,7 +14,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Some};\n use result::{Ok, Err};\n-use slice::{bytes, CloneableVector, ImmutableSlice};\n+use slice::{bytes, CloneSliceAllocPrelude, SlicePrelude};\n use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;\n "}, {"sha": "07aa25bc044a545867904d7bfd68fa5ef0f5c991", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -22,7 +22,7 @@ use num::Int;\n use option::{Option, Some, None};\n use ptr::RawPtr;\n use result::{Ok, Err};\n-use slice::{ImmutableSlice, AsSlice};\n+use slice::{SlicePrelude, AsSlice};\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `EndOfFile`.\n@@ -150,7 +150,7 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n ///           32-bit value is parsed.\n pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n     use ptr::{copy_nonoverlapping_memory};\n-    use slice::MutableSlice;\n+    use slice::SlicePrelude;\n \n     assert!(size <= 8u);\n "}, {"sha": "c95d2c3f328b7e84d85ce0a2cdbbdfe595ecebbd", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -70,7 +70,7 @@ use path;\n use result::{Err, Ok};\n use rt::rtio::LocalIo;\n use rt::rtio;\n-use slice::ImmutableSlice;\n+use slice::SlicePrelude;\n use string::String;\n use vec::Vec;\n \n@@ -951,7 +951,7 @@ mod test {\n     use path::Path;\n     use io;\n     use ops::Drop;\n-    use str::StrSlice;\n+    use str::StrPrelude;\n \n     macro_rules! check( ($e:expr) => (\n         match $e {"}, {"sha": "51935862600d0817ee7e79671d402c37f7889221", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -17,7 +17,7 @@ use option::None;\n use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n-use slice::{mod, AsSlice, ImmutableSlice};\n+use slice::{mod, AsSlice, SlicePrelude};\n use vec::Vec;\n \n const BUF_CAPACITY: uint = 128;\n@@ -341,7 +341,7 @@ mod test {\n     use io::*;\n     use io;\n     use self::test::Bencher;\n-    use str::StrSlice;\n+    use str::StrPrelude;\n \n     #[test]\n     fn test_mem_writer() {"}, {"sha": "da5286b16ae1146ee258ac7192a9eaf8f3fd1ff5", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -236,8 +236,8 @@ use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n-use slice::{AsSlice, ImmutableSlice};\n-use str::{Str, StrSlice};\n+use slice::{AsSlice, SlicePrelude};\n+use str::{Str, StrPrelude};\n use str;\n use string::String;\n use uint;"}, {"sha": "2a2d978ef495ba30c06b5c564e68481c7c29633e", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -22,8 +22,8 @@ use io::net;\n use iter::Iterator;\n use option::{Option, None, Some};\n use result::{Ok, Err};\n-use str::StrSlice;\n-use slice::{MutableCloneableSlice, MutableSlice, ImmutableSlice};\n+use str::StrPrelude;\n+use slice::{CloneSlicePrelude, SlicePrelude};\n use vec::Vec;\n \n pub type Port = u16;"}, {"sha": "7bae67c0aa6b6015c68e4417a4e1f397137fce9c", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -41,8 +41,8 @@ use rt;\n use rt::local::Local;\n use rt::task::Task;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n-use slice::ImmutableSlice;\n-use str::StrSlice;\n+use slice::SlicePrelude;\n+use str::StrPrelude;\n use uint;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all"}, {"sha": "d82147947de65077126a7bbf852d67f7c9ff5cd9", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -330,7 +330,7 @@ macro_rules! try (\n #[macro_export]\n macro_rules! vec[\n     ($($x:expr),*) => ({\n-        use std::slice::BoxedSlice;\n+        use std::slice::BoxedSlicePrelude;\n         let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n         xs.into_vec()\n     });"}, {"sha": "612090a3a51f2925a778b76626e63cc340a3b629", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -20,8 +20,8 @@ use num;\n use num::{Int, Bounded};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use option::{None, Option, Some};\n-use slice::{ImmutableSlice, MutableSlice, CloneableVector};\n-use str::StrSlice;\n+use slice::{SlicePrelude, CloneSliceAllocPrelude};\n+use str::StrPrelude;\n use string::String;\n use vec::Vec;\n "}, {"sha": "0042a3ae205927ab6fff817881c289cdbbeaf2fd", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -46,9 +46,9 @@ use path::{Path, GenericPath, BytesContainer};\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n-use slice::{AsSlice, ImmutableSlice, MutableSlice, ImmutablePartialEqSlice};\n-use slice::CloneableVector;\n-use str::{Str, StrSlice, StrAllocating};\n+use slice::{AsSlice, SlicePrelude, PartialEqSlicePrelude};\n+use slice::CloneSliceAllocPrelude;\n+use str::{Str, StrPrelude, StrAllocating};\n use string::String;\n use to_string::ToString;\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n@@ -146,9 +146,9 @@ pub mod windows {\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n-    use slice::{MutableSlice, ImmutableSlice};\n+    use slice::{SlicePrelude};\n     use string::String;\n-    use str::StrSlice;\n+    use str::StrPrelude;\n     use vec::Vec;\n \n     pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)"}, {"sha": "e55933c4262422ed65f33068927d1a7280782dd2", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -74,10 +74,10 @@ use fmt;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n-use str::{MaybeOwned, Str, StrSlice};\n+use str::{MaybeOwned, Str, StrPrelude};\n use string::String;\n-use slice::{AsSlice, CloneableVector};\n-use slice::{ImmutablePartialEqSlice, ImmutableSlice};\n+use slice::{AsSlice, CloneSliceAllocPrelude};\n+use slice::{PartialEqSlicePrelude, SlicePrelude};\n use vec::Vec;\n \n /// Typedef for POSIX file paths."}, {"sha": "a927e09184036fbc68e403b067409738486c734a", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -20,8 +20,8 @@ use iter::{DoubleEndedIterator, AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n use str::Str;\n use str;\n-use slice::{CloneableVector, Splits, AsSlice, VectorVector,\n-            ImmutablePartialEqSlice, ImmutableSlice};\n+use slice::{CloneSliceAllocPrelude, Splits, AsSlice, VectorVector,\n+            PartialEqSlicePrelude, SlicePrelude};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -444,7 +444,7 @@ mod tests {\n     use super::*;\n     use mem;\n     use str;\n-    use str::StrSlice;\n+    use str::StrPrelude;\n \n     macro_rules! t(\n         (s: $path:expr, $exp:expr) => ("}, {"sha": "c5f84244928b79820740c6aadc3f46f6d2088142", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -22,8 +22,8 @@ use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Iterator, Map};\n use mem;\n use option::{Option, Some, None};\n-use slice::{AsSlice, ImmutableSlice};\n-use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};\n+use slice::{AsSlice, SlicePrelude};\n+use str::{CharSplits, Str, StrAllocating, StrVector, StrPrelude};\n use string::String;\n use unicode::char::UnicodeChar;\n use vec::Vec;"}, {"sha": "449d3a14bc977f22934ab609fce46b4b98c20ce7", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -76,18 +76,15 @@\n #[doc(no_inline)] pub use ptr::{RawPtr, RawMutPtr};\n #[doc(no_inline)] pub use result::{Result, Ok, Err};\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek};\n-#[doc(no_inline)] pub use str::{Str, StrVector, StrSlice};\n-#[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating, UnicodeStrSlice};\n+#[doc(no_inline)] pub use str::{Str, StrVector, StrPrelude};\n+#[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating, UnicodeStrPrelude};\n #[doc(no_inline)] pub use to_string::{ToString, IntoStr};\n #[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-#[doc(no_inline)] pub use slice::{CloneableVector, ImmutableCloneableVector};\n-#[doc(no_inline)] pub use slice::{MutableCloneableSlice, MutableOrdSlice};\n-#[doc(no_inline)] pub use slice::{ImmutableSlice, MutableSlice};\n-#[doc(no_inline)] pub use slice::{ImmutablePartialEqSlice, ImmutableOrdSlice};\n-#[doc(no_inline)] pub use slice::{AsSlice, VectorVector, BoxedSlice};\n-#[doc(no_inline)] pub use slice::MutableSliceAllocating;\n+#[doc(no_inline)] pub use slice::{SlicePrelude, AsSlice, CloneSlicePrelude};\n+#[doc(no_inline)] pub use slice::{VectorVector, PartialEqSlicePrelude, OrdSlicePrelude};\n+#[doc(no_inline)] pub use slice::{CloneSliceAllocPrelude, OrdSliceAllocPrelude, SliceAllocPrelude};\n #[doc(no_inline)] pub use string::String;\n #[doc(no_inline)] pub use vec::Vec;\n "}, {"sha": "b6b66e593a2dae56e7450b5058e5c91178d596c7", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -69,7 +69,7 @@ mod imp {\n     use rand::Rng;\n     use result::{Ok};\n     use self::libc::{c_int, size_t};\n-    use slice::{ImmutableSlice, MutableSlice};\n+    use slice::{SlicePrelude};\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -137,7 +137,7 @@ mod imp {\n     use result::{Ok, Err};\n     use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n     use self::libc::types::os::arch::extra::{LONG_PTR};\n-    use slice::{ImmutableSlice, MutableSlice};\n+    use slice::{SlicePrelude};\n \n     type HCRYPTPROV = LONG_PTR;\n "}, {"sha": "c8ed980521542adb4f36b8094256c0cf3e497851", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -13,7 +13,7 @@\n use io::Reader;\n use rand::Rng;\n use result::{Ok, Err};\n-use slice::ImmutableSlice;\n+use slice::SlicePrelude;\n \n /// An RNG that reads random bytes straight from a `Reader`. This will\n /// work best with an infinite reader, but this is not required."}, {"sha": "b08b92b8587b6fdd1ae55fe73fa9f19bc5ec8daa", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -18,7 +18,7 @@ use iter::Iterator;\n use option::{Some, None};\n use os;\n use result::{Ok, Err};\n-use str::StrSlice;\n+use str::StrPrelude;\n use sync::atomic;\n use unicode::char::UnicodeChar;\n \n@@ -255,7 +255,7 @@ mod imp {\n     pub fn write(w: &mut Writer) -> IoResult<()> {\n         use iter::{Iterator, range};\n         use result;\n-        use slice::{MutableSlice};\n+        use slice::{SlicePrelude};\n \n         extern {\n             fn backtrace(buf: *mut *mut libc::c_void,\n@@ -394,7 +394,7 @@ mod imp {\n         use path::GenericPath;\n         use ptr::RawPtr;\n         use ptr;\n-        use slice::{ImmutableSlice, MutableSlice};\n+        use slice::{SlicePrelude};\n \n         ////////////////////////////////////////////////////////////////////////\n         // libbacktrace.h API\n@@ -666,8 +666,8 @@ mod imp {\n     use path::Path;\n     use result::{Ok, Err};\n     use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use slice::ImmutableSlice;\n-    use str::StrSlice;\n+    use slice::SlicePrelude;\n+    use str::StrPrelude;\n     use dynamic_lib::DynamicLibrary;\n \n     #[allow(non_snake_case)]"}, {"sha": "0db0ffd5cb4edb793f993b1d8ceb1f54e5cc5a73", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -73,7 +73,7 @@ pub mod char {\n }\n \n pub mod str {\n-    pub use u_str::{UnicodeStrSlice, Words, Graphemes, GraphemeIndices};\n+    pub use u_str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n }\n \n // this lets us use #[deriving(Clone)]"}, {"sha": "ad36215c11bcbd1e527f2b7586641b8504eee084", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -16,7 +16,7 @@\n use core::cmp::{Equal, Less, Greater};\n use core::option::{Option, Some, None};\n use core::slice;\n-use core::slice::ImmutableSlice;\n+use core::slice::SlicePrelude;\n use tables::normalization::{canonical_table, compatibility_table, composition_table};\n \n fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'static [T]> {"}, {"sha": "212502fd181243eda05dad6b35142bb2938e28b5", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -13,12 +13,12 @@\n #![allow(missing_doc, non_uppercase_statics, non_snake_case)]\n \n /// The version of [Unicode](http://www.unicode.org/)\n-/// that the `UnicodeChar` and `UnicodeStrSlice` traits are based on.\n+/// that the `UnicodeChar` and `UnicodeStrPrelude` traits are based on.\n pub const UNICODE_VERSION: (uint, uint, uint) = (7, 0, 0);\n \n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableSlice;\n+    use core::slice::SlicePrelude;\n     r.binary_search(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n@@ -6242,7 +6242,7 @@ pub mod normalization {\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n         use core::cmp::{Equal, Less, Greater};\n-        use core::slice::ImmutableSlice;\n+        use core::slice::SlicePrelude;\n         use core::slice;\n         match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n@@ -6367,7 +6367,7 @@ pub mod normalization {\n \n pub mod conversions {\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableSlice;\n+    use core::slice::SlicePrelude;\n     use core::tuple::Tuple2;\n     use core::option::{Option, Some, None};\n     use core::slice;\n@@ -6935,7 +6935,7 @@ pub mod conversions {\n \n pub mod charwidth {\n     use core::option::{Option, Some, None};\n-    use core::slice::ImmutableSlice;\n+    use core::slice::SlicePrelude;\n     use core::slice;\n \n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n@@ -7134,7 +7134,7 @@ pub mod charwidth {\n }\n \n pub mod grapheme {\n-    use core::slice::ImmutableSlice;\n+    use core::slice::SlicePrelude;\n     use core::slice;\n \n     #[allow(non_camel_case_types)]"}, {"sha": "50f257c9c859e81eb2f779a43176df4ef961be52", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfafc1b7377d34d8c60db7cd386836d39b80af41/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=cfafc1b7377d34d8c60db7cd386836d39b80af41", "patch": "@@ -18,11 +18,11 @@\n  */\n \n use core::cmp;\n-use core::slice::ImmutableSlice;\n+use core::slice::SlicePrelude;\n use core::iter::{Filter, AdditiveIterator, Iterator, DoubleEndedIterator};\n use core::kinds::Sized;\n use core::option::{Option, None, Some};\n-use core::str::{CharSplits, StrSlice};\n+use core::str::{CharSplits, StrPrelude};\n use u_char;\n use u_char::UnicodeChar;\n use tables::grapheme::GraphemeCat;\n@@ -32,7 +32,7 @@ pub type Words<'a> =\n     Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n \n /// Methods for Unicode string slices\n-pub trait UnicodeStrSlice for Sized? {\n+pub trait UnicodeStrPrelude for Sized? {\n     /// Returns an iterator over the\n     /// [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n     /// of the string.\n@@ -129,7 +129,7 @@ pub trait UnicodeStrSlice for Sized? {\n     fn trim_right<'a>(&'a self) -> &'a str;\n }\n \n-impl UnicodeStrSlice for str {\n+impl UnicodeStrPrelude for str {\n     #[inline]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n         Graphemes { string: self, extended: is_extended, cat: None, catb: None }"}]}