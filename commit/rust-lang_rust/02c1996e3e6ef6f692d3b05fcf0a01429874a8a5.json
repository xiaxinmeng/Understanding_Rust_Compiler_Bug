{"sha": "02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYzE5OTZlM2U2ZWY2ZjY5MmQzYjA1ZmNmMGEwMTQyOTg3NGE4YTU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-06-15T20:53:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-15T20:53:54Z"}, "message": "Merge pull request #1680 from topecongiro/tuple-pattern\n\nUse block indent for tuple pattern", "tree": {"sha": "2420d620ecc30a2473bd81e4f67ced9d1880329d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2420d620ecc30a2473bd81e4f67ced9d1880329d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "html_url": "https://github.com/rust-lang/rust/commit/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd1eff55bb70112c7f0cbca9333d4864625484c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1eff55bb70112c7f0cbca9333d4864625484c1", "html_url": "https://github.com/rust-lang/rust/commit/bd1eff55bb70112c7f0cbca9333d4864625484c1"}, {"sha": "de10113c748825750b421e4ec5e0fe5aaf1d65ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/de10113c748825750b421e4ec5e0fe5aaf1d65ec", "html_url": "https://github.com/rust-lang/rust/commit/de10113c748825750b421e4ec5e0fe5aaf1d65ec"}], "stats": {"total": 455, "additions": 293, "deletions": 162}, "files": [{"sha": "6bba83b520cc3493311dd3d4ec9362b65e576815", "filename": "src/expr.rs", "status": "modified", "additions": 113, "deletions": 39, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -25,10 +25,11 @@ use utils::{extra_offset, last_line_width, wrap_str, binary_search, first_line_w\n use visitor::FmtVisitor;\n use config::{Config, IndentStyle, MultilineStyle, ControlBraceStyle, Style};\n use comment::{FindUncommented, rewrite_comment, contains_comment, recover_comment_removed};\n-use types::{rewrite_path, PathContext};\n+use types::{rewrite_path, PathContext, can_be_overflowed_type};\n use items::{span_lo_for_arg, span_hi_for_arg};\n use chains::rewrite_chain;\n use macros::{rewrite_macro, MacroPosition};\n+use patterns::{TuplePatField, can_be_overflowed_pat};\n \n use syntax::{ast, ptr};\n use syntax::codemap::{CodeMap, Span, BytePos};\n@@ -110,7 +111,13 @@ fn format_expr(\n         }\n         ast::ExprKind::Call(ref callee, ref args) => {\n             let inner_span = mk_sp(callee.span.hi, expr.span.hi);\n-            rewrite_call_with_binary_search(context, &**callee, args, inner_span, shape)\n+            rewrite_call_with_binary_search(\n+                context,\n+                &**callee,\n+                &args.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+                inner_span,\n+                shape,\n+            )\n         }\n         ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape),\n         ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n@@ -136,7 +143,14 @@ fn format_expr(\n                 shape,\n             )\n         }\n-        ast::ExprKind::Tup(ref items) => rewrite_tuple(context, items, expr.span, shape),\n+        ast::ExprKind::Tup(ref items) => {\n+            rewrite_tuple(\n+                context,\n+                &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+                expr.span,\n+                shape,\n+            )\n+        }\n         ast::ExprKind::While(ref cond, ref block, label) => {\n             ControlFlow::new_while(None, cond, block, label, expr.span).rewrite(context, shape)\n         }\n@@ -1800,7 +1814,7 @@ fn string_requires_rewrite(\n pub fn rewrite_call_with_binary_search<R>(\n     context: &RewriteContext,\n     callee: &R,\n-    args: &[ptr::P<ast::Expr>],\n+    args: &[&ast::Expr],\n     span: Span,\n     shape: Shape,\n ) -> Option<String>\n@@ -1818,7 +1832,15 @@ where\n             Ordering::Greater,\n         )?;\n \n-        rewrite_call_inner(context, &callee_str, args, span, shape, false)\n+        rewrite_call_inner(\n+            context,\n+            &callee_str,\n+            args,\n+            span,\n+            shape,\n+            context.config.fn_call_width(),\n+            false,\n+        )\n     };\n \n     binary_search(1, shape.width, closure)\n@@ -1831,15 +1853,24 @@ pub fn rewrite_call(\n     span: Span,\n     shape: Shape,\n ) -> Option<String> {\n-    rewrite_call_inner(context, &callee, args, span, shape, false).ok()\n+    rewrite_call_inner(\n+        context,\n+        &callee,\n+        &args.iter().map(|x| &**x).collect::<Vec<_>>(),\n+        span,\n+        shape,\n+        context.config.fn_call_width(),\n+        false,\n+    ).ok()\n }\n \n-fn rewrite_call_inner<'a, T>(\n+pub fn rewrite_call_inner<'a, T>(\n     context: &RewriteContext,\n     callee_str: &str,\n-    args: &[ptr::P<T>],\n+    args: &[&T],\n     span: Span,\n     shape: Shape,\n+    args_max_width: usize,\n     force_trailing_comma: bool,\n ) -> Result<String, Ordering>\n where\n@@ -1873,6 +1904,7 @@ where\n         args_span,\n         nested_shape,\n         one_line_width,\n+        args_max_width,\n         force_trailing_comma,\n     ).or_else(|| if context.use_block_indent() {\n         rewrite_call_args(\n@@ -1884,6 +1916,7 @@ where\n                 context.config,\n             ),\n             0,\n+            0,\n             force_trailing_comma,\n         )\n     } else {\n@@ -1900,6 +1933,7 @@ where\n             args,\n             span,\n             shape,\n+            args_max_width,\n             force_trailing_comma,\n         );\n     }\n@@ -1930,10 +1964,11 @@ fn need_block_indent(s: &str, shape: Shape) -> bool {\n \n fn rewrite_call_args<'a, T>(\n     context: &RewriteContext,\n-    args: &[ptr::P<T>],\n+    args: &[&T],\n     span: Span,\n     shape: Shape,\n     one_line_width: usize,\n+    args_max_width: usize,\n     force_trailing_comma: bool,\n ) -> Option<(bool, String)>\n where\n@@ -1956,13 +1991,13 @@ where\n     // Try letting the last argument overflow to the next line with block\n     // indentation. If its first line fits on one line with the other arguments,\n     // we format the function arguments horizontally.\n-    let args = args.iter().filter_map(|e| e.to_expr()).collect::<Vec<_>>();\n     let tactic = try_overflow_last_arg(\n         &item_context,\n         &mut item_vec,\n         &args[..],\n         shape,\n         one_line_width,\n+        args_max_width,\n     );\n \n     let fmt = ListFormatting {\n@@ -1985,38 +2020,45 @@ where\n     })\n }\n \n-fn try_overflow_last_arg(\n+fn try_overflow_last_arg<'a, T>(\n     context: &RewriteContext,\n     item_vec: &mut Vec<ListItem>,\n-    args: &[&ast::Expr],\n+    args: &[&T],\n     shape: Shape,\n     one_line_width: usize,\n-) -> DefinitiveListTactic {\n+    args_max_width: usize,\n+) -> DefinitiveListTactic\n+where\n+    T: Rewrite + Spanned + ToExpr + 'a,\n+{\n     let overflow_last = can_be_overflowed(&context, args);\n \n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n     let (orig_last, placeholder) = if overflow_last {\n         let mut context = context.clone();\n-        match args[args.len() - 1].node {\n-            ast::ExprKind::MethodCall(..) => context.force_one_line_chain = true,\n-            _ => (),\n-        }\n-        last_arg_shape(&context, &item_vec, shape).map_or((None, None), |arg_shape| {\n-            rewrite_last_arg_with_overflow(\n-                &context,\n-                args[args.len() - 1],\n-                &mut item_vec[args.len() - 1],\n-                arg_shape,\n-            )\n-        })\n+        if let Some(expr) = args[args.len() - 1].to_expr() {\n+            match expr.node {\n+                ast::ExprKind::MethodCall(..) => context.force_one_line_chain = true,\n+                _ => (),\n+            }\n+        }\n+        last_arg_shape(&context, &item_vec, shape, args_max_width)\n+            .map_or((None, None), |arg_shape| {\n+                rewrite_last_arg_with_overflow(\n+                    &context,\n+                    args[args.len() - 1],\n+                    &mut item_vec[args.len() - 1],\n+                    arg_shape,\n+                )\n+            })\n     } else {\n         (None, None)\n     };\n \n     let tactic = definitive_tactic(\n         &*item_vec,\n-        ListTactic::LimitedHorizontalVertical(context.config.fn_call_width()),\n+        ListTactic::LimitedHorizontalVertical(args_max_width),\n         one_line_width,\n     );\n \n@@ -2035,11 +2077,16 @@ fn try_overflow_last_arg(\n     tactic\n }\n \n-fn last_arg_shape(context: &RewriteContext, items: &Vec<ListItem>, shape: Shape) -> Option<Shape> {\n+fn last_arg_shape(\n+    context: &RewriteContext,\n+    items: &Vec<ListItem>,\n+    shape: Shape,\n+    args_max_width: usize,\n+) -> Option<Shape> {\n     let overhead = items.iter().rev().skip(1).fold(0, |acc, i| {\n         acc + i.item.as_ref().map_or(0, |s| first_line_width(&s))\n     });\n-    let max_width = min(context.config.fn_call_width(), shape.width);\n+    let max_width = min(args_max_width, shape.width);\n     let arg_indent = if context.use_block_indent() {\n         shape.block().indent.block_unindent(context.config)\n     } else {\n@@ -2052,12 +2099,15 @@ fn last_arg_shape(context: &RewriteContext, items: &Vec<ListItem>, shape: Shape)\n     })\n }\n \n-fn rewrite_last_arg_with_overflow(\n+fn rewrite_last_arg_with_overflow<'a, T>(\n     context: &RewriteContext,\n-    last_arg: &ast::Expr,\n+    last_arg: &T,\n     last_item: &mut ListItem,\n     shape: Shape,\n-) -> (Option<String>, Option<String>) {\n+) -> (Option<String>, Option<String>)\n+where\n+    T: Rewrite + Spanned + ToExpr + 'a,\n+{\n     let rewrite = last_arg.rewrite(context, shape);\n     let orig_last = last_item.item.clone();\n \n@@ -2070,13 +2120,17 @@ fn rewrite_last_arg_with_overflow(\n     }\n }\n \n-fn can_be_overflowed(context: &RewriteContext, args: &[&ast::Expr]) -> bool {\n-    args.last().map_or(false, |x| {\n-        can_be_overflowed_expr(context, &x, args.len())\n-    })\n+fn can_be_overflowed<'a, T>(context: &RewriteContext, args: &[&T]) -> bool\n+where\n+    T: Rewrite + Spanned + ToExpr + 'a,\n+{\n+    args.last().map_or(\n+        false,\n+        |x| x.can_be_overflowed(context, args.len()),\n+    )\n }\n \n-fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n+pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n     match expr.node {\n         ast::ExprKind::Match(..) => {\n             (context.use_block_indent() && args_len == 1) ||\n@@ -2117,7 +2171,7 @@ fn paren_overhead(context: &RewriteContext) -> usize {\n     }\n }\n \n-fn wrap_args_with_parens(\n+pub fn wrap_args_with_parens(\n     context: &RewriteContext,\n     args_str: &str,\n     is_extendable: bool,\n@@ -2370,7 +2424,7 @@ fn shape_from_fn_call_style(\n \n fn rewrite_tuple_in_visual_indent_style<'a, T>(\n     context: &RewriteContext,\n-    items: &[ptr::P<T>],\n+    items: &[&T],\n     span: Span,\n     shape: Shape,\n ) -> Option<String>\n@@ -2417,7 +2471,7 @@ where\n \n pub fn rewrite_tuple<'a, T>(\n     context: &RewriteContext,\n-    items: &[ptr::P<T>],\n+    items: &[&T],\n     span: Span,\n     shape: Shape,\n ) -> Option<String>\n@@ -2433,6 +2487,7 @@ where\n             items,\n             span,\n             shape,\n+            context.config.fn_call_width(),\n             items.len() == 1,\n         ).ok()\n     } else {\n@@ -2590,16 +2645,35 @@ fn rewrite_expr_addrof(\n \n pub trait ToExpr {\n     fn to_expr(&self) -> Option<&ast::Expr>;\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool;\n }\n \n impl ToExpr for ast::Expr {\n     fn to_expr(&self) -> Option<&ast::Expr> {\n         Some(self)\n     }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        can_be_overflowed_expr(context, self, len)\n+    }\n }\n \n impl ToExpr for ast::Ty {\n     fn to_expr(&self) -> Option<&ast::Expr> {\n         None\n     }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        can_be_overflowed_type(context, self, len)\n+    }\n+}\n+\n+impl<'a> ToExpr for TuplePatField<'a> {\n+    fn to_expr(&self) -> Option<&ast::Expr> {\n+        None\n+    }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        can_be_overflowed_pat(context, self, len)\n+    }\n }"}, {"sha": "7a2d3048ff03ba6278e24f6e272fece44a11bac1", "filename": "src/items.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -684,13 +684,15 @@ fn format_impl_ref_and_type(\n     item: &ast::Item,\n     offset: Indent,\n ) -> Option<String> {\n-    if let ast::ItemKind::Impl(unsafety,\n-                               polarity,\n-                               _,\n-                               ref generics,\n-                               ref trait_ref,\n-                               ref self_ty,\n-                               _) = item.node\n+    if let ast::ItemKind::Impl(\n+        unsafety,\n+        polarity,\n+        _,\n+        ref generics,\n+        ref trait_ref,\n+        ref self_ty,\n+        _,\n+    ) = item.node\n     {\n         let mut result = String::new();\n "}, {"sha": "3ca8aa52455f0626f580f98ca01fdad1b15539fb", "filename": "src/patterns.rs", "status": "modified", "additions": 70, "deletions": 56, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -13,10 +13,9 @@ use codemap::SpanUtils;\n use config::{IndentStyle, MultilineStyle};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{wrap_str, format_mutability, mk_sp};\n-use lists::{DefinitiveListTactic, SeparatorTactic, format_item_list, itemize_list, ListItem,\n-            struct_lit_shape, struct_lit_tactic, shape_for_tactic, struct_lit_formatting,\n-            write_list};\n-use expr::{rewrite_unary_prefix, rewrite_pair};\n+use lists::{DefinitiveListTactic, SeparatorTactic, itemize_list, struct_lit_shape,\n+            struct_lit_tactic, shape_for_tactic, struct_lit_formatting, write_list};\n+use expr::{rewrite_call_inner, rewrite_unary_prefix, rewrite_pair, can_be_overflowed_expr};\n use types::{rewrite_path, PathContext};\n use super::Spanned;\n use comment::FindUncommented;\n@@ -239,7 +238,7 @@ impl Rewrite for FieldPat {\n     }\n }\n \n-enum TuplePatField<'a> {\n+pub enum TuplePatField<'a> {\n     Pat(&'a ptr::P<ast::Pat>),\n     Dotdot(Span),\n }\n@@ -262,6 +261,25 @@ impl<'a> Spanned for TuplePatField<'a> {\n     }\n }\n \n+pub fn can_be_overflowed_pat(context: &RewriteContext, pat: &TuplePatField, len: usize) -> bool {\n+    match pat {\n+        &TuplePatField::Pat(ref pat) => {\n+            match pat.node {\n+                ast::PatKind::Path(..) |\n+                ast::PatKind::Tuple(..) |\n+                ast::PatKind::Struct(..) => context.use_block_indent() && len == 1,\n+                ast::PatKind::Ref(ref p, _) |\n+                ast::PatKind::Box(ref p) => {\n+                    can_be_overflowed_pat(context, &TuplePatField::Pat(p), len)\n+                }\n+                ast::PatKind::Lit(ref expr) => can_be_overflowed_expr(context, expr, len),\n+                _ => false,\n+            }\n+        }\n+        &TuplePatField::Dotdot(..) => false,\n+    }\n+}\n+\n fn rewrite_tuple_pat(\n     pats: &[ptr::P<ast::Pat>],\n     dotdot_pos: Option<usize>,\n@@ -286,77 +304,73 @@ fn rewrite_tuple_pat(\n         let dot_span = mk_sp(prev, next);\n         let snippet = context.snippet(dot_span);\n         let lo = dot_span.lo + BytePos(snippet.find_uncommented(\"..\").unwrap() as u32);\n-        let span = Span {\n+        let dotdot = TuplePatField::Dotdot(Span {\n             lo: lo,\n             // 2 == \"..\".len()\n             hi: lo + BytePos(2),\n             ctxt: codemap::NO_EXPANSION,\n-        };\n-        let dotdot = TuplePatField::Dotdot(span);\n+        });\n         pat_vec.insert(pos, dotdot);\n     }\n \n     if pat_vec.is_empty() {\n         return Some(format!(\"{}()\", try_opt!(path_str)));\n     }\n+\n+    let wildcard_suffix_len = count_wildcard_suffix_len(context, &pat_vec, span, shape);\n+    let (pat_vec, span) =\n+        if context.config.condense_wildcard_suffixes() && wildcard_suffix_len >= 2 {\n+            let new_item_count = 1 + pat_vec.len() - wildcard_suffix_len;\n+            let sp = pat_vec[new_item_count - 1].span();\n+            let snippet = context.snippet(sp);\n+            let lo = sp.lo + BytePos(snippet.find_uncommented(\"_\").unwrap() as u32);\n+            pat_vec[new_item_count - 1] = TuplePatField::Dotdot(mk_sp(lo, lo + BytePos(1)));\n+            (&pat_vec[..new_item_count], mk_sp(span.lo, lo + BytePos(1)))\n+        } else {\n+            (&pat_vec[..], span)\n+        };\n+\n     // add comma if `(x,)`\n     let add_comma = path_str.is_none() && pat_vec.len() == 1 && dotdot_pos.is_none();\n+    let mut context = context.clone();\n+    if let Some(&TuplePatField::Dotdot(..)) = pat_vec.last() {\n+        context.inside_macro = true;\n+    }\n+    let path_str = path_str.unwrap_or(String::new());\n+    let mut pat_ref_vec = Vec::with_capacity(pat_vec.len());\n+    for pat in pat_vec {\n+        pat_ref_vec.push(pat);\n+    }\n+    return rewrite_call_inner(\n+        &context,\n+        &path_str,\n+        &pat_ref_vec[..],\n+        span,\n+        shape,\n+        shape.width,\n+        add_comma,\n+    ).ok();\n+}\n+\n+fn count_wildcard_suffix_len(\n+    context: &RewriteContext,\n+    patterns: &[TuplePatField],\n+    span: Span,\n+    shape: Shape,\n+) -> usize {\n+    let mut suffix_len = 0;\n \n-    let path_len = path_str.as_ref().map(|p| p.len()).unwrap_or(0);\n-    // 2 = \"()\".len(), 3 = \"(,)\".len()\n-    let nested_shape = try_opt!(shape.sub_width(path_len + if add_comma { 3 } else { 2 }));\n-    // 1 = \"(\".len()\n-    let nested_shape = nested_shape.visual_indent(path_len + 1);\n-    let mut items: Vec<_> = itemize_list(\n+    let items: Vec<_> = itemize_list(\n         context.codemap,\n-        pat_vec.iter(),\n-        if add_comma { \",)\" } else { \")\" },\n+        patterns.iter(),\n+        \")\",\n         |item| item.span().lo,\n         |item| item.span().hi,\n-        |item| item.rewrite(context, nested_shape),\n+        |item| item.rewrite(context, shape),\n         context.codemap.span_after(span, \"(\"),\n         span.hi - BytePos(1),\n     ).collect();\n \n-    // Condense wildcard string suffix into a single ..\n-    let wildcard_suffix_len = count_wildcard_suffix_len(&items);\n-\n-    let list = if context.config.condense_wildcard_suffixes() && wildcard_suffix_len >= 2 {\n-        let new_item_count = 1 + pats.len() - wildcard_suffix_len;\n-        items[new_item_count - 1].item = Some(\"..\".to_owned());\n-\n-        let da_iter = items.into_iter().take(new_item_count);\n-        try_opt!(format_item_list(da_iter, nested_shape, context.config))\n-    } else {\n-        try_opt!(format_item_list(\n-            items.into_iter(),\n-            nested_shape,\n-            context.config,\n-        ))\n-    };\n-\n-    match path_str {\n-        Some(path_str) => {\n-            Some(if context.config.spaces_within_parens() {\n-                format!(\"{}( {} )\", path_str, list)\n-            } else {\n-                format!(\"{}({})\", path_str, list)\n-            })\n-        }\n-        None => {\n-            let comma = if add_comma { \",\" } else { \"\" };\n-            Some(if context.config.spaces_within_parens() {\n-                format!(\"( {}{} )\", list, comma)\n-            } else {\n-                format!(\"({}{})\", list, comma)\n-            })\n-        }\n-    }\n-}\n-\n-fn count_wildcard_suffix_len(items: &[ListItem]) -> usize {\n-    let mut suffix_len = 0;\n-\n     for item in items.iter().rev().take_while(|i| match i.item {\n         Some(ref internal_string) if internal_string == \"_\" => true,\n         _ => false,"}, {"sha": "57a7b301f5423f87132904e9009fd6447ed72732", "filename": "src/types.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -371,11 +371,11 @@ impl Rewrite for ast::WherePredicate {\n         // TODO: dead spans?\n         let result = match *self {\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                                                    ref bound_lifetimes,\n-                                                    ref bounded_ty,\n-                                                    ref bounds,\n-                                                    ..\n-                                                }) => {\n+                ref bound_lifetimes,\n+                ref bounded_ty,\n+                ref bounds,\n+                ..\n+            }) => {\n                 let type_str = try_opt!(bounded_ty.rewrite(context, shape));\n \n                 let colon = type_bound_colon(context);\n@@ -428,10 +428,10 @@ impl Rewrite for ast::WherePredicate {\n                 }\n             }\n             ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n-                                                     ref lifetime,\n-                                                     ref bounds,\n-                                                     ..\n-                                                 }) => {\n+                ref lifetime,\n+                ref bounds,\n+                ..\n+            }) => {\n                 try_opt!(rewrite_bounded_lifetime(\n                     lifetime,\n                     bounds.iter(),\n@@ -440,10 +440,10 @@ impl Rewrite for ast::WherePredicate {\n                 ))\n             }\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n-                                                 ref lhs_ty,\n-                                                 ref rhs_ty,\n-                                                 ..\n-                                             }) => {\n+                ref lhs_ty,\n+                ref rhs_ty,\n+                ..\n+            }) => {\n                 let lhs_ty_str = try_opt!(lhs_ty.rewrite(context, shape));\n                 // 3 = \" = \".len()\n                 let used_width = 3 + lhs_ty_str.len();\n@@ -689,7 +689,14 @@ impl Rewrite for ast::Ty {\n                         format!(\"[{}]\", ty_str)\n                     })\n             }\n-            ast::TyKind::Tup(ref items) => rewrite_tuple(context, items, self.span, shape),\n+            ast::TyKind::Tup(ref items) => {\n+                rewrite_tuple(\n+                    context,\n+                    &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+                    self.span,\n+                    shape,\n+                )\n+            }\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }\n@@ -792,3 +799,13 @@ pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &Vec<Strin\n         result\n     }\n }\n+\n+pub fn can_be_overflowed_type(context: &RewriteContext, ty: &ast::Ty, len: usize) -> bool {\n+    match ty.node {\n+        ast::TyKind::Path(..) |\n+        ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n+        ast::TyKind::Rptr(_, ref mutty) |\n+        ast::TyKind::Ptr(ref mutty) => can_be_overflowed_type(context, &*mutty.ty, len),\n+        _ => false,\n+    }\n+}"}, {"sha": "c432df301dfd1849f3896e08e63c08e77ddb8055", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -99,6 +99,7 @@ pub fn last_line_width(s: &str) -> usize {\n         None => s.len(),\n     }\n }\n+\n #[inline]\n pub fn trimmed_last_line_width(s: &str) -> usize {\n     match s.rfind('\\n') {"}, {"sha": "47d8c6bf166f23cd4c239b6ac10ed3c0f9a8ea90", "filename": "tests/target/closure.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -128,18 +128,20 @@ fn issue470() {\n     {\n         {\n             {\n-                let explicit_arg_decls = explicit_arguments.into_iter().enumerate().map(|(index,\n-                  (ty,\n-                   pattern))| {\n-                    let lvalue = Lvalue::Arg(index as u32);\n-                    block = this.pattern(\n-                        block,\n-                        argument_extent,\n-                        hair::PatternRef::Hair(pattern),\n-                        &lvalue,\n-                    );\n-                    ArgDecl { ty: ty }\n-                });\n+                let explicit_arg_decls =\n+                    explicit_arguments.into_iter().enumerate().map(|(\n+                        index,\n+                        (ty, pattern),\n+                    )| {\n+                        let lvalue = Lvalue::Arg(index as u32);\n+                        block = this.pattern(\n+                            block,\n+                            argument_extent,\n+                            hair::PatternRef::Hair(pattern),\n+                            &lvalue,\n+                        );\n+                        ArgDecl { ty: ty }\n+                    });\n             }\n         }\n     }"}, {"sha": "7741939df459bf3b53fb612efd1b2321c560dd3e", "filename": "tests/target/expr.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -52,18 +52,22 @@ fn foo() -> bool {\n                           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\n     {}\n \n-    if let (some_very_large,\n-            tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) = 1 + 2 + 3\n-    {\n-    }\n+    if let (\n+        some_very_large,\n+        tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple,\n+    ) = 1 + 2 + 3\n+    {}\n \n-    if let (some_very_large,\n-            tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) =\n-        1111 + 2222\n+    if let (\n+        some_very_large,\n+        tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple,\n+    ) = 1111 + 2222\n     {}\n \n-    if let (some_very_large,\n-            tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) = 1 + 2 + 3\n+    if let (\n+        some_very_large,\n+        tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple,\n+    ) = 1 + 2 + 3\n     {}\n \n     let test = if true { 5 } else { 3 };"}, {"sha": "68919b1039c8bc7c4e5422614f10c49345b40b8a", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -21,8 +21,10 @@ fn main() {\n \n \tlet str = \"AAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAa\";\n \n-\tif let (some_very_large,\n-\t        tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) = 1 + 2 + 3\n+\tif let (\n+\t\tsome_very_large,\n+\t\ttuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple,\n+\t) = 1 + 2 + 3\n \t{}\n \n \tif cond() {"}, {"sha": "7034740734614ebefb78ac967993620fd18d4cf1", "filename": "tests/target/issue-1021.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fissue-1021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fissue-1021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1021.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -6,11 +6,15 @@ fn main() {\n         S(.., true) => (),\n         S(..) => (),\n         S(_) => (),\n-        S(// ..\n-          ..) => (),\n-        S(// ..\n-          ..,\n-          true) => (),\n+        S(\n+            // ..\n+            ..\n+        ) => (),\n+        S(\n+            // ..\n+            ..,\n+            true,\n+        ) => (),\n     }\n \n     match y {\n@@ -19,10 +23,14 @@ fn main() {\n         (.., true) => (),\n         (..) => (),\n         (_,) => (),\n-        (// ..\n-         ..) => (),\n-        (// ..\n-         ..,\n-         true) => (),\n+        (\n+            // ..\n+            ..\n+        ) => (),\n+        (\n+            // ..\n+            ..,\n+            true,\n+        ) => (),\n     }\n }"}, {"sha": "1bfd1cd00413265db8c2e8dfce8a092945b3a465", "filename": "tests/target/issue-913.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fissue-913.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fissue-913.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-913.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -10,11 +10,13 @@ mod client {\n             };\n \n             let next_state = match self.state {\n-                State::V5(v5::State::Command(v5::comand::State::WriteVersion(ref mut response))) => {\n+                State::V5(\n+                    v5::State::Command(v5::comand::State::WriteVersion(ref mut response)),\n+                ) => {\n                     // The pattern cannot be formatted in a way that the match stays\n                     // within the column limit. The rewrite should therefore be\n                     // skipped.\n-                    let x =  dont . reformat . meeee();\n+                    let x = dont.reformat.meeee();\n                 }\n             };\n         }"}, {"sha": "d47e94b6464ed983ebf025036f31af307ed7b929", "filename": "tests/target/match.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -262,10 +262,12 @@ fn issue507() {\n \n fn issue508() {\n     match s.type_id() {\n-        Some(NodeTypeId::Element(ElementTypeId::HTMLElement(\n-                    HTMLElementTypeId::HTMLCanvasElement))) => true,\n-        Some(NodeTypeId::Element(ElementTypeId::HTMLElement(\n-                        HTMLElementTypeId::HTMLObjectElement))) => s.has_object_data(),\n+        Some(\n+            NodeTypeId::Element(ElementTypeId::HTMLElement(HTMLElementTypeId::HTMLCanvasElement)),\n+        ) => true,\n+        Some(\n+            NodeTypeId::Element(ElementTypeId::HTMLElement(HTMLElementTypeId::HTMLObjectElement)),\n+        ) => s.has_object_data(),\n         Some(NodeTypeId::Element(_)) => false,\n     }\n }"}, {"sha": "9f630f6dada602c626cb1158ec79047cdfbf120a", "filename": "tests/target/pattern-condense-wildcards.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fpattern-condense-wildcards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fpattern-condense-wildcards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpattern-condense-wildcards.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -7,10 +7,12 @@ fn main() {\n         Tup(_) => \"nah\",\n         Quad(_, _, x, _) => \" also no rewrite\",\n         Quad(x, ..) => \"condense me pls\",\n-        Weird(x,\n-              _,\n-              _,\n-              // dont condense before\n-              ..) => \"pls work\",\n+        Weird(\n+            x,\n+            _,\n+            _,\n+            // dont condense before\n+            ..\n+        ) => \"pls work\",\n     }\n }"}, {"sha": "39a8408a6301a4428c99859facfe8beea92f9843", "filename": "tests/target/pattern.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5/tests%2Ftarget%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpattern.rs?ref=02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "patch": "@@ -47,8 +47,9 @@ fn main() {\n impl<'a, 'b> ResolveGeneratedContentFragmentMutator<'a, 'b> {\n     fn mutate_fragment(&mut self, fragment: &mut Fragment) {\n         match **info {\n-            GeneratedContentInfo::ContentItem(ContentItem::Counter(ref counter_name,\n-                                                                   counter_style)) => {}\n+            GeneratedContentInfo::ContentItem(\n+                ContentItem::Counter(ref counter_name, counter_style),\n+            ) => {}\n         }\n     }\n }"}]}