{"sha": "2cdbd288ac0606902885434e1ccd8d8bde68913d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZGJkMjg4YWMwNjA2OTAyODg1NDM0ZTFjY2Q4ZDhiZGU2ODkxM2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T23:34:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T23:34:48Z"}, "message": "rollup merge of #22210: aturon/stab-final-borrow\n\nConflicts:\n\tsrc/libcollections/btree/map.rs\n\tsrc/libcollections/str.rs\n\tsrc/libcollections/vec.rs\n\tsrc/libcore/borrow.rs\n\tsrc/libcore/hash/mod.rs\n\tsrc/libstd/collections/hash/map.rs\n\tsrc/libstd/collections/hash/set.rs", "tree": {"sha": "9a7d37f7dd44424182797c76d49ba0ece99f9513", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a7d37f7dd44424182797c76d49ba0ece99f9513"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cdbd288ac0606902885434e1ccd8d8bde68913d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cdbd288ac0606902885434e1ccd8d8bde68913d", "html_url": "https://github.com/rust-lang/rust/commit/2cdbd288ac0606902885434e1ccd8d8bde68913d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cdbd288ac0606902885434e1ccd8d8bde68913d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "365bd9a9e3b9dafa98e26982353fd28a6ca1efef", "url": "https://api.github.com/repos/rust-lang/rust/commits/365bd9a9e3b9dafa98e26982353fd28a6ca1efef", "html_url": "https://github.com/rust-lang/rust/commit/365bd9a9e3b9dafa98e26982353fd28a6ca1efef"}, {"sha": "a99e698628cbd396c8100ef776d10ac61d911847", "url": "https://api.github.com/repos/rust-lang/rust/commits/a99e698628cbd396c8100ef776d10ac61d911847", "html_url": "https://github.com/rust-lang/rust/commit/a99e698628cbd396c8100ef776d10ac61d911847"}], "stats": {"total": 1280, "additions": 766, "deletions": 514}, "files": [{"sha": "934e6ab2159166bd9823779a88670684997731ae", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -73,7 +73,6 @@ use core::prelude::*;\n \n use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n-use core::borrow::BorrowFrom;\n use core::fmt;\n use core::cmp::{Ordering};\n use core::default::Default;\n@@ -244,12 +243,6 @@ impl<T> Clone for Arc<T> {\n     }\n }\n \n-impl<T> BorrowFrom<Arc<T>> for T {\n-    fn borrow_from(owned: &Arc<T>) -> &T {\n-        &**owned\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Arc<T> {\n     type Target = T;"}, {"sha": "9d39511543188736cd20c9935d80a9f0d3469e78", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -144,7 +144,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::borrow::BorrowFrom;\n use core::cell::Cell;\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n@@ -349,12 +348,6 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n-impl<T> BorrowFrom<Rc<T>> for T {\n-    fn borrow_from(owned: &Rc<T>) -> &T {\n-        &**owned\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Rc<T> {\n     type Target = T;"}, {"sha": "901d7a73b51ed27bbc051ccc09a261fc3b5e3353", "filename": "src/libcollections/borrow.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -0,0 +1,316 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A module for working with borrowed data.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use core::clone::Clone;\n+use core::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n+use core::hash::{Hash, Hasher};\n+use core::marker::Sized;\n+use core::ops::Deref;\n+use core::option::Option;\n+\n+use fmt;\n+use alloc::{rc, arc};\n+\n+use self::Cow::*;\n+\n+/// A trait for borrowing data.\n+///\n+/// In general, there may be several ways to \"borrow\" a piece of data.  The\n+/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n+/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n+/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+///\n+/// When writing generic code, it is often desirable to abstract over all ways\n+/// of borrowing data from a given type. That is the role of the `Borrow`\n+/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n+/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n+/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Borrow<Borrowed: ?Sized> {\n+    /// Immutably borrow from an owned value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow(&self) -> &Borrowed;\n+}\n+\n+/// A trait for mutably borrowing data.\n+///\n+/// Similar to `Borrow`, but for mutable borrows.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n+    /// Mutably borrow from an owned value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow_mut(&mut self) -> &mut Borrowed;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Borrow<T> for T {\n+    fn borrow(&self) -> &T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> BorrowMut<T> for T {\n+    fn borrow_mut(&mut self) -> &mut T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a mut T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n+    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n+}\n+\n+impl<T> Borrow<T> for rc::Rc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+impl<T> Borrow<T> for arc::Arc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n+    fn borrow(&self) -> &B {\n+        &**self\n+    }\n+}\n+\n+/// A generalization of Clone to borrowed data.\n+///\n+/// Some types make it possible to go from borrowed to owned, usually by\n+/// implementing the `Clone` trait. But `Clone` works only for going from `&T`\n+/// to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n+/// from any borrow of a given type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ToOwned {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Owned: Borrow<Self>;\n+\n+    /// Create owned data from borrowed data, usually by copying.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_owned(&self) -> Self::Owned;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ToOwned for T where T: Clone {\n+    type Owned = T;\n+    fn to_owned(&self) -> T { self.clone() }\n+}\n+\n+/// A clone-on-write smart pointer.\n+///\n+/// The type `Cow` is a smart pointer providing clone-on-write functionality: it\n+/// can enclose and provide immutable access to borrowed data, and clone the\n+/// data lazily when mutation or ownership is required. The type is designed to\n+/// work with general borrowed data via the `Borrow` trait.\n+///\n+/// `Cow` implements both `Deref`, which means that you can call\n+/// non-mutating methods directly on the data it encloses. If mutation\n+/// is desired, `to_mut` will obtain a mutable references to an owned\n+/// value, cloning if necessary.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::borrow::Cow;\n+///\n+/// fn abs_all(input: &mut Cow<[int]>) {\n+///     for i in 0..input.len() {\n+///         let v = input[i];\n+///         if v < 0 {\n+///             // clones into a vector the first time (if not already owned)\n+///             input.to_mut()[i] = -v;\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Cow<'a, B: ?Sized + 'a> where B: ToOwned {\n+    /// Borrowed data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Borrowed(&'a B),\n+\n+    /// Owned data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Owned(<B as ToOwned>::Owned)\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n+    fn clone(&self) -> Cow<'a, B> {\n+        match *self {\n+            Borrowed(b) => Borrowed(b),\n+            Owned(ref o) => {\n+                let b: &B = o.borrow();\n+                Owned(b.to_owned())\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n+    /// Acquire a mutable reference to the owned form of the data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn to_mut(&mut self) -> &mut <B as ToOwned>::Owned {\n+        match *self {\n+            Borrowed(borrowed) => {\n+                *self = Owned(borrowed.to_owned());\n+                self.to_mut()\n+            }\n+            Owned(ref mut owned) => owned\n+        }\n+    }\n+\n+    /// Extract the owned data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_owned(self) -> <B as ToOwned>::Owned {\n+        match self {\n+            Borrowed(borrowed) => borrowed.to_owned(),\n+            Owned(owned) => owned\n+        }\n+    }\n+\n+    /// Returns true if this `Cow` wraps a borrowed value\n+    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_borrowed(&self) -> bool {\n+        match *self {\n+            Borrowed(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this `Cow` wraps an owned value\n+    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_owned(&self) -> bool {\n+        match *self {\n+            Owned(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Deref for Cow<'a, B> where B: ToOwned {\n+    type Target = B;\n+\n+    fn deref(&self) -> &B {\n+        match *self {\n+            Borrowed(borrowed) => borrowed,\n+            Owned(ref owned) => owned.borrow()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Eq for Cow<'a, B> where B: Eq + ToOwned {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Ord for Cow<'a, B> where B: Ord + ToOwned {\n+    #[inline]\n+    fn cmp(&self, other: &Cow<'a, B>) -> Ordering {\n+        Ord::cmp(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n+    B: PartialEq<C> + ToOwned, C: ToOwned,\n+{\n+    #[inline]\n+    fn eq(&self, other: &Cow<'b, C>) -> bool {\n+        PartialEq::eq(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where B: PartialOrd + ToOwned,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n+    B: fmt::Debug + ToOwned,\n+    <B as ToOwned>::Owned: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n+            Owned(ref o) => fmt::Debug::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n+    B: fmt::Display + ToOwned,\n+    <B as ToOwned>::Owned: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Display::fmt(b, f),\n+            Owned(ref o) => fmt::Display::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n+impl<'a, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, B> where B: Hash<S> + ToOwned\n+{\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        Hash::hash(&**self, state)\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n+{\n+    #[inline]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        Hash::hash(&**self, state)\n+    }\n+}\n+\n+/// Trait for moving into a `Cow`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n+    /// Moves `self` into `Cow`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_cow(self) -> Cow<'a, B>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n+    fn into_cow(self) -> Cow<'a, B> {\n+        self\n+    }\n+}"}, {"sha": "c1d74b16ce6bcacff795ef172f31283a17ec04fb", "filename": "src/libcollections/borrow_stage0.rs", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fborrow_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fborrow_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow_stage0.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -0,0 +1,313 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A module for working with borrowed data.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use core::clone::Clone;\n+use core::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n+use core::hash::{Hash, Hasher};\n+use core::marker::Sized;\n+use core::ops::Deref;\n+use core::option::Option;\n+\n+use fmt;\n+use alloc::{rc, arc};\n+\n+use self::Cow::*;\n+\n+/// A trait for borrowing data.\n+///\n+/// In general, there may be several ways to \"borrow\" a piece of data.  The\n+/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n+/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n+/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+///\n+/// When writing generic code, it is often desirable to abstract over all ways\n+/// of borrowing data from a given type. That is the role of the `Borrow`\n+/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n+/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n+/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Borrow<Borrowed: ?Sized> {\n+    /// Immutably borrow from an owned value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow(&self) -> &Borrowed;\n+}\n+\n+/// A trait for mutably borrowing data.\n+///\n+/// Similar to `Borrow`, but for mutable borrows.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n+    /// Mutably borrow from an owned value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow_mut(&mut self) -> &mut Borrowed;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Borrow<T> for T {\n+    fn borrow(&self) -> &T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> BorrowMut<T> for T {\n+    fn borrow_mut(&mut self) -> &mut T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a mut T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n+    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n+}\n+\n+impl<T> Borrow<T> for rc::Rc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+impl<T> Borrow<T> for arc::Arc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n+    fn borrow(&self) -> &B {\n+        &**self\n+    }\n+}\n+\n+/// A generalization of Clone to borrowed data.\n+///\n+/// Some types make it possible to go from borrowed to owned, usually by\n+/// implementing the `Clone` trait. But `Clone` works only for going from `&T`\n+/// to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n+/// from any borrow of a given type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ToOwned {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Owned: Borrow<Self>;\n+\n+    /// Create owned data from borrowed data, usually by copying.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_owned(&self) -> Self::Owned;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ToOwned for T where T: Clone {\n+    type Owned = T;\n+    fn to_owned(&self) -> T { self.clone() }\n+}\n+\n+/// A clone-on-write smart pointer.\n+///\n+/// The type `Cow` is a smart pointer providing clone-on-write functionality: it\n+/// can enclose and provide immutable access to borrowed data, and clone the\n+/// data lazily when mutation or ownership is required. The type is designed to\n+/// work with general borrowed data via the `Borrow` trait.\n+///\n+/// `Cow` implements both `Deref`, which means that you can call\n+/// non-mutating methods directly on the data it encloses. If mutation\n+/// is desired, `to_mut` will obtain a mutable references to an owned\n+/// value, cloning if necessary.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::borrow::Cow;\n+///\n+/// fn abs_all(input: &mut Cow<[int]>) {\n+///     for i in 0..input.len() {\n+///         let v = input[i];\n+///         if v < 0 {\n+///             // clones into a vector the first time (if not already owned)\n+///             input.to_mut()[i] = -v;\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Cow<'a, B: ?Sized + 'a> where B: ToOwned {\n+    /// Borrowed data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Borrowed(&'a B),\n+\n+    /// Owned data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Owned(<B as ToOwned>::Owned)\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n+    fn clone(&self) -> Cow<'a, B> {\n+        match *self {\n+            Borrowed(b) => Borrowed(b),\n+            Owned(ref o) => {\n+                let b: &B = o.borrow();\n+                Owned(b.to_owned())\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n+    /// Acquire a mutable reference to the owned form of the data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn to_mut(&mut self) -> &mut <B as ToOwned>::Owned where <B as ToOwned>::Owned: 'a {\n+        match *self {\n+            Borrowed(borrowed) => {\n+                *self = Owned(borrowed.to_owned());\n+                self.to_mut()\n+            }\n+            Owned(ref mut owned) => owned\n+        }\n+    }\n+\n+    /// Extract the owned data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_owned(self) -> <B as ToOwned>::Owned {\n+        match self {\n+            Borrowed(borrowed) => borrowed.to_owned(),\n+            Owned(owned) => owned\n+        }\n+    }\n+\n+    /// Returns true if this `Cow` wraps a borrowed value\n+    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_borrowed(&self) -> bool {\n+        match *self {\n+            Borrowed(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this `Cow` wraps an owned value\n+    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_owned(&self) -> bool {\n+        match *self {\n+            Owned(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Deref for Cow<'a, B> where\n+    B: ToOwned, <B as ToOwned>::Owned: 'a\n+{\n+    type Target = B;\n+\n+    fn deref(&self) -> &B {\n+        match *self {\n+            Borrowed(borrowed) => borrowed,\n+            Owned(ref owned) => owned.borrow()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Eq for Cow<'a, B> where B: Eq + ToOwned, <B as ToOwned>::Owned: 'a {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Ord for Cow<'a, B> where\n+    B: Ord + ToOwned, <B as ToOwned>::Owned: 'a\n+{\n+    #[inline]\n+    fn cmp(&self, other: &Cow<'a, B>) -> Ordering {\n+        Ord::cmp(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n+    B: PartialEq<C> + ToOwned, C: ToOwned,\n+    <B as ToOwned>::Owned: 'a, <C as ToOwned>::Owned: 'b,\n+{\n+    #[inline]\n+    fn eq(&self, other: &Cow<'b, C>) -> bool {\n+        PartialEq::eq(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where\n+    B: PartialOrd + ToOwned, <B as ToOwned>::Owned: 'a\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n+    B: fmt::Debug + ToOwned,\n+    <B as ToOwned>::Owned: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n+            Owned(ref o) => fmt::Debug::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n+    B: fmt::Display + ToOwned,\n+    <B as ToOwned>::Owned: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Display::fmt(b, f),\n+            Owned(ref o) => fmt::Display::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, B> where\n+    B: Hash<S> + ToOwned, <B as ToOwned>::Owned: 'a\n+{\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        Hash::hash(&**self, state)\n+    }\n+}\n+\n+/// Trait for moving into a `Cow`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n+    /// Moves `self` into `Cow`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_cow(self) -> Cow<'a, B>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n+    fn into_cow(self) -> Cow<'a, B> {\n+        self\n+    }\n+}"}, {"sha": "c6cd68957288351fe722042af5d156f8f9374367", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -19,7 +19,6 @@ use self::Entry::*;\n \n use core::prelude::*;\n \n-use core::borrow::BorrowFrom;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Debug;\n@@ -29,6 +28,7 @@ use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n use Bound::{self, Included, Excluded, Unbounded};\n \n+use borrow::Borrow;\n use vec_deque::VecDeque;\n \n use self::Continuation::{Continue, Finished};\n@@ -208,7 +208,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: Ord {\n         let mut cur_node = &self.root;\n         loop {\n             match Node::search(cur_node, key) {\n@@ -240,7 +240,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where K: Borrow<Q>, Q: Ord {\n         self.get(key).is_some()\n     }\n \n@@ -264,7 +264,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where K: Borrow<Q>, Q: Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -434,7 +434,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where K: Borrow<Q>, Q: Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -913,7 +913,7 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n-    where Q: BorrowFrom<K> + Ord\n+    where K: Borrow<Q>, Q: Ord\n {\n     type Output = V;\n \n@@ -924,7 +924,7 @@ impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n-    where Q: BorrowFrom<K> + Ord\n+    where K: Borrow<Q>, Q: Ord\n {\n     fn index_mut(&mut self, key: &Q) -> &mut V {\n         self.get_mut(key).expect(\"no entry found for key\")"}, {"sha": "8f5ee35fcb2658a22d9eec522805c063d74ff0e9", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -18,14 +18,15 @@ pub use self::TraversalItem::*;\n \n use core::prelude::*;\n \n-use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{Greater, Less, Equal};\n use core::iter::Zip;\n use core::ops::{Deref, DerefMut, Index, IndexMut};\n use core::ptr::Unique;\n use core::{slice, mem, ptr, cmp, num, raw};\n use alloc::heap;\n \n+use borrow::Borrow;\n+\n /// Represents the result of an Insertion: either the item fit, or the node had to split\n pub enum InsertionResult<K, V> {\n     /// The inserted element fit\n@@ -543,7 +544,7 @@ impl<K: Ord, V> Node<K, V> {\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n     pub fn search<Q: ?Sized, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n-                  -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n+                  -> SearchResult<NodeRef> where K: Borrow<Q>, Q: Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for usizes.\n@@ -1491,9 +1492,9 @@ macro_rules! node_slice_impl {\n         impl<'a, K: Ord + 'a, V: 'a> $NodeSlice<'a, K, V> {\n             /// Performs linear search in a slice. Returns a tuple of (index, is_exact_match).\n             fn search_linear<Q: ?Sized>(&self, key: &Q) -> (usize, bool)\n-                    where Q: BorrowFrom<K> + Ord {\n+                    where K: Borrow<Q>, Q: Ord {\n                 for (i, k) in self.keys.iter().enumerate() {\n-                    match key.cmp(BorrowFrom::borrow_from(k)) {\n+                    match key.cmp(k.borrow()) {\n                         Greater => {},\n                         Equal => return (i, true),\n                         Less => return (i, false),"}, {"sha": "929b2f58043035105097de82e38a1702575f2477", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -13,14 +13,14 @@\n \n use core::prelude::*;\n \n-use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n use core::default::Default;\n use core::fmt::Debug;\n use core::fmt;\n use core::iter::{Peekable, Map, FromIterator, IntoIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n+use borrow::Borrow;\n use btree_map::{BTreeMap, Keys};\n use Bound;\n \n@@ -336,7 +336,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where T: Borrow<Q>, Q: Ord {\n         self.map.contains_key(value)\n     }\n \n@@ -466,7 +466,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where T: Borrow<Q>, Q: Ord {\n         self.map.remove(value).is_some()\n     }\n }"}, {"sha": "8fce626755ee35a309b15c257ef6a04dae214605", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -96,6 +96,13 @@ pub mod string;\n pub mod vec;\n pub mod vec_map;\n \n+#[cfg(stage0)]\n+#[path = \"borrow_stage0.rs\"]\n+pub mod borrow;\n+\n+#[cfg(not(stage0))]\n+pub mod borrow;\n+\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n pub mod bit_vec {"}, {"sha": "a0cb98267fa771176ff243d0375e8ff529c5f1d2", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -88,7 +88,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n-use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n use core::clone::Clone;\n use core::cmp::Ordering::{self, Greater, Less};\n use core::cmp::{self, Ord, PartialEq};\n@@ -105,6 +104,7 @@ use core::result::Result;\n use core::slice as core_slice;\n use self::Direction::*;\n \n+use borrow::{Borrow, BorrowMut, ToOwned};\n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, Windows};\n@@ -1175,18 +1175,19 @@ impl ElementSwaps {\n // Standard trait implementations for slices\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl<T> BorrowFrom<Vec<T>> for [T] {\n-    fn borrow_from(owned: &Vec<T>) -> &[T] { &owned[] }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Borrow<[T]> for Vec<T> {\n+    fn borrow(&self) -> &[T] { &self[] }\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { &mut owned[] }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> BorrowMut<[T]> for Vec<T> {\n+    fn borrow_mut(&mut self) -> &mut [T] { &mut self[] }\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl<T: Clone> ToOwned<Vec<T>> for [T] {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Clone> ToOwned for [T] {\n+    type Owned = Vec<T>;\n     fn to_owned(&self) -> Vec<T> { self.to_vec() }\n }\n "}, {"sha": "cdc503500d2a69bd2feee6b0e856896d5ce98484", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -55,7 +55,6 @@\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n \n-use core::borrow::{BorrowFrom, ToOwned};\n use core::char::CharExt;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n@@ -69,6 +68,7 @@ use core::str as core_str;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n use vec_deque::VecDeque;\n+use borrow::{Borrow, ToOwned};\n use slice::SliceExt;\n use string::String;\n use unicode;\n@@ -386,13 +386,14 @@ macro_rules! utf8_acc_cont_byte {\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl BorrowFrom<String> for str {\n-    fn borrow_from(owned: &String) -> &str { &owned[] }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Borrow<str> for String {\n+    fn borrow(&self) -> &str { &self[] }\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl ToOwned<String> for str {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToOwned for str {\n+    type Owned = String;\n     fn to_owned(&self) -> String {\n         unsafe {\n             String::from_utf8_unchecked(self.as_bytes().to_owned())"}, {"sha": "5e48336dfad27954c68a867bae6a430dffd80839", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -16,7 +16,6 @@\n \n use core::prelude::*;\n \n-use core::borrow::{Cow, IntoCow};\n use core::default::Default;\n use core::error::Error;\n use core::fmt;\n@@ -29,6 +28,7 @@ use core::raw::Slice as RawSlice;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n+use borrow::{Cow, IntoCow};\n use str::{self, CharRange, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n@@ -142,7 +142,7 @@ impl String {\n     /// assert_eq!(output.as_slice(), \"Hello \\u{FFFD}World\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n+    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n         let mut i = 0;\n         match str::from_utf8(v) {\n             Ok(s) => return Cow::Borrowed(s),\n@@ -782,22 +782,22 @@ macro_rules! impl_eq {\n }\n \n impl_eq! { String, &'a str }\n-impl_eq! { CowString<'a>, String }\n+impl_eq! { Cow<'a, str>, String }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n+impl<'a, 'b> PartialEq<&'b str> for Cow<'a, str> {\n     #[inline]\n     fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n+impl<'a, 'b> PartialEq<Cow<'a, str>> for &'b str {\n     #[inline]\n-    fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n+    fn eq(&self, other: &Cow<'a, str>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n-    fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n+    fn ne(&self, other: &Cow<'a, str>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n #[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n@@ -969,31 +969,34 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n     }\n }\n \n-impl IntoCow<'static, String, str> for String {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl IntoCow<'static, str> for String {\n     #[inline]\n-    fn into_cow(self) -> CowString<'static> {\n+    fn into_cow(self) -> Cow<'static, str> {\n         Cow::Owned(self)\n     }\n }\n \n-impl<'a> IntoCow<'a, String, str> for &'a str {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> IntoCow<'a, str> for &'a str {\n     #[inline]\n-    fn into_cow(self) -> CowString<'a> {\n+    fn into_cow(self) -> Cow<'a, str> {\n         Cow::Borrowed(self)\n     }\n }\n \n-/// A clone-on-write string\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub type CowString<'a> = Cow<'a, String, str>;\n-\n-impl<'a> Str for CowString<'a> {\n+impl<'a> Str for Cow<'a, str> {\n     #[inline]\n     fn as_slice<'b>(&'b self) -> &'b str {\n         &**self\n     }\n }\n \n+/// A clone-on-write string\n+#[deprecated(since = \"1.0.0\", reason = \"use Cow<'a, str> instead\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type CowString<'a> = Cow<'a, str>;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]"}, {"sha": "e303d7760034f5354351630977b02b7d9d4b3c5c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -50,7 +50,6 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n-use core::borrow::{Cow, IntoCow};\n use core::cmp::max;\n use core::cmp::{Ordering};\n use core::default::Default;\n@@ -69,6 +68,8 @@ use core::raw::Slice as RawSlice;\n use core::slice;\n use core::usize;\n \n+use borrow::{Cow, IntoCow};\n+\n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n /// # Examples\n@@ -1529,54 +1530,53 @@ macro_rules! impl_eq {\n impl_eq! { Vec<A>, &'b [B] }\n impl_eq! { Vec<A>, &'b mut [B] }\n \n-impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+impl<'a, A, B> PartialEq<Vec<B>> for Cow<'a, [A]> where A: PartialEq<B> + Clone {\n     #[inline]\n     fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n+impl<'a, A, B> PartialEq<Cow<'a, [A]>> for Vec<B> where A: Clone, B: PartialEq<A> {\n     #[inline]\n-    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+    fn eq(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n-    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+    fn ne(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n macro_rules! impl_eq_for_cowvec {\n     ($rhs:ty) => {\n-        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+        impl<'a, 'b, A, B> PartialEq<$rhs> for Cow<'a, [A]> where A: PartialEq<B> + Clone {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n-        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n+        impl<'a, 'b, A, B> PartialEq<Cow<'a, [A]>> for $rhs where A: Clone, B: PartialEq<A> {\n             #[inline]\n-            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+            fn eq(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n-            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+            fn ne(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n     }\n }\n \n impl_eq_for_cowvec! { &'b [B] }\n impl_eq_for_cowvec! { &'b mut [B] }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"waiting on PartialOrd stability\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Eq stability\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Vec<T> {}\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Ord stability\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n@@ -1659,26 +1659,26 @@ impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"collections\",\n-           reason = \"unclear how valuable this alias is\")]\n /// A clone-on-write vector\n-pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n+#[deprecated(since = \"1.0.0\", reason = \"use Cow<'a, [T]> instead\")]\n+#[unstable(feature = \"collections\")]\n+pub type CowVec<'a, T> = Cow<'a, [T]>;\n \n #[unstable(feature = \"collections\")]\n-impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n-    fn from_iter<I: IntoIterator<Item=T>>(it: I) -> CowVec<'a, T> {\n+impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n+    fn from_iter<I: IntoIterator<Item=T>>(it: I) -> Cow<'a, [T]> {\n         Cow::Owned(FromIterator::from_iter(it))\n     }\n }\n \n-impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n+impl<'a, T: 'a> IntoCow<'a, [T]> for Vec<T> where T: Clone {\n+    fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Owned(self)\n     }\n }\n \n-impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n+impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n+    fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Borrowed(self)\n     }\n }"}, {"sha": "3131952d94dbbdd96c28806484782c3976d705b7", "filename": "src/libcore/borrow.rs", "status": "removed", "additions": 0, "deletions": 265, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/365bd9a9e3b9dafa98e26982353fd28a6ca1efef/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/365bd9a9e3b9dafa98e26982353fd28a6ca1efef/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=365bd9a9e3b9dafa98e26982353fd28a6ca1efef", "patch": "@@ -1,265 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A module for working with borrowed data.\n-//!\n-//! # The `BorrowFrom` traits\n-//!\n-//! In general, there may be several ways to \"borrow\" a piece of data.  The\n-//! typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n-//! (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n-//! borrows: the borrowed slices `&[T]` and `&mut [T]`.\n-//!\n-//! When writing generic code, it is often desirable to abstract over all ways\n-//! of borrowing data from a given type. That is the role of the `BorrowFrom`\n-//! trait: if `T: BorrowFrom<U>`, then `&T` can be borrowed from `&U`.  A given\n-//! type can be borrowed as multiple different types. In particular, `Vec<T>:\n-//! BorrowFrom<Vec<T>>` and `[T]: BorrowFrom<Vec<T>>`.\n-//!\n-//! # The `ToOwned` trait\n-//!\n-//! Some types make it possible to go from borrowed to owned, usually by\n-//! implementing the `Clone` trait. But `Clone` works only for going from `&T`\n-//! to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n-//! from any borrow of a given type.\n-//!\n-//! # The `Cow` (clone-on-write) type\n-//!\n-//! The type `Cow` is a smart pointer providing clone-on-write functionality: it\n-//! can enclose and provide immutable access to borrowed data, and clone the\n-//! data lazily when mutation or ownership is required. The type is designed to\n-//! work with general borrowed data via the `BorrowFrom` trait.\n-//!\n-//! `Cow` implements both `Deref`, which means that you can call\n-//! non-mutating methods directly on the data it encloses. If mutation\n-//! is desired, `to_mut` will obtain a mutable references to an owned\n-//! value, cloning if necessary.\n-\n-#![unstable(feature = \"core\",\n-            reason = \"recently added as part of collections reform\")]\n-\n-use clone::Clone;\n-use cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n-use fmt;\n-use marker::Sized;\n-use ops::Deref;\n-use option::Option;\n-use self::Cow::*;\n-\n-/// A trait for borrowing data.\n-#[old_orphan_check]\n-pub trait BorrowFrom<Owned: ?Sized> {\n-    /// Immutably borrow from an owned value.\n-    fn borrow_from(owned: &Owned) -> &Self;\n-}\n-\n-/// A trait for mutably borrowing data.\n-#[old_orphan_check]\n-pub trait BorrowFromMut<Owned: ?Sized> : BorrowFrom<Owned> {\n-    /// Mutably borrow from an owned value.\n-    fn borrow_from_mut(owned: &mut Owned) -> &mut Self;\n-}\n-\n-impl<T: ?Sized> BorrowFrom<T> for T {\n-    fn borrow_from(owned: &T) -> &T { owned }\n-}\n-\n-impl<T: ?Sized> BorrowFromMut<T> for T {\n-    fn borrow_from_mut(owned: &mut T) -> &mut T { owned }\n-}\n-\n-impl<'a, T: ?Sized> BorrowFrom<&'a T> for T {\n-    fn borrow_from<'b>(owned: &'b &'a T) -> &'b T { &**owned }\n-}\n-\n-impl<'a, T: ?Sized> BorrowFrom<&'a mut T> for T {\n-    fn borrow_from<'b>(owned: &'b &'a mut T) -> &'b T { &**owned }\n-}\n-\n-impl<'a, T: ?Sized> BorrowFromMut<&'a mut T> for T {\n-    fn borrow_from_mut<'b>(owned: &'b mut &'a mut T) -> &'b mut T { &mut **owned }\n-}\n-\n-impl<'a, T, B: ?Sized> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n-    fn borrow_from<'b>(owned: &'b Cow<'a, T, B>) -> &'b B {\n-        &**owned\n-    }\n-}\n-\n-/// Trait for moving into a `Cow`\n-#[old_orphan_check]\n-pub trait IntoCow<'a, T, B: ?Sized> {\n-    /// Moves `self` into `Cow`\n-    fn into_cow(self) -> Cow<'a, T, B>;\n-}\n-\n-impl<'a, T, B: ?Sized> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> {\n-    fn into_cow(self) -> Cow<'a, T, B> {\n-        self\n-    }\n-}\n-\n-/// A generalization of Clone to borrowed data.\n-#[old_orphan_check]\n-pub trait ToOwned<Owned>: BorrowFrom<Owned> {\n-    /// Create owned data from borrowed data, usually by copying.\n-    fn to_owned(&self) -> Owned;\n-}\n-\n-impl<T> ToOwned<T> for T where T: Clone {\n-    fn to_owned(&self) -> T { self.clone() }\n-}\n-\n-/// A clone-on-write smart pointer.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::borrow::Cow;\n-///\n-/// fn abs_all(input: &mut Cow<Vec<i32>, [i32]>) {\n-///     for i in 0..input.len() {\n-///         let v = input[i];\n-///         if v < 0 {\n-///             // clones into a vector the first time (if not already owned)\n-///             input.to_mut()[i] = -v;\n-///         }\n-///     }\n-/// }\n-/// ```\n-pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n-    /// Borrowed data.\n-    Borrowed(&'a B),\n-\n-    /// Owned data.\n-    Owned(T)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n-    fn clone(&self) -> Cow<'a, T, B> {\n-        match *self {\n-            Borrowed(b) => Borrowed(b),\n-            Owned(ref o) => {\n-                let b: &B = BorrowFrom::borrow_from(o);\n-                Owned(b.to_owned())\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> {\n-    /// Acquire a mutable reference to the owned form of the data.\n-    ///\n-    /// Copies the data if it is not already owned.\n-    pub fn to_mut(&mut self) -> &mut T {\n-        match *self {\n-            Borrowed(borrowed) => {\n-                *self = Owned(borrowed.to_owned());\n-                self.to_mut()\n-            }\n-            Owned(ref mut owned) => owned\n-        }\n-    }\n-\n-    /// Extract the owned data.\n-    ///\n-    /// Copies the data if it is not already owned.\n-    pub fn into_owned(self) -> T {\n-        match self {\n-            Borrowed(borrowed) => borrowed.to_owned(),\n-            Owned(owned) => owned\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps a borrowed value\n-    pub fn is_borrowed(&self) -> bool {\n-        match *self {\n-            Borrowed(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps an owned value\n-    pub fn is_owned(&self) -> bool {\n-        match *self {\n-            Owned(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n-    type Target = B;\n-\n-    fn deref(&self) -> &B {\n-        match *self {\n-            Borrowed(borrowed) => borrowed,\n-            Owned(ref owned) => BorrowFrom::borrow_from(owned)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n-        Ord::cmp(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n-    B: PartialEq<C> + ToOwned<T>,\n-    C: ToOwned<U>,\n-{\n-    #[inline]\n-    fn eq(&self, other: &Cow<'b, U, C>) -> bool {\n-        PartialEq::eq(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n-        PartialOrd::partial_cmp(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> fmt::Debug for Cow<'a, T, B> where\n-    B: fmt::Debug + ToOwned<T>,\n-    T: fmt::Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n-            Owned(ref o) => fmt::Debug::fmt(o, f),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> fmt::Display for Cow<'a, T, B> where\n-    B: fmt::Display + ToOwned<T>,\n-    T: fmt::Display,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Borrowed(ref b) => fmt::Display::fmt(b, f),\n-            Owned(ref o) => fmt::Display::fmt(o, f),\n-        }\n-    }\n-}"}, {"sha": "3d0c9761dda77b122f94d3efa5a20413c1ea9336", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 116, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -58,8 +58,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use default::Default;\n-use marker::Sized;\n use mem;\n \n pub use self::sip::SipHasher;\n@@ -398,119 +399,4 @@ mod impls {\n             }\n         )*}\n     }\n-\n-    impl_write! {\n-        (u8, write_u8),\n-        (u16, write_u16),\n-        (u32, write_u32),\n-        (u64, write_u64),\n-        (usize, write_usize),\n-        (i8, write_i8),\n-        (i16, write_i16),\n-        (i32, write_i32),\n-        (i64, write_i64),\n-        (isize, write_isize),\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for bool {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            state.write_u8(*self as u8)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for char {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            state.write_u32(*self as u32)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for str {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            state.write(self.as_bytes());\n-            state.write_u8(0xff)\n-        }\n-    }\n-\n-    macro_rules! impl_hash_tuple {\n-        () => (\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Hash for () {\n-                fn hash<H: Hasher>(&self, _state: &mut H) {}\n-            }\n-        );\n-\n-        ( $($name:ident)+) => (\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($name: Hash),*> Hash for ($($name,)*) {\n-                #[allow(non_snake_case)]\n-                fn hash<S: Hasher>(&self, state: &mut S) {\n-                    let ($(ref $name,)*) = *self;\n-                    $($name.hash(state);)*\n-                }\n-            }\n-        );\n-    }\n-\n-    impl_hash_tuple! {}\n-    impl_hash_tuple! { A }\n-    impl_hash_tuple! { A B }\n-    impl_hash_tuple! { A B C }\n-    impl_hash_tuple! { A B C D }\n-    impl_hash_tuple! { A B C D E }\n-    impl_hash_tuple! { A B C D E F }\n-    impl_hash_tuple! { A B C D E F G }\n-    impl_hash_tuple! { A B C D E F G H }\n-    impl_hash_tuple! { A B C D E F G H I }\n-    impl_hash_tuple! { A B C D E F G H I J }\n-    impl_hash_tuple! { A B C D E F G H I J K }\n-    impl_hash_tuple! { A B C D E F G H I J K L }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Hash> Hash for [T] {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            self.len().hash(state);\n-            Hash::hash_slice(self, state)\n-        }\n-    }\n-\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T: ?Sized + Hash> Hash for &'a T {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            (**self).hash(state);\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T: ?Sized + Hash> Hash for &'a mut T {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            (**self).hash(state);\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T> Hash for *const T {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            state.write_usize(*self as usize)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T> Hash for *mut T {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            state.write_usize(*self as usize)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T, B: ?Sized> Hash for Cow<'a, T, B>\n-        where B: Hash + ToOwned<T>\n-    {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            Hash::hash(&**self, state)\n-        }\n-    }\n }"}, {"sha": "3c58480ff0cfa1d70275b9f04bf6931782575468", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -126,7 +126,6 @@ pub mod default;\n \n pub mod any;\n pub mod atomic;\n-pub mod borrow;\n pub mod cell;\n pub mod char;\n pub mod panicking;"}, {"sha": "28a97b1e8dbb3589b5154afc4c0d9c8fcaa57e5a", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -358,7 +358,7 @@ impl<'a> Id<'a> {\n     ///\n     /// Passing an invalid string (containing spaces, brackets,\n     /// quotes, ...) will return an empty `Err` value.\n-    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Result<Id<'a>, ()> {\n+    pub fn new<Name: IntoCow<'a, str>>(name: Name) -> Result<Id<'a>, ()> {\n         let name = name.into_cow();\n         {\n             let mut chars = name.chars();\n@@ -427,11 +427,11 @@ pub trait Labeller<'a,N,E> {\n }\n \n impl<'a> LabelText<'a> {\n-    pub fn label<S:IntoCow<'a, String, str>>(s: S) -> LabelText<'a> {\n+    pub fn label<S:IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n         LabelStr(s.into_cow())\n     }\n \n-    pub fn escaped<S:IntoCow<'a, String, str>>(s: S) -> LabelText<'a> {\n+    pub fn escaped<S:IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n         EscStr(s.into_cow())\n     }\n "}, {"sha": "f6d523cda8500ff54915fa4bf5f0cbbfa2aee91c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -68,7 +68,7 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FnvHashMap};\n \n use arena::TypedArena;\n-use std::borrow::{BorrowFrom, Cow};\n+use std::borrow::{Borrow, Cow};\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt;\n@@ -1001,9 +1001,9 @@ impl<'tcx> Hash for InternedTy<'tcx> {\n     }\n }\n \n-impl<'tcx> BorrowFrom<InternedTy<'tcx>> for sty<'tcx> {\n-    fn borrow_from<'a>(ty: &'a InternedTy<'tcx>) -> &'a sty<'tcx> {\n-        &ty.ty.sty\n+impl<'tcx> Borrow<sty<'tcx>> for InternedTy<'tcx> {\n+    fn borrow<'a>(&'a self) -> &'a sty<'tcx> {\n+        &self.ty.sty\n     }\n }\n "}, {"sha": "ade4f1f0533ee73abdb388bab488ac4a9a2d0452", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -14,7 +14,7 @@ use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n-use borrow::BorrowFrom;\n+use borrow::Borrow;\n use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n@@ -451,18 +451,18 @@ impl<K, V, S> HashMap<K, V, S>\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n     fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash\n+        where K: Borrow<Q>, Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n             .into_option()\n     }\n \n     fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash\n+        where K: Borrow<Q>, Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n             .into_option()\n     }\n \n@@ -1033,7 +1033,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where Q: Hash + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash + Eq\n     {\n         self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n@@ -1056,7 +1056,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where Q: Hash + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash + Eq\n     {\n         self.search(k).is_some()\n     }\n@@ -1082,7 +1082,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where Q: Hash + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash + Eq\n     {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n@@ -1134,7 +1134,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where Q: Hash + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash + Eq\n     {\n         if self.table.size() == 0 {\n             return None\n@@ -1236,8 +1236,8 @@ impl<K, V, S> Default for HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          Q: Eq + Hash + BorrowFrom<K>,\n+    where K: Eq + Hash + Borrow<Q>,\n+          Q: Eq + Hash,\n           S: HashState,\n {\n     type Output = V;\n@@ -1250,8 +1250,8 @@ impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          Q: Eq + Hash + BorrowFrom<K>,\n+    where K: Eq + Hash + Borrow<Q>,\n+          Q: Eq + Hash,\n           S: HashState,\n {\n     #[inline]"}, {"sha": "e0631a64d44b127048402f0667195daed7e4ffc6", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -10,7 +10,7 @@\n //\n // ignore-lexer-test FIXME #15883\n \n-use borrow::BorrowFrom;\n+use borrow::Borrow;\n use clone::Clone;\n use cmp::{Eq, PartialEq};\n use core::marker::Sized;\n@@ -460,7 +460,7 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash + Eq\n+        where T: Borrow<Q>, Q: Hash + Eq\n     {\n         self.map.contains_key(value)\n     }\n@@ -570,7 +570,7 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash + Eq\n+        where T: Borrow<Q>, Q: Hash + Eq\n     {\n         self.map.remove(value).is_some()\n     }"}, {"sha": "feace0bd7025f1765c0a31f495939e81fb5d6e1d", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -34,7 +34,7 @@\n \n use core::prelude::*;\n \n-use core::borrow::{BorrowFrom, ToOwned};\n+use borrow::{Borrow, ToOwned};\n use fmt::{self, Debug};\n use mem;\n use string::{String, CowString};\n@@ -285,11 +285,12 @@ impl Debug for OsStr {\n     }\n }\n \n-impl BorrowFrom<OsString> for OsStr {\n-    fn borrow_from(owned: &OsString) -> &OsStr { &owned[] }\n+impl Borrow<OsStr> for OsString {\n+    fn borrow(&self) -> &OsStr { &self[] }\n }\n \n-impl ToOwned<OsString> for OsStr {\n+impl ToOwned for OsStr {\n+    type Owned = OsString;\n     fn to_owned(&self) -> OsString { self.to_os_string() }\n }\n "}, {"sha": "fbd403ea593b8a970b0218f876a193d4cc71f778", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -161,7 +161,6 @@ extern crate libc;\n // NB: These reexports are in the order they should be listed in rustdoc\n \n pub use core::any;\n-pub use core::borrow;\n pub use core::cell;\n pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;\n@@ -184,6 +183,7 @@ pub use core::error;\n #[cfg(not(test))] pub use alloc::boxed;\n pub use alloc::rc;\n \n+pub use core_collections::borrow;\n pub use core_collections::fmt;\n pub use core_collections::slice;\n pub use core_collections::str;"}, {"sha": "3d95d0f19d1d9d1314fdd37adb0b3670b5044d63", "filename": "src/libstd/path.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -108,12 +108,11 @@\n use core::prelude::*;\n \n use ascii::*;\n-use borrow::BorrowFrom;\n+use borrow::{Borrow, ToOwned, Cow};\n use cmp;\n use iter::{self, IntoIterator};\n use mem;\n use ops::{self, Deref};\n-use string::CowString;\n use vec::Vec;\n use fmt;\n \n@@ -982,12 +981,17 @@ impl ops::Deref for PathBuf {\n     }\n }\n \n-impl BorrowFrom<PathBuf> for Path {\n-    fn borrow_from(owned: &PathBuf) -> &Path {\n-        owned.deref()\n+impl Borrow<Path> for PathBuf {\n+    fn borrow(&self) -> &Path {\n+        self.deref()\n     }\n }\n \n+impl ToOwned for Path {\n+    type Owned = PathBuf;\n+    fn to_owned(&self) -> PathBuf { self.to_path_buf() }\n+}\n+\n impl cmp::PartialEq for PathBuf {\n     fn eq(&self, other: &PathBuf) -> bool {\n         self.components() == other.components()\n@@ -1066,10 +1070,10 @@ impl Path {\n         self.inner.to_str()\n     }\n \n-    /// Convert a `Path` to a `CowString`.\n+    /// Convert a `Path` to a `Cow<str>`.\n     ///\n     /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n-    pub fn to_string_lossy(&self) -> CowString {\n+    pub fn to_string_lossy(&self) -> Cow<str> {\n         self.inner.to_string_lossy()\n     }\n "}, {"sha": "2e8f43be120adbec1745049830746607584768cd", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -14,7 +14,7 @@\n \n use ast::Name;\n \n-use std::borrow::BorrowFrom;\n+use std::borrow::Borrow;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::HashMap;\n@@ -80,7 +80,7 @@ impl<T: Eq + Hash<Hasher> + Clone + 'static> Interner<T> {\n     }\n \n     pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where Q: BorrowFrom<T> + Eq + Hash<Hasher> {\n+    where T: Borrow<Q>, Q: Eq + Hash<Hasher> {\n         let map = self.map.borrow();\n         match (*map).get(val) {\n             Some(v) => Some(*v),\n@@ -193,9 +193,9 @@ impl fmt::Display for RcStr {\n     }\n }\n \n-impl BorrowFrom<RcStr> for str {\n-    fn borrow_from(owned: &RcStr) -> &str {\n-        &owned.string[]\n+impl Borrow<str> for RcStr {\n+    fn borrow(&self) -> &str {\n+        &self.string[]\n     }\n }\n \n@@ -277,7 +277,7 @@ impl StrInterner {\n \n     #[cfg(stage0)]\n     pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where Q: BorrowFrom<RcStr> + Eq + Hash<Hasher> {\n+    where RcStr: Borrow<Q>, Q: Eq + Hash<Hasher> {\n         match (*self.map.borrow()).get(val) {\n             Some(v) => Some(*v),\n             None => None,"}, {"sha": "f4e18265fd9901b528653a777f77ea31f6a55226", "filename": "src/test/compile-fail/ufcs-qpath-missing-params.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -12,6 +12,5 @@ use std::borrow::IntoCow;\n \n fn main() {\n     <String as IntoCow>::into_cow(\"foo\".to_string());\n-    //~^ ERROR wrong number of type arguments: expected 2, found 0\n+    //~^ ERROR wrong number of type arguments: expected 1, found 0\n }\n-"}, {"sha": "fbbecfbf2a6267f6dc29d33c2670ef6710c49f50", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -34,7 +34,7 @@ use std::mem::size_of;\n static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n static yy: usize = 25;\n \n-static bob: Option<std::vec::CowVec<'static, isize>> = None;\n+static bob: Option<std::borrow::Cow<'static, [isize]>> = None;\n \n // buglink test - see issue #1337.\n "}, {"sha": "dce12030f79427caa502bb9f6c8cfc072ede4c76", "filename": "src/test/run-pass/const-polymorphic-paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -100,8 +100,8 @@ tests! {\n     Add::add, fn(i32, i32) -> i32, (5, 6);\n     <i32 as Add<_>>::add, fn(i32, i32) -> i32, (5, 6);\n     <i32 as Add<i32>>::add, fn(i32, i32) -> i32, (5, 6);\n-    <String as IntoCow<_, _>>::into_cow, fn(String) -> Cow<'static, String, str>,\n+    <String as IntoCow<_>>::into_cow, fn(String) -> Cow<'static, str>,\n         (\"foo\".to_string());\n-    <String as IntoCow<'static, _, _>>::into_cow, fn(String) -> Cow<'static, String, str>,\n+    <String as IntoCow<'static, _>>::into_cow, fn(String) -> Cow<'static, str>,\n         (\"foo\".to_string());\n }"}, {"sha": "33e4fa85bcb81003f155d1f4030e98c37b84acac", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -13,7 +13,7 @@ extern crate collections;\n use std::collections::HashMap;\n use std::borrow::{Cow, IntoCow};\n \n-type SendStr = Cow<'static, String, str>;\n+type SendStr = Cow<'static, str>;\n \n pub fn main() {\n     let mut map: HashMap<SendStr, uint> = HashMap::new();"}, {"sha": "3390369242d13943222cd5d9077b53712d0d9f29", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -13,7 +13,7 @@ extern crate collections;\n use self::collections::BTreeMap;\n use std::borrow::{Cow, IntoCow};\n \n-type SendStr = Cow<'static, String, str>;\n+type SendStr = Cow<'static, str>;\n \n pub fn main() {\n     let mut map: BTreeMap<SendStr, uint> = BTreeMap::new();"}, {"sha": "7e0f60d55a827acb3dbfff0b0e28408c1ce8b90f", "filename": "src/test/run-pass/traits-issue-22019.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-pass%2Ftraits-issue-22019.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdbd288ac0606902885434e1ccd8d8bde68913d/src%2Ftest%2Frun-pass%2Ftraits-issue-22019.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-issue-22019.rs?ref=2cdbd288ac0606902885434e1ccd8d8bde68913d", "patch": "@@ -23,18 +23,18 @@ pub type Node<'a> = &'a CFGNode;\n \n pub trait GraphWalk<'c, N> {\n     /// Returns all the nodes in this graph.\n-    fn nodes(&'c self) where [N]:ToOwned<Vec<N>>;\n+    fn nodes(&'c self) where [N]:ToOwned<Owned=Vec<N>>;\n }\n \n impl<'g> GraphWalk<'g, Node<'g>> for u32\n {\n-    fn nodes(&'g self) where [Node<'g>]:ToOwned<Vec<Node<'g>>>\n+    fn nodes(&'g self) where [Node<'g>]:ToOwned<Owned=Vec<Node<'g>>>\n     { loop { } }\n }\n \n impl<'h> GraphWalk<'h, Node<'h>> for u64\n {\n-    fn nodes(&'h self) where [Node<'h>]:ToOwned<Vec<Node<'h>>>\n+    fn nodes(&'h self) where [Node<'h>]:ToOwned<Owned=Vec<Node<'h>>>\n     { loop { } }\n }\n "}]}