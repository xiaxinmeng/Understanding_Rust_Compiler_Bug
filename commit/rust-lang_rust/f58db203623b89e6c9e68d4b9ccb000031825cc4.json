{"sha": "f58db203623b89e6c9e68d4b9ccb000031825cc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1OGRiMjAzNjIzYjg5ZTZjOWU2OGQ0YjljY2IwMDAwMzE4MjVjYzQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-09T06:52:01Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-11T06:42:26Z"}, "message": "move rustc::lint::{context, passes} to rustc_lint.\n\nAlso do some cleanup of the interface.", "tree": {"sha": "5f389a610a9d98b435d502f3b1b89fc32b577c56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f389a610a9d98b435d502f3b1b89fc32b577c56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f58db203623b89e6c9e68d4b9ccb000031825cc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f58db203623b89e6c9e68d4b9ccb000031825cc4", "html_url": "https://github.com/rust-lang/rust/commit/f58db203623b89e6c9e68d4b9ccb000031825cc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f58db203623b89e6c9e68d4b9ccb000031825cc4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c12c424e28beb9bf69df8ca0f68096d8b9a6a21", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c12c424e28beb9bf69df8ca0f68096d8b9a6a21", "html_url": "https://github.com/rust-lang/rust/commit/8c12c424e28beb9bf69df8ca0f68096d8b9a6a21"}], "stats": {"total": 1018, "additions": 505, "deletions": 513}, "files": [{"sha": "0008a4a361531928aadb1ae4caeccf28daa1af8f", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -3789,6 +3789,7 @@ dependencies = [\n  \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_span\",\n  \"syntax\","}, {"sha": "ef22c6621ae2c7e3254dd4874631547d3cbd9222", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -72,8 +72,6 @@ extern crate rustc_data_structures;\n #[macro_use]\n extern crate log;\n #[macro_use]\n-extern crate syntax;\n-#[macro_use]\n extern crate smallvec;\n \n #[cfg(test)]"}, {"sha": "2ed6cd5283b10c3ab3e9dc96412d63ecb0031eae", "filename": "src/librustc/lint.rs", "status": "modified", "additions": 49, "deletions": 394, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -1,30 +1,15 @@\n use std::cmp;\n \n use crate::ich::StableHashingContext;\n-use crate::lint::context::CheckLintNameResult;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{pluralize, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_hir::HirId;\n pub use rustc_session::lint::{builtin, Level, Lint, LintId, LintPass};\n use rustc_session::{DiagnosticMessageId, Session};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::print::pprust;\n-use syntax::sess::feature_err;\n-\n-use rustc_error_codes::*;\n-\n-mod context;\n-mod passes;\n-\n-pub use context::add_elided_lifetime_in_path_suggestion;\n-pub use context::{EarlyContext, LateContext, LintContext, LintStore};\n-pub use passes::{EarlyLintPass, EarlyLintPassObject, LateLintPass, LateLintPassObject};\n+use rustc_span::{Span, Symbol};\n \n /// How a lint level was set.\n #[derive(Clone, Copy, PartialEq, Eq, HashStable)]\n@@ -43,11 +28,11 @@ pub enum LintSource {\n pub type LevelSource = (Level, LintSource);\n \n pub struct LintLevelSets {\n-    list: Vec<LintSet>,\n-    lint_cap: Level,\n+    pub list: Vec<LintSet>,\n+    pub lint_cap: Level,\n }\n \n-enum LintSet {\n+pub enum LintSet {\n     CommandLine {\n         // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n         // flag.\n@@ -133,381 +118,9 @@ impl LintLevelSets {\n     }\n }\n \n-pub struct LintLevelsBuilder<'a> {\n-    sess: &'a Session,\n-    sets: LintLevelSets,\n-    id_to_set: FxHashMap<HirId, u32>,\n-    cur: u32,\n-    warn_about_weird_lints: bool,\n-}\n-\n-pub struct BuilderPush {\n-    prev: u32,\n-    pub changed: bool,\n-}\n-\n-impl<'a> LintLevelsBuilder<'a> {\n-    pub fn new(sess: &'a Session, warn_about_weird_lints: bool, store: &LintStore) -> Self {\n-        let mut builder = LintLevelsBuilder {\n-            sess,\n-            sets: LintLevelSets::new(),\n-            cur: 0,\n-            id_to_set: Default::default(),\n-            warn_about_weird_lints,\n-        };\n-        builder.process_command_line(sess, store);\n-        assert_eq!(builder.sets.list.len(), 1);\n-        builder\n-    }\n-\n-    fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n-        let mut specs = FxHashMap::default();\n-        self.sets.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n-\n-        for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            store.check_lint_name_cmdline(sess, &lint_name, level);\n-\n-            // If the cap is less than this specified level, e.g., if we've got\n-            // `--cap-lints allow` but we've also got `-D foo` then we ignore\n-            // this specification as the lint cap will set it to allow anyway.\n-            let level = cmp::min(level, self.sets.lint_cap);\n-\n-            let lint_flag_val = Symbol::intern(lint_name);\n-            let ids = match store.find_lints(&lint_name) {\n-                Ok(ids) => ids,\n-                Err(_) => continue, // errors handled in check_lint_name_cmdline above\n-            };\n-            for id in ids {\n-                let src = LintSource::CommandLine(lint_flag_val);\n-                specs.insert(id, (level, src));\n-            }\n-        }\n-\n-        self.sets.list.push(LintSet::CommandLine { specs });\n-    }\n-\n-    /// Pushes a list of AST lint attributes onto this context.\n-    ///\n-    /// This function will return a `BuilderPush` object which should be passed\n-    /// to `pop` when this scope for the attributes provided is exited.\n-    ///\n-    /// This function will perform a number of tasks:\n-    ///\n-    /// * It'll validate all lint-related attributes in `attrs`\n-    /// * It'll mark all lint-related attributes as used\n-    /// * Lint levels will be updated based on the attributes provided\n-    /// * Lint attributes are validated, e.g., a #[forbid] can't be switched to\n-    ///   #[allow]\n-    ///\n-    /// Don't forget to call `pop`!\n-    pub fn push(&mut self, attrs: &[ast::Attribute], store: &LintStore) -> BuilderPush {\n-        let mut specs = FxHashMap::default();\n-        let sess = self.sess;\n-        let bad_attr = |span| struct_span_err!(sess, span, E0452, \"malformed lint attribute input\");\n-        for attr in attrs {\n-            let level = match Level::from_symbol(attr.name_or_empty()) {\n-                None => continue,\n-                Some(lvl) => lvl,\n-            };\n-\n-            let meta = unwrap_or!(attr.meta(), continue);\n-            attr::mark_used(attr);\n-\n-            let mut metas = unwrap_or!(meta.meta_item_list(), continue);\n-\n-            if metas.is_empty() {\n-                // FIXME (#55112): issue unused-attributes lint for `#[level()]`\n-                continue;\n-            }\n-\n-            // Before processing the lint names, look for a reason (RFC 2383)\n-            // at the end.\n-            let mut reason = None;\n-            let tail_li = &metas[metas.len() - 1];\n-            if let Some(item) = tail_li.meta_item() {\n-                match item.kind {\n-                    ast::MetaItemKind::Word => {} // actual lint names handled later\n-                    ast::MetaItemKind::NameValue(ref name_value) => {\n-                        if item.path == sym::reason {\n-                            // found reason, reslice meta list to exclude it\n-                            metas = &metas[0..metas.len() - 1];\n-                            // FIXME (#55112): issue unused-attributes lint if we thereby\n-                            // don't have any lint names (`#[level(reason = \"foo\")]`)\n-                            if let ast::LitKind::Str(rationale, _) = name_value.kind {\n-                                if !self.sess.features_untracked().lint_reasons {\n-                                    feature_err(\n-                                        &self.sess.parse_sess,\n-                                        sym::lint_reasons,\n-                                        item.span,\n-                                        \"lint reasons are experimental\",\n-                                    )\n-                                    .emit();\n-                                }\n-                                reason = Some(rationale);\n-                            } else {\n-                                bad_attr(name_value.span)\n-                                    .span_label(name_value.span, \"reason must be a string literal\")\n-                                    .emit();\n-                            }\n-                        } else {\n-                            bad_attr(item.span)\n-                                .span_label(item.span, \"bad attribute argument\")\n-                                .emit();\n-                        }\n-                    }\n-                    ast::MetaItemKind::List(_) => {\n-                        bad_attr(item.span).span_label(item.span, \"bad attribute argument\").emit();\n-                    }\n-                }\n-            }\n-\n-            for li in metas {\n-                let meta_item = match li.meta_item() {\n-                    Some(meta_item) if meta_item.is_word() => meta_item,\n-                    _ => {\n-                        let sp = li.span();\n-                        let mut err = bad_attr(sp);\n-                        let mut add_label = true;\n-                        if let Some(item) = li.meta_item() {\n-                            if let ast::MetaItemKind::NameValue(_) = item.kind {\n-                                if item.path == sym::reason {\n-                                    err.span_label(sp, \"reason in lint attribute must come last\");\n-                                    add_label = false;\n-                                }\n-                            }\n-                        }\n-                        if add_label {\n-                            err.span_label(sp, \"bad attribute argument\");\n-                        }\n-                        err.emit();\n-                        continue;\n-                    }\n-                };\n-                let tool_name = if meta_item.path.segments.len() > 1 {\n-                    let tool_ident = meta_item.path.segments[0].ident;\n-                    if !attr::is_known_lint_tool(tool_ident) {\n-                        struct_span_err!(\n-                            sess,\n-                            tool_ident.span,\n-                            E0710,\n-                            \"an unknown tool name found in scoped lint: `{}`\",\n-                            pprust::path_to_string(&meta_item.path),\n-                        )\n-                        .emit();\n-                        continue;\n-                    }\n-\n-                    Some(tool_ident.name)\n-                } else {\n-                    None\n-                };\n-                let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n-                match store.check_lint_name(&name.as_str(), tool_name) {\n-                    CheckLintNameResult::Ok(ids) => {\n-                        let src = LintSource::Node(name, li.span(), reason);\n-                        for id in ids {\n-                            specs.insert(*id, (level, src));\n-                        }\n-                    }\n-\n-                    CheckLintNameResult::Tool(result) => {\n-                        match result {\n-                            Ok(ids) => {\n-                                let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n-                                let src = LintSource::Node(\n-                                    Symbol::intern(complete_name),\n-                                    li.span(),\n-                                    reason,\n-                                );\n-                                for id in ids {\n-                                    specs.insert(*id, (level, src));\n-                                }\n-                            }\n-                            Err((Some(ids), new_lint_name)) => {\n-                                let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                                let (lvl, src) =\n-                                    self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n-                                let msg = format!(\n-                                    \"lint name `{}` is deprecated \\\n-                                     and may not have an effect in the future. \\\n-                                     Also `cfg_attr(cargo-clippy)` won't be necessary anymore\",\n-                                    name\n-                                );\n-                                struct_lint_level(\n-                                    self.sess,\n-                                    lint,\n-                                    lvl,\n-                                    src,\n-                                    Some(li.span().into()),\n-                                    &msg,\n-                                )\n-                                .span_suggestion(\n-                                    li.span(),\n-                                    \"change it to\",\n-                                    new_lint_name.to_string(),\n-                                    Applicability::MachineApplicable,\n-                                )\n-                                .emit();\n-\n-                                let src = LintSource::Node(\n-                                    Symbol::intern(&new_lint_name),\n-                                    li.span(),\n-                                    reason,\n-                                );\n-                                for id in ids {\n-                                    specs.insert(*id, (level, src));\n-                                }\n-                            }\n-                            Err((None, _)) => {\n-                                // If Tool(Err(None, _)) is returned, then either the lint does not\n-                                // exist in the tool or the code was not compiled with the tool and\n-                                // therefore the lint was never added to the `LintStore`. To detect\n-                                // this is the responsibility of the lint tool.\n-                            }\n-                        }\n-                    }\n-\n-                    _ if !self.warn_about_weird_lints => {}\n-\n-                    CheckLintNameResult::Warning(msg, renamed) => {\n-                        let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                        let (level, src) =\n-                            self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n-                        let mut err = struct_lint_level(\n-                            self.sess,\n-                            lint,\n-                            level,\n-                            src,\n-                            Some(li.span().into()),\n-                            &msg,\n-                        );\n-                        if let Some(new_name) = renamed {\n-                            err.span_suggestion(\n-                                li.span(),\n-                                \"use the new name\",\n-                                new_name,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        err.emit();\n-                    }\n-                    CheckLintNameResult::NoLint(suggestion) => {\n-                        let lint = builtin::UNKNOWN_LINTS;\n-                        let (level, src) =\n-                            self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n-                        let msg = format!(\"unknown lint: `{}`\", name);\n-                        let mut db = struct_lint_level(\n-                            self.sess,\n-                            lint,\n-                            level,\n-                            src,\n-                            Some(li.span().into()),\n-                            &msg,\n-                        );\n-\n-                        if let Some(suggestion) = suggestion {\n-                            db.span_suggestion(\n-                                li.span(),\n-                                \"did you mean\",\n-                                suggestion.to_string(),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-\n-                        db.emit();\n-                    }\n-                }\n-            }\n-        }\n-\n-        for (id, &(level, ref src)) in specs.iter() {\n-            if level == Level::Forbid {\n-                continue;\n-            }\n-            let forbid_src = match self.sets.get_lint_id_level(*id, self.cur, None) {\n-                (Some(Level::Forbid), src) => src,\n-                _ => continue,\n-            };\n-            let forbidden_lint_name = match forbid_src {\n-                LintSource::Default => id.to_string(),\n-                LintSource::Node(name, _, _) => name.to_string(),\n-                LintSource::CommandLine(name) => name.to_string(),\n-            };\n-            let (lint_attr_name, lint_attr_span) = match *src {\n-                LintSource::Node(name, span, _) => (name, span),\n-                _ => continue,\n-            };\n-            let mut diag_builder = struct_span_err!(\n-                self.sess,\n-                lint_attr_span,\n-                E0453,\n-                \"{}({}) overruled by outer forbid({})\",\n-                level.as_str(),\n-                lint_attr_name,\n-                forbidden_lint_name\n-            );\n-            diag_builder.span_label(lint_attr_span, \"overruled by previous forbid\");\n-            match forbid_src {\n-                LintSource::Default => {}\n-                LintSource::Node(_, forbid_source_span, reason) => {\n-                    diag_builder.span_label(forbid_source_span, \"`forbid` level set here\");\n-                    if let Some(rationale) = reason {\n-                        diag_builder.note(&rationale.as_str());\n-                    }\n-                }\n-                LintSource::CommandLine(_) => {\n-                    diag_builder.note(\"`forbid` lint level was set on command line\");\n-                }\n-            }\n-            diag_builder.emit();\n-            // don't set a separate error for every lint in the group\n-            break;\n-        }\n-\n-        let prev = self.cur;\n-        if specs.len() > 0 {\n-            self.cur = self.sets.list.len() as u32;\n-            self.sets.list.push(LintSet::Node { specs: specs, parent: prev });\n-        }\n-\n-        BuilderPush { prev: prev, changed: prev != self.cur }\n-    }\n-\n-    /// Called after `push` when the scope of a set of attributes are exited.\n-    pub fn pop(&mut self, push: BuilderPush) {\n-        self.cur = push.prev;\n-    }\n-\n-    /// Used to emit a lint-related diagnostic based on the current state of\n-    /// this lint context.\n-    pub fn struct_lint(\n-        &self,\n-        lint: &'static Lint,\n-        span: Option<MultiSpan>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'a> {\n-        let (level, src) = self.sets.get_lint_level(lint, self.cur, None, self.sess);\n-        struct_lint_level(self.sess, lint, level, src, span, msg)\n-    }\n-\n-    /// Registers the ID provided with the current set of lints stored in\n-    /// this context.\n-    pub fn register_id(&mut self, id: HirId) {\n-        self.id_to_set.insert(id, self.cur);\n-    }\n-\n-    pub fn build(self) -> LintLevelSets {\n-        self.sets\n-    }\n-\n-    pub fn build_map(self) -> LintLevelMap {\n-        LintLevelMap { sets: self.sets, id_to_set: self.id_to_set }\n-    }\n-}\n-\n pub struct LintLevelMap {\n-    sets: LintLevelSets,\n-    id_to_set: FxHashMap<HirId, u32>,\n+    pub sets: LintLevelSets,\n+    pub id_to_set: FxHashMap<HirId, u32>,\n }\n \n impl LintLevelMap {\n@@ -712,3 +325,45 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n         ExpnKind::Macro(..) => true, // definitely a plugin\n     }\n }\n+\n+pub fn add_elided_lifetime_in_path_suggestion(\n+    sess: &Session,\n+    db: &mut DiagnosticBuilder<'_>,\n+    n: usize,\n+    path_span: Span,\n+    incl_angl_brckt: bool,\n+    insertion_span: Span,\n+    anon_lts: String,\n+) {\n+    let (replace_span, suggestion) = if incl_angl_brckt {\n+        (insertion_span, anon_lts)\n+    } else {\n+        // When possible, prefer a suggestion that replaces the whole\n+        // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n+        // at a point (which makes for an ugly/confusing label)\n+        if let Ok(snippet) = sess.source_map().span_to_snippet(path_span) {\n+            // But our spans can get out of whack due to macros; if the place we think\n+            // we want to insert `'_` isn't even within the path expression's span, we\n+            // should bail out of making any suggestion rather than panicking on a\n+            // subtract-with-overflow or string-slice-out-out-bounds (!)\n+            // FIXME: can we do better?\n+            if insertion_span.lo().0 < path_span.lo().0 {\n+                return;\n+            }\n+            let insertion_index = (insertion_span.lo().0 - path_span.lo().0) as usize;\n+            if insertion_index > snippet.len() {\n+                return;\n+            }\n+            let (before, after) = snippet.split_at(insertion_index);\n+            (path_span, format!(\"{}{}{}\", before, anon_lts, after))\n+        } else {\n+            (insertion_span, anon_lts)\n+        }\n+    };\n+    db.span_suggestion(\n+        replace_span,\n+        &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n+        suggestion,\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "d30d0bd8345fff22d2f00f3e77f1db27567b8166", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -37,7 +37,6 @@ use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n use rustc::hir::map::definitions::{DefKey, DefPathData, Definitions};\n use rustc::hir::map::Map;\n-use rustc::lint::builtin;\n use rustc::{bug, span_bug};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n@@ -51,7 +50,7 @@ use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ParamName};\n use rustc_index::vec::IndexVec;\n use rustc_session::config::nightly_options;\n-use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n+use rustc_session::lint::{builtin, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::node_id::NodeMap;\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnId;"}, {"sha": "072b85d716d74d17367f2e668fc1d1762f35bc52", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -23,9 +23,7 @@ extern crate lazy_static;\n \n pub extern crate rustc_plugin_impl as plugin;\n \n-//use rustc_resolve as resolve;\n-use rustc::lint;\n-use rustc::lint::Lint;\n+use rustc::lint::{Lint, LintId};\n use rustc::middle::cstore::MetadataLoader;\n use rustc::session::config::nightly_options;\n use rustc::session::config::{ErrorOutputType, Input, OutputType, PrintRequest};\n@@ -41,6 +39,7 @@ use rustc_feature::{find_gated_cfg, UnstableFeatures};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::util::get_builtin_codegen_backend;\n use rustc_interface::{interface, Queries};\n+use rustc_lint::LintStore;\n use rustc_metadata::locator;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n@@ -811,7 +810,7 @@ the command line flag directly.\n     );\n }\n \n-fn describe_lints(sess: &Session, lint_store: &lint::LintStore, loaded_plugins: bool) {\n+fn describe_lints(sess: &Session, lint_store: &LintStore, loaded_plugins: bool) {\n     println!(\n         \"\n Available lint options:\n@@ -832,8 +831,8 @@ Available lint options:\n     }\n \n     fn sort_lint_groups(\n-        lints: Vec<(&'static str, Vec<lint::LintId>, bool)>,\n-    ) -> Vec<(&'static str, Vec<lint::LintId>)> {\n+        lints: Vec<(&'static str, Vec<LintId>, bool)>,\n+    ) -> Vec<(&'static str, Vec<LintId>)> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n         lints.sort_by_key(|l| l.0);\n         lints\n@@ -892,7 +891,7 @@ Available lint options:\n     println!(\"    {}  {}\", padded(\"----\"), \"---------\");\n     println!(\"    {}  {}\", padded(\"warnings\"), \"all lints that are set to issue warnings\");\n \n-    let print_lint_groups = |lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n+    let print_lint_groups = |lints: Vec<(&'static str, Vec<LintId>)>| {\n         for (name, to) in lints {\n             let name = name.to_lowercase().replace(\"_\", \"-\");\n             let desc = to"}, {"sha": "9cd9eb66cf6c1f0b304385a0ec22323790c53b0f", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -12,6 +12,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n+use rustc_lint::LintStore;\n use rustc_parse::new_parser_from_source_str;\n use rustc_span::edition;\n use rustc_span::source_map::{FileLoader, FileName, SourceMap};\n@@ -36,7 +37,7 @@ pub struct Compiler {\n     pub(crate) output_dir: Option<PathBuf>,\n     pub(crate) output_file: Option<PathBuf>,\n     pub(crate) crate_name: Option<String>,\n-    pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n+    pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut LintStore) + Send + Sync>>,\n     pub(crate) override_queries:\n         Option<fn(&Session, &mut ty::query::Providers<'_>, &mut ty::query::Providers<'_>)>,\n }\n@@ -136,7 +137,7 @@ pub struct Config {\n     ///\n     /// Note that if you find a Some here you probably want to call that function in the new\n     /// function being registered.\n-    pub register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n+    pub register_lints: Option<Box<dyn Fn(&Session, &mut LintStore) + Send + Sync>>,\n \n     /// This is a callback from the driver that is called just after we have populated\n     /// the list of queries."}, {"sha": "67f9819f3314d6c280f3e11f03b596d35e59497f", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -27,6 +27,7 @@ use rustc_errors::PResult;\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental;\n+use rustc_lint::LintStore;\n use rustc_mir as mir;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, hir_stats, layout_test};\n@@ -100,7 +101,7 @@ declare_box_region_type!(\n /// Returns `None` if we're aborting after handling -W help.\n pub fn configure_and_expand(\n     sess: Lrc<Session>,\n-    lint_store: Lrc<lint::LintStore>,\n+    lint_store: Lrc<LintStore>,\n     metadata_loader: Box<MetadataLoaderDyn>,\n     krate: ast::Crate,\n     crate_name: &str,\n@@ -150,10 +151,10 @@ impl BoxedResolver {\n pub fn register_plugins<'a>(\n     sess: &'a Session,\n     metadata_loader: &'a dyn MetadataLoader,\n-    register_lints: impl Fn(&Session, &mut lint::LintStore),\n+    register_lints: impl Fn(&Session, &mut LintStore),\n     mut krate: ast::Crate,\n     crate_name: &str,\n-) -> Result<(ast::Crate, Lrc<lint::LintStore>)> {\n+) -> Result<(ast::Crate, Lrc<LintStore>)> {\n     krate = sess.time(\"attributes_injection\", || {\n         rustc_builtin_macros::cmdline_attrs::inject(\n             krate,\n@@ -214,7 +215,7 @@ pub fn register_plugins<'a>(\n \n fn configure_and_expand_inner<'a>(\n     sess: &'a Session,\n-    lint_store: &'a lint::LintStore,\n+    lint_store: &'a LintStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n     resolver_arenas: &'a ResolverArenas<'a>,\n@@ -420,7 +421,7 @@ fn configure_and_expand_inner<'a>(\n \n pub fn lower_to_hir<'res, 'tcx>(\n     sess: &'tcx Session,\n-    lint_store: &lint::LintStore,\n+    lint_store: &LintStore,\n     resolver: &'res mut Resolver<'_>,\n     dep_graph: &'res DepGraph,\n     krate: &'res ast::Crate,\n@@ -705,7 +706,7 @@ impl<'tcx> QueryContext<'tcx> {\n \n pub fn create_global_ctxt<'tcx>(\n     compiler: &'tcx Compiler,\n-    lint_store: Lrc<lint::LintStore>,\n+    lint_store: Lrc<LintStore>,\n     hir_forest: &'tcx map::Forest<'tcx>,\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,"}, {"sha": "bd9717d3f3d0253bb6b158244821460b6cfd371b", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -4,8 +4,6 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n use rustc::hir::map;\n-use rustc::lint;\n-use rustc::lint::LintStore;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::session::Session;\n use rustc::ty::steal::Steal;\n@@ -15,6 +13,7 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_incremental::DepGraphFuture;\n+use rustc_lint::LintStore;\n use std::any::Any;\n use std::cell::{Ref, RefCell, RefMut};\n use std::mem;\n@@ -133,7 +132,7 @@ impl<'tcx> Queries<'tcx> {\n             let crate_name = self.crate_name()?.peek().clone();\n             let krate = self.parse()?.take();\n \n-            let empty: &(dyn Fn(&Session, &mut lint::LintStore) + Sync + Send) = &|_, _| {};\n+            let empty: &(dyn Fn(&Session, &mut LintStore) + Sync + Send) = &|_, _| {};\n             let result = passes::register_plugins(\n                 self.session(),\n                 &*self.codegen_backend().metadata_loader(),"}, {"sha": "fb11b6771e9caceec027973e4b905751b3330c98", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::{LateContext, LateLintPass, LintContext};\n+use crate::{LateContext, LateLintPass, LintContext};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment};\n use rustc_errors::Applicability;"}, {"sha": "15a8332a28492e1f432062f52c31d1268fdb8ed2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -21,8 +21,8 @@\n //! If you define a new `LateLintPass`, you will also need to add it to the\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n+use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::hir::map::Map;\n-use rustc::lint::{self, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::traits::misc::can_type_implement_copy;\n use rustc::ty::{self, layout::VariantIdx, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n@@ -51,7 +51,7 @@ use log::debug;\n use std::fmt::Write;\n \n // hardwired lints from librustc\n-pub use lint::builtin::*;\n+pub use rustc_session::lint::builtin::*;\n \n declare_lint! {\n     WHILE_TRUE,"}, {"sha": "2b514c301f2a3890a6765c845e7f5950d104313a", "filename": "src/librustc_lint/context.rs", "status": "renamed", "additions": 9, "deletions": 50, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -16,17 +16,18 @@\n \n use self::TargetLint::*;\n \n-use crate::hir::map::definitions::{DefPathData, DisambiguatedDefPathData};\n-use crate::lint::passes::{EarlyLintPassObject, LateLintPassObject};\n-use crate::lint::LintLevelsBuilder;\n-use crate::middle::privacy::AccessLevels;\n-use crate::middle::stability;\n-use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n-use crate::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n+use crate::levels::LintLevelsBuilder;\n+use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n+use rustc::hir::map::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc::lint::add_elided_lifetime_in_path_suggestion;\n+use rustc::middle::privacy::AccessLevels;\n+use rustc::middle::stability;\n+use rustc::ty::layout::{LayoutError, LayoutOf, TyLayout};\n+use rustc::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n use rustc_error_codes::*;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -467,48 +468,6 @@ impl LintPassObject for EarlyLintPassObject {}\n \n impl LintPassObject for LateLintPassObject {}\n \n-pub fn add_elided_lifetime_in_path_suggestion(\n-    sess: &Session,\n-    db: &mut DiagnosticBuilder<'_>,\n-    n: usize,\n-    path_span: Span,\n-    incl_angl_brckt: bool,\n-    insertion_span: Span,\n-    anon_lts: String,\n-) {\n-    let (replace_span, suggestion) = if incl_angl_brckt {\n-        (insertion_span, anon_lts)\n-    } else {\n-        // When possible, prefer a suggestion that replaces the whole\n-        // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n-        // at a point (which makes for an ugly/confusing label)\n-        if let Ok(snippet) = sess.source_map().span_to_snippet(path_span) {\n-            // But our spans can get out of whack due to macros; if the place we think\n-            // we want to insert `'_` isn't even within the path expression's span, we\n-            // should bail out of making any suggestion rather than panicking on a\n-            // subtract-with-overflow or string-slice-out-out-bounds (!)\n-            // FIXME: can we do better?\n-            if insertion_span.lo().0 < path_span.lo().0 {\n-                return;\n-            }\n-            let insertion_index = (insertion_span.lo().0 - path_span.lo().0) as usize;\n-            if insertion_index > snippet.len() {\n-                return;\n-            }\n-            let (before, after) = snippet.split_at(insertion_index);\n-            (path_span, format!(\"{}{}{}\", before, anon_lts, after))\n-        } else {\n-            (insertion_span, anon_lts)\n-        }\n-    };\n-    db.span_suggestion(\n-        replace_span,\n-        &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n-        suggestion,\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n pub trait LintContext: Sized {\n     type PassObject: LintPassObject;\n ", "previous_filename": "src/librustc/lint/context.rs"}, {"sha": "490114b2d4d2a037d84793042d36efe05dd5df80", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -14,10 +14,9 @@\n //! upon. As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n \n-use rustc::lint::{EarlyContext, LintStore};\n-use rustc::lint::{EarlyLintPass, EarlyLintPassObject};\n-use rustc::lint::{LintContext, LintPass};\n-use rustc_session::lint::LintBuffer;\n+use crate::context::{EarlyContext, LintContext, LintStore};\n+use crate::passes::{EarlyLintPass, EarlyLintPassObject};\n+use rustc_session::lint::{LintBuffer, LintPass};\n use rustc_session::Session;\n use rustc_span::Span;\n use syntax::ast;\n@@ -291,7 +290,7 @@ macro_rules! early_lint_pass_impl {\n     )\n }\n \n-early_lint_methods!(early_lint_pass_impl, []);\n+crate::early_lint_methods!(early_lint_pass_impl, []);\n \n fn early_lint_crate<T: EarlyLintPass>(\n     sess: &Session,"}, {"sha": "2f8393bd906c0e0f9bdfea87072deec9dbe30ecb", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -1,8 +1,7 @@\n //! Some lints that are only useful in the compiler or crates that use compiler internals, such as\n //! Clippy.\n \n-use crate::lint::{EarlyContext, LateContext, LintContext};\n-use crate::lint::{EarlyLintPass, LateLintPass};\n+use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::{GenericArg, HirId, MutTy, Mutability, Path, PathSegment, QPath, Ty, TyKind};"}, {"sha": "eb5f89c9507d380cd928e1393d2d8eacd6521818", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -14,8 +14,8 @@\n //! upon. As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n \n+use crate::{passes::LateLintPassObject, LateContext, LateLintPass, LintStore};\n use rustc::hir::map::Map;\n-use rustc::lint::{LateContext, LateLintPass, LateLintPassObject, LintStore};\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n use rustc_hir as hir;\n@@ -347,7 +347,7 @@ macro_rules! late_lint_pass_impl {\n     )\n }\n \n-late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n+crate::late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n \n fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "bbc3e57f5dd01a38683395b1906e4b88a769c5ba", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 388, "deletions": 3, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -1,14 +1,27 @@\n-use super::late::unerased_lint_store;\n+use crate::context::{CheckLintNameResult, LintStore};\n+use crate::late::unerased_lint_store;\n use rustc::hir::map::Map;\n-use rustc::lint::{LintLevelMap, LintLevelsBuilder, LintStore};\n+use rustc::lint::struct_lint_level;\n+use rustc::lint::{LintLevelMap, LintLevelSets, LintSet, LintSource};\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_error_codes::*;\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc_hir::hir_id::HirId;\n use rustc_hir::intravisit;\n+use rustc_session::lint::{builtin, Level, Lint};\n+use rustc_session::Session;\n+use rustc_span::{sym, MultiSpan, Symbol};\n use syntax::ast;\n+use syntax::attr;\n+use syntax::print::pprust;\n+use syntax::sess::feature_err;\n+use syntax::unwrap_or;\n \n-pub use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintId};\n+use std::cmp;\n \n fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n@@ -28,6 +41,378 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     tcx.arena.alloc(builder.levels.build_map())\n }\n \n+pub struct LintLevelsBuilder<'a> {\n+    sess: &'a Session,\n+    sets: LintLevelSets,\n+    id_to_set: FxHashMap<HirId, u32>,\n+    cur: u32,\n+    warn_about_weird_lints: bool,\n+}\n+\n+pub struct BuilderPush {\n+    prev: u32,\n+    pub changed: bool,\n+}\n+\n+impl<'a> LintLevelsBuilder<'a> {\n+    pub fn new(sess: &'a Session, warn_about_weird_lints: bool, store: &LintStore) -> Self {\n+        let mut builder = LintLevelsBuilder {\n+            sess,\n+            sets: LintLevelSets::new(),\n+            cur: 0,\n+            id_to_set: Default::default(),\n+            warn_about_weird_lints,\n+        };\n+        builder.process_command_line(sess, store);\n+        assert_eq!(builder.sets.list.len(), 1);\n+        builder\n+    }\n+\n+    fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n+        let mut specs = FxHashMap::default();\n+        self.sets.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n+\n+        for &(ref lint_name, level) in &sess.opts.lint_opts {\n+            store.check_lint_name_cmdline(sess, &lint_name, level);\n+\n+            // If the cap is less than this specified level, e.g., if we've got\n+            // `--cap-lints allow` but we've also got `-D foo` then we ignore\n+            // this specification as the lint cap will set it to allow anyway.\n+            let level = cmp::min(level, self.sets.lint_cap);\n+\n+            let lint_flag_val = Symbol::intern(lint_name);\n+            let ids = match store.find_lints(&lint_name) {\n+                Ok(ids) => ids,\n+                Err(_) => continue, // errors handled in check_lint_name_cmdline above\n+            };\n+            for id in ids {\n+                let src = LintSource::CommandLine(lint_flag_val);\n+                specs.insert(id, (level, src));\n+            }\n+        }\n+\n+        self.sets.list.push(LintSet::CommandLine { specs });\n+    }\n+\n+    /// Pushes a list of AST lint attributes onto this context.\n+    ///\n+    /// This function will return a `BuilderPush` object which should be passed\n+    /// to `pop` when this scope for the attributes provided is exited.\n+    ///\n+    /// This function will perform a number of tasks:\n+    ///\n+    /// * It'll validate all lint-related attributes in `attrs`\n+    /// * It'll mark all lint-related attributes as used\n+    /// * Lint levels will be updated based on the attributes provided\n+    /// * Lint attributes are validated, e.g., a #[forbid] can't be switched to\n+    ///   #[allow]\n+    ///\n+    /// Don't forget to call `pop`!\n+    pub fn push(&mut self, attrs: &[ast::Attribute], store: &LintStore) -> BuilderPush {\n+        let mut specs = FxHashMap::default();\n+        let sess = self.sess;\n+        let bad_attr = |span| struct_span_err!(sess, span, E0452, \"malformed lint attribute input\");\n+        for attr in attrs {\n+            let level = match Level::from_symbol(attr.name_or_empty()) {\n+                None => continue,\n+                Some(lvl) => lvl,\n+            };\n+\n+            let meta = unwrap_or!(attr.meta(), continue);\n+            attr::mark_used(attr);\n+\n+            let mut metas = unwrap_or!(meta.meta_item_list(), continue);\n+\n+            if metas.is_empty() {\n+                // FIXME (#55112): issue unused-attributes lint for `#[level()]`\n+                continue;\n+            }\n+\n+            // Before processing the lint names, look for a reason (RFC 2383)\n+            // at the end.\n+            let mut reason = None;\n+            let tail_li = &metas[metas.len() - 1];\n+            if let Some(item) = tail_li.meta_item() {\n+                match item.kind {\n+                    ast::MetaItemKind::Word => {} // actual lint names handled later\n+                    ast::MetaItemKind::NameValue(ref name_value) => {\n+                        if item.path == sym::reason {\n+                            // found reason, reslice meta list to exclude it\n+                            metas = &metas[0..metas.len() - 1];\n+                            // FIXME (#55112): issue unused-attributes lint if we thereby\n+                            // don't have any lint names (`#[level(reason = \"foo\")]`)\n+                            if let ast::LitKind::Str(rationale, _) = name_value.kind {\n+                                if !self.sess.features_untracked().lint_reasons {\n+                                    feature_err(\n+                                        &self.sess.parse_sess,\n+                                        sym::lint_reasons,\n+                                        item.span,\n+                                        \"lint reasons are experimental\",\n+                                    )\n+                                    .emit();\n+                                }\n+                                reason = Some(rationale);\n+                            } else {\n+                                bad_attr(name_value.span)\n+                                    .span_label(name_value.span, \"reason must be a string literal\")\n+                                    .emit();\n+                            }\n+                        } else {\n+                            bad_attr(item.span)\n+                                .span_label(item.span, \"bad attribute argument\")\n+                                .emit();\n+                        }\n+                    }\n+                    ast::MetaItemKind::List(_) => {\n+                        bad_attr(item.span).span_label(item.span, \"bad attribute argument\").emit();\n+                    }\n+                }\n+            }\n+\n+            for li in metas {\n+                let meta_item = match li.meta_item() {\n+                    Some(meta_item) if meta_item.is_word() => meta_item,\n+                    _ => {\n+                        let sp = li.span();\n+                        let mut err = bad_attr(sp);\n+                        let mut add_label = true;\n+                        if let Some(item) = li.meta_item() {\n+                            if let ast::MetaItemKind::NameValue(_) = item.kind {\n+                                if item.path == sym::reason {\n+                                    err.span_label(sp, \"reason in lint attribute must come last\");\n+                                    add_label = false;\n+                                }\n+                            }\n+                        }\n+                        if add_label {\n+                            err.span_label(sp, \"bad attribute argument\");\n+                        }\n+                        err.emit();\n+                        continue;\n+                    }\n+                };\n+                let tool_name = if meta_item.path.segments.len() > 1 {\n+                    let tool_ident = meta_item.path.segments[0].ident;\n+                    if !attr::is_known_lint_tool(tool_ident) {\n+                        struct_span_err!(\n+                            sess,\n+                            tool_ident.span,\n+                            E0710,\n+                            \"an unknown tool name found in scoped lint: `{}`\",\n+                            pprust::path_to_string(&meta_item.path),\n+                        )\n+                        .emit();\n+                        continue;\n+                    }\n+\n+                    Some(tool_ident.name)\n+                } else {\n+                    None\n+                };\n+                let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n+                match store.check_lint_name(&name.as_str(), tool_name) {\n+                    CheckLintNameResult::Ok(ids) => {\n+                        let src = LintSource::Node(name, li.span(), reason);\n+                        for id in ids {\n+                            specs.insert(*id, (level, src));\n+                        }\n+                    }\n+\n+                    CheckLintNameResult::Tool(result) => {\n+                        match result {\n+                            Ok(ids) => {\n+                                let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n+                                let src = LintSource::Node(\n+                                    Symbol::intern(complete_name),\n+                                    li.span(),\n+                                    reason,\n+                                );\n+                                for id in ids {\n+                                    specs.insert(*id, (level, src));\n+                                }\n+                            }\n+                            Err((Some(ids), new_lint_name)) => {\n+                                let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n+                                let (lvl, src) =\n+                                    self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n+                                let msg = format!(\n+                                    \"lint name `{}` is deprecated \\\n+                                     and may not have an effect in the future. \\\n+                                     Also `cfg_attr(cargo-clippy)` won't be necessary anymore\",\n+                                    name\n+                                );\n+                                struct_lint_level(\n+                                    self.sess,\n+                                    lint,\n+                                    lvl,\n+                                    src,\n+                                    Some(li.span().into()),\n+                                    &msg,\n+                                )\n+                                .span_suggestion(\n+                                    li.span(),\n+                                    \"change it to\",\n+                                    new_lint_name.to_string(),\n+                                    Applicability::MachineApplicable,\n+                                )\n+                                .emit();\n+\n+                                let src = LintSource::Node(\n+                                    Symbol::intern(&new_lint_name),\n+                                    li.span(),\n+                                    reason,\n+                                );\n+                                for id in ids {\n+                                    specs.insert(*id, (level, src));\n+                                }\n+                            }\n+                            Err((None, _)) => {\n+                                // If Tool(Err(None, _)) is returned, then either the lint does not\n+                                // exist in the tool or the code was not compiled with the tool and\n+                                // therefore the lint was never added to the `LintStore`. To detect\n+                                // this is the responsibility of the lint tool.\n+                            }\n+                        }\n+                    }\n+\n+                    _ if !self.warn_about_weird_lints => {}\n+\n+                    CheckLintNameResult::Warning(msg, renamed) => {\n+                        let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n+                        let (level, src) =\n+                            self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n+                        let mut err = struct_lint_level(\n+                            self.sess,\n+                            lint,\n+                            level,\n+                            src,\n+                            Some(li.span().into()),\n+                            &msg,\n+                        );\n+                        if let Some(new_name) = renamed {\n+                            err.span_suggestion(\n+                                li.span(),\n+                                \"use the new name\",\n+                                new_name,\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                        err.emit();\n+                    }\n+                    CheckLintNameResult::NoLint(suggestion) => {\n+                        let lint = builtin::UNKNOWN_LINTS;\n+                        let (level, src) =\n+                            self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n+                        let msg = format!(\"unknown lint: `{}`\", name);\n+                        let mut db = struct_lint_level(\n+                            self.sess,\n+                            lint,\n+                            level,\n+                            src,\n+                            Some(li.span().into()),\n+                            &msg,\n+                        );\n+\n+                        if let Some(suggestion) = suggestion {\n+                            db.span_suggestion(\n+                                li.span(),\n+                                \"did you mean\",\n+                                suggestion.to_string(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+\n+                        db.emit();\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (id, &(level, ref src)) in specs.iter() {\n+            if level == Level::Forbid {\n+                continue;\n+            }\n+            let forbid_src = match self.sets.get_lint_id_level(*id, self.cur, None) {\n+                (Some(Level::Forbid), src) => src,\n+                _ => continue,\n+            };\n+            let forbidden_lint_name = match forbid_src {\n+                LintSource::Default => id.to_string(),\n+                LintSource::Node(name, _, _) => name.to_string(),\n+                LintSource::CommandLine(name) => name.to_string(),\n+            };\n+            let (lint_attr_name, lint_attr_span) = match *src {\n+                LintSource::Node(name, span, _) => (name, span),\n+                _ => continue,\n+            };\n+            let mut diag_builder = struct_span_err!(\n+                self.sess,\n+                lint_attr_span,\n+                E0453,\n+                \"{}({}) overruled by outer forbid({})\",\n+                level.as_str(),\n+                lint_attr_name,\n+                forbidden_lint_name\n+            );\n+            diag_builder.span_label(lint_attr_span, \"overruled by previous forbid\");\n+            match forbid_src {\n+                LintSource::Default => {}\n+                LintSource::Node(_, forbid_source_span, reason) => {\n+                    diag_builder.span_label(forbid_source_span, \"`forbid` level set here\");\n+                    if let Some(rationale) = reason {\n+                        diag_builder.note(&rationale.as_str());\n+                    }\n+                }\n+                LintSource::CommandLine(_) => {\n+                    diag_builder.note(\"`forbid` lint level was set on command line\");\n+                }\n+            }\n+            diag_builder.emit();\n+            // don't set a separate error for every lint in the group\n+            break;\n+        }\n+\n+        let prev = self.cur;\n+        if specs.len() > 0 {\n+            self.cur = self.sets.list.len() as u32;\n+            self.sets.list.push(LintSet::Node { specs: specs, parent: prev });\n+        }\n+\n+        BuilderPush { prev: prev, changed: prev != self.cur }\n+    }\n+\n+    /// Called after `push` when the scope of a set of attributes are exited.\n+    pub fn pop(&mut self, push: BuilderPush) {\n+        self.cur = push.prev;\n+    }\n+\n+    /// Used to emit a lint-related diagnostic based on the current state of\n+    /// this lint context.\n+    pub fn struct_lint(\n+        &self,\n+        lint: &'static Lint,\n+        span: Option<MultiSpan>,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'a> {\n+        let (level, src) = self.sets.get_lint_level(lint, self.cur, None, self.sess);\n+        struct_lint_level(self.sess, lint, level, src, span, msg)\n+    }\n+\n+    /// Registers the ID provided with the current set of lints stored in\n+    /// this context.\n+    pub fn register_id(&mut self, id: HirId) {\n+        self.id_to_set.insert(id, self.cur);\n+    }\n+\n+    pub fn build(self) -> LintLevelSets {\n+        self.sets\n+    }\n+\n+    pub fn build_map(self) -> LintLevelMap {\n+        LintLevelMap { sets: self.sets, id_to_set: self.id_to_set }\n+    }\n+}\n+\n struct LintLevelMapBuilder<'a, 'tcx> {\n     levels: LintLevelsBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "93eae1d6c1ae5137669d2289aa70964a9bbb8db8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -15,6 +15,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n+#![feature(never_type)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]\n \n@@ -25,33 +26,29 @@ extern crate rustc_session;\n \n mod array_into_iter;\n pub mod builtin;\n+mod context;\n mod early;\n mod internal;\n mod late;\n mod levels;\n mod non_ascii_idents;\n mod nonstandard_style;\n+mod passes;\n mod redundant_semicolon;\n mod types;\n mod unused;\n \n-use rustc::lint;\n-use rustc::lint::builtin::{\n-    BARE_TRAIT_OBJECTS, ELIDED_LIFETIMES_IN_PATHS, EXPLICIT_OUTLIVES_REQUIREMENTS,\n-    INTRA_DOC_LINK_RESOLUTION_FAILURE, MISSING_DOC_CODE_EXAMPLES, PRIVATE_DOC_TESTS,\n-};\n-use rustc::lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_session::lint::{LintArray, LintPass};\n-\n+use rustc_session::lint::builtin::{\n+    BARE_TRAIT_OBJECTS, ELIDED_LIFETIMES_IN_PATHS, EXPLICIT_OUTLIVES_REQUIREMENTS,\n+    INTRA_DOC_LINK_RESOLUTION_FAILURE, MISSING_DOC_CODE_EXAMPLES, PRIVATE_DOC_TESTS,\n+};\n use rustc_span::Span;\n use syntax::ast;\n \n-use lint::LintId;\n-\n use array_into_iter::ArrayIntoIter;\n use builtin::*;\n use internal::*;\n@@ -61,10 +58,15 @@ use redundant_semicolon::*;\n use types::*;\n use unused::*;\n \n-/// Useful for other parts of the compiler.\n+/// Useful for other parts of the compiler / Clippy.\n pub use builtin::SoftLints;\n+pub use context::{EarlyContext, LateContext, LintContext, LintStore};\n pub use early::check_ast_crate;\n pub use late::check_crate;\n+pub use passes::{EarlyLintPass, LateLintPass};\n+pub use rustc_session::lint::Level::{self, *};\n+pub use rustc_session::lint::{BufferedEarlyLint, FutureIncompatibleInfo, Lint, LintId};\n+pub use rustc_session::lint::{LintArray, LintPass};\n \n pub fn provide(providers: &mut Providers<'_>) {\n     levels::provide(providers);\n@@ -181,8 +183,8 @@ late_lint_passes!(declare_combined_late_pass, [pub BuiltinCombinedLateLintPass])\n \n late_lint_mod_passes!(declare_combined_late_pass, [BuiltinCombinedModuleLateLintPass]);\n \n-pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> lint::LintStore {\n-    let mut lint_store = lint::LintStore::new();\n+pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> LintStore {\n+    let mut lint_store = LintStore::new();\n \n     register_builtins(&mut lint_store, no_interleave_lints);\n     if internal_lints {\n@@ -195,7 +197,7 @@ pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> lint::\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc::lint::builtin`).\n-fn register_builtins(store: &mut lint::LintStore, no_interleave_lints: bool) {\n+fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     macro_rules! add_lint_group {\n         ($name:expr, $($lint:ident),*) => (\n             store.register_group(false, $name, None, vec![$(LintId::of($lint)),*]);\n@@ -392,7 +394,7 @@ fn register_builtins(store: &mut lint::LintStore, no_interleave_lints: bool) {\n     store.register_removed(\"plugin_as_library\", \"plugins have been deprecated and retired\");\n }\n \n-fn register_internals(store: &mut lint::LintStore) {\n+fn register_internals(store: &mut LintStore) {\n     store.register_lints(&DefaultHashTypes::get_lints());\n     store.register_early_pass(|| box DefaultHashTypes::new());\n     store.register_lints(&LintPassImpl::get_lints());"}, {"sha": "3c85a1b31b2445e77e37a7533d11529c64be8718", "filename": "src/librustc_lint/non_ascii_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnon_ascii_idents.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::{EarlyContext, EarlyLintPass, LintContext};\n+use crate::{EarlyContext, EarlyLintPass, LintContext};\n use syntax::ast;\n \n declare_lint! {"}, {"sha": "a2b7884241ff7b9bbc4600aa68b64a47043b3be1", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::ty;\n use rustc_errors::Applicability;\n use rustc_hir as hir;"}, {"sha": "cb54105381fb2f37d75ffbca59f98b70bbe15fff", "filename": "src/librustc_lint/passes.rs", "status": "renamed", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fpasses.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -18,23 +18,15 @@\n //! example) requires more effort. See `emit_lint` and `GatherNodeLevels`\n //! in `context.rs`.\n \n-pub use self::Level::*;\n-pub use crate::lint::LintSource::{self, *};\n+use crate::context::{EarlyContext, LateContext};\n \n use rustc_data_structures::sync;\n use rustc_hir as hir;\n use rustc_session::lint::builtin::HardwiredLints;\n+use rustc_session::lint::LintPass;\n use rustc_span::Span;\n use syntax::ast;\n \n-pub use crate::lint::context::{\n-    add_elided_lifetime_in_path_suggestion, CheckLintNameResult, EarlyContext, LateContext,\n-    LintContext, LintStore,\n-};\n-\n-pub use rustc_session::lint::{builtin, LintArray, LintPass};\n-pub use rustc_session::lint::{BufferedEarlyLint, FutureIncompatibleInfo, Level, Lint, LintId};\n-\n #[macro_export]\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n@@ -169,6 +161,7 @@ macro_rules! declare_combined_late_lint_pass {\n             expand_combined_late_lint_pass_methods!([$($passes),*], $methods);\n         }\n \n+        #[allow(rustc::lint_pass_impl_without_macro)]\n         impl LintPass for $name {\n             fn name(&self) -> &'static str {\n                 panic!()\n@@ -296,6 +289,7 @@ macro_rules! declare_combined_early_lint_pass {\n             expand_combined_early_lint_pass_methods!([$($passes),*], $methods);\n         }\n \n+        #[allow(rustc::lint_pass_impl_without_macro)]\n         impl LintPass for $name {\n             fn name(&self) -> &'static str {\n                 panic!()", "previous_filename": "src/librustc/lint/passes.rs"}, {"sha": "21b244ad75d4e048c52233abf670497c53ac403d", "filename": "src/librustc_lint/redundant_semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fredundant_semicolon.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::{EarlyContext, EarlyLintPass, LintContext};\n+use crate::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_errors::Applicability;\n use syntax::ast::{ExprKind, Stmt, StmtKind};\n "}, {"sha": "674a82b61961c457bf68b3f092027bbc7f301f34", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -1,6 +1,6 @@\n #![allow(non_snake_case)]\n \n-use rustc::lint::{LateContext, LateLintPass, LintContext};\n+use crate::{LateContext, LateLintPass, LintContext};\n use rustc::mir::interpret::{sign_extend, truncate};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf, SizeSkeleton, VariantIdx};\n use rustc::ty::subst::SubstsRef;"}, {"sha": "26cbda3d97895bf04e5fc2a1a8907ce1f7ed3dbd", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -1,5 +1,4 @@\n-use rustc::lint::builtin::UNUSED_ATTRIBUTES;\n-use rustc::lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::ty::adjustment;\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashMap;\n@@ -8,6 +7,7 @@ use rustc_feature::{AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_session::lint::builtin::UNUSED_ATTRIBUTES;\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span};"}, {"sha": "41e6c699c340ec592b1a243ddc377b34b154a0ef", "filename": "src/librustc_plugin_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_plugin_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_plugin_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2FCargo.toml?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -14,6 +14,7 @@ doctest = false\n rustc = { path = \"../librustc\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_lint = { path = \"../librustc_lint\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n syntax = { path = \"../libsyntax\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "10712eb60b9e3bf21de86462d15a5f884b806c86", "filename": "src/librustc_plugin_impl/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_plugin_impl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58db203623b89e6c9e68d4b9ccb000031825cc4/src%2Flibrustc_plugin_impl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Flib.rs?ref=f58db203623b89e6c9e68d4b9ccb000031825cc4", "patch": "@@ -9,7 +9,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(nll)]\n \n-use rustc::lint::LintStore;\n+use rustc_lint::LintStore;\n \n pub mod build;\n pub mod load;"}]}