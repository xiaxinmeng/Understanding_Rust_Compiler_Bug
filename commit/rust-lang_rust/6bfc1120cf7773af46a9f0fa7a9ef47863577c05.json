{"sha": "6bfc1120cf7773af46a9f0fa7a9ef47863577c05", "node_id": "C_kwDOAAsO6NoAKDZiZmMxMTIwY2Y3NzczYWY0NmE5ZjBmYTdhOWVmNDc4NjM1NzdjMDU", "commit": {"author": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2022-03-08T09:37:53Z"}, "committer": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2022-03-08T09:37:53Z"}, "message": "add nop if-let expression check.\nre-design test cases as some of them are not worth the effort to check.", "tree": {"sha": "49cbdd890c0cae2be6de2f18ceb60075f7d932af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49cbdd890c0cae2be6de2f18ceb60075f7d932af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bfc1120cf7773af46a9f0fa7a9ef47863577c05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfc1120cf7773af46a9f0fa7a9ef47863577c05", "html_url": "https://github.com/rust-lang/rust/commit/6bfc1120cf7773af46a9f0fa7a9ef47863577c05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bfc1120cf7773af46a9f0fa7a9ef47863577c05/comments", "author": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db3fcf8df7269f9265e4643d4aa81f11d550e06b", "url": "https://api.github.com/repos/rust-lang/rust/commits/db3fcf8df7269f9265e4643d4aa81f11d550e06b", "html_url": "https://github.com/rust-lang/rust/commit/db3fcf8df7269f9265e4643d4aa81f11d550e06b"}], "stats": {"total": 395, "additions": 224, "deletions": 171}, "files": [{"sha": "74e7ca2d5fe1cef31324a7b2baf241f3123420b1", "filename": "clippy_lints/src/matches/nop_match.rs", "status": "modified", "additions": 73, "deletions": 22, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6bfc1120cf7773af46a9f0fa7a9ef47863577c05/clippy_lints%2Fsrc%2Fmatches%2Fnop_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfc1120cf7773af46a9f0fa7a9ef47863577c05/clippy_lints%2Fsrc%2Fmatches%2Fnop_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fnop_match.rs?ref=6bfc1120cf7773af46a9f0fa7a9ef47863577c05", "patch": "@@ -1,25 +1,13 @@\n-#![allow(unused_variables)]\n use super::NOP_MATCH;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{eq_expr_value, get_parent_expr};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{eq_expr_value, get_parent_expr, higher, is_else_clause, is_lang_ctor, peel_blocks_with_stmt};\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, Pat, PatKind, PathSegment, QPath};\n+use rustc_hir::LangItem::OptionNone;\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, Pat, PatKind, Path, PathSegment, QPath};\n use rustc_lint::LateContext;\n-\n-pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n-    if false {\n-        span_lint_and_sugg(\n-            cx,\n-            NOP_MATCH,\n-            ex.span,\n-            \"this if-let expression is unnecessary\",\n-            \"replace it with\",\n-            \"\".to_string(),\n-            Applicability::MachineApplicable,\n-        );\n-    }\n-}\n+use rustc_span::sym;\n \n pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     // This is for avoiding collision with `match_single_binding`.\n@@ -52,6 +40,70 @@ pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n     }\n }\n \n+/// Check for nop `if let` expression that assembled as unnecessary match\n+///\n+/// ```rust,ignore\n+/// if let Some(a) = option {\n+///     Some(a)\n+/// } else {\n+///     None\n+/// }\n+/// ```\n+/// OR\n+/// ```rust,ignore\n+/// if let SomeEnum::A = some_enum {\n+///     SomeEnum::A\n+/// } else if let SomeEnum::B = some_enum {\n+///     SomeEnum::B\n+/// } else {\n+///     some_enum\n+/// }\n+/// ```\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n+    if_chain! {\n+        if let Some(ref if_let) = higher::IfLet::hir(cx, ex);\n+        if !is_else_clause(cx.tcx, ex);\n+        if check_if_let(cx, if_let);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                NOP_MATCH,\n+                ex.span,\n+                \"this if-let expression is unnecessary\",\n+                \"replace it with\",\n+                snippet_with_applicability(cx, if_let.let_expr.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n+    if let Some(else_block) = if_let.if_else {\n+        if !pat_same_as_expr(if_let.let_pat, peel_blocks_with_stmt(if_let.if_then)) {\n+            return false;\n+        }\n+\n+        let else_expr = peel_blocks_with_stmt(else_block);\n+        // Recurrsively check for each `else if let` phrase,\n+        if let Some(ref nested_if_let) = higher::IfLet::hir(cx, else_expr) {\n+            return check_if_let(cx, nested_if_let);\n+        }\n+        let ret = strip_return(else_expr);\n+        let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n+        if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n+            if let ExprKind::Path(ref qpath) = ret.kind {\n+                return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n+            }\n+        } else {\n+            return eq_expr_value(cx, if_let.let_expr, ret);\n+        }\n+        return true;\n+    }\n+    false\n+}\n+\n fn strip_return<'hir>(expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n     if let ExprKind::Ret(Some(ret)) = expr.kind {\n         ret\n@@ -68,15 +120,15 @@ fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n             ExprKind::Call(call_expr, [first_param, ..]),\n         ) => {\n             if let ExprKind::Path(QPath::Resolved(_, call_path)) = call_expr.kind {\n-                if is_identical_segments(path.segments, call_path.segments)\n+                if has_identical_segments(path.segments, call_path.segments)\n                     && has_same_non_ref_symbol(first_pat, first_param)\n                 {\n                     return true;\n                 }\n             }\n         },\n         (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {\n-            return is_identical_segments(p_path.segments, e_path.segments);\n+            return has_identical_segments(p_path.segments, e_path.segments);\n         },\n         (PatKind::Lit(pat_lit_expr), ExprKind::Lit(expr_spanned)) => {\n             if let ExprKind::Lit(pat_spanned) = &pat_lit_expr.kind {\n@@ -89,7 +141,7 @@ fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n     false\n }\n \n-fn is_identical_segments(left_segs: &[PathSegment<'_>], right_segs: &[PathSegment<'_>]) -> bool {\n+fn has_identical_segments(left_segs: &[PathSegment<'_>], right_segs: &[PathSegment<'_>]) -> bool {\n     if left_segs.len() != right_segs.len() {\n         return false;\n     }\n@@ -105,8 +157,7 @@ fn has_same_non_ref_symbol(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n     if_chain! {\n         if let PatKind::Binding(annot, _, pat_ident, _) = pat.kind;\n         if !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-        if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind;\n-        if let Some(first_seg) = path.segments.first();\n+        if let ExprKind::Path(QPath::Resolved(_, Path {segments: [first_seg, ..], .. })) = expr.kind;\n         then {\n             return pat_ident.name == first_seg.ident.name;\n         }"}, {"sha": "c8c05b6f4a415f2c7d93b44c87a74a05d98cee24", "filename": "tests/ui/nop_match.fixed", "status": "modified", "additions": 40, "deletions": 61, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6bfc1120cf7773af46a9f0fa7a9ef47863577c05/tests%2Fui%2Fnop_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6bfc1120cf7773af46a9f0fa7a9ef47863577c05/tests%2Fui%2Fnop_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnop_match.fixed?ref=6bfc1120cf7773af46a9f0fa7a9ef47863577c05", "patch": "@@ -1,88 +1,67 @@\n // run-rustfix\n #![warn(clippy::nop_match)]\n #![allow(clippy::manual_map)]\n-#![allow(clippy::question_mark)]\n #![allow(dead_code)]\n \n-fn func_ret_err<T>(err: T) -> Result<(), T> {\n-    Err(err)\n-}\n-\n-enum SampleEnum {\n+enum Choice {\n     A,\n     B,\n     C,\n+    D,\n }\n \n-fn useless_prim_type_match(x: i32) -> i32 {\n-    x\n-}\n-\n-fn useless_custom_type_match(se: SampleEnum) -> SampleEnum {\n-    se\n-}\n-\n-// Don't trigger\n-fn mingled_custom_type(se: SampleEnum) -> SampleEnum {\n-    match se {\n-        SampleEnum::A => SampleEnum::B,\n-        SampleEnum::B => SampleEnum::C,\n-        SampleEnum::C => SampleEnum::A,\n-    }\n-}\n-\n-fn option_match() -> Option<i32> {\n-    Some(1)\n+fn useless_match(x: i32) {\n+    let _: i32 = x;\n }\n \n-fn result_match() -> Result<i32, i32> {\n-    Ok(1)\n+fn custom_type_match(se: Choice) {\n+    let _: Choice = se;\n+    // Don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::A,\n+        Choice::B => Choice::B,\n+        _ => Choice::C,\n+    };\n+    // Mingled, don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::B,\n+        Choice::B => Choice::C,\n+        Choice::C => Choice::D,\n+        Choice::D => Choice::A,\n+    };\n }\n \n-fn result_match_func_call() {\n-    let _ = func_ret_err(0_i32);\n+fn option_match(x: Option<i32>) {\n+    let _: Option<i32> = x;\n+    // Don't trigger, this is the case for manual_map_option\n+    let _: Option<i32> = match x {\n+        Some(a) => Some(-a),\n+        None => None,\n+    };\n }\n \n-fn option_check() -> Option<i32> {\n-    if let Some(a) = Some(1) { Some(a) } else { None }\n-}\n-\n-fn option_check_no_else() -> Option<i32> {\n-    if let Some(a) = Some(1) {\n-        return Some(a);\n-    }\n-    None\n-}\n-\n-fn result_check_no_else() -> Result<(), i32> {\n-    if let Err(e) = func_ret_err(0_i32) {\n-        return Err(e);\n-    }\n-    Ok(())\n+fn func_ret_err<T>(err: T) -> Result<i32, T> {\n+    Err(err)\n }\n \n-fn result_check_a() -> Result<(), i32> {\n-    if let Err(e) = func_ret_err(0_i32) {\n-        Err(e)\n-    } else {\n-        Ok(())\n-    }\n+fn result_match() {\n+    let _: Result<i32, i32> = Ok(1);\n+    let _: Result<i32, i32> = func_ret_err(0_i32);\n }\n \n-// Don't trigger\n-fn result_check_b() -> Result<(), i32> {\n-    if let Err(e) = Ok(1) { Err(e) } else { Ok(()) }\n+fn if_let_option() -> Option<i32> {\n+    Some(1)\n }\n \n-fn result_check_c() -> Result<(), i32> {\n-    let example = Ok(());\n-    if let Err(e) = example { Err(e) } else { example }\n+fn if_let_result(x: Result<(), i32>) {\n+    let _: Result<(), i32> = x;\n+    let _: Result<(), i32> = x;\n+    // Input type mismatch, don't trigger\n+    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n }\n \n-// Don't trigger\n-fn result_check_d() -> Result<(), i32> {\n-    let example = Ok(1);\n-    if let Err(e) = example { Err(e) } else { Ok(()) }\n+fn custom_enum_a(x: Choice) -> Choice {\n+    x\n }\n \n fn main() {}"}, {"sha": "978811e28d164d0883c307224dbfbf88021cf892", "filename": "tests/ui/nop_match.rs", "status": "modified", "additions": 55, "deletions": 67, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6bfc1120cf7773af46a9f0fa7a9ef47863577c05/tests%2Fui%2Fnop_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfc1120cf7773af46a9f0fa7a9ef47863577c05/tests%2Fui%2Fnop_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnop_match.rs?ref=6bfc1120cf7773af46a9f0fa7a9ef47863577c05", "patch": "@@ -1,106 +1,94 @@\n // run-rustfix\n #![warn(clippy::nop_match)]\n #![allow(clippy::manual_map)]\n-#![allow(clippy::question_mark)]\n #![allow(dead_code)]\n \n-fn func_ret_err<T>(err: T) -> Result<(), T> {\n-    Err(err)\n-}\n-\n-enum SampleEnum {\n+enum Choice {\n     A,\n     B,\n     C,\n+    D,\n }\n \n-fn useless_prim_type_match(x: i32) -> i32 {\n-    match x {\n+fn useless_match(x: i32) {\n+    let _: i32 = match x {\n         0 => 0,\n         1 => 1,\n         2 => 2,\n         _ => x,\n-    }\n-}\n-\n-fn useless_custom_type_match(se: SampleEnum) -> SampleEnum {\n-    match se {\n-        SampleEnum::A => SampleEnum::A,\n-        SampleEnum::B => SampleEnum::B,\n-        SampleEnum::C => SampleEnum::C,\n-    }\n+    };\n }\n \n-// Don't trigger\n-fn mingled_custom_type(se: SampleEnum) -> SampleEnum {\n-    match se {\n-        SampleEnum::A => SampleEnum::B,\n-        SampleEnum::B => SampleEnum::C,\n-        SampleEnum::C => SampleEnum::A,\n-    }\n+fn custom_type_match(se: Choice) {\n+    let _: Choice = match se {\n+        Choice::A => Choice::A,\n+        Choice::B => Choice::B,\n+        Choice::C => Choice::C,\n+        Choice::D => Choice::D,\n+    };\n+    // Don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::A,\n+        Choice::B => Choice::B,\n+        _ => Choice::C,\n+    };\n+    // Mingled, don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::B,\n+        Choice::B => Choice::C,\n+        Choice::C => Choice::D,\n+        Choice::D => Choice::A,\n+    };\n }\n \n-fn option_match() -> Option<i32> {\n-    match Some(1) {\n+fn option_match(x: Option<i32>) {\n+    let _: Option<i32> = match x {\n         Some(a) => Some(a),\n         None => None,\n-    }\n+    };\n+    // Don't trigger, this is the case for manual_map_option\n+    let _: Option<i32> = match x {\n+        Some(a) => Some(-a),\n+        None => None,\n+    };\n }\n \n-fn result_match() -> Result<i32, i32> {\n-    match Ok(1) {\n-        Ok(a) => Ok(a),\n-        Err(err) => Err(err),\n-    }\n+fn func_ret_err<T>(err: T) -> Result<i32, T> {\n+    Err(err)\n }\n \n-fn result_match_func_call() {\n-    let _ = match func_ret_err(0_i32) {\n+fn result_match() {\n+    let _: Result<i32, i32> = match Ok(1) {\n         Ok(a) => Ok(a),\n         Err(err) => Err(err),\n     };\n+    let _: Result<i32, i32> = match func_ret_err(0_i32) {\n+        Err(err) => Err(err),\n+        Ok(a) => Ok(a),\n+    };\n }\n \n-fn option_check() -> Option<i32> {\n+fn if_let_option() -> Option<i32> {\n     if let Some(a) = Some(1) { Some(a) } else { None }\n }\n \n-fn option_check_no_else() -> Option<i32> {\n-    if let Some(a) = Some(1) {\n-        return Some(a);\n-    }\n-    None\n-}\n-\n-fn result_check_no_else() -> Result<(), i32> {\n-    if let Err(e) = func_ret_err(0_i32) {\n-        return Err(e);\n-    }\n-    Ok(())\n+fn if_let_result(x: Result<(), i32>) {\n+    let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n+    let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n+    // Input type mismatch, don't trigger\n+    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n }\n \n-fn result_check_a() -> Result<(), i32> {\n-    if let Err(e) = func_ret_err(0_i32) {\n-        Err(e)\n+fn custom_enum_a(x: Choice) -> Choice {\n+    if let Choice::A = x {\n+        Choice::A\n+    } else if let Choice::B = x {\n+        Choice::B\n+    } else if let Choice::C = x {\n+        Choice::C\n     } else {\n-        Ok(())\n+        x\n     }\n }\n \n-// Don't trigger\n-fn result_check_b() -> Result<(), i32> {\n-    if let Err(e) = Ok(1) { Err(e) } else { Ok(()) }\n-}\n-\n-fn result_check_c() -> Result<(), i32> {\n-    let example = Ok(());\n-    if let Err(e) = example { Err(e) } else { example }\n-}\n-\n-// Don't trigger\n-fn result_check_d() -> Result<(), i32> {\n-    let example = Ok(1);\n-    if let Err(e) = example { Err(e) } else { Ok(()) }\n-}\n-\n fn main() {}"}, {"sha": "23a1d382a3045f63ee1a95b245fb1719fedec793", "filename": "tests/ui/nop_match.stderr", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6bfc1120cf7773af46a9f0fa7a9ef47863577c05/tests%2Fui%2Fnop_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bfc1120cf7773af46a9f0fa7a9ef47863577c05/tests%2Fui%2Fnop_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnop_match.stderr?ref=6bfc1120cf7773af46a9f0fa7a9ef47863577c05", "patch": "@@ -1,53 +1,88 @@\n error: this match expression is unnecessary\n-  --> $DIR/nop_match.rs:18:5\n+  --> $DIR/nop_match.rs:14:18\n    |\n-LL | /     match x {\n+LL |       let _: i32 = match x {\n+   |  __________________^\n LL | |         0 => 0,\n LL | |         1 => 1,\n LL | |         2 => 2,\n LL | |         _ => x,\n-LL | |     }\n+LL | |     };\n    | |_____^ help: replace it with: `x`\n    |\n    = note: `-D clippy::nop-match` implied by `-D warnings`\n \n error: this match expression is unnecessary\n-  --> $DIR/nop_match.rs:27:5\n+  --> $DIR/nop_match.rs:23:21\n    |\n-LL | /     match se {\n-LL | |         SampleEnum::A => SampleEnum::A,\n-LL | |         SampleEnum::B => SampleEnum::B,\n-LL | |         SampleEnum::C => SampleEnum::C,\n-LL | |     }\n+LL |       let _: Choice = match se {\n+   |  _____________________^\n+LL | |         Choice::A => Choice::A,\n+LL | |         Choice::B => Choice::B,\n+LL | |         Choice::C => Choice::C,\n+LL | |         Choice::D => Choice::D,\n+LL | |     };\n    | |_____^ help: replace it with: `se`\n \n error: this match expression is unnecessary\n-  --> $DIR/nop_match.rs:44:5\n+  --> $DIR/nop_match.rs:45:26\n    |\n-LL | /     match Some(1) {\n+LL |       let _: Option<i32> = match x {\n+   |  __________________________^\n LL | |         Some(a) => Some(a),\n LL | |         None => None,\n-LL | |     }\n-   | |_____^ help: replace it with: `Some(1)`\n+LL | |     };\n+   | |_____^ help: replace it with: `x`\n \n error: this match expression is unnecessary\n-  --> $DIR/nop_match.rs:51:5\n+  --> $DIR/nop_match.rs:61:31\n    |\n-LL | /     match Ok(1) {\n+LL |       let _: Result<i32, i32> = match Ok(1) {\n+   |  _______________________________^\n LL | |         Ok(a) => Ok(a),\n LL | |         Err(err) => Err(err),\n-LL | |     }\n+LL | |     };\n    | |_____^ help: replace it with: `Ok(1)`\n \n error: this match expression is unnecessary\n-  --> $DIR/nop_match.rs:58:13\n+  --> $DIR/nop_match.rs:65:31\n    |\n-LL |       let _ = match func_ret_err(0_i32) {\n-   |  _____________^\n-LL | |         Ok(a) => Ok(a),\n+LL |       let _: Result<i32, i32> = match func_ret_err(0_i32) {\n+   |  _______________________________^\n LL | |         Err(err) => Err(err),\n+LL | |         Ok(a) => Ok(a),\n LL | |     };\n    | |_____^ help: replace it with: `func_ret_err(0_i32)`\n \n-error: aborting due to 5 previous errors\n+error: this if-let expression is unnecessary\n+  --> $DIR/nop_match.rs:72:5\n+   |\n+LL |     if let Some(a) = Some(1) { Some(a) } else { None }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `Some(1)`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/nop_match.rs:76:30\n+   |\n+LL |     let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/nop_match.rs:77:30\n+   |\n+LL |     let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/nop_match.rs:83:5\n+   |\n+LL | /     if let Choice::A = x {\n+LL | |         Choice::A\n+LL | |     } else if let Choice::B = x {\n+LL | |         Choice::B\n+...  |\n+LL | |         x\n+LL | |     }\n+   | |_____^ help: replace it with: `x`\n+\n+error: aborting due to 9 previous errors\n "}]}