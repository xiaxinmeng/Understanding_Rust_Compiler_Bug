{"sha": "58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YjY4OTY2YmYwZTBkNWFlNWM1NmUyZGExZDZkZWY1ZTBlYzA5MjU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-05T12:42:12Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-11T14:21:20Z"}, "message": "Handle resolution errors in where clauses\n\nThis is slightly hacky, but maybe more elegant than alternative solutions: We\njust use a hardcoded Chalk trait ID which we special-case to have no impls.", "tree": {"sha": "2d92dbadd7f6cbf756766040eec8685688415241", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d92dbadd7f6cbf756766040eec8685688415241"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925", "html_url": "https://github.com/rust-lang/rust/commit/58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50bbf9eb09dc34781cc34e10bfba5f154e833123", "url": "https://api.github.com/repos/rust-lang/rust/commits/50bbf9eb09dc34781cc34e10bfba5f154e833123", "html_url": "https://github.com/rust-lang/rust/commit/50bbf9eb09dc34781cc34e10bfba5f154e833123"}], "stats": {"total": 71, "additions": 56, "deletions": 15}, "files": [{"sha": "3c55a093f9bcca19dd96ceb187bb93fd18252ab2", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925", "patch": "@@ -2501,6 +2501,21 @@ fn test() { (&S).foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n+#[test]\n+fn method_resolution_where_clause_for_unknown_trait() {\n+    // The blanket impl shouldn't apply because we can't even resolve UnknownTrait\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T> Trait for T where T: UnknownTrait {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n #[test]\n fn method_resolution_where_clause_not_met() {\n     // The blanket impl shouldn't apply because we can't prove S: Clone"}, {"sha": "7879701860ccb762c09448fa9674f3b094489bf1", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=58b68966bf0e0d5ae5c56e2da1d6def5e0ec0925", "patch": "@@ -15,6 +15,10 @@ use crate::{\n };\n use super::ChalkContext;\n \n+/// This represents a trait whose name we could not resolve.\n+const UNKNOWN_TRAIT: chalk_ir::TraitId =\n+    chalk_ir::TraitId(chalk_ir::RawId { index: u32::max_value() });\n+\n pub(super) trait ToChalk {\n     type Chalk;\n     fn to_chalk(self, db: &impl HirDatabase) -> Self::Chalk;\n@@ -45,7 +49,10 @@ impl ToChalk for Ty {\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n             // FIXME this is clearly incorrect, but probably not too incorrect\n             // and I'm not sure what to actually do with Ty::Unknown\n-            Ty::Unknown => PlaceholderIndex { ui: UniverseIndex::ROOT, idx: 0 }.to_ty(),\n+            // maybe an alternative would be `for<T> T`? (meaningless in rust, but expressible in chalk's Ty)\n+            Ty::Unknown => {\n+                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::max_value() }.to_ty()\n+            }\n         }\n     }\n     fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty) -> Self {\n@@ -154,7 +161,13 @@ impl ToChalk for GenericPredicate {\n             GenericPredicate::Implemented(trait_ref) => {\n                 make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n             }\n-            GenericPredicate::Error => panic!(\"Trying to pass errored where clause to Chalk\"),\n+            GenericPredicate::Error => {\n+                let impossible_trait_ref = chalk_ir::TraitRef {\n+                    trait_id: UNKNOWN_TRAIT,\n+                    parameters: vec![Ty::Unknown.to_chalk(db).cast()],\n+                };\n+                make_binders(chalk_ir::WhereClause::Implemented(impossible_trait_ref), 0)\n+            }\n         }\n     }\n \n@@ -178,19 +191,13 @@ fn convert_where_clauses(\n     db: &impl HirDatabase,\n     def: GenericDef,\n     substs: &Substs,\n-) -> (Vec<chalk_ir::QuantifiedWhereClause>, bool) {\n+) -> Vec<chalk_ir::QuantifiedWhereClause> {\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n-    let mut has_error = false;\n     for pred in generic_predicates.iter() {\n-        // FIXME: it would probably be nicer if we could just convert errored predicates to a where clause that is never true...\n-        if pred.is_error() {\n-            has_error = true;\n-        } else {\n-            result.push(pred.clone().subst(substs).to_chalk(db));\n-        }\n+        result.push(pred.clone().subst(substs).to_chalk(db));\n     }\n-    (result, has_error)\n+    result\n }\n \n impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n@@ -202,6 +209,23 @@ where\n     }\n     fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum> {\n         debug!(\"trait_datum {:?}\", trait_id);\n+        if trait_id == UNKNOWN_TRAIT {\n+            let trait_datum_bound = chalk_rust_ir::TraitDatumBound {\n+                trait_ref: chalk_ir::TraitRef {\n+                    trait_id: UNKNOWN_TRAIT,\n+                    parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n+                },\n+                associated_ty_ids: Vec::new(),\n+                where_clauses: Vec::new(),\n+                flags: chalk_rust_ir::TraitFlags {\n+                    auto: false,\n+                    marker: false,\n+                    upstream: true,\n+                    fundamental: false,\n+                },\n+            };\n+            return Arc::new(TraitDatum { binders: make_binders(trait_datum_bound, 1) });\n+        }\n         let trait_: Trait = from_chalk(self.db, trait_id);\n         let generic_params = trait_.generic_params(self.db);\n         let bound_vars = Substs::bound_vars(&generic_params);\n@@ -213,7 +237,7 @@ where\n             upstream: trait_.module(self.db).krate(self.db) != Some(self.krate),\n             fundamental: false,\n         };\n-        let (where_clauses, _) = convert_where_clauses(self.db, trait_.into(), &bound_vars);\n+        let where_clauses = convert_where_clauses(self.db, trait_.into(), &bound_vars);\n         let associated_ty_ids = Vec::new(); // FIXME add associated tys\n         let trait_datum_bound =\n             chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags, associated_ty_ids };\n@@ -241,7 +265,7 @@ where\n             TypeCtor::Adt(adt) => {\n                 let generic_params = adt.generic_params(self.db);\n                 let bound_vars = Substs::bound_vars(&generic_params);\n-                let (where_clauses, _) = convert_where_clauses(self.db, adt.into(), &bound_vars);\n+                let where_clauses = convert_where_clauses(self.db, adt.into(), &bound_vars);\n                 (\n                     generic_params.count_params_including_parent(),\n                     where_clauses,\n@@ -281,8 +305,7 @@ where\n         } else {\n             chalk_rust_ir::ImplType::External\n         };\n-        let (where_clauses, where_clause_error) =\n-            convert_where_clauses(self.db, impl_block.into(), &bound_vars);\n+        let where_clauses = convert_where_clauses(self.db, impl_block.into(), &bound_vars);\n         let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n             // FIXME handle negative impls (impl !Sync for Foo)\n             trait_ref: chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref.to_chalk(self.db)),\n@@ -295,6 +318,9 @@ where\n     }\n     fn impls_for_trait(&self, trait_id: chalk_ir::TraitId) -> Vec<ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n+        if trait_id == UNKNOWN_TRAIT {\n+            return Vec::new();\n+        }\n         let trait_ = from_chalk(self.db, trait_id);\n         self.db\n             .impls_for_trait(self.krate, trait_)"}]}