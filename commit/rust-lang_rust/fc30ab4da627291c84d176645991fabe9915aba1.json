{"sha": "fc30ab4da627291c84d176645991fabe9915aba1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMzBhYjRkYTYyNzI5MWM4NGQxNzY2NDU5OTFmYWJlOTkxNWFiYTE=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-11-18T22:24:46Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-19T14:06:14Z"}, "message": "Rollup merge of #55949 - ljedrz:return_impl_Iterator_from_Predicate_walk_tys, r=oli-obk\n\nty: return impl Iterator from Predicate::walk_tys\n\nFixes the lazyboye `FIXME` by returning a custom `Iterator` as intended by the original author of the function.\n\nIt is indeed a bit convoluted, so I'm ok with not changing this if perf results are not favourable enough. Also happy to adjust any names if need be.", "tree": {"sha": "927a2073d4005d488c2f97856f051ba600a97e7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/927a2073d4005d488c2f97856f051ba600a97e7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc30ab4da627291c84d176645991fabe9915aba1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlvyw1cACgkQ/vbIBR0O\nATyAaQ//UyUNs07w2J2GIIpNHcrswf4q/2820V/74yMj8NVILCYpIRgVYmkJmZIr\nWpDsPsPvWf+ZMk6RkX6FdmyHBc09gpMoAD322PSDA6EgEtpMjTsGPKSO42+MfDCO\nE0cmDMCwrgowDuzZmICfUMaaEKPA62mmcq0e4ScKQ/6O0399H7jBfTgsAB3Jey/T\n9hKV8QW0vU0ak5a/jF8VdV0QwYpQGZiw9bd49FTUNw3MHXLSEJB3WnCtfASCQke4\nkcKS3KwQPIwE1lpT4K2DDWFYLfPRfQxJVqMBtZm2l4k9LWSFwUREnaXGyq2IIP+Q\n8ih8wn2Urz7w2wNvHgNef3wWYexggpDpYRXu2VecWLAcnKUGF1jYwyzl44+lFx+i\nSdlzOrHJUKf6SE7Q/FNxUkWrfVVjFYQAVrccM7QW9+GGsKzJltzEc7UYHVQmKryB\n1jzJqB+O2mUkRZfQGiAq3HGzkFuIrcYnAmj2PWuSs9vIPX3DmDN67GerXr48EfW4\nbC9PGfgcgQ6wg9WrZJ8KXJeA2AF/BUnTCGJdjsdBtFJ81RqiunCp9Qz22yE8b1vA\nYBvmWuBzi6paEOgKEyTmpblekogho5zM7D1eE5as4u7IRVEN69BTeZXC1ar4TeUC\n2ZfHni1I7brJqswR/9R7JaZOz6tgLIhnjNVtMwTIRE/72WeXEKI=\n=nqWB\n-----END PGP SIGNATURE-----", "payload": "tree 927a2073d4005d488c2f97856f051ba600a97e7f\nparent 715d83fe01b02c3c42f6a60810cf8fe8316788e5\nparent e6e56357308d1e20b56f1be9af2c2dfc73c49d0d\nauthor Pietro Albini <pietro@pietroalbini.org> 1542579886 +0100\ncommitter kennytm <kennytm@gmail.com> 1542636374 +0800\n\nRollup merge of #55949 - ljedrz:return_impl_Iterator_from_Predicate_walk_tys, r=oli-obk\n\nty: return impl Iterator from Predicate::walk_tys\n\nFixes the lazyboye `FIXME` by returning a custom `Iterator` as intended by the original author of the function.\n\nIt is indeed a bit convoluted, so I'm ok with not changing this if perf results are not favourable enough. Also happy to adjust any names if need be.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc30ab4da627291c84d176645991fabe9915aba1", "html_url": "https://github.com/rust-lang/rust/commit/fc30ab4da627291c84d176645991fabe9915aba1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc30ab4da627291c84d176645991fabe9915aba1/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "715d83fe01b02c3c42f6a60810cf8fe8316788e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/715d83fe01b02c3c42f6a60810cf8fe8316788e5", "html_url": "https://github.com/rust-lang/rust/commit/715d83fe01b02c3c42f6a60810cf8fe8316788e5"}, {"sha": "e6e56357308d1e20b56f1be9af2c2dfc73c49d0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e56357308d1e20b56f1be9af2c2dfc73c49d0d", "html_url": "https://github.com/rust-lang/rust/commit/e6e56357308d1e20b56f1be9af2c2dfc73c49d0d"}], "stats": {"total": 78, "additions": 58, "deletions": 20}, "files": [{"sha": "729505342c5928060832125c3a288a172b64bad8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 58, "deletions": 20, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/fc30ab4da627291c84d176645991fabe9915aba1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc30ab4da627291c84d176645991fabe9915aba1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fc30ab4da627291c84d176645991fabe9915aba1", "patch": "@@ -49,7 +49,6 @@ use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use rustc_data_structures::sync::{self, Lrc, ParallelIterator, par_iter};\n use std::slice;\n-use std::vec::IntoIter;\n use std::{mem, ptr};\n use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n@@ -1343,49 +1342,88 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     }\n }\n \n+// A custom iterator used by Predicate::walk_tys.\n+enum WalkTysIter<'tcx, I, J, K>\n+    where I: Iterator<Item = Ty<'tcx>>,\n+          J: Iterator<Item = Ty<'tcx>>,\n+          K: Iterator<Item = Ty<'tcx>>\n+{\n+    None,\n+    One(Ty<'tcx>),\n+    Two(Ty<'tcx>, Ty<'tcx>),\n+    Types(I),\n+    InputTypes(J),\n+    ProjectionTypes(K)\n+}\n+\n+impl<'tcx, I, J, K> Iterator for WalkTysIter<'tcx, I, J, K>\n+    where I: Iterator<Item = Ty<'tcx>>,\n+          J: Iterator<Item = Ty<'tcx>>,\n+          K: Iterator<Item = Ty<'tcx>>\n+{\n+    type Item = Ty<'tcx>;\n+\n+    fn next(&mut self) -> Option<Ty<'tcx>> {\n+        match *self {\n+            WalkTysIter::None => None,\n+            WalkTysIter::One(item) => {\n+                *self = WalkTysIter::None;\n+                Some(item)\n+            },\n+            WalkTysIter::Two(item1, item2) => {\n+                *self = WalkTysIter::One(item2);\n+                Some(item1)\n+            },\n+            WalkTysIter::Types(ref mut iter) => {\n+                iter.next()\n+            },\n+            WalkTysIter::InputTypes(ref mut iter) => {\n+                iter.next()\n+            },\n+            WalkTysIter::ProjectionTypes(ref mut iter) => {\n+                iter.next()\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> Predicate<'tcx> {\n     /// Iterates over the types in this predicate. Note that in all\n     /// cases this is skipping over a binder, so late-bound regions\n     /// with depth 0 are bound by the predicate.\n-    pub fn walk_tys(&self) -> IntoIter<Ty<'tcx>> {\n-        let vec: Vec<_> = match *self {\n+    pub fn walk_tys(&'a self) -> impl Iterator<Item = Ty<'tcx>> + 'a {\n+        match *self {\n             ty::Predicate::Trait(ref data) => {\n-                data.skip_binder().input_types().collect()\n+                WalkTysIter::InputTypes(data.skip_binder().input_types())\n             }\n             ty::Predicate::Subtype(binder) => {\n                 let SubtypePredicate { a, b, a_is_expected: _ } = binder.skip_binder();\n-                vec![a, b]\n+                WalkTysIter::Two(a, b)\n             }\n             ty::Predicate::TypeOutlives(binder) => {\n-                vec![binder.skip_binder().0]\n+                WalkTysIter::One(binder.skip_binder().0)\n             }\n             ty::Predicate::RegionOutlives(..) => {\n-                vec![]\n+                WalkTysIter::None\n             }\n             ty::Predicate::Projection(ref data) => {\n                 let inner = data.skip_binder();\n-                inner.projection_ty.substs.types().chain(Some(inner.ty)).collect()\n+                WalkTysIter::ProjectionTypes(\n+                    inner.projection_ty.substs.types().chain(Some(inner.ty)))\n             }\n             ty::Predicate::WellFormed(data) => {\n-                vec![data]\n+                WalkTysIter::One(data)\n             }\n             ty::Predicate::ObjectSafe(_trait_def_id) => {\n-                vec![]\n+                WalkTysIter::None\n             }\n             ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) => {\n-                closure_substs.substs.types().collect()\n+                WalkTysIter::Types(closure_substs.substs.types())\n             }\n             ty::Predicate::ConstEvaluatable(_, substs) => {\n-                substs.types().collect()\n+                WalkTysIter::Types(substs.types())\n             }\n-        };\n-\n-        // FIXME: The only reason to collect into a vector here is that I was\n-        // too lazy to make the full (somewhat complicated) iterator\n-        // type that would be needed here. But I wanted this fn to\n-        // return an iterator conceptually, rather than a `Vec`, so as\n-        // to be closer to `Ty::walk`.\n-        vec.into_iter()\n+        }\n     }\n \n     pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {"}]}