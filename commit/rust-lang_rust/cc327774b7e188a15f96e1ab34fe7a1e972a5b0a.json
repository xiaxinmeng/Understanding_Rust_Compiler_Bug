{"sha": "cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "node_id": "C_kwDOAAsO6NoAKGNjMzI3Nzc0YjdlMTg4YTE1Zjk2ZTFhYjM0ZmU3YTFlOTcyYTViMGE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-20T15:00:45Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-20T15:00:45Z"}, "message": "internal: Replace Vec with Box in hir Expr", "tree": {"sha": "fab340abb3b0814b49365d4c3a3ffdfcbc38a27a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fab340abb3b0814b49365d4c3a3ffdfcbc38a27a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "html_url": "https://github.com/rust-lang/rust/commit/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14dff25107cec4473fde8c999256a3484a7ef1d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/14dff25107cec4473fde8c999256a3484a7ef1d0", "html_url": "https://github.com/rust-lang/rust/commit/14dff25107cec4473fde8c999256a3484a7ef1d0"}], "stats": {"total": 71, "additions": 34, "deletions": 37}, "files": [{"sha": "48aa1b3464be9de0f7037edd3485e8ff900081df", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "patch": "@@ -130,11 +130,7 @@ impl ExprCollector<'_> {\n                 self.body.params.push(param_pat);\n             }\n \n-            for param in param_list.params() {\n-                let pat = match param.pat() {\n-                    None => continue,\n-                    Some(pat) => pat,\n-                };\n+            for pat in param_list.params().filter_map(|param| param.pat()) {\n                 let param_pat = self.collect_pat(pat);\n                 self.body.params.push(param_pat);\n             }\n@@ -160,7 +156,7 @@ impl ExprCollector<'_> {\n         self.make_expr(expr, Err(SyntheticSyntax))\n     }\n     fn unit(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Tuple { exprs: Vec::new() })\n+        self.alloc_expr_desugared(Expr::Tuple { exprs: Box::default() })\n     }\n     fn missing_expr(&mut self) -> ExprId {\n         self.alloc_expr_desugared(Expr::Missing)\n@@ -235,7 +231,8 @@ impl ExprCollector<'_> {\n                                     expr: else_branch.unwrap_or_else(|| self.unit()),\n                                     guard: None,\n                                 },\n-                            ];\n+                            ]\n+                            .into();\n                             return Some(\n                                 self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr),\n                             );\n@@ -300,7 +297,8 @@ impl ExprCollector<'_> {\n                             let arms = vec![\n                                 MatchArm { pat, expr: body, guard: None },\n                                 MatchArm { pat: placeholder_pat, expr: break_, guard: None },\n-                            ];\n+                            ]\n+                            .into();\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n                             return Some(\n@@ -324,7 +322,7 @@ impl ExprCollector<'_> {\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n                 } else {\n-                    Vec::new()\n+                    Box::default()\n                 };\n                 self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n             }\n@@ -333,7 +331,7 @@ impl ExprCollector<'_> {\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n                 } else {\n-                    Vec::new()\n+                    Box::default()\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let generic_args = e\n@@ -367,7 +365,7 @@ impl ExprCollector<'_> {\n                         })\n                         .collect()\n                 } else {\n-                    Vec::new()\n+                    Box::default()\n                 };\n                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n@@ -429,7 +427,7 @@ impl ExprCollector<'_> {\n                     let spread = nfl.spread().map(|s| self.collect_expr(s));\n                     Expr::RecordLit { path, fields, spread }\n                 } else {\n-                    Expr::RecordLit { path, fields: Vec::new(), spread: None }\n+                    Expr::RecordLit { path, fields: Box::default(), spread: None }\n                 };\n \n                 self.alloc_expr(record_lit, syntax_ptr)\n@@ -496,7 +494,10 @@ impl ExprCollector<'_> {\n                     .and_then(|r| r.ty())\n                     .map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n                 let body = self.collect_expr_opt(e.body());\n-                self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Lambda { args: args.into(), arg_types: arg_types.into(), ret_type, body },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n@@ -718,7 +719,7 @@ impl ExprCollector<'_> {\n             self.statements_in_scope.pop();\n         }\n         let tail = tail;\n-        let statements = std::mem::replace(&mut self.statements_in_scope, prev_statements);\n+        let statements = std::mem::replace(&mut self.statements_in_scope, prev_statements).into();\n         let syntax_node_ptr = AstPtr::new(&block.into());\n         let expr_id = self.alloc_expr(\n             Expr::Block { id: block_id, statements, tail, label: None },"}, {"sha": "2658eece8e85e60fa93a8d95dbd4cd9bcb7a3bb4", "filename": "crates/hir_def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs?ref=cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "patch": "@@ -204,7 +204,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         }\n         Expr::Match { expr, arms } => {\n             compute_expr_scopes(*expr, body, scopes, scope);\n-            for arm in arms {\n+            for arm in arms.iter() {\n                 let mut scope = scopes.new_scope(scope);\n                 scopes.add_bindings(body, scope, arm.pat);\n                 match arm.guard {"}, {"sha": "587a5ce46d4a3e33cde8a8e815c39f43e260d5cd", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "patch": "@@ -61,7 +61,7 @@ pub enum Expr {\n     },\n     Block {\n         id: BlockId,\n-        statements: Vec<Statement>,\n+        statements: Box<[Statement]>,\n         tail: Option<ExprId>,\n         label: Option<LabelId>,\n     },\n@@ -82,17 +82,17 @@ pub enum Expr {\n     },\n     Call {\n         callee: ExprId,\n-        args: Vec<ExprId>,\n+        args: Box<[ExprId]>,\n     },\n     MethodCall {\n         receiver: ExprId,\n         method_name: Name,\n-        args: Vec<ExprId>,\n+        args: Box<[ExprId]>,\n         generic_args: Option<Box<GenericArgs>>,\n     },\n     Match {\n         expr: ExprId,\n-        arms: Vec<MatchArm>,\n+        arms: Box<[MatchArm]>,\n     },\n     Continue {\n         label: Option<Name>,\n@@ -109,7 +109,7 @@ pub enum Expr {\n     },\n     RecordLit {\n         path: Option<Box<Path>>,\n-        fields: Vec<RecordLitField>,\n+        fields: Box<[RecordLitField]>,\n         spread: Option<ExprId>,\n     },\n     Field {\n@@ -162,13 +162,13 @@ pub enum Expr {\n         index: ExprId,\n     },\n     Lambda {\n-        args: Vec<PatId>,\n-        arg_types: Vec<Option<Interned<TypeRef>>>,\n+        args: Box<[PatId]>,\n+        arg_types: Box<[Option<Interned<TypeRef>>]>,\n         ret_type: Option<Interned<TypeRef>>,\n         body: ExprId,\n     },\n     Tuple {\n-        exprs: Vec<ExprId>,\n+        exprs: Box<[ExprId]>,\n     },\n     Unsafe {\n         body: ExprId,\n@@ -233,7 +233,7 @@ impl Expr {\n                 }\n             }\n             Expr::Block { statements, tail, .. } => {\n-                for stmt in statements {\n+                for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {\n                             if let Some(expr) = initializer {\n@@ -262,19 +262,19 @@ impl Expr {\n             }\n             Expr::Call { callee, args } => {\n                 f(*callee);\n-                for arg in args {\n+                for arg in args.iter() {\n                     f(*arg);\n                 }\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n                 f(*receiver);\n-                for arg in args {\n+                for arg in args.iter() {\n                     f(*arg);\n                 }\n             }\n             Expr::Match { expr, arms } => {\n                 f(*expr);\n-                for arm in arms {\n+                for arm in arms.iter() {\n                     f(arm.expr);\n                 }\n             }\n@@ -285,7 +285,7 @@ impl Expr {\n                 }\n             }\n             Expr::RecordLit { fields, spread, .. } => {\n-                for field in fields {\n+                for field in fields.iter() {\n                     f(field.expr);\n                 }\n                 if let Some(expr) = spread {\n@@ -321,7 +321,7 @@ impl Expr {\n                 f(*expr);\n             }\n             Expr::Tuple { exprs } => {\n-                for expr in exprs {\n+                for expr in exprs.iter() {\n                     f(*expr);\n                 }\n             }"}, {"sha": "195c53c17e211fb3a2f514e53a2f87b4a668e51a", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "patch": "@@ -202,19 +202,16 @@ impl ExprValidator {\n         }\n \n         let is_method_call = matches!(expr, Expr::MethodCall { .. });\n-        let (sig, args) = match expr {\n+        let (sig, mut arg_count) = match expr {\n             Expr::Call { callee, args } => {\n                 let callee = &self.infer.type_of_expr[*callee];\n                 let sig = match callee.callable_sig(db) {\n                     Some(sig) => sig,\n                     None => return,\n                 };\n-                (sig, args.clone())\n+                (sig, args.len())\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n-                let mut args = args.clone();\n-                args.insert(0, *receiver);\n-\n                 let receiver = &self.infer.type_of_expr[*receiver];\n                 if receiver.strip_references().is_unknown() {\n                     // if the receiver is of unknown type, it's very likely we\n@@ -229,7 +226,7 @@ impl ExprValidator {\n                 };\n                 let sig = db.callable_item_signature(callee.into()).substitute(&Interner, &subst);\n \n-                (sig, args)\n+                (sig, args.len() + 1)\n             }\n             _ => return,\n         };\n@@ -241,7 +238,6 @@ impl ExprValidator {\n         let params = sig.params();\n \n         let mut param_count = params.len();\n-        let mut arg_count = args.len();\n \n         if arg_count != param_count {\n             if is_method_call {"}, {"sha": "5fb227c0e4986d66deb0e7e5e8aa5efdcb031e91", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc327774b7e188a15f96e1ab34fe7a1e972a5b0a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=cc327774b7e188a15f96e1ab34fe7a1e972a5b0a", "patch": "@@ -375,7 +375,7 @@ impl<'a> InferenceContext<'a> {\n                 let matchee_diverges = self.diverges;\n                 let mut all_arms_diverge = Diverges::Always;\n \n-                for arm in arms {\n+                for arm in arms.iter() {\n                     self.diverges = Diverges::Maybe;\n                     let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n                     match arm.guard {"}]}