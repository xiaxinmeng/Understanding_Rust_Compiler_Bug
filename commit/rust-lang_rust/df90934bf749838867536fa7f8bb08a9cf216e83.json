{"sha": "df90934bf749838867536fa7f8bb08a9cf216e83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmOTA5MzRiZjc0OTgzODg2NzUzNmZhN2Y4YmIwOGE5Y2YyMTZlODM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-19T02:19:20Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-19T02:19:20Z"}, "message": "rustc: Split write_* in typeck into versions that will record fixups", "tree": {"sha": "2a81f6841448772c9ca07fe430ebfa0230118f5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a81f6841448772c9ca07fe430ebfa0230118f5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df90934bf749838867536fa7f8bb08a9cf216e83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df90934bf749838867536fa7f8bb08a9cf216e83", "html_url": "https://github.com/rust-lang/rust/commit/df90934bf749838867536fa7f8bb08a9cf216e83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df90934bf749838867536fa7f8bb08a9cf216e83/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2bdfe36cfafe97d9114bce541bb84e82b897cf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2bdfe36cfafe97d9114bce541bb84e82b897cf8", "html_url": "https://github.com/rust-lang/rust/commit/d2bdfe36cfafe97d9114bce541bb84e82b897cf8"}], "stats": {"total": 300, "additions": 163, "deletions": 137}, "files": [{"sha": "dbad2715776e634cafd2f77054bd12e2133537e5", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 163, "deletions": 137, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/df90934bf749838867536fa7f8bb08a9cf216e83/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df90934bf749838867536fa7f8bb08a9cf216e83/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=df90934bf749838867536fa7f8bb08a9cf216e83", "patch": "@@ -391,30 +391,57 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast::ty ast_ty) -> ty::t {\n }\n \n \n-// Writes a type parameter count and type pair into the node type table.\n-fn write_type(&node_type_table ntt, uint node_id,\n-              &ty_param_substs_opt_and_ty tpot) {\n-    vec::grow_set[option::t[ty::ty_param_substs_opt_and_ty]]\n-        (*ntt,\n-         node_id,\n-         none[ty_param_substs_opt_and_ty],\n-         some[ty_param_substs_opt_and_ty](tpot));\n-}\n+// Functions that write types into the node type table.\n \n-// Writes a type with no type parameters into the node type table.\n-fn write_type_only(&node_type_table ntt, uint node_id, ty::t ty) {\n-    be write_type(ntt, node_id, tup(none[vec[ty::t]], ty));\n-}\n+mod write {\n+    fn inner(&node_type_table ntt, uint node_id,\n+             &ty_param_substs_opt_and_ty tpot) {\n+        vec::grow_set[option::t[ty::ty_param_substs_opt_and_ty]]\n+            (*ntt,\n+             node_id,\n+             none[ty_param_substs_opt_and_ty],\n+             some[ty_param_substs_opt_and_ty](tpot));\n+    }\n \n-// Writes a nil type into the node type table.\n-fn write_nil_type(ty::ctxt tcx, &node_type_table ntt, uint node_id) {\n-    be write_type_only(ntt, node_id, ty::mk_nil(tcx));\n-}\n+    // Writes a type parameter count and type pair into the node type table.\n+    fn ty(&ty::ctxt tcx, &node_type_table ntt, uint node_id,\n+          &ty_param_substs_opt_and_ty tpot) {\n+        assert (!ty::type_contains_vars(tcx, tpot._1));\n+        be inner(ntt, node_id, tpot);\n+    }\n+\n+    // Writes a type parameter count and type pair into the node type table.\n+    // This function allows for the possibility of type variables, which will\n+    // be rewritten later during the fixup phase.\n+    fn ty_fixup(&@stmt_ctxt scx, uint node_id,\n+                &ty_param_substs_opt_and_ty tpot) {\n+        inner(scx.fcx.ccx.node_types, node_id, tpot);\n+        if (ty::type_contains_vars(scx.fcx.ccx.tcx, tpot._1)) {\n+            scx.fixups += [node_id];\n+        }\n+    }\n \n-// Writes the bottom type into the node type table.\n-fn write_bot_type(ty::ctxt tcx, &node_type_table ntt, uint node_id) {\n-    // FIXME: Should be mk_bot(), but this breaks lots of stuff.\n-    be write_type_only(ntt, node_id, ty::mk_nil(tcx));\n+    // Writes a type with no type parameters into the node type table.\n+    fn ty_only(&ty::ctxt tcx, &node_type_table ntt, uint node_id, ty::t typ) {\n+        be ty(tcx, ntt, node_id, tup(none[vec[ty::t]], typ));\n+    }\n+\n+    // Writes a type with no type parameters into the node type table. This\n+    // function allows for the possibility of type variables.\n+    fn ty_only_fixup(&@stmt_ctxt scx, uint node_id, ty::t typ) {\n+        be ty_fixup(scx, node_id, tup(none[vec[ty::t]], typ));\n+    }\n+\n+    // Writes a nil type into the node type table.\n+    fn nil_ty(&ty::ctxt tcx, &node_type_table ntt, uint node_id) {\n+        be ty(tcx, ntt, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n+    }\n+\n+    // Writes the bottom type into the node type table.\n+    fn bot_ty(&ty::ctxt tcx, &node_type_table ntt, uint node_id) {\n+        // FIXME: Should be mk_bot(), but this breaks lots of stuff.\n+        be ty(tcx, ntt, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n+    }\n }\n \n \n@@ -676,7 +703,8 @@ mod collect {\n                 ann=triv_ann(variant.node.ann.id, result_ty)\n                 with variant.node\n             );\n-            write_type_only(cx.node_types, variant.node.ann.id, result_ty);\n+            write::ty_only(cx.tcx, cx.node_types, variant.node.ann.id,\n+                           result_ty);\n             result += [fold::respan(variant.span, variant_t)];\n         }\n \n@@ -727,7 +755,7 @@ mod collect {\n             }\n             case (ast::item_tag(_, ?variants, ?ty_params, ?tag_id, ?ann)) {\n                 auto tpt = ty_of_item(cx, it);\n-                write_type_only(cx.node_types, ann.id, tpt._1);\n+                write::ty_only(cx.tcx, cx.node_types, ann.id, tpt._1);\n \n                 get_tag_variant_types(cx, tag_id, variants, ty_params);\n             }\n@@ -739,7 +767,7 @@ mod collect {\n                 // we write into the table for this item.\n                 auto tpt = ty_of_obj_ctor(cx, ident, object, odid.ctor,\n                                           ty_params);\n-                write_type_only(cx.node_types, ann.id, tpt._1);\n+                write::ty_only(cx.tcx, cx.node_types, ann.id, tpt._1);\n \n                 // Write the methods into the type table.\n                 //\n@@ -749,10 +777,10 @@ mod collect {\n                 auto method_types = get_obj_method_types(cx, object);\n                 auto i = 0u;\n                 while (i < vec::len[@ast::method](object.methods)) {\n-                    write_type_only(cx.node_types,\n-                                    object.methods.(i).node.ann.id,\n-                                    ty::method_ty_to_fn_ty(cx.tcx,\n-                                        method_types.(i)));\n+                    write::ty_only(cx.tcx, cx.node_types,\n+                                   object.methods.(i).node.ann.id,\n+                                   ty::method_ty_to_fn_ty(cx.tcx,\n+                                       method_types.(i)));\n                     i += 1u;\n                 }\n \n@@ -764,7 +792,8 @@ mod collect {\n                 i = 0u;\n                 while (i < vec::len[ty::arg](args)) {\n                     auto fld = object.fields.(i);\n-                    write_type_only(cx.node_types, fld.ann.id, args.(i).ty);\n+                    write::ty_only(cx.tcx, cx.node_types, fld.ann.id,\n+                                   args.(i).ty);\n                     i += 1u;\n                 }\n \n@@ -776,7 +805,8 @@ mod collect {\n                         let vec[arg] no_args = [];\n                         auto t = ty::mk_fn(cx.tcx, ast::proto_fn, no_args,\n                                            ty::mk_nil(cx.tcx));\n-                        write_type_only(cx.node_types, m.node.ann.id, t);\n+                        write::ty_only(cx.tcx, cx.node_types, m.node.ann.id,\n+                                       t);\n                     }\n                 }\n             }\n@@ -785,7 +815,8 @@ mod collect {\n                 // of the item in passing. All we have to do here is to write\n                 // it into the node type table.\n                 auto tpt = ty_of_item(cx, it);\n-                write_type_only(cx.node_types, ty::item_ann(it).id, tpt._1);\n+                write::ty_only(cx.tcx, cx.node_types, ty::item_ann(it).id,\n+                               tpt._1);\n             }\n         }\n     }\n@@ -803,7 +834,7 @@ mod collect {\n                 // FIXME: Native types have no annotation. Should they? --pcw\n             }\n             case (ast::native_item_fn(_,_,_,_,_,?a)) {\n-                write_type_only(cx.node_types, a.id, tpt._1);\n+                write::ty_only(cx.tcx, cx.node_types, a.id, tpt._1);\n             }\n         }\n     }\n@@ -1129,21 +1160,18 @@ mod Pushdown {\n             case (ast::pat_wild(?ann)) {\n                 auto t = Demand::simple(scx, pat.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type(scx.fcx.ccx.node_types, ann.id,\n-                           tup(none[vec[ty::t]], t));\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::pat_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(scx, pat.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type(scx.fcx.ccx.node_types, ann.id,\n-                           tup(none[vec[ty::t]], t));\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::pat_bind(?id, ?did, ?ann)) {\n                 auto t = Demand::simple(scx, pat.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 scx.fcx.locals.insert(did, t);\n-                write_type(scx.fcx.ccx.node_types, ann.id,\n-                           tup(none[vec[ty::t]], t));\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::pat_tag(?id, ?subpats, ?ann)) {\n                 // Take the variant's type parameters out of the expected\n@@ -1199,7 +1227,7 @@ mod Pushdown {\n                                        some[vec[ty::t]](res_t._0));\n \n                 // TODO: push down type from \"expected\".\n-                write_type(scx.fcx.ccx.node_types, ann.id,\n+                write::ty_fixup(scx, ann.id,\n                     ty::ann_to_ty_param_substs_opt_and_ty\n                         (scx.fcx.ccx.node_types, a_1));\n             }\n@@ -1235,7 +1263,7 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n@@ -1253,7 +1281,7 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n \n@@ -1295,12 +1323,12 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_call(?sube, ?es, ?ann)) {\n                 // NB: we call 'Demand::autoderef' and pass in adk only in\n@@ -1309,34 +1337,34 @@ mod Pushdown {\n                 // so there's no need.\n                 auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // Demand::autoderef.\n                 auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n@@ -1349,56 +1377,56 @@ mod Pushdown {\n                         pushdown_expr(scx, expected, e_0);\n                     }\n                 }\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 pushdown_expr(scx, expected, lhs_0);\n                 pushdown_expr(scx, expected, rhs_0);\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 pushdown_expr(scx, expected, lhs_0);\n                 pushdown_expr(scx, expected, rhs_0);\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             case (ast::expr_path(?pth, ?ann)) {\n                 auto tp_substs_0 =\n@@ -1422,13 +1450,12 @@ mod Pushdown {\n                     }\n                 }\n \n-                write_type(scx.fcx.ccx.node_types, ann.id,\n-                           tup(ty_params_opt, t));\n+                write::ty_fixup(scx, ann.id, tup(ty_params_opt, t));\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n                 auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n             /* FIXME: should this check the type annotations? */\n             case (ast::expr_fail(_))  { /* no-op */ }\n@@ -1444,7 +1471,7 @@ mod Pushdown {\n             case (ast::expr_port(?ann)) {\n                 auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n@@ -1460,7 +1487,7 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (ast::expr_alt(?discrim, ?arms_0, ?ann)) {\n@@ -1472,14 +1499,14 @@ mod Pushdown {\n                                         arm_0.block);\n                     t = Demand::simple(scx, e.span, t, bty);\n                 }\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (ast::expr_recv(?lval, ?expr, ?ann)) {\n                 pushdown_expr(scx, next_ty_var(scx), lval);\n                 auto t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                                  lval);\n-                pushdown_expr(scx, ty::mk_port(scx.fcx.ccx.tcx, t), expr);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (ast::expr_send(?lval, ?expr, ?ann)) {\n@@ -1496,7 +1523,7 @@ mod Pushdown {\n                 // so there's no need.\n                 auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n-                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n+                write::ty_only_fixup(scx, ann.id, t);\n             }\n \n             case (_) {\n@@ -1513,14 +1540,14 @@ mod Pushdown {\n         alt (bloc.node.expr) {\n             case (some[@ast::expr](?e_0)) {\n                 pushdown_expr(scx, expected, e_0);\n-                write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                               bloc.node.a.id);\n+                write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                              bloc.node.a.id);\n             }\n             case (none[@ast::expr]) {\n                 Demand::simple(scx, bloc.span, expected,\n                                ty::mk_nil(scx.fcx.ccx.tcx));\n-                write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                               bloc.node.a.id);\n+                write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                              bloc.node.a.id);\n             }\n         }\n     }\n@@ -1544,7 +1571,8 @@ mod writeback {\n             }\n         }\n \n-        write_type_only(fcx.ccx.node_types, local.ann.id, local_ty);\n+        write::ty_only(fcx.ccx.tcx, fcx.ccx.node_types, local.ann.id,\n+                       local_ty);\n     }\n \n     fn resolve_local_types(&@fn_ctxt fcx, &ast::ann ann) {\n@@ -1562,7 +1590,8 @@ mod writeback {\n \n         auto f = bind resolver(fcx, _);\n         auto new_type = ty::fold_ty(fcx.ccx.tcx, f, tt);\n-        write_type(fcx.ccx.node_types, ann.id, tup(tpot._0, new_type));\n+        write::ty(fcx.ccx.tcx, fcx.ccx.node_types, ann.id,\n+                  tup(tpot._0, new_type));\n     }\n \n     fn visit_stmt_pre(@fn_ctxt fcx, &@ast::stmt s) {\n@@ -1617,17 +1646,17 @@ mod writeback {\n \n // AST fragment utilities\n \n-fn replace_expr_type(&node_type_table ntt,\n+fn replace_expr_type(&@stmt_ctxt scx,\n                      &@ast::expr expr,\n                      &tup(vec[ty::t], ty::t) new_tyt) {\n     auto new_tps;\n-    if (ty::expr_has_ty_params(ntt, expr)) {\n+    if (ty::expr_has_ty_params(scx.fcx.ccx.node_types, expr)) {\n         new_tps = some[vec[ty::t]](new_tyt._0);\n     } else {\n         new_tps = none[vec[ty::t]];\n     }\n \n-    write_type(ntt, ty::expr_ann(expr).id, tup(new_tps, new_tyt._1));\n+    write::ty_fixup(scx, ty::expr_ann(expr).id, tup(new_tps, new_tyt._1));\n }\n \n \n@@ -1653,16 +1682,16 @@ fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n     alt (pat.node) {\n         case (ast::pat_wild(?ann)) {\n             auto typ = next_ty_var(scx);\n-            write_type_only(scx.fcx.ccx.node_types, ann.id, typ);\n+            write::ty_only_fixup(scx, ann.id, typ);\n         }\n         case (ast::pat_lit(?lt, ?ann)) {\n             auto typ = check_lit(scx.fcx.ccx, lt);\n-            write_type_only(scx.fcx.ccx.node_types, ann.id, typ);\n+            write::ty_only_fixup(scx, ann.id, typ);\n         }\n         case (ast::pat_bind(?id, ?def_id, ?a)) {\n             auto typ = next_ty_var(scx);\n             auto ann = triv_ann(a.id, typ);\n-            write_type_only(scx.fcx.ccx.node_types, ann.id, typ);\n+            write::ty_only_fixup(scx, ann.id, typ);\n         }\n         case (ast::pat_tag(?p, ?subpats, ?old_ann)) {\n             auto vdef = ast::variant_def_ids\n@@ -1698,7 +1727,7 @@ fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n                         check_pat(scx, subpat);\n                     }\n \n-                    write_type(scx.fcx.ccx.node_types, old_ann.id, path_tpot);\n+                    write::ty_fixup(scx, old_ann.id, path_tpot);\n                 }\n \n                 // Nullary variants have tag types.\n@@ -1716,7 +1745,7 @@ fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n                         fail;   // TODO: recover\n                     }\n \n-                    write_type(scx.fcx.ccx.node_types, old_ann.id, path_tpot);\n+                    write::ty_fixup(scx, old_ann.id, path_tpot);\n                 }\n             }\n         }\n@@ -1840,7 +1869,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                                                scx.fcx.ccx.node_types, f);\n         auto tpt_1 = Demand::full(scx, f.span, tpt_0._1, t_0, tpt_0._0,\n                                   NO_AUTODEREF);\n-        replace_expr_type(scx.fcx.ccx.node_types, f, tpt_1);\n+        replace_expr_type(scx, f, tpt_1);\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1857,7 +1886,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         auto rhs_t1 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, rhs);\n \n         auto ann = triv_ann(a.id, rhs_t1);\n-        write_type_only(scx.fcx.ccx.node_types, a.id, rhs_t1);\n+        write::ty_only_fixup(scx, a.id, rhs_t1);\n     }\n \n     // A generic function for checking call expressions\n@@ -1874,7 +1903,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n     alt (expr.node) {\n         case (ast::expr_lit(?lit, ?a)) {\n             auto typ = check_lit(scx.fcx.ccx, lit);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+            write::ty_only_fixup(scx, a.id, typ);\n         }\n \n         case (ast::expr_binary(?binop, ?lhs, ?rhs, ?a)) {\n@@ -1902,7 +1931,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 case (_) { /* fall through */ }\n             }\n \n-            write_type_only(scx.fcx.ccx.node_types, a.id, t);\n+            write::ty_only_fixup(scx, a.id, t);\n         }\n \n         case (ast::expr_unary(?unop, ?oper, ?a)) {\n@@ -1929,7 +1958,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 case (_) { oper_t = strip_boxes(scx.fcx.ccx.tcx, oper_t); }\n             }\n \n-            write_type_only(scx.fcx.ccx.node_types, a.id, oper_t);\n+            write::ty_only_fixup(scx, a.id, oper_t);\n         }\n \n         case (ast::expr_path(?pth, ?old_ann)) {\n@@ -1941,7 +1970,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             if (ty::def_has_ty_params(defn)) {\n                 auto path_tpot = instantiate_path(scx, pth, tpt, expr.span);\n-                write_type(scx.fcx.ccx.node_types, old_ann.id, path_tpot);\n+                write::ty_fixup(scx, old_ann.id, path_tpot);\n                 ret;\n             }\n \n@@ -1953,26 +1982,26 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 fail;\n             }\n \n-            write_type_only(scx.fcx.ccx.node_types, old_ann.id, tpt._1);\n+            write::ty_only_fixup(scx, old_ann.id, tpt._1);\n         }\n \n         case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n             check_expr(scx, expanded);\n             auto t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                              expanded);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, t);\n+            write::ty_only_fixup(scx, a.id, t);\n         }\n \n         case (ast::expr_fail(?a)) {\n-            write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_break(?a)) {\n-            write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_cont(?a)) {\n-            write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_ret(?expr_opt, ?a)) {\n@@ -1985,16 +2014,16 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                             \"returning non-nil\");\n                     }\n \n-                    write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                   a.id);\n+                    write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  a.id);\n                 }\n \n                 case (some[@ast::expr](?e)) {\n                     check_expr(scx, e);\n                     Pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n-                    write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                   a.id);\n+                    write::bot_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  a.id);\n                 }\n             }\n         }\n@@ -2011,16 +2040,16 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                             \"put; in iterator yielding non-nil\");\n                     }\n \n-                    write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                   a.id);\n+                    write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  a.id);\n                 }\n \n                 case (some[@ast::expr](?e)) {\n                     check_expr(scx, e);\n                     Pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n-                    write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n-                                   a.id);\n+                    write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  a.id);\n                 }\n             }\n         }\n@@ -2032,12 +2061,12 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             check_expr(scx, e);\n             Pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n-            write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_log(?l, ?e, ?a)) {\n             auto expr_t = check_expr(scx, e);\n-            write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_check(?e, ?a)) {\n@@ -2065,9 +2094,8 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                             require_pure_function(scx.fcx.ccx, d_id,\n                                                   expr.span);\n \n-                            write_nil_type(scx.fcx.ccx.tcx,\n-                                           scx.fcx.ccx.node_types,\n-                                           a.id);\n+                            write::nil_ty(scx.fcx.ccx.tcx,\n+                                          scx.fcx.ccx.node_types, a.id);\n                         }\n                         case (_) {\n                            scx.fcx.ccx.sess.span_err(expr.span,\n@@ -2088,7 +2116,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e);\n             Demand::simple(scx, expr.span, ty::mk_bool(scx.fcx.ccx.tcx), ety);\n \n-            write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n+            write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_assign(?lhs, ?rhs, ?a)) {\n@@ -2120,7 +2148,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             }\n             Pushdown::pushdown_expr(scx, item_t, rhs);\n \n-            write_type_only(scx.fcx.ccx.node_types, a.id, chan_t);\n+            write::ty_only_fixup(scx, a.id, chan_t);\n         }\n \n         case (ast::expr_recv(?lhs, ?rhs, ?a)) {\n@@ -2142,7 +2170,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             }\n             Pushdown::pushdown_expr(scx, item_t, lhs);\n \n-            write_type_only(scx.fcx.ccx.node_types, a.id, item_t);\n+            write::ty_only_fixup(scx, a.id, item_t);\n         }\n \n         case (ast::expr_if(?cond, ?thn, ?elsopt, ?a)) {\n@@ -2169,7 +2197,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             Pushdown::pushdown_block(scx, elsopt_t, thn);\n \n-            write_type_only(scx.fcx.ccx.node_types, a.id, elsopt_t);\n+            write::ty_only_fixup(scx, a.id, elsopt_t);\n         }\n \n         case (ast::expr_for(?decl, ?seq, ?body, ?a)) {\n@@ -2181,7 +2209,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             // of the seq.\n \n             auto typ = ty::mk_nil(scx.fcx.ccx.tcx);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+            write::ty_only_fixup(scx, a.id, typ);\n         }\n \n         case (ast::expr_for_each(?decl, ?seq, ?body, ?a)) {\n@@ -2190,7 +2218,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             check_block(scx, body);\n \n             auto typ = ty::mk_nil(scx.fcx.ccx.tcx);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+            write::ty_only_fixup(scx, a.id, typ);\n         }\n \n         case (ast::expr_while(?cond, ?body, ?a)) {\n@@ -2199,7 +2227,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             check_block(scx, body);\n \n             auto typ = ty::mk_nil(scx.fcx.ccx.tcx);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+            write::ty_only_fixup(scx, a.id, typ);\n         }\n \n         case (ast::expr_do_while(?body, ?cond, ?a)) {\n@@ -2209,7 +2237,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             auto typ = block_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                                 body);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+            write::ty_only_fixup(scx, a.id, typ);\n         }\n \n         case (ast::expr_alt(?expr, ?arms, ?a)) {\n@@ -2252,7 +2280,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             Pushdown::pushdown_expr(scx, pattern_ty, expr);\n \n-            write_type_only(scx.fcx.ccx.node_types, a.id, result_ty);\n+            write::ty_only_fixup(scx, a.id, result_ty);\n         }\n \n         case (ast::expr_block(?b, ?a)) {\n@@ -2261,11 +2289,11 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 case (some[@ast::expr](?expr)) {\n                     auto typ = expr_ty(scx.fcx.ccx.tcx,\n                                        scx.fcx.ccx.node_types, expr);\n-                    write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+                    write::ty_only_fixup(scx, a.id, typ);\n                 }\n                 case (none[@ast::expr]) {\n                     auto typ = ty::mk_nil(scx.fcx.ccx.tcx);\n-                    write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+                    write::ty_only_fixup(scx, a.id, typ);\n                 }\n             }\n         }\n@@ -2304,7 +2332,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             }\n \n             auto t_1 = ty::mk_fn(scx.fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, t_1);\n+            write::ty_only_fixup(scx, a.id, t_1);\n         }\n \n         case (ast::expr_call(?f, ?args, ?a)) {\n@@ -2328,7 +2356,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 }\n             }\n \n-            write_type_only(scx.fcx.ccx.node_types, a.id, rt_1);\n+            write::ty_only_fixup(scx, a.id, rt_1);\n         }\n \n         case (ast::expr_self_method(?id, ?a)) {\n@@ -2353,7 +2381,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 case (_) { fail; }\n             }\n \n-            write_type_only(scx.fcx.ccx.node_types, a.id, t);\n+            write::ty_only_fixup(scx, a.id, t);\n \n             require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n         }\n@@ -2382,7 +2410,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             // FIXME: Other typechecks needed\n \n             auto typ = ty::mk_task(scx.fcx.ccx.tcx);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+            write::ty_only_fixup(scx, a.id, typ);\n         }\n \n         case (ast::expr_cast(?e, ?t, ?a)) {\n@@ -2399,7 +2427,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     \" as \" + ty_to_str(scx.fcx.ccx.tcx, t_1));\n             }\n \n-            write_type_only(scx.fcx.ccx.node_types, a.id, t_1);\n+            write::ty_only_fixup(scx, a.id, t_1);\n         }\n \n         case (ast::expr_vec(?args, ?mut, ?a)) {\n@@ -2420,7 +2448,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             }\n \n             auto typ = ty::mk_vec(scx.fcx.ccx.tcx, rec(ty=t, mut=mut));\n-            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+            write::ty_only_fixup(scx, a.id, typ);\n         }\n \n         case (ast::expr_tup(?elts, ?a)) {\n@@ -2434,7 +2462,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             }\n \n             auto typ = ty::mk_tup(scx.fcx.ccx.tcx, elts_mt);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+            write::ty_only_fixup(scx, a.id, typ);\n         }\n \n         case (ast::expr_rec(?fields, ?base, ?a)) {\n@@ -2458,7 +2486,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             alt (base) {\n                 case (none[@ast::expr]) {\n                     auto typ = ty::mk_rec(scx.fcx.ccx.tcx, fields_t);\n-                    write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+                    write::ty_only_fixup(scx, a.id, typ);\n                 }\n \n                 case (some[@ast::expr](?bexpr)) {\n@@ -2477,7 +2505,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                         }\n                     }\n \n-                    write_type_only(scx.fcx.ccx.node_types, a.id, bexpr_t);\n+                    write::ty_only_fixup(scx, a.id, bexpr_t);\n \n                     for (ty::field f in fields_t) {\n                         auto found = false;\n@@ -2512,8 +2540,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                         scx.fcx.ccx.sess.span_err(expr.span,\n                                                   \"bad index on tuple\");\n                     }\n-                    write_type_only(scx.fcx.ccx.node_types, a.id,\n-                                    args.(ix).ty);\n+                    write::ty_only_fixup(scx, a.id, args.(ix).ty);\n                 }\n \n                 case (ty::ty_rec(?fields)) {\n@@ -2523,8 +2550,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                         scx.fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    write_type_only(scx.fcx.ccx.node_types, a.id,\n-                                    fields.(ix).mt.ty);\n+                    write::ty_only_fixup(scx, a.id, fields.(ix).mt.ty);\n                 }\n \n                 case (ty::ty_obj(?methods)) {\n@@ -2537,7 +2563,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     auto meth = methods.(ix);\n                     auto t = ty::mk_fn(scx.fcx.ccx.tcx, meth.proto,\n                                        meth.inputs, meth.output);\n-                    write_type_only(scx.fcx.ccx.node_types, a.id, t);\n+                    write::ty_only_fixup(scx, a.id, t);\n                 }\n \n                 case (_) {\n@@ -2565,7 +2591,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(scx.fcx.ccx.tcx, idx_t));\n                     }\n-                    write_type_only(scx.fcx.ccx.node_types, a.id, mt.ty);\n+                    write::ty_only_fixup(scx, a.id, mt.ty);\n                 }\n                 case (ty::ty_str) {\n                     if (! type_is_integral(scx.fcx.ccx.tcx, idx_t)) {\n@@ -2575,7 +2601,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                              + ty_to_str(scx.fcx.ccx.tcx, idx_t));\n                     }\n                     auto typ = ty::mk_mach(scx.fcx.ccx.tcx, common::ty_u8);\n-                    write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n+                    write::ty_only_fixup(scx, a.id, typ);\n                 }\n                 case (_) {\n                     scx.fcx.ccx.sess.span_err\n@@ -2589,7 +2615,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         case (ast::expr_port(?a)) {\n             auto t = next_ty_var(scx);\n             auto pt = ty::mk_port(scx.fcx.ccx.tcx, t);\n-            write_type_only(scx.fcx.ccx.node_types, a.id, pt);\n+            write::ty_only_fixup(scx, a.id, pt);\n         }\n \n         case (ast::expr_chan(?x, ?a)) {\n@@ -2598,7 +2624,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             alt (struct(scx.fcx.ccx.tcx, port_t)) {\n                 case (ty::ty_port(?subtype)) {\n                     auto ct = ty::mk_chan(scx.fcx.ccx.tcx, subtype);\n-                    write_type_only(scx.fcx.ccx.node_types, a.id, ct);\n+                    write::ty_only_fixup(scx, a.id, ct);\n                 }\n                 case (_) {\n                     scx.fcx.ccx.sess.span_err(expr.span,\n@@ -2658,7 +2684,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n             }\n \n             auto a_res = local.ann;\n-            write_type_only(fcx.ccx.node_types, a_res.id, t);\n+            write::ty_only(fcx.ccx.tcx, fcx.ccx.node_types, a_res.id, t);\n \n             auto initopt = local.init;\n             alt (local.init) {\n@@ -2696,7 +2722,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) {\n         }\n     }\n \n-    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, node_id);\n+    write::nil_ty(fcx.ccx.tcx, fcx.ccx.node_types, node_id);\n }\n \n fn check_block(&@stmt_ctxt scx, &ast::block block) {\n@@ -2711,7 +2737,7 @@ fn check_block(&@stmt_ctxt scx, &ast::block block) {\n         }\n     }\n \n-    write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, block.node.a.id);\n+    write::nil_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, block.node.a.id);\n }\n \n fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::ann ann) {"}]}