{"sha": "ae24651e445444d4ed4275a717ac10980f2957a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMjQ2NTFlNDQ1NDQ0ZDRlZDQyNzVhNzE3YWMxMDk4MGYyOTU3YTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-21T23:18:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-21T23:18:19Z"}, "message": "Merge #8916\n\n8916: ItemTree pretty-printing r=jonas-schievink a=jonas-schievink\n\nThis adds a printer for `ItemTree` contents, and a few tests to ensure that `ItemTree` lowering works like we expect it to. It also adds a new \"Debug ItemTree\" command that can be used to see the `ItemTree` of the currently open file. The pretty-printed output is usually close enough to Rust syntax that we can even use Rust syntax highlighting.\r\n\r\nThis is similar to the old `ItemTree` tests we had, but produces significantly more readable output, so these should actually carry their weight.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "9ae9115957ab35a3bc7d2d446bce72031328af1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ae9115957ab35a3bc7d2d446bce72031328af1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae24651e445444d4ed4275a717ac10980f2957a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgqD+7CRBK7hj4Ov3rIwAATfMIAADu1v76wNI++w16VM5RChdz\nj5lQq4wsSU575mzB2rPUY+wMMl/vxWF2Q+Hx+tzmvzVo3P/djg3uJDhE0sCekqxA\n+TenKQBtvD60GCr4chFCFNRtprRifNUPP7Nt0TWJmE2uIhhPkhco7T0NQYyj19oQ\n/kLHTWRv3FwCp8cnaGcuFEac6YYSxptMvMnORJdSxTWZg0y+FXrRruMVYquunDWP\nb92UROCdf0WnT1sqXmLZPhfiW0cvG5FV6qm8XrcKk4JnOlDfieXvpDulKHvJtbHj\nermNpog2LNXz17aq1UzZw/m7choVKJLATPIvhhRIVdpl7VPn+iojR0Vow5A2Uwk=\n=Wxys\n-----END PGP SIGNATURE-----\n", "payload": "tree 9ae9115957ab35a3bc7d2d446bce72031328af1a\nparent 5b6c0c1af290996a407fb4be51e852317dfab7c2\nparent 463ecefc64a48d80b2c4591fd4a1b82ae62b2897\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621639099 +0000\ncommitter GitHub <noreply@github.com> 1621639099 +0000\n\nMerge #8916\n\n8916: ItemTree pretty-printing r=jonas-schievink a=jonas-schievink\n\nThis adds a printer for `ItemTree` contents, and a few tests to ensure that `ItemTree` lowering works like we expect it to. It also adds a new \"Debug ItemTree\" command that can be used to see the `ItemTree` of the currently open file. The pretty-printed output is usually close enough to Rust syntax that we can even use Rust syntax highlighting.\r\n\r\nThis is similar to the old `ItemTree` tests we had, but produces significantly more readable output, so these should actually carry their weight.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae24651e445444d4ed4275a717ac10980f2957a4", "html_url": "https://github.com/rust-lang/rust/commit/ae24651e445444d4ed4275a717ac10980f2957a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae24651e445444d4ed4275a717ac10980f2957a4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b6c0c1af290996a407fb4be51e852317dfab7c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b6c0c1af290996a407fb4be51e852317dfab7c2", "html_url": "https://github.com/rust-lang/rust/commit/5b6c0c1af290996a407fb4be51e852317dfab7c2"}, {"sha": "463ecefc64a48d80b2c4591fd4a1b82ae62b2897", "url": "https://api.github.com/repos/rust-lang/rust/commits/463ecefc64a48d80b2c4591fd4a1b82ae62b2897", "html_url": "https://github.com/rust-lang/rust/commit/463ecefc64a48d80b2c4591fd4a1b82ae62b2897"}], "stats": {"total": 928, "additions": 925, "deletions": 3}, "files": [{"sha": "89a1ea77099ada06aad8cec7b056956b9b2d691c", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -2,7 +2,7 @@\n \n use std::{\n     convert::{TryFrom, TryInto},\n-    ops,\n+    fmt, ops,\n     sync::Arc,\n };\n \n@@ -648,6 +648,15 @@ pub enum AttrInput {\n     TokenTree(Subtree),\n }\n \n+impl fmt::Display for AttrInput {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AttrInput::Literal(lit) => write!(f, \" = \\\"{}\\\"\", lit.escape_debug()),\n+            AttrInput::TokenTree(subtree) => subtree.fmt(f),\n+        }\n+    }\n+}\n+\n impl Attr {\n     fn from_src(\n         db: &dyn DefDatabase,"}, {"sha": "528270d49d3e084f730706441c9c327a885ee5c9", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -1,6 +1,9 @@\n //! A simplified AST that only contains items.\n \n mod lower;\n+mod pretty;\n+#[cfg(test)]\n+mod tests;\n \n use std::{\n     any::type_name,\n@@ -205,6 +208,10 @@ impl ItemTree {\n         }\n     }\n \n+    pub fn pretty_print(&self) -> String {\n+        pretty::print_item_tree(self)\n+    }\n+\n     fn data(&self) -> &ItemTreeData {\n         self.data.as_ref().expect(\"attempted to access data of empty ItemTree\")\n     }\n@@ -776,6 +783,10 @@ impl<T> IdRange<T> {\n     fn new(range: Range<Idx<T>>) -> Self {\n         Self { range: range.start.into_raw().into()..range.end.into_raw().into(), _p: PhantomData }\n     }\n+\n+    fn is_empty(&self) -> bool {\n+        self.range.is_empty()\n+    }\n }\n \n impl<T> Iterator for IdRange<T> {"}, {"sha": "5ec02d1be74c7e4f5ad76a9a33adcb90862af3b5", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -0,0 +1,525 @@\n+//! `ItemTree` debug printer.\n+\n+use std::fmt::{self, Write};\n+\n+use crate::{attr::RawAttrs, visibility::RawVisibility};\n+\n+use super::*;\n+\n+pub(super) fn print_item_tree(tree: &ItemTree) -> String {\n+    let mut p = Printer { tree, buf: String::new(), indent_level: 0, needs_indent: true };\n+\n+    if let Some(attrs) = tree.attrs.get(&AttrOwner::TopLevel) {\n+        p.print_attrs(attrs, true);\n+    }\n+    p.blank();\n+\n+    for item in tree.top_level_items() {\n+        p.print_mod_item(*item);\n+    }\n+\n+    let mut s = p.buf.trim_end_matches('\\n').to_string();\n+    s.push('\\n');\n+    s\n+}\n+\n+macro_rules! w {\n+    ($dst:expr, $($arg:tt)*) => {\n+        drop(write!($dst, $($arg)*))\n+    };\n+}\n+\n+macro_rules! wln {\n+    ($dst:expr) => {\n+        drop(writeln!($dst))\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n+        drop(writeln!($dst, $($arg)*))\n+    };\n+}\n+\n+struct Printer<'a> {\n+    tree: &'a ItemTree,\n+    buf: String,\n+    indent_level: usize,\n+    needs_indent: bool,\n+}\n+\n+impl<'a> Printer<'a> {\n+    fn indented(&mut self, f: impl FnOnce(&mut Self)) {\n+        self.indent_level += 1;\n+        wln!(self);\n+        f(self);\n+        self.indent_level -= 1;\n+        self.buf = self.buf.trim_end_matches('\\n').to_string();\n+    }\n+\n+    /// Ensures that a blank line is output before the next text.\n+    fn blank(&mut self) {\n+        let mut iter = self.buf.chars().rev().fuse();\n+        match (iter.next(), iter.next()) {\n+            (Some('\\n'), Some('\\n')) | (Some('\\n'), None) | (None, None) => {}\n+            (Some('\\n'), Some(_)) => {\n+                self.buf.push('\\n');\n+            }\n+            (Some(_), _) => {\n+                self.buf.push('\\n');\n+                self.buf.push('\\n');\n+            }\n+            (None, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n+    fn print_attrs(&mut self, attrs: &RawAttrs, inner: bool) {\n+        let inner = if inner { \"!\" } else { \"\" };\n+        for attr in &**attrs {\n+            wln!(\n+                self,\n+                \"#{}[{}{}]  // {:?}\",\n+                inner,\n+                attr.path,\n+                attr.input.as_ref().map(|it| it.to_string()).unwrap_or_default(),\n+                attr.id,\n+            );\n+        }\n+    }\n+\n+    fn print_attrs_of(&mut self, of: impl Into<AttrOwner>) {\n+        if let Some(attrs) = self.tree.attrs.get(&of.into()) {\n+            self.print_attrs(attrs, false);\n+        }\n+    }\n+\n+    fn print_visibility(&mut self, vis: RawVisibilityId) {\n+        match &self.tree[vis] {\n+            RawVisibility::Module(path) => w!(self, \"pub({}) \", path),\n+            RawVisibility::Public => w!(self, \"pub \"),\n+        };\n+    }\n+\n+    fn print_fields(&mut self, fields: &Fields) {\n+        match fields {\n+            Fields::Record(fields) => {\n+                w!(self, \" {{\");\n+                self.indented(|this| {\n+                    for field in fields.clone() {\n+                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        this.print_attrs_of(field);\n+                        this.print_visibility(*visibility);\n+                        w!(this, \"{}: \", name);\n+                        this.print_type_ref(type_ref);\n+                        wln!(this, \",\");\n+                    }\n+                });\n+                w!(self, \"}}\");\n+            }\n+            Fields::Tuple(fields) => {\n+                w!(self, \"(\");\n+                self.indented(|this| {\n+                    for field in fields.clone() {\n+                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        this.print_attrs_of(field);\n+                        this.print_visibility(*visibility);\n+                        w!(this, \"{}: \", name);\n+                        this.print_type_ref(type_ref);\n+                        wln!(this, \",\");\n+                    }\n+                });\n+                w!(self, \")\");\n+            }\n+            Fields::Unit => {}\n+        }\n+    }\n+\n+    fn print_mod_item(&mut self, item: ModItem) {\n+        self.print_attrs_of(item);\n+\n+        match item {\n+            ModItem::Import(it) => {\n+                let Import { visibility, path, is_glob, alias, ast_id: _, index } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"use {}\", path);\n+                if *is_glob {\n+                    w!(self, \"::*\");\n+                }\n+                if let Some(alias) = alias {\n+                    w!(self, \" as {}\", alias);\n+                }\n+                wln!(self, \";  // {}\", index);\n+            }\n+            ModItem::ExternCrate(it) => {\n+                let ExternCrate { name, alias, visibility, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"extern crate {}\", name);\n+                if let Some(alias) = alias {\n+                    w!(self, \" as {}\", alias);\n+                }\n+                wln!(self, \";\");\n+            }\n+            ModItem::ExternBlock(it) => {\n+                let ExternBlock { abi, ast_id: _, children } = &self.tree[it];\n+                w!(self, \"extern \");\n+                if let Some(abi) = abi {\n+                    w!(self, \"\\\"{}\\\" \", abi);\n+                }\n+                w!(self, \"{{\");\n+                self.indented(|this| {\n+                    for child in &**children {\n+                        this.print_mod_item(*child);\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::Function(it) => {\n+                let Function {\n+                    name,\n+                    visibility,\n+                    generic_params: _, // FIXME print these somehow\n+                    abi,\n+                    params,\n+                    ret_type,\n+                    ast_id: _,\n+                    flags,\n+                } = &self.tree[it];\n+                if flags.bits != 0 {\n+                    wln!(self, \"// flags = 0x{:X}\", flags.bits);\n+                }\n+                self.print_visibility(*visibility);\n+                if let Some(abi) = abi {\n+                    w!(self, \"extern \\\"{}\\\" \", abi);\n+                }\n+                w!(self, \"fn {}(\", name);\n+                if !params.is_empty() {\n+                    self.indented(|this| {\n+                        for param in params.clone() {\n+                            this.print_attrs_of(param);\n+                            match &this.tree[param] {\n+                                Param::Normal(ty) => {\n+                                    w!(this, \"_: \");\n+                                    this.print_type_ref(ty);\n+                                    wln!(this, \",\");\n+                                }\n+                                Param::Varargs => {\n+                                    wln!(this, \"...\");\n+                                }\n+                            };\n+                        }\n+                    });\n+                }\n+                w!(self, \") -> \");\n+                self.print_type_ref(ret_type);\n+                wln!(self, \";\");\n+            }\n+            ModItem::Struct(it) => {\n+                let Struct { visibility, name, fields, generic_params: _, ast_id: _ } =\n+                    &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"struct {}\", name);\n+                self.print_fields(fields);\n+                if matches!(fields, Fields::Record(_)) {\n+                    wln!(self);\n+                } else {\n+                    wln!(self, \";\");\n+                }\n+            }\n+            ModItem::Union(it) => {\n+                let Union { name, visibility, fields, generic_params: _, ast_id: _ } =\n+                    &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"union {}\", name);\n+                self.print_fields(fields);\n+                if matches!(fields, Fields::Record(_)) {\n+                    wln!(self);\n+                } else {\n+                    wln!(self, \";\");\n+                }\n+            }\n+            ModItem::Enum(it) => {\n+                let Enum { name, visibility, variants, generic_params: _, ast_id: _ } =\n+                    &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"enum {} {{\", name);\n+                self.indented(|this| {\n+                    for variant in variants.clone() {\n+                        let Variant { name, fields } = &this.tree[variant];\n+                        this.print_attrs_of(variant);\n+                        w!(this, \"{}\", name);\n+                        this.print_fields(fields);\n+                        wln!(this, \",\");\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::Const(it) => {\n+                let Const { name, visibility, type_ref, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"const \");\n+                match name {\n+                    Some(name) => w!(self, \"{}\", name),\n+                    None => w!(self, \"_\"),\n+                }\n+                w!(self, \": \");\n+                self.print_type_ref(type_ref);\n+                wln!(self, \" = _;\");\n+            }\n+            ModItem::Static(it) => {\n+                let Static { name, visibility, mutable, is_extern, type_ref, ast_id: _ } =\n+                    &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"static \");\n+                if *mutable {\n+                    w!(self, \"mut \");\n+                }\n+                w!(self, \"{}: \", name);\n+                self.print_type_ref(type_ref);\n+                w!(self, \" = _;\");\n+                if *is_extern {\n+                    w!(self, \"  // extern\");\n+                }\n+                wln!(self);\n+            }\n+            ModItem::Trait(it) => {\n+                let Trait {\n+                    name,\n+                    visibility,\n+                    is_auto,\n+                    is_unsafe,\n+                    bounds,\n+                    items,\n+                    generic_params: _,\n+                    ast_id: _,\n+                } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                if *is_unsafe {\n+                    w!(self, \"unsafe \");\n+                }\n+                if *is_auto {\n+                    w!(self, \"auto \");\n+                }\n+                w!(self, \"trait {}\", name);\n+                if !bounds.is_empty() {\n+                    w!(self, \": \");\n+                    self.print_type_bounds(bounds);\n+                }\n+                w!(self, \" {{\");\n+                self.indented(|this| {\n+                    for item in &**items {\n+                        this.print_mod_item((*item).into());\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::Impl(it) => {\n+                let Impl {\n+                    target_trait,\n+                    self_ty,\n+                    is_negative,\n+                    items,\n+                    generic_params: _,\n+                    ast_id: _,\n+                } = &self.tree[it];\n+                w!(self, \"impl \");\n+                if *is_negative {\n+                    w!(self, \"!\");\n+                }\n+                if let Some(tr) = target_trait {\n+                    self.print_path(&tr.path);\n+                    w!(self, \" for \");\n+                }\n+                self.print_type_ref(self_ty);\n+                w!(self, \" {{\");\n+                self.indented(|this| {\n+                    for item in &**items {\n+                        this.print_mod_item((*item).into());\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::TypeAlias(it) => {\n+                let TypeAlias {\n+                    name,\n+                    visibility,\n+                    bounds,\n+                    type_ref,\n+                    is_extern,\n+                    generic_params: _,\n+                    ast_id: _,\n+                } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"type {}\", name);\n+                if !bounds.is_empty() {\n+                    w!(self, \": \");\n+                    self.print_type_bounds(bounds);\n+                }\n+                if let Some(ty) = type_ref {\n+                    w!(self, \" = \");\n+                    self.print_type_ref(ty);\n+                }\n+                w!(self, \";\");\n+                if *is_extern {\n+                    w!(self, \"  // extern\");\n+                }\n+                wln!(self);\n+            }\n+            ModItem::Mod(it) => {\n+                let Mod { name, visibility, kind, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"mod {}\", name);\n+                match kind {\n+                    ModKind::Inline { items } => {\n+                        w!(self, \" {{\");\n+                        self.indented(|this| {\n+                            for item in &**items {\n+                                this.print_mod_item((*item).into());\n+                            }\n+                        });\n+                        wln!(self, \"}}\");\n+                    }\n+                    ModKind::Outline {} => {\n+                        wln!(self, \";\");\n+                    }\n+                }\n+            }\n+            ModItem::MacroCall(it) => {\n+                let MacroCall { path, ast_id: _, fragment: _ } = &self.tree[it];\n+                wln!(self, \"{}!(...);\", path);\n+            }\n+            ModItem::MacroRules(it) => {\n+                let MacroRules { name, ast_id: _ } = &self.tree[it];\n+                wln!(self, \"macro_rules! {} {{ ... }}\", name);\n+            }\n+            ModItem::MacroDef(it) => {\n+                let MacroDef { name, visibility, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                wln!(self, \"macro {} {{ ... }}\", name);\n+            }\n+        }\n+\n+        self.blank();\n+    }\n+\n+    fn print_type_ref(&mut self, type_ref: &TypeRef) {\n+        // FIXME: deduplicate with `HirDisplay` impl\n+        match type_ref {\n+            TypeRef::Never => w!(self, \"!\"),\n+            TypeRef::Placeholder => w!(self, \"_\"),\n+            TypeRef::Tuple(fields) => {\n+                w!(self, \"(\");\n+                for (i, field) in fields.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_type_ref(field);\n+                }\n+                w!(self, \")\");\n+            }\n+            TypeRef::Path(path) => self.print_path(path),\n+            TypeRef::RawPtr(pointee, mtbl) => {\n+                let mtbl = match mtbl {\n+                    Mutability::Shared => \"*const\",\n+                    Mutability::Mut => \"*mut\",\n+                };\n+                w!(self, \"{} \", mtbl);\n+                self.print_type_ref(pointee);\n+            }\n+            TypeRef::Reference(pointee, lt, mtbl) => {\n+                let mtbl = match mtbl {\n+                    Mutability::Shared => \"\",\n+                    Mutability::Mut => \"mut \",\n+                };\n+                w!(self, \"&\");\n+                if let Some(lt) = lt {\n+                    w!(self, \"{} \", lt.name);\n+                }\n+                w!(self, \"{}\", mtbl);\n+                self.print_type_ref(pointee);\n+            }\n+            TypeRef::Array(elem, len) => {\n+                w!(self, \"[\");\n+                self.print_type_ref(elem);\n+                w!(self, \"; {}]\", len);\n+            }\n+            TypeRef::Slice(elem) => {\n+                w!(self, \"[\");\n+                self.print_type_ref(elem);\n+                w!(self, \"]\");\n+            }\n+            TypeRef::Fn(args_and_ret, varargs) => {\n+                let (ret, args) =\n+                    args_and_ret.split_last().expect(\"TypeRef::Fn is missing return type\");\n+                w!(self, \"fn(\");\n+                for (i, arg) in args.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_type_ref(arg);\n+                }\n+                if *varargs {\n+                    if !args.is_empty() {\n+                        w!(self, \", \");\n+                    }\n+                    w!(self, \"...\");\n+                }\n+                w!(self, \") -> \");\n+                self.print_type_ref(ret);\n+            }\n+            TypeRef::Macro(_ast_id) => {\n+                w!(self, \"<macro>\");\n+            }\n+            TypeRef::Error => drop(write!(self, \"{{unknown}}\")),\n+            TypeRef::ImplTrait(bounds) => {\n+                w!(self, \"impl \");\n+                self.print_type_bounds(bounds);\n+            }\n+            TypeRef::DynTrait(bounds) => {\n+                w!(self, \"dyn \");\n+                self.print_type_bounds(bounds);\n+            }\n+        }\n+    }\n+\n+    fn print_type_bounds(&mut self, bounds: &[TypeBound]) {\n+        for (i, bound) in bounds.iter().enumerate() {\n+            if i != 0 {\n+                w!(self, \" + \");\n+            }\n+\n+            match bound {\n+                TypeBound::Path(path) => self.print_path(path),\n+                TypeBound::Lifetime(lt) => w!(self, \"{}\", lt.name),\n+                TypeBound::Error => w!(self, \"{{unknown}}\"),\n+            }\n+        }\n+    }\n+\n+    fn print_path(&mut self, path: &Path) {\n+        if path.type_anchor().is_none()\n+            && path.segments().iter().all(|seg| seg.args_and_bindings.is_none())\n+        {\n+            w!(self, \"{}\", path.mod_path());\n+        } else {\n+            // too complicated, just use `Debug`\n+            w!(self, \"{:?}\", path);\n+        }\n+    }\n+}\n+\n+impl<'a> Write for Printer<'a> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        for line in s.split_inclusive('\\n') {\n+            if self.needs_indent {\n+                match self.buf.chars().last() {\n+                    Some('\\n') | None => {}\n+                    _ => self.buf.push('\\n'),\n+                }\n+                self.buf.push_str(&\"    \".repeat(self.indent_level));\n+                self.needs_indent = false;\n+            }\n+\n+            self.buf.push_str(line);\n+            self.needs_indent = line.ends_with('\\n');\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "100ae9b97a24b49806eeb316bde0d7752c2e0fce", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -0,0 +1,244 @@\n+use base_db::fixture::WithFixture;\n+use expect_test::{expect, Expect};\n+\n+use crate::{db::DefDatabase, test_db::TestDB};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let item_tree = db.file_item_tree(file_id.into());\n+    let pretty = item_tree.pretty_print();\n+    expect.assert_eq(&pretty);\n+}\n+\n+#[test]\n+fn imports() {\n+    check(\n+        r#\"\n+//! file comment\n+#![no_std]\n+//! another file comment\n+\n+extern crate self as renamed;\n+pub(super) extern crate bli;\n+\n+pub use crate::path::{nested, items as renamed, Trait as _};\n+use globs::*;\n+\n+/// docs on import\n+use crate::{A, B};\n+        \"#,\n+        expect![[r##\"\n+            #![doc = \" file comment\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+            #![no_std]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+            #![doc = \" another file comment\"]  // AttrId { is_doc_comment: true, ast_index: 1 }\n+\n+            pub(self) extern crate self as renamed;\n+\n+            pub(super) extern crate bli;\n+\n+            pub use crate::path::nested;  // 0\n+\n+            pub use crate::path::items as renamed;  // 1\n+\n+            pub use crate::path::Trait as _;  // 2\n+\n+            pub(self) use globs::*;  // 0\n+\n+            #[doc = \" docs on import\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+            pub(self) use crate::A;  // 0\n+\n+            #[doc = \" docs on import\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+            pub(self) use crate::B;  // 1\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn extern_blocks() {\n+    check(\n+        r#\"\n+#[on_extern_block]\n+extern \"C\" {\n+    #[on_extern_type]\n+    type ExType;\n+\n+    #[on_extern_static]\n+    static EX_STATIC: u8;\n+\n+    #[on_extern_fn]\n+    fn ex_fn();\n+}\n+        \"#,\n+        expect![[r##\"\n+            #[on_extern_block]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+            extern \"C\" {\n+                #[on_extern_type]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                pub(self) type ExType;  // extern\n+\n+                #[on_extern_static]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                pub(self) static EX_STATIC: u8 = _;  // extern\n+\n+                #[on_extern_fn]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                // flags = 0x60\n+                pub(self) fn ex_fn() -> ();\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn adts() {\n+    check(\n+        r#\"\n+struct Unit;\n+\n+#[derive(Debug)]\n+struct Struct {\n+    /// fld docs\n+    fld: (),\n+}\n+\n+struct Tuple(#[attr] u8);\n+\n+union Ize {\n+    a: (),\n+    b: (),\n+}\n+\n+enum E {\n+    /// comment on Unit\n+    Unit,\n+    /// comment on Tuple\n+    Tuple(u8),\n+    Struct {\n+        /// comment on a: u8\n+        a: u8,\n+    }\n+}\n+        \"#,\n+        expect![[r##\"\n+            pub(self) struct Unit;\n+\n+            #[derive(Debug)]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+            pub(self) struct Struct {\n+                #[doc = \" fld docs\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+                pub(self) fld: (),\n+            }\n+\n+            pub(self) struct Tuple(\n+                #[attr]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                pub(self) 0: u8,\n+            );\n+\n+            pub(self) union Ize {\n+                pub(self) a: (),\n+                pub(self) b: (),\n+            }\n+\n+            pub(self) enum E {\n+                #[doc = \" comment on Unit\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+                Unit,\n+                #[doc = \" comment on Tuple\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+                Tuple(\n+                    pub(self) 0: u8,\n+                ),\n+                Struct {\n+                    #[doc = \" comment on a: u8\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+                    pub(self) a: u8,\n+                },\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn misc() {\n+    check(\n+        r#\"\n+pub static mut ST: () = ();\n+\n+const _: Anon = ();\n+\n+#[attr]\n+fn f(#[attr] arg: u8, _: ()) {\n+    #![inner_attr_in_fn]\n+}\n+\n+trait Tr: SuperTrait + 'lifetime {\n+    type Assoc: AssocBound = Default;\n+    fn method(&self);\n+}\n+        \"#,\n+        expect![[r##\"\n+            pub static mut ST: () = _;\n+\n+            pub(self) const _: Anon = _;\n+\n+            #[attr]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+            #[inner_attr_in_fn]  // AttrId { is_doc_comment: false, ast_index: 1 }\n+            // flags = 0x2\n+            pub(self) fn f(\n+                #[attr]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                _: u8,\n+                _: (),\n+            ) -> ();\n+\n+            pub(self) trait Tr: SuperTrait + 'lifetime {\n+                pub(self) type Assoc: AssocBound = Default;\n+\n+                // flags = 0x1\n+                pub(self) fn method(\n+                    _: &Self,\n+                ) -> ();\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn modules() {\n+    check(\n+        r#\"\n+/// outer\n+mod inline {\n+    //! inner\n+\n+    use super::*;\n+\n+    fn fn_in_module() {}\n+}\n+        \"#,\n+        expect![[r##\"\n+            #[doc = \" outer\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+            #[doc = \" inner\"]  // AttrId { is_doc_comment: true, ast_index: 1 }\n+            pub(self) mod inline {\n+                pub(self) use super::*;  // 0\n+\n+                // flags = 0x2\n+                pub(self) fn fn_in_module() -> ();\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn macros() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    () => {};\n+}\n+\n+pub macro m2() {}\n+\n+m!();\n+        \"#,\n+        expect![[r#\"\n+            macro_rules! m { ... }\n+\n+            pub macro m2 { ... }\n+\n+            m!(...);\n+        \"#]],\n+    );\n+}"}, {"sha": "9b8873fd25828f17089bfe0857bedf3684bbb7c4", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -46,6 +46,15 @@ pub enum ImportAlias {\n     Alias(Name),\n }\n \n+impl Display for ImportAlias {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ImportAlias::Underscore => f.write_str(\"_\"),\n+            ImportAlias::Alias(name) => f.write_str(&name.to_string()),\n+        }\n+    }\n+}\n+\n impl ModPath {\n     pub fn from_src(db: &dyn DefDatabase, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n         let ctx = LowerCtx::with_hygiene(db, hygiene);"}, {"sha": "ff2a54117bb2f4f1eb7601500d2fde0e23ecf430", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -50,6 +50,7 @@ mod typing;\n mod markdown_remove;\n mod doc_links;\n mod view_crate_graph;\n+mod view_item_tree;\n \n use std::sync::Arc;\n \n@@ -288,6 +289,10 @@ impl Analysis {\n         self.with_db(|db| view_hir::view_hir(&db, position))\n     }\n \n+    pub fn view_item_tree(&self, file_id: FileId) -> Cancelable<String> {\n+        self.with_db(|db| view_item_tree::view_item_tree(&db, file_id))\n+    }\n+\n     /// Renders the crate graph to GraphViz \"dot\" syntax.\n     pub fn view_crate_graph(&self) -> Cancelable<Result<String, String>> {\n         self.with_db(|db| view_crate_graph::view_crate_graph(&db))"}, {"sha": "3dc03085d651c9f0f2727341f29c8ade90274430", "filename": "crates/ide/src/view_item_tree.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fide%2Fsrc%2Fview_item_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Fide%2Fsrc%2Fview_item_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fview_item_tree.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -0,0 +1,16 @@\n+use hir::db::DefDatabase;\n+use ide_db::base_db::FileId;\n+use ide_db::RootDatabase;\n+\n+// Feature: Debug ItemTree\n+//\n+// Displays the ItemTree of the currently open file, for debugging.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Debug ItemTree**\n+// |===\n+pub(crate) fn view_item_tree(db: &RootDatabase, file_id: FileId) -> String {\n+    db.file_item_tree(file_id.into()).pretty_print()\n+}"}, {"sha": "aa12fd94bd95d677faa3344ddd166bc737e6e79b", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -117,6 +117,16 @@ pub(crate) fn handle_view_hir(\n     Ok(res)\n }\n \n+pub(crate) fn handle_view_item_tree(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::ViewItemTreeParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_view_item_tree\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let res = snap.analysis.view_item_tree(file_id)?;\n+    Ok(res)\n+}\n+\n pub(crate) fn handle_view_crate_graph(snap: GlobalStateSnapshot, (): ()) -> Result<String> {\n     let _p = profile::span(\"handle_view_crate_graph\");\n     let dot = snap.analysis.view_crate_graph()??;"}, {"sha": "90504879304a07591a0998c4f6b16d617abf74e5", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -70,6 +70,20 @@ impl Request for ViewCrateGraph {\n     const METHOD: &'static str = \"rust-analyzer/viewCrateGraph\";\n }\n \n+#[derive(Deserialize, Serialize, Debug)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ViewItemTreeParams {\n+    pub text_document: TextDocumentIdentifier,\n+}\n+\n+pub enum ViewItemTree {}\n+\n+impl Request for ViewItemTree {\n+    type Params = ViewItemTreeParams;\n+    type Result = String;\n+    const METHOD: &'static str = \"rust-analyzer/viewItemTree\";\n+}\n+\n pub enum ExpandMacro {}\n \n impl Request for ExpandMacro {"}, {"sha": "f837b89ddc91f88e9f0ef4343c5c136297467bae", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -514,6 +514,7 @@ impl GlobalState {\n             .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)\n             .on::<lsp_ext::ViewHir>(handlers::handle_view_hir)\n             .on::<lsp_ext::ViewCrateGraph>(handlers::handle_view_crate_graph)\n+            .on::<lsp_ext::ViewItemTree>(handlers::handle_view_item_tree)\n             .on::<lsp_ext::ExpandMacro>(handlers::handle_expand_macro)\n             .on::<lsp_ext::ParentModule>(handlers::handle_parent_module)\n             .on::<lsp_ext::Runnables>(handlers::handle_runnables)"}, {"sha": "fbe2ce1c93887a49375eb9d8feed0a6bbcb9a866", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: 10a8988e6893e6b2\n+lsp_ext.rs hash: 49f253e4a9307d4f\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:\n@@ -464,7 +464,7 @@ Clients are discouraged from but are allowed to use the `health` status to decid\n **Request:**\n \n ```typescript\n-interface SyntaxTeeParams {\n+interface SyntaxTreeParams {\n     textDocument: TextDocumentIdentifier,\n     range?: Range,\n }\n@@ -486,6 +486,22 @@ Primarily for debugging, but very useful for all people working on rust-analyzer\n Returns a textual representation of the HIR of the function containing the cursor.\n For debugging or when working on rust-analyzer itself.\n \n+## View ItemTree\n+\n+**Method:** `rust-analyzer/viewItemTree`\n+\n+**Request:**\n+\n+```typescript\n+interface ViewItemTreeParams {\n+    textDocument: TextDocumentIdentifier,\n+}\n+```\n+\n+**Response:** `string`\n+\n+Returns a textual representation of the `ItemTree` of the currently open file, for debugging.\n+\n ## View Crate Graph\n \n **Method:** `rust-analyzer/viewCrateGraph`"}, {"sha": "17d9281ff74955e1025d88398b35ebbf1284d11c", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -109,6 +109,11 @@\n                 \"title\": \"View Hir\",\n                 \"category\": \"Rust Analyzer\"\n             },\n+            {\n+                \"command\": \"rust-analyzer.viewItemTree\",\n+                \"title\": \"Debug ItemTree\",\n+                \"category\": \"Rust Analyzer\"\n+            },\n             {\n                 \"command\": \"rust-analyzer.viewCrateGraph\",\n                 \"title\": \"View Crate Graph\","}, {"sha": "0fdb9fe058ffea53180cbe7a74172ee3a4044922", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -429,6 +429,56 @@ export function viewHir(ctx: Ctx): Cmd {\n     };\n }\n \n+export function viewItemTree(ctx: Ctx): Cmd {\n+    const tdcp = new class implements vscode.TextDocumentContentProvider {\n+        readonly uri = vscode.Uri.parse('rust-analyzer://viewItemTree/itemtree.rs');\n+        readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n+        constructor() {\n+            vscode.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, ctx.subscriptions);\n+            vscode.window.onDidChangeActiveTextEditor(this.onDidChangeActiveTextEditor, this, ctx.subscriptions);\n+        }\n+\n+        private onDidChangeTextDocument(event: vscode.TextDocumentChangeEvent) {\n+            if (isRustDocument(event.document)) {\n+                // We need to order this after language server updates, but there's no API for that.\n+                // Hence, good old sleep().\n+                void sleep(10).then(() => this.eventEmitter.fire(this.uri));\n+            }\n+        }\n+        private onDidChangeActiveTextEditor(editor: vscode.TextEditor | undefined) {\n+            if (editor && isRustEditor(editor)) {\n+                this.eventEmitter.fire(this.uri);\n+            }\n+        }\n+\n+        provideTextDocumentContent(_uri: vscode.Uri, ct: vscode.CancellationToken): vscode.ProviderResult<string> {\n+            const rustEditor = ctx.activeRustEditor;\n+            const client = ctx.client;\n+            if (!rustEditor || !client) return '';\n+\n+            const params = {\n+                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(rustEditor.document),\n+            };\n+            return client.sendRequest(ra.viewItemTree, params, ct);\n+        }\n+\n+        get onDidChange(): vscode.Event<vscode.Uri> {\n+            return this.eventEmitter.event;\n+        }\n+    };\n+\n+    ctx.pushCleanup(vscode.workspace.registerTextDocumentContentProvider('rust-analyzer', tdcp));\n+\n+    return async () => {\n+        const document = await vscode.workspace.openTextDocument(tdcp.uri);\n+        tdcp.eventEmitter.fire(tdcp.uri);\n+        void await vscode.window.showTextDocument(document, {\n+            viewColumn: vscode.ViewColumn.Two,\n+            preserveFocus: true\n+        });\n+    };\n+}\n+\n export function viewCrateGraph(ctx: Ctx): Cmd {\n     return async () => {\n         const panel = vscode.window.createWebviewPanel(\"rust-analyzer.crate-graph\", \"rust-analyzer crate graph\", vscode.ViewColumn.Two);"}, {"sha": "6d5c2ea72dc224a68b5a9f151670c9d53d1354f4", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -27,6 +27,12 @@ export const syntaxTree = new lc.RequestType<SyntaxTreeParams, string, void>(\"ru\n \n export const viewHir = new lc.RequestType<lc.TextDocumentPositionParams, string, void>(\"rust-analyzer/viewHir\");\n \n+export interface ViewItemTreeParams {\n+    textDocument: lc.TextDocumentIdentifier;\n+}\n+\n+export const viewItemTree = new lc.RequestType<ViewItemTreeParams, string, void>(\"rust-analyzer/viewItemTree\");\n+\n export const viewCrateGraph = new lc.RequestType0<string, void>(\"rust-analyzer/viewCrateGraph\");\n \n export interface ExpandMacroParams {"}, {"sha": "92c797d47fae060232c0e37afb2d1879fb186de7", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae24651e445444d4ed4275a717ac10980f2957a4/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ae24651e445444d4ed4275a717ac10980f2957a4/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=ae24651e445444d4ed4275a717ac10980f2957a4", "patch": "@@ -106,6 +106,7 @@ async function tryActivate(context: vscode.ExtensionContext) {\n     ctx.registerCommand('parentModule', commands.parentModule);\n     ctx.registerCommand('syntaxTree', commands.syntaxTree);\n     ctx.registerCommand('viewHir', commands.viewHir);\n+    ctx.registerCommand('viewItemTree', commands.viewItemTree);\n     ctx.registerCommand('viewCrateGraph', commands.viewCrateGraph);\n     ctx.registerCommand('expandMacro', commands.expandMacro);\n     ctx.registerCommand('run', commands.run);"}]}