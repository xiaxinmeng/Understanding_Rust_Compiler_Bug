{"sha": "7d088a16df5983b9dcf392c7361f19e099e713bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMDg4YTE2ZGY1OTgzYjlkY2YzOTJjNzM2MWYxOWUwOTllNzEzYmY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-26T19:56:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-26T19:56:35Z"}, "message": "Merge #2421\n\n2421: Cleanup r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "94929e320d14ae8829f807ff83824fb94f44c375", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94929e320d14ae8829f807ff83824fb94f44c375"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d088a16df5983b9dcf392c7361f19e099e713bf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd3YNzCRBK7hj4Ov3rIwAAdHIIAGufPlWL3EpC7carifGAusCC\nfGzMuEIxXGgb6wQA4uKrqLprCJWOl+XRq7LvMfS6+3/YiSOZryLwZ4VYv5x/TaKj\nR3OtxxT4HYzYL1CMI1EXa2JU0GJYtYXSjjqLyKdA4UuUtw59cNA7Z5BqBkhf/O7E\nqkdpB2fKvRULyVKEa+vrgAfaQgJhTglejKV/g/38u6Pmbb2f47Xr1NoK/LTrHP9w\n4E9Nl+u2KwoIaDVwJguOwmyiXuKLnBEqMiItissU4YBcZKj7lNbYjszXIXHEIQu/\nmXxvme1O0LbrK8VqdaGo06owfBO9vEV//Avn4p84fhJBkS4XxLvX3vbl0JANqTQ=\n=ZJpZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 94929e320d14ae8829f807ff83824fb94f44c375\nparent d770f22c53a88035e2836cc01533dab4223f80d5\nparent bed6869865ccfc6e72be26cb2041d83ab5cdbe3c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574798195 +0000\ncommitter GitHub <noreply@github.com> 1574798195 +0000\n\nMerge #2421\n\n2421: Cleanup r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d088a16df5983b9dcf392c7361f19e099e713bf", "html_url": "https://github.com/rust-lang/rust/commit/7d088a16df5983b9dcf392c7361f19e099e713bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d088a16df5983b9dcf392c7361f19e099e713bf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d770f22c53a88035e2836cc01533dab4223f80d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d770f22c53a88035e2836cc01533dab4223f80d5", "html_url": "https://github.com/rust-lang/rust/commit/d770f22c53a88035e2836cc01533dab4223f80d5"}, {"sha": "bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c", "html_url": "https://github.com/rust-lang/rust/commit/bed6869865ccfc6e72be26cb2041d83ab5cdbe3c"}], "stats": {"total": 231, "additions": 118, "deletions": 113}, "files": [{"sha": "54da937eaae53eb57c60c51375597b2f9f176ad1", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=7d088a16df5983b9dcf392c7361f19e099e713bf", "patch": "@@ -28,7 +28,8 @@ use crate::{\n     expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n     ty::display::HirFormatter,\n     ty::{\n-        self, InEnvironment, InferenceResult, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n+        self, InEnvironment, InferenceResult, TraitEnvironment, TraitRef, Ty, TyDefId, TypeCtor,\n+        TypeWalk,\n     },\n     CallableDef, Either, HirDisplay, Name, Source,\n };\n@@ -498,12 +499,9 @@ impl Adt {\n         let subst = db.generic_defaults(self.into());\n         subst.iter().any(|ty| ty == &Ty::Unknown)\n     }\n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        match self {\n-            Adt::Struct(it) => it.ty(db),\n-            Adt::Union(it) => it.ty(db),\n-            Adt::Enum(it) => it.ty(db),\n-        }\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        let id = AdtId::from(self);\n+        Type::from_def(db, id.module(db).krate, id)\n     }\n \n     pub fn module(self, db: &impl DefDatabase) -> Module {\n@@ -795,8 +793,8 @@ impl TypeAlias {\n         db.type_alias_data(self.id).type_ref.clone()\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.ty(self.id.into())\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        Type::from_def(db, self.id.lookup(db).module(db).krate, self.id)\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Name {\n@@ -945,7 +943,7 @@ impl ImplBlock {\n     }\n     pub fn for_trait(db: &impl HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplBlock> {\n         let impls = db.impls_in_crate(krate.crate_id);\n-        impls.lookup_impl_blocks_for_trait(trait_).map(Self::from).collect()\n+        impls.lookup_impl_blocks_for_trait(trait_.id).map(Self::from).collect()\n     }\n \n     pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n@@ -989,6 +987,17 @@ pub struct Type {\n }\n \n impl Type {\n+    fn from_def(\n+        db: &impl HirDatabase,\n+        krate: CrateId,\n+        def: impl HasResolver + Into<TyDefId>,\n+    ) -> Type {\n+        let resolver = def.resolver(db);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = db.ty(def.into());\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n+    }\n+\n     pub fn is_bool(&self) -> bool {\n         match &self.ty.value {\n             Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -1097,6 +1106,28 @@ impl Type {\n             .map(move |ty| self.derived(ty))\n     }\n \n+    // This would be nicer if it just returned an iterator, but that runs into\n+    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n+    pub fn iterate_impl_items<T>(\n+        self,\n+        db: &impl HirDatabase,\n+        krate: Crate,\n+        mut callback: impl FnMut(AssocItem) -> Option<T>,\n+    ) -> Option<T> {\n+        for krate in self.ty.value.def_crates(db, krate.crate_id)? {\n+            let impls = db.impls_in_crate(krate);\n+\n+            for impl_block in impls.lookup_impl_blocks(&self.ty.value) {\n+                for &item in db.impl_data(impl_block).items.iter() {\n+                    if let Some(result) = callback(item.into()) {\n+                        return Some(result);\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n     // FIXME: remove\n     pub fn into_ty(self) -> Ty {\n         self.ty.value"}, {"sha": "31b21ca840c8dbcc0d7ff4f6271da24bca961edd", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=7d088a16df5983b9dcf392c7361f19e099e713bf", "patch": "@@ -2,6 +2,7 @@\n \n use std::sync::Arc;\n \n+use hir_def::{GenericDefId, LocalStructFieldId, TraitId, VariantId};\n use ra_arena::map::ArenaMap;\n use ra_db::{salsa, CrateId};\n \n@@ -12,19 +13,15 @@ use crate::{\n         CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n         ValueTyDefId,\n     },\n-    Crate, DefWithBody, ImplBlock, Trait,\n+    Crate, DefWithBody, ImplBlock,\n };\n \n-pub use hir_def::{\n-    db::{\n-        BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n-        DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n-        FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase,\n-        InternDatabaseStorage, LangItemQuery, ModuleLangItemsQuery, RawItemsQuery,\n-        RawItemsWithSourceMapQuery, StaticDataQuery, StructDataQuery, TraitDataQuery,\n-        TypeAliasDataQuery,\n-    },\n-    GenericDefId, LocalStructFieldId, VariantId,\n+pub use hir_def::db::{\n+    BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n+    DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n+    FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase, InternDatabaseStorage,\n+    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, RawItemsWithSourceMapQuery,\n+    StaticDataQuery, StructDataQuery, TraitDataQuery, TypeAliasDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -66,7 +63,7 @@ pub trait HirDatabase: DefDatabase {\n     fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplBlocks>;\n \n     #[salsa::invoke(crate::ty::traits::impls_for_trait_query)]\n-    fn impls_for_trait(&self, krate: Crate, trait_: Trait) -> Arc<[ImplBlock]>;\n+    fn impls_for_trait(&self, krate: CrateId, trait_: TraitId) -> Arc<[ImplBlock]>;\n \n     /// This provides the Chalk trait solver instance. Because Chalk always\n     /// works from a specific crate, this query is keyed on the crate; and"}, {"sha": "9f3e6c43f213c5ff2a1389bea7d01d45425a0f01", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=7d088a16df5983b9dcf392c7361f19e099e713bf", "patch": "@@ -389,14 +389,14 @@ impl SourceAnalyzer {\n     pub fn iterate_path_candidates<T>(\n         &self,\n         db: &impl HirDatabase,\n-        ty: Ty,\n+        ty: &Type,\n         name: Option<&Name>,\n         callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        let canonical = crate::ty::Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n         method_resolution::iterate_method_candidates(\n             &canonical,\n             db,"}, {"sha": "1c0f71adc2c20f5b967350ede42205a47d6abce2", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=7d088a16df5983b9dcf392c7361f19e099e713bf", "patch": "@@ -189,7 +189,7 @@ impl Ty {\n                 Ty::Param { idx, name }\n             }\n             TypeNs::SelfType(impl_block) => ImplBlock::from(impl_block).target_ty(db),\n-            TypeNs::AdtSelfType(adt) => Adt::from(adt).ty(db),\n+            TypeNs::AdtSelfType(adt) => db.ty(adt.into()),\n \n             TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n             TypeNs::BuiltinType(it) => {"}, {"sha": "92645e2a523e2bbc763d41594e9bb37ad6215d5e", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 53, "deletions": 76, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=7d088a16df5983b9dcf392c7361f19e099e713bf", "patch": "@@ -6,9 +6,10 @@ use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n use hir_def::{\n-    lang_item::LangItemTarget, resolver::HasResolver, resolver::Resolver, AssocItemId, AstItemDef,\n-    HasModule, ImplId, TraitId,\n+    lang_item::LangItemTarget, resolver::HasResolver, resolver::Resolver, type_ref::Mutability,\n+    AssocItemId, AstItemDef, HasModule, ImplId, TraitId,\n };\n+use hir_expand::name::Name;\n use ra_db::CrateId;\n use ra_prof::profile;\n use rustc_hash::FxHashMap;\n@@ -17,7 +18,7 @@ use crate::{\n     db::HirDatabase,\n     ty::primitive::{FloatBitness, Uncertain},\n     ty::{utils::all_super_traits, Ty, TypeCtor},\n-    AssocItem, Crate, Function, Mutability, Name, Trait,\n+    AssocItem, Function,\n };\n \n use super::{autoderef, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n@@ -87,60 +88,65 @@ impl CrateImplBlocks {\n         fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flatten().copied()\n     }\n \n-    pub fn lookup_impl_blocks_for_trait(&self, tr: Trait) -> impl Iterator<Item = ImplId> + '_ {\n-        self.impls_by_trait.get(&tr.id).into_iter().flatten().copied()\n+    pub fn lookup_impl_blocks_for_trait(&self, tr: TraitId) -> impl Iterator<Item = ImplId> + '_ {\n+        self.impls_by_trait.get(&tr).into_iter().flatten().copied()\n     }\n \n     pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplId> + 'a {\n         self.impls.values().chain(self.impls_by_trait.values()).flatten().copied()\n     }\n }\n \n-fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayVec<[Crate; 2]>> {\n-    // Types like slice can have inherent impls in several crates, (core and alloc).\n-    // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n-    macro_rules! lang_item_crate {\n+impl Ty {\n+    pub(crate) fn def_crates(\n+        &self,\n+        db: &impl HirDatabase,\n+        cur_crate: CrateId,\n+    ) -> Option<ArrayVec<[CrateId; 2]>> {\n+        // Types like slice can have inherent impls in several crates, (core and alloc).\n+        // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n+        macro_rules! lang_item_crate {\n         ($($name:expr),+ $(,)?) => {{\n             let mut v = ArrayVec::<[LangItemTarget; 2]>::new();\n             $(\n-                v.extend(db.lang_item(cur_crate.crate_id, $name.into()));\n+                v.extend(db.lang_item(cur_crate, $name.into()));\n             )+\n             v\n         }};\n     }\n \n-    let lang_item_targets = match ty {\n-        Ty::Apply(a_ty) => match a_ty.ctor {\n-            TypeCtor::Adt(def_id) => {\n-                return Some(std::iter::once(def_id.module(db).krate.into()).collect())\n-            }\n-            TypeCtor::Bool => lang_item_crate!(\"bool\"),\n-            TypeCtor::Char => lang_item_crate!(\"char\"),\n-            TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {\n-                // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n-                FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n-                FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n+        let lang_item_targets = match self {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Adt(def_id) => {\n+                    return Some(std::iter::once(def_id.module(db).krate).collect())\n+                }\n+                TypeCtor::Bool => lang_item_crate!(\"bool\"),\n+                TypeCtor::Char => lang_item_crate!(\"char\"),\n+                TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {\n+                    // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n+                    FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n+                    FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n+                },\n+                TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(i.ty_to_string()),\n+                TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n+                TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n+                TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),\n+                TypeCtor::RawPtr(Mutability::Mut) => lang_item_crate!(\"mut_ptr\"),\n+                _ => return None,\n             },\n-            TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(i.ty_to_string()),\n-            TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n-            TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n-            TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),\n-            TypeCtor::RawPtr(Mutability::Mut) => lang_item_crate!(\"mut_ptr\"),\n             _ => return None,\n-        },\n-        _ => return None,\n-    };\n-    let res = lang_item_targets\n-        .into_iter()\n-        .filter_map(|it| match it {\n-            LangItemTarget::ImplBlockId(it) => Some(it),\n-            _ => None,\n-        })\n-        .map(|it| it.module(db).krate.into())\n-        .collect();\n-    Some(res)\n+        };\n+        let res = lang_item_targets\n+            .into_iter()\n+            .filter_map(|it| match it {\n+                LangItemTarget::ImplBlockId(it) => Some(it),\n+                _ => None,\n+            })\n+            .map(|it| it.module(db).krate)\n+            .collect();\n+        Some(res)\n+    }\n }\n-\n /// Look up the method with the given name, returning the actual autoderefed\n /// receiver type (but without autoref applied yet).\n pub(crate) fn lookup_method(\n@@ -193,14 +199,9 @@ pub(crate) fn iterate_method_candidates<T>(\n             let environment = TraitEnvironment::lower(db, resolver);\n             let ty = InEnvironment { value: ty.clone(), environment };\n             for derefed_ty in autoderef::autoderef(db, resolver.krate(), ty) {\n-                if let Some(result) = iterate_inherent_methods(\n-                    &derefed_ty,\n-                    db,\n-                    name,\n-                    mode,\n-                    krate.into(),\n-                    &mut callback,\n-                ) {\n+                if let Some(result) =\n+                    iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n+                {\n                     return Some(result);\n                 }\n                 if let Some(result) = iterate_trait_method_candidates(\n@@ -283,11 +284,11 @@ fn iterate_inherent_methods<T>(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    krate: Crate,\n+    krate: CrateId,\n     mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n-    for krate in def_crates(db, krate, &ty.value)? {\n-        let impls = db.impls_in_crate(krate.crate_id);\n+    for krate in ty.value.def_crates(db, krate)? {\n+        let impls = db.impls_in_crate(krate);\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n             for &item in db.impl_data(impl_block).items.iter() {\n@@ -327,7 +328,7 @@ pub(crate) fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n-    krate: Crate,\n+    krate: CrateId,\n     trait_: TraitId,\n ) -> bool {\n     if ty.value.inherent_trait() == Some(trait_) {\n@@ -337,35 +338,11 @@ pub(crate) fn implements_trait(\n     }\n     let env = TraitEnvironment::lower(db, resolver);\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal);\n+    let solution = db.trait_solve(krate.into(), goal);\n \n     solution.is_some()\n }\n \n-impl Ty {\n-    // This would be nicer if it just returned an iterator, but that runs into\n-    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n-    pub fn iterate_impl_items<T>(\n-        self,\n-        db: &impl HirDatabase,\n-        krate: Crate,\n-        mut callback: impl FnMut(AssocItem) -> Option<T>,\n-    ) -> Option<T> {\n-        for krate in def_crates(db, krate, &self)? {\n-            let impls = db.impls_in_crate(krate.crate_id);\n-\n-            for impl_block in impls.lookup_impl_blocks(&self) {\n-                for &item in db.impl_data(impl_block).items.iter() {\n-                    if let Some(result) = callback(item.into()) {\n-                        return Some(result);\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-}\n-\n /// This creates Substs for a trait with the given Self type and type variables\n /// for all other parameters, to query Chalk with it.\n fn generic_implements_goal("}, {"sha": "637e21e9c4348a5c27b4ffd698f96dc352aedb44", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=7d088a16df5983b9dcf392c7361f19e099e713bf", "patch": "@@ -2,13 +2,13 @@\n use std::sync::{Arc, Mutex};\n \n use chalk_ir::{cast::Cast, family::ChalkIr};\n-use hir_def::{expr::ExprId, DefWithBodyId};\n+use hir_def::{expr::ExprId, DefWithBodyId, TraitId};\n use log::debug;\n-use ra_db::{impl_intern_key, salsa};\n+use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n-use crate::{db::HirDatabase, Crate, ImplBlock, Trait, TypeAlias};\n+use crate::{db::HirDatabase, Crate, ImplBlock, TypeAlias};\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n \n@@ -77,19 +77,19 @@ pub(crate) fn trait_solver_query(\n /// Collects impls for the given trait in the whole dependency tree of `krate`.\n pub(crate) fn impls_for_trait_query(\n     db: &impl HirDatabase,\n-    krate: Crate,\n-    trait_: Trait,\n+    krate: CrateId,\n+    trait_: TraitId,\n ) -> Arc<[ImplBlock]> {\n     let mut impls = FxHashSet::default();\n     // We call the query recursively here. On the one hand, this means we can\n     // reuse results from queries for different crates; on the other hand, this\n     // will only ever get called for a few crates near the root of the tree (the\n     // ones the user is editing), so this may actually be a waste of memory. I'm\n     // doing it like this mainly for simplicity for now.\n-    for dep in krate.dependencies(db) {\n-        impls.extend(db.impls_for_trait(dep.krate, trait_).iter());\n+    for dep in db.crate_graph().dependencies(krate) {\n+        impls.extend(db.impls_for_trait(dep.crate_id, trait_).iter());\n     }\n-    let crate_impl_blocks = db.impls_in_crate(krate.crate_id);\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n     impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(trait_).map(ImplBlock::from));\n     impls.into_iter().collect()\n }"}, {"sha": "d879382a0e323f84c628f1da547a6c1ab930577b", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=7d088a16df5983b9dcf392c7361f19e099e713bf", "patch": "@@ -448,7 +448,7 @@ where\n         let trait_: TraitId = from_chalk(self.db, trait_id);\n         let mut result: Vec<_> = self\n             .db\n-            .impls_for_trait(self.krate, trait_.into())\n+            .impls_for_trait(self.krate.crate_id, trait_.into())\n             .iter()\n             .copied()\n             .map(Impl::ImplBlock)"}, {"sha": "5155365ccbb34bd2c785c0dcefd6d91ab29cb768", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=7d088a16df5983b9dcf392c7361f19e099e713bf", "patch": "@@ -484,7 +484,7 @@ impl Resolver {\n     }\n }\n \n-pub trait HasResolver {\n+pub trait HasResolver: Copy {\n     /// Builds a resolver for type references inside this def.\n     fn resolver(self, db: &impl DefDatabase) -> Resolver;\n }\n@@ -502,7 +502,7 @@ impl HasResolver for TraitId {\n     }\n }\n \n-impl<T: Into<AdtId>> HasResolver for T {\n+impl<T: Into<AdtId> + Copy> HasResolver for T {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         let def = self.into();\n         def.module(db)"}, {"sha": "89e0009a17a6ec918b55ec495d293707790c53ab", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d088a16df5983b9dcf392c7361f19e099e713bf/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=7d088a16df5983b9dcf392c7361f19e099e713bf", "patch": "@@ -50,7 +50,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n                 _ => unreachable!(),\n             };\n-            ctx.analyzer.iterate_path_candidates(ctx.db, ty.clone(), None, |_ty, item| {\n+            ctx.analyzer.iterate_path_candidates(ctx.db, &ty, None, |_ty, item| {\n                 match item {\n                     hir::AssocItem::Function(func) => {\n                         if !func.has_self_param(ctx.db) {"}]}