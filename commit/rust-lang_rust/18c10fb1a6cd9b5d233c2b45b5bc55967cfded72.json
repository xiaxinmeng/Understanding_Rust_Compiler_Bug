{"sha": "18c10fb1a6cd9b5d233c2b45b5bc55967cfded72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YzEwZmIxYTZjZDliNWQyMzNjMmI0NWI1YmM1NTk2N2NmZGVkNzI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-05-24T16:45:21Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-06-30T18:31:53Z"}, "message": "Separate resolver creation from expansion.", "tree": {"sha": "6b6e6766f651720f4708014337389ede2bd8ae45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b6e6766f651720f4708014337389ede2bd8ae45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18c10fb1a6cd9b5d233c2b45b5bc55967cfded72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18c10fb1a6cd9b5d233c2b45b5bc55967cfded72", "html_url": "https://github.com/rust-lang/rust/commit/18c10fb1a6cd9b5d233c2b45b5bc55967cfded72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18c10fb1a6cd9b5d233c2b45b5bc55967cfded72/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f98e5ee5613abe3d8c2439af52d399bd6e98949", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f98e5ee5613abe3d8c2439af52d399bd6e98949", "html_url": "https://github.com/rust-lang/rust/commit/5f98e5ee5613abe3d8c2439af52d399bd6e98949"}], "stats": {"total": 95, "additions": 38, "deletions": 57}, "files": [{"sha": "4f7b0aea8436f436e8ff67099d81219c079d4c4b", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 29, "deletions": 49, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/18c10fb1a6cd9b5d233c2b45b5bc55967cfded72/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c10fb1a6cd9b5d233c2b45b5bc55967cfded72/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=18c10fb1a6cd9b5d233c2b45b5bc55967cfded72", "patch": "@@ -110,12 +110,9 @@ mod boxed_resolver {\n     }\n \n     impl BoxedResolver {\n-        pub(super) fn new<F>(session: Lrc<Session>, make_resolver: F) -> Result<(ast::Crate, Self)>\n+        pub(super) fn new<F>(session: Lrc<Session>, make_resolver: F) -> Self\n         where\n-            F: for<'a> FnOnce(\n-                &'a Session,\n-                &'a ResolverArenas<'a>,\n-            ) -> Result<(ast::Crate, Resolver<'a>)>,\n+            F: for<'a> FnOnce(&'a Session, &'a ResolverArenas<'a>) -> Resolver<'a>,\n         {\n             let mut boxed_resolver = Box::new(BoxedResolverInner {\n                 session,\n@@ -127,14 +124,14 @@ mod boxed_resolver {\n             // returns a resolver with the same lifetime as the arena. We ensure that the arena\n             // outlives the resolver in the drop impl and elsewhere so these transmutes are sound.\n             unsafe {\n-                let (crate_, resolver) = make_resolver(\n+                let resolver = make_resolver(\n                     std::mem::transmute::<&Session, &Session>(&boxed_resolver.session),\n                     std::mem::transmute::<&ResolverArenas<'_>, &ResolverArenas<'_>>(\n                         boxed_resolver.resolver_arenas.as_ref().unwrap(),\n                     ),\n-                )?;\n+                );\n                 boxed_resolver.resolver = Some(resolver);\n-                Ok((crate_, BoxedResolver(Pin::new_unchecked(boxed_resolver))))\n+                BoxedResolver(Pin::new_unchecked(boxed_resolver))\n             }\n         }\n \n@@ -165,35 +162,20 @@ mod boxed_resolver {\n     }\n }\n \n-/// Runs the \"early phases\" of the compiler: initial `cfg` processing, loading compiler plugins,\n-/// syntax expansion, secondary `cfg` expansion, synthesis of a test\n-/// harness if one is to be provided, injection of a dependency on the\n-/// standard library and prelude, and name resolution.\n-///\n-/// Returns [`None`] if we're aborting after handling -W help.\n-pub fn configure_and_expand(\n+pub fn create_resolver(\n     sess: Lrc<Session>,\n-    lint_store: Lrc<LintStore>,\n     metadata_loader: Box<MetadataLoaderDyn>,\n-    krate: ast::Crate,\n+    krate: &ast::Crate,\n     crate_name: &str,\n-) -> Result<(ast::Crate, BoxedResolver)> {\n-    tracing::trace!(\"configure_and_expand\");\n+) -> BoxedResolver {\n+    tracing::trace!(\"create_resolver\");\n     // Currently, we ignore the name resolution data structures for the purposes of dependency\n     // tracking. Instead we will run name resolution and include its output in the hash of each\n     // item, much like we do for macro expansion. In other words, the hash reflects not just\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n-    let crate_name = crate_name.to_string();\n     BoxedResolver::new(sess, move |sess, resolver_arenas| {\n-        configure_and_expand_inner(\n-            sess,\n-            &lint_store,\n-            krate,\n-            &crate_name,\n-            &resolver_arenas,\n-            metadata_loader,\n-        )\n+        Resolver::new(sess, &krate, &crate_name, metadata_loader, &resolver_arenas)\n     })\n }\n \n@@ -278,28 +260,26 @@ fn pre_expansion_lint(\n     });\n }\n \n-fn configure_and_expand_inner<'a>(\n-    sess: &'a Session,\n+/// Runs the \"early phases\" of the compiler: initial `cfg` processing, loading compiler plugins,\n+/// syntax expansion, secondary `cfg` expansion, synthesis of a test\n+/// harness if one is to be provided, injection of a dependency on the\n+/// standard library and prelude, and name resolution.\n+///\n+/// Returns [`None`] if we're aborting after handling -W help.\n+pub fn configure_and_expand(\n+    sess: &Session,\n     lint_store: &LintStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n-    resolver_arenas: &'a ResolverArenas<'a>,\n-    metadata_loader: Box<MetadataLoaderDyn>,\n-) -> Result<(ast::Crate, Resolver<'a>)> {\n-    tracing::trace!(\"configure_and_expand_inner\");\n+    resolver: &mut Resolver<'_>,\n+) -> Result<ast::Crate> {\n+    tracing::trace!(\"configure_and_expand\");\n     pre_expansion_lint(sess, lint_store, &krate, crate_name);\n-\n-    let mut resolver = Resolver::new(sess, &krate, crate_name, metadata_loader, &resolver_arenas);\n-    rustc_builtin_macros::register_builtin_macros(&mut resolver);\n+    rustc_builtin_macros::register_builtin_macros(resolver);\n \n     krate = sess.time(\"crate_injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n-        rustc_builtin_macros::standard_library_imports::inject(\n-            krate,\n-            &mut resolver,\n-            &sess,\n-            alt_std_name,\n-        )\n+        rustc_builtin_macros::standard_library_imports::inject(krate, resolver, &sess, alt_std_name)\n     });\n \n     util::check_attr_crate_type(&sess, &krate.attrs, &mut resolver.lint_buffer());\n@@ -354,7 +334,7 @@ fn configure_and_expand_inner<'a>(\n             pre_expansion_lint(sess, lint_store, &krate, &ident.name.as_str());\n             (krate.attrs, krate.items)\n         };\n-        let mut ecx = ExtCtxt::new(&sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n+        let mut ecx = ExtCtxt::new(&sess, cfg, resolver, Some(&extern_mod_loaded));\n \n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n@@ -396,16 +376,16 @@ fn configure_and_expand_inner<'a>(\n     })?;\n \n     sess.time(\"maybe_building_test_harness\", || {\n-        rustc_builtin_macros::test_harness::inject(&sess, &mut resolver, &mut krate)\n+        rustc_builtin_macros::test_harness::inject(&sess, resolver, &mut krate)\n     });\n \n     if let Some(PpMode::Source(PpSourceMode::EveryBodyLoops)) = sess.opts.pretty {\n         tracing::debug!(\"replacing bodies with loop {{}}\");\n-        util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n+        util::ReplaceBodyWithLoop::new(resolver).visit_crate(&mut krate);\n     }\n \n     let has_proc_macro_decls = sess.time(\"AST_validation\", || {\n-        rustc_ast_passes::ast_validation::check_crate(sess, &krate, &mut resolver.lint_buffer())\n+        rustc_ast_passes::ast_validation::check_crate(sess, &krate, resolver.lint_buffer())\n     });\n \n     let crate_types = sess.crate_types();\n@@ -431,7 +411,7 @@ fn configure_and_expand_inner<'a>(\n             let is_test_crate = sess.opts.test;\n             rustc_builtin_macros::proc_macro_harness::inject(\n                 &sess,\n-                &mut resolver,\n+                resolver,\n                 krate,\n                 is_proc_macro_crate,\n                 has_proc_macro_decls,\n@@ -471,7 +451,7 @@ fn configure_and_expand_inner<'a>(\n         }\n     });\n \n-    Ok((krate, resolver))\n+    Ok(krate)\n }\n \n pub fn lower_to_hir<'res, 'tcx>("}, {"sha": "1f0ef553e5dadc4f783e8a6584e03f5cd5a6697b", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18c10fb1a6cd9b5d233c2b45b5bc55967cfded72/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c10fb1a6cd9b5d233c2b45b5bc55967cfded72/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=18c10fb1a6cd9b5d233c2b45b5bc55967cfded72", "patch": "@@ -177,16 +177,17 @@ impl<'tcx> Queries<'tcx> {\n             let crate_name = self.crate_name()?.peek().clone();\n             let (krate, lint_store) = self.register_plugins()?.take();\n             let _timer = self.session().timer(\"configure_and_expand\");\n-            passes::configure_and_expand(\n-                self.session().clone(),\n-                lint_store.clone(),\n+            let sess = self.session();\n+            let mut resolver = passes::create_resolver(\n+                sess.clone(),\n                 self.codegen_backend().metadata_loader(),\n-                krate,\n+                &krate,\n                 &crate_name,\n-            )\n-            .map(|(krate, resolver)| {\n-                (krate, Steal::new(Rc::new(RefCell::new(resolver))), lint_store)\n-            })\n+            );\n+            let krate = resolver.access(|resolver| {\n+                passes::configure_and_expand(&sess, &lint_store, krate, &crate_name, resolver)\n+            })?;\n+            Ok((krate, Steal::new(Rc::new(RefCell::new(resolver))), lint_store))\n         })\n     }\n "}]}