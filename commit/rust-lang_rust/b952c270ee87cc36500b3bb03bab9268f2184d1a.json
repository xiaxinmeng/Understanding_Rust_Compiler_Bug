{"sha": "b952c270ee87cc36500b3bb03bab9268f2184d1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NTJjMjcwZWU4N2NjMzY1MDBiM2JiMDNiYWI5MjY4ZjIxODRkMWE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-10T19:00:36Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-10T19:00:36Z"}, "message": "Merge #762\n\n762: \"Dumb\" auto import assist r=matklad a=eulerdisk\n\nThis adds a new assist to \"add xxx::yyy to the current file\" when the cursor is on a PATH. It manages correctly nested imports,`self` keyword and creates new nested imports if necessary. [See the tests]\r\nIt doesn't use name resolution so in that sense is 'dumb', but I have plans to do that. That in the future will be useful to auto import trait names in autocompletion for example.\r\n\r\nIt can easily be extended to provide multiple actions to select in which scope to import. That's another thing I plan to do.\r\n\r\n@matklad I copied some indentation code from `ide_light`, I don't know at the moment if/how you want to refactor that code. This assist was meant to be in `ide_light`.\n\nCo-authored-by: Andrea Pretto <eulerdisk@gmail.com>", "tree": {"sha": "4ce4304b73a9e10fea6bfb6d04404c1efdbbbf84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ce4304b73a9e10fea6bfb6d04404c1efdbbbf84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b952c270ee87cc36500b3bb03bab9268f2184d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b952c270ee87cc36500b3bb03bab9268f2184d1a", "html_url": "https://github.com/rust-lang/rust/commit/b952c270ee87cc36500b3bb03bab9268f2184d1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b952c270ee87cc36500b3bb03bab9268f2184d1a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "8e4be2708635818aa3e210f0e39fb871cc433004", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4be2708635818aa3e210f0e39fb871cc433004", "html_url": "https://github.com/rust-lang/rust/commit/8e4be2708635818aa3e210f0e39fb871cc433004"}, {"sha": "1a4faaffd7608553528e19d1ad973cedf017e3ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a4faaffd7608553528e19d1ad973cedf017e3ce", "html_url": "https://github.com/rust-lang/rust/commit/1a4faaffd7608553528e19d1ad973cedf017e3ce"}], "stats": {"total": 732, "additions": 732, "deletions": 0}, "files": [{"sha": "6a0c351f199444af8e0677b69b1498348f40ad1d", "filename": "crates/ra_assists/src/auto_import.rs", "status": "added", "additions": 729, "deletions": 0, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/b952c270ee87cc36500b3bb03bab9268f2184d1a/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b952c270ee87cc36500b3bb03bab9268f2184d1a/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=b952c270ee87cc36500b3bb03bab9268f2184d1a", "patch": "@@ -0,0 +1,729 @@\n+use hir::db::HirDatabase;\n+use ra_syntax::{\n+    ast, AstNode, SyntaxNode, Direction, TextRange,\n+    SyntaxKind::{ PATH, PATH_SEGMENT, COLONCOLON, COMMA }\n+};\n+use crate::assist_ctx::{AssistCtx, Assist, AssistBuilder};\n+\n+fn collect_path_segments(path: &ast::Path) -> Option<Vec<&ast::PathSegment>> {\n+    let mut v = Vec::new();\n+    collect_path_segments_raw(&mut v, path)?;\n+    return Some(v);\n+}\n+\n+fn collect_path_segments_raw<'a>(\n+    segments: &mut Vec<&'a ast::PathSegment>,\n+    mut path: &'a ast::Path,\n+) -> Option<usize> {\n+    let oldlen = segments.len();\n+    loop {\n+        let mut children = path.syntax().children();\n+        let (first, second, third) = (\n+            children.next().map(|n| (n, n.kind())),\n+            children.next().map(|n| (n, n.kind())),\n+            children.next().map(|n| (n, n.kind())),\n+        );\n+        match (first, second, third) {\n+            (Some((subpath, PATH)), Some((_, COLONCOLON)), Some((segment, PATH_SEGMENT))) => {\n+                path = ast::Path::cast(subpath)?;\n+                segments.push(ast::PathSegment::cast(segment)?);\n+            }\n+            (Some((segment, PATH_SEGMENT)), _, _) => {\n+                segments.push(ast::PathSegment::cast(segment)?);\n+                break;\n+            }\n+            (_, _, _) => return None,\n+        }\n+    }\n+    // We need to reverse only the new added segments\n+    let only_new_segments = segments.split_at_mut(oldlen).1;\n+    only_new_segments.reverse();\n+    return Some(segments.len() - oldlen);\n+}\n+\n+fn fmt_segments(segments: &[&ast::PathSegment]) -> String {\n+    let mut buf = String::new();\n+    fmt_segments_raw(segments, &mut buf);\n+    return buf;\n+}\n+\n+fn fmt_segments_raw(segments: &[&ast::PathSegment], buf: &mut String) {\n+    let mut first = true;\n+    for s in segments {\n+        if !first {\n+            buf.push_str(\"::\");\n+        }\n+        match s.kind() {\n+            Some(ast::PathSegmentKind::Name(nameref)) => buf.push_str(nameref.text()),\n+            Some(ast::PathSegmentKind::SelfKw) => buf.push_str(\"self\"),\n+            Some(ast::PathSegmentKind::SuperKw) => buf.push_str(\"super\"),\n+            Some(ast::PathSegmentKind::CrateKw) => buf.push_str(\"crate\"),\n+            None => {}\n+        }\n+        first = false;\n+    }\n+}\n+\n+// Returns the numeber of common segments.\n+fn compare_path_segments(left: &[&ast::PathSegment], right: &[&ast::PathSegment]) -> usize {\n+    return left.iter().zip(right).filter(|(l, r)| compare_path_segment(l, r)).count();\n+}\n+\n+fn compare_path_segment(a: &ast::PathSegment, b: &ast::PathSegment) -> bool {\n+    if let (Some(ka), Some(kb)) = (a.kind(), b.kind()) {\n+        match (ka, kb) {\n+            (ast::PathSegmentKind::Name(nameref_a), ast::PathSegmentKind::Name(nameref_b)) => {\n+                nameref_a.text() == nameref_b.text()\n+            }\n+            (ast::PathSegmentKind::SelfKw, ast::PathSegmentKind::SelfKw) => true,\n+            (ast::PathSegmentKind::SuperKw, ast::PathSegmentKind::SuperKw) => true,\n+            (ast::PathSegmentKind::CrateKw, ast::PathSegmentKind::CrateKw) => true,\n+            (_, _) => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn compare_path_segment_with_name(a: &ast::PathSegment, b: &ast::Name) -> bool {\n+    if let Some(ka) = a.kind() {\n+        return match (ka, b) {\n+            (ast::PathSegmentKind::Name(nameref_a), _) => nameref_a.text() == b.text(),\n+            (_, _) => false,\n+        };\n+    } else {\n+        false\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum ImportAction<'a> {\n+    Nothing,\n+    // Add a brand new use statement.\n+    AddNewUse {\n+        anchor: Option<&'a SyntaxNode>, // anchor node\n+        add_after_anchor: bool,\n+    },\n+\n+    // To split an existing use statement creating a nested import.\n+    AddNestedImport {\n+        // how may segments matched with the target path\n+        common_segments: usize,\n+        path_to_split: &'a ast::Path,\n+        // the first segment of path_to_split we want to add into the new nested list\n+        first_segment_to_split: Option<&'a ast::PathSegment>,\n+        // Wether to add 'self' in addition to the target path\n+        add_self: bool,\n+    },\n+    // To add the target path to an existing nested import tree list.\n+    AddInTreeList {\n+        common_segments: usize,\n+        // The UseTreeList where to add the target path\n+        tree_list: &'a ast::UseTreeList,\n+        add_self: bool,\n+    },\n+}\n+\n+impl<'a> ImportAction<'a> {\n+    fn add_new_use(anchor: Option<&'a SyntaxNode>, add_after_anchor: bool) -> Self {\n+        ImportAction::AddNewUse { anchor, add_after_anchor }\n+    }\n+\n+    fn add_nested_import(\n+        common_segments: usize,\n+        path_to_split: &'a ast::Path,\n+        first_segment_to_split: Option<&'a ast::PathSegment>,\n+        add_self: bool,\n+    ) -> Self {\n+        ImportAction::AddNestedImport {\n+            common_segments,\n+            path_to_split,\n+            first_segment_to_split,\n+            add_self,\n+        }\n+    }\n+\n+    fn add_in_tree_list(\n+        common_segments: usize,\n+        tree_list: &'a ast::UseTreeList,\n+        add_self: bool,\n+    ) -> Self {\n+        ImportAction::AddInTreeList { common_segments, tree_list, add_self }\n+    }\n+\n+    fn better<'b>(left: &'b ImportAction<'a>, right: &'b ImportAction<'a>) -> &'b ImportAction<'a> {\n+        if left.is_better(right) {\n+            left\n+        } else {\n+            right\n+        }\n+    }\n+\n+    fn is_better(&self, other: &ImportAction) -> bool {\n+        match (self, other) {\n+            (ImportAction::Nothing, _) => true,\n+            (ImportAction::AddInTreeList { .. }, ImportAction::Nothing) => false,\n+            (\n+                ImportAction::AddNestedImport { common_segments: n, .. },\n+                ImportAction::AddInTreeList { common_segments: m, .. },\n+            ) => n > m,\n+            (\n+                ImportAction::AddInTreeList { common_segments: n, .. },\n+                ImportAction::AddNestedImport { common_segments: m, .. },\n+            ) => n > m,\n+            (ImportAction::AddInTreeList { .. }, _) => true,\n+            (ImportAction::AddNestedImport { .. }, ImportAction::Nothing) => false,\n+            (ImportAction::AddNestedImport { .. }, _) => true,\n+            (ImportAction::AddNewUse { .. }, _) => false,\n+        }\n+    }\n+}\n+\n+// Find out the best ImportAction to import target path against current_use_tree.\n+// If current_use_tree has a nested import the function gets called recursively on every UseTree inside a UseTreeList.\n+fn walk_use_tree_for_best_action<'a>(\n+    current_path_segments: &mut Vec<&'a ast::PathSegment>, // buffer containing path segments\n+    current_parent_use_tree_list: Option<&'a ast::UseTreeList>, // will be Some value if we are in a nested import\n+    current_use_tree: &'a ast::UseTree, // the use tree we are currently examinating\n+    target: &[&'a ast::PathSegment],    // the path we want to import\n+) -> ImportAction<'a> {\n+    // We save the number of segments in the buffer so we can restore the correct segments\n+    // before returning. Recursive call will add segments so we need to delete them.\n+    let prev_len = current_path_segments.len();\n+\n+    let tree_list = current_use_tree.use_tree_list();\n+    let alias = current_use_tree.alias();\n+\n+    let path = match current_use_tree.path() {\n+        Some(path) => path,\n+        None => {\n+            // If the use item don't have a path, it means it's broken (syntax error)\n+            return ImportAction::add_new_use(\n+                current_use_tree\n+                    .syntax()\n+                    .ancestors()\n+                    .find_map(ast::UseItem::cast)\n+                    .map(AstNode::syntax),\n+                true,\n+            );\n+        }\n+    };\n+\n+    // This can happen only if current_use_tree is a direct child of a UseItem\n+    if let Some(name) = alias.and_then(ast::NameOwner::name) {\n+        if compare_path_segment_with_name(target[0], name) {\n+            return ImportAction::Nothing;\n+        }\n+    }\n+\n+    collect_path_segments_raw(current_path_segments, path);\n+\n+    // We compare only the new segments added in the line just above.\n+    // The first prev_len segments were already compared in 'parent' recursive calls.\n+    let left = target.split_at(prev_len).1;\n+    let right = current_path_segments.split_at(prev_len).1;\n+    let common = compare_path_segments(left, right);\n+    let mut action = match common {\n+        0 => ImportAction::add_new_use(\n+            // e.g: target is std::fmt and we can have\n+            // use foo::bar\n+            // We add a brand new use statement\n+            current_use_tree.syntax().ancestors().find_map(ast::UseItem::cast).map(AstNode::syntax),\n+            true,\n+        ),\n+        common if common == left.len() && left.len() == right.len() => {\n+            // e.g: target is std::fmt and we can have\n+            // 1- use std::fmt;\n+            // 2- use std::fmt:{ ... }\n+            if let Some(list) = tree_list {\n+                // In case 2 we need to add self to the nested list\n+                // unless it's already there\n+                let has_self = list.use_trees().map(ast::UseTree::path).any(|p| {\n+                    p.and_then(ast::Path::segment)\n+                        .and_then(ast::PathSegment::kind)\n+                        .filter(|k| *k == ast::PathSegmentKind::SelfKw)\n+                        .is_some()\n+                });\n+\n+                if has_self {\n+                    ImportAction::Nothing\n+                } else {\n+                    ImportAction::add_in_tree_list(current_path_segments.len(), list, true)\n+                }\n+            } else {\n+                // Case 1\n+                ImportAction::Nothing\n+            }\n+        }\n+        common if common != left.len() && left.len() == right.len() => {\n+            // e.g: target is std::fmt and we have\n+            // use std::io;\n+            // We need to split.\n+            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n+            ImportAction::add_nested_import(\n+                prev_len + common,\n+                path,\n+                Some(segments_to_split[0]),\n+                false,\n+            )\n+        }\n+        common if left.len() > right.len() => {\n+            // e.g: target is std::fmt and we can have\n+            // 1- use std;\n+            // 2- use std::{ ... };\n+\n+            // fallback action\n+            let mut better_action = ImportAction::add_new_use(\n+                current_use_tree\n+                    .syntax()\n+                    .ancestors()\n+                    .find_map(ast::UseItem::cast)\n+                    .map(AstNode::syntax),\n+                true,\n+            );\n+            if let Some(list) = tree_list {\n+                // Case 2, check recursively if the path is already imported in the nested list\n+                for u in list.use_trees() {\n+                    let child_action =\n+                        walk_use_tree_for_best_action(current_path_segments, Some(list), u, target);\n+                    if child_action.is_better(&better_action) {\n+                        better_action = child_action;\n+                        if let ImportAction::Nothing = better_action {\n+                            return better_action;\n+                        }\n+                    }\n+                }\n+            } else {\n+                // Case 1, split\n+                better_action = ImportAction::add_nested_import(prev_len + common, path, None, true)\n+            }\n+            better_action\n+        }\n+        common if left.len() < right.len() => {\n+            // e.g: target is std::fmt and we can have\n+            // use std::fmt::Debug;\n+            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n+            ImportAction::add_nested_import(\n+                prev_len + common,\n+                path,\n+                Some(segments_to_split[0]),\n+                true,\n+            )\n+        }\n+        _ => unreachable!(),\n+    };\n+\n+    // If we are inside a UseTreeList adding a use statement become adding to the existing\n+    // tree list.\n+    action = match (current_parent_use_tree_list, action) {\n+        (Some(use_tree_list), ImportAction::AddNewUse { .. }) => {\n+            ImportAction::add_in_tree_list(prev_len, use_tree_list, false)\n+        }\n+        (_, _) => action,\n+    };\n+\n+    // We remove the segments added\n+    current_path_segments.truncate(prev_len);\n+    return action;\n+}\n+\n+fn best_action_for_target<'b, 'a: 'b>(\n+    container: &'a SyntaxNode,\n+    path: &'a ast::Path,\n+    target: &'b [&'a ast::PathSegment],\n+) -> ImportAction<'a> {\n+    let mut storage = Vec::with_capacity(16); // this should be the only allocation\n+    let best_action = container\n+        .children()\n+        .filter_map(ast::UseItem::cast)\n+        .filter_map(ast::UseItem::use_tree)\n+        .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n+        .fold(None, |best, a| {\n+            best.and_then(|best| Some(*ImportAction::better(&best, &a))).or(Some(a))\n+        });\n+\n+    match best_action {\n+        Some(action) => return action,\n+        None => {\n+            // We have no action we no use item was found in container so we find\n+            // another item and we use it as anchor.\n+            // If there are not items, we choose the target path itself as anchor.\n+            let anchor = container\n+                .children()\n+                .find_map(ast::ModuleItem::cast)\n+                .map(AstNode::syntax)\n+                .or(Some(path.syntax()));\n+\n+            return ImportAction::add_new_use(anchor, false);\n+        }\n+    }\n+}\n+\n+fn make_assist(action: &ImportAction, target: &[&ast::PathSegment], edit: &mut AssistBuilder) {\n+    match action {\n+        ImportAction::AddNewUse { anchor, add_after_anchor } => {\n+            make_assist_add_new_use(anchor, *add_after_anchor, target, edit)\n+        }\n+        ImportAction::AddInTreeList { common_segments, tree_list, add_self } => {\n+            // We know that the fist n segments already exists in the use statement we want\n+            // to modify, so we want to add only the last target.len() - n segments.\n+            let segments_to_add = target.split_at(*common_segments).1;\n+            make_assist_add_in_tree_list(tree_list, segments_to_add, *add_self, edit)\n+        }\n+        ImportAction::AddNestedImport {\n+            common_segments,\n+            path_to_split,\n+            first_segment_to_split,\n+            add_self,\n+        } => {\n+            let segments_to_add = target.split_at(*common_segments).1;\n+            make_assist_add_nested_import(\n+                path_to_split,\n+                first_segment_to_split,\n+                segments_to_add,\n+                *add_self,\n+                edit,\n+            )\n+        }\n+        _ => {}\n+    }\n+}\n+\n+fn make_assist_add_new_use(\n+    anchor: &Option<&SyntaxNode>,\n+    after: bool,\n+    target: &[&ast::PathSegment],\n+    edit: &mut AssistBuilder,\n+) {\n+    if let Some(anchor) = anchor {\n+        let indent = ra_fmt::leading_indent(anchor);\n+        let mut buf = String::new();\n+        if after {\n+            buf.push_str(\"\\n\");\n+            if let Some(spaces) = indent {\n+                buf.push_str(spaces);\n+            }\n+        }\n+        buf.push_str(\"use \");\n+        fmt_segments_raw(target, &mut buf);\n+        buf.push_str(\";\");\n+        if !after {\n+            buf.push_str(\"\\n\\n\");\n+            if let Some(spaces) = indent {\n+                buf.push_str(spaces);\n+            }\n+        }\n+        let position = if after { anchor.range().end() } else { anchor.range().start() };\n+        edit.insert(position, buf);\n+    }\n+}\n+\n+fn make_assist_add_in_tree_list(\n+    tree_list: &ast::UseTreeList,\n+    target: &[&ast::PathSegment],\n+    add_self: bool,\n+    edit: &mut AssistBuilder,\n+) {\n+    let last = tree_list.use_trees().last();\n+    if let Some(last) = last {\n+        let mut buf = String::new();\n+        let comma = last.syntax().siblings(Direction::Next).find(|n| n.kind() == COMMA);\n+        let offset = if let Some(comma) = comma {\n+            comma.range().end()\n+        } else {\n+            buf.push_str(\",\");\n+            last.syntax().range().end()\n+        };\n+        if add_self {\n+            buf.push_str(\" self\")\n+        } else {\n+            buf.push_str(\" \");\n+        }\n+        fmt_segments_raw(target, &mut buf);\n+        edit.insert(offset, buf);\n+    } else {\n+\n+    }\n+}\n+\n+fn make_assist_add_nested_import(\n+    path: &ast::Path,\n+    first_segment_to_split: &Option<&ast::PathSegment>,\n+    target: &[&ast::PathSegment],\n+    add_self: bool,\n+    edit: &mut AssistBuilder,\n+) {\n+    let use_tree = path.syntax().ancestors().find_map(ast::UseTree::cast);\n+    if let Some(use_tree) = use_tree {\n+        let (start, add_colon_colon) = if let Some(first_segment_to_split) = first_segment_to_split\n+        {\n+            (first_segment_to_split.syntax().range().start(), false)\n+        } else {\n+            (use_tree.syntax().range().end(), true)\n+        };\n+        let end = use_tree.syntax().range().end();\n+\n+        let mut buf = String::new();\n+        if add_colon_colon {\n+            buf.push_str(\"::\");\n+        }\n+        buf.push_str(\"{ \");\n+        if add_self {\n+            buf.push_str(\"self, \");\n+        }\n+        fmt_segments_raw(target, &mut buf);\n+        if !target.is_empty() {\n+            buf.push_str(\", \");\n+        }\n+        edit.insert(start, buf);\n+        edit.insert(end, \"}\");\n+    }\n+}\n+\n+pub(crate) fn auto_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let node = ctx.covering_node();\n+    let current_file = node.ancestors().find_map(ast::SourceFile::cast)?;\n+\n+    let path = node.ancestors().find_map(ast::Path::cast)?;\n+    // We don't want to mess with use statements\n+    if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n+        return None;\n+    }\n+\n+    let segments = collect_path_segments(path)?;\n+    if segments.len() < 2 {\n+        return None;\n+    }\n+\n+    ctx.build(format!(\"import {} in the current file\", fmt_segments(&segments)), |edit| {\n+        let action = best_action_for_target(current_file.syntax(), path, &segments);\n+        make_assist(&action, segments.as_slice(), edit);\n+        if let Some(last_segment) = path.segment() {\n+            // Here we are assuming the assist will provide a  correct use statement\n+            // so we can delete the path qualifier\n+            edit.delete(TextRange::from_to(\n+                path.syntax().range().start(),\n+                last_segment.syntax().range().start(),\n+            ));\n+        }\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::helpers::{ check_assist, check_assist_not_applicable };\n+\n+    #[test]\n+    fn test_auto_import_file_add_use_no_anchor() {\n+        check_assist(\n+            auto_import,\n+            \"\n+std::fmt::Debug<|>\n+    \",\n+            \"\n+use std::fmt::Debug;\n+\n+Debug<|>\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_use() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use stdx;\n+\n+impl std::fmt::Debug<|> for Foo {\n+}\n+    \",\n+            \"\n+use stdx;\n+use std::fmt::Debug;\n+\n+impl Debug<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_use_other_anchor() {\n+        check_assist(\n+            auto_import,\n+            \"\n+impl std::fmt::Debug<|> for Foo {\n+}\n+    \",\n+            \"\n+use std::fmt::Debug;\n+\n+impl Debug<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_use_other_anchor_indent() {\n+        check_assist(\n+            auto_import,\n+            \"\n+    impl std::fmt::Debug<|> for Foo {\n+    }\n+    \",\n+            \"\n+    use std::fmt::Debug;\n+\n+    impl Debug<|> for Foo {\n+    }\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_split_different() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt;\n+\n+impl std::io<|> for Foo {\n+}\n+    \",\n+            \"\n+use std::{ io, fmt};\n+\n+impl io<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_split_self_for_use() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt;\n+\n+impl std::fmt::Debug<|> for Foo {\n+}\n+    \",\n+            \"\n+use std::fmt::{ self, Debug, };\n+\n+impl Debug<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_split_self_for_target() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt::Debug;\n+\n+impl std::fmt<|> for Foo {\n+}\n+    \",\n+            \"\n+use std::fmt::{ self, Debug};\n+\n+impl fmt<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_to_nested_self_nested() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt::{Debug, nested::{Display}};\n+\n+impl std::fmt::nested<|> for Foo {\n+}\n+\",\n+            \"\n+use std::fmt::{Debug, nested::{Display, self}};\n+\n+impl nested<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_to_nested_self_already_included() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt::{Debug, nested::{self, Display}};\n+\n+impl std::fmt::nested<|> for Foo {\n+}\n+\",\n+            \"\n+use std::fmt::{Debug, nested::{self, Display}};\n+\n+impl nested<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_to_nested_nested() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt::{Debug, nested::{Display}};\n+\n+impl std::fmt::nested::Debug<|> for Foo {\n+}\n+\",\n+            \"\n+use std::fmt::{Debug, nested::{Display, Debug}};\n+\n+impl Debug<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_alias() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt as foo;\n+\n+impl foo::Debug<|> for Foo {\n+}\n+\",\n+            \"\n+use std::fmt as foo;\n+\n+impl Debug<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_not_applicable_one_segment() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            \"\n+impl foo<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+}"}, {"sha": "af578893efc46b45327450d1b941dc11a5808b32", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b952c270ee87cc36500b3bb03bab9268f2184d1a/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b952c270ee87cc36500b3bb03bab9268f2184d1a/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=b952c270ee87cc36500b3bb03bab9268f2184d1a", "patch": "@@ -84,6 +84,8 @@ mod introduce_variable;\n mod replace_if_let_with_match;\n mod split_import;\n mod remove_dbg;\n+mod auto_import;\n+\n fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assist>] {\n     &[\n         add_derive::add_derive,\n@@ -95,6 +97,7 @@ fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assis\n         replace_if_let_with_match::replace_if_let_with_match,\n         split_import::split_import,\n         remove_dbg::remove_dbg,\n+        auto_import::auto_import,\n     ]\n }\n "}]}