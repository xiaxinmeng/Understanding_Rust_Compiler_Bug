{"sha": "9ccb7108b5284ddcb70920240bf0d4a9b177adb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljY2I3MTA4YjUyODRkZGNiNzA5MjAyNDBiZjBkNGE5YjE3N2FkYjI=", "commit": {"author": {"name": "Cameron Steffen", "email": "CSteffen@trustwave.com", "date": "2017-10-08T22:26:39Z"}, "committer": {"name": "Cameron Steffen", "email": "CSteffen@trustwave.com", "date": "2017-10-08T22:26:39Z"}, "message": "fix never_loop", "tree": {"sha": "470f168e88cd9bcc15dbf55c60caf8a7bedb8a6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/470f168e88cd9bcc15dbf55c60caf8a7bedb8a6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ccb7108b5284ddcb70920240bf0d4a9b177adb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ccb7108b5284ddcb70920240bf0d4a9b177adb2", "html_url": "https://github.com/rust-lang/rust/commit/9ccb7108b5284ddcb70920240bf0d4a9b177adb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ccb7108b5284ddcb70920240bf0d4a9b177adb2/comments", "author": null, "committer": null, "parents": [{"sha": "533a50547f9868ed8a278b80f2504b5ddf65dfb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/533a50547f9868ed8a278b80f2504b5ddf65dfb5", "html_url": "https://github.com/rust-lang/rust/commit/533a50547f9868ed8a278b80f2504b5ddf65dfb5"}], "stats": {"total": 124, "additions": 90, "deletions": 34}, "files": [{"sha": "3b158e280ad25a0eb2654cc5a72bf2ed3d141d81", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 78, "deletions": 34, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9ccb7108b5284ddcb70920240bf0d4a9b177adb2/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ccb7108b5284ddcb70920240bf0d4a9b177adb2/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=9ccb7108b5284ddcb70920240bf0d4a9b177adb2", "patch": "@@ -16,6 +16,7 @@ use rustc::ty::{self, Ty};\n use rustc::ty::subst::{Subst, Substs};\n use rustc_const_eval::ConstContext;\n use std::collections::{HashMap, HashSet};\n+use std::iter::{Iterator, once};\n use syntax::ast;\n use syntax::codemap::Span;\n use utils::sugg;\n@@ -378,7 +379,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         match expr.node {\n             ExprWhile(_, ref block, _) |\n             ExprLoop(ref block, _, _) => {\n-                if never_loop(block, expr.id) {\n+                let mut state = NeverLoopState {\n+                    breaks: HashSet::new(),\n+                    continues: HashSet::new(),\n+                };\n+                let may_complete = never_loop_block(block, &mut state);\n+                if !may_complete && !state.continues.contains(&expr.id) {\n                     span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\");\n                 }\n             },\n@@ -485,31 +491,34 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn never_loop(block: &Block, id: NodeId) -> bool {\n-    !contains_continue_block(block, Some(id)) && loop_exit_block(block, &mut vec![id])\n+struct NeverLoopState {\n+    breaks: HashSet<NodeId>,\n+    continues: HashSet<NodeId>,\n }\n \n-fn loop_exit_block(block: &Block, loops: &mut Vec<NodeId>) -> bool {\n-    block.stmts.iter().take_while(|s| !contains_continue_stmt(s, None)).any(|s| loop_exit_stmt(s, loops))\n-        || block.expr.as_ref().map_or(false, |e| loop_exit_expr(e, loops))\n+fn never_loop_block(block: &Block, state: &mut NeverLoopState) -> bool {\n+    let stmts = block.stmts.iter().map(stmt_to_expr);\n+    let expr = once(block.expr.as_ref().map(|p| &**p));\n+    let mut iter = stmts.chain(expr).filter_map(|e| e);\n+    never_loop_expr_seq(&mut iter, state)\n }\n \n-fn loop_exit_stmt(stmt: &Stmt, loops: &mut Vec<NodeId>) -> bool {\n+fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n     match stmt.node {\n-        StmtSemi(ref e, _) |\n-        StmtExpr(ref e, _) => loop_exit_expr(e, loops),\n-        StmtDecl(ref d, _) => loop_exit_decl(d, loops),\n+        StmtSemi(ref e, ..) |\n+        StmtExpr(ref e, ..) => Some(e),\n+        StmtDecl(ref d, ..) => decl_to_expr(d),\n     }\n }\n \n-fn loop_exit_decl(decl: &Decl, loops: &mut Vec<NodeId>) -> bool {\n+fn decl_to_expr(decl: &Decl) -> Option<&Expr> {\n     match decl.node {\n-        DeclLocal(ref local) => local.init.as_ref().map_or(false, |e| loop_exit_expr(e, loops)),\n-        _ => false,\n+        DeclLocal(ref local) => local.init.as_ref().map(|p| &**p),\n+        _ => None,\n     }\n }\n \n-fn loop_exit_expr(expr: &Expr, loops: &mut Vec<NodeId>) -> bool {\n+fn never_loop_expr(expr: &Expr, state: &mut NeverLoopState) -> bool {\n     match expr.node {\n         ExprBox(ref e) |\n         ExprUnary(_, ref e) |\n@@ -518,38 +527,73 @@ fn loop_exit_expr(expr: &Expr, loops: &mut Vec<NodeId>) -> bool {\n         ExprField(ref e, _) |\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n-        ExprRepeat(ref e, _) => loop_exit_expr(e, loops),\n+        ExprRepeat(ref e, _) => never_loop_expr(e, state),\n         ExprArray(ref es) |\n         ExprMethodCall(_, _, ref es) |\n-        ExprTup(ref es) => es.iter().any(|e| loop_exit_expr(e, loops)),\n-        ExprCall(ref e, ref es) => loop_exit_expr(e, loops) || es.iter().any(|e| loop_exit_expr(e, loops)),\n+        ExprTup(ref es) => never_loop_expr_seq(&mut es.iter(), state),\n+        ExprCall(ref e, ref es) => never_loop_expr_seq(&mut once(&**e).chain(es.iter()), state),\n         ExprBinary(_, ref e1, ref e2) |\n         ExprAssign(ref e1, ref e2) |\n         ExprAssignOp(_, ref e1, ref e2) |\n-        ExprIndex(ref e1, ref e2) => [e1, e2].iter().any(|e| loop_exit_expr(e, loops)),\n-        ExprIf(ref e, ref e2, ref e3) => loop_exit_expr(e, loops)\n-            || e3.as_ref().map_or(false, |e3| loop_exit_expr(e3, loops)) && loop_exit_expr(e2, loops),\n+        ExprIndex(ref e1, ref e2) => never_loop_expr_seq(&mut [&**e1, &**e2].iter().cloned(), state),\n+        ExprIf(ref e, ref e2, ref e3) => {\n+            let e1 = never_loop_expr(e, state);\n+            let e2 = never_loop_expr(e2, state);\n+            match *e3 {\n+                Some(ref e3) => {\n+                    let e3 = never_loop_expr(e3, state);\n+                    e1 && (e2 || e3)\n+                },\n+                None => e1,\n+            }\n+        },\n         ExprLoop(ref b, _, _) => {\n-            loops.push(expr.id);\n-            let val = loop_exit_block(b, loops);\n-            loops.pop();\n-            val\n+            let block_may_complete = never_loop_block(b, state);\n+            let has_break = state.breaks.remove(&expr.id);\n+            state.continues.remove(&expr.id);\n+            block_may_complete || has_break\n         },\n         ExprWhile(ref e, ref b, _) => {\n-            loops.push(expr.id);\n-            let val = loop_exit_expr(e, loops) || loop_exit_block(b, loops);\n-            loops.pop();\n-            val\n+            let e = never_loop_expr(e, state);\n+            let block_may_complete = never_loop_block(b, state);\n+            let has_break = state.breaks.remove(&expr.id);\n+            let has_continue = state.continues.remove(&expr.id);\n+            e && (block_may_complete || has_break || has_continue)\n         },\n-        ExprMatch(ref e, ref arms, _) => loop_exit_expr(e, loops) || arms.iter().all(|a| loop_exit_expr(&a.body, loops)),\n-        ExprBlock(ref b) => loop_exit_block(b, loops),\n-        ExprAgain(d) => d.target_id.opt_id().map_or(false, |id| loops.iter().skip(1).all(|&id2| id != id2)),\n-        ExprBreak(d, _) => d.target_id.opt_id().map_or(false, |id| loops[0] == id),\n-        ExprRet(_) => true,\n-        _ => false,\n+        ExprMatch(ref e, ref arms, _) => {\n+            let e = never_loop_expr(e, state);\n+            let arms = never_loop_expr_branch(&mut arms.iter().map(|a| &*a.body), state);\n+            e && arms\n+        },\n+        ExprBlock(ref b) => never_loop_block(b, state),\n+        ExprAgain(d) => {\n+            let id = d.target_id.opt_id().expect(\"continue is missing target id\");\n+            state.continues.insert(id);\n+            false\n+        },\n+        ExprBreak(d, _) => {\n+            let id = d.target_id.opt_id().expect(\"break is missing target id\");\n+            state.breaks.insert(id);\n+            false\n+        },\n+        ExprRet(ref e) => {\n+            if let Some(ref e) = *e {\n+                never_loop_expr(e, state);\n+            }\n+            false\n+        },\n+        _ => true,\n     }\n }\n \n+fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, state: &mut NeverLoopState) -> bool {\n+    es.map(|e| never_loop_expr(e, state)).fold(true, |a, b| a && b)\n+}\n+\n+fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, state: &mut NeverLoopState) -> bool {\n+    e.map(|e| never_loop_expr(e, state)).fold(false, |a, b| a || b)\n+}\n+\n fn check_for_loop<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     pat: &'tcx Pat,"}, {"sha": "80eeb6c28882d2b2c99e567d5da2ef3b43b07a8b", "filename": "tests/ui/never_loop.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ccb7108b5284ddcb70920240bf0d4a9b177adb2/tests%2Fui%2Fnever_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ccb7108b5284ddcb70920240bf0d4a9b177adb2/tests%2Fui%2Fnever_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.stderr?ref=9ccb7108b5284ddcb70920240bf0d4a9b177adb2", "patch": "@@ -68,3 +68,15 @@ error: this loop never actually loops\n 103 | |     }\n     | |_____^\n \n+error: this loop never actually loops\n+   --> $DIR/never_loop.rs:144:5\n+    |\n+144 | /     'outer: while a { // never loops\n+145 | |         while a {\n+146 | |             if a {\n+147 | |                 a = false;\n+...   |\n+151 | |         break 'outer;\n+152 | |     }\n+    | |_____^\n+"}]}