{"sha": "bb918d0a5bf22211df0423f7474e4e4056978007", "node_id": "C_kwDOAAsO6NoAKGJiOTE4ZDBhNWJmMjIyMTFkZjA0MjNmNzQ3NGU0ZTQwNTY5NzgwMDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-09T10:00:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-09T10:00:54Z"}, "message": "Auto merge of #89698 - matthiaskrgr:rollup-gna54x6, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #88707 (String.split_terminator: Add an example when using a slice of chars)\n - #89605 (Fix stabilization version for `bindings_after_at`)\n - #89634 (rustc_driver: Enable the `WARN` log level by default)\n - #89641 (make #[target_feature] work with `asm` register classes)\n - #89678 (Fix minor std::thread documentation typo)\n - #89684 (Fix asm docs typo)\n - #89687 (Move `read2_abbreviated` function into read2.rs)\n - #89693 (Add #[must_use] to stdin/stdout/stderr locks)\n - #89694 (Add #[must_use] to string/char transformation methods)\n - #89697 (Fix min LLVM version for bpf-types test)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e04106a063fb7c42b2a898f95024ff6ce29fe4ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e04106a063fb7c42b2a898f95024ff6ce29fe4ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb918d0a5bf22211df0423f7474e4e4056978007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb918d0a5bf22211df0423f7474e4e4056978007", "html_url": "https://github.com/rust-lang/rust/commit/bb918d0a5bf22211df0423f7474e4e4056978007", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb918d0a5bf22211df0423f7474e4e4056978007/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "910692de742e9c0b1a57b7c5e467b8b85d903269", "url": "https://api.github.com/repos/rust-lang/rust/commits/910692de742e9c0b1a57b7c5e467b8b85d903269", "html_url": "https://github.com/rust-lang/rust/commit/910692de742e9c0b1a57b7c5e467b8b85d903269"}, {"sha": "2e5a5e22b215b9dc59386315f5562c0517cec064", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e5a5e22b215b9dc59386315f5562c0517cec064", "html_url": "https://github.com/rust-lang/rust/commit/2e5a5e22b215b9dc59386315f5562c0517cec064"}], "stats": {"total": 566, "additions": 361, "deletions": 205}, "files": [{"sha": "957b14f34872962eef8455fcbf1bc5ffa712993d", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -202,39 +202,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let mut used_input_regs = FxHashMap::default();\n         let mut used_output_regs = FxHashMap::default();\n-        let mut required_features: Vec<&str> = vec![];\n+\n         for (idx, &(ref op, op_sp)) in operands.iter().enumerate() {\n             if let Some(reg) = op.reg() {\n-                // Make sure we don't accidentally carry features from the\n-                // previous iteration.\n-                required_features.clear();\n-\n                 let reg_class = reg.reg_class();\n                 if reg_class == asm::InlineAsmRegClass::Err {\n                     continue;\n                 }\n \n-                // We ignore target feature requirements for clobbers: if the\n-                // feature is disabled then the compiler doesn't care what we\n-                // do with the registers.\n-                //\n-                // Note that this is only possible for explicit register\n-                // operands, which cannot be used in the asm string.\n-                let is_clobber = matches!(\n-                    op,\n-                    hir::InlineAsmOperand::Out {\n-                        reg: asm::InlineAsmRegOrRegClass::Reg(_),\n-                        late: _,\n-                        expr: None\n-                    }\n-                );\n-\n                 // Some register classes can only be used as clobbers. This\n                 // means that we disallow passing a value in/out of the asm and\n                 // require that the operand name an explicit register, not a\n                 // register class.\n                 if reg_class.is_clobber_only(asm_arch.unwrap())\n-                    && !(is_clobber && matches!(reg, asm::InlineAsmRegOrRegClass::Reg(_)))\n+                    && !(op.is_clobber() && matches!(reg, asm::InlineAsmRegOrRegClass::Reg(_)))\n                 {\n                     let msg = format!(\n                         \"register class `{}` can only be used as a clobber, \\\n@@ -245,47 +226,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     continue;\n                 }\n \n-                if !is_clobber {\n-                    // Validate register classes against currently enabled target\n-                    // features. We check that at least one type is available for\n-                    // the current target.\n-                    for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n-                        if let Some(feature) = feature {\n-                            if self.sess.target_features.contains(&Symbol::intern(feature)) {\n-                                required_features.clear();\n-                                break;\n-                            } else {\n-                                required_features.push(feature);\n-                            }\n-                        } else {\n-                            required_features.clear();\n-                            break;\n-                        }\n-                    }\n-                    // We are sorting primitive strs here and can use unstable sort here\n-                    required_features.sort_unstable();\n-                    required_features.dedup();\n-                    match &required_features[..] {\n-                        [] => {}\n-                        [feature] => {\n-                            let msg = format!(\n-                                \"register class `{}` requires the `{}` target feature\",\n-                                reg_class.name(),\n-                                feature\n-                            );\n-                            sess.struct_span_err(op_sp, &msg).emit();\n-                        }\n-                        features => {\n-                            let msg = format!(\n-                                \"register class `{}` requires at least one target feature: {}\",\n-                                reg_class.name(),\n-                                features.join(\", \")\n-                            );\n-                            sess.struct_span_err(op_sp, &msg).emit();\n-                        }\n-                    }\n-                }\n-\n                 // Check for conflicts between explicit register operands.\n                 if let asm::InlineAsmRegOrRegClass::Reg(reg) = reg {\n                     let (input, output) = match op {"}, {"sha": "cf1c60588978c33085d32337045a460ec8e4e3a0", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -843,19 +843,18 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         let msg_bus = \"clang: error: unable to execute command: Bus error: 10\";\n         if out.contains(msg_segv) || out.contains(msg_bus) {\n             warn!(\n+                ?cmd, %out,\n                 \"looks like the linker segfaulted when we tried to call it, \\\n-                 automatically retrying again. cmd = {:?}, out = {}.\",\n-                cmd, out,\n+                 automatically retrying again\",\n             );\n             continue;\n         }\n \n         if is_illegal_instruction(&output.status) {\n             warn!(\n+                ?cmd, %out, status = %output.status,\n                 \"looks like the linker hit an illegal instruction when we \\\n-                 tried to call it, automatically retrying again. cmd = {:?}, ]\\\n-                 out = {}, status = {}.\",\n-                cmd, out, output.status,\n+                 tried to call it, automatically retrying again.\",\n             );\n             continue;\n         }"}, {"sha": "05c7e11cbc29a126d5977b6510fc90b3cebfece0", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -1253,12 +1253,16 @@ pub fn init_rustc_env_logger() {\n /// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to choose an env var\n /// other than `RUSTC_LOG`.\n pub fn init_env_logger(env: &str) {\n-    // Don't register a dispatcher if there's no filter to print anything\n-    match std::env::var(env) {\n-        Err(_) => return,\n-        Ok(s) if s.is_empty() => return,\n-        Ok(_) => {}\n-    }\n+    use tracing_subscriber::{\n+        filter::{self, EnvFilter, LevelFilter},\n+        layer::SubscriberExt,\n+    };\n+\n+    let filter = match std::env::var(env) {\n+        Ok(env) => EnvFilter::from_env(env),\n+        _ => EnvFilter::default().add_directive(filter::Directive::from(LevelFilter::WARN)),\n+    };\n+\n     let color_logs = match std::env::var(String::from(env) + \"_COLOR\") {\n         Ok(value) => match value.as_ref() {\n             \"always\" => true,\n@@ -1278,7 +1282,7 @@ pub fn init_env_logger(env: &str) {\n             \"non-Unicode log color value: expected one of always, never, or auto\",\n         ),\n     };\n-    let filter = tracing_subscriber::EnvFilter::from_env(env);\n+\n     let layer = tracing_tree::HierarchicalLayer::default()\n         .with_writer(io::stderr)\n         .with_indent_lines(true)\n@@ -1288,7 +1292,6 @@ pub fn init_env_logger(env: &str) {\n     #[cfg(parallel_compiler)]\n     let layer = layer.with_thread_ids(true).with_thread_names(true);\n \n-    use tracing_subscriber::layer::SubscriberExt;\n     let subscriber = tracing_subscriber::Registry::default().with(filter).with(layer);\n     tracing::subscriber::set_global_default(subscriber).unwrap();\n }"}, {"sha": "778d58eeadcf0344ae3ec63c72c9c661259b6988", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -2308,7 +2308,7 @@ pub fn is_case_difference(sm: &SourceMap, suggested: &str, sp: Span) -> bool {\n     let found = match sm.span_to_snippet(sp) {\n         Ok(snippet) => snippet,\n         Err(e) => {\n-            warn!(\"Invalid span {:?}. Err={:?}\", sp, e);\n+            warn!(error = ?e, \"Invalid span {:?}\", sp);\n             return false;\n         }\n     };"}, {"sha": "55ec3703df8f8ba7a107fa05331eda26567bb0a5", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -288,7 +288,7 @@ declare_features! (\n     (accepted, member_constraints, \"1.54.0\", Some(61997), None),\n     /// Allows bindings in the subpattern of a binding pattern.\n     /// For example, you can write `x @ Some(y)`.\n-    (accepted, bindings_after_at, \"1.54.0\", Some(65490), None),\n+    (accepted, bindings_after_at, \"1.56.0\", Some(65490), None),\n     /// Allows calling `transmute` in const fn\n     (accepted, const_fn_transmute, \"1.56.0\", Some(53605), None),\n     /// Allows accessing fields of unions inside `const` functions."}, {"sha": "5264f7cc326128edea67e2d149ae524971589288", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -2293,6 +2293,13 @@ impl<'hir> InlineAsmOperand<'hir> {\n             Self::Const { .. } | Self::Sym { .. } => None,\n         }\n     }\n+\n+    pub fn is_clobber(&self) -> bool {\n+        matches!(\n+            self,\n+            InlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(_), late: _, expr: None }\n+        )\n+    }\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "c0bf4b659aa9674c12fa61201d51571afe3decaf", "filename": "compiler/rustc_mir_dataflow/src/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -289,7 +289,7 @@ impl<'tcx> RustcPeekAt<'tcx> for MaybeMutBorrowedLocals<'_, 'tcx> {\n         flow_state: &BitSet<Local>,\n         call: PeekCall,\n     ) {\n-        warn!(\"peek_at: place={:?}\", place);\n+        info!(?place, \"peek_at\");\n         let local = if let Some(l) = place.as_local() {\n             l\n         } else {\n@@ -311,7 +311,7 @@ impl<'tcx> RustcPeekAt<'tcx> for MaybeLiveLocals {\n         flow_state: &BitSet<Local>,\n         call: PeekCall,\n     ) {\n-        warn!(\"peek_at: place={:?}\", place);\n+        info!(?place, \"peek_at\");\n         let local = if let Some(l) = place.as_local() {\n             l\n         } else {"}, {"sha": "008b856ebf2fab873801412b4aa325000afff27b", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 120, "deletions": 16, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -141,6 +141,7 @@ impl ExprVisitor<'tcx> {\n         template: &[InlineAsmTemplatePiece],\n         is_input: bool,\n         tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n+        target_features: &[Symbol],\n     ) -> Option<InlineAsmType> {\n         // Check the type against the allowed types for inline asm.\n         let ty = self.typeck_results.expr_ty_adjusted(expr);\n@@ -283,17 +284,20 @@ impl ExprVisitor<'tcx> {\n         };\n \n         // Check whether the selected type requires a target feature. Note that\n-        // this is different from the feature check we did earlier in AST\n-        // lowering. While AST lowering checked that this register class is\n-        // usable at all with the currently enabled features, some types may\n-        // only be usable with a register class when a certain feature is\n-        // enabled. We check this here since it depends on the results of typeck.\n+        // this is different from the feature check we did earlier. While the\n+        // previous check checked that this register class is usable at all\n+        // with the currently enabled features, some types may only be usable\n+        // with a register class when a certain feature is enabled. We check\n+        // this here since it depends on the results of typeck.\n         //\n         // Also note that this check isn't run when the operand type is never\n-        // (!). In that case we still need the earlier check in AST lowering to\n-        // verify that the register class is usable at all.\n+        // (!). In that case we still need the earlier check to verify that the\n+        // register class is usable at all.\n         if let Some(feature) = feature {\n-            if !self.tcx.sess.target_features.contains(&Symbol::intern(feature)) {\n+            let feat_sym = Symbol::intern(feature);\n+            if !self.tcx.sess.target_features.contains(&feat_sym)\n+                && !target_features.contains(&feat_sym)\n+            {\n                 let msg = &format!(\"`{}` target feature is not enabled\", feature);\n                 let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n                 err.note(&format!(\n@@ -349,23 +353,122 @@ impl ExprVisitor<'tcx> {\n         Some(asm_ty)\n     }\n \n-    fn check_asm(&self, asm: &hir::InlineAsm<'tcx>) {\n-        for (idx, (op, _)) in asm.operands.iter().enumerate() {\n+    fn check_asm(&self, asm: &hir::InlineAsm<'tcx>, hir_id: hir::HirId) {\n+        let hir = self.tcx.hir();\n+        let enclosing_id = hir.enclosing_body_owner(hir_id);\n+        let enclosing_def_id = hir.local_def_id(enclosing_id).to_def_id();\n+        let attrs = self.tcx.codegen_fn_attrs(enclosing_def_id);\n+        for (idx, (op, op_sp)) in asm.operands.iter().enumerate() {\n+            // Validate register classes against currently enabled target\n+            // features. We check that at least one type is available for\n+            // the enabled features.\n+            //\n+            // We ignore target feature requirements for clobbers: if the\n+            // feature is disabled then the compiler doesn't care what we\n+            // do with the registers.\n+            //\n+            // Note that this is only possible for explicit register\n+            // operands, which cannot be used in the asm string.\n+            if let Some(reg) = op.reg() {\n+                if !op.is_clobber() {\n+                    let mut missing_required_features = vec![];\n+                    let reg_class = reg.reg_class();\n+                    for &(_, feature) in reg_class.supported_types(self.tcx.sess.asm_arch.unwrap())\n+                    {\n+                        match feature {\n+                            Some(feature) => {\n+                                let feat_sym = Symbol::intern(feature);\n+                                if self.tcx.sess.target_features.contains(&feat_sym)\n+                                    || attrs.target_features.contains(&feat_sym)\n+                                {\n+                                    missing_required_features.clear();\n+                                    break;\n+                                } else {\n+                                    missing_required_features.push(feature);\n+                                }\n+                            }\n+                            None => {\n+                                missing_required_features.clear();\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    // We are sorting primitive strs here and can use unstable sort here\n+                    missing_required_features.sort_unstable();\n+                    missing_required_features.dedup();\n+                    match &missing_required_features[..] {\n+                        [] => {}\n+                        [feature] => {\n+                            let msg = format!(\n+                                \"register class `{}` requires the `{}` target feature\",\n+                                reg_class.name(),\n+                                feature\n+                            );\n+                            self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                            // register isn't enabled, don't do more checks\n+                            continue;\n+                        }\n+                        features => {\n+                            let msg = format!(\n+                                \"register class `{}` requires at least one of the following target features: {}\",\n+                                reg_class.name(),\n+                                features.join(\", \")\n+                            );\n+                            self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                            // register isn't enabled, don't do more checks\n+                            continue;\n+                        }\n+                    }\n+                }\n+            }\n+\n             match *op {\n                 hir::InlineAsmOperand::In { reg, ref expr } => {\n-                    self.check_asm_operand_type(idx, reg, expr, asm.template, true, None);\n+                    self.check_asm_operand_type(\n+                        idx,\n+                        reg,\n+                        expr,\n+                        asm.template,\n+                        true,\n+                        None,\n+                        &attrs.target_features,\n+                    );\n                 }\n                 hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n                     if let Some(expr) = expr {\n-                        self.check_asm_operand_type(idx, reg, expr, asm.template, false, None);\n+                        self.check_asm_operand_type(\n+                            idx,\n+                            reg,\n+                            expr,\n+                            asm.template,\n+                            false,\n+                            None,\n+                            &attrs.target_features,\n+                        );\n                     }\n                 }\n                 hir::InlineAsmOperand::InOut { reg, late: _, ref expr } => {\n-                    self.check_asm_operand_type(idx, reg, expr, asm.template, false, None);\n+                    self.check_asm_operand_type(\n+                        idx,\n+                        reg,\n+                        expr,\n+                        asm.template,\n+                        false,\n+                        None,\n+                        &attrs.target_features,\n+                    );\n                 }\n                 hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n-                    let in_ty =\n-                        self.check_asm_operand_type(idx, reg, in_expr, asm.template, true, None);\n+                    let in_ty = self.check_asm_operand_type(\n+                        idx,\n+                        reg,\n+                        in_expr,\n+                        asm.template,\n+                        true,\n+                        None,\n+                        &attrs.target_features,\n+                    );\n                     if let Some(out_expr) = out_expr {\n                         self.check_asm_operand_type(\n                             idx,\n@@ -374,6 +477,7 @@ impl ExprVisitor<'tcx> {\n                             asm.template,\n                             false,\n                             Some((in_expr, in_ty)),\n+                            &attrs.target_features,\n                         );\n                     }\n                 }\n@@ -422,7 +526,7 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::InlineAsm(asm) => self.check_asm(asm),\n+            hir::ExprKind::InlineAsm(asm) => self.check_asm(asm, expr.hir_id),\n \n             _ => {}\n         }"}, {"sha": "860f21085f32542ffc1854ba2dfe55bea5ee2106", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -662,6 +662,8 @@ impl [u8] {\n     ///\n     /// [`make_ascii_uppercase`]: slice::make_ascii_uppercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[must_use = \"this returns the uppercase bytes as a new Vec, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n@@ -680,6 +682,8 @@ impl [u8] {\n     ///\n     /// [`make_ascii_lowercase`]: slice::make_ascii_lowercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[must_use = \"this returns the lowercase bytes as a new Vec, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> Vec<u8> {"}, {"sha": "2900d01d9bdae6bdc27c54b7a9909760d5461884", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -367,6 +367,8 @@ impl str {\n     /// assert_eq!(new_year, new_year.to_lowercase());\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[must_use = \"this returns the lowercase string as a new String, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_lowercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());\n@@ -447,6 +449,8 @@ impl str {\n     /// assert_eq!(\"TSCH\u00dcSS\", s.to_uppercase());\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[must_use = \"this returns the uppercase string as a new String, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());\n@@ -534,6 +538,7 @@ impl str {\n     /// [`make_ascii_uppercase`]: str::make_ascii_uppercase\n     /// [`to_uppercase`]: #method.to_uppercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[must_use = \"to uppercase the value in-place, use `make_ascii_lowercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> String {\n@@ -565,6 +570,7 @@ impl str {\n     /// [`make_ascii_lowercase`]: str::make_ascii_lowercase\n     /// [`to_lowercase`]: #method.to_lowercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[must_use = \"to lowercase the value in-place, use `make_ascii_lowercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> String {"}, {"sha": "b3af1f1ffb5928dd00556dfa884c6b98804b06a1", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -949,6 +949,8 @@ impl char {\n     /// // convert into themselves.\n     /// assert_eq!('\u5c71'.to_lowercase().to_string(), \"\u5c71\");\n     /// ```\n+    #[must_use = \"this returns the lowercase character as a new iterator, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_lowercase(self) -> ToLowercase {\n@@ -1039,6 +1041,8 @@ impl char {\n     /// ```\n     ///\n     /// holds across languages.\n+    #[must_use = \"this returns the uppercase character as a new iterator, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_uppercase(self) -> ToUppercase {\n@@ -1085,6 +1089,7 @@ impl char {\n     ///\n     /// [`make_ascii_uppercase()`]: #method.make_ascii_uppercase\n     /// [`to_uppercase()`]: #method.to_uppercase\n+    #[must_use = \"to uppercase the value in-place, use `make_ascii_uppercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.52.0\")]\n     #[inline]\n@@ -1118,6 +1123,7 @@ impl char {\n     ///\n     /// [`make_ascii_lowercase()`]: #method.make_ascii_lowercase\n     /// [`to_lowercase()`]: #method.to_lowercase\n+    #[must_use = \"to lowercase the value in-place, use `make_ascii_lowercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.52.0\")]\n     #[inline]"}, {"sha": "44918a711d47046e7955b7e9bc9c4c2c5a3ac826", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -282,6 +282,7 @@ impl u8 {\n     /// ```\n     ///\n     /// [`make_ascii_uppercase`]: Self::make_ascii_uppercase\n+    #[must_use = \"to uppercase the value in-place, use `make_ascii_uppercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.52.0\")]\n     #[inline]\n@@ -306,6 +307,7 @@ impl u8 {\n     /// ```\n     ///\n     /// [`make_ascii_lowercase`]: Self::make_ascii_lowercase\n+    #[must_use = \"to lowercase the value in-place, use `make_ascii_lowercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.52.0\")]\n     #[inline]\n@@ -769,6 +771,8 @@ impl u8 {\n     /// assert_eq!(\"\\\\\\\\\", b'\\\\'.escape_ascii().to_string());\n     /// assert_eq!(\"\\\\x9d\", b'\\x9d'.escape_ascii().to_string());\n     /// ```\n+    #[must_use = \"this returns the escaped byte as an iterator, \\\n+                  without modifying the original\"]\n     #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n     #[inline]\n     pub fn escape_ascii(&self) -> ascii::EscapeDefault {"}, {"sha": "cbb5627cef9820b544ee98e3251d58efb65a29db", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -72,6 +72,8 @@ impl [u8] {\n     /// let escaped = s.escape_ascii().to_string();\n     /// assert_eq!(escaped, \"0\\\\t\\\\r\\\\n\\\\'\\\\\\\"\\\\\\\\\\\\x9d\");\n     /// ```\n+    #[must_use = \"this returns the escaped bytes as an iterator, \\\n+                  without modifying the original\"]\n     #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n     pub fn escape_ascii(&self) -> EscapeAscii<'_> {\n         EscapeAscii { inner: self.iter().flat_map(EscapeByte) }"}, {"sha": "f25ab52cfa0d010c315b5f125604ca9cca614964", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -798,6 +798,8 @@ impl str {\n     ///\n     /// assert_eq!(None, iter.next());\n     /// ```\n+    #[must_use = \"this returns the split string as an iterator, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n     #[inline]\n     pub fn split_whitespace(&self) -> SplitWhitespace<'_> {\n@@ -839,6 +841,8 @@ impl str {\n     ///\n     /// assert_eq!(None, iter.next());\n     /// ```\n+    #[must_use = \"this returns the split string as an iterator, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n     #[inline]\n     pub fn split_ascii_whitespace(&self) -> SplitAsciiWhitespace<'_> {\n@@ -914,6 +918,8 @@ impl str {\n     ///\n     /// assert!(utf16_len <= utf8_len);\n     /// ```\n+    #[must_use = \"this returns the encoded string as an iterator, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n     pub fn encode_utf16(&self) -> EncodeUtf16<'_> {\n         EncodeUtf16 { chars: self.chars(), extra: 0 }\n@@ -1353,6 +1359,9 @@ impl str {\n     ///\n     /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n     /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A.B:C.D\".split_terminator(&['.', ':'][..]).collect();\n+    /// assert_eq!(v, [\"A\", \"B\", \"C\", \"D\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1396,6 +1405,9 @@ impl str {\n     ///\n     /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n     /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A.B:C.D\".rsplit_terminator(&['.', ':'][..]).collect();\n+    /// assert_eq!(v, [\"D\", \"C\", \"B\", \"A\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1840,6 +1852,8 @@ impl str {\n     /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea\";\n     /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n     /// ```\n+    #[must_use = \"this returns the trimmed string as a new slice, \\\n+                  without modifying the original\"]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(\n@@ -1882,6 +1896,8 @@ impl str {\n     /// let s = \"\u05e2\u05d1\u05e8\u05d9\u05ea  \";\n     /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n     /// ```\n+    #[must_use = \"this returns the trimmed string as a new slice, \\\n+                  without modifying the original\"]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(\n@@ -2346,6 +2362,8 @@ impl str {\n     /// ```\n     /// assert_eq!(\"\u2764\\n!\".escape_debug().to_string(), \"\u2764\\\\n!\");\n     /// ```\n+    #[must_use = \"this returns the escaped string as an iterator, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n     pub fn escape_debug(&self) -> EscapeDebug<'_> {\n         let mut chars = self.chars();\n@@ -2390,6 +2408,8 @@ impl str {\n     /// ```\n     /// assert_eq!(\"\u2764\\n!\".escape_default().to_string(), \"\\\\u{2764}\\\\n!\");\n     /// ```\n+    #[must_use = \"this returns the escaped string as an iterator, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n     pub fn escape_default(&self) -> EscapeDefault<'_> {\n         EscapeDefault { inner: self.chars().flat_map(CharEscapeDefault) }\n@@ -2426,6 +2446,8 @@ impl str {\n     /// ```\n     /// assert_eq!(\"\u2764\\n!\".escape_unicode().to_string(), \"\\\\u{2764}\\\\u{a}\\\\u{21}\");\n     /// ```\n+    #[must_use = \"this returns the escaped string as an iterator, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n     pub fn escape_unicode(&self) -> EscapeUnicode<'_> {\n         EscapeUnicode { inner: self.chars().flat_map(CharEscapeUnicode) }"}, {"sha": "c305519dd4461ad549a98d7a65778b7278e301d1", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -777,6 +777,7 @@ impl OsStr {\n     ///\n     /// assert_eq!(\"gr\u00fc\u00dfe, j\u00fcrgen \u2764\", s.to_ascii_lowercase());\n     /// ```\n+    #[must_use = \"to lowercase the value in-place, use `make_ascii_lowercase`\"]\n     #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n     pub fn to_ascii_lowercase(&self) -> OsString {\n         OsString::from_inner(self.inner.to_ascii_lowercase())\n@@ -798,6 +799,7 @@ impl OsStr {\n     ///\n     /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s.to_ascii_uppercase());\n     /// ```\n+    #[must_use = \"to uppercase the value in-place, use `make_ascii_uppercase`\"]\n     #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n     pub fn to_ascii_uppercase(&self) -> OsString {\n         OsString::from_inner(self.inner.to_ascii_uppercase())"}, {"sha": "1ac3bbc95c66dea8d405ddd7fb76e58704803b2d", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -256,6 +256,7 @@ pub struct Stdin {\n ///     Ok(())\n /// }\n /// ```\n+#[must_use = \"if unused stdin will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdinLock<'a> {\n     inner: MutexGuard<'a, BufReader<StdinRaw>>,\n@@ -624,6 +625,7 @@ pub struct Stdout {\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n+#[must_use = \"if unused stdout will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdoutLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n@@ -907,6 +909,7 @@ pub struct Stderr {\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n+#[must_use = \"if unused stderr will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StderrLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<StderrRaw>>,"}, {"sha": "7d404aff30e0792bde572ebb70ccd2f3c12e378b", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -412,9 +412,9 @@ impl Builder {\n     ///\n     /// # Safety\n     ///\n-    /// The caller has to ensure that no references in the supplied thread closure\n-    /// or its return type can outlive the spawned thread's lifetime. This can be\n-    /// guaranteed in two ways:\n+    /// The caller has to ensure that the spawned thread does not outlive any\n+    /// references in the supplied thread closure and its return type.\n+    /// This can be guaranteed in two ways:\n     ///\n     /// - ensure that [`join`][`JoinHandle::join`] is called before any referenced\n     /// data is dropped"}, {"sha": "a2afa88028fea4c8b0ae77796555950f587f8b7b", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -613,8 +613,8 @@ Each register class has constraints on which value types they can be used with.\n | x86 | `xmm_reg` | `sse` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n | x86 | `ymm_reg` | `avx` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` |\n | x86 | `zmm_reg` | `avx512f` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` <br> `i8x64`, `i16x32`, `i32x16`, `i64x8`, `f32x16`, `f64x8` |\n-| x86 | `kreg` | `axv512f` | `i8`, `i16` |\n-| x86 | `kreg` | `axv512bw` | `i32`, `i64` |\n+| x86 | `kreg` | `avx512f` | `i8`, `i16` |\n+| x86 | `kreg` | `avx512bw` | `i32`, `i64` |\n | x86 | `mmx_reg` | N/A | Only clobbers |\n | x86 | `x87_reg` | N/A | Only clobbers |\n | AArch64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |"}, {"sha": "7271ef11287efcfd8c6614ffd25291adc5fb7045", "filename": "src/test/assembly/asm/bpf-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fassembly%2Fasm%2Fbpf-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fassembly%2Fasm%2Fbpf-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fbpf-types.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -1,4 +1,4 @@\n-// min-llvm-version: 10.0.1\n+// min-llvm-version: 13.0\n // assembly-output: emit-asm\n // compile-flags: --target bpfel-unknown-none -C target_feature=+alu32\n // needs-llvm-components: bpf"}, {"sha": "91d0f8c33f9793c58a0d8b37e6e20f7c3a321036", "filename": "src/test/ui/asm/x86_64/bad-reg.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -21,10 +21,6 @@ fn main() {\n         //~^ ERROR asm template modifiers are not allowed for `const` arguments\n         asm!(\"{:a}\", sym main);\n         //~^ ERROR asm template modifiers are not allowed for `sym` arguments\n-        asm!(\"{}\", in(zmm_reg) foo);\n-        //~^ ERROR register class `zmm_reg` requires the `avx512f` target feature\n-        asm!(\"\", in(\"zmm0\") foo);\n-        //~^ ERROR register class `zmm_reg` requires the `avx512f` target feature\n         asm!(\"\", in(\"ebp\") foo);\n         //~^ ERROR invalid register `ebp`: the frame pointer cannot be used as an operand\n         asm!(\"\", in(\"rsp\") foo);"}, {"sha": "102a17e981570d4fe857639cbfb50742dc228288", "filename": "src/test/ui/asm/x86_64/bad-reg.stderr", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -46,127 +46,115 @@ LL |         asm!(\"{:a}\", sym main);\n    |               |\n    |               template modifier\n \n-error: register class `zmm_reg` requires the `avx512f` target feature\n-  --> $DIR/bad-reg.rs:24:20\n-   |\n-LL |         asm!(\"{}\", in(zmm_reg) foo);\n-   |                    ^^^^^^^^^^^^^^^\n-\n-error: register class `zmm_reg` requires the `avx512f` target feature\n-  --> $DIR/bad-reg.rs:26:18\n-   |\n-LL |         asm!(\"\", in(\"zmm0\") foo);\n-   |                  ^^^^^^^^^^^^^^\n-\n error: invalid register `ebp`: the frame pointer cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:28:18\n+  --> $DIR/bad-reg.rs:24:18\n    |\n LL |         asm!(\"\", in(\"ebp\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: invalid register `rsp`: the stack pointer cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:30:18\n+  --> $DIR/bad-reg.rs:26:18\n    |\n LL |         asm!(\"\", in(\"rsp\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: invalid register `ip`: the instruction pointer cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:32:18\n+  --> $DIR/bad-reg.rs:28:18\n    |\n LL |         asm!(\"\", in(\"ip\") foo);\n    |                  ^^^^^^^^^^^^\n \n error: invalid register `k0`: the k0 AVX mask register cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:34:18\n+  --> $DIR/bad-reg.rs:30:18\n    |\n LL |         asm!(\"\", in(\"k0\") foo);\n    |                  ^^^^^^^^^^^^\n \n error: invalid register `ah`: high byte registers cannot be used as an operand on x86_64\n-  --> $DIR/bad-reg.rs:36:18\n+  --> $DIR/bad-reg.rs:32:18\n    |\n LL |         asm!(\"\", in(\"ah\") foo);\n    |                  ^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:39:18\n+  --> $DIR/bad-reg.rs:35:18\n    |\n LL |         asm!(\"\", in(\"st(2)\") foo);\n    |                  ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:41:18\n+  --> $DIR/bad-reg.rs:37:18\n    |\n LL |         asm!(\"\", in(\"mm0\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:45:20\n+  --> $DIR/bad-reg.rs:41:20\n    |\n LL |         asm!(\"{}\", in(x87_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:47:20\n+  --> $DIR/bad-reg.rs:43:20\n    |\n LL |         asm!(\"{}\", in(mmx_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:49:20\n+  --> $DIR/bad-reg.rs:45:20\n    |\n LL |         asm!(\"{}\", out(x87_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:51:20\n+  --> $DIR/bad-reg.rs:47:20\n    |\n LL |         asm!(\"{}\", out(mmx_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register `al` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:57:33\n+  --> $DIR/bad-reg.rs:53:33\n    |\n LL |         asm!(\"\", in(\"eax\") foo, in(\"al\") bar);\n    |                  -------------  ^^^^^^^^^^^^ register `al`\n    |                  |\n    |                  register `ax`\n \n error: register `ax` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:59:33\n+  --> $DIR/bad-reg.rs:55:33\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  -------------  ^^^^^^^^^^^^^^ register `ax`\n    |                  |\n    |                  register `ax`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:59:18\n+  --> $DIR/bad-reg.rs:55:18\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  ^^^^^^^^^^^^^\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:62:34\n+  --> $DIR/bad-reg.rs:58:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, in(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:64:34\n+  --> $DIR/bad-reg.rs:60:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:64:18\n+  --> $DIR/bad-reg.rs:60:18\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  ^^^^^^^^^^^^^^\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 21 previous errors\n "}, {"sha": "4f82cd8aab9d03ea768165993e85c93aa58a7a7d", "filename": "src/test/ui/asm/x86_64/target-feature-attr.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -0,0 +1,40 @@\n+// only-x86_64\n+\n+#![feature(asm, avx512_target_feature)]\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn foo() {\n+    let mut x = 1;\n+    let y = 2;\n+    asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+    assert_eq!(x, 3);\n+}\n+\n+unsafe fn bar() {\n+    let mut x = 1;\n+    let y = 2;\n+    asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+    //~^ ERROR: register class `ymm_reg` requires the `avx` target feature\n+    //~| ERROR: register class `ymm_reg` requires the `avx` target feature\n+    //~| ERROR: register class `ymm_reg` requires the `avx` target feature\n+    assert_eq!(x, 3);\n+}\n+\n+#[target_feature(enable = \"avx512bw\")]\n+unsafe fn baz() {\n+    let x = 1;\n+    asm!(\"/* {0} */\", in(kreg) x);\n+}\n+\n+unsafe fn baz2() {\n+    let x = 1;\n+    asm!(\"/* {0} */\", in(kreg) x);\n+    //~^ ERROR: register class `kreg` requires at least one of the following target features: avx512bw, avx512f\n+}\n+\n+fn main() {\n+    unsafe {\n+        foo();\n+        bar();\n+    }\n+}"}, {"sha": "295c8a97ed3bc4607a03a7f3a6948f941df349a2", "filename": "src/test/ui/asm/x86_64/target-feature-attr.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.stderr?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -0,0 +1,26 @@\n+error: register class `ymm_reg` requires the `avx` target feature\n+  --> $DIR/target-feature-attr.rs:16:40\n+   |\n+LL |     asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+   |                                        ^^^^^^^^^^^^^\n+\n+error: register class `ymm_reg` requires the `avx` target feature\n+  --> $DIR/target-feature-attr.rs:16:55\n+   |\n+LL |     asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+   |                                                       ^^^^^^^^^^^^^\n+\n+error: register class `ymm_reg` requires the `avx` target feature\n+  --> $DIR/target-feature-attr.rs:16:70\n+   |\n+LL |     asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+   |                                                                      ^^^^^^^^^^^^^^^^^^\n+\n+error: register class `kreg` requires at least one of the following target features: avx512bw, avx512f\n+  --> $DIR/target-feature-attr.rs:31:23\n+   |\n+LL |     asm!(\"/* {0} */\", in(kreg) x);\n+   |                       ^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c82dea4aa50dfbc8b9c2f0ade78f5d6aa1e2797b", "filename": "src/test/ui/consts/const_in_pattern/issue-73431.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-73431.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-73431.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-73431.stderr?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -0,0 +1 @@\n+WARN rustc_mir_build::thir::pattern::const_to_pat MIR const-checker found novel structural match violation. See #73448."}, {"sha": "897b9dd4007939b07acded6460dc01737eb7c4d8", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -2,6 +2,77 @@\n // Consider unify the read2() in libstd, cargo and this to prevent further code duplication.\n \n pub use self::imp::read2;\n+use std::io;\n+use std::process::{Child, Output};\n+\n+pub fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n+    use io::Write;\n+    use std::mem::replace;\n+\n+    const HEAD_LEN: usize = 160 * 1024;\n+    const TAIL_LEN: usize = 256 * 1024;\n+\n+    enum ProcOutput {\n+        Full(Vec<u8>),\n+        Abbreviated { head: Vec<u8>, skipped: usize, tail: Box<[u8]> },\n+    }\n+\n+    impl ProcOutput {\n+        fn extend(&mut self, data: &[u8]) {\n+            let new_self = match *self {\n+                ProcOutput::Full(ref mut bytes) => {\n+                    bytes.extend_from_slice(data);\n+                    let new_len = bytes.len();\n+                    if new_len <= HEAD_LEN + TAIL_LEN {\n+                        return;\n+                    }\n+                    let tail = bytes.split_off(new_len - TAIL_LEN).into_boxed_slice();\n+                    let head = replace(bytes, Vec::new());\n+                    let skipped = new_len - HEAD_LEN - TAIL_LEN;\n+                    ProcOutput::Abbreviated { head, skipped, tail }\n+                }\n+                ProcOutput::Abbreviated { ref mut skipped, ref mut tail, .. } => {\n+                    *skipped += data.len();\n+                    if data.len() <= TAIL_LEN {\n+                        tail[..data.len()].copy_from_slice(data);\n+                        tail.rotate_left(data.len());\n+                    } else {\n+                        tail.copy_from_slice(&data[(data.len() - TAIL_LEN)..]);\n+                    }\n+                    return;\n+                }\n+            };\n+            *self = new_self;\n+        }\n+\n+        fn into_bytes(self) -> Vec<u8> {\n+            match self {\n+                ProcOutput::Full(bytes) => bytes,\n+                ProcOutput::Abbreviated { mut head, skipped, tail } => {\n+                    write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n+                    head.extend_from_slice(&tail);\n+                    head\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut stdout = ProcOutput::Full(Vec::new());\n+    let mut stderr = ProcOutput::Full(Vec::new());\n+\n+    drop(child.stdin.take());\n+    read2(\n+        child.stdout.take().unwrap(),\n+        child.stderr.take().unwrap(),\n+        &mut |is_stdout, data, _| {\n+            if is_stdout { &mut stdout } else { &mut stderr }.extend(data);\n+            data.clear();\n+        },\n+    )?;\n+    let status = child.wait()?;\n+\n+    Ok(Output { status, stdout: stdout.into_bytes(), stderr: stderr.into_bytes() })\n+}\n \n #[cfg(not(any(unix, windows)))]\n mod imp {"}, {"sha": "934839bbd605b0202a7fadf64ec20393d746f953", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 2, "deletions": 70, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb918d0a5bf22211df0423f7474e4e4056978007/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=bb918d0a5bf22211df0423f7474e4e4056978007", "patch": "@@ -12,6 +12,7 @@ use crate::compute_diff::{write_diff, write_filtered_diff};\n use crate::errors::{self, Error, ErrorKind};\n use crate::header::TestProps;\n use crate::json;\n+use crate::read2::read2_abbreviated;\n use crate::util::get_pointer_width;\n use crate::util::{logv, PathBufExt};\n use crate::ColorConfig;\n@@ -27,7 +28,7 @@ use std::hash::{Hash, Hasher};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n-use std::process::{Child, Command, ExitStatus, Output, Stdio};\n+use std::process::{Command, ExitStatus, Output, Stdio};\n use std::str;\n \n use glob::glob;\n@@ -3820,72 +3821,3 @@ enum AllowUnused {\n     Yes,\n     No,\n }\n-\n-fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n-    use crate::read2::read2;\n-    use std::mem::replace;\n-\n-    const HEAD_LEN: usize = 160 * 1024;\n-    const TAIL_LEN: usize = 256 * 1024;\n-\n-    enum ProcOutput {\n-        Full(Vec<u8>),\n-        Abbreviated { head: Vec<u8>, skipped: usize, tail: Box<[u8]> },\n-    }\n-\n-    impl ProcOutput {\n-        fn extend(&mut self, data: &[u8]) {\n-            let new_self = match *self {\n-                ProcOutput::Full(ref mut bytes) => {\n-                    bytes.extend_from_slice(data);\n-                    let new_len = bytes.len();\n-                    if new_len <= HEAD_LEN + TAIL_LEN {\n-                        return;\n-                    }\n-                    let tail = bytes.split_off(new_len - TAIL_LEN).into_boxed_slice();\n-                    let head = replace(bytes, Vec::new());\n-                    let skipped = new_len - HEAD_LEN - TAIL_LEN;\n-                    ProcOutput::Abbreviated { head, skipped, tail }\n-                }\n-                ProcOutput::Abbreviated { ref mut skipped, ref mut tail, .. } => {\n-                    *skipped += data.len();\n-                    if data.len() <= TAIL_LEN {\n-                        tail[..data.len()].copy_from_slice(data);\n-                        tail.rotate_left(data.len());\n-                    } else {\n-                        tail.copy_from_slice(&data[(data.len() - TAIL_LEN)..]);\n-                    }\n-                    return;\n-                }\n-            };\n-            *self = new_self;\n-        }\n-\n-        fn into_bytes(self) -> Vec<u8> {\n-            match self {\n-                ProcOutput::Full(bytes) => bytes,\n-                ProcOutput::Abbreviated { mut head, skipped, tail } => {\n-                    write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n-                    head.extend_from_slice(&tail);\n-                    head\n-                }\n-            }\n-        }\n-    }\n-\n-    let mut stdout = ProcOutput::Full(Vec::new());\n-    let mut stderr = ProcOutput::Full(Vec::new());\n-\n-    drop(child.stdin.take());\n-    read2(\n-        child.stdout.take().unwrap(),\n-        child.stderr.take().unwrap(),\n-        &mut |is_stdout, data, _| {\n-            if is_stdout { &mut stdout } else { &mut stderr }.extend(data);\n-            data.clear();\n-        },\n-    )?;\n-    let status = child.wait()?;\n-\n-    Ok(Output { status, stdout: stdout.into_bytes(), stderr: stderr.into_bytes() })\n-}"}]}