{"sha": "3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa", "node_id": "C_kwDOAAsO6NoAKDNmODA0Y2E2ZDNkZThiOWM0MmY1NWQzM2MwMDI0ZjU0MzdlY2Q2ZmE", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-09-18T04:43:39Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-09-29T03:46:43Z"}, "message": "Move `update_lints` specific code out of `lib`", "tree": {"sha": "cb84a1f0fc465dd34e889dc0940acd31ec004eff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb84a1f0fc465dd34e889dc0940acd31ec004eff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa", "html_url": "https://github.com/rust-lang/rust/commit/3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa/comments", "author": null, "committer": null, "parents": [{"sha": "e6747df5cd4232d26747a556c263d0a5d9c72414", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6747df5cd4232d26747a556c263d0a5d9c72414", "html_url": "https://github.com/rust-lang/rust/commit/e6747df5cd4232d26747a556c263d0a5d9c72414"}], "stats": {"total": 1105, "additions": 551, "deletions": 554}, "files": [{"sha": "5538f62c8e786c0f2f16092fa5a754ace47c5988", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 550, "changes": 551, "blob_url": "https://github.com/rust-lang/rust/blob/3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa", "patch": "@@ -3,14 +3,7 @@\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n-use itertools::Itertools;\n-use regex::Regex;\n-use std::collections::{BTreeSet, HashMap};\n-use std::ffi::OsStr;\n-use std::fs;\n-use std::lazy::SyncLazy;\n-use std::path::{Path, PathBuf};\n-use walkdir::WalkDir;\n+use std::path::PathBuf;\n \n pub mod bless;\n pub mod fmt;\n@@ -19,339 +12,6 @@ pub mod serve;\n pub mod setup;\n pub mod update_lints;\n \n-const GENERATED_FILE_COMMENT: &str = \"// This file was generated by `cargo dev update_lints`.\\n\\\n-     // Use that command to update this file and do not edit by hand.\\n\\\n-     // Manual edits will be overwritten.\\n\\n\";\n-\n-static DEC_CLIPPY_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n-    Regex::new(\n-        r#\"(?x)\n-    declare_clippy_lint!\\s*[\\{(]\n-    (?:\\s+///.*)*\n-    \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n-    (?P<cat>[a-z_]+)\\s*,\\s*\n-    \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n-\"#,\n-    )\n-    .unwrap()\n-});\n-\n-static DEC_DEPRECATED_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n-    Regex::new(\n-        r#\"(?x)\n-    declare_deprecated_lint!\\s*[{(]\\s*\n-    (?:\\s+///.*)*\n-    \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n-    \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n-\"#,\n-    )\n-    .unwrap()\n-});\n-static NL_ESCAPE_RE: SyncLazy<Regex> = SyncLazy::new(|| Regex::new(r#\"\\\\\\n\\s*\"#).unwrap());\n-\n-pub static DOCS_LINK: &str = \"https://rust-lang.github.io/rust-clippy/master/index.html\";\n-\n-/// Lint data parsed from the Clippy source code.\n-#[derive(Clone, PartialEq, Debug)]\n-pub struct Lint {\n-    pub name: String,\n-    pub group: String,\n-    pub desc: String,\n-    pub deprecation: Option<String>,\n-    pub module: String,\n-}\n-\n-impl Lint {\n-    #[must_use]\n-    pub fn new(name: &str, group: &str, desc: &str, deprecation: Option<&str>, module: &str) -> Self {\n-        Self {\n-            name: name.to_lowercase(),\n-            group: group.to_string(),\n-            desc: NL_ESCAPE_RE.replace(&desc.replace(\"\\\\\\\"\", \"\\\"\"), \"\").to_string(),\n-            deprecation: deprecation.map(ToString::to_string),\n-            module: module.to_string(),\n-        }\n-    }\n-\n-    /// Returns all non-deprecated lints and non-internal lints\n-    #[must_use]\n-    pub fn usable_lints(lints: &[Self]) -> Vec<Self> {\n-        lints\n-            .iter()\n-            .filter(|l| l.deprecation.is_none() && !l.group.starts_with(\"internal\"))\n-            .cloned()\n-            .collect()\n-    }\n-\n-    /// Returns all internal lints (not `internal_warn` lints)\n-    #[must_use]\n-    pub fn internal_lints(lints: &[Self]) -> Vec<Self> {\n-        lints.iter().filter(|l| l.group == \"internal\").cloned().collect()\n-    }\n-\n-    /// Returns all deprecated lints\n-    #[must_use]\n-    pub fn deprecated_lints(lints: &[Self]) -> Vec<Self> {\n-        lints.iter().filter(|l| l.deprecation.is_some()).cloned().collect()\n-    }\n-\n-    /// Returns the lints in a `HashMap`, grouped by the different lint groups\n-    #[must_use]\n-    pub fn by_lint_group(lints: impl Iterator<Item = Self>) -> HashMap<String, Vec<Self>> {\n-        lints.map(|lint| (lint.group.to_string(), lint)).into_group_map()\n-    }\n-}\n-\n-/// Generates the code for registering a group\n-pub fn gen_lint_group_list<'a>(group_name: &str, lints: impl Iterator<Item = &'a Lint>) -> String {\n-    let mut details: Vec<_> = lints.map(|l| (&l.module, l.name.to_uppercase())).collect();\n-    details.sort_unstable();\n-\n-    let mut output = GENERATED_FILE_COMMENT.to_string();\n-\n-    output.push_str(&format!(\n-        \"store.register_group(true, \\\"clippy::{0}\\\", Some(\\\"clippy_{0}\\\"), vec![\\n\",\n-        group_name\n-    ));\n-    for (module, name) in details {\n-        output.push_str(&format!(\"    LintId::of({}::{}),\\n\", module, name));\n-    }\n-    output.push_str(\"])\\n\");\n-\n-    output\n-}\n-\n-/// Generates the module declarations for `lints`\n-#[must_use]\n-pub fn gen_modules_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> String {\n-    let module_names: BTreeSet<_> = lints.map(|l| &l.module).collect();\n-\n-    let mut output = GENERATED_FILE_COMMENT.to_string();\n-    for name in module_names {\n-        output.push_str(&format!(\"mod {};\\n\", name));\n-    }\n-    output\n-}\n-\n-/// Generates the list of lint links at the bottom of the README\n-#[must_use]\n-pub fn gen_changelog_lint_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n-    lints\n-        .sorted_by_key(|l| &l.name)\n-        .map(|l| format!(\"[`{}`]: {}#{}\", l.name, DOCS_LINK, l.name))\n-        .collect()\n-}\n-\n-/// Generates the `register_removed` code\n-#[must_use]\n-pub fn gen_deprecated<'a>(lints: impl Iterator<Item = &'a Lint>) -> String {\n-    let mut output = GENERATED_FILE_COMMENT.to_string();\n-    output.push_str(\"{\\n\");\n-    for Lint { name, deprecation, .. } in lints {\n-        output.push_str(&format!(\n-            concat!(\n-                \"    store.register_removed(\\n\",\n-                \"        \\\"clippy::{}\\\",\\n\",\n-                \"        \\\"{}\\\",\\n\",\n-                \"    );\\n\"\n-            ),\n-            name,\n-            deprecation.as_ref().expect(\"`lints` are deprecated\")\n-        ));\n-    }\n-    output.push_str(\"}\\n\");\n-\n-    output\n-}\n-\n-/// Generates the code for registering lints\n-#[must_use]\n-pub fn gen_register_lint_list<'a>(\n-    internal_lints: impl Iterator<Item = &'a Lint>,\n-    usable_lints: impl Iterator<Item = &'a Lint>,\n-) -> String {\n-    let mut details: Vec<_> = internal_lints\n-        .map(|l| (false, &l.module, l.name.to_uppercase()))\n-        .chain(usable_lints.map(|l| (true, &l.module, l.name.to_uppercase())))\n-        .collect();\n-    details.sort_unstable();\n-\n-    let mut output = GENERATED_FILE_COMMENT.to_string();\n-    output.push_str(\"store.register_lints(&[\\n\");\n-\n-    for (is_public, module_name, lint_name) in details {\n-        if !is_public {\n-            output.push_str(\"    #[cfg(feature = \\\"internal-lints\\\")]\\n\");\n-        }\n-        output.push_str(&format!(\"    {}::{},\\n\", module_name, lint_name));\n-    }\n-    output.push_str(\"])\\n\");\n-\n-    output\n-}\n-\n-/// Gathers all files in `src/clippy_lints` and gathers all lints inside\n-pub fn gather_all() -> impl Iterator<Item = Lint> {\n-    lint_files().flat_map(|f| gather_from_file(&f))\n-}\n-\n-fn gather_from_file(dir_entry: &walkdir::DirEntry) -> impl Iterator<Item = Lint> {\n-    let content = fs::read_to_string(dir_entry.path()).unwrap();\n-    let path = dir_entry.path();\n-    let filename = path.file_stem().unwrap();\n-    let path_buf = path.with_file_name(filename);\n-    let mut rel_path = path_buf\n-        .strip_prefix(clippy_project_root().join(\"clippy_lints/src\"))\n-        .expect(\"only files in `clippy_lints/src` should be looked at\");\n-    // If the lints are stored in mod.rs, we get the module name from\n-    // the containing directory:\n-    if filename == \"mod\" {\n-        rel_path = rel_path.parent().unwrap();\n-    }\n-\n-    let module = rel_path\n-        .components()\n-        .map(|c| c.as_os_str().to_str().unwrap())\n-        .collect::<Vec<_>>()\n-        .join(\"::\");\n-\n-    parse_contents(&content, &module)\n-}\n-\n-fn parse_contents(content: &str, module: &str) -> impl Iterator<Item = Lint> {\n-    let lints = DEC_CLIPPY_LINT_RE\n-        .captures_iter(content)\n-        .map(|m| Lint::new(&m[\"name\"], &m[\"cat\"], &m[\"desc\"], None, module));\n-    let deprecated = DEC_DEPRECATED_LINT_RE\n-        .captures_iter(content)\n-        .map(|m| Lint::new(&m[\"name\"], \"Deprecated\", &m[\"desc\"], Some(&m[\"desc\"]), module));\n-    // Removing the `.collect::<Vec<Lint>>().into_iter()` causes some lifetime issues due to the map\n-    lints.chain(deprecated).collect::<Vec<Lint>>().into_iter()\n-}\n-\n-/// Collects all .rs files in the `clippy_lints/src` directory\n-fn lint_files() -> impl Iterator<Item = walkdir::DirEntry> {\n-    // We use `WalkDir` instead of `fs::read_dir` here in order to recurse into subdirectories.\n-    // Otherwise we would not collect all the lints, for example in `clippy_lints/src/methods/`.\n-    let path = clippy_project_root().join(\"clippy_lints/src\");\n-    WalkDir::new(path)\n-        .into_iter()\n-        .filter_map(Result::ok)\n-        .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n-}\n-\n-/// Whether a file has had its text changed or not\n-#[derive(PartialEq, Debug)]\n-pub struct FileChange {\n-    pub changed: bool,\n-    pub new_lines: String,\n-}\n-\n-/// Replaces a region in a file delimited by two lines matching regexes.\n-///\n-/// `path` is the relative path to the file on which you want to perform the replacement.\n-///\n-/// See `replace_region_in_text` for documentation of the other options.\n-///\n-/// # Panics\n-///\n-/// Panics if the path could not read or then written\n-pub fn replace_region_in_file<F>(\n-    path: &Path,\n-    start: &str,\n-    end: &str,\n-    replace_start: bool,\n-    write_back: bool,\n-    replacements: F,\n-) -> FileChange\n-where\n-    F: FnOnce() -> Vec<String>,\n-{\n-    let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from {}: {}\", path.display(), e));\n-    let file_change = replace_region_in_text(&contents, start, end, replace_start, replacements);\n-\n-    if write_back {\n-        if let Err(e) = fs::write(path, file_change.new_lines.as_bytes()) {\n-            panic!(\"Cannot write to {}: {}\", path.display(), e);\n-        }\n-    }\n-    file_change\n-}\n-\n-/// Replaces a region in a text delimited by two lines matching regexes.\n-///\n-/// * `text` is the input text on which you want to perform the replacement\n-/// * `start` is a `&str` that describes the delimiter line before the region you want to replace.\n-///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n-/// * `end` is a `&str` that describes the delimiter line until where the replacement should happen.\n-///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n-/// * If `replace_start` is true, the `start` delimiter line is replaced as well. The `end`\n-///   delimiter line is never replaced.\n-/// * `replacements` is a closure that has to return a `Vec<String>` which contains the new text.\n-///\n-/// If you want to perform the replacement on files instead of already parsed text,\n-/// use `replace_region_in_file`.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let the_text = \"replace_start\\nsome text\\nthat will be replaced\\nreplace_end\";\n-/// let result =\n-///     clippy_dev::replace_region_in_text(the_text, \"replace_start\", \"replace_end\", false, || {\n-///         vec![\"a different\".to_string(), \"text\".to_string()]\n-///     })\n-///     .new_lines;\n-/// assert_eq!(\"replace_start\\na different\\ntext\\nreplace_end\", result);\n-/// ```\n-///\n-/// # Panics\n-///\n-/// Panics if start or end is not valid regex\n-pub fn replace_region_in_text<F>(text: &str, start: &str, end: &str, replace_start: bool, replacements: F) -> FileChange\n-where\n-    F: FnOnce() -> Vec<String>,\n-{\n-    let replace_it = replacements();\n-    let mut in_old_region = false;\n-    let mut found = false;\n-    let mut new_lines = vec![];\n-    let start = Regex::new(start).unwrap();\n-    let end = Regex::new(end).unwrap();\n-\n-    for line in text.lines() {\n-        if in_old_region {\n-            if end.is_match(line) {\n-                in_old_region = false;\n-                new_lines.extend(replace_it.clone());\n-                new_lines.push(line.to_string());\n-            }\n-        } else if start.is_match(line) {\n-            if !replace_start {\n-                new_lines.push(line.to_string());\n-            }\n-            in_old_region = true;\n-            found = true;\n-        } else {\n-            new_lines.push(line.to_string());\n-        }\n-    }\n-\n-    if !found {\n-        // This happens if the provided regex in `clippy_dev/src/main.rs` does not match in the\n-        // given text or file. Most likely this is an error on the programmer's side and the Regex\n-        // is incorrect.\n-        eprintln!(\"error: regex \\n{:?}\\ndoesn't match. You may have to update it.\", start);\n-        std::process::exit(1);\n-    }\n-\n-    let mut new_lines = new_lines.join(\"\\n\");\n-    if text.ends_with('\\n') {\n-        new_lines.push('\\n');\n-    }\n-    let changed = new_lines != text;\n-    FileChange { changed, new_lines }\n-}\n-\n /// Returns the path to the Clippy project directory\n ///\n /// # Panics\n@@ -376,212 +36,3 @@ pub fn clippy_project_root() -> PathBuf {\n     }\n     panic!(\"error: Can't determine root of project. Please run inside a Clippy working dir.\");\n }\n-\n-#[test]\n-fn test_parse_contents() {\n-    let result: Vec<Lint> = parse_contents(\n-        r#\"\n-declare_clippy_lint! {\n-    pub PTR_ARG,\n-    style,\n-    \"really long \\\n-     text\"\n-}\n-\n-declare_clippy_lint!{\n-    pub DOC_MARKDOWN,\n-    pedantic,\n-    \"single line\"\n-}\n-\n-/// some doc comment\n-declare_deprecated_lint! {\n-    pub SHOULD_ASSERT_EQ,\n-    \"`assert!()` will be more flexible with RFC 2011\"\n-}\n-    \"#,\n-        \"module_name\",\n-    )\n-    .collect();\n-\n-    let expected = vec![\n-        Lint::new(\"ptr_arg\", \"style\", \"really long text\", None, \"module_name\"),\n-        Lint::new(\"doc_markdown\", \"pedantic\", \"single line\", None, \"module_name\"),\n-        Lint::new(\n-            \"should_assert_eq\",\n-            \"Deprecated\",\n-            \"`assert!()` will be more flexible with RFC 2011\",\n-            Some(\"`assert!()` will be more flexible with RFC 2011\"),\n-            \"module_name\",\n-        ),\n-    ];\n-    assert_eq!(expected, result);\n-}\n-\n-#[test]\n-fn test_replace_region() {\n-    let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n-    let expected = FileChange {\n-        changed: true,\n-        new_lines: \"\\nabc\\nhello world\\ndef\\nghi\".to_string(),\n-    };\n-    let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, false, || {\n-        vec![\"hello world\".to_string()]\n-    });\n-    assert_eq!(expected, result);\n-}\n-\n-#[test]\n-fn test_replace_region_with_start() {\n-    let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n-    let expected = FileChange {\n-        changed: true,\n-        new_lines: \"\\nhello world\\ndef\\nghi\".to_string(),\n-    };\n-    let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, true, || {\n-        vec![\"hello world\".to_string()]\n-    });\n-    assert_eq!(expected, result);\n-}\n-\n-#[test]\n-fn test_replace_region_no_changes() {\n-    let text = \"123\\n456\\n789\";\n-    let expected = FileChange {\n-        changed: false,\n-        new_lines: \"123\\n456\\n789\".to_string(),\n-    };\n-    let result = replace_region_in_text(text, r#\"^\\s*123$\"#, r#\"^\\s*456\"#, false, Vec::new);\n-    assert_eq!(expected, result);\n-}\n-\n-#[test]\n-fn test_usable_lints() {\n-    let lints = vec![\n-        Lint::new(\"should_assert_eq\", \"Deprecated\", \"abc\", Some(\"Reason\"), \"module_name\"),\n-        Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"abc\", None, \"module_name\"),\n-        Lint::new(\"should_assert_eq2\", \"internal\", \"abc\", None, \"module_name\"),\n-        Lint::new(\"should_assert_eq2\", \"internal_style\", \"abc\", None, \"module_name\"),\n-    ];\n-    let expected = vec![Lint::new(\n-        \"should_assert_eq2\",\n-        \"Not Deprecated\",\n-        \"abc\",\n-        None,\n-        \"module_name\",\n-    )];\n-    assert_eq!(expected, Lint::usable_lints(&lints));\n-}\n-\n-#[test]\n-fn test_by_lint_group() {\n-    let lints = vec![\n-        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-        Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n-        Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n-    ];\n-    let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n-    expected.insert(\n-        \"group1\".to_string(),\n-        vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n-        ],\n-    );\n-    expected.insert(\n-        \"group2\".to_string(),\n-        vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")],\n-    );\n-    assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n-}\n-\n-#[test]\n-fn test_gen_changelog_lint_list() {\n-    let lints = vec![\n-        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-        Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n-    ];\n-    let expected = vec![\n-        format!(\"[`should_assert_eq`]: {}#should_assert_eq\", DOCS_LINK.to_string()),\n-        format!(\"[`should_assert_eq2`]: {}#should_assert_eq2\", DOCS_LINK.to_string()),\n-    ];\n-    assert_eq!(expected, gen_changelog_lint_list(lints.iter()));\n-}\n-\n-#[test]\n-fn test_gen_deprecated() {\n-    let lints = vec![\n-        Lint::new(\n-            \"should_assert_eq\",\n-            \"group1\",\n-            \"abc\",\n-            Some(\"has been superseded by should_assert_eq2\"),\n-            \"module_name\",\n-        ),\n-        Lint::new(\n-            \"another_deprecated\",\n-            \"group2\",\n-            \"abc\",\n-            Some(\"will be removed\"),\n-            \"module_name\",\n-        ),\n-    ];\n-\n-    let expected = GENERATED_FILE_COMMENT.to_string()\n-        + &[\n-            \"{\",\n-            \"    store.register_removed(\",\n-            \"        \\\"clippy::should_assert_eq\\\",\",\n-            \"        \\\"has been superseded by should_assert_eq2\\\",\",\n-            \"    );\",\n-            \"    store.register_removed(\",\n-            \"        \\\"clippy::another_deprecated\\\",\",\n-            \"        \\\"will be removed\\\",\",\n-            \"    );\",\n-            \"}\",\n-        ]\n-        .join(\"\\n\")\n-        + \"\\n\";\n-\n-    assert_eq!(expected, gen_deprecated(lints.iter()));\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_gen_deprecated_fail() {\n-    let lints = vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")];\n-    let _deprecated_lints = gen_deprecated(lints.iter());\n-}\n-\n-#[test]\n-fn test_gen_modules_list() {\n-    let lints = vec![\n-        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-        Lint::new(\"incorrect_stuff\", \"group3\", \"abc\", None, \"another_module\"),\n-    ];\n-    let expected = GENERATED_FILE_COMMENT.to_string() + &[\"mod another_module;\", \"mod module_name;\"].join(\"\\n\") + \"\\n\";\n-    assert_eq!(expected, gen_modules_list(lints.iter()));\n-}\n-\n-#[test]\n-fn test_gen_lint_group_list() {\n-    let lints = vec![\n-        Lint::new(\"abc\", \"group1\", \"abc\", None, \"module_name\"),\n-        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-        Lint::new(\"internal\", \"internal_style\", \"abc\", None, \"module_name\"),\n-    ];\n-    let expected = GENERATED_FILE_COMMENT.to_string()\n-        + &[\n-            \"store.register_group(true, \\\"clippy::group1\\\", Some(\\\"clippy_group1\\\"), vec![\",\n-            \"    LintId::of(module_name::ABC),\",\n-            \"    LintId::of(module_name::INTERNAL),\",\n-            \"    LintId::of(module_name::SHOULD_ASSERT_EQ),\",\n-            \"])\",\n-        ]\n-        .join(\"\\n\")\n-        + \"\\n\";\n-\n-    let result = gen_lint_group_list(\"group1\", lints.iter());\n-\n-    assert_eq!(expected, result);\n-}"}, {"sha": "f713f3c6da004e3c2d26beac9a4fd4d7994e2841", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 550, "deletions": 4, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=3f804ca6d3de8b9c42f55d33c0024f5437ecd6fa", "patch": "@@ -1,9 +1,45 @@\n-use crate::{\n-    gather_all, gen_changelog_lint_list, gen_deprecated, gen_lint_group_list, gen_modules_list, gen_register_lint_list,\n-    replace_region_in_file, Lint, DOCS_LINK,\n-};\n+use itertools::Itertools;\n+use regex::Regex;\n+use std::collections::{BTreeSet, HashMap};\n+use std::ffi::OsStr;\n use std::fs;\n+use std::lazy::SyncLazy;\n use std::path::Path;\n+use walkdir::WalkDir;\n+\n+use crate::clippy_project_root;\n+\n+const GENERATED_FILE_COMMENT: &str = \"// This file was generated by `cargo dev update_lints`.\\n\\\n+     // Use that command to update this file and do not edit by hand.\\n\\\n+     // Manual edits will be overwritten.\\n\\n\";\n+\n+static DEC_CLIPPY_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n+    Regex::new(\n+        r#\"(?x)\n+    declare_clippy_lint!\\s*[\\{(]\n+    (?:\\s+///.*)*\n+    \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n+    (?P<cat>[a-z_]+)\\s*,\\s*\n+    \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n+\"#,\n+    )\n+    .unwrap()\n+});\n+\n+static DEC_DEPRECATED_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n+    Regex::new(\n+        r#\"(?x)\n+    declare_deprecated_lint!\\s*[{(]\\s*\n+    (?:\\s+///.*)*\n+    \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n+    \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n+\"#,\n+    )\n+    .unwrap()\n+});\n+static NL_ESCAPE_RE: SyncLazy<Regex> = SyncLazy::new(|| Regex::new(r#\"\\\\\\n\\s*\"#).unwrap());\n+\n+static DOCS_LINK: &str = \"https://rust-lang.github.io/rust-clippy/master/index.html\";\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum UpdateMode {\n@@ -147,3 +183,513 @@ fn exit_with_failure() {\n     );\n     std::process::exit(1);\n }\n+\n+/// Lint data parsed from the Clippy source code.\n+#[derive(Clone, PartialEq, Debug)]\n+struct Lint {\n+    name: String,\n+    group: String,\n+    desc: String,\n+    deprecation: Option<String>,\n+    module: String,\n+}\n+\n+impl Lint {\n+    #[must_use]\n+    fn new(name: &str, group: &str, desc: &str, deprecation: Option<&str>, module: &str) -> Self {\n+        Self {\n+            name: name.to_lowercase(),\n+            group: group.to_string(),\n+            desc: NL_ESCAPE_RE.replace(&desc.replace(\"\\\\\\\"\", \"\\\"\"), \"\").to_string(),\n+            deprecation: deprecation.map(ToString::to_string),\n+            module: module.to_string(),\n+        }\n+    }\n+\n+    /// Returns all non-deprecated lints and non-internal lints\n+    #[must_use]\n+    fn usable_lints(lints: &[Self]) -> Vec<Self> {\n+        lints\n+            .iter()\n+            .filter(|l| l.deprecation.is_none() && !l.group.starts_with(\"internal\"))\n+            .cloned()\n+            .collect()\n+    }\n+\n+    /// Returns all internal lints (not `internal_warn` lints)\n+    #[must_use]\n+    fn internal_lints(lints: &[Self]) -> Vec<Self> {\n+        lints.iter().filter(|l| l.group == \"internal\").cloned().collect()\n+    }\n+\n+    /// Returns all deprecated lints\n+    #[must_use]\n+    fn deprecated_lints(lints: &[Self]) -> Vec<Self> {\n+        lints.iter().filter(|l| l.deprecation.is_some()).cloned().collect()\n+    }\n+\n+    /// Returns the lints in a `HashMap`, grouped by the different lint groups\n+    #[must_use]\n+    fn by_lint_group(lints: impl Iterator<Item = Self>) -> HashMap<String, Vec<Self>> {\n+        lints.map(|lint| (lint.group.to_string(), lint)).into_group_map()\n+    }\n+}\n+\n+/// Generates the code for registering a group\n+fn gen_lint_group_list<'a>(group_name: &str, lints: impl Iterator<Item = &'a Lint>) -> String {\n+    let mut details: Vec<_> = lints.map(|l| (&l.module, l.name.to_uppercase())).collect();\n+    details.sort_unstable();\n+\n+    let mut output = GENERATED_FILE_COMMENT.to_string();\n+\n+    output.push_str(&format!(\n+        \"store.register_group(true, \\\"clippy::{0}\\\", Some(\\\"clippy_{0}\\\"), vec![\\n\",\n+        group_name\n+    ));\n+    for (module, name) in details {\n+        output.push_str(&format!(\"    LintId::of({}::{}),\\n\", module, name));\n+    }\n+    output.push_str(\"])\\n\");\n+\n+    output\n+}\n+\n+/// Generates the module declarations for `lints`\n+#[must_use]\n+fn gen_modules_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> String {\n+    let module_names: BTreeSet<_> = lints.map(|l| &l.module).collect();\n+\n+    let mut output = GENERATED_FILE_COMMENT.to_string();\n+    for name in module_names {\n+        output.push_str(&format!(\"mod {};\\n\", name));\n+    }\n+    output\n+}\n+\n+/// Generates the list of lint links at the bottom of the README\n+#[must_use]\n+fn gen_changelog_lint_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n+    lints\n+        .sorted_by_key(|l| &l.name)\n+        .map(|l| format!(\"[`{}`]: {}#{}\", l.name, DOCS_LINK, l.name))\n+        .collect()\n+}\n+\n+/// Generates the `register_removed` code\n+#[must_use]\n+fn gen_deprecated<'a>(lints: impl Iterator<Item = &'a Lint>) -> String {\n+    let mut output = GENERATED_FILE_COMMENT.to_string();\n+    output.push_str(\"{\\n\");\n+    for Lint { name, deprecation, .. } in lints {\n+        output.push_str(&format!(\n+            concat!(\n+                \"    store.register_removed(\\n\",\n+                \"        \\\"clippy::{}\\\",\\n\",\n+                \"        \\\"{}\\\",\\n\",\n+                \"    );\\n\"\n+            ),\n+            name,\n+            deprecation.as_ref().expect(\"`lints` are deprecated\")\n+        ));\n+    }\n+    output.push_str(\"}\\n\");\n+\n+    output\n+}\n+\n+/// Generates the code for registering lints\n+#[must_use]\n+fn gen_register_lint_list<'a>(\n+    internal_lints: impl Iterator<Item = &'a Lint>,\n+    usable_lints: impl Iterator<Item = &'a Lint>,\n+) -> String {\n+    let mut details: Vec<_> = internal_lints\n+        .map(|l| (false, &l.module, l.name.to_uppercase()))\n+        .chain(usable_lints.map(|l| (true, &l.module, l.name.to_uppercase())))\n+        .collect();\n+    details.sort_unstable();\n+\n+    let mut output = GENERATED_FILE_COMMENT.to_string();\n+    output.push_str(\"store.register_lints(&[\\n\");\n+\n+    for (is_public, module_name, lint_name) in details {\n+        if !is_public {\n+            output.push_str(\"    #[cfg(feature = \\\"internal-lints\\\")]\\n\");\n+        }\n+        output.push_str(&format!(\"    {}::{},\\n\", module_name, lint_name));\n+    }\n+    output.push_str(\"])\\n\");\n+\n+    output\n+}\n+\n+/// Gathers all files in `src/clippy_lints` and gathers all lints inside\n+fn gather_all() -> impl Iterator<Item = Lint> {\n+    lint_files().flat_map(|f| gather_from_file(&f))\n+}\n+\n+fn gather_from_file(dir_entry: &walkdir::DirEntry) -> impl Iterator<Item = Lint> {\n+    let content = fs::read_to_string(dir_entry.path()).unwrap();\n+    let path = dir_entry.path();\n+    let filename = path.file_stem().unwrap();\n+    let path_buf = path.with_file_name(filename);\n+    let mut rel_path = path_buf\n+        .strip_prefix(clippy_project_root().join(\"clippy_lints/src\"))\n+        .expect(\"only files in `clippy_lints/src` should be looked at\");\n+    // If the lints are stored in mod.rs, we get the module name from\n+    // the containing directory:\n+    if filename == \"mod\" {\n+        rel_path = rel_path.parent().unwrap();\n+    }\n+\n+    let module = rel_path\n+        .components()\n+        .map(|c| c.as_os_str().to_str().unwrap())\n+        .collect::<Vec<_>>()\n+        .join(\"::\");\n+\n+    parse_contents(&content, &module)\n+}\n+\n+fn parse_contents(content: &str, module: &str) -> impl Iterator<Item = Lint> {\n+    let lints = DEC_CLIPPY_LINT_RE\n+        .captures_iter(content)\n+        .map(|m| Lint::new(&m[\"name\"], &m[\"cat\"], &m[\"desc\"], None, module));\n+    let deprecated = DEC_DEPRECATED_LINT_RE\n+        .captures_iter(content)\n+        .map(|m| Lint::new(&m[\"name\"], \"Deprecated\", &m[\"desc\"], Some(&m[\"desc\"]), module));\n+    // Removing the `.collect::<Vec<Lint>>().into_iter()` causes some lifetime issues due to the map\n+    lints.chain(deprecated).collect::<Vec<Lint>>().into_iter()\n+}\n+\n+/// Collects all .rs files in the `clippy_lints/src` directory\n+fn lint_files() -> impl Iterator<Item = walkdir::DirEntry> {\n+    // We use `WalkDir` instead of `fs::read_dir` here in order to recurse into subdirectories.\n+    // Otherwise we would not collect all the lints, for example in `clippy_lints/src/methods/`.\n+    let path = clippy_project_root().join(\"clippy_lints/src\");\n+    WalkDir::new(path)\n+        .into_iter()\n+        .filter_map(Result::ok)\n+        .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n+}\n+\n+/// Whether a file has had its text changed or not\n+#[derive(PartialEq, Debug)]\n+struct FileChange {\n+    changed: bool,\n+    new_lines: String,\n+}\n+\n+/// Replaces a region in a file delimited by two lines matching regexes.\n+///\n+/// `path` is the relative path to the file on which you want to perform the replacement.\n+///\n+/// See `replace_region_in_text` for documentation of the other options.\n+///\n+/// # Panics\n+///\n+/// Panics if the path could not read or then written\n+fn replace_region_in_file<F>(\n+    path: &Path,\n+    start: &str,\n+    end: &str,\n+    replace_start: bool,\n+    write_back: bool,\n+    replacements: F,\n+) -> FileChange\n+where\n+    F: FnOnce() -> Vec<String>,\n+{\n+    let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from {}: {}\", path.display(), e));\n+    let file_change = replace_region_in_text(&contents, start, end, replace_start, replacements);\n+\n+    if write_back {\n+        if let Err(e) = fs::write(path, file_change.new_lines.as_bytes()) {\n+            panic!(\"Cannot write to {}: {}\", path.display(), e);\n+        }\n+    }\n+    file_change\n+}\n+\n+/// Replaces a region in a text delimited by two lines matching regexes.\n+///\n+/// * `text` is the input text on which you want to perform the replacement\n+/// * `start` is a `&str` that describes the delimiter line before the region you want to replace.\n+///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n+/// * `end` is a `&str` that describes the delimiter line until where the replacement should happen.\n+///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n+/// * If `replace_start` is true, the `start` delimiter line is replaced as well. The `end`\n+///   delimiter line is never replaced.\n+/// * `replacements` is a closure that has to return a `Vec<String>` which contains the new text.\n+///\n+/// If you want to perform the replacement on files instead of already parsed text,\n+/// use `replace_region_in_file`.\n+///\n+/// # Example\n+///\n+/// ```ignore\n+/// let the_text = \"replace_start\\nsome text\\nthat will be replaced\\nreplace_end\";\n+/// let result =\n+///     replace_region_in_text(the_text, \"replace_start\", \"replace_end\", false, || {\n+///         vec![\"a different\".to_string(), \"text\".to_string()]\n+///     })\n+///     .new_lines;\n+/// assert_eq!(\"replace_start\\na different\\ntext\\nreplace_end\", result);\n+/// ```\n+///\n+/// # Panics\n+///\n+/// Panics if start or end is not valid regex\n+fn replace_region_in_text<F>(text: &str, start: &str, end: &str, replace_start: bool, replacements: F) -> FileChange\n+where\n+    F: FnOnce() -> Vec<String>,\n+{\n+    let replace_it = replacements();\n+    let mut in_old_region = false;\n+    let mut found = false;\n+    let mut new_lines = vec![];\n+    let start = Regex::new(start).unwrap();\n+    let end = Regex::new(end).unwrap();\n+\n+    for line in text.lines() {\n+        if in_old_region {\n+            if end.is_match(line) {\n+                in_old_region = false;\n+                new_lines.extend(replace_it.clone());\n+                new_lines.push(line.to_string());\n+            }\n+        } else if start.is_match(line) {\n+            if !replace_start {\n+                new_lines.push(line.to_string());\n+            }\n+            in_old_region = true;\n+            found = true;\n+        } else {\n+            new_lines.push(line.to_string());\n+        }\n+    }\n+\n+    if !found {\n+        // This happens if the provided regex in `clippy_dev/src/main.rs` does not match in the\n+        // given text or file. Most likely this is an error on the programmer's side and the Regex\n+        // is incorrect.\n+        eprintln!(\"error: regex \\n{:?}\\ndoesn't match. You may have to update it.\", start);\n+        std::process::exit(1);\n+    }\n+\n+    let mut new_lines = new_lines.join(\"\\n\");\n+    if text.ends_with('\\n') {\n+        new_lines.push('\\n');\n+    }\n+    let changed = new_lines != text;\n+    FileChange { changed, new_lines }\n+}\n+\n+#[test]\n+fn test_parse_contents() {\n+    let result: Vec<Lint> = parse_contents(\n+        r#\"\n+declare_clippy_lint! {\n+    pub PTR_ARG,\n+    style,\n+    \"really long \\\n+     text\"\n+}\n+\n+declare_clippy_lint!{\n+    pub DOC_MARKDOWN,\n+    pedantic,\n+    \"single line\"\n+}\n+\n+/// some doc comment\n+declare_deprecated_lint! {\n+    pub SHOULD_ASSERT_EQ,\n+    \"`assert!()` will be more flexible with RFC 2011\"\n+}\n+    \"#,\n+        \"module_name\",\n+    )\n+    .collect();\n+\n+    let expected = vec![\n+        Lint::new(\"ptr_arg\", \"style\", \"really long text\", None, \"module_name\"),\n+        Lint::new(\"doc_markdown\", \"pedantic\", \"single line\", None, \"module_name\"),\n+        Lint::new(\n+            \"should_assert_eq\",\n+            \"Deprecated\",\n+            \"`assert!()` will be more flexible with RFC 2011\",\n+            Some(\"`assert!()` will be more flexible with RFC 2011\"),\n+            \"module_name\",\n+        ),\n+    ];\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_replace_region() {\n+    let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n+    let expected = FileChange {\n+        changed: true,\n+        new_lines: \"\\nabc\\nhello world\\ndef\\nghi\".to_string(),\n+    };\n+    let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, false, || {\n+        vec![\"hello world\".to_string()]\n+    });\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_replace_region_with_start() {\n+    let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n+    let expected = FileChange {\n+        changed: true,\n+        new_lines: \"\\nhello world\\ndef\\nghi\".to_string(),\n+    };\n+    let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, true, || {\n+        vec![\"hello world\".to_string()]\n+    });\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_replace_region_no_changes() {\n+    let text = \"123\\n456\\n789\";\n+    let expected = FileChange {\n+        changed: false,\n+        new_lines: \"123\\n456\\n789\".to_string(),\n+    };\n+    let result = replace_region_in_text(text, r#\"^\\s*123$\"#, r#\"^\\s*456\"#, false, Vec::new);\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_usable_lints() {\n+    let lints = vec![\n+        Lint::new(\"should_assert_eq\", \"Deprecated\", \"abc\", Some(\"Reason\"), \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"internal\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"internal_style\", \"abc\", None, \"module_name\"),\n+    ];\n+    let expected = vec![Lint::new(\n+        \"should_assert_eq2\",\n+        \"Not Deprecated\",\n+        \"abc\",\n+        None,\n+        \"module_name\",\n+    )];\n+    assert_eq!(expected, Lint::usable_lints(&lints));\n+}\n+\n+#[test]\n+fn test_by_lint_group() {\n+    let lints = vec![\n+        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n+    ];\n+    let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n+    expected.insert(\n+        \"group1\".to_string(),\n+        vec![\n+            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+            Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n+        ],\n+    );\n+    expected.insert(\n+        \"group2\".to_string(),\n+        vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")],\n+    );\n+    assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n+}\n+\n+#[test]\n+fn test_gen_changelog_lint_list() {\n+    let lints = vec![\n+        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n+    ];\n+    let expected = vec![\n+        format!(\"[`should_assert_eq`]: {}#should_assert_eq\", DOCS_LINK.to_string()),\n+        format!(\"[`should_assert_eq2`]: {}#should_assert_eq2\", DOCS_LINK.to_string()),\n+    ];\n+    assert_eq!(expected, gen_changelog_lint_list(lints.iter()));\n+}\n+\n+#[test]\n+fn test_gen_deprecated() {\n+    let lints = vec![\n+        Lint::new(\n+            \"should_assert_eq\",\n+            \"group1\",\n+            \"abc\",\n+            Some(\"has been superseded by should_assert_eq2\"),\n+            \"module_name\",\n+        ),\n+        Lint::new(\n+            \"another_deprecated\",\n+            \"group2\",\n+            \"abc\",\n+            Some(\"will be removed\"),\n+            \"module_name\",\n+        ),\n+    ];\n+\n+    let expected = GENERATED_FILE_COMMENT.to_string()\n+        + &[\n+            \"{\",\n+            \"    store.register_removed(\",\n+            \"        \\\"clippy::should_assert_eq\\\",\",\n+            \"        \\\"has been superseded by should_assert_eq2\\\",\",\n+            \"    );\",\n+            \"    store.register_removed(\",\n+            \"        \\\"clippy::another_deprecated\\\",\",\n+            \"        \\\"will be removed\\\",\",\n+            \"    );\",\n+            \"}\",\n+        ]\n+        .join(\"\\n\")\n+        + \"\\n\";\n+\n+    assert_eq!(expected, gen_deprecated(lints.iter()));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_gen_deprecated_fail() {\n+    let lints = vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")];\n+    let _deprecated_lints = gen_deprecated(lints.iter());\n+}\n+\n+#[test]\n+fn test_gen_modules_list() {\n+    let lints = vec![\n+        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"incorrect_stuff\", \"group3\", \"abc\", None, \"another_module\"),\n+    ];\n+    let expected = GENERATED_FILE_COMMENT.to_string() + &[\"mod another_module;\", \"mod module_name;\"].join(\"\\n\") + \"\\n\";\n+    assert_eq!(expected, gen_modules_list(lints.iter()));\n+}\n+\n+#[test]\n+fn test_gen_lint_group_list() {\n+    let lints = vec![\n+        Lint::new(\"abc\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"internal\", \"internal_style\", \"abc\", None, \"module_name\"),\n+    ];\n+    let expected = GENERATED_FILE_COMMENT.to_string()\n+        + &[\n+            \"store.register_group(true, \\\"clippy::group1\\\", Some(\\\"clippy_group1\\\"), vec![\",\n+            \"    LintId::of(module_name::ABC),\",\n+            \"    LintId::of(module_name::INTERNAL),\",\n+            \"    LintId::of(module_name::SHOULD_ASSERT_EQ),\",\n+            \"])\",\n+        ]\n+        .join(\"\\n\")\n+        + \"\\n\";\n+\n+    let result = gen_lint_group_list(\"group1\", lints.iter());\n+\n+    assert_eq!(expected, result);\n+}"}]}