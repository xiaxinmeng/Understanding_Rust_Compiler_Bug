{"sha": "5d23518a12548fdbbca74fcc3171fdc2f3888334", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMjM1MThhMTI1NDhmZGJiY2E3NGZjYzMxNzFmZGMyZjM4ODgzMzQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-28T08:03:00Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-28T08:03:00Z"}, "message": "const_prop: detect and avoid catching Miri errors that require allocation", "tree": {"sha": "f8c816d122a3b0495980440659b27e2029b95850", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8c816d122a3b0495980440659b27e2029b95850"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d23518a12548fdbbca74fcc3171fdc2f3888334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d23518a12548fdbbca74fcc3171fdc2f3888334", "html_url": "https://github.com/rust-lang/rust/commit/5d23518a12548fdbbca74fcc3171fdc2f3888334", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d23518a12548fdbbca74fcc3171fdc2f3888334/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04e69e4f4234beb4f12cc76dcc53e2cc4247a9be", "url": "https://api.github.com/repos/rust-lang/rust/commits/04e69e4f4234beb4f12cc76dcc53e2cc4247a9be", "html_url": "https://github.com/rust-lang/rust/commit/04e69e4f4234beb4f12cc76dcc53e2cc4247a9be"}], "stats": {"total": 52, "additions": 38, "deletions": 14}, "files": [{"sha": "fadd90c22570f902bcb237f30fbba5653b218f40", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d23518a12548fdbbca74fcc3171fdc2f3888334/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d23518a12548fdbbca74fcc3171fdc2f3888334/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=5d23518a12548fdbbca74fcc3171fdc2f3888334", "patch": "@@ -44,14 +44,14 @@ CloneTypeFoldableImpls! {\n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n     pub error: crate::mir::interpret::InterpError<'tcx>,\n     pub stacktrace: Vec<FrameInfo<'tcx>>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug)]\n pub struct FrameInfo<'tcx> {\n     /// This span is in the caller.\n     pub call_site: Span,\n@@ -327,7 +327,7 @@ impl<O: fmt::Debug> fmt::Debug for PanicInfo<O> {\n /// Error information for when the program we executed turned out not to actually be a valid\n /// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n /// where we work on generic code or execution does not have all information available.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum InvalidProgramInfo<'tcx> {\n     /// Resolution can fail if we are in a too generic context.\n     TooGeneric,\n@@ -357,7 +357,7 @@ impl fmt::Debug for InvalidProgramInfo<'tcx> {\n }\n \n /// Error information for when the program caused Undefined Behavior.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum UndefinedBehaviorInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Ub(String),\n@@ -390,11 +390,15 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n ///\n /// Currently, we also use this as fall-back error kind for errors that have not been\n /// categorized yet.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum UnsupportedOpInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n+    /// When const-prop encounters a situation it does not support, it raises this error.\n+    /// This must not allocate for performance reasons.\n+    ConstPropUnsupported(&'tcx str),\n+\n     // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n@@ -555,13 +559,15 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                     not a power of two\"),\n             Unsupported(ref msg) =>\n                 write!(f, \"{}\", msg),\n+            ConstPropUnsupported(ref msg) =>\n+                write!(f, \"Constant propagation encountered an unsupported situation: {}\", msg),\n         }\n     }\n }\n \n /// Error information for when the program exhausted the resources granted to it\n /// by the interpreter.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big.\n     StackFrameLimitReached,\n@@ -582,7 +588,7 @@ impl fmt::Debug for ResourceExhaustionInfo {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum InterpError<'tcx> {\n     /// The program panicked.\n     Panic(PanicInfo<u64>),"}, {"sha": "c02d07b80faaa11e77092615201c26634dc7ba5b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5d23518a12548fdbbca74fcc3171fdc2f3888334/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d23518a12548fdbbca74fcc3171fdc2f3888334/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=5d23518a12548fdbbca74fcc3171fdc2f3888334", "patch": "@@ -168,14 +168,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>\n     ) -> InterpResult<'tcx> {\n-        throw_unsup_format!(\"calling intrinsics isn't supported in ConstProp\");\n+        throw_unsup!(ConstPropUnsupported(\"calling intrinsics isn't supported in ConstProp\"));\n     }\n \n     fn ptr_to_int(\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer,\n     ) -> InterpResult<'tcx, u64> {\n-        throw_unsup_format!(\"ptr-to-int casts aren't supported in ConstProp\");\n+        throw_unsup!(ConstPropUnsupported(\"ptr-to-int casts aren't supported in ConstProp\"));\n     }\n \n     fn binary_ptr_op(\n@@ -185,7 +185,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _right: ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         // We can't do this because aliasing of memory can differ between const eval and llvm\n-        throw_unsup_format!(\"pointer arithmetic or comparisons aren't supported in ConstProp\");\n+        throw_unsup!(ConstPropUnsupported(\"pointer arithmetic or comparisons aren't supported \\\n+            in ConstProp\"));\n     }\n \n     fn find_foreign_static(\n@@ -218,7 +219,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        throw_unsup_format!(\"can't const prop `box` keyword\");\n+        throw_unsup!(ConstPropUnsupported(\"can't const prop `box` keyword\"));\n     }\n \n     fn access_local(\n@@ -229,7 +230,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         let l = &frame.locals[local];\n \n         if l.value == LocalValue::Uninitialized {\n-            throw_unsup_format!(\"tried to access an uninitialized local\");\n+            throw_unsup!(ConstPropUnsupported(\"tried to access an uninitialized local\"));\n         }\n \n         l.access()\n@@ -241,7 +242,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n         // the memory behind that in the future), then we can't const prop it\n         if allocation.mutability == Mutability::Mutable || allocation.relocations().len() > 0 {\n-            throw_unsup_format!(\"can't eval mutable statics in ConstProp\");\n+            throw_unsup!(ConstPropUnsupported(\"can't eval mutable statics in ConstProp\"));\n         }\n \n         Ok(())\n@@ -389,9 +390,26 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n-                use rustc::mir::interpret::InterpError::*;\n+                use rustc::mir::interpret::{\n+                    UnsupportedOpInfo,\n+                    UndefinedBehaviorInfo,\n+                    InterpError::*\n+                };\n                 match error.kind {\n                     Exit(_) => bug!(\"the CTFE program cannot exit\"),\n+\n+                    // Some error shouldn't come up because creating them causes\n+                    // an allocation, which we should avoid. When that happens,\n+                    // dedicated error variants should be introduced instead.\n+                    // Only test this in debug builds though to avoid disruptions.\n+                    Unsupported(UnsupportedOpInfo::Unsupported(_))\n+                    | Unsupported(UnsupportedOpInfo::ValidationFailure(_))\n+                    | UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n+                    | UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_))\n+                      if cfg!(debug_assertions) => {\n+                        bug!(\"const-prop encountered allocating error: {:?}\", error.kind);\n+                    }\n+\n                     Unsupported(_)\n                     | UndefinedBehavior(_)\n                     | InvalidProgram(_)"}]}