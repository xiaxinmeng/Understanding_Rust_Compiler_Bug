{"sha": "466fc6815d23dc201e26aa3210f3476443805e80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NmZjNjgxNWQyM2RjMjAxZTI2YWEzMjEwZjM0NzY0NDM4MDVlODA=", "commit": {"author": {"name": "Isaac Whitfield", "email": "iw@whitfin.io", "date": "2018-05-10T01:00:18Z"}, "committer": {"name": "Isaac Whitfield", "email": "iw@whitfin.io", "date": "2018-05-18T16:37:13Z"}, "message": "Avoid generating attributes more than once for CrateMetadata", "tree": {"sha": "ba04719a0c6bea5949f253f8a88ad7fbf73a6552", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba04719a0c6bea5949f253f8a88ad7fbf73a6552"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/466fc6815d23dc201e26aa3210f3476443805e80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/466fc6815d23dc201e26aa3210f3476443805e80", "html_url": "https://github.com/rust-lang/rust/commit/466fc6815d23dc201e26aa3210f3476443805e80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/466fc6815d23dc201e26aa3210f3476443805e80/comments", "author": {"login": "whitfin", "id": 5376378, "node_id": "MDQ6VXNlcjUzNzYzNzg=", "avatar_url": "https://avatars.githubusercontent.com/u/5376378?v=4", "gravatar_id": "", "url": "https://api.github.com/users/whitfin", "html_url": "https://github.com/whitfin", "followers_url": "https://api.github.com/users/whitfin/followers", "following_url": "https://api.github.com/users/whitfin/following{/other_user}", "gists_url": "https://api.github.com/users/whitfin/gists{/gist_id}", "starred_url": "https://api.github.com/users/whitfin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/whitfin/subscriptions", "organizations_url": "https://api.github.com/users/whitfin/orgs", "repos_url": "https://api.github.com/users/whitfin/repos", "events_url": "https://api.github.com/users/whitfin/events{/privacy}", "received_events_url": "https://api.github.com/users/whitfin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "whitfin", "id": 5376378, "node_id": "MDQ6VXNlcjUzNzYzNzg=", "avatar_url": "https://avatars.githubusercontent.com/u/5376378?v=4", "gravatar_id": "", "url": "https://api.github.com/users/whitfin", "html_url": "https://github.com/whitfin", "followers_url": "https://api.github.com/users/whitfin/followers", "following_url": "https://api.github.com/users/whitfin/following{/other_user}", "gists_url": "https://api.github.com/users/whitfin/gists{/gist_id}", "starred_url": "https://api.github.com/users/whitfin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/whitfin/subscriptions", "organizations_url": "https://api.github.com/users/whitfin/orgs", "repos_url": "https://api.github.com/users/whitfin/repos", "events_url": "https://api.github.com/users/whitfin/events{/privacy}", "received_events_url": "https://api.github.com/users/whitfin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f418f1dd7889a5896df43ce1ef5be0eb57bf341c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f418f1dd7889a5896df43ce1ef5be0eb57bf341c", "html_url": "https://github.com/rust-lang/rust/commit/f418f1dd7889a5896df43ce1ef5be0eb57bf341c"}], "stats": {"total": 89, "additions": 49, "deletions": 40}, "files": [{"sha": "796048b58d1be7bd2b36b211d9bf40b022b4b4a7", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/466fc6815d23dc201e26aa3210f3476443805e80/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466fc6815d23dc201e26aa3210f3476443805e80/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=466fc6815d23dc201e26aa3210f3476443805e80", "patch": "@@ -214,7 +214,6 @@ impl<'a> CrateLoader<'a> {\n         let root = if root.is_some() { root } else { &crate_paths };\n \n         let Library { dylib, rlib, rmeta, metadata } = lib;\n-\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n@@ -229,7 +228,7 @@ impl<'a> CrateLoader<'a> {\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n \n-        let cmeta = cstore::CrateMetadata {\n+        let mut cmeta = cstore::CrateMetadata {\n             name,\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n@@ -249,8 +248,17 @@ impl<'a> CrateLoader<'a> {\n                 rlib,\n                 rmeta,\n             },\n+            compiler_builtins: None,\n+            needs_allocator: None,\n+            needs_panic_runtime: None,\n+            no_builtins: None,\n+            panic_runtime: None,\n+            profiler_runtime: None,\n+            sanitizer_runtime: None,\n         };\n \n+        cmeta.derive_attributes(self.sess);\n+\n         let cmeta = Lrc::new(cmeta);\n         self.cstore.set_crate_data(cnum, cmeta.clone());\n         (cnum, cmeta)\n@@ -641,15 +649,14 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n                                                           \"needs_panic_runtime\");\n \n-        let sess = self.sess;\n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime ||\n-                                  data.needs_panic_runtime(sess);\n-            if data.is_panic_runtime(sess) {\n+                                  data.needs_panic_runtime();\n+            if data.is_panic_runtime() {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.needs_panic_runtime(sess));\n+                                          &|data| data.needs_panic_runtime());\n                 runtime_found = runtime_found || *data.dep_kind.lock() == DepKind::Explicit;\n             }\n         });\n@@ -686,7 +693,7 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.is_panic_runtime(self.sess) {\n+        if !data.is_panic_runtime() {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n@@ -698,7 +705,7 @@ impl<'a> CrateLoader<'a> {\n \n         self.sess.injected_panic_runtime.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.needs_panic_runtime(self.sess));\n+                                  &|data| data.needs_panic_runtime());\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -793,7 +800,7 @@ impl<'a> CrateLoader<'a> {\n                                        PathKind::Crate, dep_kind);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.is_sanitizer_runtime(self.sess) {\n+                if !data.is_sanitizer_runtime() {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -816,7 +823,7 @@ impl<'a> CrateLoader<'a> {\n                                    PathKind::Crate, dep_kind);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n-            if !data.is_profiler_runtime(self.sess) {\n+            if !data.is_profiler_runtime() {\n                 self.sess.err(&format!(\"the crate `profiler_builtins` is not \\\n                                         a profiler runtime\"));\n             }\n@@ -833,7 +840,7 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n                                                       \"needs_allocator\");\n         self.cstore.iter_crate_data(|_, data| {\n-            needs_allocator = needs_allocator || data.needs_allocator(self.sess);\n+            needs_allocator = needs_allocator || data.needs_allocator();\n         });\n         if !needs_allocator {\n             self.sess.injected_allocator.set(None);"}, {"sha": "4650c64543f745e148d61f3621bc332134c04c08", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/466fc6815d23dc201e26aa3210f3476443805e80/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466fc6815d23dc201e26aa3210f3476443805e80/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=466fc6815d23dc201e26aa3210f3476443805e80", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n-use rustc::session::{Session, CrateDisambiguator};\n+use rustc::session::{CrateDisambiguator, Session};\n use rustc_target::spec::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, NodeMap};\n@@ -85,6 +85,15 @@ pub struct CrateMetadata {\n     pub source: CrateSource,\n \n     pub proc_macros: Option<Vec<(ast::Name, Lrc<SyntaxExtension>)>>,\n+\n+    // Booleans derived from attributes\n+    pub compiler_builtins: Option<bool>,\n+    pub needs_allocator: Option<bool>,\n+    pub needs_panic_runtime: Option<bool>,\n+    pub no_builtins: Option<bool>,\n+    pub panic_runtime: Option<bool>,\n+    pub profiler_runtime: Option<bool>,\n+    pub sanitizer_runtime: Option<bool>,\n }\n \n pub struct CStore {\n@@ -188,47 +197,40 @@ impl CrateMetadata {\n         self.root.disambiguator\n     }\n \n-    pub fn needs_allocator(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"needs_allocator\")\n+    pub fn needs_allocator(&self) -> bool {\n+        self.needs_allocator.unwrap_or(false)\n     }\n \n     pub fn has_global_allocator(&self) -> bool {\n-        self.root.has_global_allocator.clone()\n+        self.root.has_global_allocator\n     }\n \n     pub fn has_default_lib_allocator(&self) -> bool {\n-        self.root.has_default_lib_allocator.clone()\n+        self.root.has_default_lib_allocator\n     }\n \n-    pub fn is_panic_runtime(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"panic_runtime\")\n+    pub fn is_panic_runtime(&self) -> bool {\n+        self.panic_runtime.unwrap_or(false)\n     }\n \n-    pub fn needs_panic_runtime(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"needs_panic_runtime\")\n+    pub fn needs_panic_runtime(&self) -> bool {\n+        self.needs_panic_runtime.unwrap_or(false)\n     }\n \n-    pub fn is_compiler_builtins(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"compiler_builtins\")\n+    pub fn is_compiler_builtins(&self) -> bool {\n+        self.compiler_builtins.unwrap_or(false)\n     }\n \n-    pub fn is_sanitizer_runtime(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"sanitizer_runtime\")\n+    pub fn is_sanitizer_runtime(&self) -> bool {\n+        self.sanitizer_runtime.unwrap_or(false)\n     }\n \n-    pub fn is_profiler_runtime(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"profiler_runtime\")\n+    pub fn is_profiler_runtime(&self) -> bool {\n+        self.profiler_runtime.unwrap_or(false)\n     }\n \n-    pub fn is_no_builtins(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"no_builtins\")\n+    pub fn is_no_builtins(&self) -> bool {\n+        self.no_builtins.unwrap_or(false)\n     }\n \n     pub fn panic_strategy(&self) -> PanicStrategy {"}, {"sha": "6bb6b1a1747d5ccf69af661a4831ab58daf101db", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/466fc6815d23dc201e26aa3210f3476443805e80/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466fc6815d23dc201e26aa3210f3476443805e80/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=466fc6815d23dc201e26aa3210f3476443805e80", "patch": "@@ -170,17 +170,17 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n     dylib_dependency_formats => { Lrc::new(cdata.get_dylib_dependency_formats()) }\n-    is_panic_runtime => { cdata.is_panic_runtime(tcx.sess) }\n-    is_compiler_builtins => { cdata.is_compiler_builtins(tcx.sess) }\n+    is_panic_runtime => { cdata.is_panic_runtime() }\n+    is_compiler_builtins => { cdata.is_compiler_builtins() }\n     has_global_allocator => { cdata.has_global_allocator() }\n-    is_sanitizer_runtime => { cdata.is_sanitizer_runtime(tcx.sess) }\n-    is_profiler_runtime => { cdata.is_profiler_runtime(tcx.sess) }\n+    is_sanitizer_runtime => { cdata.is_sanitizer_runtime() }\n+    is_profiler_runtime => { cdata.is_profiler_runtime() }\n     panic_strategy => { cdata.panic_strategy() }\n     extern_crate => {\n         let r = Lrc::new(*cdata.extern_crate.lock());\n         r\n     }\n-    is_no_builtins => { cdata.is_no_builtins(tcx.sess) }\n+    is_no_builtins => { cdata.is_no_builtins() }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n     reachable_non_generics => {\n         let reachable_non_generics = tcx"}]}