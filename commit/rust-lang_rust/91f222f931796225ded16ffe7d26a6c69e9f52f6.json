{"sha": "91f222f931796225ded16ffe7d26a6c69e9f52f6", "node_id": "C_kwDOAAsO6NoAKDkxZjIyMmY5MzE3OTYyMjVkZWQxNmZmZTdkMjZhNmM2OWU5ZjUyZjY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-06-03T18:38:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-03T18:38:10Z"}, "message": "Rollup merge of #111659 - y21:suggest-as-deref, r=cjgillot\n\nsuggest `Option::as_deref(_mut)` on type mismatch in option combinator if it passes typeck\n\nFixes #106342.\nThis adds a suggestion to call `.as_deref()` (or `.as_deref_mut()` resp.) if typeck fails due to a type mismatch in the function passed to an `Option` combinator such as `.map()` or `.and_then()`.\nFor example:\n```rs\nfn foo(_: &str) {}\nSome(String::new()).map(foo);\n```\nThe `.map()` method requires its argument to satisfy `F: FnOnce(String)`, but it received `fn(&str)`, which won't pass. However, placing a `.as_deref()` before the `.map()` call fixes this since `&str == &<String as Deref>::Target`", "tree": {"sha": "a63f2701c4b05475aea06659323fc4665d9cb53a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a63f2701c4b05475aea06659323fc4665d9cb53a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91f222f931796225ded16ffe7d26a6c69e9f52f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJke4iSCRBK7hj4Ov3rIwAACosIABuACUvPxhG/jn6vv9Elp1ef\nyzDwNEDwRYHBEI2SB1C6k3pfNqNt4WbWUGT9e4jOGaScj0sDXiYLEaNDpq2zO4cb\ntVd5VFoz8ZSyXNJau3Q85RkuCt6AmjG0J2MgWG/BO2KJ+IKy40K1rzgDui/6BJbW\nCyP7ejHtRPJpoUtOI9si9SrMlfzwefAaSdjgP2Vm6P4mNJV7utK3w+hzvIWU6lol\npAc9q5gVSlOeG1Q10SnQ64n5khF6xiXafjQiVUzOANgDETEX8LxURDs3FTXdQAIc\nkTHMk/aQFBqBFb2SJdA6URrm6raMf0zLyCuxlAbSMmLVUl3lodYlGXpOL3cK178=\n=JlIg\n-----END PGP SIGNATURE-----\n", "payload": "tree a63f2701c4b05475aea06659323fc4665d9cb53a\nparent 2f5e6bb817c115c067ff47453eb9aa89a0a31358\nparent 268b08b01bfd95d315c03a9e3a69f254176b2a35\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1685817490 +0200\ncommitter GitHub <noreply@github.com> 1685817490 +0200\n\nRollup merge of #111659 - y21:suggest-as-deref, r=cjgillot\n\nsuggest `Option::as_deref(_mut)` on type mismatch in option combinator if it passes typeck\n\nFixes #106342.\nThis adds a suggestion to call `.as_deref()` (or `.as_deref_mut()` resp.) if typeck fails due to a type mismatch in the function passed to an `Option` combinator such as `.map()` or `.and_then()`.\nFor example:\n```rs\nfn foo(_: &str) {}\nSome(String::new()).map(foo);\n```\nThe `.map()` method requires its argument to satisfy `F: FnOnce(String)`, but it received `fn(&str)`, which won't pass. However, placing a `.as_deref()` before the `.map()` call fixes this since `&str == &<String as Deref>::Target`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91f222f931796225ded16ffe7d26a6c69e9f52f6", "html_url": "https://github.com/rust-lang/rust/commit/91f222f931796225ded16ffe7d26a6c69e9f52f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91f222f931796225ded16ffe7d26a6c69e9f52f6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f5e6bb817c115c067ff47453eb9aa89a0a31358", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f5e6bb817c115c067ff47453eb9aa89a0a31358", "html_url": "https://github.com/rust-lang/rust/commit/2f5e6bb817c115c067ff47453eb9aa89a0a31358"}, {"sha": "268b08b01bfd95d315c03a9e3a69f254176b2a35", "url": "https://api.github.com/repos/rust-lang/rust/commits/268b08b01bfd95d315c03a9e3a69f254176b2a35", "html_url": "https://github.com/rust-lang/rust/commit/268b08b01bfd95d315c03a9e3a69f254176b2a35"}], "stats": {"total": 363, "additions": 354, "deletions": 9}, "files": [{"sha": "42038dbc3d82ee7ca194950d0fb6fffe6acbcbca", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 95, "deletions": 9, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/91f222f931796225ded16ffe7d26a6c69e9f52f6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f222f931796225ded16ffe7d26a6c69e9f52f6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=91f222f931796225ded16ffe7d26a6c69e9f52f6", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n     error_code, pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed, MultiSpan, Style,\n+    ErrorGuaranteed, MultiSpan, Style, SuggestionStyle,\n };\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -362,6 +362,15 @@ pub trait TypeErrCtxtExt<'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n+\n+    fn suggest_option_method_if_applicable(\n+        &self,\n+        failed_pred: ty::Predicate<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+    );\n+\n     fn note_function_argument_obligation(\n         &self,\n         body_id: LocalDefId,\n@@ -3521,15 +3530,92 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 err.replace_span_with(path.ident.span, true);\n             }\n         }\n-        if let Some(Node::Expr(hir::Expr {\n-            kind:\n-                hir::ExprKind::Call(hir::Expr { span, .. }, _)\n-                | hir::ExprKind::MethodCall(hir::PathSegment { ident: Ident { span, .. }, .. }, ..),\n-            ..\n-        })) = hir.find(call_hir_id)\n+\n+        if let Some(Node::Expr(expr)) = hir.find(call_hir_id) {\n+            if let hir::ExprKind::Call(hir::Expr { span, .. }, _)\n+            | hir::ExprKind::MethodCall(\n+                hir::PathSegment { ident: Ident { span, .. }, .. },\n+                ..,\n+            ) = expr.kind\n+            {\n+                if Some(*span) != err.span.primary_span() {\n+                    err.span_label(*span, \"required by a bound introduced by this call\");\n+                }\n+            }\n+\n+            if let hir::ExprKind::MethodCall(_, expr, ..) = expr.kind {\n+                self.suggest_option_method_if_applicable(failed_pred, param_env, err, expr);\n+            }\n+        }\n+    }\n+\n+    fn suggest_option_method_if_applicable(\n+        &self,\n+        failed_pred: ty::Predicate<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+    ) {\n+        let tcx = self.tcx;\n+        let infcx = self.infcx;\n+        let Some(typeck_results) = self.typeck_results.as_ref() else { return };\n+\n+        // Make sure we're dealing with the `Option` type.\n+        let Some(option_ty_adt) = typeck_results.expr_ty_adjusted(expr).ty_adt_def() else { return };\n+        if !tcx.is_diagnostic_item(sym::Option, option_ty_adt.did()) {\n+            return;\n+        }\n+\n+        // Given the predicate `fn(&T): FnOnce<(U,)>`, extract `fn(&T)` and `(U,)`,\n+        // then suggest `Option::as_deref(_mut)` if `U` can deref to `T`\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate { trait_ref, .. }))\n+            = failed_pred.kind().skip_binder()\n+            && tcx.is_fn_trait(trait_ref.def_id)\n+            && let [self_ty, found_ty] = trait_ref.substs.as_slice()\n+            && let Some(fn_ty) = self_ty.as_type().filter(|ty| ty.is_fn())\n+            && let fn_sig @ ty::FnSig {\n+                abi: abi::Abi::Rust,\n+                c_variadic: false,\n+                unsafety: hir::Unsafety::Normal,\n+                ..\n+            } = fn_ty.fn_sig(tcx).skip_binder()\n+\n+            // Extract first param of fn sig with peeled refs, e.g. `fn(&T)` -> `T`\n+            && let Some(&ty::Ref(_, target_ty, needs_mut)) = fn_sig.inputs().first().map(|t| t.kind())\n+            && !target_ty.has_escaping_bound_vars()\n+\n+            // Extract first tuple element out of fn trait, e.g. `FnOnce<(U,)>` -> `U`\n+            && let Some(ty::Tuple(tys)) = found_ty.as_type().map(Ty::kind)\n+            && let &[found_ty] = tys.as_slice()\n+            && !found_ty.has_escaping_bound_vars()\n+\n+            // Extract `<U as Deref>::Target` assoc type and check that it is `T`\n+            && let Some(deref_target_did) = tcx.lang_items().deref_target()\n+            && let projection = tcx.mk_projection(deref_target_did, tcx.mk_substs(&[ty::GenericArg::from(found_ty)]))\n+            && let Ok(deref_target) = tcx.try_normalize_erasing_regions(param_env, projection)\n+            && deref_target == target_ty\n         {\n-            if Some(*span) != err.span.primary_span() {\n-                err.span_label(*span, \"required by a bound introduced by this call\");\n+            let help = if let hir::Mutability::Mut = needs_mut\n+                && let Some(deref_mut_did) = tcx.lang_items().deref_mut_trait()\n+                && infcx\n+                    .type_implements_trait(deref_mut_did, iter::once(found_ty), param_env)\n+                    .must_apply_modulo_regions()\n+            {\n+                Some((\"call `Option::as_deref_mut()` first\", \".as_deref_mut()\"))\n+            } else if let hir::Mutability::Not = needs_mut {\n+                Some((\"call `Option::as_deref()` first\", \".as_deref()\"))\n+            } else {\n+                None\n+            };\n+\n+            if let Some((msg, sugg)) = help {\n+                err.span_suggestion_with_style(\n+                    expr.span.shrink_to_hi(),\n+                    msg,\n+                    sugg,\n+                    Applicability::MaybeIncorrect,\n+                    SuggestionStyle::ShowAlways\n+                );\n             }\n         }\n     }"}, {"sha": "cc9ba5514fef129c1b75f24850d74131049d5080", "filename": "tests/ui/mismatched_types/suggest-option-asderef-unfixable.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.rs?ref=91f222f931796225ded16ffe7d26a6c69e9f52f6", "patch": "@@ -0,0 +1,40 @@\n+fn produces_string() -> Option<String> {\n+    Some(\"my cool string\".to_owned())\n+}\n+\n+fn takes_str_but_too_many_refs(_: &&str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn no_args() -> Option<()> {\n+    Some(())\n+}\n+\n+fn generic_ref<T>(_: &T) -> Option<()> {\n+    Some(())\n+}\n+\n+extern \"C\" fn takes_str_but_wrong_abi(_: &str) -> Option<()> {\n+    Some(())\n+}\n+\n+unsafe fn takes_str_but_unsafe(_: &str) -> Option<()> {\n+    Some(())\n+}\n+\n+struct TypeWithoutDeref;\n+\n+fn main() {\n+    let _ = produces_string().and_then(takes_str_but_too_many_refs);\n+    //~^ ERROR type mismatch in function arguments\n+    let _ = produces_string().and_then(takes_str_but_wrong_abi);\n+    //~^ ERROR expected a `FnOnce<(String,)>` closure, found `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n+    let _ = produces_string().and_then(takes_str_but_unsafe);\n+    //~^ ERROR expected a `FnOnce<(String,)>` closure, found `for<'a> unsafe fn(&'a str) -> Option<()> {takes_str_but_unsafe}`\n+    let _ = produces_string().and_then(no_args);\n+    //~^ ERROR function is expected to take 1 argument, but it takes 0 arguments\n+    let _ = produces_string().and_then(generic_ref);\n+    //~^ ERROR type mismatch in function arguments\n+    let _ = Some(TypeWithoutDeref).and_then(takes_str_but_too_many_refs);\n+    //~^ ERROR type mismatch in function arguments\n+}"}, {"sha": "079909eb48d1d188a1d20623885076793628ddca", "filename": "tests/ui/mismatched_types/suggest-option-asderef-unfixable.stderr", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.stderr?ref=91f222f931796225ded16ffe7d26a6c69e9f52f6", "patch": "@@ -0,0 +1,96 @@\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef-unfixable.rs:28:40\n+   |\n+LL | fn takes_str_but_too_many_refs(_: &&str) -> Option<()> {\n+   | ------------------------------------------------------ found signature defined here\n+...\n+LL |     let _ = produces_string().and_then(takes_str_but_too_many_refs);\n+   |                               -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected due to this\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a, 'b> fn(&'a &'b str) -> _`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error[E0277]: expected a `FnOnce<(String,)>` closure, found `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n+  --> $DIR/suggest-option-asderef-unfixable.rs:30:40\n+   |\n+LL |     let _ = produces_string().and_then(takes_str_but_wrong_abi);\n+   |                               -------- ^^^^^^^^^^^^^^^^^^^^^^^ expected an `FnOnce<(String,)>` closure, found `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+   = help: the trait `FnOnce<(String,)>` is not implemented for fn item `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error[E0277]: expected a `FnOnce<(String,)>` closure, found `for<'a> unsafe fn(&'a str) -> Option<()> {takes_str_but_unsafe}`\n+  --> $DIR/suggest-option-asderef-unfixable.rs:32:40\n+   |\n+LL |     let _ = produces_string().and_then(takes_str_but_unsafe);\n+   |                               -------- ^^^^^^^^^^^^^^^^^^^^ call the function in a closure: `|| unsafe { /* code */ }`\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+   = help: the trait `FnOnce<(String,)>` is not implemented for fn item `for<'a> unsafe fn(&'a str) -> Option<()> {takes_str_but_unsafe}`\n+   = note: unsafe function cannot be called generically without an unsafe block\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error[E0593]: function is expected to take 1 argument, but it takes 0 arguments\n+  --> $DIR/suggest-option-asderef-unfixable.rs:34:40\n+   |\n+LL | fn no_args() -> Option<()> {\n+   | -------------------------- takes 0 arguments\n+...\n+LL |     let _ = produces_string().and_then(no_args);\n+   |                               -------- ^^^^^^^ expected function that takes 1 argument\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef-unfixable.rs:36:40\n+   |\n+LL | fn generic_ref<T>(_: &T) -> Option<()> {\n+   | -------------------------------------- found signature defined here\n+...\n+LL |     let _ = produces_string().and_then(generic_ref);\n+   |                               -------- ^^^^^^^^^^^ expected due to this\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a> fn(&'a _) -> _`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: do not borrow the argument\n+   |\n+LL - fn generic_ref<T>(_: &T) -> Option<()> {\n+LL + fn generic_ref<T>(_: T) -> Option<()> {\n+   |\n+\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef-unfixable.rs:38:45\n+   |\n+LL | fn takes_str_but_too_many_refs(_: &&str) -> Option<()> {\n+   | ------------------------------------------------------ found signature defined here\n+...\n+LL |     let _ = Some(TypeWithoutDeref).and_then(takes_str_but_too_many_refs);\n+   |                                    -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected due to this\n+   |                                    |\n+   |                                    required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(TypeWithoutDeref) -> _`\n+              found function signature `for<'a, 'b> fn(&'a &'b str) -> _`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0277, E0593, E0631.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "08805999341ffbbd1aa77e393458d779de4fe904", "filename": "tests/ui/mismatched_types/suggest-option-asderef.fixed", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.fixed?ref=91f222f931796225ded16ffe7d26a6c69e9f52f6", "patch": "@@ -0,0 +1,30 @@\n+// run-rustfix\n+\n+fn produces_string() -> Option<String> {\n+    Some(\"my cool string\".to_owned())\n+}\n+\n+fn takes_str(_: &str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn takes_str_mut(_: &mut str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn generic<T>(_: T) -> Option<()> {\n+    Some(())\n+}\n+\n+fn main() {\n+    let _: Option<()> = produces_string().as_deref().and_then(takes_str);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n+    let _: Option<Option<()>> = produces_string().as_deref().map(takes_str);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n+    let _: Option<Option<()>> = produces_string().as_deref_mut().map(takes_str_mut);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref_mut()` first\n+    let _ = produces_string().and_then(generic);\n+}"}, {"sha": "3cfb2ffa828c6687f4ab0cf5dd50e57299ebeeb1", "filename": "tests/ui/mismatched_types/suggest-option-asderef.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.rs?ref=91f222f931796225ded16ffe7d26a6c69e9f52f6", "patch": "@@ -0,0 +1,30 @@\n+// run-rustfix\n+\n+fn produces_string() -> Option<String> {\n+    Some(\"my cool string\".to_owned())\n+}\n+\n+fn takes_str(_: &str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn takes_str_mut(_: &mut str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn generic<T>(_: T) -> Option<()> {\n+    Some(())\n+}\n+\n+fn main() {\n+    let _: Option<()> = produces_string().and_then(takes_str);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n+    let _: Option<Option<()>> = produces_string().map(takes_str);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n+    let _: Option<Option<()>> = produces_string().map(takes_str_mut);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref_mut()` first\n+    let _ = produces_string().and_then(generic);\n+}"}, {"sha": "46da19d2bf4f2da1829561e9a74124c42253f9cc", "filename": "tests/ui/mismatched_types/suggest-option-asderef.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91f222f931796225ded16ffe7d26a6c69e9f52f6/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.stderr?ref=91f222f931796225ded16ffe7d26a6c69e9f52f6", "patch": "@@ -0,0 +1,63 @@\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef.rs:20:52\n+   |\n+LL | fn takes_str(_: &str) -> Option<()> {\n+   | ----------------------------------- found signature defined here\n+...\n+LL |     let _: Option<()> = produces_string().and_then(takes_str);\n+   |                                           -------- ^^^^^^^^^ expected due to this\n+   |                                           |\n+   |                                           required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a> fn(&'a str) -> _`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: call `Option::as_deref()` first\n+   |\n+LL |     let _: Option<()> = produces_string().as_deref().and_then(takes_str);\n+   |                                          +++++++++++\n+\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef.rs:23:55\n+   |\n+LL | fn takes_str(_: &str) -> Option<()> {\n+   | ----------------------------------- found signature defined here\n+...\n+LL |     let _: Option<Option<()>> = produces_string().map(takes_str);\n+   |                                                   --- ^^^^^^^^^ expected due to this\n+   |                                                   |\n+   |                                                   required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a> fn(&'a str) -> _`\n+note: required by a bound in `Option::<T>::map`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: call `Option::as_deref()` first\n+   |\n+LL |     let _: Option<Option<()>> = produces_string().as_deref().map(takes_str);\n+   |                                                  +++++++++++\n+\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef.rs:26:55\n+   |\n+LL | fn takes_str_mut(_: &mut str) -> Option<()> {\n+   | ------------------------------------------- found signature defined here\n+...\n+LL |     let _: Option<Option<()>> = produces_string().map(takes_str_mut);\n+   |                                                   --- ^^^^^^^^^^^^^ expected due to this\n+   |                                                   |\n+   |                                                   required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a> fn(&'a mut str) -> _`\n+note: required by a bound in `Option::<T>::map`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: call `Option::as_deref_mut()` first\n+   |\n+LL |     let _: Option<Option<()>> = produces_string().as_deref_mut().map(takes_str_mut);\n+   |                                                  +++++++++++++++\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0631`."}]}