{"sha": "b1dc2c50949dc747c6246e547294bdbd1e4e6488", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZGMyYzUwOTQ5ZGM3NDdjNjI0NmU1NDcyOTRiZGJkMWU0ZTY0ODg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-05T08:15:38Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-05T08:15:38Z"}, "message": "Rollup merge of #27519 - JanLikar:rearrange-patterns, r=steveklabnik\n\n  - Move \"Destructuring\" after \"Multiple patterns\", because some of\r\n    later sections include examples which make use of destructuring.\r\n\r\n  - Move \"Ignoring bindings\" after \"Destructoring\", because the former\r\n    features Result<T,E> destructuring. Some of examples in later\r\n    sections use \"_\" and \"..\", so \"Ignoring bindings\" must be\r\n    positioned before them.\r\n\r\n  - Fix #27347 by moving \"Ref and mut ref\" before \"Ranges\" and\r\n    \"Bindings\", because \"Bindings\" section includes a somewhat\r\n    difficult example, which also makes use of \"ref\" and \"mut ref\"\r\n    operators.", "tree": {"sha": "da8ba4c97590660cf8b7dd222beef41797713779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da8ba4c97590660cf8b7dd222beef41797713779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1dc2c50949dc747c6246e547294bdbd1e4e6488", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1dc2c50949dc747c6246e547294bdbd1e4e6488", "html_url": "https://github.com/rust-lang/rust/commit/b1dc2c50949dc747c6246e547294bdbd1e4e6488", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1dc2c50949dc747c6246e547294bdbd1e4e6488/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8228240ca88371150314d5474b6795c5410c7a8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8228240ca88371150314d5474b6795c5410c7a8e", "html_url": "https://github.com/rust-lang/rust/commit/8228240ca88371150314d5474b6795c5410c7a8e"}, {"sha": "c1f938d7b834852aede4f865a18ee2226668a8e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1f938d7b834852aede4f865a18ee2226668a8e6", "html_url": "https://github.com/rust-lang/rust/commit/c1f938d7b834852aede4f865a18ee2226668a8e6"}], "stats": {"total": 244, "additions": 122, "deletions": 122}, "files": [{"sha": "26574f15c2c62542475730ea746f5df62b1caf09", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 122, "deletions": 122, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/b1dc2c50949dc747c6246e547294bdbd1e4e6488/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1dc2c50949dc747c6246e547294bdbd1e4e6488/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=b1dc2c50949dc747c6246e547294bdbd1e4e6488", "patch": "@@ -39,79 +39,81 @@ match x {\n \n This prints `one or two`.\n \n-# Ranges\n+# Destructuring\n \n-You can match a range of values with `...`:\n+If you have a compound data type, like a [`struct`][struct], you can destructure it\n+inside of a pattern:\n \n ```rust\n-let x = 1;\n-\n-match x {\n-    1 ... 5 => println!(\"one through five\"),\n-    _ => println!(\"anything\"),\n+struct Point {\n+    x: i32,\n+    y: i32,\n }\n-```\n-\n-This prints `one through five`.\n \n-Ranges are mostly used with integers and `char`s:\n-\n-```rust\n-let x = '\ud83d\udc85';\n+let origin = Point { x: 0, y: 0 };\n \n-match x {\n-    'a' ... 'j' => println!(\"early letter\"),\n-    'k' ... 'z' => println!(\"late letter\"),\n-    _ => println!(\"something else\"),\n+match origin {\n+    Point { x, y } => println!(\"({},{})\", x, y),\n }\n ```\n \n-This prints `something else`.\n-\n-# Bindings\n+[struct]: structs.html\n \n-You can bind values to names with `@`:\n+We can use `:` to give a value a different name.\n \n ```rust\n-let x = 1;\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n \n-match x {\n-    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n-    _ => println!(\"anything\"),\n+let origin = Point { x: 0, y: 0 };\n+\n+match origin {\n+    Point { x: x1, y: y1 } => println!(\"({},{})\", x1, y1),\n }\n ```\n \n-This prints `got a range element 1`. This is useful when you want to\n-do a complicated match of part of a data structure:\n+If we only care about some of the values, we don\u2019t have to give them all names:\n \n ```rust\n-#[derive(Debug)]\n-struct Person {\n-    name: Option<String>,\n+struct Point {\n+    x: i32,\n+    y: i32,\n }\n \n-let name = \"Steve\".to_string();\n-let mut x: Option<Person> = Some(Person { name: Some(name) });\n-match x {\n-    Some(Person { name: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n-    _ => {}\n+let origin = Point { x: 0, y: 0 };\n+\n+match origin {\n+    Point { x, .. } => println!(\"x is {}\", x),\n }\n ```\n \n-This prints `Some(\"Steve\")`: We\u2019ve bound the inner `name` to `a`.\n+This prints `x is 0`.\n \n-If you use `@` with `|`, you need to make sure the name is bound in each part\n-of the pattern:\n+You can do this kind of match on any member, not just the first:\n \n ```rust\n-let x = 5;\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n \n-match x {\n-    e @ 1 ... 5 | e @ 8 ... 10 => println!(\"got a range element {}\", e),\n-    _ => println!(\"anything\"),\n+let origin = Point { x: 0, y: 0 };\n+\n+match origin {\n+    Point { y, .. } => println!(\"y is {}\", y),\n }\n ```\n \n+This prints `y is 0`.\n+\n+This \u2018destructuring\u2019 behavior works on any compound data type, like\n+[tuples][tuples] or [enums][enums].\n+\n+[tuples]: primitive-types.html#tuples\n+[enums]: enums.html\n+\n # Ignoring bindings\n \n You can use `_` in a pattern to disregard the type and value.\n@@ -162,154 +164,152 @@ match x {\n \n This prints `Got a tuple!`.\n \n-# Guards\n+# ref and ref mut\n \n-You can introduce \u2018match guards\u2019 with `if`:\n+If you want to get a [reference][ref], use the `ref` keyword:\n \n ```rust\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-\n-let x = OptionalInt::Value(5);\n+let x = 5;\n \n match x {\n-    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n-    OptionalInt::Value(..) => println!(\"Got an int!\"),\n-    OptionalInt::Missing => println!(\"No such luck.\"),\n+    ref r => println!(\"Got a reference to {}\", r),\n }\n ```\n \n-This prints `Got an int!`.\n+This prints `Got a reference to 5`.\n \n-If you\u2019re using `if` with multiple patterns, the `if` applies to both sides:\n+[ref]: references-and-borrowing.html\n+\n+Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n+keyword _creates_ a reference, for use in the pattern. If you need a mutable\n+reference, `ref mut` will work in the same way:\n \n ```rust\n-let x = 4;\n-let y = false;\n+let mut x = 5;\n \n match x {\n-    4 | 5 if y => println!(\"yes\"),\n-    _ => println!(\"no\"),\n+    ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n }\n ```\n \n-This prints `no`, because the `if` applies to the whole of `4 | 5`, and not to\n-just the `5`, In other words, the the precedence of `if` behaves like this:\n+# Ranges\n \n-```text\n-(4 | 5) if y => ...\n-```\n+You can match a range of values with `...`:\n \n-not this:\n+```rust\n+let x = 1;\n \n-```text\n-4 | (5 if y) => ...\n+match x {\n+    1 ... 5 => println!(\"one through five\"),\n+    _ => println!(\"anything\"),\n+}\n ```\n \n-# ref and ref mut\n+This prints `one through five`.\n \n-If you want to get a [reference][ref], use the `ref` keyword:\n+Ranges are mostly used with integers and `char`s:\n \n ```rust\n-let x = 5;\n+let x = '\ud83d\udc85';\n \n match x {\n-    ref r => println!(\"Got a reference to {}\", r),\n+    'a' ... 'j' => println!(\"early letter\"),\n+    'k' ... 'z' => println!(\"late letter\"),\n+    _ => println!(\"something else\"),\n }\n ```\n \n-This prints `Got a reference to 5`.\n+This prints `something else`.\n \n-[ref]: references-and-borrowing.html\n+# Bindings\n \n-Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n-keyword _creates_ a reference, for use in the pattern. If you need a mutable\n-reference, `ref mut` will work in the same way:\n+You can bind values to names with `@`:\n \n ```rust\n-let mut x = 5;\n+let x = 1;\n \n match x {\n-    ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n+    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n }\n ```\n \n-# Destructuring\n-\n-If you have a compound data type, like a [`struct`][struct], you can destructure it\n-inside of a pattern:\n+This prints `got a range element 1`. This is useful when you want to\n+do a complicated match of part of a data structure:\n \n ```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n+#[derive(Debug)]\n+struct Person {\n+    name: Option<String>,\n }\n \n-let origin = Point { x: 0, y: 0 };\n-\n-match origin {\n-    Point { x, y } => println!(\"({},{})\", x, y),\n+let name = \"Steve\".to_string();\n+let mut x: Option<Person> = Some(Person { name: Some(name) });\n+match x {\n+    Some(Person { name: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n+    _ => {}\n }\n ```\n \n-[struct]: structs.html\n+This prints `Some(\"Steve\")`: We\u2019ve bound the inner `name` to `a`.\n \n-We can use `:` to give a value a different name.\n+If you use `@` with `|`, you need to make sure the name is bound in each part\n+of the pattern:\n \n ```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-let origin = Point { x: 0, y: 0 };\n+let x = 5;\n \n-match origin {\n-    Point { x: x1, y: y1 } => println!(\"({},{})\", x1, y1),\n+match x {\n+    e @ 1 ... 5 | e @ 8 ... 10 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n }\n ```\n \n-If we only care about some of the values, we don\u2019t have to give them all names:\n+# Guards\n+\n+You can introduce \u2018match guards\u2019 with `if`:\n \n ```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n+enum OptionalInt {\n+    Value(i32),\n+    Missing,\n }\n \n-let origin = Point { x: 0, y: 0 };\n+let x = OptionalInt::Value(5);\n \n-match origin {\n-    Point { x, .. } => println!(\"x is {}\", x),\n+match x {\n+    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n+    OptionalInt::Value(..) => println!(\"Got an int!\"),\n+    OptionalInt::Missing => println!(\"No such luck.\"),\n }\n ```\n \n-This prints `x is 0`.\n+This prints `Got an int!`.\n \n-You can do this kind of match on any member, not just the first:\n+If you\u2019re using `if` with multiple patterns, the `if` applies to both sides:\n \n ```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-let origin = Point { x: 0, y: 0 };\n+let x = 4;\n+let y = false;\n \n-match origin {\n-    Point { y, .. } => println!(\"y is {}\", y),\n+match x {\n+    4 | 5 if y => println!(\"yes\"),\n+    _ => println!(\"no\"),\n }\n ```\n \n-This prints `y is 0`.\n+This prints `no`, because the `if` applies to the whole of `4 | 5`, and not to\n+just the `5`, In other words, the the precedence of `if` behaves like this:\n \n-This \u2018destructuring\u2019 behavior works on any compound data type, like\n-[tuples][tuples] or [enums][enums].\n+```text\n+(4 | 5) if y => ...\n+```\n \n-[tuples]: primitive-types.html#tuples\n-[enums]: enums.html\n+not this:\n+\n+```text\n+4 | (5 if y) => ...\n+```\n \n # Mix and Match\n "}]}