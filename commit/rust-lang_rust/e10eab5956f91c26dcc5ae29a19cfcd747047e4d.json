{"sha": "e10eab5956f91c26dcc5ae29a19cfcd747047e4d", "node_id": "C_kwDOAAsO6NoAKGUxMGVhYjU5NTZmOTFjMjZkY2M1YWUyOWExOWNmY2Q3NDcwNDdlNGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-25T09:22:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-25T09:22:15Z"}, "message": "Auto merge of #109371 - Zoxc:verify-hash-opt, r=cjgillot\n\nOptimize `incremental_verify_ich`\n\nThis optimizes `incremental_verify_ich` by operating on `SerializedDepNodeIndex`, saving 2 hashmap lookups. The panic paths are also changed to get a `TyCtxt` reference using TLS.", "tree": {"sha": "c552182517dcb1975944e510e1dba5ba5c17455b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c552182517dcb1975944e510e1dba5ba5c17455b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e10eab5956f91c26dcc5ae29a19cfcd747047e4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e10eab5956f91c26dcc5ae29a19cfcd747047e4d", "html_url": "https://github.com/rust-lang/rust/commit/e10eab5956f91c26dcc5ae29a19cfcd747047e4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e10eab5956f91c26dcc5ae29a19cfcd747047e4d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fa6b3c15758e85657d5be051cfa57022a8bbe57", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa6b3c15758e85657d5be051cfa57022a8bbe57", "html_url": "https://github.com/rust-lang/rust/commit/9fa6b3c15758e85657d5be051cfa57022a8bbe57"}, {"sha": "820e3a8d6aec53d8f5f451e43cd1ef87bd29dc0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/820e3a8d6aec53d8f5f451e43cd1ef87bd29dc0a", "html_url": "https://github.com/rust-lang/rust/commit/820e3a8d6aec53d8f5f451e43cd1ef87bd29dc0a"}], "stats": {"total": 143, "additions": 62, "deletions": 81}, "files": [{"sha": "80618fd1abed2b986f8fe3b28e24fa28109909ee", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e10eab5956f91c26dcc5ae29a19cfcd747047e4d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10eab5956f91c26dcc5ae29a19cfcd747047e4d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=e10eab5956f91c26dcc5ae29a19cfcd747047e4d", "patch": "@@ -535,16 +535,22 @@ impl<K: DepKind> DepGraph<K> {\n             // value to an existing node.\n             //\n             // For sanity, we still check that the loaded stable hash and the new one match.\n-            if let Some(dep_node_index) = data.dep_node_index_of_opt(&node) {\n-                let _current_fingerprint =\n-                    crate::query::incremental_verify_ich(cx, data, result, &node, hash_result);\n+            if let Some(prev_index) = data.previous.node_to_index_opt(&node) {\n+                let dep_node_index = data.current.prev_index_to_index.lock()[prev_index];\n+                if let Some(dep_node_index) = dep_node_index {\n+                    crate::query::incremental_verify_ich(cx, data, result, prev_index, hash_result);\n \n-                #[cfg(debug_assertions)]\n-                if hash_result.is_some() {\n-                    data.current.record_edge(dep_node_index, node, _current_fingerprint);\n-                }\n+                    #[cfg(debug_assertions)]\n+                    if hash_result.is_some() {\n+                        data.current.record_edge(\n+                            dep_node_index,\n+                            node,\n+                            data.prev_fingerprint_of(prev_index),\n+                        );\n+                    }\n \n-                return dep_node_index;\n+                    return dep_node_index;\n+                }\n             }\n \n             let mut edges = SmallVec::new();\n@@ -626,13 +632,19 @@ impl<K: DepKind> DepGraphData<K> {\n \n     /// Returns true if the given node has been marked as green during the\n     /// current compilation session. Used in various assertions\n-    pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n-        self.node_color(dep_node).map_or(false, |c| c.is_green())\n+    #[inline]\n+    pub fn is_index_green(&self, prev_index: SerializedDepNodeIndex) -> bool {\n+        self.colors.get(prev_index).map_or(false, |c| c.is_green())\n+    }\n+\n+    #[inline]\n+    pub fn prev_fingerprint_of(&self, prev_index: SerializedDepNodeIndex) -> Fingerprint {\n+        self.previous.fingerprint_by_index(prev_index)\n     }\n \n     #[inline]\n-    pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n-        self.previous.fingerprint_of(dep_node)\n+    pub fn prev_node_of(&self, prev_index: SerializedDepNodeIndex) -> DepNode<K> {\n+        self.previous.index_to_node(prev_index)\n     }\n \n     pub fn mark_debug_loaded_from_disk(&self, dep_node: DepNode<K>) {\n@@ -643,7 +655,7 @@ impl<K: DepKind> DepGraphData<K> {\n impl<K: DepKind> DepGraph<K> {\n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n-        self.data.as_ref().and_then(|data| data.dep_node_index_of_opt(dep_node)).is_some()\n+        self.data.as_ref().map_or(false, |data| data.dep_node_exists(dep_node))\n     }\n \n     /// Checks whether a previous work product exists for `v` and, if"}, {"sha": "3d19a84915aec05eb43d1ca5e886e6e418dd0dfe", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e10eab5956f91c26dcc5ae29a19cfcd747047e4d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10eab5956f91c26dcc5ae29a19cfcd747047e4d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=e10eab5956f91c26dcc5ae29a19cfcd747047e4d", "patch": "@@ -79,11 +79,6 @@ impl<K: DepKind> SerializedDepGraph<K> {\n         self.index.get(dep_node).cloned()\n     }\n \n-    #[inline]\n-    pub fn fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n-        self.index.get(dep_node).map(|&node_index| self.fingerprints[node_index])\n-    }\n-\n     #[inline]\n     pub fn fingerprint_by_index(&self, dep_node_index: SerializedDepNodeIndex) -> Fingerprint {\n         self.fingerprints[dep_node_index]"}, {"sha": "186417e862a23267badf54bf8c498c6e1db3d1cb", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e10eab5956f91c26dcc5ae29a19cfcd747047e4d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10eab5956f91c26dcc5ae29a19cfcd747047e4d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=e10eab5956f91c26dcc5ae29a19cfcd747047e4d", "patch": "@@ -7,6 +7,7 @@ use crate::dep_graph::{DepGraphData, HasDepContext};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n+use crate::query::SerializedDepNodeIndex;\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n use crate::values::Value;\n use crate::HandleCycleError;\n@@ -19,7 +20,6 @@ use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, FatalError};\n-use rustc_session::Session;\n use rustc_span::{Span, DUMMY_SP};\n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n@@ -537,7 +537,7 @@ where\n \n     let (prev_dep_node_index, dep_node_index) = dep_graph_data.try_mark_green(qcx, &dep_node)?;\n \n-    debug_assert!(dep_graph_data.is_green(dep_node));\n+    debug_assert!(dep_graph_data.is_index_green(prev_dep_node_index));\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n@@ -561,8 +561,7 @@ where\n                 dep_graph_data.mark_debug_loaded_from_disk(*dep_node)\n             }\n \n-            let prev_fingerprint =\n-                dep_graph_data.prev_fingerprint_of(dep_node).unwrap_or(Fingerprint::ZERO);\n+            let prev_fingerprint = dep_graph_data.prev_fingerprint_of(prev_dep_node_index);\n             // If `-Zincremental-verify-ich` is specified, re-hash results from\n             // the cache and make sure that they have the expected fingerprint.\n             //\n@@ -578,7 +577,7 @@ where\n                     *qcx.dep_context(),\n                     dep_graph_data,\n                     &result,\n-                    dep_node,\n+                    prev_dep_node_index,\n                     query.hash_result(),\n                 );\n             }\n@@ -623,7 +622,7 @@ where\n         *qcx.dep_context(),\n         dep_graph_data,\n         &result,\n-        dep_node,\n+        prev_dep_node_index,\n         query.hash_result(),\n     );\n \n@@ -636,77 +635,50 @@ pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n     tcx: Tcx,\n     dep_graph_data: &DepGraphData<Tcx::DepKind>,\n     result: &V,\n-    dep_node: &DepNode<Tcx::DepKind>,\n+    prev_index: SerializedDepNodeIndex,\n     hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n-) -> Fingerprint\n-where\n+) where\n     Tcx: DepContext,\n {\n-    assert!(\n-        dep_graph_data.is_green(dep_node),\n-        \"fingerprint for green query instance not loaded from cache: {dep_node:?}\",\n-    );\n+    if !dep_graph_data.is_index_green(prev_index) {\n+        incremental_verify_ich_not_green(tcx, prev_index)\n+    }\n \n     let new_hash = hash_result.map_or(Fingerprint::ZERO, |f| {\n         tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n \n-    let old_hash = dep_graph_data.prev_fingerprint_of(dep_node);\n+    let old_hash = dep_graph_data.prev_fingerprint_of(prev_index);\n \n-    if Some(new_hash) != old_hash {\n-        incremental_verify_ich_failed(\n-            tcx.sess(),\n-            DebugArg::from(&dep_node),\n-            DebugArg::from(&result),\n-        );\n+    if new_hash != old_hash {\n+        incremental_verify_ich_failed(tcx, prev_index, result);\n     }\n-\n-    new_hash\n }\n \n-// This DebugArg business is largely a mirror of std::fmt::ArgumentV1, which is\n-// currently not exposed publicly.\n-//\n-// The PR which added this attempted to use `&dyn Debug` instead, but that\n-// showed statistically significant worse compiler performance. It's not\n-// actually clear what the cause there was -- the code should be cold. If this\n-// can be replaced with `&dyn Debug` with on perf impact, then it probably\n-// should be.\n-extern \"C\" {\n-    type Opaque;\n-}\n-\n-struct DebugArg<'a> {\n-    value: &'a Opaque,\n-    fmt: fn(&Opaque, &mut std::fmt::Formatter<'_>) -> std::fmt::Result,\n-}\n-\n-impl<'a, T> From<&'a T> for DebugArg<'a>\n+#[cold]\n+#[inline(never)]\n+fn incremental_verify_ich_not_green<Tcx>(tcx: Tcx, prev_index: SerializedDepNodeIndex)\n where\n-    T: std::fmt::Debug,\n+    Tcx: DepContext,\n {\n-    fn from(value: &'a T) -> DebugArg<'a> {\n-        DebugArg {\n-            value: unsafe { std::mem::transmute(value) },\n-            fmt: unsafe {\n-                std::mem::transmute(<T as std::fmt::Debug>::fmt as fn(_, _) -> std::fmt::Result)\n-            },\n-        }\n-    }\n-}\n-\n-impl std::fmt::Debug for DebugArg<'_> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        (self.fmt)(self.value, f)\n-    }\n+    panic!(\n+        \"fingerprint for green query instance not loaded from cache: {:?}\",\n+        tcx.dep_graph().data().unwrap().prev_node_of(prev_index)\n+    )\n }\n \n-// Note that this is marked #[cold] and intentionally takes the equivalent of\n-// `dyn Debug` for its arguments, as we want to avoid generating a bunch of\n-// different implementations for LLVM to chew on (and filling up the final\n-// binary, too).\n+// Note that this is marked #[cold] and intentionally takes `dyn Debug` for `result`,\n+// as we want to avoid generating a bunch of different implementations for LLVM to\n+// chew on (and filling up the final binary, too).\n #[cold]\n-fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result: DebugArg<'_>) {\n+#[inline(never)]\n+fn incremental_verify_ich_failed<Tcx>(\n+    tcx: Tcx,\n+    prev_index: SerializedDepNodeIndex,\n+    result: &dyn Debug,\n+) where\n+    Tcx: DepContext,\n+{\n     // When we emit an error message and panic, we try to debug-print the `DepNode`\n     // and query result. Unfortunately, this can cause us to run additional queries,\n     // which may result in another fingerprint mismatch while we're in the middle\n@@ -720,15 +692,17 @@ fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result:\n     let old_in_panic = INSIDE_VERIFY_PANIC.with(|in_panic| in_panic.replace(true));\n \n     if old_in_panic {\n-        sess.emit_err(crate::error::Reentrant);\n+        tcx.sess().emit_err(crate::error::Reentrant);\n     } else {\n-        let run_cmd = if let Some(crate_name) = &sess.opts.crate_name {\n+        let run_cmd = if let Some(crate_name) = &tcx.sess().opts.crate_name {\n             format!(\"`cargo clean -p {crate_name}` or `cargo clean`\")\n         } else {\n             \"`cargo clean`\".to_string()\n         };\n \n-        sess.emit_err(crate::error::IncrementCompilation {\n+        let dep_node = tcx.dep_graph().data().unwrap().prev_node_of(prev_index);\n+\n+        let dep_node = tcx.sess().emit_err(crate::error::IncrementCompilation {\n             run_cmd,\n             dep_node: format!(\"{dep_node:?}\"),\n         });"}]}