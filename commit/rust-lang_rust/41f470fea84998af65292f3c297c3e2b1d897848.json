{"sha": "41f470fea84998af65292f3c297c3e2b1d897848", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZjQ3MGZlYTg0OTk4YWY2NTI5MmYzYzI5N2MzZTJiMWQ4OTc4NDg=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-08T20:34:55Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-08T20:34:55Z"}, "message": "Correctly support SelfType when searching for usages", "tree": {"sha": "2dee702ff58dd614a559e9f4ef3080419cabd2c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dee702ff58dd614a559e9f4ef3080419cabd2c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41f470fea84998af65292f3c297c3e2b1d897848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41f470fea84998af65292f3c297c3e2b1d897848", "html_url": "https://github.com/rust-lang/rust/commit/41f470fea84998af65292f3c297c3e2b1d897848", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41f470fea84998af65292f3c297c3e2b1d897848/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96c5df9b171730ad69e130e074584684cee35014", "url": "https://api.github.com/repos/rust-lang/rust/commits/96c5df9b171730ad69e130e074584684cee35014", "html_url": "https://github.com/rust-lang/rust/commit/96c5df9b171730ad69e130e074584684cee35014"}], "stats": {"total": 286, "additions": 210, "deletions": 76}, "files": [{"sha": "c9ef4b42056878205e3644197067bbe9a7779408", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=41f470fea84998af65292f3c297c3e2b1d897848", "patch": "@@ -2071,6 +2071,10 @@ impl Type {\n         Some(adt.into())\n     }\n \n+    pub fn as_builtin(&self) -> Option<BuiltinType> {\n+        self.ty.as_builtin().map(|inner| BuiltinType { inner })\n+    }\n+\n     pub fn as_dyn_trait(&self) -> Option<Trait> {\n         self.ty.dyn_trait().map(Into::into)\n     }"}, {"sha": "5232a7d80387fcdf4d68ffac43e84195b043d0f0", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=41f470fea84998af65292f3c297c3e2b1d897848", "patch": "@@ -1,8 +1,10 @@\n //! Various extensions traits for Chalk types.\n \n-use chalk_ir::Mutability;\n+use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, UintTy};\n use hir_def::{\n-    type_ref::Rawness, AssocContainerId, FunctionId, GenericDefId, HasModule, Lookup, TraitId,\n+    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n+    type_ref::Rawness,\n+    AssocContainerId, FunctionId, GenericDefId, HasModule, Lookup, TraitId,\n };\n \n use crate::{\n@@ -18,6 +20,7 @@ pub trait TyExt {\n     fn is_unknown(&self) -> bool;\n \n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)>;\n+    fn as_builtin(&self) -> Option<BuiltinType>;\n     fn as_tuple(&self) -> Option<&Substitution>;\n     fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId>;\n     fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)>;\n@@ -59,6 +62,35 @@ impl TyExt for Ty {\n         }\n     }\n \n+    fn as_builtin(&self) -> Option<BuiltinType> {\n+        match self.kind(&Interner) {\n+            TyKind::Str => Some(BuiltinType::Str),\n+            TyKind::Scalar(Scalar::Bool) => Some(BuiltinType::Bool),\n+            TyKind::Scalar(Scalar::Char) => Some(BuiltinType::Char),\n+            TyKind::Scalar(Scalar::Float(fty)) => Some(BuiltinType::Float(match fty {\n+                FloatTy::F64 => BuiltinFloat::F64,\n+                FloatTy::F32 => BuiltinFloat::F32,\n+            })),\n+            TyKind::Scalar(Scalar::Int(ity)) => Some(BuiltinType::Int(match ity {\n+                IntTy::Isize => BuiltinInt::Isize,\n+                IntTy::I8 => BuiltinInt::I8,\n+                IntTy::I16 => BuiltinInt::I16,\n+                IntTy::I32 => BuiltinInt::I32,\n+                IntTy::I64 => BuiltinInt::I64,\n+                IntTy::I128 => BuiltinInt::I128,\n+            })),\n+            TyKind::Scalar(Scalar::Uint(ity)) => Some(BuiltinType::Uint(match ity {\n+                UintTy::Usize => BuiltinUint::Usize,\n+                UintTy::U8 => BuiltinUint::U8,\n+                UintTy::U16 => BuiltinUint::U16,\n+                UintTy::U32 => BuiltinUint::U32,\n+                UintTy::U64 => BuiltinUint::U64,\n+                UintTy::U128 => BuiltinUint::U128,\n+            })),\n+            _ => None,\n+        }\n+    }\n+\n     fn as_tuple(&self) -> Option<&Substitution> {\n         match self.kind(&Interner) {\n             TyKind::Tuple(_, substs) => Some(substs),"}, {"sha": "1551cd2a8b6f871c38fead63b4406ecd910eda82", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=41f470fea84998af65292f3c297c3e2b1d897848", "patch": "@@ -65,7 +65,7 @@ pub(crate) fn find_all_refs(\n             (find_def(&sema, &syntax, position)?, false)\n         };\n \n-    let mut usages = def.usages(sema).set_scope(search_scope).all();\n+    let mut usages = def.usages(sema).set_scope(search_scope).include_self_refs().all();\n     if is_literal_search {\n         // filter for constructor-literals\n         let refs = usages.references.values_mut();\n@@ -1166,18 +1166,67 @@ fn foo<const FOO$0: usize>() -> usize {\n     fn test_find_self_ty_in_trait_def() {\n         check(\n             r#\"\n-trait Foo {\n+trait Foo where Self: {\n     fn f() -> Self$0;\n }\n \"#,\n             expect![[r#\"\n                 Self TypeParam FileId(0) 6..9 6..9\n \n-                FileId(0) 26..30\n+                FileId(0) 16..20\n+                FileId(0) 38..42\n             \"#]],\n         );\n+        //         check(\n+        //             r#\"\n+        // trait Foo$0 where Self: {\n+        //     fn f() -> Self;\n+        // }\n+        // \"#,\n+        //             expect![[r#\"\n+        //                 Foo Trait FileId(0) 0..45 6..9\n+\n+        //                 FileId(0) 16..20\n+        //                 FileId(0) 38..42\n+        //             \"#]],\n+        //         );\n     }\n \n+    #[test]\n+    fn test_self_ty() {\n+        check(\n+            r#\"\n+        struct $0Foo;\n+\n+        impl Foo where Self: {\n+            fn f() -> Self;\n+        }\n+        \"#,\n+            expect![[r#\"\n+                        Foo Struct FileId(0) 0..11 7..10\n+\n+                        FileId(0) 18..21\n+                        FileId(0) 28..32\n+                        FileId(0) 50..54\n+                    \"#]],\n+        );\n+        check(\n+            r#\"\n+struct Foo;\n+\n+impl Foo where Self: {\n+    fn f() -> Self$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                impl Impl FileId(0) 13..57 18..21\n+\n+                FileId(0) 18..21\n+                FileId(0) 28..32\n+                FileId(0) 50..54\n+            \"#]],\n+        );\n+    }\n     #[test]\n     fn test_self_variant_with_payload() {\n         check("}, {"sha": "2bf9533052a26c1f8ce394e6f017470bfc8e5dad", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=41f470fea84998af65292f3c297c3e2b1d897848", "patch": "@@ -1888,4 +1888,21 @@ impl Foo {\n             \"error: Cannot rename `Self`\",\n         );\n     }\n+\n+    #[test]\n+    fn test_rename_ignores_self_ty() {\n+        check(\n+            \"Fo0\",\n+            r#\"\n+struct $0Foo;\n+\n+impl Foo where Self: {}\n+\"#,\n+            r#\"\n+struct Fo0;\n+\n+impl Fo0 where Self: {}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "70949ca3580f7c3df6a9c9784305a3e281ba3434", "filename": "crates/ide_assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=41f470fea84998af65292f3c297c3e2b1d897848", "patch": "@@ -107,7 +107,7 @@ fn edit_struct_references(\n     names: &[ast::Name],\n ) {\n     let strukt_def = Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(strukt)));\n-    let usages = strukt_def.usages(&ctx.sema).include_self_kw_refs(true).all();\n+    let usages = strukt_def.usages(&ctx.sema).include_self_refs().all();\n \n     let edit_node = |edit: &mut AssistBuilder, node: SyntaxNode| -> Option<()> {\n         match_ast! {"}, {"sha": "891b8cf0a089494bdef91041ea9179aeea251dd4", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 102, "deletions": 70, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f470fea84998af65292f3c297c3e2b1d897848/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=41f470fea84998af65292f3c297c3e2b1d897848", "patch": "@@ -233,6 +233,13 @@ impl Definition {\n             };\n         }\n \n+        if let Definition::SelfType(impl_) = self {\n+            return match impl_.source(db).map(|src| src.value.syntax().text_range()) {\n+                Some(range) => SearchScope::file_range(FileRange { file_id, range }),\n+                None => SearchScope::single_file(file_id),\n+            };\n+        }\n+\n         if let Definition::GenericParam(hir::GenericParam::LifetimeParam(param)) = self {\n             let range = match param.parent(db) {\n                 hir::GenericDef::Function(it) => {\n@@ -297,20 +304,21 @@ impl Definition {\n     }\n \n     pub fn usages<'a>(&'a self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n-        FindUsages { def: self, sema, scope: None, include_self_kw_refs: false }\n+        FindUsages { def: self, sema, scope: None, include_self_kw_refs: None }\n     }\n }\n \n pub struct FindUsages<'a> {\n     def: &'a Definition,\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n-    include_self_kw_refs: bool,\n+    include_self_kw_refs: Option<hir::Type>,\n }\n \n impl<'a> FindUsages<'a> {\n-    pub fn include_self_kw_refs(mut self, include: bool) -> FindUsages<'a> {\n-        self.include_self_kw_refs = include;\n+    /// Enable searching for `Self` when the definition is a type.\n+    pub fn include_self_refs(mut self) -> FindUsages<'a> {\n+        self.include_self_kw_refs = def_to_ty(self.sema.db, self.def);\n         self\n     }\n \n@@ -354,13 +362,18 @@ impl<'a> FindUsages<'a> {\n             }\n         };\n \n-        let name = match self.def.name(sema.db) {\n-            Some(it) => it.to_string(),\n+        let name = self.def.name(sema.db).or_else(|| {\n+            self.include_self_kw_refs.as_ref().and_then(|ty| {\n+                ty.as_adt()\n+                    .map(|adt| adt.name(self.sema.db))\n+                    .or_else(|| ty.as_builtin().map(|builtin| builtin.name()))\n+            })\n+        });\n+        let name = match name {\n+            Some(name) => name.to_string(),\n             None => return,\n         };\n-\n-        let pat = name.as_str();\n-        let search_for_self = self.include_self_kw_refs;\n+        let name = name.as_str();\n \n         for (file_id, search_range) in search_scope {\n             let text = sema.db.file_text(file_id);\n@@ -369,51 +382,63 @@ impl<'a> FindUsages<'a> {\n \n             let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n \n-            let mut handle_match = |idx: usize| -> bool {\n+            for (idx, _) in text.match_indices(name) {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n-                    return false;\n+                    continue;\n                 }\n \n                 if let Some(name) = sema.find_node_at_offset_with_descend(&tree, offset) {\n-                    match name {\n-                        ast::NameLike::NameRef(name_ref) => {\n-                            if self.found_name_ref(&name_ref, sink) {\n-                                return true;\n-                            }\n-                        }\n-                        ast::NameLike::Name(name) => {\n-                            if self.found_name(&name, sink) {\n-                                return true;\n-                            }\n-                        }\n-                        ast::NameLike::Lifetime(lifetime) => {\n-                            if self.found_lifetime(&lifetime, sink) {\n-                                return true;\n-                            }\n-                        }\n+                    if match name {\n+                        ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n+                        ast::NameLike::Name(name) => self.found_name(&name, sink),\n+                        ast::NameLike::Lifetime(lifetime) => self.found_lifetime(&lifetime, sink),\n+                    } {\n+                        return;\n                     }\n                 }\n-\n-                return false;\n-            };\n-\n-            for (idx, _) in text.match_indices(pat) {\n-                if handle_match(idx) {\n-                    return;\n-                }\n             }\n-\n-            if search_for_self {\n+            if let Some(self_ty) = &self.include_self_kw_refs {\n                 for (idx, _) in text.match_indices(\"Self\") {\n-                    if handle_match(idx) {\n-                        return;\n+                    let offset: TextSize = idx.try_into().unwrap();\n+                    if !search_range.contains_inclusive(offset) {\n+                        continue;\n+                    }\n+\n+                    if let Some(ast::NameLike::NameRef(name_ref)) =\n+                        sema.find_node_at_offset_with_descend(&tree, offset)\n+                    {\n+                        if self.found_self_ty_name_ref(&self_ty, &name_ref, sink) {\n+                            return;\n+                        }\n                     }\n                 }\n             }\n         }\n     }\n \n+    fn found_self_ty_name_ref(\n+        &self,\n+        self_ty: &hir::Type,\n+        name_ref: &ast::NameRef,\n+        sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n+    ) -> bool {\n+        match NameRefClass::classify(self.sema, &name_ref) {\n+            Some(NameRefClass::Definition(Definition::SelfType(impl_)))\n+                if impl_.self_ty(self.sema.db) == *self_ty =>\n+            {\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::NameRef(name_ref.clone()),\n+                    access: None,\n+                };\n+                sink(file_id, reference)\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn found_lifetime(\n         &self,\n         lifetime: &ast::Lifetime,\n@@ -429,7 +454,7 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n-            _ => false, // not a usage\n+            _ => false,\n         }\n     }\n \n@@ -448,42 +473,35 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n-            Some(NameRefClass::Definition(Definition::SelfType(impl_))) => {\n-                let ty = impl_.self_ty(self.sema.db);\n-\n-                if let Some(adt) = ty.as_adt() {\n-                    if &Definition::ModuleDef(ModuleDef::Adt(adt)) == self.def {\n-                        let FileRange { file_id, range } =\n-                            self.sema.original_range(name_ref.syntax());\n-                        let reference = FileReference {\n-                            range,\n-                            name: ast::NameLike::NameRef(name_ref.clone()),\n-                            access: None,\n-                        };\n-                        return sink(file_id, reference);\n-                    }\n+            Some(NameRefClass::Definition(def)) if self.include_self_kw_refs.is_some() => {\n+                if self.include_self_kw_refs == def_to_ty(self.sema.db, &def) {\n+                    let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                    let reference = FileReference {\n+                        range,\n+                        name: ast::NameLike::NameRef(name_ref.clone()),\n+                        access: reference_access(&def, &name_ref),\n+                    };\n+                    sink(file_id, reference)\n+                } else {\n+                    false\n                 }\n-\n-                false\n             }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n-                let reference = match self.def {\n-                    Definition::Field(_) if &field == self.def => FileReference {\n-                        range,\n-                        name: ast::NameLike::NameRef(name_ref.clone()),\n-                        access: reference_access(&field, &name_ref),\n-                    },\n-                    Definition::Local(l) if &local == l => FileReference {\n-                        range,\n-                        name: ast::NameLike::NameRef(name_ref.clone()),\n-                        access: reference_access(&Definition::Local(local), &name_ref),\n-                    },\n-                    _ => return false, // not a usage\n+                let access = match self.def {\n+                    Definition::Field(_) if &field == self.def => {\n+                        reference_access(&field, &name_ref)\n+                    }\n+                    Definition::Local(l) if &local == l => {\n+                        reference_access(&Definition::Local(local), &name_ref)\n+                    }\n+                    _ => return false,\n                 };\n+                let reference =\n+                    FileReference { range, name: ast::NameLike::NameRef(name_ref.clone()), access };\n                 sink(file_id, reference)\n             }\n-            _ => false, // not a usage\n+            _ => false,\n         }\n     }\n \n@@ -513,11 +531,25 @@ impl<'a> FindUsages<'a> {\n                     FileReference { range, name: ast::NameLike::Name(name.clone()), access: None };\n                 sink(file_id, reference)\n             }\n-            _ => false, // not a usage\n+            _ => false,\n         }\n     }\n }\n \n+fn def_to_ty(db: &RootDatabase, def: &Definition) -> Option<hir::Type> {\n+    match def {\n+        Definition::ModuleDef(def) => match def {\n+            ModuleDef::Adt(adt) => Some(adt.ty(db)),\n+            ModuleDef::TypeAlias(it) => Some(it.ty(db)),\n+            ModuleDef::BuiltinType(_it) => None, // FIXME somehow acquire some module to construct the builtin type\n+            ModuleDef::Trait(_it) => None,       // FIXME turn trait into its self-type\n+            _ => None,\n+        },\n+        Definition::SelfType(it) => Some(it.self_ty(db)),\n+        _ => None,\n+    }\n+}\n+\n fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n     // Only Locals and Fields have accesses for now.\n     if !matches!(def, Definition::Local(_) | Definition::Field(_)) {"}]}