{"sha": "a072d1bca6282d1d2fbec103d12393527eb5a868", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNzJkMWJjYTYyODJkMWQyZmJlYzEwM2QxMjM5MzUyN2ViNWE4Njg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-24T14:47:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-24T14:47:17Z"}, "message": "Auto merge of #54509 - matthewjasper:better-drop-access, r=pnkfelix\n\n[NLL] Rework checking for borrows conflicting with drops\n\nPreviously, we would split the drop access into multiple checks for each\nfield of a struct/tuple/closure and through `Box` dereferences. This\nchanges this to check if the borrow is accessed by the drop in\n`places_conflict`.\n\nWe also now handle enums containing `Drop` types.\n\nCloses #53569\n\nr? @nikomatsakis\ncc @pnkfelix", "tree": {"sha": "75e68c7a54376c61581e00d6e8c10967e1e52b07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75e68c7a54376c61581e00d6e8c10967e1e52b07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a072d1bca6282d1d2fbec103d12393527eb5a868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a072d1bca6282d1d2fbec103d12393527eb5a868", "html_url": "https://github.com/rust-lang/rust/commit/a072d1bca6282d1d2fbec103d12393527eb5a868", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a072d1bca6282d1d2fbec103d12393527eb5a868/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5c6575801028f5e089ef2e7720aa1af9d452334", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5c6575801028f5e089ef2e7720aa1af9d452334", "html_url": "https://github.com/rust-lang/rust/commit/e5c6575801028f5e089ef2e7720aa1af9d452334"}, {"sha": "cfbd1a9a250ba3a82041c46605dcf16356f33727", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfbd1a9a250ba3a82041c46605dcf16356f33727", "html_url": "https://github.com/rust-lang/rust/commit/cfbd1a9a250ba3a82041c46605dcf16356f33727"}], "stats": {"total": 698, "additions": 282, "deletions": 416}, "files": [{"sha": "1d91fa365d547a57b565a1d7e4d6760e98f884d6", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 83, "deletions": 25, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::{WriteKind, StorageDeadOrDrop};\n+use borrow_check::WriteKind;\n use borrow_check::prefixes::IsPrefixOf;\n use borrow_check::nll::explain_borrow::BorrowExplanation;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, FakeReadCause, Field, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, ProjectionElem, Rvalue, Statement,\n-    StatementKind, TerminatorKind, VarBindingForm,\n+    LocalDecl, LocalKind, Location, Operand, Place, PlaceProjection, ProjectionElem, Rvalue,\n+    Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -452,13 +452,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.access_place_error_reported\n             .insert((root_place.clone(), borrow_span));\n \n-        if let Some(WriteKind::StorageDeadOrDrop(StorageDeadOrDrop::Destructor)) = kind {\n+        if let StorageDeadOrDrop::Destructor(dropped_ty)\n+            = self.classify_drop_access_kind(&borrow.borrowed_place)\n+        {\n             // If a borrow of path `B` conflicts with drop of `D` (and\n             // we're not in the uninteresting case where `B` is a\n             // prefix of `D`), then report this as a more interesting\n             // destructor conflict.\n             if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n-                self.report_borrow_conflicts_with_destructor(context, borrow, place_span, kind);\n+                self.report_borrow_conflicts_with_destructor(\n+                    context,\n+                    borrow,\n+                    place_span,\n+                    kind,\n+                    dropped_ty,\n+                );\n                 return;\n             }\n         }\n@@ -566,6 +574,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         (place, drop_span): (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n+        dropped_ty: ty::Ty<'tcx>,\n     ) {\n         debug!(\n             \"report_borrow_conflicts_with_destructor(\\\n@@ -579,28 +588,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let mut err = self.infcx.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n \n-        let (what_was_dropped, dropped_ty) = {\n-            let desc = match self.describe_place(place) {\n-                Some(name) => format!(\"`{}`\", name.as_str()),\n-                None => format!(\"temporary value\"),\n-            };\n-            let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n-            (desc, ty)\n+        let what_was_dropped = match self.describe_place(place) {\n+            Some(name) => format!(\"`{}`\", name.as_str()),\n+            None => format!(\"temporary value\"),\n         };\n \n-        let label = match dropped_ty.sty {\n-            ty::Adt(adt, _) if adt.has_dtor(self.infcx.tcx) && !adt.is_box() => {\n-                match self.describe_place(&borrow.borrowed_place) {\n-                    Some(borrowed) =>\n-                        format!(\"here, drop of {D} needs exclusive access to `{B}`, \\\n-                                 because the type `{T}` implements the `Drop` trait\",\n-                                D=what_was_dropped, T=dropped_ty, B=borrowed),\n-                    None =>\n-                        format!(\"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n-                                D=what_was_dropped, T=dropped_ty),\n-                }\n-            }\n-            _ => format!(\"drop of {D} occurs here\", D=what_was_dropped),\n+        let label = match self.describe_place(&borrow.borrowed_place) {\n+            Some(borrowed) =>\n+                format!(\"here, drop of {D} needs exclusive access to `{B}`, \\\n+                         because the type `{T}` implements the `Drop` trait\",\n+                        D=what_was_dropped, T=dropped_ty, B=borrowed),\n+            None =>\n+                format!(\"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n+                        D=what_was_dropped, T=dropped_ty),\n         };\n         err.span_label(drop_span, label);\n \n@@ -880,6 +880,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n pub(super) struct IncludingDowncast(bool);\n \n+/// Which case a StorageDeadOrDrop is for.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum StorageDeadOrDrop<'tcx> {\n+    LocalStorageDead,\n+    BoxedStorageDead,\n+    Destructor(ty::Ty<'tcx>),\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // End-user visible description of `place` if one can be found. If the\n     // place is a temporary for instance, None will be returned.\n@@ -1167,6 +1175,56 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn classify_drop_access_kind(&self, place: &Place<'tcx>) -> StorageDeadOrDrop<'tcx> {\n+        let tcx = self.infcx.tcx;\n+        match place {\n+            Place::Local(_)\n+            | Place::Static(_)\n+            | Place::Promoted(_) => StorageDeadOrDrop::LocalStorageDead,\n+            Place::Projection(box PlaceProjection { base, elem }) => {\n+                let base_access = self.classify_drop_access_kind(base);\n+                match elem {\n+                    ProjectionElem::Deref => {\n+                        match base_access {\n+                            StorageDeadOrDrop::LocalStorageDead\n+                            | StorageDeadOrDrop::BoxedStorageDead => {\n+                                assert!(base.ty(self.mir, tcx).to_ty(tcx).is_box(),\n+                                        \"Drop of value behind a reference or raw pointer\");\n+                                StorageDeadOrDrop::BoxedStorageDead\n+                            }\n+                            StorageDeadOrDrop::Destructor(_) => {\n+                                base_access\n+                            }\n+                        }\n+                    }\n+                    ProjectionElem::Field(..)\n+                    | ProjectionElem::Downcast(..) => {\n+                        let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+                        match base_ty.sty {\n+                            ty::Adt(def, _) if def.has_dtor(tcx) => {\n+                                // Report the outermost adt with a destructor\n+                                match base_access {\n+                                    StorageDeadOrDrop::Destructor(_) => {\n+                                        base_access\n+                                    }\n+                                    StorageDeadOrDrop::LocalStorageDead\n+                                    | StorageDeadOrDrop::BoxedStorageDead => {\n+                                        StorageDeadOrDrop::Destructor(base_ty)\n+                                    }\n+                                }\n+                            }\n+                            _ => base_access,\n+                        }\n+                    }\n+\n+                    ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. }\n+                    | ProjectionElem::Index(_) => base_access,\n+                }\n+            }\n+        }\n+    }\n+\n     /// Annotate argument and return type of function and closure with (synthesized) lifetime for\n     /// borrow of local value that does not live long enough.\n     fn annotate_argument_and_return_for_borrow("}, {"sha": "769e1097bff05bf303de493d67434b69501c5832", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 23, "deletions": 251, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -23,13 +23,12 @@ use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Pla\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, ParamEnv, TyCtxt, Ty};\n+use rustc::ty::{self, TyCtxt};\n \n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, Level};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::Dominators;\n-use rustc_data_structures::indexed_vec::Idx;\n use smallvec::SmallVec;\n \n use std::rc::Rc;\n@@ -251,7 +250,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         mir,\n         mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n-        param_env: param_env,\n         location_table,\n         movable_generator,\n         locals_are_invalidated_at_exit,\n@@ -393,7 +391,6 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// when MIR borrowck begins.\n     location_table: &'cx LocationTable,\n \n-    param_env: ParamEnv<'gcx>,\n     movable_generator: bool,\n     /// This keeps track of whether local variables are free-ed when the function\n     /// exits even without a `StorageDead`, which appears to be the case for\n@@ -574,8 +571,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 self.access_place(\n                     ContextKind::StorageDead.new(location),\n                     (&Place::Local(local), span),\n-                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop(\n-                        StorageDeadOrDrop::LocalStorageDead))),\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n@@ -630,8 +626,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                         loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n                        loc, term, drop_place, drop_place_ty, span);\n \n-                self.visit_terminator_drop(\n-                    loc, term, flow_state, drop_place, drop_place_ty, span, SeenTy(None));\n+                self.access_place(\n+                    ContextKind::Drop.new(loc),\n+                    (drop_place, span),\n+                    (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n+                    LocalMutationIsAllowed::Yes,\n+                    flow_state,\n+                );\n             }\n             TerminatorKind::DropAndReplace {\n                 location: ref drop_place,\n@@ -748,7 +749,7 @@ enum MutateMode {\n }\n \n use self::ReadOrWrite::{Activation, Read, Reservation, Write};\n-use self::ShallowOrDeep::{Deep, Shallow};\n+use self::AccessDepth::{Deep, Shallow};\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ArtificialField {\n@@ -757,7 +758,7 @@ enum ArtificialField {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum ShallowOrDeep {\n+enum AccessDepth {\n     /// From the RFC: \"A *shallow* access means that the immediate\n     /// fields reached at P are accessed, but references or pointers\n     /// found within are not dereferenced. Right now, the only access\n@@ -769,6 +770,10 @@ enum ShallowOrDeep {\n     /// through the given place may be invalidated or accesses by\n     /// this action.\"\n     Deep,\n+\n+    /// Access is Deep only when there is a Drop implementation that\n+    /// can reach the data behind the reference.\n+    Drop,\n }\n \n /// Kind of access to a value: read or write\n@@ -803,21 +808,12 @@ enum ReadKind {\n /// (For informational purposes only)\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum WriteKind {\n-    StorageDeadOrDrop(StorageDeadOrDrop),\n+    StorageDeadOrDrop,\n     MutableBorrow(BorrowKind),\n     Mutate,\n     Move,\n }\n \n-/// Specify whether which case a StorageDeadOrDrop is in.\n-/// (For informational purposes only)\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum StorageDeadOrDrop {\n-    LocalStorageDead,\n-    BoxedStorageDead,\n-    Destructor,\n-}\n-\n /// When checking permissions for a place access, this flag is used to indicate that an immutable\n /// local place can be mutated.\n ///\n@@ -868,231 +864,7 @@ impl InitializationRequiringAction {\n     }\n }\n \n-/// A simple linked-list threaded up the stack of recursive calls in `visit_terminator_drop`.\n-#[derive(Copy, Clone, Debug)]\n-struct SeenTy<'a, 'gcx: 'a>(Option<(Ty<'gcx>, &'a SeenTy<'a, 'gcx>)>);\n-\n-impl<'a, 'gcx> SeenTy<'a, 'gcx> {\n-    /// Return a new list with `ty` prepended to the front of `self`.\n-    fn cons(&'a self, ty: Ty<'gcx>) -> Self {\n-        SeenTy(Some((ty, self)))\n-    }\n-\n-    /// True if and only if `ty` occurs on the linked list `self`.\n-    fn have_seen(self, ty: Ty) -> bool {\n-        let mut this = self.0;\n-        loop {\n-            match this {\n-                None => return false,\n-                Some((seen_ty, recur)) => {\n-                    if seen_ty == ty {\n-                        return true;\n-                    } else {\n-                        this = recur.0;\n-                        continue;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    /// Invokes `access_place` as appropriate for dropping the value\n-    /// at `drop_place`. Note that the *actual* `Drop` in the MIR is\n-    /// always for a variable (e.g., `Drop(x)`) -- but we recursively\n-    /// break this variable down into subpaths (e.g., `Drop(x.foo)`)\n-    /// to indicate more precisely which fields might actually be\n-    /// accessed by a destructor.\n-    fn visit_terminator_drop(\n-        &mut self,\n-        loc: Location,\n-        term: &Terminator<'tcx>,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n-        drop_place: &Place<'tcx>,\n-        erased_drop_place_ty: ty::Ty<'gcx>,\n-        span: Span,\n-        prev_seen: SeenTy<'_, 'gcx>,\n-    ) {\n-        if prev_seen.have_seen(erased_drop_place_ty) {\n-            // if we have directly seen the input ty `T`, then we must\n-            // have had some *direct* ownership loop between `T` and\n-            // some directly-owned (as in, actually traversed by\n-            // recursive calls below) part that is also of type `T`.\n-            //\n-            // Note: in *all* such cases, the data in question cannot\n-            // be constructed (nor destructed) in finite time/space.\n-            //\n-            // Proper examples, some of which are statically rejected:\n-            //\n-            // * `struct A { field: A, ... }`:\n-            //   statically rejected as infinite size\n-            //\n-            // * `type B = (B, ...);`:\n-            //   statically rejected as cyclic\n-            //\n-            // * `struct C { field: Box<C>, ... }`\n-            // * `struct D { field: Box<(D, D)>, ... }`:\n-            //   *accepted*, though impossible to construct\n-            //\n-            // Here is *NOT* an example:\n-            // * `struct Z { field: Option<Box<Z>>, ... }`:\n-            //   Here, the type is both representable in finite space (due to the boxed indirection)\n-            //   and constructable in finite time (since the recursion can bottom out with `None`).\n-            //   This is an obvious instance of something the compiler must accept.\n-            //\n-            // Since some of the above impossible cases like `C` and\n-            // `D` are accepted by the compiler, we must take care not\n-            // to infinite-loop while processing them. But since such\n-            // cases cannot actually arise, it is sound for us to just\n-            // skip them during drop. If the developer uses unsafe\n-            // code to construct them, they should not be surprised by\n-            // weird drop behavior in their resulting code.\n-            debug!(\"visit_terminator_drop previously seen \\\n-                    erased_drop_place_ty: {:?} on prev_seen: {:?}; returning early.\",\n-                   erased_drop_place_ty, prev_seen);\n-            return;\n-        }\n-\n-        let gcx = self.infcx.tcx.global_tcx();\n-        let drop_field = |mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n-                          (index, field): (usize, ty::Ty<'gcx>)| {\n-            let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n-            let place = drop_place.clone().field(Field::new(index), field_ty);\n-\n-            debug!(\"visit_terminator_drop drop_field place: {:?} field_ty: {:?}\", place, field_ty);\n-            let seen = prev_seen.cons(erased_drop_place_ty);\n-            mir.visit_terminator_drop(loc, term, flow_state, &place, field_ty, span, seen);\n-        };\n-\n-        match erased_drop_place_ty.sty {\n-            // When a struct is being dropped, we need to check\n-            // whether it has a destructor, if it does, then we can\n-            // call it, if it does not then we need to check the\n-            // individual fields instead. This way if `foo` has a\n-            // destructor but `bar` does not, we will only check for\n-            // borrows of `x.foo` and not `x.bar`. See #47703.\n-            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n-                def.all_fields()\n-                    .map(|field| field.ty(gcx, substs))\n-                    .enumerate()\n-                    .for_each(|field| drop_field(self, field));\n-            }\n-            // Same as above, but for tuples.\n-            ty::Tuple(tys) => {\n-                tys.iter()\n-                    .cloned()\n-                    .enumerate()\n-                    .for_each(|field| drop_field(self, field));\n-            }\n-            // Closures also have disjoint fields, but they are only\n-            // directly accessed in the body of the closure.\n-            ty::Closure(def, substs)\n-                if *drop_place == Place::Local(Local::new(1))\n-                    && !self.mir.upvar_decls.is_empty() =>\n-            {\n-                substs\n-                    .upvar_tys(def, self.infcx.tcx)\n-                    .enumerate()\n-                    .for_each(|field| drop_field(self, field));\n-            }\n-            // Generators also have disjoint fields, but they are only\n-            // directly accessed in the body of the generator.\n-            ty::Generator(def, substs, _)\n-                if *drop_place == Place::Local(Local::new(1))\n-                    && !self.mir.upvar_decls.is_empty() =>\n-            {\n-                substs\n-                    .upvar_tys(def, self.infcx.tcx)\n-                    .enumerate()\n-                    .for_each(|field| drop_field(self, field));\n-            }\n-\n-            // #45696: special-case Box<T> by treating its dtor as\n-            // only deep *across owned content*. Namely, we know\n-            // dropping a box does not touch data behind any\n-            // references it holds; if we were to instead fall into\n-            // the base case below, we would have a Deep Write due to\n-            // the box being `needs_drop`, and that Deep Write would\n-            // touch `&mut` data in the box.\n-            ty::Adt(def, _) if def.is_box() => {\n-                // When/if we add a `&own T` type, this action would\n-                // be like running the destructor of the `&own T`.\n-                // (And the owner of backing storage referenced by the\n-                // `&own T` would be responsible for deallocating that\n-                // backing storage.)\n-\n-                // we model dropping any content owned by the box by\n-                // recurring on box contents. This catches cases like\n-                // `Box<Box<ScribbleWhenDropped<&mut T>>>`, while\n-                // still restricting Write to *owned* content.\n-                let ty = erased_drop_place_ty.boxed_ty();\n-                let deref_place = drop_place.clone().deref();\n-                debug!(\"visit_terminator_drop drop-box-content deref_place: {:?} ty: {:?}\",\n-                       deref_place, ty);\n-                let seen = prev_seen.cons(erased_drop_place_ty);\n-                self.visit_terminator_drop(\n-                    loc, term, flow_state, &deref_place, ty, span, seen);\n-            }\n-\n-            _ => {\n-                // We have now refined the type of the value being\n-                // dropped (potentially) to just the type of a\n-                // subfield; so check whether that field's type still\n-                // \"needs drop\".\n-                if erased_drop_place_ty.needs_drop(gcx, self.param_env) {\n-                    // If so, we assume that the destructor may access\n-                    // any data it likes (i.e., a Deep Write).\n-                    self.access_place(\n-                        ContextKind::Drop.new(loc),\n-                        (drop_place, span),\n-                        (Deep, Write(WriteKind::StorageDeadOrDrop(\n-                            StorageDeadOrDrop::Destructor))),\n-                        LocalMutationIsAllowed::Yes,\n-                        flow_state,\n-                    );\n-                } else {\n-                    // If there is no destructor, we still include a\n-                    // *shallow* write.  This essentially ensures that\n-                    // borrows of the memory directly at `drop_place`\n-                    // cannot continue to be borrowed across the drop.\n-                    //\n-                    // If we were to use a Deep Write here, then any\n-                    // `&mut T` that is reachable from `drop_place`\n-                    // would get invalidated; fixing that is the\n-                    // essence of resolving issue #45696.\n-                    //\n-                    // * Note: In the compiler today, doing a Deep\n-                    //   Write here would not actually break\n-                    //   anything beyond #45696; for example it does not\n-                    //   break this example:\n-                    //\n-                    //   ```rust\n-                    //   fn reborrow(x: &mut i32) -> &mut i32 { &mut *x }\n-                    //   ```\n-                    //\n-                    //   Why? Because we do not schedule/emit\n-                    //   `Drop(x)` in the MIR unless `x` needs drop in\n-                    //   the first place.\n-                    self.access_place(\n-                        ContextKind::Drop.new(loc),\n-                        (drop_place, span),\n-                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop(\n-                            // rust-lang/rust#52059: distinguish\n-                            // between invaliding the backing storage\n-                            // vs running a destructor.\n-                            //\n-                            // See also: rust-lang/rust#52782,\n-                            // specifically #discussion_r206658948\n-                            StorageDeadOrDrop::BoxedStorageDead))),\n-                        LocalMutationIsAllowed::Yes,\n-                        flow_state,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this\n@@ -1103,7 +875,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         place_span: (&Place<'tcx>, Span),\n-        kind: (ShallowOrDeep, ReadOrWrite),\n+        kind: (AccessDepth, ReadOrWrite),\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n@@ -1159,7 +931,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         place_span: (&Place<'tcx>, Span),\n-        sd: ShallowOrDeep,\n+        sd: AccessDepth,\n         rw: ReadOrWrite,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) -> bool {\n@@ -1252,7 +1024,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             error_reported = true;\n                             this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n-                        WriteKind::StorageDeadOrDrop(_) => {\n+                        WriteKind::StorageDeadOrDrop => {\n                             error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n                                 context,\n@@ -1281,7 +1053,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         place_span: (&Place<'tcx>, Span),\n-        kind: ShallowOrDeep,\n+        kind: AccessDepth,\n         mode: MutateMode,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n@@ -1925,9 +1697,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Reservation(wk @ WriteKind::Move)\n             | Write(wk @ WriteKind::Move)\n-            | Reservation(wk @ WriteKind::StorageDeadOrDrop(_))\n+            | Reservation(wk @ WriteKind::StorageDeadOrDrop)\n             | Reservation(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n-            | Write(wk @ WriteKind::StorageDeadOrDrop(_))\n+            | Write(wk @ WriteKind::StorageDeadOrDrop)\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n                 if let Err(_place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     if self.infcx.tcx.migrate_borrowck() {\n@@ -1942,7 +1714,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         error_access = match wk {\n                             WriteKind::MutableBorrow(_) => AccessKind::MutableBorrow,\n                             WriteKind::Move => AccessKind::Move,\n-                            WriteKind::StorageDeadOrDrop(_) |\n+                            WriteKind::StorageDeadOrDrop |\n                             WriteKind::Mutate => AccessKind::Mutate,\n                         };\n                         self.report_mutability_error("}, {"sha": "f4052f948013ab3971ab7becfdbfdd2cc2c65300", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -143,13 +143,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(Cause::DropVar(local, location)) => match &mir.local_decls[local].name {\n                 Some(local_name) => {\n                     let mut should_note_order = false;\n-                    if let Some((WriteKind::StorageDeadOrDrop(_), place)) = kind_place {\n+                    if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n                         if let Place::Local(borrowed_local) = place {\n                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n                             let borrowed_local_scope =\n                                 mir.local_decls[*borrowed_local].visibility_scope;\n \n-                            if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope) {\n+                            if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope)\n+                                && local != *borrowed_local\n+                            {\n                                 should_note_order = true;\n                             }\n                         }"}, {"sha": "3d387963da9dabda94ac15eca74114123a18723a", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 28, "deletions": 108, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -11,70 +11,61 @@\n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::{JustWrite, WriteAndRead};\n-use borrow_check::{ShallowOrDeep, Deep, Shallow};\n+use borrow_check::{AccessDepth, Deep, Shallow};\n use borrow_check::{ReadOrWrite, Activation, Read, Reservation, Write};\n use borrow_check::{Context, ContextKind};\n use borrow_check::{LocalMutationIsAllowed, MutateMode};\n use borrow_check::ArtificialField;\n-use borrow_check::{ReadKind, WriteKind, StorageDeadOrDrop};\n+use borrow_check::{ReadKind, WriteKind};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::path_utils::*;\n use dataflow::move_paths::indexes::BorrowIndex;\n-use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n+use rustc::ty::TyCtxt;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, Location, Mir, Place, Rvalue, Local};\n+use rustc::mir::{BasicBlock, Location, Mir, Place, Rvalue};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n-use rustc::mir::{Field, Operand, BorrowKind};\n-use rustc::ty::{self, ParamEnv};\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc::mir::{Operand, BorrowKind};\n use rustc_data_structures::graph::dominators::Dominators;\n \n pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n-    mir_def_id: DefId,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     if !all_facts.is_some() {\n         // Nothing to do if we don't have any facts\n         return;\n     }\n \n-    let param_env = infcx.tcx.param_env(mir_def_id);\n-\n     if let Some(all_facts) = all_facts {\n         let dominators = mir.dominators();\n         let mut ig = InvalidationGenerator {\n             all_facts,\n             borrow_set,\n-            infcx,\n+            tcx,\n             location_table,\n             mir,\n             dominators,\n-            param_env,\n         };\n         ig.visit_mir(mir);\n     }\n }\n \n-/// 'cg = the duration of the constraint generation process itself.\n-struct InvalidationGenerator<'cg, 'cx: 'cg, 'tcx: 'cx, 'gcx: 'tcx> {\n-    infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n-    all_facts: &'cg mut AllFacts,\n-    location_table: &'cg LocationTable,\n-    mir: &'cg Mir<'tcx>,\n+struct InvalidationGenerator<'cx, 'tcx: 'cx, 'gcx: 'tcx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    all_facts: &'cx mut AllFacts,\n+    location_table: &'cx LocationTable,\n+    mir: &'cx Mir<'tcx>,\n     dominators: Dominators<BasicBlock>,\n-    borrow_set: &'cg BorrowSet<'tcx>,\n-    param_env: ParamEnv<'gcx>,\n+    borrow_set: &'cx BorrowSet<'tcx>,\n }\n \n /// Visits the whole MIR and generates invalidates() facts\n /// Most of the code implementing this was stolen from borrow_check/mod.rs\n-impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n+impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     fn visit_statement(&mut self,\n                        block: BasicBlock,\n                        statement: &Statement<'tcx>,\n@@ -154,8 +145,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tc\n                 self.access_place(\n                     ContextKind::StorageDead.new(location),\n                     &Place::Local(local),\n-                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop(\n-                        StorageDeadOrDrop::LocalStorageDead))),\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n@@ -184,12 +174,12 @@ impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tc\n                 target: _,\n                 unwind: _,\n             } => {\n-                let tcx = self.infcx.tcx;\n-                let gcx = tcx.global_tcx();\n-                let drop_place_ty = drop_place.ty(self.mir, tcx);\n-                let drop_place_ty = tcx.erase_regions(&drop_place_ty).to_ty(tcx);\n-                let drop_place_ty = gcx.lift(&drop_place_ty).unwrap();\n-                self.visit_terminator_drop(location, terminator, drop_place, drop_place_ty);\n+                self.access_place(\n+                    ContextKind::Drop.new(location),\n+                    drop_place,\n+                    (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n+                    LocalMutationIsAllowed::Yes,\n+                );\n             }\n             TerminatorKind::DropAndReplace {\n                 location: ref drop_place,\n@@ -286,83 +276,13 @@ impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tc\n     }\n }\n \n-impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n-    /// Simulates dropping of a variable\n-    fn visit_terminator_drop(\n-        &mut self,\n-        loc: Location,\n-        term: &Terminator<'tcx>,\n-        drop_place: &Place<'tcx>,\n-        erased_drop_place_ty: ty::Ty<'gcx>,\n-    ) {\n-        let gcx = self.infcx.tcx.global_tcx();\n-        let drop_field = |\n-            ig: &mut InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx>,\n-            (index, field): (usize, ty::Ty<'gcx>),\n-        | {\n-            let field_ty = gcx.normalize_erasing_regions(ig.param_env, field);\n-            let place = drop_place.clone().field(Field::new(index), field_ty);\n-\n-            ig.visit_terminator_drop(loc, term, &place, field_ty);\n-        };\n-\n-        match erased_drop_place_ty.sty {\n-            // When a struct is being dropped, we need to check\n-            // whether it has a destructor, if it does, then we can\n-            // call it, if it does not then we need to check the\n-            // individual fields instead. This way if `foo` has a\n-            // destructor but `bar` does not, we will only check for\n-            // borrows of `x.foo` and not `x.bar`. See #47703.\n-            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n-                def.all_fields()\n-                    .map(|field| field.ty(gcx, substs))\n-                    .enumerate()\n-                    .for_each(|field| drop_field(self, field));\n-            }\n-            // Same as above, but for tuples.\n-            ty::Tuple(tys) => {\n-                tys.iter().cloned().enumerate()\n-                    .for_each(|field| drop_field(self, field));\n-            }\n-            // Closures and generators also have disjoint fields, but they are only\n-            // directly accessed in the body of the closure/generator.\n-            ty::Generator(def, substs, ..)\n-                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n-            => {\n-                substs.upvar_tys(def, self.infcx.tcx).enumerate()\n-                    .for_each(|field| drop_field(self, field));\n-            }\n-            ty::Closure(def, substs)\n-                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n-                => {\n-                    substs.upvar_tys(def, self.infcx.tcx).enumerate()\n-                        .for_each(|field| drop_field(self, field));\n-                }\n-            _ => {\n-                // We have now refined the type of the value being\n-                // dropped (potentially) to just the type of a\n-                // subfield; so check whether that field's type still\n-                // \"needs drop\". If so, we assume that the destructor\n-                // may access any data it likes (i.e., a Deep Write).\n-                if erased_drop_place_ty.needs_drop(gcx, self.param_env) {\n-                    self.access_place(\n-                        ContextKind::Drop.new(loc),\n-                        drop_place,\n-                        (Deep, Write(WriteKind::StorageDeadOrDrop(\n-                            StorageDeadOrDrop::Destructor))),\n-                        LocalMutationIsAllowed::Yes,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n+impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     /// Simulates mutation of a place\n     fn mutate_place(\n         &mut self,\n         context: Context,\n         place: &Place<'tcx>,\n-        kind: ShallowOrDeep,\n+        kind: AccessDepth,\n         _mode: MutateMode,\n     ) {\n         self.access_place(\n@@ -412,7 +332,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut { .. } => {\n                         let wk = WriteKind::MutableBorrow(bk);\n-                        if allow_two_phase_borrow(&self.infcx.tcx, bk) {\n+                        if allow_two_phase_borrow(&self.tcx, bk) {\n                             (Deep, Reservation(wk))\n                         } else {\n                             (Deep, Write(wk))\n@@ -471,7 +391,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n         &mut self,\n         context: Context,\n         place: &Place<'tcx>,\n-        kind: (ShallowOrDeep, ReadOrWrite),\n+        kind: (AccessDepth, ReadOrWrite),\n         _is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) {\n         let (sd, rw) = kind;\n@@ -483,7 +403,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n         &mut self,\n         context: Context,\n         place: &Place<'tcx>,\n-        sd: ShallowOrDeep,\n+        sd: AccessDepth,\n         rw: ReadOrWrite,\n     ) {\n         debug!(\n@@ -494,7 +414,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n             sd,\n             rw,\n         );\n-        let tcx = self.infcx.tcx;\n+        let tcx = self.tcx;\n         let mir = self.mir;\n         let borrow_set = self.borrow_set.clone();\n         let indices = self.borrow_set.borrows.indices();\n@@ -527,7 +447,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n                         // Reading from mere reservations of mutable-borrows is OK.\n                         if !is_active(&this.dominators, borrow, context.loc) {\n                             // If the borrow isn't active yet, reads don't invalidate it\n-                            assert!(allow_two_phase_borrow(&this.infcx.tcx, borrow.kind));\n+                            assert!(allow_two_phase_borrow(&this.tcx, borrow.kind));\n                             return Control::Continue;\n                         }\n "}, {"sha": "b9f22c7402a07eb42f3793fd7fe516ca82593280", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -160,11 +160,10 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n \n     // Generate various additional constraints.\n     invalidation::generate_invalidates(\n-        infcx,\n+        infcx.tcx,\n         &mut all_facts,\n         location_table,\n         &mir,\n-        def_id,\n         borrow_set,\n     );\n "}, {"sha": "67787d23db692c5d86336545d14b3ad481d78843", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -11,7 +11,7 @@\n use borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseActivation};\n use borrow_check::places_conflict;\n use borrow_check::Context;\n-use borrow_check::ShallowOrDeep;\n+use borrow_check::AccessDepth;\n use dataflow::indexes::BorrowIndex;\n use rustc::mir::{BasicBlock, Location, Mir, Place};\n use rustc::mir::{ProjectionElem, BorrowKind};\n@@ -43,7 +43,7 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     _context: Context,\n-    access_place: (ShallowOrDeep, &Place<'tcx>),\n+    access_place: (AccessDepth, &Place<'tcx>),\n     borrow_set: &BorrowSet<'tcx>,\n     candidates: I,\n     mut op: F,"}, {"sha": "e371b34c4800c344a2b7156db7a96cab3268d52c", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -10,7 +10,7 @@\n \n use borrow_check::ArtificialField;\n use borrow_check::Overlap;\n-use borrow_check::{Deep, Shallow, ShallowOrDeep};\n+use borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n use rustc::mir::{Mir, Place};\n use rustc::mir::{Projection, ProjectionElem};\n@@ -22,7 +22,7 @@ pub(super) fn places_conflict<'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     borrow_place: &Place<'tcx>,\n     access_place: &Place<'tcx>,\n-    access: ShallowOrDeep,\n+    access: AccessDepth,\n ) -> bool {\n     debug!(\n         \"places_conflict({:?},{:?},{:?})\",\n@@ -49,7 +49,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     mut borrow_components: PlaceComponentsIter<'_, 'tcx>,\n     mut access_components: PlaceComponentsIter<'_, 'tcx>,\n-    access: ShallowOrDeep,\n+    access: AccessDepth,\n ) -> bool {\n     // The borrowck rules for proving disjointness are applied from the \"root\" of the\n     // borrow forwards, iterating over \"similar\" projections in lockstep until\n@@ -179,16 +179,26 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         return false;\n                     }\n                     (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n-                        // the borrow goes through a dereference of a shared reference.\n-                        //\n-                        // I'm not sure why we are tracking these borrows - shared\n-                        // references can *always* be aliased, which means the\n-                        // permission check already account for this borrow.\n-                        debug!(\"places_conflict: behind a shared ref\");\n+                        // Shouldn't be tracked\n+                        bug!(\"Tracking borrow behind shared reference.\");\n+                    }\n+                    (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n+                        // Values behind a mutatble reference are not access either by Dropping a\n+                        // value, or by StorageDead\n+                        debug!(\"places_conflict: drop access behind ptr\");\n                         return false;\n                     }\n \n+                    (ProjectionElem::Field { .. }, ty::Adt(def, _), AccessDepth::Drop) => {\n+                        // Drop can read/write arbitrary projections, so places\n+                        // conflict regardless of further projections.\n+                        if def.has_dtor(tcx) {\n+                            return true;\n+                        }\n+                    }\n+\n                     (ProjectionElem::Deref, _, Deep)\n+                    | (ProjectionElem::Deref, _, AccessDepth::Drop)\n                     | (ProjectionElem::Field { .. }, _, _)\n                     | (ProjectionElem::Index { .. }, _, _)\n                     | (ProjectionElem::ConstantIndex { .. }, _, _)"}, {"sha": "ffb322b85dc34232d46ced6e0748bc4de5db078d", "filename": "src/test/ui/dropck/dropck-union.nll.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fdropck%2Fdropck-union.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fdropck%2Fdropck-union.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-union.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -8,8 +8,6 @@ LL | }\n    | |\n    | `v` dropped here while still borrowed\n    | borrow later used here, when `v` is dropped\n-   |\n-   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "ef7e64ffd97ae251494a68b10e5b8548955c115b", "filename": "src/test/ui/generator/dropck.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | `*cell` dropped here while still borrowed\n    | borrow later used here, when `gen` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `ref_` does not live long enough\n   --> $DIR/dropck.rs:22:11"}, {"sha": "5c753817e358d2cab177bd83a664f59ab9cfed0e", "filename": "src/test/ui/issues/issue-45696-scribble-on-boxed-borrow.migrate.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -23,7 +23,7 @@ LL |     &mut *(*s).0 //[nll]~ ERROR borrow may still be in use when destructor\n    |     ^^^^^^^^^^^^\n ...\n LL | }\n-   | - here, drop of `*s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n+   | - here, drop of `s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 72:20...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:72:20\n@@ -41,7 +41,7 @@ LL |     &mut *(**s).0 //[nll]~ ERROR borrow may still be in use when destructor\n    |     ^^^^^^^^^^^^^\n ...\n LL | }\n-   | - here, drop of `**s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n+   | - here, drop of `s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 82:26...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:82:26"}, {"sha": "79a7c0631f4804ffca17f6cd553b4858b2ff0781", "filename": "src/test/ui/issues/issue-45696-scribble-on-boxed-borrow.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -20,7 +20,7 @@ LL |     &mut *(*s).0 //[nll]~ ERROR borrow may still be in use when destructor\n    |     ^^^^^^^^^^^^\n ...\n LL | }\n-   | - here, drop of `*s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n+   | - here, drop of `s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 72:20...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:72:20\n@@ -35,7 +35,7 @@ LL |     &mut *(**s).0 //[nll]~ ERROR borrow may still be in use when destructor\n    |     ^^^^^^^^^^^^^\n ...\n LL | }\n-   | - here, drop of `**s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n+   | - here, drop of `s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 82:26...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:82:26"}, {"sha": "dc436d20fd85736c20a4fcaa325fec069261618c", "filename": "src/test/ui/nll/enum-drop-access.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fnll%2Fenum-drop-access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fnll%2Fenum-drop-access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fenum-drop-access.rs?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -0,0 +1,51 @@\n+#![feature(nll)]\n+\n+enum DropOption<T> {\n+    Some(T),\n+    None,\n+}\n+\n+impl<T> Drop for DropOption<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+// Dropping opt could access the value behind the reference,\n+fn drop_enum(opt: DropOption<&mut i32>) -> Option<&mut i32> {\n+    match opt {\n+        DropOption::Some(&mut ref mut r) => { //~ ERROR\n+            Some(r)\n+        },\n+        DropOption::None => None,\n+    }\n+}\n+\n+fn optional_drop_enum(opt: Option<DropOption<&mut i32>>) -> Option<&mut i32> {\n+    match opt {\n+        Some(DropOption::Some(&mut ref mut r)) => { //~ ERROR\n+            Some(r)\n+        },\n+        Some(DropOption::None) | None => None,\n+    }\n+}\n+\n+// Ok, dropping opt doesn't access the reference\n+fn optional_tuple(opt: Option<(&mut i32, String)>) -> Option<&mut i32> {\n+    match opt {\n+        Some((&mut ref mut r, _)) => {\n+            Some(r)\n+        },\n+        None => None,\n+    }\n+}\n+\n+// Ok, dropping res doesn't access the Ok case.\n+fn different_variants(res: Result<&mut i32, String>) -> Option<&mut i32> {\n+    match res {\n+        Ok(&mut ref mut r) => {\n+            Some(r)\n+        },\n+        Err(_) => None,\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "57daf26596dfb55830b0a8fa948418f52e369b8f", "filename": "src/test/ui/nll/enum-drop-access.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fnll%2Fenum-drop-access.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fnll%2Fenum-drop-access.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fenum-drop-access.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -0,0 +1,45 @@\n+error[E0713]: borrow may still be in use when destructor runs\n+  --> $DIR/enum-drop-access.rs:15:31\n+   |\n+LL |         DropOption::Some(&mut ref mut r) => { //~ ERROR\n+   |                               ^^^^^^^^^\n+...\n+LL | }\n+   | - here, drop of `opt` needs exclusive access to `*opt.0`, because the type `DropOption<&mut i32>` implements the `Drop` trait\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...\n+  --> $DIR/enum-drop-access.rs:13:1\n+   |\n+LL | / fn drop_enum(opt: DropOption<&mut i32>) -> Option<&mut i32> {\n+LL | |     match opt {\n+LL | |         DropOption::Some(&mut ref mut r) => { //~ ERROR\n+LL | |             Some(r)\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0713]: borrow may still be in use when destructor runs\n+  --> $DIR/enum-drop-access.rs:24:36\n+   |\n+LL |         Some(DropOption::Some(&mut ref mut r)) => { //~ ERROR\n+   |                                    ^^^^^^^^^\n+...\n+LL | }\n+   | - here, drop of `opt` needs exclusive access to `*opt.0.0`, because the type `DropOption<&mut i32>` implements the `Drop` trait\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 22:1...\n+  --> $DIR/enum-drop-access.rs:22:1\n+   |\n+LL | / fn optional_drop_enum(opt: Option<DropOption<&mut i32>>) -> Option<&mut i32> {\n+LL | |     match opt {\n+LL | |         Some(DropOption::Some(&mut ref mut r)) => { //~ ERROR\n+LL | |             Some(r)\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0713`."}, {"sha": "c565842c2c0020e5ad0ecd9b50b09e1289d53000", "filename": "src/test/ui/span/borrowck-ref-into-rvalue.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -1,16 +1,16 @@\n-error[E0713]: borrow may still be in use when destructor runs\n-  --> $DIR/borrowck-ref-into-rvalue.rs:14:14\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/borrowck-ref-into-rvalue.rs:13:11\n    |\n-LL |         Some(ref m) => {\n-   |              ^^^^^\n+LL |     match Some(\"Hello\".to_string()) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n ...\n LL |     }\n-   |     - drop of temporary value occurs here\n+   |     - temporary value only lives until here\n LL |     println!(\"{}\", *msg);\n    |                    ---- borrow later used here\n    |\n    = note: consider using a `let` binding to create a longer lived value\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0713`.\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "74db695e7e5609bc1251cf74527bb8e0e55009f7", "filename": "src/test/ui/span/dropck_arr_cycle_checked.nll.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | `b2` dropped here while still borrowed\n    | borrow later used here, when `b1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `b3` does not live long enough\n   --> $DIR/dropck_arr_cycle_checked.rs:105:24\n@@ -21,6 +23,8 @@ LL | }\n    | |\n    | `b3` dropped here while still borrowed\n    | borrow later used here, when `b1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `b1` does not live long enough\n   --> $DIR/dropck_arr_cycle_checked.rs:111:24"}, {"sha": "baf3cef2ae83c84a211c1da1b6614c715ac2e579", "filename": "src/test/ui/span/dropck_direct_cycle_with_drop.nll.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fdropck_direct_cycle_with_drop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fdropck_direct_cycle_with_drop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_direct_cycle_with_drop.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -23,8 +23,6 @@ LL | }\n    | |\n    | `d1` dropped here while still borrowed\n    | borrow later used here, when `d1` is dropped\n-   |\n-   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f7ff4e5169fd45e20cd7cfbfb3353fe6bd045762", "filename": "src/test/ui/span/dropck_vec_cycle_checked.nll.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | `c2` dropped here while still borrowed\n    | borrow later used here, when `c1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `c3` does not live long enough\n   --> $DIR/dropck_vec_cycle_checked.rs:115:24\n@@ -21,6 +23,8 @@ LL | }\n    | |\n    | `c3` dropped here while still borrowed\n    | borrow later used here, when `c1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `c1` does not live long enough\n   --> $DIR/dropck_vec_cycle_checked.rs:121:24"}, {"sha": "a1451866e677ca319378464196f9abf9d3a2e2aa", "filename": "src/test/ui/span/issue-29106.nll.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fissue-29106.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fissue-29106.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-29106.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -8,6 +8,8 @@ LL |     }\n    |     |\n    |     `x` dropped here while still borrowed\n    |     borrow later used here, when `y` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `x` does not live long enough\n   --> $DIR/issue-29106.rs:33:25\n@@ -19,6 +21,8 @@ LL |     }\n    |     |\n    |     `x` dropped here while still borrowed\n    |     borrow later used here, when `y` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0f6f6e381d801e681e826be0f7d6fa3c6c9887c3", "filename": "src/test/ui/span/issue28498-reject-ex1.nll.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-ex1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-ex1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-ex1.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -11,7 +11,6 @@ LL | }\n    | borrow later used here, when `foo` is dropped\n    |\n    = note: consider using a `let` binding to create a longer lived value\n-   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "292c007f5122518c24ad41cc1f0a42a77c722382", "filename": "src/test/ui/span/vec-must-not-hide-type-from-dropck.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fvec-must-not-hide-type-from-dropck.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Fspan%2Fvec-must-not-hide-type-from-dropck.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvec-must-not-hide-type-from-dropck.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | `c2` dropped here while still borrowed\n    | borrow later used here, when `c1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `c1` does not live long enough\n   --> $DIR/vec-must-not-hide-type-from-dropck.rs:129:24"}, {"sha": "afd90237d16aee165d1c1b21092908bce203d592", "filename": "src/test/ui/unboxed-closures/unboxed-closures-failed-recursive-fn-1.nll.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a072d1bca6282d1d2fbec103d12393527eb5a868/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-1.nll.stderr?ref=a072d1bca6282d1d2fbec103d12393527eb5a868", "patch": "@@ -11,8 +11,6 @@ LL | }\n    | |\n    | `factorial` dropped here while still borrowed\n    | borrow later used here, when `factorial` is dropped\n-   |\n-   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0506]: cannot assign to `factorial` because it is borrowed\n   --> $DIR/unboxed-closures-failed-recursive-fn-1.rs:30:5"}]}