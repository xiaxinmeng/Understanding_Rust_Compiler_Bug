{"sha": "43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYjI0YzZjODNhY2JkN2VmNjNhOTdjZjQ1YjFhNjIyZDJjZDYxYjA=", "commit": {"author": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-04-18T22:47:07Z"}, "committer": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-04-20T00:31:45Z"}, "message": "Pass the right type to box_free() in MIR\n\nCurrently, MIR just passes the raw Box to box_free(), which happens to\nwork because practically, it's the same thing. But that might not be\ntrue in the future, with Box<T, A: Alloc>.\n\nThe MIR inline pass actually fixes up the argument while inlining\nbox_free, but this is not enabled by default and doesn't necessarily\nhappen (the inline threshold needs to be passed).\n\nThis change effectively moves what the MIR inline pass does to the\nelaborate_drops pass, so that box_free() is passed the raw pointer\ninstead of the Box.", "tree": {"sha": "93ef599e9a6e3db6d73a4acd6e3140d59ed41f88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93ef599e9a6e3db6d73a4acd6e3140d59ed41f88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0", "html_url": "https://github.com/rust-lang/rust/commit/43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0/comments", "author": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8830a0304327ba8c983555ac5d42cec0569c31bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8830a0304327ba8c983555ac5d42cec0569c31bb", "html_url": "https://github.com/rust-lang/rust/commit/8830a0304327ba8c983555ac5d42cec0569c31bb"}], "stats": {"total": 104, "additions": 34, "deletions": 70}, "files": [{"sha": "b81bb5c81ca1e23febcd9a4c7329cb9c8b708317", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 63, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0", "patch": "@@ -379,8 +379,6 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n                 debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n \n-                let is_box_free = Some(callsite.callee) == self.tcx.lang_items().box_free_fn();\n-\n                 let mut local_map = IndexVec::with_capacity(callee_mir.local_decls.len());\n                 let mut scope_map = IndexVec::with_capacity(callee_mir.visibility_scopes.len());\n                 let mut promoted_map = IndexVec::with_capacity(callee_mir.promoted.len());\n@@ -460,24 +458,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 let return_block = destination.1;\n \n-                let args : Vec<_> = if is_box_free {\n-                    assert!(args.len() == 1);\n-                    // box_free takes a Box, but is defined with a *mut T, inlining\n-                    // needs to generate the cast.\n-                    // FIXME: we should probably just generate correct MIR in the first place...\n-\n-                    let arg = if let Operand::Move(ref place) = args[0] {\n-                        place.clone()\n-                    } else {\n-                        bug!(\"Constant arg to \\\"box_free\\\"\");\n-                    };\n-\n-                    let ptr_ty = args[0].ty(caller_mir, self.tcx);\n-                    vec![self.cast_box_free_arg(arg, ptr_ty, &callsite, caller_mir)]\n-                } else {\n-                    // Copy the arguments if needed.\n-                    self.make_call_args(args, &callsite, caller_mir)\n-                };\n+                // Copy the arguments if needed.\n+                let args: Vec<_> = self.make_call_args(args, &callsite, caller_mir);\n \n                 let bb_len = caller_mir.basic_blocks().len();\n                 let mut integrator = Integrator {\n@@ -518,49 +500,6 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n-    fn cast_box_free_arg(&self, arg: Place<'tcx>, ptr_ty: Ty<'tcx>,\n-                         callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Local {\n-        let arg = Rvalue::Ref(\n-            self.tcx.types.re_erased,\n-            BorrowKind::Mut { allow_two_phase_borrow: false },\n-            arg.deref());\n-\n-        let ty = arg.ty(caller_mir, self.tcx);\n-        let ref_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n-        let ref_tmp = caller_mir.local_decls.push(ref_tmp);\n-        let ref_tmp = Place::Local(ref_tmp);\n-\n-        let ref_stmt = Statement {\n-            source_info: callsite.location,\n-            kind: StatementKind::Assign(ref_tmp.clone(), arg)\n-        };\n-\n-        caller_mir[callsite.bb]\n-            .statements.push(ref_stmt);\n-\n-        let pointee_ty = match ptr_ty.sty {\n-            ty::TyRawPtr(tm) | ty::TyRef(_, tm) => tm.ty,\n-            _ if ptr_ty.is_box() => ptr_ty.boxed_ty(),\n-            _ => bug!(\"Invalid type `{:?}` for call to box_free\", ptr_ty)\n-        };\n-        let ptr_ty = self.tcx.mk_mut_ptr(pointee_ty);\n-\n-        let raw_ptr = Rvalue::Cast(CastKind::Misc, Operand::Move(ref_tmp), ptr_ty);\n-\n-        let cast_tmp = LocalDecl::new_temp(ptr_ty, callsite.location.span);\n-        let cast_tmp = caller_mir.local_decls.push(cast_tmp);\n-\n-        let cast_stmt = Statement {\n-            source_info: callsite.location,\n-            kind: StatementKind::Assign(Place::Local(cast_tmp), raw_ptr)\n-        };\n-\n-        caller_mir[callsite.bb]\n-            .statements.push(cast_stmt);\n-\n-        cast_tmp\n-    }\n-\n     fn make_call_args(\n         &self,\n         args: Vec<Operand<'tcx>>,"}, {"sha": "1564db1ee2a51c0a30a34879851c3effa3ae926d", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=43b24c6c83acbd7ef63a97cf45b1a622d2cd61b0", "patch": "@@ -876,14 +876,39 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n+        let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n+            ty: ty,\n+            mutbl: hir::Mutability::MutMutable\n+        });\n+        let ptr_ty = tcx.mk_mut_ptr(ty);\n+        let ref_tmp = Place::Local(self.new_temp(ref_ty));\n+        let ptr_tmp = Place::Local(self.new_temp(ptr_ty));\n \n-        let call = TerminatorKind::Call {\n-            func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n-            args: vec![Operand::Move(self.place.clone())],\n-            destination: Some((unit_temp, target)),\n-            cleanup: None\n-        }; // FIXME(#43234)\n-        let free_block = self.new_block(unwind, call);\n+        let free_block = BasicBlockData {\n+            statements: vec![\n+                self.assign(&ref_tmp, Rvalue::Ref(\n+                    tcx.types.re_erased,\n+                    BorrowKind::Mut { allow_two_phase_borrow: false },\n+                    self.place.clone().deref()\n+                )),\n+                self.assign(&ptr_tmp, Rvalue::Cast(\n+                    CastKind::Misc,\n+                    Operand::Move(ref_tmp),\n+                    ptr_ty,\n+                )),\n+            ],\n+            terminator: Some(Terminator {\n+                kind: TerminatorKind::Call {\n+                    func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n+                    args: vec![Operand::Move(ptr_tmp)],\n+                    destination: Some((unit_temp, target)),\n+                    cleanup: None\n+                }, // FIXME(#43234)\n+                source_info: self.source_info,\n+            }),\n+            is_cleanup: unwind.is_cleanup()\n+        };\n+        let free_block = self.elaborator.patch().new_block(free_block);\n \n         let block_start = Location { block: free_block, statement_index: 0 };\n         self.elaborator.clear_drop_flag(block_start, self.path, DropFlagMode::Shallow);"}]}