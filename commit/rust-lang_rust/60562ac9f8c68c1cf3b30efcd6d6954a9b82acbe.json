{"sha": "60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNTYyYWM5ZjhjNjhjMWNmM2IzMGVmY2Q2ZDY5NTRhOWI4MmFjYmU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-07-12T05:58:14Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:12Z"}, "message": "whitespace, reindentation, and comments only", "tree": {"sha": "e9ee19f59738dd6ada11f5ebe50218984a51abd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9ee19f59738dd6ada11f5ebe50218984a51abd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "html_url": "https://github.com/rust-lang/rust/commit/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec0a64def54e0b381ede187bfe199b7620b56c45", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec0a64def54e0b381ede187bfe199b7620b56c45", "html_url": "https://github.com/rust-lang/rust/commit/ec0a64def54e0b381ede187bfe199b7620b56c45"}], "stats": {"total": 69, "additions": 42, "deletions": 27}, "files": [{"sha": "9e281172b26114dd6ce3739d65d706ea9db9c979", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "patch": "@@ -2787,7 +2787,8 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n \n pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'static str, ValueRef>) {\n     ifn!(intrinsics, \"llvm.dbg.declare\", [Type::metadata(), Type::metadata()], Type::void());\n-    ifn!(intrinsics, \"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n+    ifn!(intrinsics,\n+         \"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n }\n \n pub fn trap(bcx: @mut Block) {"}, {"sha": "819d390ac28b09ac6997cd5633ee2ebfdb39604a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "patch": "@@ -1176,8 +1176,9 @@ fn trans_rec_or_struct(bcx: @mut Block,\n         let mut need_base = vec::from_elem(field_tys.len(), true);\n \n         let numbered_fields = do fields.map |field| {\n-            let opt_pos = field_tys.iter().position(|field_ty|\n-                                                    field_ty.ident.name == field.ident.name);\n+            let opt_pos =\n+                field_tys.iter().position(|field_ty|\n+                                          field_ty.ident.name == field.ident.name);\n             match opt_pos {\n                 Some(i) => {\n                     need_base[i] = false;"}, {"sha": "6a4b2ade9315106254cbc3a57460751cb0e5c521", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "patch": "@@ -51,6 +51,12 @@ impl Ident {\n         if (self.ctxt == other.ctxt) {\n             self.name == other.name\n         } else {\n+            // IF YOU SEE ONE OF THESE FAILS: it means that you're comparing\n+            // idents that have different contexts. You can't fix this without\n+            // knowing whether the comparison should be hygienic or non-hygienic.\n+            // if it should be non-hygienic (most things are), just compare the\n+            // 'name' fields of the idents. Or, even better, replace the idents\n+            // with Name's.\n             fail!(fmt!(\"not allowed to compare these idents: %?, %?\", self, other));\n         }\n     }\n@@ -128,6 +134,7 @@ pub type FnIdent = Option<Ident>;\n pub struct Lifetime {\n     id: NodeId,\n     span: Span,\n+    // FIXME #7743 : change this to Name!\n     ident: Ident\n }\n \n@@ -647,7 +654,6 @@ pub enum matcher_ {\n     // lo, hi position-in-match-array used:\n     match_seq(~[matcher], Option<::parse::token::Token>, bool, uint, uint),\n     // parse a Rust NT: name to bind, name of NT, position in match array:\n-    // NOTE: 'name of NT' shouldnt really be represented as an ident, should it?\n     match_nonterminal(Ident, Ident, uint)\n }\n "}, {"sha": "57a0e12ec2ffc1ce690cbfc1504550aa4cac9c34", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "patch": "@@ -948,11 +948,14 @@ pub fn resolve_internal(id : Ident,\n                 match table.table[id.ctxt] {\n                     EmptyCtxt => id.name,\n                     // ignore marks here:\n-                    Mark(_,subctxt) => resolve_internal(Ident{name:id.name, ctxt: subctxt},table,resolve_table),\n+                    Mark(_,subctxt) =>\n+                        resolve_internal(Ident{name:id.name, ctxt: subctxt},table,resolve_table),\n                     // do the rename if necessary:\n                     Rename(Ident{name,ctxt},toname,subctxt) => {\n-                        let resolvedfrom = resolve_internal(Ident{name:name,ctxt:ctxt},table,resolve_table);\n-                        let resolvedthis = resolve_internal(Ident{name:id.name,ctxt:subctxt},table,resolve_table);\n+                        let resolvedfrom =\n+                            resolve_internal(Ident{name:name,ctxt:ctxt},table,resolve_table);\n+                        let resolvedthis =\n+                            resolve_internal(Ident{name:id.name,ctxt:subctxt},table,resolve_table);\n                         if ((resolvedthis == resolvedfrom)\n                             && (marksof(ctxt,resolvedthis,table)\n                                 == marksof(subctxt,resolvedthis,table))) {\n@@ -1034,8 +1037,9 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n     } else {\n         for (idx,seg) in a.iter().enumerate() {\n             if (seg.identifier.name != b[idx].identifier.name)\n-                // ident -> name problems in lifetime comparison?\n+                // FIXME #7743: ident -> name problems in lifetime comparison?\n                 || (seg.lifetime != b[idx].lifetime)\n+                // can types contain idents?\n                 || (seg.types != b[idx].types) {\n                 return false;\n             }"}, {"sha": "8ee045ba8c12b6641c9b3792a39e22b306ab8142", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "patch": "@@ -76,19 +76,20 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             // mark before:\n                             let marked_before = mark_tts(*tts,fm);\n                             let marked_ctxt = new_mark(fm, ctxt);\n-                            let expanded = match expandfun(cx, mac.span, marked_before, marked_ctxt) {\n-                                MRExpr(e) => e,\n-                                MRAny(expr_maker,_,_) => expr_maker(),\n-                                _ => {\n-                                    cx.span_fatal(\n-                                        pth.span,\n-                                        fmt!(\n-                                            \"non-expr macro in expr pos: %s\",\n-                                            extnamestr\n+                            let expanded =\n+                                match expandfun(cx, mac.span, marked_before, marked_ctxt) {\n+                                    MRExpr(e) => e,\n+                                    MRAny(expr_maker,_,_) => expr_maker(),\n+                                    _ => {\n+                                        cx.span_fatal(\n+                                            pth.span,\n+                                            fmt!(\n+                                                \"non-expr macro in expr pos: %s\",\n+                                                extnamestr\n+                                            )\n                                         )\n-                                    )\n-                                }\n-                            };\n+                                    }\n+                                };\n                             // mark after:\n                             let marked_after = mark_expr(expanded,fm);\n \n@@ -1735,12 +1736,14 @@ mod test {\n                  ~[~[0]])\n                 // FIXME #6994: the next string exposes the bug referred to in issue 6994, so I'm\n                 // commenting it out.\n-                // the z flows into and out of two macros (g & f) along one path, and one (just g) along the\n-                // other, so the result of the whole thing should be \"let z_123 = 3; z_123\"\n-                //\"macro_rules! g (($x:ident) => ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}))\n+                // the z flows into and out of two macros (g & f) along one path, and one\n+                // (just g) along the other, so the result of the whole thing should\n+                // be \"let z_123 = 3; z_123\"\n+                //\"macro_rules! g (($x:ident) =>\n+                //   ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}))\n                 //   fn a(){g!(z)}\"\n-                // create a really evil test case where a $x appears inside a binding of $x but *shouldnt*\n-                // bind because it was inserted by a different macro....\n+                // create a really evil test case where a $x appears inside a binding of $x\n+                // but *shouldnt* bind because it was inserted by a different macro....\n             ];\n         for s in tests.iter() {\n             run_renaming_test(s);\n@@ -1820,7 +1823,8 @@ mod test {\n         // find the ext_cx binding\n         let bindings = @mut ~[];\n         visit::walk_crate(&mut new_name_finder(bindings), crate, ());\n-        let cxbinds : ~[&ast::Ident] = bindings.iter().filter(|b|{@\"ext_cx\" == (ident_to_str(*b))}).collect();\n+        let cxbinds : ~[&ast::Ident] =\n+            bindings.iter().filter(|b|{@\"ext_cx\" == (ident_to_str(*b))}).collect();\n         let cxbind = match cxbinds {\n             [b] => b,\n             _ => fail!(\"expected just one binding for ext_cx\")"}, {"sha": "4b0974b70bf2b3dfcc0a7d65b8203525edd12215", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=60562ac9f8c68c1cf3b30efcd6d6954a9b82acbe", "patch": "@@ -49,7 +49,6 @@ pub fn add_new_extension(cx: @ExtCtxt,\n     // ...quasiquoting this would be nice.\n     let argument_gram = ~[\n         ms(match_seq(~[\n-            // NOTE : probably just use an enum for the NT_name ?\n             ms(match_nonterminal(lhs_nm, special_idents::matchers, 0u)),\n             ms(match_tok(FAT_ARROW)),\n             ms(match_nonterminal(rhs_nm, special_idents::tt, 1u)),"}]}