{"sha": "9ea1544b804818c8df259de60c0e26a85ac52850", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYTE1NDRiODA0ODE4YzhkZjI1OWRlNjBjMGUyNmE4NWFjNTI4NTA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-11-23T00:35:07Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-11-23T00:35:07Z"}, "message": "Add a test", "tree": {"sha": "e361848f539647dbd024dad20d8804a0bd2eb1d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e361848f539647dbd024dad20d8804a0bd2eb1d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ea1544b804818c8df259de60c0e26a85ac52850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea1544b804818c8df259de60c0e26a85ac52850", "html_url": "https://github.com/rust-lang/rust/commit/9ea1544b804818c8df259de60c0e26a85ac52850", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ea1544b804818c8df259de60c0e26a85ac52850/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3295afa6e2dd9d3b50bce0342199a7d448d480aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3295afa6e2dd9d3b50bce0342199a7d448d480aa", "html_url": "https://github.com/rust-lang/rust/commit/3295afa6e2dd9d3b50bce0342199a7d448d480aa"}], "stats": {"total": 541, "additions": 541, "deletions": 0}, "files": [{"sha": "3711b6ea8959b7548bd3c5b5134a2dee4e6004fd", "filename": "src/test/run-make/save-analysis-fail/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FMakefile?ref=9ea1544b804818c8df259de60c0e26a85ac52850", "patch": "@@ -0,0 +1,8 @@\n+-include ../tools.mk\n+all: code\n+krate2: krate2.rs\n+\t$(RUSTC) $<\n+code: foo.rs krate2\n+\t$(RUSTC) foo.rs -Zsave-analysis-csv\n+\t$(RUSTC) foo.rs -Zsave-analysis\n+\t$(RUSTC) foo.rs -Zsave-analysis-api"}, {"sha": "fe70ac1edef6e782569e9c14b92c698995d80d0a", "filename": "src/test/run-make/save-analysis-fail/SameDir.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FSameDir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FSameDir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FSameDir.rs?ref=9ea1544b804818c8df259de60c0e26a85ac52850", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// sub-module in the same directory as the main crate file\n+\n+pub struct SameStruct {\n+    pub name: String\n+}"}, {"sha": "315f900868b45443131616e4672f97ed13764c8d", "filename": "src/test/run-make/save-analysis-fail/SameDir3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FSameDir3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FSameDir3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FSameDir3.rs?ref=9ea1544b804818c8df259de60c0e26a85ac52850", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn hello(x: isize) {\n+    println!(\"macro {} :-(\", x);\n+}"}, {"sha": "fe84db08da9008f6af7349f7e4dc98fb16a9d08e", "filename": "src/test/run-make/save-analysis-fail/SubDir/mod.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FSubDir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FSubDir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2FSubDir%2Fmod.rs?ref=9ea1544b804818c8df259de60c0e26a85ac52850", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// sub-module in a sub-directory\n+\n+use sub::sub2 as msalias;\n+use sub::sub2;\n+\n+static yy: usize = 25;\n+\n+mod sub {\n+    pub mod sub2 {\n+        pub mod sub3 {\n+            pub fn hello() {\n+                println!(\"hello from module 3\");\n+            }\n+        }\n+        pub fn hello() {\n+            println!(\"hello from a module\");\n+        }\n+\n+        pub struct nested_struct {\n+            pub field2: u32,\n+        }\n+    }\n+}\n+\n+pub struct SubStruct {\n+    pub name: String\n+}"}, {"sha": "e331f65abb7b3200edb7fb16a5c8c7b55ef95bf5", "filename": "src/test/run-make/save-analysis-fail/foo.rs", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs?ref=9ea1544b804818c8df259de60c0e26a85ac52850", "patch": "@@ -0,0 +1,450 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![ crate_name = \"test\" ]\n+#![feature(box_syntax)]\n+#![feature(rustc_private)]\n+\n+extern crate graphviz;\n+// A simple rust project\n+\n+extern crate krate2;\n+extern crate krate2 as krate3;\n+extern crate flate as myflate;\n+\n+use graphviz::RenderOption;\n+use std::collections::{HashMap,HashSet};\n+use std::cell::RefCell;\n+use std::io::Write;\n+\n+\n+use sub::sub2 as msalias;\n+use sub::sub2;\n+use sub::sub2::nested_struct as sub_struct;\n+\n+use std::mem::size_of;\n+\n+use std::char::from_u32;\n+\n+static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n+static yy: usize = 25;\n+\n+static bob: Option<graphviz::RenderOption> = None;\n+\n+// buglink test - see issue #1337.\n+\n+fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n+    let s = sub_struct{ field2: 45u32, };\n+\n+    // import tests\n+    fn foo(x: &Write) {}\n+    let _: Option<_> = from_u32(45);\n+\n+    let x = 42usize;\n+\n+    krate2::hello();\n+    krate3::hello();\n+    myflate::deflate_bytes(&[]);\n+\n+    let x = (3isize, 4usize);\n+    let y = x.1;\n+}\n+\n+// Issue #37700\n+const LUT_BITS: usize = 3;\n+pub struct HuffmanTable {\n+    ac_lut: Option<[(i16, u8); 1 << LUT_BITS]>,\n+}\n+\n+struct TupStruct(isize, isize, Box<str>);\n+\n+fn test_tup_struct(x: TupStruct) -> isize {\n+    x.1\n+}\n+\n+fn println(s: &str) {\n+    std::io::stdout().write_all(s.as_bytes());\n+}\n+\n+mod sub {\n+    pub mod sub2 {\n+        use std::io::Write;\n+        pub mod sub3 {\n+            use std::io::Write;\n+            pub fn hello() {\n+                ::println(\"hello from module 3\");\n+            }\n+        }\n+        pub fn hello() {\n+            ::println(\"hello from a module\");\n+        }\n+\n+        pub struct nested_struct {\n+            pub field2: u32,\n+        }\n+\n+        pub enum nested_enum {\n+            Nest2 = 2,\n+            Nest3 = 3\n+        }\n+    }\n+}\n+\n+pub mod SameDir;\n+pub mod SubDir;\n+\n+#[path = \"SameDir3.rs\"]\n+pub mod SameDir2;\n+\n+struct nofields;\n+\n+#[derive(Clone)]\n+struct some_fields {\n+    field1: u32,\n+}\n+\n+type SF = some_fields;\n+\n+trait SuperTrait {\n+    fn qux(&self) { panic!(); }\n+}\n+\n+trait SomeTrait: SuperTrait {\n+    fn Method(&self, x: u32) -> u32;\n+\n+    fn prov(&self, x: u32) -> u32 {\n+        println(&x.to_string());\n+        42\n+    }\n+    fn provided_method(&self) -> u32 {\n+        42\n+    }\n+}\n+\n+trait SubTrait: SomeTrait {\n+    fn stat2(x: &Self) -> u32 {\n+        32\n+    }\n+}\n+\n+trait SizedTrait: Sized {}\n+\n+fn error(s: &SizedTrait) {\n+    let foo = 42;\n+    println!(\"Hello world! {}\", foo);\n+}\n+\n+impl SomeTrait for some_fields {\n+    fn Method(&self, x: u32) -> u32 {\n+        println(&x.to_string());\n+        self.field1\n+    }\n+}\n+\n+impl SuperTrait for some_fields {\n+}\n+\n+impl SubTrait for some_fields {}\n+\n+impl some_fields {\n+    fn stat(x: u32) -> u32 {\n+        println(&x.to_string());\n+        42\n+    }\n+    fn stat2(x: &some_fields) -> u32 {\n+        42\n+    }\n+\n+    fn align_to<T>(&mut self) {\n+\n+    }\n+\n+    fn test(&mut self) {\n+        self.align_to::<bool>();\n+    }\n+}\n+\n+impl SuperTrait for nofields {\n+}\n+impl SomeTrait for nofields {\n+    fn Method(&self, x: u32) -> u32 {\n+        self.Method(x);\n+        43\n+    }\n+\n+    fn provided_method(&self) -> u32 {\n+        21\n+    }\n+}\n+\n+impl SubTrait for nofields {}\n+\n+impl SuperTrait for (Box<nofields>, Box<some_fields>) {}\n+\n+fn f_with_params<T: SomeTrait>(x: &T) {\n+    x.Method(41);\n+}\n+\n+type MyType = Box<some_fields>;\n+\n+enum SomeEnum<'a> {\n+    Ints(isize, isize),\n+    Floats(f64, f64),\n+    Strings(&'a str, &'a str, &'a str),\n+    MyTypes(MyType, MyType)\n+}\n+\n+#[derive(Copy, Clone)]\n+enum SomeOtherEnum {\n+    SomeConst1,\n+    SomeConst2,\n+    SomeConst3\n+}\n+\n+enum SomeStructEnum {\n+    EnumStruct{a:isize, b:isize},\n+    EnumStruct2{f1:MyType, f2:MyType},\n+    EnumStruct3{f1:MyType, f2:MyType, f3:SomeEnum<'static>}\n+}\n+\n+fn matchSomeEnum(val: SomeEnum) {\n+    match val {\n+        SomeEnum::Ints(int1, int2) => { println(&(int1+int2).to_string()); }\n+        SomeEnum::Floats(float1, float2) => { println(&(float2*float1).to_string()); }\n+        SomeEnum::Strings(.., s3) => { println(s3); }\n+        SomeEnum::MyTypes(mt1, mt2) => { println(&(mt1.field1 - mt2.field1).to_string()); }\n+    }\n+}\n+\n+fn matchSomeStructEnum(se: SomeStructEnum) {\n+    match se {\n+        SomeStructEnum::EnumStruct{a:a, ..} => println(&a.to_string()),\n+        SomeStructEnum::EnumStruct2{f1:f1, f2:f_2} => println(&f_2.field1.to_string()),\n+        SomeStructEnum::EnumStruct3{f1, ..} => println(&f1.field1.to_string()),\n+    }\n+}\n+\n+\n+fn matchSomeStructEnum2(se: SomeStructEnum) {\n+    use SomeStructEnum::*;\n+    match se {\n+        EnumStruct{a: ref aaa, ..} => println(&aaa.to_string()),\n+        EnumStruct2{f1, f2: f2} => println(&f1.field1.to_string()),\n+        EnumStruct3{f1, f3: SomeEnum::Ints(..), f2} => println(&f1.field1.to_string()),\n+        _ => {},\n+    }\n+}\n+\n+fn matchSomeOtherEnum(val: SomeOtherEnum) {\n+    use SomeOtherEnum::{SomeConst2, SomeConst3};\n+    match val {\n+        SomeOtherEnum::SomeConst1 => { println(\"I'm const1.\"); }\n+        SomeConst2 | SomeConst3 => { println(\"I'm const2 or const3.\"); }\n+    }\n+}\n+\n+fn hello<X: SomeTrait>((z, a) : (u32, String), ex: X) {\n+    SameDir2::hello(43);\n+\n+    println(&yy.to_string());\n+    let (x, y): (u32, u32) = (5, 3);\n+    println(&x.to_string());\n+    println(&z.to_string());\n+    let x: u32 = x;\n+    println(&x.to_string());\n+    let x = \"hello\";\n+    println(x);\n+\n+    let x = 32.0f32;\n+    let _ = (x + ((x * x) + 1.0).sqrt()).ln();\n+\n+    let s: Box<SomeTrait> = box some_fields {field1: 43};\n+    let s2: Box<some_fields> =  box some_fields {field1: 43};\n+    let s3 = box nofields;\n+\n+    s.Method(43);\n+    s3.Method(43);\n+    s2.Method(43);\n+\n+    ex.prov(43);\n+\n+    let y: u32 = 56;\n+    // static method on struct\n+    let r = some_fields::stat(y);\n+    // trait static method, calls default\n+    let r = SubTrait::stat2(&*s3);\n+\n+    let s4 = s3 as Box<SomeTrait>;\n+    s4.Method(43);\n+\n+    s4.provided_method();\n+    s2.prov(45);\n+\n+    let closure = |x: u32, s: &SomeTrait| {\n+        s.Method(23);\n+        return x + y;\n+    };\n+\n+    let z = closure(10, &*s);\n+}\n+\n+pub struct blah {\n+    used_link_args: RefCell<[&'static str; 0]>,\n+}\n+\n+#[macro_use]\n+mod macro_use_test {\n+    macro_rules! test_rec {\n+        (q, $src: expr) => {{\n+            print!(\"{}\", $src);\n+            test_rec!($src);\n+        }};\n+        ($src: expr) => {\n+            print!(\"{}\", $src);\n+        };\n+    }\n+\n+    macro_rules! internal_vars {\n+        ($src: ident) => {{\n+            let mut x = $src;\n+            x += 100;\n+        }};\n+    }\n+}\n+\n+fn main() { // foo\n+    let s = box some_fields {field1: 43};\n+    hello((43, \"a\".to_string()), *s);\n+    sub::sub2::hello();\n+    sub2::sub3::hello();\n+\n+    let h = sub2::sub3::hello;\n+    h();\n+\n+    // utf8 chars\n+    let ut = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n+\n+    // For some reason, this pattern of macro_rules foiled our generated code\n+    // avoiding strategy.\n+    macro_rules! variable_str(($name:expr) => (\n+        some_fields {\n+            field1: $name,\n+        }\n+    ));\n+    let vs = variable_str!(32);\n+\n+    let mut candidates: RefCell<HashMap<&'static str, &'static str>> = RefCell::new(HashMap::new());\n+    let _ = blah {\n+        used_link_args: RefCell::new([]),\n+    };\n+    let s1 = nofields;\n+    let s2 = SF { field1: 55};\n+    let s3: some_fields = some_fields{ field1: 55};\n+    let s4: msalias::nested_struct = sub::sub2::nested_struct{ field2: 55};\n+    let s4: msalias::nested_struct = sub2::nested_struct{ field2: 55};\n+    println(&s2.field1.to_string());\n+    let s5: MyType = box some_fields{ field1: 55};\n+    let s = SameDir::SameStruct{name: \"Bob\".to_string()};\n+    let s = SubDir::SubStruct{name:\"Bob\".to_string()};\n+    let s6: SomeEnum = SomeEnum::MyTypes(box s2.clone(), s5);\n+    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n+    matchSomeEnum(s6);\n+    matchSomeEnum(s7);\n+    let s8: SomeOtherEnum = SomeOtherEnum::SomeConst2;\n+    matchSomeOtherEnum(s8);\n+    let s9: SomeStructEnum = SomeStructEnum::EnumStruct2{ f1: box some_fields{ field1:10 },\n+                                                          f2: box s2 };\n+    matchSomeStructEnum(s9);\n+\n+    for x in &vec![1, 2, 3] {\n+        let _y = x;\n+    }\n+\n+    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n+    if let SomeEnum::Strings(..) = s7 {\n+        println!(\"hello!\");\n+    }\n+\n+    for i in 0..5 {\n+        foo_foo(i);\n+    }\n+\n+    if let Some(x) = None {\n+        foo_foo(x);\n+    }\n+\n+    if false {\n+    } else if let Some(y) = None {\n+        foo_foo(y);\n+    }\n+\n+    while let Some(z) = None {\n+        foo_foo(z);\n+    }\n+\n+    let mut x = 4;\n+    test_rec!(q, \"Hello\");\n+    assert_eq!(x, 4);\n+    internal_vars!(x);\n+}\n+\n+fn foo_foo(_: i32) {}\n+\n+impl Iterator for nofields {\n+    type Item = (usize, usize);\n+\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        panic!()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        panic!()\n+    }\n+}\n+\n+trait Pattern<'a> {\n+    type Searcher;\n+}\n+\n+struct CharEqPattern;\n+\n+impl<'a> Pattern<'a> for CharEqPattern {\n+    type Searcher = CharEqPattern;\n+}\n+\n+struct CharSearcher<'a>(<CharEqPattern as Pattern<'a>>::Searcher);\n+\n+pub trait Error {\n+}\n+\n+impl Error + 'static {\n+    pub fn is<T: Error + 'static>(&self) -> bool {\n+        panic!()\n+    }\n+}\n+\n+impl Error + 'static + Send {\n+    pub fn is<T: Error + 'static>(&self) -> bool {\n+        <Error + 'static>::is::<T>(self)\n+    }\n+}\n+extern crate serialize;\n+#[derive(Clone, Copy, Hash, Encodable, Decodable, PartialEq, Eq, PartialOrd, Ord, Debug, Default)]\n+struct AllDerives(i32);\n+\n+fn test_format_args() {\n+    let x = 1;\n+    let y = 2;\n+    let name = \"Joe Blogg\";\n+    println!(\"Hello {}\", name);\n+    print!(\"Hello {0}\", name);\n+    print!(\"{0} + {} = {}\", x, y);\n+    print!(\"x is {}, y is {1}, name is {n}\", x, y, n = name);\n+}"}, {"sha": "2c6f517ff3882a3cdddf99c13e7d5dc7037b5720", "filename": "src/test/run-make/save-analysis-fail/krate2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Fkrate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea1544b804818c8df259de60c0e26a85ac52850/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Fkrate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Fkrate2.rs?ref=9ea1544b804818c8df259de60c0e26a85ac52850", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![ crate_name = \"krate2\" ]\n+#![ crate_type = \"lib\" ]\n+\n+use std::io::Write;\n+\n+pub fn hello() {\n+    std::io::stdout().write_all(b\"hello world!\\n\");\n+}"}]}