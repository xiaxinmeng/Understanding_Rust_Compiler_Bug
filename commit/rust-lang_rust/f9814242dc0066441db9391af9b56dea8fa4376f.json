{"sha": "f9814242dc0066441db9391af9b56dea8fa4376f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ODE0MjQyZGMwMDY2NDQxZGI5MzkxYWY5YjU2ZGVhOGZhNDM3NmY=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-12-22T16:43:05Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-06T11:57:52Z"}, "message": "panic/panic_bounds_check to destructure tys\n\nNot any more beautiful.", "tree": {"sha": "f9a6bf77cb127b25a054b997ac6e075f44654856", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9a6bf77cb127b25a054b997ac6e075f44654856"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9814242dc0066441db9391af9b56dea8fa4376f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9814242dc0066441db9391af9b56dea8fa4376f", "html_url": "https://github.com/rust-lang/rust/commit/f9814242dc0066441db9391af9b56dea8fa4376f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9814242dc0066441db9391af9b56dea8fa4376f/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "html_url": "https://github.com/rust-lang/rust/commit/d1c644c1e94403f0cd42c7afc2ac06c0554422b7"}], "stats": {"total": 90, "additions": 51, "deletions": 39}, "files": [{"sha": "4e03ed489eb9fcf93bcf9ca1828c521b3a42ac3d", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9814242dc0066441db9391af9b56dea8fa4376f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9814242dc0066441db9391af9b56dea8fa4376f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=f9814242dc0066441db9391af9b56dea8fa4376f", "patch": "@@ -71,7 +71,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                        cond: Operand::Consume(lt),\n                                        targets: (success, failure),\n                                    });\n-                this.panic_bound_check(failure, idx.clone(), Operand::Consume(len), expr_span);\n+                this.panic_bounds_check(failure, idx.clone(), Operand::Consume(len), expr_span);\n                 success.and(slice.index(idx))\n             }\n             ExprKind::SelfRef => {"}, {"sha": "e912e933bd81f2869ee29cae3350e527c87b4322", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f9814242dc0066441db9391af9b56dea8fa4376f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9814242dc0066441db9391af9b56dea8fa4376f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f9814242dc0066441db9391af9b56dea8fa4376f", "patch": "@@ -90,7 +90,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc::middle::region::CodeExtent;\n use rustc::middle::lang_items;\n use rustc::middle::subst::Substs;\n-use rustc::middle::ty::{Ty, Region};\n+use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::intern_and_get_ident;\n@@ -297,27 +297,34 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.scopes.first().map(|scope| scope.extent).unwrap()\n     }\n \n-    pub fn panic_bound_check(&mut self,\n+    pub fn panic_bounds_check(&mut self,\n                              block: BasicBlock,\n                              index: Operand<'tcx>,\n                              len: Operand<'tcx>,\n                              span: Span) {\n+        // fn(&(filename: &'static str, line: u32), index: usize, length: usize) -> !\n         let func = self.lang_function(lang_items::PanicBoundsCheckFnLangItem);\n-        let str_ty = self.hir.tcx().mk_static_str();\n-        let tup_ty = self.hir.tcx().mk_tup(vec![str_ty, self.hir.tcx().types.u32]);\n-        // FIXME: ReStatic might be wrong here?\n-        let ref_region = self.hir.tcx().mk_region(Region::ReStatic);\n-        let ref_ty = self.hir.tcx().mk_imm_ref(ref_region, tup_ty.clone());\n-        let (file_arg, line_arg) = self.span_to_fileline_args(span);\n+        let args = func.ty.fn_args();\n+        let ref_ty = args.skip_binder()[0];\n+        let (region, tup_ty) = if let ty::TyRef(region, tyandmut) = ref_ty.sty {\n+            (region, tyandmut.ty)\n+        } else {\n+            self.hir.span_bug(span, &format!(\"unexpected panic_bound_check type: {:?}\", func.ty));\n+        };\n         let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n-        self.cfg.push_assign(block, DUMMY_SP, &tuple, // tuple = (message_arg, file_arg, line_arg);\n-                             Rvalue::Aggregate(AggregateKind::Tuple, vec![file_arg, line_arg]));\n-        // FIXME: ReStatic might be wrong here?\n+        let (file, line) = self.span_to_fileline_args(span);\n+        let elems = vec![Operand::Constant(file), Operand::Constant(line)];\n+        // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n+        // icache with cold branch code), however to achieve that we either have to rely on rvalue\n+        // promotion or have some way, in MIR, to create constants.\n+        self.cfg.push_assign(block, DUMMY_SP, &tuple, // tuple = (file_arg, line_arg);\n+                             Rvalue::Aggregate(AggregateKind::Tuple, elems));\n+        // FIXME: is this region really correct here?\n         self.cfg.push_assign(block, DUMMY_SP, &tuple_ref, // tuple_ref = &tuple;\n-                             Rvalue::Ref(*ref_region, BorrowKind::Unique, tuple));\n+                             Rvalue::Ref(*region, BorrowKind::Unique, tuple));\n         let cleanup = self.diverge_cleanup();\n         self.cfg.terminate(block, Terminator::Call {\n-            func: func,\n+            func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref), index, len],\n             kind: match cleanup {\n                 None => CallKind::Diverging,\n@@ -328,31 +335,36 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n     /// Create diverge cleanup and branch to it from `block`.\n     pub fn panic(&mut self, block: BasicBlock, msg: &'static str, span: Span) {\n+        // fn(&(msg: &'static str filename: &'static str, line: u32)) -> !\n         let func = self.lang_function(lang_items::PanicFnLangItem);\n-\n-        let str_ty = self.hir.tcx().mk_static_str();\n-        let tup_ty = self.hir.tcx().mk_tup(vec![str_ty, str_ty, self.hir.tcx().types.u32]);\n-        // FIXME: ReStatic might be wrong here?\n-        let ref_region = self.hir.tcx().mk_region(Region::ReStatic);\n-        let ref_ty = self.hir.tcx().mk_imm_ref(ref_region, tup_ty.clone());\n-        let message_arg = Operand::Constant(Constant {\n+        let args = func.ty.fn_args();\n+        let ref_ty = args.skip_binder()[0];\n+        let (region, tup_ty) = if let ty::TyRef(region, tyandmut) = ref_ty.sty {\n+            (region, tyandmut.ty)\n+        } else {\n+            self.hir.span_bug(span, &format!(\"unexpected panic type: {:?}\", func.ty));\n+        };\n+        let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n+        let (file, line) = self.span_to_fileline_args(span);\n+        let message = Constant {\n             span: DUMMY_SP,\n-            ty: str_ty,\n+            ty: self.hir.tcx().mk_static_str(),\n             literal: self.hir.str_literal(intern_and_get_ident(msg))\n-        });\n-        let (file_arg, line_arg) = self.span_to_fileline_args(span);\n-        let tuple = self.temp(tup_ty);\n-        let tuple_ref = self.temp(ref_ty);\n+        };\n+        let elems = vec![Operand::Constant(message),\n+                         Operand::Constant(file),\n+                         Operand::Constant(line)];\n+        // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n+        // icache with cold branch code), however to achieve that we either have to rely on rvalue\n+        // promotion or have some way, in MIR, to create constants.\n         self.cfg.push_assign(block, DUMMY_SP, &tuple, // tuple = (message_arg, file_arg, line_arg);\n-                             Rvalue::Aggregate(AggregateKind::Tuple,\n-                                               vec![message_arg, file_arg, line_arg])\n-        );\n-        // FIXME: ReStatic might be wrong here?\n+                             Rvalue::Aggregate(AggregateKind::Tuple, elems));\n+        // FIXME: is this region really correct here?\n         self.cfg.push_assign(block, DUMMY_SP, &tuple_ref, // tuple_ref = &tuple;\n-                             Rvalue::Ref(*ref_region, BorrowKind::Unique, tuple));\n+                             Rvalue::Ref(*region, BorrowKind::Unique, tuple));\n         let cleanup = self.diverge_cleanup();\n         self.cfg.terminate(block, Terminator::Call {\n-            func: func,\n+            func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref)],\n             kind: match cleanup {\n                 None => CallKind::Diverging,\n@@ -361,34 +373,34 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         });\n     }\n \n-    fn lang_function(&mut self, lang_item: lang_items::LangItem) -> Operand<'tcx> {\n+    fn lang_function(&mut self, lang_item: lang_items::LangItem) -> Constant<'tcx> {\n         let funcdid = match self.hir.tcx().lang_items.require(lang_item) {\n             Ok(d) => d,\n             Err(m) => {\n                 self.hir.tcx().sess.fatal(&*m)\n             }\n         };\n-        Operand::Constant(Constant {\n+        Constant {\n             span: DUMMY_SP,\n             ty: self.hir.tcx().lookup_item_type(funcdid).ty,\n             literal: Literal::Item {\n                 def_id: funcdid,\n                 kind: ItemKind::Function,\n                 substs: self.hir.tcx().mk_substs(Substs::empty())\n             }\n-        })\n+        }\n     }\n \n-    fn span_to_fileline_args(&mut self, span: Span) -> (Operand<'tcx>, Operand<'tcx>) {\n+    fn span_to_fileline_args(&mut self, span: Span) -> (Constant<'tcx>, Constant<'tcx>) {\n         let span_lines = self.hir.tcx().sess.codemap().lookup_char_pos(span.lo);\n-        (Operand::Constant(Constant {\n+        (Constant {\n             span: DUMMY_SP,\n             ty: self.hir.tcx().mk_static_str(),\n             literal: self.hir.str_literal(intern_and_get_ident(&span_lines.file.name))\n-        }), Operand::Constant(Constant {\n+        }, Constant {\n             span: DUMMY_SP,\n             ty: self.hir.tcx().types.u32,\n             literal: self.hir.usize_literal(span_lines.line)\n-        }))\n+        })\n     }\n }"}]}