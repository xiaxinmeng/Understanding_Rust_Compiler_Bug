{"sha": "c35b9f6703e11e08d5250434472b36a109353cc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNWI5ZjY3MDNlMTFlMDhkNTI1MDQzNDQ3MmIzNmExMDkzNTNjYzM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-08T02:26:54Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-08T17:43:38Z"}, "message": "Add UnixListener doc examples", "tree": {"sha": "2b9664a7f900579480461297d6a5d583c4b43d97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b9664a7f900579480461297d6a5d583c4b43d97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c35b9f6703e11e08d5250434472b36a109353cc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c35b9f6703e11e08d5250434472b36a109353cc3", "html_url": "https://github.com/rust-lang/rust/commit/c35b9f6703e11e08d5250434472b36a109353cc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c35b9f6703e11e08d5250434472b36a109353cc3/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fe17f96d5acf5753e05414748cf3e1f63371c81", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe17f96d5acf5753e05414748cf3e1f63371c81", "html_url": "https://github.com/rust-lang/rust/commit/7fe17f96d5acf5753e05414748cf3e1f63371c81"}], "stats": {"total": 111, "additions": 101, "deletions": 10}, "files": [{"sha": "f346e3eb44f051f69fbe6bdcdf9e6806744088df", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 101, "deletions": 10, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/c35b9f6703e11e08d5250434472b36a109353cc3/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b9f6703e11e08d5250434472b36a109353cc3/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=c35b9f6703e11e08d5250434472b36a109353cc3", "patch": "@@ -437,7 +437,6 @@ impl UnixStream {\n     ///\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n     ///\n     /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n@@ -453,7 +452,6 @@ impl UnixStream {\n     ///\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n     ///\n     /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// if let Ok(Some(err)) = socket.take_error() {\n@@ -477,7 +475,6 @@ impl UnixStream {\n     ///\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n     ///\n     /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n@@ -557,7 +554,7 @@ impl IntoRawFd for UnixStream {\n ///\n /// # Examples\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::thread;\n /// use std::os::unix::net::{UnixStream, UnixListener};\n ///\n@@ -580,9 +577,6 @@ impl IntoRawFd for UnixStream {\n ///         }\n ///     }\n /// }\n-///\n-/// // close the listener socket\n-/// drop(listener);\n /// ```\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct UnixListener(Socket);\n@@ -601,6 +595,20 @@ impl fmt::Debug for UnixListener {\n \n impl UnixListener {\n     /// Creates a new `UnixListener` bound to the specified socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n         fn inner(path: &Path) -> io::Result<UnixListener> {\n@@ -620,8 +628,23 @@ impl UnixListener {\n     /// Accepts a new incoming connection to this listener.\n     ///\n     /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corersponding `UnixStream` and\n+    /// is established. When established, the corersponding [`UnixStream`] and\n     /// the remote peer's address will be returned.\n+    ///\n+    /// [`UnixStream`]: ../../std/os/unix/net/struct.UnixStream.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// match listener.accept() {\n+    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n+    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n         let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n@@ -636,33 +659,101 @@ impl UnixListener {\n     /// The returned `UnixListener` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n     /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixListener> {\n         self.0.duplicate().map(UnixListener)\n     }\n \n     /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// socket.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let socket = match UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// if let Ok(Some(err)) = socket.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n     }\n \n     /// Returns an iterator over incoming connections.\n     ///\n-    /// The iterator will never return `None` and will also not yield the\n-    /// peer's `SocketAddr` structure.\n+    /// The iterator will never return [`None`] and will also not yield the\n+    /// peer's [`SocketAddr`] structure.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`SocketAddr`]: struct.SocketAddr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread;\n+    /// use std::os::unix::net::{UnixStream, UnixListener};\n+    ///\n+    /// fn handle_client(stream: UnixStream) {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// for stream in listener.incoming() {\n+    ///     match stream {\n+    ///         Ok(stream) => {\n+    ///             thread::spawn(|| handle_client(stream));\n+    ///         }\n+    ///         Err(err) => {\n+    ///             break;\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n         Incoming { listener: self }"}]}