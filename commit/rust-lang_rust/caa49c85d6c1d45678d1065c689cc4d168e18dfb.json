{"sha": "caa49c85d6c1d45678d1065c689cc4d168e18dfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYTQ5Yzg1ZDZjMWQ0NTY3OGQxMDY1YzY4OWNjNGQxNjhlMThkZmI=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-18T07:03:56Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-26T11:18:37Z"}, "message": "Move absurd_extreme_comparisons to its own module", "tree": {"sha": "f6f0b9ec2ed498b3a90acc5ce1a5081e5f77d941", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6f0b9ec2ed498b3a90acc5ce1a5081e5f77d941"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caa49c85d6c1d45678d1065c689cc4d168e18dfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caa49c85d6c1d45678d1065c689cc4d168e18dfb", "html_url": "https://github.com/rust-lang/rust/commit/caa49c85d6c1d45678d1065c689cc4d168e18dfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caa49c85d6c1d45678d1065c689cc4d168e18dfb/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63aca96e9143bb03cc6f657aade80fdedc02e015", "url": "https://api.github.com/repos/rust-lang/rust/commits/63aca96e9143bb03cc6f657aade80fdedc02e015", "html_url": "https://github.com/rust-lang/rust/commit/63aca96e9143bb03cc6f657aade80fdedc02e015"}], "stats": {"total": 360, "additions": 183, "deletions": 177}, "files": [{"sha": "33c720c666e432aeb1731f94ee68b2a6d773af9a", "filename": "clippy_lints/src/absurd_extreme_comparisons.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/caa49c85d6c1d45678d1065c689cc4d168e18dfb/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa49c85d6c1d45678d1065c689cc4d168e18dfb/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs?ref=caa49c85d6c1d45678d1065c689cc4d168e18dfb", "patch": "@@ -0,0 +1,173 @@\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::consts::{constant, Constant};\n+\n+use clippy_utils::comparisons::{normalize_comparison, Rel};\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::is_isize_or_usize;\n+use clippy_utils::{clip, int_bits, unsext};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where one side of the relation is\n+    /// either the minimum or maximum value for its type and warns if it involves a\n+    /// case that is always true or always false. Only integer and boolean types are\n+    /// checked.\n+    ///\n+    /// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n+    /// that it is possible for `x` to be less than the minimum. Expressions like\n+    /// `max < x` are probably mistakes.\n+    ///\n+    /// **Known problems:** For `usize` the size of the current compile target will\n+    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n+    /// a comparison to detect target pointer width will trigger this lint. One can\n+    /// use `mem::sizeof` and compare its value or conditional compilation\n+    /// attributes\n+    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let vec: Vec<isize> = Vec::new();\n+    /// if vec.len() <= 0 {}\n+    /// if 100 > i32::MAX {}\n+    /// ```\n+    pub ABSURD_EXTREME_COMPARISONS,\n+    correctness,\n+    \"a comparison with a maximum or minimum value that is always true or false\"\n+}\n+\n+declare_lint_pass!(AbsurdExtremeComparisons => [ABSURD_EXTREME_COMPARISONS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n+            if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n+                if !expr.span.from_expansion() {\n+                    let msg = \"this comparison involving the minimum or maximum element for this \\\n+                               type contains a case that is always true or always false\";\n+\n+                    let conclusion = match result {\n+                        AbsurdComparisonResult::AlwaysFalse => \"this comparison is always false\".to_owned(),\n+                        AbsurdComparisonResult::AlwaysTrue => \"this comparison is always true\".to_owned(),\n+                        AbsurdComparisonResult::InequalityImpossible => format!(\n+                            \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n+                             instead\",\n+                            snippet(cx, lhs.span, \"lhs\"),\n+                            snippet(cx, rhs.span, \"rhs\")\n+                        ),\n+                    };\n+\n+                    let help = format!(\n+                        \"because `{}` is the {} value for this type, {}\",\n+                        snippet(cx, culprit.expr.span, \"x\"),\n+                        match culprit.which {\n+                            ExtremeType::Minimum => \"minimum\",\n+                            ExtremeType::Maximum => \"maximum\",\n+                        },\n+                        conclusion\n+                    );\n+\n+                    span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+enum ExtremeType {\n+    Minimum,\n+    Maximum,\n+}\n+\n+struct ExtremeExpr<'a> {\n+    which: ExtremeType,\n+    expr: &'a Expr<'a>,\n+}\n+\n+enum AbsurdComparisonResult {\n+    AlwaysFalse,\n+    AlwaysTrue,\n+    InequalityImpossible,\n+}\n+\n+fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n+        let precast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n+\n+        return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n+    }\n+\n+    false\n+}\n+\n+fn detect_absurd_comparison<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    op: BinOpKind,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n+    use AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n+    use ExtremeType::{Maximum, Minimum};\n+    // absurd comparison only makes sense on primitive types\n+    // primitive types don't implement comparison operators with each other\n+    if cx.typeck_results().expr_ty(lhs) != cx.typeck_results().expr_ty(rhs) {\n+        return None;\n+    }\n+\n+    // comparisons between fix sized types and target sized types are considered unanalyzable\n+    if is_cast_between_fixed_and_target(cx, lhs) || is_cast_between_fixed_and_target(cx, rhs) {\n+        return None;\n+    }\n+\n+    let (rel, normalized_lhs, normalized_rhs) = normalize_comparison(op, lhs, rhs)?;\n+\n+    let lx = detect_extreme_expr(cx, normalized_lhs);\n+    let rx = detect_extreme_expr(cx, normalized_rhs);\n+\n+    Some(match rel {\n+        Rel::Lt => {\n+            match (lx, rx) {\n+                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n+                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n+                _ => return None,\n+            }\n+        },\n+        Rel::Le => {\n+            match (lx, rx) {\n+                (Some(l @ ExtremeExpr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n+                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, InequalityImpossible), // max <= x\n+                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n+                (_, Some(r @ ExtremeExpr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n+                _ => return None,\n+            }\n+        },\n+        Rel::Ne | Rel::Eq => return None,\n+    })\n+}\n+\n+fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+\n+    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n+\n+    let which = match (ty.kind(), cv) {\n+        (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => ExtremeType::Minimum,\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) => {\n+            ExtremeType::Minimum\n+        },\n+\n+        (&ty::Bool, Constant::Bool(true)) => ExtremeType::Maximum,\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MAX >> (128 - int_bits(cx.tcx, ity)), ity) => {\n+            ExtremeType::Maximum\n+        },\n+        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::MAX, uty) == i => ExtremeType::Maximum,\n+\n+        _ => return None,\n+    };\n+    Some(ExtremeExpr { which, expr })\n+}"}, {"sha": "7b261121f5184a7734482a8fa7fb66176df84ce6", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/caa49c85d6c1d45678d1065c689cc4d168e18dfb/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa49c85d6c1d45678d1065c689cc4d168e18dfb/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=caa49c85d6c1d45678d1065c689cc4d168e18dfb", "patch": "@@ -164,6 +164,7 @@ mod consts;\n mod utils;\n \n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n+mod absurd_extreme_comparisons;\n mod approx_const;\n mod arithmetic;\n mod as_conversions;\n@@ -558,6 +559,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::PRODUCE_ICE,\n         #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n+        &absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS,\n         &approx_const::APPROX_CONSTANT,\n         &arithmetic::FLOAT_ARITHMETIC,\n         &arithmetic::INTEGER_ARITHMETIC,\n@@ -955,7 +957,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &transmute::WRONG_TRANSMUTE,\n         &transmuting_null::TRANSMUTING_NULL,\n         &try_err::TRY_ERR,\n-        &types::ABSURD_EXTREME_COMPARISONS,\n         &types::BORROWED_BOX,\n         &types::BOX_VEC,\n         &types::IMPLICIT_HASHER,\n@@ -1112,7 +1113,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n     store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n     store.register_late_pass(|| box empty_enum::EmptyEnum);\n-    store.register_late_pass(|| box types::AbsurdExtremeComparisons);\n+    store.register_late_pass(|| box absurd_extreme_comparisons::AbsurdExtremeComparisons);\n     store.register_late_pass(|| box types::InvalidUpcastComparisons);\n     store.register_late_pass(|| box regex::Regex::default());\n     store.register_late_pass(|| box copies::CopyAndPaste);\n@@ -1442,6 +1443,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n \n     store.register_group(true, \"clippy::all\", Some(\"clippy\"), vec![\n+        LintId::of(&absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&approx_const::APPROX_CONSTANT),\n         LintId::of(&assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n         LintId::of(&assign_ops::ASSIGN_OP_PATTERN),\n@@ -1701,7 +1703,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),\n         LintId::of(&try_err::TRY_ERR),\n-        LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&types::BORROWED_BOX),\n         LintId::of(&types::BOX_VEC),\n         LintId::of(&types::REDUNDANT_ALLOCATION),\n@@ -1941,6 +1942,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n \n     store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), vec![\n+        LintId::of(&absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&approx_const::APPROX_CONSTANT),\n         LintId::of(&async_yields_async::ASYNC_YIELDS_ASYNC),\n         LintId::of(&atomic_ordering::INVALID_ATOMIC_ORDERING),\n@@ -2002,7 +2004,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::UNSOUND_COLLECTION_TRANSMUTE),\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),\n-        LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n         LintId::of(&unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),"}, {"sha": "0c50ed8348ec362183e05a7e096fa171c6a6595b", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 5, "deletions": 173, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/caa49c85d6c1d45678d1065c689cc4d168e18dfb/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa49c85d6c1d45678d1065c689cc4d168e18dfb/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=caa49c85d6c1d45678d1065c689cc4d168e18dfb", "patch": "@@ -13,16 +13,16 @@ use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::collections::BTreeMap;\n \n-use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_help, span_lint_and_then};\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{is_isize_or_usize, is_type_diagnostic_item};\n+use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n-    ImplItemKind, Item, ItemKind, Local, MutTy, QPath, TraitFn, TraitItem, TraitItemKind, TyKind,\n+    Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem, ImplItemKind, Item,\n+    ItemKind, Local, MutTy, QPath, TraitFn, TraitItem, TraitItemKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -37,7 +37,7 @@ use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n use clippy_utils::paths;\n-use clippy_utils::{clip, comparisons, differing_macro_contexts, int_bits, match_path, sext, unsext};\n+use clippy_utils::{comparisons, differing_macro_contexts, match_path, sext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n@@ -552,174 +552,6 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n     }\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for comparisons where one side of the relation is\n-    /// either the minimum or maximum value for its type and warns if it involves a\n-    /// case that is always true or always false. Only integer and boolean types are\n-    /// checked.\n-    ///\n-    /// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n-    /// that it is possible for `x` to be less than the minimum. Expressions like\n-    /// `max < x` are probably mistakes.\n-    ///\n-    /// **Known problems:** For `usize` the size of the current compile target will\n-    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n-    /// a comparison to detect target pointer width will trigger this lint. One can\n-    /// use `mem::sizeof` and compare its value or conditional compilation\n-    /// attributes\n-    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// let vec: Vec<isize> = Vec::new();\n-    /// if vec.len() <= 0 {}\n-    /// if 100 > i32::MAX {}\n-    /// ```\n-    pub ABSURD_EXTREME_COMPARISONS,\n-    correctness,\n-    \"a comparison with a maximum or minimum value that is always true or false\"\n-}\n-\n-declare_lint_pass!(AbsurdExtremeComparisons => [ABSURD_EXTREME_COMPARISONS]);\n-\n-enum ExtremeType {\n-    Minimum,\n-    Maximum,\n-}\n-\n-struct ExtremeExpr<'a> {\n-    which: ExtremeType,\n-    expr: &'a Expr<'a>,\n-}\n-\n-enum AbsurdComparisonResult {\n-    AlwaysFalse,\n-    AlwaysTrue,\n-    InequalityImpossible,\n-}\n-\n-fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let precast_ty = cx.typeck_results().expr_ty(cast_exp);\n-        let cast_ty = cx.typeck_results().expr_ty(expr);\n-\n-        return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n-    }\n-\n-    false\n-}\n-\n-fn detect_absurd_comparison<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    op: BinOpKind,\n-    lhs: &'tcx Expr<'_>,\n-    rhs: &'tcx Expr<'_>,\n-) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n-    use crate::types::AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n-    use crate::types::ExtremeType::{Maximum, Minimum};\n-    use clippy_utils::comparisons::{normalize_comparison, Rel};\n-\n-    // absurd comparison only makes sense on primitive types\n-    // primitive types don't implement comparison operators with each other\n-    if cx.typeck_results().expr_ty(lhs) != cx.typeck_results().expr_ty(rhs) {\n-        return None;\n-    }\n-\n-    // comparisons between fix sized types and target sized types are considered unanalyzable\n-    if is_cast_between_fixed_and_target(cx, lhs) || is_cast_between_fixed_and_target(cx, rhs) {\n-        return None;\n-    }\n-\n-    let (rel, normalized_lhs, normalized_rhs) = normalize_comparison(op, lhs, rhs)?;\n-\n-    let lx = detect_extreme_expr(cx, normalized_lhs);\n-    let rx = detect_extreme_expr(cx, normalized_rhs);\n-\n-    Some(match rel {\n-        Rel::Lt => {\n-            match (lx, rx) {\n-                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n-                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n-                _ => return None,\n-            }\n-        },\n-        Rel::Le => {\n-            match (lx, rx) {\n-                (Some(l @ ExtremeExpr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n-                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, InequalityImpossible), // max <= x\n-                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n-                (_, Some(r @ ExtremeExpr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n-                _ => return None,\n-            }\n-        },\n-        Rel::Ne | Rel::Eq => return None,\n-    })\n-}\n-\n-fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n-    use crate::types::ExtremeType::{Maximum, Minimum};\n-\n-    let ty = cx.typeck_results().expr_ty(expr);\n-\n-    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n-\n-    let which = match (ty.kind(), cv) {\n-        (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n-        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) => {\n-            Minimum\n-        },\n-\n-        (&ty::Bool, Constant::Bool(true)) => Maximum,\n-        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MAX >> (128 - int_bits(cx.tcx, ity)), ity) => {\n-            Maximum\n-        },\n-        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::MAX, uty) == i => Maximum,\n-\n-        _ => return None,\n-    };\n-    Some(ExtremeExpr { which, expr })\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        use crate::types::AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n-        use crate::types::ExtremeType::{Maximum, Minimum};\n-\n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n-            if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n-                if !expr.span.from_expansion() {\n-                    let msg = \"this comparison involving the minimum or maximum element for this \\\n-                               type contains a case that is always true or always false\";\n-\n-                    let conclusion = match result {\n-                        AlwaysFalse => \"this comparison is always false\".to_owned(),\n-                        AlwaysTrue => \"this comparison is always true\".to_owned(),\n-                        InequalityImpossible => format!(\n-                            \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n-                             instead\",\n-                            snippet(cx, lhs.span, \"lhs\"),\n-                            snippet(cx, rhs.span, \"rhs\")\n-                        ),\n-                    };\n-\n-                    let help = format!(\n-                        \"because `{}` is the {} value for this type, {}\",\n-                        snippet(cx, culprit.expr.span, \"x\"),\n-                        match culprit.which {\n-                            Minimum => \"minimum\",\n-                            Maximum => \"maximum\",\n-                        },\n-                        conclusion\n-                    );\n-\n-                    span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for comparisons where the relation is always either\n     /// true or false, but where one side has been upcast so that the comparison is"}]}