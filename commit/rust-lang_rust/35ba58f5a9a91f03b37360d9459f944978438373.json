{"sha": "35ba58f5a9a91f03b37360d9459f944978438373", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YmE1OGY1YTlhOTFmMDNiMzczNjBkOTQ1OWY5NDQ5Nzg0MzgzNzM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-27T23:02:51Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-12-02T09:25:36Z"}, "message": "Remove minification on search-index.js file", "tree": {"sha": "98e490790e6b2bc14b3f7d8bfe0ff1a89f8c0f3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98e490790e6b2bc14b3f7d8bfe0ff1a89f8c0f3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35ba58f5a9a91f03b37360d9459f944978438373", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35ba58f5a9a91f03b37360d9459f944978438373", "html_url": "https://github.com/rust-lang/rust/commit/35ba58f5a9a91f03b37360d9459f944978438373", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35ba58f5a9a91f03b37360d9459f944978438373/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5748b4ce95a2aaba6fede25408f59d044a8e0804", "url": "https://api.github.com/repos/rust-lang/rust/commits/5748b4ce95a2aaba6fede25408f59d044a8e0804", "html_url": "https://github.com/rust-lang/rust/commit/5748b4ce95a2aaba6fede25408f59d044a8e0804"}], "stats": {"total": 94, "additions": 9, "deletions": 85}, "files": [{"sha": "2d7fef56731a25f0c230a88f33f611c8a6628150", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 85, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/35ba58f5a9a91f03b37360d9459f944978438373/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ba58f5a9a91f03b37360d9459f944978438373/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=35ba58f5a9a91f03b37360d9459f944978438373", "patch": "@@ -715,19 +715,13 @@ themePicker.onblur = handleThemeButtonsBlur;\n         path: &Path,\n         krate: &str,\n         key: &str,\n-        for_search_index: bool,\n-    ) -> io::Result<(Vec<String>, Vec<String>, Vec<String>)> {\n+    ) -> io::Result<(Vec<String>, Vec<String>)> {\n         let mut ret = Vec::new();\n         let mut krates = Vec::new();\n-        let mut variables = Vec::new();\n \n         if path.exists() {\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n-                if for_search_index && line.starts_with(\"var R\") {\n-                    variables.push(line.clone());\n-                    continue;\n-                }\n                 if !line.starts_with(key) {\n                     continue;\n                 }\n@@ -741,7 +735,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                                  .unwrap_or_else(|| String::new()));\n             }\n         }\n-        Ok((ret, krates, variables))\n+        Ok((ret, krates))\n     }\n \n     fn show_item(item: &IndexItem, krate: &str) -> String {\n@@ -756,7 +750,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     let dst = cx.dst.join(&format!(\"aliases{}.js\", cx.shared.resource_suffix));\n     {\n-        let (mut all_aliases, _, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\", false), &dst);\n+        let (mut all_aliases, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\"), &dst);\n         let mut output = String::with_capacity(100);\n         for (alias, items) in &cx.cache.aliases {\n             if items.is_empty() {\n@@ -853,9 +847,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n \n         let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n-        let (mut all_sources, _krates, _) = try_err!(collect(&dst, &krate.name, \"sourcesIndex\",\n-                                                             false),\n-                                                     &dst);\n+        let (mut all_sources, _krates) = try_err!(collect(&dst, &krate.name, \"sourcesIndex\"), &dst);\n         all_sources.push(format!(\"sourcesIndex[\\\"{}\\\"] = {};\",\n                                  &krate.name,\n                                  hierarchy.to_json_string()));\n@@ -867,20 +859,15 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     // Update the search index\n     let dst = cx.dst.join(&format!(\"search-index{}.js\", cx.shared.resource_suffix));\n-    let (mut all_indexes, mut krates, variables) = try_err!(collect(&dst,\n-                                                                    &krate.name,\n-                                                                    \"searchIndex\",\n-                                                                    true), &dst);\n+    let (mut all_indexes, mut krates) = try_err!(collect(&dst, &krate.name, \"searchIndex\"), &dst);\n     all_indexes.push(search_index);\n \n     // Sort the indexes by crate so the file will be generated identically even\n     // with rustdoc running in parallel.\n     all_indexes.sort();\n     {\n-        let mut v = String::from(\"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={};\\n\");\n-        v.push_str(&minify_replacer(\n-            &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n-            options.enable_minification));\n+        let mut v = String::from(\"var searchIndex={};\\n\");\n+        v.push_str(&all_indexes.join(\"\\n\"));\n         // \"addSearchOptions\" has to be called first so the crate filtering can be set before the\n         // search might start (if it's set into the URL for example).\n         v.push_str(\"addSearchOptions(searchIndex);initSearch(searchIndex);\");\n@@ -981,9 +968,8 @@ themePicker.onblur = handleThemeButtonsBlur;\n                             remote_item_type,\n                             remote_path[remote_path.len() - 1]));\n \n-        let (mut all_implementors, _, _) = try_err!(collect(&mydst, &krate.name, \"implementors\",\n-                                                            false),\n-                                                    &mydst);\n+        let (mut all_implementors, _) = try_err!(collect(&mydst, &krate.name, \"implementors\"),\n+                                                 &mydst);\n         all_implementors.push(implementors);\n         // Sort the implementors by crate so the file will be generated\n         // identically even with rustdoc running in parallel.\n@@ -1020,68 +1006,6 @@ fn write_minify(fs:&DocFS, dst: PathBuf, contents: &str, enable_minification: bo\n     }\n }\n \n-fn minify_replacer(\n-    contents: &str,\n-    enable_minification: bool,\n-) -> String {\n-    use minifier::js::{simple_minify, Keyword, ReservedChar, Token, Tokens};\n-\n-    if enable_minification {\n-        let tokens: Tokens<'_> = simple_minify(contents)\n-            .into_iter()\n-            .filter(|(f, next)| {\n-                // We keep backlines.\n-                minifier::js::clean_token_except(f, next, &|c: &Token<'_>| {\n-                    c.get_char() != Some(ReservedChar::Backline)\n-                })\n-            })\n-            .map(|(f, _)| {\n-                minifier::js::replace_token_with(f, &|t: &Token<'_>| {\n-                    match *t {\n-                        Token::Keyword(Keyword::Null) => Some(Token::Other(\"N\")),\n-                        Token::String(s) => {\n-                            let s = &s[1..s.len() -1]; // The quotes are included\n-                            if s.is_empty() {\n-                                Some(Token::Other(\"E\"))\n-                            } else if s == \"t\" {\n-                                Some(Token::Other(\"T\"))\n-                            } else if s == \"u\" {\n-                                Some(Token::Other(\"U\"))\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                        _ => None,\n-                    }\n-                })\n-            })\n-            .collect::<Vec<_>>()\n-            .into();\n-        let o = tokens.apply(|f| {\n-            // We add a backline after the newly created variables.\n-            minifier::js::aggregate_strings_into_array_with_separation_filter(\n-                f,\n-                \"R\",\n-                Token::Char(ReservedChar::Backline),\n-                // This closure prevents crates' names from being aggregated.\n-                //\n-                // The point here is to check if the string is preceded by '[' and\n-                // \"searchIndex\". If so, it means this is a crate name and that it\n-                // shouldn't be aggregated.\n-                |tokens, pos| {\n-                    pos < 2 ||\n-                    !tokens[pos - 1].eq_char(ReservedChar::OpenBracket) ||\n-                    tokens[pos - 2].get_other() != Some(\"searchIndex\")\n-                }\n-            )\n-        })\n-        .to_string();\n-        format!(\"{}\\n\", o)\n-    } else {\n-        format!(\"{}\\n\", contents)\n-    }\n-}\n-\n #[derive(Debug, Eq, PartialEq, Hash)]\n struct ItemEntry {\n     url: String,"}]}