{"sha": "8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYjQ5NDFlMzBkMmE0MGJjMDM4NDBkZDBkOTliZWI1YWFmODE1OWQ=", "commit": {"author": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2018-06-16T02:49:00Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2018-07-24T02:54:43Z"}, "message": "Implement 2015 vs 2018 `?` kleene op + test", "tree": {"sha": "c2b4f35f76ad4697f92741e5b6fa6ce5cf4d6bce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2b4f35f76ad4697f92741e5b6fa6ce5cf4d6bce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "html_url": "https://github.com/rust-lang/rust/commit/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a7ae04a6872edd8a1bffa620fde53a2eb2964e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a7ae04a6872edd8a1bffa620fde53a2eb2964e1", "html_url": "https://github.com/rust-lang/rust/commit/2a7ae04a6872edd8a1bffa620fde53a2eb2964e1"}], "stats": {"total": 1327, "additions": 862, "deletions": 465}, "files": [{"sha": "3c1b20562089200aa9e1989f8855d193d487b714", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -127,7 +127,7 @@ macro_rules! declare_lint {\n         };\n     );\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n-     $lint_edition: expr => $edition_level: ident $(,)?\n+     $lint_edition: expr => $edition_level: ident\n     ) => (\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n@@ -142,7 +142,8 @@ macro_rules! declare_lint {\n /// Declare a static `LintArray` and return it as an expression.\n #[macro_export]\n macro_rules! lint_array {\n-    ($( $lint:expr ),* $(,)?) => {{\n+    ($( $lint:expr ),* ,) => { lint_array!( $($lint),* ) };\n+    ($( $lint:expr ),*) => {{\n         vec![$($lint),*]\n     }}\n }"}, {"sha": "e6aa7c0d16c6a9b8285a0ac09eb49fddb127e13b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -617,7 +617,7 @@ declare_lint! {\n     pub ANONYMOUS_PARAMETERS,\n     Allow,\n     \"detects anonymous parameters\",\n-    Edition::Edition2018 => Warn,\n+    Edition::Edition2018 => Warn\n }\n \n /// Checks for use of anonymous parameters (RFC 1685)\n@@ -1706,7 +1706,7 @@ impl LintPass for SoftLints {\n             UNIONS_WITH_DROP_FIELDS,\n             UNREACHABLE_PUB,\n             TYPE_ALIAS_BOUNDS,\n-            TRIVIAL_BOUNDS,\n+            TRIVIAL_BOUNDS\n         )\n     }\n }"}, {"sha": "b84046d10505125f1ca9a7ad9024f23b6154f3db", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -44,8 +44,10 @@ macro_rules! ast_fragments {\n     (\n         $($Kind:ident($AstTy:ty) {\n             $kind_name:expr;\n-            $(one fn $fold_ast:ident; fn $visit_ast:ident;)?\n-            $(many fn $fold_ast_elt:ident; fn $visit_ast_elt:ident;)?\n+            // FIXME: HACK: this should be `$(one ...)?` and `$(many ...)?` but `?` macro\n+            // repetition was removed from 2015 edition in #51587 because of ambiguities.\n+            $(one fn $fold_ast:ident; fn $visit_ast:ident;)*\n+            $(many fn $fold_ast_elt:ident; fn $visit_ast_elt:ident;)*\n             fn $make_ast:ident;\n         })*\n     ) => {\n@@ -100,22 +102,22 @@ macro_rules! ast_fragments {\n                     AstFragment::OptExpr(expr) =>\n                         AstFragment::OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n                     $($(AstFragment::$Kind(ast) =>\n-                        AstFragment::$Kind(folder.$fold_ast(ast)),)?)*\n+                        AstFragment::$Kind(folder.$fold_ast(ast)),)*)*\n                     $($(AstFragment::$Kind(ast) =>\n                         AstFragment::$Kind(ast.into_iter()\n                                               .flat_map(|ast| folder.$fold_ast_elt(ast))\n-                                              .collect()),)?)*\n+                                              .collect()),)*)*\n                 }\n             }\n \n             pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n                 match *self {\n                     AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n                     AstFragment::OptExpr(None) => {}\n-                    $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n+                    $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)*)*\n                     $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n                         visitor.$visit_ast_elt(ast_elt);\n-                    })?)*\n+                    })*)*\n                 }\n             }\n         }\n@@ -126,10 +128,10 @@ macro_rules! ast_fragments {\n             }\n             $($(fn $fold_ast(&mut self, ast: $AstTy) -> $AstTy {\n                 self.expand_fragment(AstFragment::$Kind(ast)).$make_ast()\n-            })?)*\n+            })*)*\n             $($(fn $fold_ast_elt(&mut self, ast_elt: <$AstTy as IntoIterator>::Item) -> $AstTy {\n                 self.expand_fragment(AstFragment::$Kind(SmallVector::one(ast_elt))).$make_ast()\n-            })?)*\n+            })*)*\n         }\n \n         impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> {"}, {"sha": "05e59d6b47cc071d476b8844373c929c5b093efe", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 280, "deletions": 182, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -8,28 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {ast, attr};\n-use syntax_pos::{Span, DUMMY_SP};\n use edition::Edition;\n-use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n-use ext::base::{NormalTT, TTMacroExpander};\n-use ext::expand::{AstFragment, AstFragmentKind};\n-use ext::tt::macro_parser::{Success, Error, Failure};\n-use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n-use ext::tt::macro_parser::{parse, parse_failure_msg};\n-use ext::tt::quoted;\n-use ext::tt::transcribe::transcribe;\n+use ext::{\n+    base::{DummyResult, ExtCtxt, MacResult, NormalTT, SyntaxExtension, TTMacroExpander},\n+    expand::{AstFragment, AstFragmentKind},\n+    tt::{\n+        macro_parser::{\n+            parse, parse_failure_msg, Error, Failure, MatchedNonterminal, MatchedSeq, Success,\n+        },\n+        quoted,\n+        transcribe::transcribe,\n+    },\n+};\n use feature_gate::{self, emit_feature_err, Features, GateIssue};\n-use parse::{Directory, ParseSess};\n-use parse::parser::Parser;\n-use parse::token::{self, NtTT};\n-use parse::token::Token::*;\n+use parse::{\n+    parser::Parser,\n+    token::{self, NtTT, Token::*},\n+    Directory, ParseSess,\n+};\n use symbol::Symbol;\n+use syntax_pos::{Span, DUMMY_SP};\n use tokenstream::{TokenStream, TokenTree};\n+use {ast, attr};\n \n-use std::borrow::Cow;\n-use std::collections::HashMap;\n-use std::collections::hash_map::Entry;\n+use std::{\n+    borrow::Cow,\n+    collections::{hash_map::Entry, HashMap},\n+};\n \n use rustc_data_structures::sync::Lrc;\n \n@@ -39,12 +44,16 @@ pub struct ParserAnyMacro<'a> {\n     /// Span of the expansion site of the macro this parser is for\n     site_span: Span,\n     /// The ident of the macro we're parsing\n-    macro_ident: ast::Ident\n+    macro_ident: ast::Ident,\n }\n \n impl<'a> ParserAnyMacro<'a> {\n     pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n-        let ParserAnyMacro { site_span, macro_ident, ref mut parser } = *self;\n+        let ParserAnyMacro {\n+            site_span,\n+            macro_ident,\n+            ref mut parser,\n+        } = *self;\n         let fragment = panictry!(parser.parse_ast_fragment(kind, true));\n \n         // We allow semicolons at the end of expressions -- e.g. the semicolon in\n@@ -77,17 +86,16 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         if !self.valid {\n             return DummyResult::any(sp);\n         }\n-        generic_extension(cx,\n-                          sp,\n-                          self.name,\n-                          input,\n-                          &self.lhses,\n-                          &self.rhses)\n+        generic_extension(cx, sp, self.name, input, &self.lhses, &self.rhses)\n     }\n }\n \n fn trace_macros_note(cx: &mut ExtCtxt, sp: Span, message: String) {\n-    let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n+    let sp = sp\n+        .macro_backtrace()\n+        .last()\n+        .map(|trace| trace.call_site)\n+        .unwrap_or(sp);\n     let values: &mut Vec<String> = cx.expansions.entry(sp).or_insert_with(Vec::new);\n     values.push(message);\n }\n@@ -108,10 +116,11 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n     let mut best_fail_spot = DUMMY_SP;\n     let mut best_fail_tok = None;\n \n-    for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n+    for (i, lhs) in lhses.iter().enumerate() {\n+        // try each arm's matchers\n         let lhs_tt = match *lhs {\n             quoted::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n-            _ => cx.span_bug(sp, \"malformed macro lhs\")\n+            _ => cx.span_bug(sp, \"malformed macro lhs\"),\n         };\n \n         match TokenTree::parse(cx, lhs_tt, arg.clone()) {\n@@ -147,7 +156,11 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                     ownership: cx.current_expansion.directory_ownership,\n                 };\n                 let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), true, false);\n-                p.root_module_name = cx.current_expansion.module.mod_path.last()\n+                p.root_module_name = cx\n+                    .current_expansion\n+                    .module\n+                    .mod_path\n+                    .last()\n                     .map(|id| id.as_str().to_string());\n \n                 p.process_potential_macro_variable();\n@@ -160,16 +173,14 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                     // so we can print a useful error message if the parse of the expanded\n                     // macro leaves unparsed tokens.\n                     site_span: sp,\n-                    macro_ident: name\n-                })\n+                    macro_ident: name,\n+                });\n             }\n             Failure(sp, tok) => if sp.lo() >= best_fail_spot.lo() {\n                 best_fail_spot = sp;\n                 best_fail_tok = Some(tok);\n             },\n-            Error(err_sp, ref msg) => {\n-                cx.span_fatal(err_sp.substitute_dummy(sp), &msg[..])\n-            }\n+            Error(err_sp, ref msg) => cx.span_fatal(err_sp.substitute_dummy(sp), &msg[..]),\n         }\n     }\n \n@@ -185,8 +196,12 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition: Edition)\n-               -> SyntaxExtension {\n+pub fn compile(\n+    sess: &ParseSess,\n+    features: &Features,\n+    def: &ast::Item,\n+    edition: Edition,\n+) -> SyntaxExtension {\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n@@ -202,69 +217,105 @@ pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition:\n     // ...quasiquoting this would be nice.\n     // These spans won't matter, anyways\n     let argument_gram = vec![\n-        quoted::TokenTree::Sequence(DUMMY_SP, Lrc::new(quoted::SequenceRepetition {\n-            tts: vec![\n-                quoted::TokenTree::MetaVarDecl(DUMMY_SP, lhs_nm, ast::Ident::from_str(\"tt\")),\n-                quoted::TokenTree::Token(DUMMY_SP, token::FatArrow),\n-                quoted::TokenTree::MetaVarDecl(DUMMY_SP, rhs_nm, ast::Ident::from_str(\"tt\")),\n-            ],\n-            separator: Some(if body.legacy { token::Semi } else { token::Comma }),\n-            op: quoted::KleeneOp::OneOrMore,\n-            num_captures: 2,\n-        })),\n+        quoted::TokenTree::Sequence(\n+            DUMMY_SP,\n+            Lrc::new(quoted::SequenceRepetition {\n+                tts: vec![\n+                    quoted::TokenTree::MetaVarDecl(DUMMY_SP, lhs_nm, ast::Ident::from_str(\"tt\")),\n+                    quoted::TokenTree::Token(DUMMY_SP, token::FatArrow),\n+                    quoted::TokenTree::MetaVarDecl(DUMMY_SP, rhs_nm, ast::Ident::from_str(\"tt\")),\n+                ],\n+                separator: Some(if body.legacy {\n+                    token::Semi\n+                } else {\n+                    token::Comma\n+                }),\n+                op: quoted::KleeneOp::OneOrMore,\n+                num_captures: 2,\n+            }),\n+        ),\n         // to phase into semicolon-termination instead of semicolon-separation\n-        quoted::TokenTree::Sequence(DUMMY_SP, Lrc::new(quoted::SequenceRepetition {\n-            tts: vec![quoted::TokenTree::Token(DUMMY_SP, token::Semi)],\n-            separator: None,\n-            op: quoted::KleeneOp::ZeroOrMore,\n-            num_captures: 0\n-        })),\n+        quoted::TokenTree::Sequence(\n+            DUMMY_SP,\n+            Lrc::new(quoted::SequenceRepetition {\n+                tts: vec![quoted::TokenTree::Token(DUMMY_SP, token::Semi)],\n+                separator: None,\n+                op: quoted::KleeneOp::ZeroOrMore,\n+                num_captures: 0,\n+            }),\n+        ),\n     ];\n \n     let argument_map = match parse(sess, body.stream(), &argument_gram, None, true) {\n         Success(m) => m,\n         Failure(sp, tok) => {\n             let s = parse_failure_msg(tok);\n-            sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &s).raise();\n+            sess.span_diagnostic\n+                .span_fatal(sp.substitute_dummy(def.span), &s)\n+                .raise();\n         }\n         Error(sp, s) => {\n-            sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &s).raise();\n+            sess.span_diagnostic\n+                .span_fatal(sp.substitute_dummy(def.span), &s)\n+                .raise();\n         }\n     };\n \n     let mut valid = true;\n \n     // Extract the arguments:\n     let lhses = match *argument_map[&lhs_nm] {\n-        MatchedSeq(ref s, _) => {\n-            s.iter().map(|m| {\n+        MatchedSeq(ref s, _) => s\n+            .iter()\n+            .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = quoted::parse(tt.clone().into(), true, sess, features, &def.attrs)\n-                            .pop().unwrap();\n+                        let tt = quoted::parse(\n+                            tt.clone().into(),\n+                            true,\n+                            sess,\n+                            features,\n+                            &def.attrs,\n+                            edition,\n+                        ).pop()\n+                            .unwrap();\n                         valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n                 }\n-                sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n-            }).collect::<Vec<quoted::TokenTree>>()\n-        }\n-        _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n+                sess.span_diagnostic\n+                    .span_bug(def.span, \"wrong-structured lhs\")\n+            })\n+            .collect::<Vec<quoted::TokenTree>>(),\n+        _ => sess\n+            .span_diagnostic\n+            .span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n     let rhses = match *argument_map[&rhs_nm] {\n-        MatchedSeq(ref s, _) => {\n-            s.iter().map(|m| {\n+        MatchedSeq(ref s, _) => s\n+            .iter()\n+            .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return quoted::parse(tt.clone().into(), false, sess, features, &def.attrs)\n-                            .pop().unwrap();\n+                        return quoted::parse(\n+                            tt.clone().into(),\n+                            false,\n+                            sess,\n+                            features,\n+                            &def.attrs,\n+                            edition,\n+                        ).pop()\n+                            .unwrap();\n                     }\n                 }\n-                sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n-            }).collect::<Vec<quoted::TokenTree>>()\n-        }\n-        _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\")\n+                sess.span_diagnostic\n+                    .span_bug(def.span, \"wrong-structured lhs\")\n+            })\n+            .collect::<Vec<quoted::TokenTree>>(),\n+        _ => sess\n+            .span_diagnostic\n+            .span_bug(def.span, \"wrong-structured rhs\"),\n     };\n \n     for rhs in &rhses {\n@@ -293,14 +344,14 @@ pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition:\n             }\n         }\n \n-        let unstable_feature = attr::find_stability(&sess.span_diagnostic,\n-                                                    &def.attrs, def.span).and_then(|stability| {\n-            if let attr::StabilityLevel::Unstable { issue, .. } = stability.level {\n-                Some((stability.feature, issue))\n-            } else {\n-                None\n-            }\n-        });\n+        let unstable_feature = attr::find_stability(&sess.span_diagnostic, &def.attrs, def.span)\n+            .and_then(|stability| {\n+                if let attr::StabilityLevel::Unstable { issue, .. } = stability.level {\n+                    Some((stability.feature, issue))\n+                } else {\n+                    None\n+                }\n+            });\n \n         NormalTT {\n             expander,\n@@ -323,10 +374,12 @@ pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition:\n     }\n }\n \n-fn check_lhs_nt_follows(sess: &ParseSess,\n-                        features: &Features,\n-                        attrs: &[ast::Attribute],\n-                        lhs: &quoted::TokenTree) -> bool {\n+fn check_lhs_nt_follows(\n+    sess: &ParseSess,\n+    features: &Features,\n+    attrs: &[ast::Attribute],\n+    lhs: &quoted::TokenTree,\n+) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     if let quoted::TokenTree::Delimited(_, ref tts) = *lhs {\n@@ -351,15 +404,15 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n                 return false;\n             },\n             TokenTree::Sequence(span, ref seq) => {\n-                if seq.separator.is_none() && seq.tts.iter().all(|seq_tt| {\n-                    match *seq_tt {\n-                        TokenTree::MetaVarDecl(_, _, id) => id.name == \"vis\",\n-                        TokenTree::Sequence(_, ref sub_seq) =>\n-                            sub_seq.op == quoted::KleeneOp::ZeroOrMore,\n-                        _ => false,\n+                if seq.separator.is_none() && seq.tts.iter().all(|seq_tt| match *seq_tt {\n+                    TokenTree::MetaVarDecl(_, _, id) => id.name == \"vis\",\n+                    TokenTree::Sequence(_, ref sub_seq) => {\n+                        sub_seq.op == quoted::KleeneOp::ZeroOrMore\n                     }\n+                    _ => false,\n                 }) {\n-                    sess.span_diagnostic.span_err(span, \"repetition matches empty token tree\");\n+                    sess.span_diagnostic\n+                        .span_err(span, \"repetition matches empty token tree\");\n                     return false;\n                 }\n                 if !check_lhs_no_empty_seq(sess, &seq.tts) {\n@@ -375,15 +428,19 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n     match *rhs {\n         quoted::TokenTree::Delimited(..) => return true,\n-        _ => sess.span_diagnostic.span_err(rhs.span(), \"macro rhs must be delimited\")\n+        _ => sess\n+            .span_diagnostic\n+            .span_err(rhs.span(), \"macro rhs must be delimited\"),\n     }\n     false\n }\n \n-fn check_matcher(sess: &ParseSess,\n-                 features: &Features,\n-                 attrs: &[ast::Attribute],\n-                 matcher: &[quoted::TokenTree]) -> bool {\n+fn check_matcher(\n+    sess: &ParseSess,\n+    features: &Features,\n+    attrs: &[ast::Attribute],\n+    matcher: &[quoted::TokenTree],\n+) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n     let err = sess.span_diagnostic.err_count();\n@@ -417,7 +474,9 @@ impl FirstSets {\n     fn new(tts: &[quoted::TokenTree]) -> FirstSets {\n         use self::quoted::TokenTree;\n \n-        let mut sets = FirstSets { first: HashMap::new() };\n+        let mut sets = FirstSets {\n+            first: HashMap::new(),\n+        };\n         build_recur(&mut sets, tts);\n         return sets;\n \n@@ -456,16 +515,20 @@ impl FirstSets {\n                         // If the sequence contents can be empty, then the first\n                         // token could be the separator token itself.\n \n-                        if let (Some(ref sep), true) = (seq_rep.separator.clone(),\n-                                                        subfirst.maybe_empty) {\n+                        if let (Some(ref sep), true) =\n+                            (seq_rep.separator.clone(), subfirst.maybe_empty)\n+                        {\n                             first.add_one_maybe(TokenTree::Token(sp, sep.clone()));\n                         }\n \n                         // Reverse scan: Sequence comes before `first`.\n                         if subfirst.maybe_empty || seq_rep.op == quoted::KleeneOp::ZeroOrMore {\n                             // If sequence is potentially empty, then\n                             // union them (preserving first emptiness).\n-                            first.add_all(&TokenSet { maybe_empty: true, ..subfirst });\n+                            first.add_all(&TokenSet {\n+                                maybe_empty: true,\n+                                ..subfirst\n+                            });\n                         } else {\n                             // Otherwise, sequence guaranteed\n                             // non-empty; replace first.\n@@ -499,19 +562,18 @@ impl FirstSets {\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n                     match self.first.get(&sp) {\n                         Some(&Some(ref subfirst)) => {\n-\n                             // If the sequence contents can be empty, then the first\n                             // token could be the separator token itself.\n \n-                            if let (Some(ref sep), true) = (seq_rep.separator.clone(),\n-                                                            subfirst.maybe_empty) {\n+                            if let (Some(ref sep), true) =\n+                                (seq_rep.separator.clone(), subfirst.maybe_empty)\n+                            {\n                                 first.add_one_maybe(TokenTree::Token(sp, sep.clone()));\n                             }\n \n                             assert!(first.maybe_empty);\n                             first.add_all(subfirst);\n-                            if subfirst.maybe_empty ||\n-                               seq_rep.op == quoted::KleeneOp::ZeroOrMore {\n+                            if subfirst.maybe_empty || seq_rep.op == quoted::KleeneOp::ZeroOrMore {\n                                 // continue scanning for more first\n                                 // tokens, but also make sure we\n                                 // restore empty-tracking state\n@@ -559,12 +621,20 @@ struct TokenSet {\n \n impl TokenSet {\n     // Returns a set for the empty sequence.\n-    fn empty() -> Self { TokenSet { tokens: Vec::new(), maybe_empty: true } }\n+    fn empty() -> Self {\n+        TokenSet {\n+            tokens: Vec::new(),\n+            maybe_empty: true,\n+        }\n+    }\n \n     // Returns the set `{ tok }` for the single-token (and thus\n     // non-empty) sequence [tok].\n     fn singleton(tok: quoted::TokenTree) -> Self {\n-        TokenSet { tokens: vec![tok], maybe_empty: false }\n+        TokenSet {\n+            tokens: vec![tok],\n+            maybe_empty: false,\n+        }\n     }\n \n     // Changes self to be the set `{ tok }`.\n@@ -628,12 +698,14 @@ impl TokenSet {\n //\n // Requires that `first_sets` is pre-computed for `matcher`;\n // see `FirstSets::new`.\n-fn check_matcher_core(sess: &ParseSess,\n-                      features: &Features,\n-                      attrs: &[ast::Attribute],\n-                      first_sets: &FirstSets,\n-                      matcher: &[quoted::TokenTree],\n-                      follow: &TokenSet) -> TokenSet {\n+fn check_matcher_core(\n+    sess: &ParseSess,\n+    features: &Features,\n+    attrs: &[ast::Attribute],\n+    first_sets: &FirstSets,\n+    matcher: &[quoted::TokenTree],\n+    follow: &TokenSet,\n+) -> TokenSet {\n     use self::quoted::TokenTree;\n \n     let mut last = TokenSet::empty();\n@@ -643,11 +715,13 @@ fn check_matcher_core(sess: &ParseSess,\n     // then ensure T can also be followed by any element of FOLLOW.\n     'each_token: for i in 0..matcher.len() {\n         let token = &matcher[i];\n-        let suffix = &matcher[i+1..];\n+        let suffix = &matcher[i + 1..];\n \n         let build_suffix_first = || {\n             let mut s = first_sets.first(suffix);\n-            if s.maybe_empty { s.add_all(follow); }\n+            if s.maybe_empty {\n+                s.add_all(follow);\n+            }\n             s\n         };\n \n@@ -663,9 +737,12 @@ fn check_matcher_core(sess: &ParseSess,\n                 let can_be_followed_by_any;\n                 if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, attrs, token) {\n                     let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n-                    sess.span_diagnostic.struct_span_err(token.span(), &msg)\n-                        .help(\"valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, \\\n-                              `pat`, `ty`, `literal`, `path`, `meta`, `tt`, `item` and `vis`\")\n+                    sess.span_diagnostic\n+                        .struct_span_err(token.span(), &msg)\n+                        .help(\n+                            \"valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, \\\n+                             `pat`, `ty`, `literal`, `path`, `meta`, `tt`, `item` and `vis`\",\n+                        )\n                         .emit();\n                     // (This eliminates false positives and duplicates\n                     // from error messages.)\n@@ -719,12 +796,8 @@ fn check_matcher_core(sess: &ParseSess,\n                 // At this point, `suffix_first` is built, and\n                 // `my_suffix` is some TokenSet that we can use\n                 // for checking the interior of `seq_rep`.\n-                let next = check_matcher_core(sess,\n-                                              features,\n-                                              attrs,\n-                                              first_sets,\n-                                              &seq_rep.tts,\n-                                              my_suffix);\n+                let next =\n+                    check_matcher_core(sess, features, attrs, first_sets, &seq_rep.tts, my_suffix);\n                 if next.maybe_empty {\n                     last.add_all(&next);\n                 } else {\n@@ -746,16 +819,17 @@ fn check_matcher_core(sess: &ParseSess,\n                 for next_token in &suffix_first.tokens {\n                     match is_in_follow(next_token, &frag_spec.as_str()) {\n                         Err((msg, help)) => {\n-                            sess.span_diagnostic.struct_span_err(next_token.span(), &msg)\n-                                .help(help).emit();\n+                            sess.span_diagnostic\n+                                .struct_span_err(next_token.span(), &msg)\n+                                .help(help)\n+                                .emit();\n                             // don't bother reporting every source of\n                             // conflict for a particular element of `last`.\n                             continue 'each_last;\n                         }\n                         Ok(true) => {}\n                         Ok(false) => {\n-                            let may_be = if last.tokens.len() == 1 &&\n-                                suffix_first.tokens.len() == 1\n+                            let may_be = if last.tokens.len() == 1 && suffix_first.tokens.len() == 1\n                             {\n                                 \"is\"\n                             } else {\n@@ -764,12 +838,14 @@ fn check_matcher_core(sess: &ParseSess,\n \n                             sess.span_diagnostic.span_err(\n                                 next_token.span(),\n-                                &format!(\"`${name}:{frag}` {may_be} followed by `{next}`, which \\\n-                                          is not allowed for `{frag}` fragments\",\n-                                         name=name,\n-                                         frag=frag_spec,\n-                                         next=quoted_tt_to_string(next_token),\n-                                         may_be=may_be)\n+                                &format!(\n+                                    \"`${name}:{frag}` {may_be} followed by `{next}`, which \\\n+                                     is not allowed for `{frag}` fragments\",\n+                                    name = name,\n+                                    frag = frag_spec,\n+                                    next = quoted_tt_to_string(next_token),\n+                                    may_be = may_be\n+                                ),\n                             );\n                         }\n                     }\n@@ -834,77 +910,90 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n                 // since items *must* be followed by either a `;` or a `}`, we can\n                 // accept anything after them\n                 Ok(true)\n-            },\n+            }\n             \"block\" => {\n                 // anything can follow block, the braces provide an easy boundary to\n                 // maintain\n                 Ok(true)\n-            },\n-            \"stmt\" | \"expr\"  => match *tok {\n+            }\n+            \"stmt\" | \"expr\" => match *tok {\n                 TokenTree::Token(_, ref tok) => match *tok {\n                     FatArrow | Comma | Semi => Ok(true),\n-                    _ => Ok(false)\n+                    _ => Ok(false),\n                 },\n                 _ => Ok(false),\n             },\n             \"pat\" => match *tok {\n                 TokenTree::Token(_, ref tok) => match *tok {\n                     FatArrow | Comma | Eq | BinOp(token::Or) => Ok(true),\n                     Ident(i, false) if i.name == \"if\" || i.name == \"in\" => Ok(true),\n-                    _ => Ok(false)\n+                    _ => Ok(false),\n                 },\n                 _ => Ok(false),\n             },\n             \"path\" | \"ty\" => match *tok {\n                 TokenTree::Token(_, ref tok) => match *tok {\n-                    OpenDelim(token::DelimToken::Brace) | OpenDelim(token::DelimToken::Bracket) |\n-                    Comma | FatArrow | Colon | Eq | Gt | Semi | BinOp(token::Or) => Ok(true),\n+                    OpenDelim(token::DelimToken::Brace)\n+                    | OpenDelim(token::DelimToken::Bracket)\n+                    | Comma\n+                    | FatArrow\n+                    | Colon\n+                    | Eq\n+                    | Gt\n+                    | Semi\n+                    | BinOp(token::Or) => Ok(true),\n                     Ident(i, false) if i.name == \"as\" || i.name == \"where\" => Ok(true),\n-                    _ => Ok(false)\n+                    _ => Ok(false),\n                 },\n                 TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"block\" => Ok(true),\n                 _ => Ok(false),\n             },\n             \"ident\" | \"lifetime\" => {\n                 // being a single token, idents and lifetimes are harmless\n                 Ok(true)\n-            },\n+            }\n             \"literal\" => {\n                 // literals may be of a single token, or two tokens (negative numbers)\n                 Ok(true)\n-            },\n+            }\n             \"meta\" | \"tt\" => {\n                 // being either a single token or a delimited sequence, tt is\n                 // harmless\n                 Ok(true)\n-            },\n+            }\n             \"vis\" => {\n                 // Explicitly disallow `priv`, on the off chance it comes back.\n                 match *tok {\n                     TokenTree::Token(_, ref tok) => match *tok {\n                         Comma => Ok(true),\n                         Ident(i, is_raw) if is_raw || i.name != \"priv\" => Ok(true),\n-                        ref tok => Ok(tok.can_begin_type())\n+                        ref tok => Ok(tok.can_begin_type()),\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"ident\"\n-                                                       || frag.name == \"ty\"\n-                                                       || frag.name == \"path\" => Ok(true),\n-                    _ => Ok(false)\n+                    TokenTree::MetaVarDecl(_, _, frag)\n+                        if frag.name == \"ident\" || frag.name == \"ty\" || frag.name == \"path\" =>\n+                    {\n+                        Ok(true)\n+                    }\n+                    _ => Ok(false),\n                 }\n-            },\n+            }\n             \"\" => Ok(true), // keywords::Invalid\n-            _ => Err((format!(\"invalid fragment specifier `{}`\", frag),\n-                     \"valid fragment specifiers are `ident`, `block`, \\\n-                      `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt`, \\\n-                      `literal`, `item` and `vis`\"))\n+            _ => Err((\n+                format!(\"invalid fragment specifier `{}`\", frag),\n+                \"valid fragment specifiers are `ident`, `block`, \\\n+                 `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt`, \\\n+                 `literal`, `item` and `vis`\",\n+            )),\n         }\n     }\n }\n \n-fn has_legal_fragment_specifier(sess: &ParseSess,\n-                                features: &Features,\n-                                attrs: &[ast::Attribute],\n-                                tok: &quoted::TokenTree) -> Result<(), String> {\n+fn has_legal_fragment_specifier(\n+    sess: &ParseSess,\n+    features: &Features,\n+    attrs: &[ast::Attribute],\n+    tok: &quoted::TokenTree,\n+) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n     if let quoted::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n         let frag_name = frag_spec.as_str();\n@@ -916,38 +1005,45 @@ fn has_legal_fragment_specifier(sess: &ParseSess,\n     Ok(())\n }\n \n-fn is_legal_fragment_specifier(sess: &ParseSess,\n-                               features: &Features,\n-                               attrs: &[ast::Attribute],\n-                               frag_name: &str,\n-                               frag_span: Span) -> bool {\n+fn is_legal_fragment_specifier(\n+    sess: &ParseSess,\n+    features: &Features,\n+    attrs: &[ast::Attribute],\n+    frag_name: &str,\n+    frag_span: Span,\n+) -> bool {\n     match frag_name {\n-        \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" | \"lifetime\" |\n-        \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n+        \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" | \"lifetime\" | \"path\" | \"ty\" | \"ident\"\n+        | \"meta\" | \"tt\" | \"\" => true,\n         \"literal\" => {\n-            if !features.macro_literal_matcher &&\n-               !attr::contains_name(attrs, \"allow_internal_unstable\") {\n+            if !features.macro_literal_matcher\n+                && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+            {\n                 let explain = feature_gate::EXPLAIN_LITERAL_MATCHER;\n-                emit_feature_err(sess,\n-                                 \"macro_literal_matcher\",\n-                                 frag_span,\n-                                 GateIssue::Language,\n-                                 explain);\n+                emit_feature_err(\n+                    sess,\n+                    \"macro_literal_matcher\",\n+                    frag_span,\n+                    GateIssue::Language,\n+                    explain,\n+                );\n             }\n             true\n-        },\n+        }\n         \"vis\" => {\n-            if !features.macro_vis_matcher &&\n-               !attr::contains_name(attrs, \"allow_internal_unstable\") {\n+            if !features.macro_vis_matcher && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+            {\n                 let explain = feature_gate::EXPLAIN_VIS_MATCHER;\n-                emit_feature_err(sess,\n-                                 \"macro_vis_matcher\",\n-                                 frag_span,\n-                                 GateIssue::Language,\n-                                 explain);\n+                emit_feature_err(\n+                    sess,\n+                    \"macro_vis_matcher\",\n+                    frag_span,\n+                    GateIssue::Language,\n+                    explain,\n+                );\n             }\n             true\n-        },\n+        }\n         _ => false,\n     }\n }\n@@ -957,7 +1053,9 @@ fn quoted_tt_to_string(tt: &quoted::TokenTree) -> String {\n         quoted::TokenTree::Token(_, ref tok) => ::print::pprust::token_to_string(tok),\n         quoted::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n         quoted::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n-        _ => panic!(\"unexpected quoted::TokenTree::{{Sequence or Delimited}} \\\n-                     in follow set checker\"),\n+        _ => panic!(\n+            \"unexpected quoted::TokenTree::{{Sequence or Delimited}} \\\n+             in follow set checker\"\n+        ),\n     }\n }"}, {"sha": "1bca6dd065323d168079eef9b6b81db31e61e84d", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 196, "deletions": 67, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {ast, attr};\n use ext::tt::macro_parser;\n use feature_gate::{self, emit_feature_err, Features, GateIssue};\n use parse::{token, ParseSess};\n use print::pprust;\n use symbol::keywords;\n-use syntax_pos::{BytePos, Span};\n+use syntax_pos::{edition::Edition, BytePos, Span, DUMMY_SP};\n use tokenstream;\n+use {ast, attr};\n \n-use std::iter::Peekable;\n use rustc_data_structures::sync::Lrc;\n+use std::iter::Peekable;\n \n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n /// that the delimiter itself might be `NoDelim`.\n@@ -174,6 +174,7 @@ impl TokenTree {\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n ///   unstable features or not.\n+/// - `edition`: which edition are we in.\n ///\n /// # Returns\n ///\n@@ -184,6 +185,7 @@ pub fn parse(\n     sess: &ParseSess,\n     features: &Features,\n     attrs: &[ast::Attribute],\n+    edition: Edition,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -194,7 +196,15 @@ pub fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e. in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, features, attrs);\n+        let tree = parse_tree(\n+            tree,\n+            &mut trees,\n+            expect_matchers,\n+            sess,\n+            features,\n+            attrs,\n+            edition,\n+        );\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -207,11 +217,13 @@ pub fn parse(\n                             }\n                             _ => end_sp,\n                         },\n-                        tree => tree.as_ref()\n+                        tree => tree\n+                            .as_ref()\n                             .map(tokenstream::TokenTree::span)\n                             .unwrap_or(span),\n                     },\n-                    tree => tree.as_ref()\n+                    tree => tree\n+                        .as_ref()\n                         .map(tokenstream::TokenTree::span)\n                         .unwrap_or(start_sp),\n                 };\n@@ -252,6 +264,7 @@ fn parse_tree<I>(\n     sess: &ParseSess,\n     features: &Features,\n     attrs: &[ast::Attribute],\n+    edition: Edition,\n ) -> TokenTree\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n@@ -270,9 +283,17 @@ where\n                     sess.span_diagnostic.span_err(span, &msg);\n                 }\n                 // Parse the contents of the sequence itself\n-                let sequence = parse(delimited.tts.into(), expect_matchers, sess, features, attrs);\n+                let sequence = parse(\n+                    delimited.tts.into(),\n+                    expect_matchers,\n+                    sess,\n+                    features,\n+                    attrs,\n+                    edition,\n+                );\n                 // Get the Kleene operator and optional separator\n-                let (separator, op) = parse_sep_and_kleene_op(trees, span, sess, features, attrs);\n+                let (separator, op) =\n+                    parse_sep_and_kleene_op(trees, span, sess, features, attrs, edition);\n                 // Count the number of captured \"names\" (i.e. named metavars)\n                 let name_captures = macro_parser::count_names(&sequence);\n                 TokenTree::Sequence(\n@@ -322,7 +343,14 @@ where\n             span,\n             Lrc::new(Delimited {\n                 delim: delimited.delim,\n-                tts: parse(delimited.tts.into(), expect_matchers, sess, features, attrs),\n+                tts: parse(\n+                    delimited.tts.into(),\n+                    expect_matchers,\n+                    sess,\n+                    features,\n+                    attrs,\n+                    edition,\n+                ),\n             }),\n         ),\n     }\n@@ -341,22 +369,23 @@ fn kleene_op(token: &token::Token) -> Option<KleeneOp> {\n \n /// Parse the next token tree of the input looking for a KleeneOp. Returns\n ///\n-/// - Ok(Ok(op)) if the next token tree is a KleeneOp\n+/// - Ok(Ok((op, span))) if the next token tree is a KleeneOp\n /// - Ok(Err(tok, span)) if the next token tree is a token but not a KleeneOp\n /// - Err(span) if the next token tree is not a token\n fn parse_kleene_op<I>(\n     input: &mut I,\n     span: Span,\n-) -> Result<Result<KleeneOp, (token::Token, Span)>, Span>\n+) -> Result<Result<(KleeneOp, Span), (token::Token, Span)>, Span>\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n {\n     match input.next() {\n         Some(tokenstream::TokenTree::Token(span, tok)) => match kleene_op(&tok) {\n-            Some(op) => Ok(Ok(op)),\n+            Some(op) => Ok(Ok((op, span))),\n             None => Ok(Err((tok, span))),\n         },\n-        tree => Err(tree.as_ref()\n+        tree => Err(tree\n+            .as_ref()\n             .map(tokenstream::TokenTree::span)\n             .unwrap_or(span)),\n     }\n@@ -374,12 +403,34 @@ where\n /// session `sess`. If the next one (or possibly two) tokens in `input` correspond to a Kleene\n /// operator and separator, then a tuple with `(separator, KleeneOp)` is returned. Otherwise, an\n /// error with the appropriate span is emitted to `sess` and a dummy value is returned.\n+///\n+/// NOTE: In 2015 edition, * and + are the only Kleene operators and `?` is a separator. In 2018,\n+/// `?` is a Kleene op and not a separator.\n fn parse_sep_and_kleene_op<I>(\n     input: &mut Peekable<I>,\n     span: Span,\n     sess: &ParseSess,\n     features: &Features,\n     attrs: &[ast::Attribute],\n+    edition: Edition,\n+) -> (Option<token::Token>, KleeneOp)\n+where\n+    I: Iterator<Item = tokenstream::TokenTree>,\n+{\n+    match edition {\n+        Edition::Edition2015 => parse_sep_and_kleene_op_2015(input, span, sess, features, attrs),\n+        Edition::Edition2018 => parse_sep_and_kleene_op_2018(input, span, sess, features, attrs),\n+        _ => unimplemented!(),\n+    }\n+}\n+\n+// `?` is a separator (with a migration warning) and never a KleeneOp.\n+fn parse_sep_and_kleene_op_2015<I>(\n+    input: &mut Peekable<I>,\n+    span: Span,\n+    sess: &ParseSess,\n+    _features: &Features,\n+    _attrs: &[ast::Attribute],\n ) -> (Option<token::Token>, KleeneOp)\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n@@ -388,14 +439,14 @@ where\n     let span = match parse_kleene_op(input, span) {\n         // #1 is a `+` or `*` KleeneOp\n         //\n-        // `?` is ambiguous: it could be a separator or a Kleene::ZeroOrOne, so we need to look\n-        // ahead one more token to be sure.\n-        Ok(Ok(op)) if op != KleeneOp::ZeroOrOne => return (None, op),\n-\n-        // #1 is `?` token, but it could be a Kleene::ZeroOrOne without a separator or it could\n-        // be a `?` separator followed by any Kleene operator. We need to look ahead 1 token to\n-        // find out which.\n-        Ok(Ok(op)) => {\n+        // `?` is ambiguous: it could be a separator (warning) or a Kleene::ZeroOrOne (error), so\n+        // we need to look ahead one more token to be sure.\n+        Ok(Ok((op, _))) if op != KleeneOp::ZeroOrOne => return (None, op),\n+\n+        // #1 is `?` token, but it could be a Kleene::ZeroOrOne (error in 2015) without a separator\n+        // or it could be a `?` separator followed by any Kleene operator. We need to look ahead 1\n+        // token to find out which.\n+        Ok(Ok((op, op1_span))) => {\n             assert_eq!(op, KleeneOp::ZeroOrOne);\n \n             // Lookahead at #2. If it is a KleenOp, then #1 is a separator.\n@@ -406,71 +457,147 @@ where\n             };\n \n             if is_1_sep {\n-                // #1 is a separator and #2 should be a KleepeOp::*\n+                // #1 is a separator and #2 should be a KleepeOp.\n                 // (N.B. We need to advance the input iterator.)\n                 match parse_kleene_op(input, span) {\n-                    // #2 is a KleeneOp (this is the only valid option) :)\n-                    Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n-                        if !features.macro_at_most_once_rep\n-                            && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-                        {\n-                            let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                            emit_feature_err(\n-                                sess,\n-                                \"macro_at_most_once_rep\",\n-                                span,\n-                                GateIssue::Language,\n-                                explain,\n-                            );\n-                        }\n+                    // #2 is `?`, which is not allowed as a Kleene op in 2015 edition.\n+                    Ok(Ok((op, op2_span))) if op == KleeneOp::ZeroOrOne => {\n+                        sess.span_diagnostic\n+                            .struct_span_err(op2_span, \"expected `*` or `+`\")\n+                            .note(\"`?` is not a macro repetition operator\")\n+                            .emit();\n+\n+                        // Return a dummy\n+                        return (None, KleeneOp::ZeroOrMore);\n+                    }\n+\n+                    // #2 is a Kleene op, which is the the only valid option\n+                    Ok(Ok((op, _))) => {\n+                        // Warn that `?` as a separator will be deprecated\n+                        sess.span_diagnostic.span_warn(\n+                            op1_span,\n+                            \"using `?` as a separator is deprecated and will be \\\n+                             a hard error in an upcoming edition\",\n+                        );\n+\n                         return (Some(token::Question), op);\n                     }\n-                    Ok(Ok(op)) => return (Some(token::Question), op),\n \n                     // #2 is a random token (this is an error) :(\n-                    Ok(Err((_, span))) => span,\n+                    Ok(Err((_, _))) => op1_span,\n \n                     // #2 is not even a token at all :(\n-                    Err(span) => span,\n+                    Err(_) => op1_span,\n                 }\n             } else {\n-                if !features.macro_at_most_once_rep\n-                    && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-                {\n-                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                    emit_feature_err(\n-                        sess,\n-                        \"macro_at_most_once_rep\",\n-                        span,\n-                        GateIssue::Language,\n-                        explain,\n-                    );\n-                }\n+                // `?` is not allowed as a Kleene op in 2015\n+                sess.span_diagnostic\n+                    .struct_span_err(op1_span, \"expected `*` or `+`\")\n+                    .note(\"`?` is not a macro repetition operator\")\n+                    .emit();\n+\n+                // Return a dummy\n+                return (None, KleeneOp::ZeroOrMore);\n+            }\n+        }\n+\n+        // #1 is a separator followed by #2, a KleeneOp\n+        Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n+            // #2 is a `?`, which is not allowed as a Kleene op in 2015 edition.\n+            Ok(Ok((op, op2_span))) if op == KleeneOp::ZeroOrOne => {\n+                sess.span_diagnostic\n+                    .struct_span_err(op2_span, \"expected `*` or `+`\")\n+                    .note(\"`?` is not a macro repetition operator\")\n+                    .emit();\n+\n+                // Return a dummy\n+                return (None, KleeneOp::ZeroOrMore);\n+            }\n+\n+            // #2 is a KleeneOp :D\n+            Ok(Ok((op, _))) => return (Some(tok), op),\n+\n+            // #2 is a random token :(\n+            Ok(Err((_, span))) => span,\n+\n+            // #2 is not a token at all :(\n+            Err(span) => span,\n+        },\n+\n+        // #1 is not a token\n+        Err(span) => span,\n+    };\n+\n+    sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n+\n+    // Return a dummy\n+    (None, KleeneOp::ZeroOrMore)\n+}\n+\n+// `?` is a Kleene op, not a separator\n+fn parse_sep_and_kleene_op_2018<I>(\n+    input: &mut Peekable<I>,\n+    span: Span,\n+    sess: &ParseSess,\n+    features: &Features,\n+    attrs: &[ast::Attribute],\n+) -> (Option<token::Token>, KleeneOp)\n+where\n+    I: Iterator<Item = tokenstream::TokenTree>,\n+{\n+    // We basically look at two token trees here, denoted as #1 and #2 below\n+    let span = match parse_kleene_op(input, span) {\n+        // #1 is a `?` (needs feature gate)\n+        Ok(Ok((op, op1_span))) if op == KleeneOp::ZeroOrOne => {\n+            if !features.macro_at_most_once_rep\n+                && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+            {\n+                let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                emit_feature_err(\n+                    sess,\n+                    \"macro_at_most_once_rep\",\n+                    op1_span,\n+                    GateIssue::Language,\n+                    explain,\n+                );\n \n-                // #2 is a random tree and #1 is KleeneOp::ZeroOrOne\n+                op1_span\n+            } else {\n                 return (None, op);\n             }\n         }\n \n+        // #1 is a `+` or `*` KleeneOp\n+        Ok(Ok((op, _))) => return (None, op),\n+\n         // #1 is a separator followed by #2, a KleeneOp\n         Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n-            // #2 is a KleeneOp :D\n-            Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n+            // #2 is the `?` Kleene op, which does not take a separator (error)\n+            Ok(Ok((op, op2_span))) if op == KleeneOp::ZeroOrOne => {\n+                // Error!\n+\n                 if !features.macro_at_most_once_rep\n                     && !attr::contains_name(attrs, \"allow_internal_unstable\")\n                 {\n-                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                    emit_feature_err(\n-                        sess,\n-                        \"macro_at_most_once_rep\",\n+                    // FIXME: when `?` as a Kleene op is stabilized, we only need the \"does not\n+                    // take a macro separator\" error (i.e. the `else` case).\n+                    sess.span_diagnostic\n+                        .struct_span_err(op2_span, \"expected `*` or `+`\")\n+                        .note(\"`?` is not a macro repetition operator\")\n+                        .emit();\n+                } else {\n+                    sess.span_diagnostic.span_err(\n                         span,\n-                        GateIssue::Language,\n-                        explain,\n+                        \"the `?` macro repetition operator does not take a separator\",\n                     );\n                 }\n-                return (Some(tok), op);\n+\n+                // Return a dummy\n+                return (None, KleeneOp::ZeroOrMore);\n             }\n-            Ok(Ok(op)) => return (Some(tok), op),\n+\n+            // #2 is a KleeneOp :D\n+            Ok(Ok((op, _))) => return (Some(tok), op),\n \n             // #2 is a random token :(\n             Ok(Err((_, span))) => span,\n@@ -483,13 +610,15 @@ where\n         Err(span) => span,\n     };\n \n-    if !features.macro_at_most_once_rep\n-        && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-    {\n+    // If we ever get to this point, we have experienced an \"unexpected token\" error\n+\n+    if !features.macro_at_most_once_rep && !attr::contains_name(attrs, \"allow_internal_unstable\") {\n+        sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n+    } else {\n         sess.span_diagnostic\n             .span_err(span, \"expected one of: `*`, `+`, or `?`\");\n-    } else {\n-        sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n     }\n+\n+    // Return a dummy\n     (None, KleeneOp::ZeroOrMore)\n }"}, {"sha": "15d491719a6d58dd8edf2350edd32d3309d98fee", "filename": "src/test/parse-fail/issue-33569.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fparse-fail%2Fissue-33569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fparse-fail%2Fissue-33569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-33569.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -13,7 +13,7 @@\n macro_rules! foo {\n     { $+ } => { //~ ERROR expected identifier, found `+`\n                 //~^ ERROR missing fragment specifier\n-        $(x)(y) //~ ERROR expected one of: `*`, `+`, or `?`\n+        $(x)(y) //~ ERROR expected `*` or `+`\n     }\n }\n "}, {"sha": "664e9eeb3e04efe936a401fa835dc276dc949f70", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -29,11 +29,9 @@ use syntax::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use syntax::ext::tt::macro_parser::{Success, Failure, Error};\n use syntax::ext::tt::macro_parser::parse_failure_msg;\n use syntax::ptr::P;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, edition::Edition};\n use rustc_plugin::Registry;\n \n-use std::cell::RefCell;\n-\n fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n         -> Box<MacResult + 'static> {\n \n@@ -42,7 +40,8 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n                                     true,\n                                     cx.parse_sess,\n                                     &Features::new(),\n-                                    &[]);\n+                                    &[],\n+                                    Edition::Edition2015);\n     let map = match TokenTree::parse(cx, &mbe_matcher, args.iter().cloned().collect()) {\n         Success(map) => map,\n         Failure(_, tok) => {"}, {"sha": "dcf2222ba6dea18a012768b49d4f0db05957bc97", "filename": "src/test/run-pass/macro-at-most-once-rep.rs", "status": "modified", "additions": 2, "deletions": 47, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -18,6 +18,8 @@\n //\n // This test focuses on non-error cases and making sure the correct number of repetitions happen.\n \n+// compile-flags: --edition=2018\n+\n #![feature(macro_at_most_once_rep)]\n \n macro_rules! foo {\n@@ -32,57 +34,10 @@ macro_rules! foo {\n     } }\n }\n \n-macro_rules! baz {\n-    ($($a:ident),? ; $num:expr) => { { // comma separator is meaningless for `?`\n-        let mut x = 0;\n-\n-        $(\n-            x += $a;\n-         )?\n-\n-        assert_eq!(x, $num);\n-    } }\n-}\n-\n-macro_rules! barplus {\n-    ($($a:ident)?+ ; $num:expr) => { {\n-        let mut x = 0;\n-\n-        $(\n-            x += $a;\n-         )+\n-\n-        assert_eq!(x, $num);\n-    } }\n-}\n-\n-macro_rules! barstar {\n-    ($($a:ident)?* ; $num:expr) => { {\n-        let mut x = 0;\n-\n-        $(\n-            x += $a;\n-         )*\n-\n-        assert_eq!(x, $num);\n-    } }\n-}\n-\n pub fn main() {\n     let a = 1;\n \n     // accept 0 or 1 repetitions\n     foo!( ; 0);\n     foo!(a ; 1);\n-    baz!( ; 0);\n-    baz!(a ; 1);\n-\n-    // Make sure using ? as a separator works as before\n-    barplus!(a ; 1);\n-    barplus!(a?a ; 2);\n-    barplus!(a?a?a ; 3);\n-    barstar!( ; 0);\n-    barstar!(a ; 1);\n-    barstar!(a?a ; 2);\n-    barstar!(a?a?a ; 3);\n }"}, {"sha": "9ca71d937f8598dadfd363d0af6e11731b42df55", "filename": "src/test/ui/feature-gate-macro_at_most_once_rep.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a7ae04a6872edd8a1bffa620fde53a2eb2964e1/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a7ae04a6872edd8a1bffa620fde53a2eb2964e1/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr?ref=2a7ae04a6872edd8a1bffa620fde53a2eb2964e1", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: using the `?` macro Kleene operator for \"at most one\" repetition is unstable (see issue #48075)\n-  --> $DIR/feature-gate-macro_at_most_once_rep.rs:14:20\n-   |\n-LL | macro_rules! m { ($(a)?) => {} }\n-   |                    ^^^\n-   |\n-   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "15eef429eab974667e3ea77daaada669acb10ccc", "filename": "src/test/ui/issue-39388.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fissue-39388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fissue-39388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-39388.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -11,7 +11,7 @@\n #![allow(unused_macros)]\n \n macro_rules! assign {\n-    (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected one of: `*`, `+`, or `?`\n+    (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected `*` or `+`\n         $($a)* = $($b)*\n     }\n }"}, {"sha": "fd7925ea3eeeb07bf1821fa8d6ae55396f80892b", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-rep-feature-flag.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test behavior of `?` macro _kleene op_ under the 2015 edition. Namely, it doesn't exist, even\n+// with the feature flag.\n+\n+// gate-test-macro_at_most_once_rep\n+// compile-flags: --edition=2015\n+\n+#![feature(macro_at_most_once_rep)]\n+\n+macro_rules! bar {\n+    ($(a)?) => {} //~ERROR expected `*` or `+`\n+}\n+\n+macro_rules! baz {\n+    ($(a),?) => {} //~ERROR expected `*` or `+`\n+}\n+\n+fn main() {}\n+"}, {"sha": "5f687900421bf4823aaedb95b0f663f82429eb2f", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-rep-feature-flag.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.stderr?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -0,0 +1,18 @@\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2015-ques-rep-feature-flag.rs:20:10\n+   |\n+LL |     ($(a)?) => {} //~ERROR expected `*` or `+`\n+   |          ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2015-ques-rep-feature-flag.rs:24:11\n+   |\n+LL |     ($(a),?) => {} //~ERROR expected `*` or `+`\n+   |           ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "90bc19739b8724b279891854f02352afa8a24fe9", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-rep.rs", "status": "renamed", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that `?` macro Kleene operator can not be used when the `macro_at_most_once_rep` feature\n-// gate is not used.\n+// Test behavior of `?` macro _kleene op_ under the 2015 edition. Namely, it doesn't exist.\n \n-macro_rules! m { ($(a)?) => {} }\n-//~^ ERROR using the `?` macro Kleene operator for \"at most one\" repetition is unstable\n+// compile-flags: --edition=2015\n \n-fn main() {\n-    m!();\n+macro_rules! bar {\n+    ($(a)?) => {} //~ERROR expected `*` or `+`\n }\n+\n+macro_rules! baz {\n+    ($(a),?) => {} //~ERROR expected `*` or `+`\n+}\n+\n+fn main() {}", "previous_filename": "src/test/ui/feature-gate-macro_at_most_once_rep.rs"}, {"sha": "8681b5d5be54e0394ebea1253dc7e8478050cf67", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-rep.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.stderr?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -0,0 +1,18 @@\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2015-ques-rep.rs:16:10\n+   |\n+LL |     ($(a)?) => {} //~ERROR expected `*` or `+`\n+   |          ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2015-ques-rep.rs:20:11\n+   |\n+LL |     ($(a),?) => {} //~ERROR expected `*` or `+`\n+   |           ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4b3dfbdc2e8a5cabdb803a9b961f08347b61043b", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-sep.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test behavior of `?` macro _separator_ under the 2015 edition. Namely, `?` can be used as a\n+// separator, but you get a migration warning for the edition.\n+\n+// compile-flags: --edition=2015\n+// compile-pass\n+\n+macro_rules! bar {\n+    ($(a)?*) => {} //~WARN using `?` as a separator\n+}\n+\n+macro_rules! baz {\n+    ($(a)?+) => {} //~WARN using `?` as a separator\n+}\n+\n+fn main() {\n+    bar!();\n+    bar!(a);\n+    bar!(a?a);\n+    bar!(a?a?a?a?a);\n+\n+    baz!(a);\n+    baz!(a?a);\n+    baz!(a?a?a?a?a);\n+}"}, {"sha": "0ab4138864e00a648123f0cad0d5dbb2a8acacf6", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-sep.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.stderr?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -0,0 +1,12 @@\n+warning: using `?` as a separator is deprecated and will be a hard error in an upcoming edition\n+  --> $DIR/macro-at-most-once-rep-2015-ques-sep.rs:18:10\n+   |\n+LL |     ($(a)?*) => {} //~WARN using `?` as a separator\n+   |          ^\n+\n+warning: using `?` as a separator is deprecated and will be a hard error in an upcoming edition\n+  --> $DIR/macro-at-most-once-rep-2015-ques-sep.rs:22:10\n+   |\n+LL |     ($(a)?+) => {} //~WARN using `?` as a separator\n+   |          ^\n+"}, {"sha": "f3107d4f1e4f6382942cfef5bea134988755bea8", "filename": "src/test/ui/macros/macro-at-most-once-rep-2018-feature-gate.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Feature gate test for macro_at_most_once_rep under 2018 edition.\n+\n+// gate-test-macro_at_most_once_rep\n+// compile-flags: --edition=2018\n+\n+macro_rules! foo {\n+    ($(a)?) => {}\n+    //~^ERROR using the `?` macro Kleene operator for\n+    //~|ERROR expected `*` or `+`\n+}\n+\n+macro_rules! baz {\n+    ($(a),?) => {} //~ERROR expected `*` or `+`\n+}\n+\n+macro_rules! barplus {\n+    ($(a)?+) => {}\n+    //~^ERROR using the `?` macro Kleene operator for\n+    //~|ERROR expected `*` or `+`\n+}\n+\n+macro_rules! barstar {\n+    ($(a)?*) => {}\n+    //~^ERROR using the `?` macro Kleene operator for\n+    //~|ERROR expected `*` or `+`\n+}\n+\n+pub fn main() {\n+    foo!();\n+    foo!(a);\n+    foo!(a?); //~ ERROR no rules expected the token `?`\n+    foo!(a?a); //~ ERROR no rules expected the token `?`\n+    foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+}\n+"}, {"sha": "22f1c94fced6f3cbf02d63c49ae579e252d128c8", "filename": "src/test/ui/macros/macro-at-most-once-rep-2018-feature-gate.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.stderr?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -0,0 +1,71 @@\n+error[E0658]: using the `?` macro Kleene operator for \"at most one\" repetition is unstable (see issue #48075)\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:17:10\n+   |\n+LL |     ($(a)?) => {}\n+   |          ^\n+   |\n+   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:17:10\n+   |\n+LL |     ($(a)?) => {}\n+   |          ^\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:23:11\n+   |\n+LL |     ($(a),?) => {} //~ERROR expected `*` or `+`\n+   |           ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error[E0658]: using the `?` macro Kleene operator for \"at most one\" repetition is unstable (see issue #48075)\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:27:10\n+   |\n+LL |     ($(a)?+) => {}\n+   |          ^\n+   |\n+   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:27:10\n+   |\n+LL |     ($(a)?+) => {}\n+   |          ^\n+\n+error[E0658]: using the `?` macro Kleene operator for \"at most one\" repetition is unstable (see issue #48075)\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:33:10\n+   |\n+LL |     ($(a)?*) => {}\n+   |          ^\n+   |\n+   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:33:10\n+   |\n+LL |     ($(a)?*) => {}\n+   |          ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:41:11\n+   |\n+LL |     foo!(a?); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:42:11\n+   |\n+LL |     foo!(a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:43:11\n+   |\n+LL |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: aborting due to 10 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "958a7e0cdf444beed41e76010c0f8ebe5580420c", "filename": "src/test/ui/macros/macro-at-most-once-rep-2018.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.rs?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that `?` is a Kleene op and not a macro separator in the 2018 edition.\n+\n+// compile-flags: --edition=2018\n+\n+#![feature(macro_at_most_once_rep)]\n+\n+macro_rules! foo {\n+    ($(a)?) => {}\n+}\n+\n+macro_rules! baz {\n+    ($(a),?) => {} //~ERROR the `?` macro repetition operator\n+}\n+\n+macro_rules! barplus {\n+    ($(a)?+) => {} // ok. matches \"a+\" and \"+\"\n+}\n+\n+macro_rules! barstar {\n+    ($(a)?*) => {} // ok. matches \"a*\" and \"*\"\n+}\n+\n+pub fn main() {\n+    foo!();\n+    foo!(a);\n+    foo!(a?); //~ ERROR no rules expected the token `?`\n+    foo!(a?a); //~ ERROR no rules expected the token `?`\n+    foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+\n+    barplus!(); //~ERROR unexpected end of macro invocation\n+    barplus!(a); //~ERROR unexpected end of macro invocation\n+    barplus!(a?); //~ ERROR no rules expected the token `?`\n+    barplus!(a?a); //~ ERROR no rules expected the token `?`\n+    barplus!(a+);\n+    barplus!(+);\n+\n+    barstar!(); //~ERROR unexpected end of macro invocation\n+    barstar!(a); //~ERROR unexpected end of macro invocation\n+    barstar!(a?); //~ ERROR no rules expected the token `?`\n+    barstar!(a?a); //~ ERROR no rules expected the token `?`\n+    barstar!(a*);\n+    barstar!(*);\n+}"}, {"sha": "0a15bdb10686d9e01fef808ca474af1a4d4c6b1f", "filename": "src/test/ui/macros/macro-at-most-once-rep-2018.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.stderr?ref=8eb4941e30d2a40bc03840dd0d99beb5aaf8159d", "patch": "@@ -0,0 +1,74 @@\n+error: the `?` macro repetition operator does not take a separator\n+  --> $DIR/macro-at-most-once-rep-2018.rs:22:10\n+   |\n+LL |     ($(a),?) => {} //~ERROR the `?` macro repetition operator\n+   |          ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:36:11\n+   |\n+LL |     foo!(a?); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:37:11\n+   |\n+LL |     foo!(a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:38:11\n+   |\n+LL |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-2018.rs:40:5\n+   |\n+LL |     barplus!(); //~ERROR unexpected end of macro invocation\n+   |     ^^^^^^^^^^^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-2018.rs:41:14\n+   |\n+LL |     barplus!(a); //~ERROR unexpected end of macro invocation\n+   |              ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:42:15\n+   |\n+LL |     barplus!(a?); //~ ERROR no rules expected the token `?`\n+   |               ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:43:15\n+   |\n+LL |     barplus!(a?a); //~ ERROR no rules expected the token `?`\n+   |               ^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-2018.rs:47:5\n+   |\n+LL |     barstar!(); //~ERROR unexpected end of macro invocation\n+   |     ^^^^^^^^^^^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-2018.rs:48:14\n+   |\n+LL |     barstar!(a); //~ERROR unexpected end of macro invocation\n+   |              ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:49:15\n+   |\n+LL |     barstar!(a?); //~ ERROR no rules expected the token `?`\n+   |               ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:50:15\n+   |\n+LL |     barstar!(a?a); //~ ERROR no rules expected the token `?`\n+   |               ^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "a5660f8b41f8da43aeeea29deefa8607dc764bf4", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2a7ae04a6872edd8a1bffa620fde53a2eb2964e1/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7ae04a6872edd8a1bffa620fde53a2eb2964e1/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs?ref=2a7ae04a6872edd8a1bffa620fde53a2eb2964e1", "patch": "@@ -1,53 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// The logic for parsing Kleene operators in macros has a special case to disambiguate `?`.\n-// Specifically, `$(pat)?` is the ZeroOrOne operator whereas `$(pat)?+` or `$(pat)?*` are the\n-// ZeroOrMore and OneOrMore operators using `?` as a separator. These tests are intended to\n-// exercise that logic in the macro parser.\n-//\n-// Moreover, we also throw in some tests for using a separator with `?`, which is meaningless but\n-// included for consistency with `+` and `*`.\n-//\n-// This test focuses on error cases.\n-\n-#![feature(macro_at_most_once_rep)]\n-\n-macro_rules! foo {\n-    ($(a)?) => {}\n-}\n-\n-macro_rules! baz {\n-    ($(a),?) => {} // comma separator is meaningless for `?`\n-}\n-\n-macro_rules! barplus {\n-    ($(a)?+) => {}\n-}\n-\n-macro_rules! barstar {\n-    ($(a)?*) => {}\n-}\n-\n-pub fn main() {\n-    foo!(a?a?a); //~ ERROR no rules expected the token `?`\n-    foo!(a?a); //~ ERROR no rules expected the token `?`\n-    foo!(a?); //~ ERROR no rules expected the token `?`\n-    baz!(a?a?a); //~ ERROR no rules expected the token `?`\n-    baz!(a?a); //~ ERROR no rules expected the token `?`\n-    baz!(a?); //~ ERROR no rules expected the token `?`\n-    baz!(a,); //~ ERROR unexpected end of macro invocation\n-    baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n-    baz!(a?a,); //~ ERROR no rules expected the token `?`\n-    baz!(a?,); //~ ERROR no rules expected the token `?`\n-    barplus!(); //~ ERROR unexpected end of macro invocation\n-    barplus!(a?); //~ ERROR unexpected end of macro invocation\n-    barstar!(a?); //~ ERROR unexpected end of macro invocation\n-}"}, {"sha": "d382082a5758562bb4f6163ef74237c8c0fbc3af", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.stderr", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2a7ae04a6872edd8a1bffa620fde53a2eb2964e1/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a7ae04a6872edd8a1bffa620fde53a2eb2964e1/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr?ref=2a7ae04a6872edd8a1bffa620fde53a2eb2964e1", "patch": "@@ -1,80 +0,0 @@\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:40:11\n-   |\n-LL |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:41:11\n-   |\n-LL |     foo!(a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:42:11\n-   |\n-LL |     foo!(a?); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:43:11\n-   |\n-LL |     baz!(a?a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:44:11\n-   |\n-LL |     baz!(a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:45:11\n-   |\n-LL |     baz!(a?); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:46:11\n-   |\n-LL |     baz!(a,); //~ ERROR unexpected end of macro invocation\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:47:11\n-   |\n-LL |     baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:48:11\n-   |\n-LL |     baz!(a?a,); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:49:11\n-   |\n-LL |     baz!(a?,); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:50:5\n-   |\n-LL |     barplus!(); //~ ERROR unexpected end of macro invocation\n-   |     ^^^^^^^^^^^\n-\n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:51:15\n-   |\n-LL |     barplus!(a?); //~ ERROR unexpected end of macro invocation\n-   |               ^\n-\n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:52:15\n-   |\n-LL |     barstar!(a?); //~ ERROR unexpected end of macro invocation\n-   |               ^\n-\n-error: aborting due to 13 previous errors\n-"}]}