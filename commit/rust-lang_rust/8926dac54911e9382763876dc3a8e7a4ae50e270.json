{"sha": "8926dac54911e9382763876dc3a8e7a4ae50e270", "node_id": "C_kwDOAAsO6NoAKDg5MjZkYWM1NDkxMWU5MzgyNzYzODc2ZGMzYThlN2E0YWU1MGUyNzA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-21T01:26:00Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-21T07:43:00Z"}, "message": "And for patterns too", "tree": {"sha": "ac0ae0fefe2c275faf9e12e145ce53c12ffdf6e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac0ae0fefe2c275faf9e12e145ce53c12ffdf6e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8926dac54911e9382763876dc3a8e7a4ae50e270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8926dac54911e9382763876dc3a8e7a4ae50e270", "html_url": "https://github.com/rust-lang/rust/commit/8926dac54911e9382763876dc3a8e7a4ae50e270", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8926dac54911e9382763876dc3a8e7a4ae50e270/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99c32570bbe20645fa953b0618cec9970c9750fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/99c32570bbe20645fa953b0618cec9970c9750fd", "html_url": "https://github.com/rust-lang/rust/commit/99c32570bbe20645fa953b0618cec9970c9750fd"}], "stats": {"total": 303, "additions": 184, "deletions": 119}, "files": [{"sha": "5c1ab2bf5888d708589c0caad599d06a0c2a39ce", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 89, "deletions": 78, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/8926dac54911e9382763876dc3a8e7a4ae50e270/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8926dac54911e9382763876dc3a8e7a4ae50e270/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8926dac54911e9382763876dc3a8e7a4ae50e270", "patch": "@@ -614,13 +614,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.span_label(span, \"expected due to this\");\n             }\n             ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                semi_span,\n+                arm_block_id,\n+                arm_span,\n+                arm_ty,\n+                prior_arm_block_id,\n+                prior_arm_span,\n+                prior_arm_ty,\n                 source,\n                 ref prior_arms,\n-                last_ty,\n                 scrut_hir_id,\n                 opt_suggest_box_span,\n-                arm_span,\n                 scrut_span,\n                 ..\n             }) => match source {\n@@ -651,10 +654,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n                 _ => {\n-                    // `last_ty` can be `!`, `expected` will have better info when present.\n+                    // `prior_arm_ty` can be `!`, `expected` will have better info when present.\n                     let t = self.resolve_vars_if_possible(match exp_found {\n                         Some(ty::error::ExpectedFound { expected, .. }) => expected,\n-                        _ => last_ty,\n+                        _ => prior_arm_ty,\n                     });\n                     let source_map = self.tcx.sess.source_map();\n                     let mut any_multiline_arm = source_map.is_multiline(arm_span);\n@@ -679,37 +682,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(outer_error_span, msg);\n-                    if let Some((sp, boxed)) = semi_span {\n-                        if let (StatementAsExpression::NeedsBoxing, [.., prior_arm]) =\n-                            (boxed, &prior_arms[..])\n-                        {\n-                            err.multipart_suggestion(\n-                                \"consider removing this semicolon and boxing the expressions\",\n-                                vec![\n-                                    (prior_arm.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                    (prior_arm.shrink_to_hi(), \")\".to_string()),\n-                                    (arm_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                    (arm_span.shrink_to_hi(), \")\".to_string()),\n-                                    (sp, String::new()),\n-                                ],\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        } else if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n-                            err.span_suggestion_short(\n-                                sp,\n-                                \"consider removing this semicolon and boxing the expressions\",\n-                                \"\",\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            err.span_suggestion_short(\n-                                sp,\n-                                \"consider removing this semicolon\",\n-                                \"\",\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    }\n+                    self.suggest_remove_semi_or_return_binding(\n+                        err,\n+                        prior_arm_block_id,\n+                        prior_arm_ty,\n+                        prior_arm_span,\n+                        arm_block_id,\n+                        arm_ty,\n+                        arm_span,\n+                    );\n                     if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n                         self.suggest_boxing_for_return_impl_trait(\n@@ -734,48 +715,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if let Some(sp) = outer_span {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n-                let semicolon = if let hir::Node::Block(blk) = self.tcx.hir().get(then_id)\n-                    && let Some(remove_semicolon) = self.could_remove_semicolon(blk, else_ty)\n-                {\n-                    Some(remove_semicolon)\n-                } else if let hir::Node::Block(blk) = self.tcx.hir().get(else_id)\n-                    && let Some(remove_semicolon) = self.could_remove_semicolon(blk, then_ty)\n-                {\n-                    Some(remove_semicolon)\n-                } else {\n-                    None\n-                };\n-                if let Some((sp, boxed)) = semicolon {\n-                    if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n-                        err.multipart_suggestion(\n-                            \"consider removing this semicolon and boxing the expression\",\n-                            vec![\n-                                (then_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (then_span.shrink_to_hi(), \")\".to_string()),\n-                                (else_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (else_span.shrink_to_hi(), \")\".to_string()),\n-                                (sp, String::new()),\n-                            ],\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        err.span_suggestion_short(\n-                            sp,\n-                            \"consider removing this semicolon\",\n-                            \"\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                } else {\n-                    let suggested = if let hir::Node::Block(blk) = self.tcx.hir().get(then_id) {\n-                        self.consider_returning_binding(blk, else_ty, err)\n-                    } else {\n-                        false\n-                    };\n-                    if !suggested && let hir::Node::Block(blk) = self.tcx.hir().get(else_id) {\n-                        self.consider_returning_binding(blk, then_ty, err);\n-                    }\n-                }\n+                self.suggest_remove_semi_or_return_binding(\n+                    err,\n+                    Some(then_id),\n+                    then_ty,\n+                    then_span,\n+                    Some(else_id),\n+                    else_ty,\n+                    else_span,\n+                );\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n                         err,\n@@ -800,6 +748,69 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_remove_semi_or_return_binding(\n+        &self,\n+        err: &mut Diagnostic,\n+        first_id: Option<hir::HirId>,\n+        first_ty: Ty<'tcx>,\n+        first_span: Span,\n+        second_id: Option<hir::HirId>,\n+        second_ty: Ty<'tcx>,\n+        second_span: Span,\n+    ) {\n+        let semicolon =\n+            if let Some(first_id) = first_id\n+                && let hir::Node::Block(blk) = self.tcx.hir().get(first_id)\n+                && let Some(remove_semicolon) = self.could_remove_semicolon(blk, second_ty)\n+            {\n+                Some(remove_semicolon)\n+            } else if let Some(second_id) = second_id\n+                && let hir::Node::Block(blk) = self.tcx.hir().get(second_id)\n+                && let Some(remove_semicolon) = self.could_remove_semicolon(blk, first_ty)\n+            {\n+                Some(remove_semicolon)\n+            } else {\n+                None\n+            };\n+        if let Some((sp, boxed)) = semicolon {\n+            if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n+                err.multipart_suggestion(\n+                    \"consider removing this semicolon and boxing the expressions\",\n+                    vec![\n+                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (first_span.shrink_to_hi(), \")\".to_string()),\n+                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (second_span.shrink_to_hi(), \")\".to_string()),\n+                        (sp, String::new()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_suggestion_short(\n+                    sp,\n+                    \"consider removing this semicolon\",\n+                    \"\",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        } else {\n+            let suggested =\n+                if let Some(first_id) = first_id\n+                    && let hir::Node::Block(blk) = self.tcx.hir().get(first_id)\n+                {\n+                    self.consider_returning_binding(blk, second_ty, err)\n+                } else {\n+                    false\n+                };\n+            if !suggested\n+                && let Some(second_id) = second_id\n+                && let hir::Node::Block(blk) = self.tcx.hir().get(second_id)\n+            {\n+                self.consider_returning_binding(blk, first_ty, err);\n+            }\n+        }\n+    }\n+\n     fn suggest_boxing_for_return_impl_trait(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "c55971557fac1967551d819554b9ffc0e8d947c8", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8926dac54911e9382763876dc3a8e7a4ae50e270/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8926dac54911e9382763876dc3a8e7a4ae50e270/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=8926dac54911e9382763876dc3a8e7a4ae50e270", "patch": "@@ -488,12 +488,15 @@ impl<'tcx> ty::Lift<'tcx> for StatementAsExpression {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_block_id: Option<hir::HirId>,\n+    pub arm_ty: Ty<'tcx>,\n     pub arm_span: Span,\n+    pub prior_arm_block_id: Option<hir::HirId>,\n+    pub prior_arm_ty: Ty<'tcx>,\n+    pub prior_arm_span: Span,\n     pub scrut_span: Span,\n-    pub semi_span: Option<(Span, StatementAsExpression)>,\n     pub source: hir::MatchSource,\n     pub prior_arms: Vec<Span>,\n-    pub last_ty: Ty<'tcx>,\n     pub scrut_hir_id: hir::HirId,\n     pub opt_suggest_box_span: Option<Span>,\n }"}, {"sha": "2671f2f4f89cab82fb419d0af14d7c1c4a377942", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8926dac54911e9382763876dc3a8e7a4ae50e270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8926dac54911e9382763876dc3a8e7a4ae50e270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=8926dac54911e9382763876dc3a8e7a4ae50e270", "patch": "@@ -9,7 +9,6 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n-    StatementAsExpression,\n };\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -75,8 +74,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let mut other_arms = vec![]; // Used only for diagnostics.\n-        let mut prior_arm_ty = None;\n-        for (i, arm) in arms.iter().enumerate() {\n+        let mut prior_arm = None;\n+        for arm in arms {\n             if let Some(g) = &arm.guard {\n                 self.diverges.set(Diverges::Maybe);\n                 match g {\n@@ -96,21 +95,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let opt_suggest_box_span = self.opt_suggest_box_span(arm_ty, orig_expected);\n \n-            let (arm_span, semi_span) =\n-                self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n-            let (span, code) = match i {\n+            let (arm_block_id, arm_span) = if let hir::ExprKind::Block(blk, _) = arm.body.kind {\n+                (Some(blk.hir_id), self.find_block_span(blk))\n+            } else {\n+                (None, arm.body.span)\n+            };\n+\n+            let (span, code) = match prior_arm {\n                 // The reason for the first arm to fail is not that the match arms diverge,\n                 // but rather that there's a prior obligation that doesn't hold.\n-                0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n-                _ => (\n+                None => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n+                Some((prior_arm_block_id, prior_arm_ty, prior_arm_span)) => (\n                     expr.span,\n                     ObligationCauseCode::MatchExpressionArm(Box::new(MatchExpressionArmCause {\n+                        arm_block_id,\n                         arm_span,\n+                        arm_ty,\n+                        prior_arm_block_id,\n+                        prior_arm_ty,\n+                        prior_arm_span,\n                         scrut_span: scrut.span,\n-                        semi_span,\n                         source: match_src,\n                         prior_arms: other_arms.clone(),\n-                        last_ty: prior_arm_ty.unwrap(),\n                         scrut_hir_id: scrut.hir_id,\n                         opt_suggest_box_span,\n                     })),\n@@ -139,7 +145,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let ret_ty = ret_coercion.borrow().expected_ty();\n                             let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n                             self.can_coerce(arm_ty, ret_ty)\n-                                && prior_arm_ty.map_or(true, |t| self.can_coerce(t, ret_ty))\n+                                && prior_arm.map_or(true, |(_, t, _)| self.can_coerce(t, ret_ty))\n                                 // The match arms need to unify for the case of `impl Trait`.\n                                 && !matches!(ret_ty.kind(), ty::Opaque(..))\n                         }\n@@ -181,7 +187,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if other_arms.len() > 5 {\n                 other_arms.remove(0);\n             }\n-            prior_arm_ty = Some(arm_ty);\n+\n+            prior_arm = Some((arm_block_id, arm_ty, arm_span));\n         }\n \n         // If all of the arms in the `match` diverge,\n@@ -207,32 +214,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match_ty\n     }\n \n-    fn get_appropriate_arm_semicolon_removal_span(\n-        &self,\n-        arms: &'tcx [hir::Arm<'tcx>],\n-        i: usize,\n-        prior_arm_ty: Option<Ty<'tcx>>,\n-        arm_ty: Ty<'tcx>,\n-    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n-        let arm = &arms[i];\n-        let (arm_span, mut semi_span) = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n-            (\n-                self.find_block_span(blk),\n-                prior_arm_ty\n-                    .and_then(|prior_arm_ty| self.could_remove_semicolon(blk, prior_arm_ty)),\n-            )\n-        } else {\n-            (arm.body.span, None)\n-        };\n-        if semi_span.is_none() && i > 0 {\n-            if let hir::ExprKind::Block(blk, _) = &arms[i - 1].body.kind {\n-                let semi_span_prev = self.could_remove_semicolon(blk, arm_ty);\n-                semi_span = semi_span_prev;\n-            }\n-        }\n-        (arm_span, semi_span)\n-    }\n-\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm<'tcx>]) {"}, {"sha": "fa1bad37699f36fcba63fc02407d3c7af87fd00a", "filename": "src/test/ui/suggestions/return-bindings.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8926dac54911e9382763876dc3a8e7a4ae50e270/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8926dac54911e9382763876dc3a8e7a4ae50e270/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs?ref=8926dac54911e9382763876dc3a8e7a4ae50e270", "patch": "@@ -24,4 +24,28 @@ fn d(opt_str: Option<String>) {\n     };\n }\n \n+fn d2(opt_str: Option<String>) {\n+    let s = if let Some(s) = opt_str {\n+    } else {\n+        String::new()\n+        //~^ ERROR `if` and `else` have incompatible types\n+    };\n+}\n+\n+fn e(opt_str: Option<String>) {\n+    let s: String = match opt_str {\n+        Some(s) => {}\n+        //~^ ERROR mismatched types\n+        None => String::new(),\n+    };\n+}\n+\n+fn e2(opt_str: Option<String>) {\n+    let s = match opt_str {\n+        Some(s) => {}\n+        None => String::new(),\n+        //~^ ERROR `match` arms have incompatible types\n+    };\n+}\n+\n fn main() {}"}, {"sha": "c14fb336773d1f79791c5ebd88cc0909c5a438dd", "filename": "src/test/ui/suggestions/return-bindings.stderr", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8926dac54911e9382763876dc3a8e7a4ae50e270/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8926dac54911e9382763876dc3a8e7a4ae50e270/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr?ref=8926dac54911e9382763876dc3a8e7a4ae50e270", "patch": "@@ -59,6 +59,52 @@ LL +         s\n LL ~\n    |\n \n-error: aborting due to 4 previous errors\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/return-bindings.rs:30:9\n+   |\n+LL |       let s = if let Some(s) = opt_str {\n+   |  ______________________________________-\n+LL | |     } else {\n+   | |_____- expected because of this\n+LL |           String::new()\n+   |           ^^^^^^^^^^^^^ expected `()`, found struct `String`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL ~     let s = if let Some(s) = opt_str {\n+LL +         s\n+LL ~     } else {\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings.rs:37:20\n+   |\n+LL |         Some(s) => {}\n+   |                    ^^ expected struct `String`, found `()`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL |         Some(s) => { s }\n+   |                      +\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/return-bindings.rs:46:17\n+   |\n+LL |       let s = match opt_str {\n+   |  _____________-\n+LL | |         Some(s) => {}\n+   | |                    -- this is found to be of type `()`\n+LL | |         None => String::new(),\n+   | |                 ^^^^^^^^^^^^^ expected `()`, found struct `String`\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL |         Some(s) => { s }\n+   |                      +\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}