{"sha": "732f22745dbac22fad9e8f9c0f17d37a23db52f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMmYyMjc0NWRiYWMyMmZhZDllOGY5YzBmMTdkMzdhMjNkYjUyZjg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-09-24T14:45:24Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-26T19:41:17Z"}, "message": "move hair::cx::pattern to const_eval", "tree": {"sha": "f0e144dbe06e8a2660b695e08c16abf9050c01f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0e144dbe06e8a2660b695e08c16abf9050c01f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/732f22745dbac22fad9e8f9c0f17d37a23db52f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/732f22745dbac22fad9e8f9c0f17d37a23db52f8", "html_url": "https://github.com/rust-lang/rust/commit/732f22745dbac22fad9e8f9c0f17d37a23db52f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/732f22745dbac22fad9e8f9c0f17d37a23db52f8/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb5afb412198d9c91abe85b1227d005dfa58e196", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5afb412198d9c91abe85b1227d005dfa58e196", "html_url": "https://github.com/rust-lang/rust/commit/bb5afb412198d9c91abe85b1227d005dfa58e196"}], "stats": {"total": 336, "additions": 158, "deletions": 178}, "files": [{"sha": "d12b95d8b22e3470d7e34aabe33ac77aae2b7168", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=732f22745dbac22fad9e8f9c0f17d37a23db52f8", "patch": "@@ -335,6 +335,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\","}, {"sha": "ec4d2fdf967d6deffdd6521514c0434b2a6817ee", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=732f22745dbac22fad9e8f9c0f17d37a23db52f8", "patch": "@@ -14,6 +14,7 @@ serialize = { path = \"../libserialize\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }"}, {"sha": "9a97df966960046d205bc30084dcbe61267b1407", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=732f22745dbac22fad9e8f9c0f17d37a23db52f8", "patch": "@@ -36,6 +36,7 @@\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_const_math;\n+extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate graphviz;\n extern crate syntax_pos;\n@@ -47,6 +48,7 @@ pub mod diagnostics;\n \n mod eval;\n pub mod check_match;\n+pub mod pattern;\n \n pub use eval::*;\n "}, {"sha": "b32c78b31bb3660a14fd755e18fb1f2a80cde4cc", "filename": "src/librustc_const_eval/pattern.rs", "status": "renamed", "additions": 146, "deletions": 97, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=732f22745dbac22fad9e8f9c0f17d37a23db52f8", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,87 +8,128 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hair::*;\n-use hair::cx::Cx;\n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc_const_eval as const_eval;\n+use eval;\n+\n+use rustc::middle::const_val::ConstVal;\n+use rustc::mir::repr::{Field, Literal, BorrowKind, Mutability};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n+use rustc::hir::{self, PatKind};\n use rustc::hir::def::Def;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::ty::{self, Ty};\n-use rustc::mir::repr::*;\n-use rustc::hir::{self, PatKind};\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n-/// When there are multiple patterns in a single arm, each one has its\n-/// own node-ids for the bindings.  References to the variables always\n-/// use the node-ids from the first pattern in the arm, so we just\n-/// remap the ids for all subsequent bindings to the first one.\n-///\n-/// Example:\n-/// ```\n-/// match foo {\n-///    Test1(flavor /* def 1 */) |\n-///    Test2(flavor /* def 2 */) if flavor /* ref 1 */.is_tasty() => { ... }\n-///    _ => { ... }\n-/// }\n-/// ```\n-struct PatCx<'patcx, 'cx: 'patcx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n-    cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n+#[derive(Copy, Clone, Debug)]\n+pub enum BindingMode<'tcx> {\n+    ByValue,\n+    ByRef(&'tcx Region, BorrowKind),\n }\n \n-impl<'cx, 'gcx, 'tcx> Cx<'cx, 'gcx, 'tcx> {\n-    pub fn irrefutable_pat(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        PatCx::new(self).to_pattern(pat)\n-    }\n+#[derive(Clone, Debug)]\n+pub struct FieldPattern<'tcx> {\n+    pub field: Field,\n+    pub pattern: Pattern<'tcx>,\n+}\n \n-    pub fn refutable_pat(&mut self,\n-                         pat: &hir::Pat)\n-                         -> Pattern<'tcx> {\n-        PatCx::new(self).to_pattern(pat)\n-    }\n+#[derive(Clone, Debug)]\n+pub struct Pattern<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub span: Span,\n+    pub kind: Box<PatternKind<'tcx>>,\n }\n \n-impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n-    fn new(cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>)\n-               -> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n-        PatCx {\n-            cx: cx,\n-        }\n-    }\n+#[derive(Clone, Debug)]\n+pub enum PatternKind<'tcx> {\n+    Wild,\n+\n+    /// x, ref x, x @ P, etc\n+    Binding {\n+        mutability: Mutability,\n+        name: ast::Name,\n+        mode: BindingMode<'tcx>,\n+        var: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        subpattern: Option<Pattern<'tcx>>,\n+    },\n+\n+    /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n+    Variant {\n+        adt_def: AdtDef<'tcx>,\n+        variant_index: usize,\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n+    },\n+\n+    /// (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n+    Leaf {\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n+    },\n+\n+    /// box P, &P, &mut P, etc\n+    Deref {\n+        subpattern: Pattern<'tcx>,\n+    },\n+\n+    Constant {\n+        value: ConstVal,\n+    },\n+\n+    Range {\n+        lo: Literal<'tcx>,\n+        hi: Literal<'tcx>,\n+    },\n+\n+    /// matches against a slice, checking the length and extracting elements\n+    Slice {\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n+    },\n+\n+    /// fixed match against an array, irrefutable\n+    Array {\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n+    },\n+}\n \n-    fn to_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.cx.tcx.node_id_to_type(pat.id);\n+impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n+    pub fn from_hir(tcx: TyCtxt<'a, 'gcx, 'tcx>, pat: &hir::Pat) -> Self {\n+        let mut ty = tcx.node_id_to_type(pat.id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n \n             PatKind::Lit(ref value) => {\n-                let value = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), value);\n+                let value = eval::eval_const_expr(tcx.global_tcx(), value);\n                 PatternKind::Constant { value: value }\n             }\n \n             PatKind::Range(ref lo, ref hi) => {\n-                let lo = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), lo);\n+                let lo = eval::eval_const_expr(tcx.global_tcx(), lo);\n                 let lo = Literal::Value { value: lo };\n-                let hi = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), hi);\n+                let hi = eval::eval_const_expr(tcx.global_tcx(), hi);\n                 let hi = Literal::Value { value: hi };\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n             PatKind::Path(..) => {\n-                match self.cx.tcx.expect_def(pat.id) {\n+                match tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                        let tcx = self.cx.tcx.global_tcx();\n-                        let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n-                        match const_eval::lookup_const_by_id(tcx, def_id, substs) {\n+                        let tcx = tcx.global_tcx();\n+                        let substs = Some(tcx.node_id_item_substs(pat.id).substs);\n+                        match eval::lookup_const_by_id(tcx, def_id, substs) {\n                             Some((const_expr, _const_ty)) => {\n-                                match const_eval::const_expr_to_pat(tcx,\n-                                                                    const_expr,\n-                                                                    pat.id,\n-                                                                    pat.span) {\n+                                match eval::const_expr_to_pat(tcx,\n+                                                              const_expr,\n+                                                              pat.id,\n+                                                              pat.span) {\n                                     Ok(pat) =>\n-                                        return self.to_pattern(&pat),\n+                                        return Pattern::from_hir(tcx, &pat),\n                                     Err(_) =>\n                                         span_bug!(\n                                             pat.span, \"illegal constant\"),\n@@ -103,32 +144,33 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                         }\n                     }\n                     _ => {\n-                        self.variant_or_leaf(pat, vec![])\n+                        PatternKind::from_variant_or_leaf(tcx, pat, vec![])\n                     }\n                 }\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n             PatKind::Box(ref subpattern) => {\n-                PatternKind::Deref { subpattern: self.to_pattern(subpattern) }\n+                PatternKind::Deref { subpattern: Self::from_hir(tcx, subpattern) }\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.cx.tcx.node_id_to_type(pat.id);\n+                let ty = tcx.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n                             subpattern: Pattern {\n                                 ty: mt.ty,\n                                 span: pat.span,\n-                                kind: Box::new(self.slice_or_array_pattern(pat.span, mt.ty, prefix,\n-                                                                           slice, suffix)),\n+                                kind: Box::new(PatternKind::from_slice_or_array(\n+                                    tcx, pat.span, mt.ty, prefix, slice, suffix))\n                             },\n                         },\n \n                     ty::TySlice(..) |\n                     ty::TyArray(..) =>\n-                        self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n+                        PatternKind::from_slice_or_array(\n+                            tcx, pat.span, ty, prefix, slice, suffix),\n \n                     ref sty =>\n                         span_bug!(\n@@ -139,14 +181,14 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                match self.cx.tcx.node_id_to_type(pat.id).sty {\n+                match tcx.node_id_to_type(pat.id).sty {\n                     ty::TyTuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n                                        .enumerate_and_adjust(tys.len(), ddpos)\n                                        .map(|(i, subpattern)| FieldPattern {\n                                             field: Field::new(i),\n-                                            pattern: self.to_pattern(subpattern),\n+                                            pattern: Self::from_hir(tcx, subpattern),\n                                        })\n                                        .collect();\n \n@@ -158,9 +200,9 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             }\n \n             PatKind::Binding(bm, ref ident, ref sub) => {\n-                let def_id = self.cx.tcx.expect_def(pat.id).def_id();\n-                let id = self.cx.tcx.map.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n+                let def_id = tcx.expect_def(pat.id).def_id();\n+                let id = tcx.map.as_local_node_id(def_id).unwrap();\n+                let var_ty = tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n@@ -192,31 +234,31 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                     name: ident.node,\n                     var: id,\n                     ty: var_ty,\n-                    subpattern: self.to_opt_pattern(sub),\n+                    subpattern: Self::from_opt_pattern(tcx, sub),\n                 }\n             }\n \n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n-                let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n+                let pat_ty = tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n                 };\n-                let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(tcx.expect_def(pat.id));\n \n                 let subpatterns =\n                         subpatterns.iter()\n                                    .enumerate_and_adjust(variant_def.fields.len(), ddpos)\n                                    .map(|(i, field)| FieldPattern {\n                                        field: Field::new(i),\n-                                       pattern: self.to_pattern(field),\n+                                       pattern: Self::from_hir(tcx, field),\n                                    })\n                                    .collect();\n-                self.variant_or_leaf(pat, subpatterns)\n+                PatternKind::from_variant_or_leaf(tcx, pat, subpatterns)\n             }\n \n             PatKind::Struct(_, ref fields, _) => {\n-                let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n+                let pat_ty = tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -225,7 +267,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                             \"struct pattern not applied to an ADT\");\n                     }\n                 };\n-                let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(tcx.expect_def(pat.id));\n \n                 let subpatterns =\n                     fields.iter()\n@@ -239,12 +281,12 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                               });\n                               FieldPattern {\n                                   field: Field::new(index),\n-                                  pattern: self.to_pattern(&field.node.pat),\n+                                  pattern: Self::from_hir(tcx, &field.node.pat),\n                               }\n                           })\n                           .collect();\n \n-                self.variant_or_leaf(pat, subpatterns)\n+                PatternKind::from_variant_or_leaf(tcx, pat, subpatterns)\n             }\n         };\n \n@@ -255,38 +297,43 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn to_patterns(&mut self, pats: &[P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n-        pats.iter().map(|p| self.to_pattern(p)).collect()\n+    fn from_patterns(tcx: TyCtxt<'a, 'gcx, 'tcx>, pats: &[P<hir::Pat>]) -> Vec<Self> {\n+        pats.iter().map(|p| Self::from_hir(tcx, p)).collect()\n     }\n \n-    fn to_opt_pattern(&mut self, pat: &Option<P<hir::Pat>>) -> Option<Pattern<'tcx>> {\n-        pat.as_ref().map(|p| self.to_pattern(p))\n+    fn from_opt_pattern(tcx: TyCtxt<'a, 'gcx, 'tcx>, pat: &Option<P<hir::Pat>>) -> Option<Self>\n+    {\n+        pat.as_ref().map(|p| Self::from_hir(tcx, p))\n     }\n+}\n \n-    fn slice_or_array_pattern(&mut self,\n-                              span: Span,\n-                              ty: Ty<'tcx>,\n-                              prefix: &[P<hir::Pat>],\n-                              slice: &Option<P<hir::Pat>>,\n-                              suffix: &[P<hir::Pat>])\n-                              -> PatternKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> PatternKind<'tcx> {\n+    fn from_slice_or_array(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+        prefix: &[P<hir::Pat>],\n+        slice: &Option<P<hir::Pat>>,\n+        suffix: &[P<hir::Pat>])\n+        -> Self\n+    {\n         match ty.sty {\n             ty::TySlice(..) => {\n                 // matching a slice or fixed-length array\n                 PatternKind::Slice {\n-                    prefix: self.to_patterns(prefix),\n-                    slice: self.to_opt_pattern(slice),\n-                    suffix: self.to_patterns(suffix),\n+                    prefix: Pattern::from_patterns(tcx, prefix),\n+                    slice: Pattern::from_opt_pattern(tcx, slice),\n+                    suffix: Pattern::from_patterns(tcx, suffix),\n                 }\n             }\n \n             ty::TyArray(_, len) => {\n                 // fixed-length array\n                 assert!(len >= prefix.len() + suffix.len());\n                 PatternKind::Array {\n-                    prefix: self.to_patterns(prefix),\n-                    slice: self.to_opt_pattern(slice),\n-                    suffix: self.to_patterns(suffix),\n+                    prefix: Pattern::from_patterns(tcx, prefix),\n+                    slice: Pattern::from_opt_pattern(tcx, slice),\n+                    suffix: Pattern::from_patterns(tcx, suffix),\n                 }\n             }\n \n@@ -296,14 +343,16 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn variant_or_leaf(&mut self,\n-                       pat: &hir::Pat,\n-                       subpatterns: Vec<FieldPattern<'tcx>>)\n-                       -> PatternKind<'tcx> {\n-        match self.cx.tcx.expect_def(pat.id) {\n+    fn from_variant_or_leaf(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        pat: &hir::Pat,\n+        subpatterns: Vec<FieldPattern<'tcx>>)\n+        -> Self\n+    {\n+        match tcx.expect_def(pat.id) {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                let enum_id = self.cx.tcx.parent_def_id(variant_id).unwrap();\n-                let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n+                let enum_id = tcx.parent_def_id(variant_id).unwrap();\n+                let adt_def = tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n                     PatternKind::Variant {\n                         adt_def: adt_def,", "previous_filename": "src/librustc_mir/hair/cx/pattern.rs"}, {"sha": "a7249677e01031a7c9895e02cf72720f2e9fad96", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=732f22745dbac22fad9e8f9c0f17d37a23db52f8", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use hair::cx::Cx;\n+use hair::Pattern;\n+\n use rustc::middle::region::{CodeExtent, CodeExtentData, ROOT_CODE_EXTENT};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n@@ -339,7 +341,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let lvalue = Lvalue::Local(Local::new(index + 1));\n \n             if let Some(pattern) = pattern {\n-                let pattern = self.hir.irrefutable_pat(pattern);\n+                let pattern = Pattern::from_hir(self.hir.tcx(), pattern);\n                 scope = self.declare_bindings(scope, ast_block.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }"}, {"sha": "ec1136368c1354317d18670e0b500be4f4dfa452", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=732f22745dbac22fad9e8f9c0f17d37a23db52f8", "patch": "@@ -57,7 +57,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     let remainder_extent =\n                         cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n \n-                    let pattern = cx.irrefutable_pat(&local.pat);\n+                    let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n                     result.push(StmtRef::Mirror(Box::new(Stmt {\n                         span: stmt.span,\n                         kind: StmtKind::Let {"}, {"sha": "45c49a4627ff6cac481d647c50c812f0e8c89250", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=732f22745dbac22fad9e8f9c0f17d37a23db52f8", "patch": "@@ -657,7 +657,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n-        patterns: arm.pats.iter().map(|p| cx.refutable_pat(p)).collect(),\n+        patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }"}, {"sha": "f87e0acaa4ca1c689b97015ade729d23e1ff0583", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=732f22745dbac22fad9e8f9c0f17d37a23db52f8", "patch": "@@ -196,5 +196,4 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n mod block;\n mod expr;\n-mod pattern;\n mod to_ref;"}, {"sha": "49a592b07fb4f5134728da29738787bdf02c1b0a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732f22745dbac22fad9e8f9c0f17d37a23db52f8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=732f22745dbac22fad9e8f9c0f17d37a23db52f8", "patch": "@@ -14,9 +14,7 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp,\n-    TypedConstVal};\n-use rustc::middle::const_val::ConstVal;\n+use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, UnOp, TypedConstVal};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::ty::subst::Substs;\n@@ -28,6 +26,8 @@ use self::cx::Cx;\n \n pub mod cx;\n \n+pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n+\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub extent: CodeExtent,\n@@ -266,86 +266,12 @@ pub struct Arm<'tcx> {\n     pub body: ExprRef<'tcx>,\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Pattern<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub span: Span,\n-    pub kind: Box<PatternKind<'tcx>>,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum LogicalOp {\n     And,\n     Or,\n }\n \n-#[derive(Clone, Debug)]\n-pub enum PatternKind<'tcx> {\n-    Wild,\n-\n-    /// x, ref x, x @ P, etc\n-    Binding {\n-        mutability: Mutability,\n-        name: ast::Name,\n-        mode: BindingMode<'tcx>,\n-        var: ast::NodeId,\n-        ty: Ty<'tcx>,\n-        subpattern: Option<Pattern<'tcx>>,\n-    },\n-\n-    /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n-    Variant {\n-        adt_def: AdtDef<'tcx>,\n-        variant_index: usize,\n-        subpatterns: Vec<FieldPattern<'tcx>>,\n-    },\n-\n-    /// (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n-    Leaf {\n-        subpatterns: Vec<FieldPattern<'tcx>>,\n-    },\n-\n-    /// box P, &P, &mut P, etc\n-    Deref {\n-        subpattern: Pattern<'tcx>,\n-    },\n-\n-    Constant {\n-        value: ConstVal,\n-    },\n-\n-    Range {\n-        lo: Literal<'tcx>,\n-        hi: Literal<'tcx>,\n-    },\n-\n-    /// matches against a slice, checking the length and extracting elements\n-    Slice {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n-    },\n-\n-    /// fixed match against an array, irrefutable\n-    Array {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n-    },\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum BindingMode<'tcx> {\n-    ByValue,\n-    ByRef(&'tcx Region, BorrowKind),\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct FieldPattern<'tcx> {\n-    pub field: Field,\n-    pub pattern: Pattern<'tcx>,\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // The Mirror trait\n "}]}