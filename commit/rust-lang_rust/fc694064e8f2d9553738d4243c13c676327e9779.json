{"sha": "fc694064e8f2d9553738d4243c13c676327e9779", "node_id": "C_kwDOAAsO6NoAKGZjNjk0MDY0ZThmMmQ5NTUzNzM4ZDQyNDNjMTNjNjc2MzI3ZTk3Nzk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-21T21:03:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-21T21:03:11Z"}, "message": "Rollup merge of #91965 - ferrocene:pa-more-granular-exclude, r=Mark-Simulacrum\n\nAdd more granular `--exclude` in `x.py`\n\nx.py has support for excluding some steps from the current invocation, but unfortunately that's not granular enough: some steps have the same name in different modules, and that prevents excluding only *some* of them.\n\nAs a practical example, let's say you need to run everything in `./x.py test` except for the standard library tests, as those tests require IPv6 and need to be executed on a separate machine. Before this commit, if you were to just run this:\n\n    ./x.py test --exclude library/std\n\n...the invocation would eventually fail, as that would not only exclude running the tests for the standard library (`library/std` in the `test` module), it would also exclude generating its documentation (`library/std` in the `doc` module), breaking linkchecker.\n\nThis commit adds support to the `--exclude` flag for prefixing paths with the name of the module their step is defined in, allowing the user to choose which module to exclude from:\n\n    ./x.py test --exclude test::library/std\n\nThis maintains backward compatibility with existing invocations, while allowing more ganular exclusion. Examples of the behavior:\n\n| `--exclude`         | Docs    | Tests   |\n| ------------------- | ------- | ------- |\n| `library/std`       | Skipped | Skipped |\n| `doc::library/std`  | Skipped | Run     |\n| `test::library/std` | Run     | Skipped |\n\nNote that this PR only changes the `--exclude` flag, and not in other `x.py` arguments or flags yet.\n\nIn the implementation I tried to limit the impact this would have with rustbuild as a whole as much as possible. The module name is extracted from the step by parsing the result of `std::any::type_name()`: unfortunately that output can change at any point in time, but IMO it's better than having to annotate all the existing and future `Step` implementations with the module name. I added a test to ensure the parsing works as expected, so hopefully if anyone makes changes to the output of `std::any::type_name()` they'll also notice they have to update rustbuild.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "a262dc1232307ab3228fb265f01ec6f00c8e0c22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a262dc1232307ab3228fb265f01ec6f00c8e0c22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc694064e8f2d9553738d4243c13c676327e9779", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh6x+QCRBK7hj4Ov3rIwAAIK8IAHXVjIN4gp2WW4+6KE1mpk3s\nNSGR0tvGzd/nB0uf09kSoyAaAcm7iq1YN2MT+oEFb2WgFYKab+vaYCYVW5SqMsIq\n18ofFPpzvYMJdJm+B4keXwsgfzWFMx6xW39yNfBnGkY5Hv+0pqUZWHpu+pAA//VW\n9DBzDsqAbr6UzHaaWMYlt8lGqWalFS/c9FHF6nP/OC0TWi/C0Zkf5T2FlK2xK1+4\n6Nb6Wyxyp2nSd4k09+qKcpwI4AQYmk+Q0WwJxvB5cZr1o9c4X4QOgiT870I9oq3j\n32R4Wb8a8BABjIC1B6MwZ8nqB4SRqxzFMrjuLT9NGYVF2eV2SFZYxIexCQm3ffw=\n=jMVw\n-----END PGP SIGNATURE-----\n", "payload": "tree a262dc1232307ab3228fb265f01ec6f00c8e0c22\nparent cbaeec14f90b59a91a6b0f17fc046c66fa811892\nparent b3ad40532db231cd3ca55bc37047aa50fb1a1a71\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642798991 +0100\ncommitter GitHub <noreply@github.com> 1642798991 +0100\n\nRollup merge of #91965 - ferrocene:pa-more-granular-exclude, r=Mark-Simulacrum\n\nAdd more granular `--exclude` in `x.py`\n\nx.py has support for excluding some steps from the current invocation, but unfortunately that's not granular enough: some steps have the same name in different modules, and that prevents excluding only *some* of them.\n\nAs a practical example, let's say you need to run everything in `./x.py test` except for the standard library tests, as those tests require IPv6 and need to be executed on a separate machine. Before this commit, if you were to just run this:\n\n    ./x.py test --exclude library/std\n\n...the invocation would eventually fail, as that would not only exclude running the tests for the standard library (`library/std` in the `test` module), it would also exclude generating its documentation (`library/std` in the `doc` module), breaking linkchecker.\n\nThis commit adds support to the `--exclude` flag for prefixing paths with the name of the module their step is defined in, allowing the user to choose which module to exclude from:\n\n    ./x.py test --exclude test::library/std\n\nThis maintains backward compatibility with existing invocations, while allowing more ganular exclusion. Examples of the behavior:\n\n| `--exclude`         | Docs    | Tests   |\n| ------------------- | ------- | ------- |\n| `library/std`       | Skipped | Skipped |\n| `doc::library/std`  | Skipped | Run     |\n| `test::library/std` | Run     | Skipped |\n\nNote that this PR only changes the `--exclude` flag, and not in other `x.py` arguments or flags yet.\n\nIn the implementation I tried to limit the impact this would have with rustbuild as a whole as much as possible. The module name is extracted from the step by parsing the result of `std::any::type_name()`: unfortunately that output can change at any point in time, but IMO it's better than having to annotate all the existing and future `Step` implementations with the module name. I added a test to ensure the parsing works as expected, so hopefully if anyone makes changes to the output of `std::any::type_name()` they'll also notice they have to update rustbuild.\n\nr? `@Mark-Simulacrum`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc694064e8f2d9553738d4243c13c676327e9779", "html_url": "https://github.com/rust-lang/rust/commit/fc694064e8f2d9553738d4243c13c676327e9779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc694064e8f2d9553738d4243c13c676327e9779/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbaeec14f90b59a91a6b0f17fc046c66fa811892", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbaeec14f90b59a91a6b0f17fc046c66fa811892", "html_url": "https://github.com/rust-lang/rust/commit/cbaeec14f90b59a91a6b0f17fc046c66fa811892"}, {"sha": "b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "html_url": "https://github.com/rust-lang/rust/commit/b3ad40532db231cd3ca55bc37047aa50fb1a1a71"}], "stats": {"total": 191, "additions": 146, "deletions": 45}, "files": [{"sha": "5cab3e8be1039f9917d609c5c0e9498d0ffe5ca8", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 135, "deletions": 35, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=fc694064e8f2d9553738d4243c13c676327e9779", "patch": "@@ -7,7 +7,7 @@ use std::fmt::Debug;\n use std::fs;\n use std::hash::Hash;\n use std::ops::Deref;\n-use std::path::{Path, PathBuf};\n+use std::path::{Component, Path, PathBuf};\n use std::process::Command;\n use std::time::{Duration, Instant};\n \n@@ -105,6 +105,44 @@ struct StepDescription {\n     should_run: fn(ShouldRun<'_>) -> ShouldRun<'_>,\n     make_run: fn(RunConfig<'_>),\n     name: &'static str,\n+    kind: Kind,\n+}\n+\n+#[derive(Clone, PartialOrd, Ord, PartialEq, Eq)]\n+pub struct TaskPath {\n+    pub path: PathBuf,\n+    pub kind: Option<Kind>,\n+}\n+\n+impl TaskPath {\n+    pub fn parse(path: impl Into<PathBuf>) -> TaskPath {\n+        let mut kind = None;\n+        let mut path = path.into();\n+\n+        let mut components = path.components();\n+        if let Some(Component::Normal(os_str)) = components.next() {\n+            if let Some(str) = os_str.to_str() {\n+                if let Some((found_kind, found_prefix)) = str.split_once(\"::\") {\n+                    if found_kind.is_empty() {\n+                        panic!(\"empty kind in task path {}\", path.display());\n+                    }\n+                    kind = Some(Kind::parse(found_kind));\n+                    path = Path::new(found_prefix).join(components.as_path());\n+                }\n+            }\n+        }\n+\n+        TaskPath { path, kind }\n+    }\n+}\n+\n+impl Debug for TaskPath {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        if let Some(kind) = &self.kind {\n+            write!(f, \"{}::\", kind.as_str())?;\n+        }\n+        write!(f, \"{}\", self.path.display())\n+    }\n }\n \n /// Collection of paths used to match a task rule.\n@@ -115,50 +153,61 @@ pub enum PathSet {\n     /// These are generally matched as a path suffix. For example, a\n     /// command-line value of `libstd` will match if `src/libstd` is in the\n     /// set.\n-    Set(BTreeSet<PathBuf>),\n+    Set(BTreeSet<TaskPath>),\n     /// A \"suite\" of paths.\n     ///\n     /// These can match as a path suffix (like `Set`), or as a prefix. For\n     /// example, a command-line value of `src/test/ui/abi/variadic-ffi.rs`\n     /// will match `src/test/ui`. A command-line value of `ui` would also\n     /// match `src/test/ui`.\n-    Suite(PathBuf),\n+    Suite(TaskPath),\n }\n \n impl PathSet {\n     fn empty() -> PathSet {\n         PathSet::Set(BTreeSet::new())\n     }\n \n-    fn one<P: Into<PathBuf>>(path: P) -> PathSet {\n+    fn one<P: Into<PathBuf>>(path: P, kind: Kind) -> PathSet {\n         let mut set = BTreeSet::new();\n-        set.insert(path.into());\n+        set.insert(TaskPath { path: path.into(), kind: Some(kind.into()) });\n         PathSet::Set(set)\n     }\n \n-    fn has(&self, needle: &Path) -> bool {\n+    fn has(&self, needle: &Path, module: Option<Kind>) -> bool {\n+        let check = |p: &TaskPath| {\n+            if let (Some(p_kind), Some(kind)) = (&p.kind, module) {\n+                p.path.ends_with(needle) && *p_kind == kind\n+            } else {\n+                p.path.ends_with(needle)\n+            }\n+        };\n+\n         match self {\n-            PathSet::Set(set) => set.iter().any(|p| p.ends_with(needle)),\n-            PathSet::Suite(suite) => suite.ends_with(needle),\n+            PathSet::Set(set) => set.iter().any(check),\n+            PathSet::Suite(suite) => check(suite),\n         }\n     }\n \n     fn path(&self, builder: &Builder<'_>) -> PathBuf {\n         match self {\n-            PathSet::Set(set) => set.iter().next().unwrap_or(&builder.build.src).to_path_buf(),\n-            PathSet::Suite(path) => PathBuf::from(path),\n+            PathSet::Set(set) => {\n+                set.iter().next().map(|p| &p.path).unwrap_or(&builder.build.src).clone()\n+            }\n+            PathSet::Suite(path) => path.path.clone(),\n         }\n     }\n }\n \n impl StepDescription {\n-    fn from<S: Step>() -> StepDescription {\n+    fn from<S: Step>(kind: Kind) -> StepDescription {\n         StepDescription {\n             default: S::DEFAULT,\n             only_hosts: S::ONLY_HOSTS,\n             should_run: S::should_run,\n             make_run: S::make_run,\n             name: std::any::type_name::<S>(),\n+            kind,\n         }\n     }\n \n@@ -177,7 +226,7 @@ impl StepDescription {\n     }\n \n     fn is_excluded(&self, builder: &Builder<'_>, pathset: &PathSet) -> bool {\n-        if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n+        if builder.config.exclude.iter().any(|e| pathset.has(&e.path, e.kind)) {\n             eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n             return true;\n         }\n@@ -192,8 +241,10 @@ impl StepDescription {\n     }\n \n     fn run(v: &[StepDescription], builder: &Builder<'_>, paths: &[PathBuf]) {\n-        let should_runs =\n-            v.iter().map(|desc| (desc.should_run)(ShouldRun::new(builder))).collect::<Vec<_>>();\n+        let should_runs = v\n+            .iter()\n+            .map(|desc| (desc.should_run)(ShouldRun::new(builder, desc.kind)))\n+            .collect::<Vec<_>>();\n \n         // sanity checks on rules\n         for (desc, should_run) in v.iter().zip(&should_runs) {\n@@ -226,7 +277,7 @@ impl StepDescription {\n                 if let Some(suite) = should_run.is_suite_path(path) {\n                     attempted_run = true;\n                     desc.maybe_run(builder, suite);\n-                } else if let Some(pathset) = should_run.pathset_for_path(path) {\n+                } else if let Some(pathset) = should_run.pathset_for_path(path, desc.kind) {\n                     attempted_run = true;\n                     desc.maybe_run(builder, pathset);\n                 }\n@@ -246,6 +297,8 @@ enum ReallyDefault<'a> {\n \n pub struct ShouldRun<'a> {\n     pub builder: &'a Builder<'a>,\n+    kind: Kind,\n+\n     // use a BTreeSet to maintain sort order\n     paths: BTreeSet<PathSet>,\n \n@@ -255,9 +308,10 @@ pub struct ShouldRun<'a> {\n }\n \n impl<'a> ShouldRun<'a> {\n-    fn new(builder: &'a Builder<'_>) -> ShouldRun<'a> {\n+    fn new(builder: &'a Builder<'_>, kind: Kind) -> ShouldRun<'a> {\n         ShouldRun {\n             builder,\n+            kind,\n             paths: BTreeSet::new(),\n             is_really_default: ReallyDefault::Bool(true), // by default no additional conditions\n         }\n@@ -293,7 +347,7 @@ impl<'a> ShouldRun<'a> {\n         let mut set = BTreeSet::new();\n         for krate in self.builder.in_tree_crates(name, None) {\n             let path = krate.local_path(self.builder);\n-            set.insert(path);\n+            set.insert(TaskPath { path, kind: Some(self.kind) });\n         }\n         self.paths.insert(PathSet::Set(set));\n         self\n@@ -306,7 +360,7 @@ impl<'a> ShouldRun<'a> {\n     pub fn krate(mut self, name: &str) -> Self {\n         for krate in self.builder.in_tree_crates(name, None) {\n             let path = krate.local_path(self.builder);\n-            self.paths.insert(PathSet::one(path));\n+            self.paths.insert(PathSet::one(path, self.kind));\n         }\n         self\n     }\n@@ -318,19 +372,25 @@ impl<'a> ShouldRun<'a> {\n \n     // multiple aliases for the same job\n     pub fn paths(mut self, paths: &[&str]) -> Self {\n-        self.paths.insert(PathSet::Set(paths.iter().map(PathBuf::from).collect()));\n+        self.paths.insert(PathSet::Set(\n+            paths\n+                .iter()\n+                .map(|p| TaskPath { path: p.into(), kind: Some(self.kind.into()) })\n+                .collect(),\n+        ));\n         self\n     }\n \n     pub fn is_suite_path(&self, path: &Path) -> Option<&PathSet> {\n         self.paths.iter().find(|pathset| match pathset {\n-            PathSet::Suite(p) => path.starts_with(p),\n+            PathSet::Suite(p) => path.starts_with(&p.path),\n             PathSet::Set(_) => false,\n         })\n     }\n \n     pub fn suite_path(mut self, suite: &str) -> Self {\n-        self.paths.insert(PathSet::Suite(PathBuf::from(suite)));\n+        self.paths\n+            .insert(PathSet::Suite(TaskPath { path: suite.into(), kind: Some(self.kind.into()) }));\n         self\n     }\n \n@@ -340,12 +400,12 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n-    fn pathset_for_path(&self, path: &Path) -> Option<&PathSet> {\n-        self.paths.iter().find(|pathset| pathset.has(path))\n+    fn pathset_for_path(&self, path: &Path, kind: Kind) -> Option<&PathSet> {\n+        self.paths.iter().find(|pathset| pathset.has(path, Some(kind)))\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n pub enum Kind {\n     Build,\n     Check,\n@@ -359,11 +419,44 @@ pub enum Kind {\n     Run,\n }\n \n+impl Kind {\n+    fn parse(string: &str) -> Kind {\n+        match string {\n+            \"build\" => Kind::Build,\n+            \"check\" => Kind::Check,\n+            \"clippy\" => Kind::Clippy,\n+            \"fix\" => Kind::Fix,\n+            \"test\" => Kind::Test,\n+            \"bench\" => Kind::Bench,\n+            \"dist\" => Kind::Dist,\n+            \"doc\" => Kind::Doc,\n+            \"install\" => Kind::Install,\n+            \"run\" => Kind::Run,\n+            other => panic!(\"unknown kind: {}\", other),\n+        }\n+    }\n+\n+    fn as_str(&self) -> &'static str {\n+        match self {\n+            Kind::Build => \"build\",\n+            Kind::Check => \"check\",\n+            Kind::Clippy => \"clippy\",\n+            Kind::Fix => \"fix\",\n+            Kind::Test => \"test\",\n+            Kind::Bench => \"bench\",\n+            Kind::Dist => \"dist\",\n+            Kind::Doc => \"doc\",\n+            Kind::Install => \"install\",\n+            Kind::Run => \"run\",\n+        }\n+    }\n+}\n+\n impl<'a> Builder<'a> {\n     fn get_step_descriptions(kind: Kind) -> Vec<StepDescription> {\n         macro_rules! describe {\n             ($($rule:ty),+ $(,)?) => {{\n-                vec![$(StepDescription::from::<$rule>()),+]\n+                vec![$(StepDescription::from::<$rule>(kind)),+]\n             }};\n         }\n         match kind {\n@@ -540,8 +633,11 @@ impl<'a> Builder<'a> {\n \n         let builder = Self::new_internal(build, kind, vec![]);\n         let builder = &builder;\n-        let mut should_run = ShouldRun::new(builder);\n+        // The \"build\" kind here is just a placeholder, it will be replaced with something else in\n+        // the following statement.\n+        let mut should_run = ShouldRun::new(builder, Kind::Build);\n         for desc in Builder::get_step_descriptions(builder.kind) {\n+            should_run.kind = desc.kind;\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n@@ -552,11 +648,11 @@ impl<'a> Builder<'a> {\n             match pathset {\n                 PathSet::Set(set) => {\n                     for path in set {\n-                        add_path(&path);\n+                        add_path(&path.path);\n                     }\n                 }\n                 PathSet::Suite(path) => {\n-                    add_path(&path.join(\"...\"));\n+                    add_path(&path.path.join(\"...\"));\n                 }\n             }\n         }\n@@ -1626,9 +1722,10 @@ impl<'a> Builder<'a> {\n     pub(crate) fn ensure_if_default<T, S: Step<Output = Option<T>>>(\n         &'a self,\n         step: S,\n+        kind: Kind,\n     ) -> S::Output {\n-        let desc = StepDescription::from::<S>();\n-        let should_run = (desc.should_run)(ShouldRun::new(self));\n+        let desc = StepDescription::from::<S>(kind);\n+        let should_run = (desc.should_run)(ShouldRun::new(self, desc.kind));\n \n         // Avoid running steps contained in --exclude\n         for pathset in &should_run.paths {\n@@ -1642,13 +1739,16 @@ impl<'a> Builder<'a> {\n     }\n \n     /// Checks if any of the \"should_run\" paths is in the `Builder` paths.\n-    pub(crate) fn was_invoked_explicitly<S: Step>(&'a self) -> bool {\n-        let desc = StepDescription::from::<S>();\n-        let should_run = (desc.should_run)(ShouldRun::new(self));\n+    pub(crate) fn was_invoked_explicitly<S: Step>(&'a self, kind: Kind) -> bool {\n+        let desc = StepDescription::from::<S>(kind);\n+        let should_run = (desc.should_run)(ShouldRun::new(self, desc.kind));\n \n         for path in &self.paths {\n-            if should_run.paths.iter().any(|s| s.has(path))\n-                && !desc.is_excluded(self, &PathSet::Suite(path.clone()))\n+            if should_run.paths.iter().any(|s| s.has(path, Some(desc.kind)))\n+                && !desc.is_excluded(\n+                    self,\n+                    &PathSet::Suite(TaskPath { path: path.clone(), kind: Some(desc.kind.into()) }),\n+                )\n             {\n                 return true;\n             }"}, {"sha": "bc71034496968ff3fad5a502309b39e65ae72408", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=fc694064e8f2d9553738d4243c13c676327e9779", "patch": "@@ -499,7 +499,7 @@ mod dist {\n         let host = TargetSelection::from_user(\"A\");\n \n         builder.run_step_descriptions(\n-            &[StepDescription::from::<test::Crate>()],\n+            &[StepDescription::from::<test::Crate>(Kind::Test)],\n             &[\"library/std\".into()],\n         );\n \n@@ -520,7 +520,7 @@ mod dist {\n     #[test]\n     fn test_exclude() {\n         let mut config = configure(&[\"A\"], &[\"A\"]);\n-        config.exclude = vec![\"src/tools/tidy\".into()];\n+        config.exclude = vec![TaskPath::parse(\"src/tools/tidy\")];\n         config.cmd = Subcommand::Test {\n             paths: Vec::new(),\n             test_args: Vec::new(),"}, {"sha": "683cfc630e7715f6a8bfef208a3c5f8cd37f0833", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=fc694064e8f2d9553738d4243c13c676327e9779", "patch": "@@ -12,6 +12,7 @@ use std::fs;\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n+use crate::builder::TaskPath;\n use crate::cache::{Interned, INTERNER};\n use crate::channel::GitInfo;\n pub use crate::flags::Subcommand;\n@@ -62,7 +63,7 @@ pub struct Config {\n     pub sanitizers: bool,\n     pub profiler: bool,\n     pub ignore_git: bool,\n-    pub exclude: Vec<PathBuf>,\n+    pub exclude: Vec<TaskPath>,\n     pub include_default_paths: bool,\n     pub rustc_error_format: Option<String>,\n     pub json_output: bool,\n@@ -635,7 +636,7 @@ impl Config {\n         let flags = Flags::parse(&args);\n \n         let mut config = Config::default_opts();\n-        config.exclude = flags.exclude;\n+        config.exclude = flags.exclude.into_iter().map(|path| TaskPath::parse(path)).collect();\n         config.include_default_paths = flags.include_default_paths;\n         config.rustc_error_format = flags.rustc_error_format;\n         config.json_output = flags.json_output;"}, {"sha": "66b63cd1278c525f98649b45c697b41b79321989", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=fc694064e8f2d9553738d4243c13c676327e9779", "patch": "@@ -16,7 +16,7 @@ use std::process::Command;\n \n use build_helper::{output, t};\n \n-use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n use crate::config::TargetSelection;\n@@ -1368,7 +1368,7 @@ impl Step for Extended {\n         let mut built_tools = HashSet::new();\n         macro_rules! add_component {\n             ($name:expr => $step:expr) => {\n-                if let Some(tarball) = builder.ensure_if_default($step) {\n+                if let Some(tarball) = builder.ensure_if_default($step, Kind::Dist) {\n                     tarballs.push(tarball);\n                     built_tools.insert($name);\n                 }"}, {"sha": "23b5ddcd47a0ecbc02ac7760e652684726b5b8cc", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc694064e8f2d9553738d4243c13c676327e9779/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=fc694064e8f2d9553738d4243c13c676327e9779", "patch": "@@ -15,7 +15,7 @@ use std::path::{Path, PathBuf};\n use crate::Mode;\n use build_helper::{t, up_to_date};\n \n-use crate::builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n+use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n use crate::config::{Config, TargetSelection};\n@@ -240,7 +240,7 @@ impl Step for TheBook {\n             invoke_rustdoc(builder, compiler, target, path);\n         }\n \n-        if builder.was_invoked_explicitly::<Self>() {\n+        if builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n             let out = builder.doc_out(target);\n             let index = out.join(\"book\").join(\"index.html\");\n             open(builder, &index);\n@@ -400,7 +400,7 @@ impl Step for Standalone {\n \n         // We open doc/index.html as the default if invoked as `x.py doc --open`\n         // with no particular explicit doc requested (e.g. library/core).\n-        if builder.paths.is_empty() || builder.was_invoked_explicitly::<Self>() {\n+        if builder.paths.is_empty() || builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n             let index = out.join(\"index.html\");\n             open(builder, &index);\n         }\n@@ -902,7 +902,7 @@ impl Step for RustcBook {\n             name: INTERNER.intern_str(\"rustc\"),\n             src: INTERNER.intern_path(out_base),\n         });\n-        if builder.was_invoked_explicitly::<Self>() {\n+        if builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n             let out = builder.doc_out(self.target);\n             let index = out.join(\"rustc\").join(\"index.html\");\n             open(builder, &index);"}]}