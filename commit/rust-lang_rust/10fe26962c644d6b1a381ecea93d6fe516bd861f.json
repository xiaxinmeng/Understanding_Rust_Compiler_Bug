{"sha": "10fe26962c644d6b1a381ecea93d6fe516bd861f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZmUyNjk2MmM2NDRkNmIxYTM4MWVjZWE5M2Q2ZmU1MTZiZDg2MWY=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-05-23T19:53:59Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-05-24T17:43:42Z"}, "message": "Make ignore_borrow iterate instead of recurse", "tree": {"sha": "7f192d034c52edabc9367ad52527a500dd3cfb90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f192d034c52edabc9367ad52527a500dd3cfb90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10fe26962c644d6b1a381ecea93d6fe516bd861f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10fe26962c644d6b1a381ecea93d6fe516bd861f", "html_url": "https://github.com/rust-lang/rust/commit/10fe26962c644d6b1a381ecea93d6fe516bd861f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10fe26962c644d6b1a381ecea93d6fe516bd861f/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27cc0db7a248308fc2634ac68d7608a20b4a1c09", "url": "https://api.github.com/repos/rust-lang/rust/commits/27cc0db7a248308fc2634ac68d7608a20b4a1c09", "html_url": "https://github.com/rust-lang/rust/commit/27cc0db7a248308fc2634ac68d7608a20b4a1c09"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "9ad0e936e1b2d7b4283bd0b0c5f8f2134106eb8e", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/10fe26962c644d6b1a381ecea93d6fe516bd861f/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10fe26962c644d6b1a381ecea93d6fe516bd861f/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=10fe26962c644d6b1a381ecea93d6fe516bd861f", "patch": "@@ -25,40 +25,36 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         mir: &Mir<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        match self {\n-            // If a local variable is immutable, then we only need to track borrows to guard\n-            // against two kinds of errors:\n-            // * The variable being dropped while still borrowed (e.g., because the fn returns\n-            //   a reference to a local variable)\n-            // * The variable being moved while still borrowed\n-            //\n-            // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n-            // so we don't have to worry about mutation while borrowed.\n-            Place::Base(PlaceBase::Local(index)) => {\n-                match locals_state_at_exit {\n-                    LocalsStateAtExit::AllAreInvalidated => false,\n-                    LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                        let ignore = !has_storage_dead_or_moved.contains(*index) &&\n-                            mir.local_decls[*index].mutability == Mutability::Not;\n-                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n-                        ignore\n+        self.iterate(|place_base, place_projection| {\n+            let ignore = match place_base {\n+                // If a local variable is immutable, then we only need to track borrows to guard\n+                // against two kinds of errors:\n+                // * The variable being dropped while still borrowed (e.g., because the fn returns\n+                //   a reference to a local variable)\n+                // * The variable being moved while still borrowed\n+                //\n+                // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n+                // so we don't have to worry about mutation while borrowed.\n+                PlaceBase::Local(index) => {\n+                    match locals_state_at_exit {\n+                        LocalsStateAtExit::AllAreInvalidated => false,\n+                        LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n+                            let ignore = !has_storage_dead_or_moved.contains(*index) &&\n+                                mir.local_decls[*index].mutability == Mutability::Not;\n+                            debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n+                            ignore\n+                        }\n                     }\n                 }\n-            }\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n-                false,\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n-                tcx.is_mutable_static(*def_id)\n-            }\n-            Place::Projection(proj) => match proj.elem {\n-                ProjectionElem::Field(..)\n-                | ProjectionElem::Downcast(..)\n-                | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Index(_) => proj.base.ignore_borrow(\n-                    tcx, mir, locals_state_at_exit),\n+                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. }) =>\n+                    false,\n+                PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. }) => {\n+                    tcx.is_mutable_static(*def_id)\n+                }\n+            };\n \n-                ProjectionElem::Deref => {\n+            for proj in place_projection {\n+                if proj.elem == ProjectionElem::Deref {\n                     let ty = proj.base.ty(mir, tcx).ty;\n                     match ty.sty {\n                         // For both derefs of raw pointers and `&T`\n@@ -71,11 +67,13 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                         // original path into a new variable and\n                         // borrowed *that* one, leaving the original\n                         // path unborrowed.\n-                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => true,\n-                        _ => proj.base.ignore_borrow(tcx, mir, locals_state_at_exit),\n+                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => return true,\n+                        _ => {}\n                     }\n                 }\n-            },\n-        }\n+            }\n+\n+            ignore\n+        })\n     }\n }"}]}