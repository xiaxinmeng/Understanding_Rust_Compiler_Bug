{"sha": "8cdc3fda11b2e341f305c03678a04c6bb01ce635", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZGMzZmRhMTFiMmUzNDFmMzA1YzAzNjc4YTA0YzZiYjAxY2U2MzU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-15T22:59:39Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-20T22:08:18Z"}, "message": "convert ast::ty into a struct", "tree": {"sha": "203eb55d29526de6c6148fd603d94d597165334c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/203eb55d29526de6c6148fd603d94d597165334c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cdc3fda11b2e341f305c03678a04c6bb01ce635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cdc3fda11b2e341f305c03678a04c6bb01ce635", "html_url": "https://github.com/rust-lang/rust/commit/8cdc3fda11b2e341f305c03678a04c6bb01ce635", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cdc3fda11b2e341f305c03678a04c6bb01ce635/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a3a1fc1489fb1f313fdd75af4e73a6a3b271ce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3a1fc1489fb1f313fdd75af4e73a6a3b271ce2", "html_url": "https://github.com/rust-lang/rust/commit/8a3a1fc1489fb1f313fdd75af4e73a6a3b271ce2"}], "stats": {"total": 229, "additions": 149, "deletions": 80}, "files": [{"sha": "2dea8d8717637ad37d6909f9f9bb084fc79cdfcf", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -329,19 +329,25 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::Ty {\n         mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n                       cx.sess.ident_of(~\"TestDesc\")]);\n \n-    let test_desc_ty: ast::Ty =\n-        {id: cx.sess.next_node_id(),\n-         node: ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()),\n-         span: dummy_sp()};\n+    let test_desc_ty = ast::Ty {\n+        id: cx.sess.next_node_id(),\n+        node: ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()),\n+        span: dummy_sp(),\n+    };\n \n     let vec_mt = ast::mt {ty: @test_desc_ty, mutbl: ast::m_imm};\n \n-    let inner_ty = @{id: cx.sess.next_node_id(),\n-                     node: ast::ty_vec(vec_mt),\n-                     span: dummy_sp()};\n-    return @{id: cx.sess.next_node_id(),\n-          node: ast::ty_uniq(ast::mt {ty: inner_ty, mutbl: ast::m_imm}),\n-          span: dummy_sp()};\n+    let inner_ty = @ast::Ty {\n+        id: cx.sess.next_node_id(),\n+        node: ast::ty_vec(vec_mt),\n+        span: dummy_sp(),\n+    };\n+\n+    @ast::Ty {\n+        id: cx.sess.next_node_id(),\n+        node: ast::ty_uniq(ast::mt { ty: inner_ty, mutbl: ast::m_imm }),\n+        span: dummy_sp(),\n+    }\n }\n \n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n@@ -482,7 +488,11 @@ fn mk_test_wrapper(cx: test_ctxt,\n \n     let wrapper_decl: ast::fn_decl = {\n         inputs: ~[],\n-        output: @{id: cx.sess.next_node_id(), node: ast::ty_nil, span: span},\n+        output: @ast::Ty {\n+            id: cx.sess.next_node_id(),\n+            node: ast::ty_nil,\n+            span: span,\n+        },\n         cf: ast::return_val\n     };\n \n@@ -505,9 +515,11 @@ fn mk_test_wrapper(cx: test_ctxt,\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n-    let ret_ty = {id: cx.sess.next_node_id(),\n-                  node: ast::ty_nil,\n-                  span: dummy_sp()};\n+    let ret_ty = ast::Ty {\n+        id: cx.sess.next_node_id(),\n+        node: ast::ty_nil,\n+        span: dummy_sp(),\n+    };\n \n     let decl: ast::fn_decl =\n         {inputs: ~[],"}, {"sha": "0805757d829f018e7952473e72c8a98c8a07504b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -1281,7 +1281,7 @@ impl Resolver {\n                 // If there are static methods, then create the module\n                 // and add them.\n                 match (trait_ref_opt, ty) {\n-                    (None, @{ id: _, node: ty_path(path, _), span: _ }) if\n+                    (None, @Ty { node: ty_path(path, _), _ }) if\n                             has_static_methods && path.idents.len() == 1 => {\n                         // Create the module.\n                         let name = path_to_ident(path);"}, {"sha": "4ae99d03c8dea96260cc93f01aa1d38cf7ba009c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -1040,7 +1040,11 @@ impl float_ty : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-type Ty = {id: node_id, node: ty_, span: span};\n+struct Ty {\n+    id: node_id,\n+    node: ty_,\n+    span: span,\n+}\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n #[auto_encode]"}, {"sha": "0af9d2211be6fbd2590c66a71603b3bee42bbd8a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -435,7 +435,7 @@ fn operator_prec(op: ast::binop) -> uint {\n }\n \n fn dtor_dec() -> fn_decl {\n-    let nil_t = @{id: 0, node: ty_nil, span: dummy_sp()};\n+    let nil_t = @ast::Ty { id: 0, node: ty_nil, span: dummy_sp() };\n     // dtor has no args\n     {inputs: ~[],\n      output: nil_t, cf: return_val}"}, {"sha": "aa5775918047468076257f46b76c1a8f7a18c4d5", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -130,7 +130,10 @@ fn expand_auto_encode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_encode) {\n             match item.node {\n-                ast::item_ty(@{node: ast::ty_rec(ref fields), _}, tps) => {\n+                ast::item_ty(\n+                    @ast::Ty {node: ast::ty_rec(ref fields), _},\n+                    tps\n+                ) => {\n                     let ser_impl = mk_rec_ser_impl(\n                         cx,\n                         item.span,\n@@ -196,7 +199,10 @@ fn expand_auto_decode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_decode) {\n             match item.node {\n-                ast::item_ty(@{node: ast::ty_rec(ref fields), _}, tps) => {\n+                ast::item_ty(\n+                    @ast::Ty {node: ast::ty_rec(ref fields), _},\n+                    tps\n+                ) => {\n                     let deser_impl = mk_rec_deser_impl(\n                         cx,\n                         item.span,\n@@ -249,7 +255,7 @@ priv impl ext_ctxt {\n         path: @ast::path,\n         bounds: @~[ast::ty_param_bound]\n     ) -> ast::ty_param {\n-        let bound = ast::TraitTyParamBound(@{\n+        let bound = ast::TraitTyParamBound(@ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_path(path, self.next_id()),\n             span: span,\n@@ -315,9 +321,13 @@ priv impl ext_ctxt {\n \n     fn ty_path(span: span, strs: ~[ast::ident],\n                tps: ~[@ast::Ty]) -> @ast::Ty {\n-        @{id: self.next_id(),\n-          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n-          span: span}\n+        @ast::Ty {\n+            id: self.next_id(),\n+            node: ast::ty_path(\n+                self.path_tps(span, strs, tps),\n+                self.next_id()),\n+            span: span,\n+        }\n     }\n \n     fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n@@ -438,7 +448,7 @@ fn mk_impl(\n     let mut trait_tps = vec::append(\n         ~[ty_param],\n          do tps.map |tp| {\n-            let t_bound = ast::TraitTyParamBound(@{\n+            let t_bound = ast::TraitTyParamBound(@ast::Ty {\n                 id: cx.next_id(),\n                 node: ast::ty_path(path, cx.next_id()),\n                 span: span,\n@@ -568,7 +578,7 @@ fn mk_ser_method(\n     span: span,\n     ser_body: ast::blk\n ) -> @ast::method {\n-    let ty_s = @{\n+    let ty_s = @ast::Ty {\n         id: cx.next_id(),\n         node: ast::ty_rptr(\n             @{\n@@ -597,7 +607,7 @@ fn mk_ser_method(\n         id: cx.next_id(),\n     }];\n \n-    let ser_output = @{\n+    let ser_output = @ast::Ty {\n         id: cx.next_id(),\n         node: ast::ty_nil,\n         span: span,\n@@ -631,7 +641,7 @@ fn mk_deser_method(\n     ty: @ast::Ty,\n     deser_body: ast::blk\n ) -> @ast::method {\n-    let ty_d = @{\n+    let ty_d = @ast::Ty {\n         id: cx.next_id(),\n         node: ast::ty_rptr(\n             @{\n@@ -670,8 +680,7 @@ fn mk_deser_method(\n         ident: cx.ident_of(~\"decode\"),\n         attrs: ~[],\n         tps: ~[],\n-        self_ty: ast::spanned { node: ast::sty_static,\n-                                span: span },\n+        self_ty: ast::spanned { node: ast::sty_static, span: span },\n         purity: ast::impure_fn,\n         decl: deser_decl,\n         body: deser_body,\n@@ -1181,7 +1190,7 @@ fn mk_enum_deser_body(\n             {\n                 inputs: ~[{\n                     mode: ast::infer(cx.next_id()),\n-                    ty: @{\n+                    ty: @ast::Ty {\n                         id: cx.next_id(),\n                         node: ast::ty_infer,\n                         span: span\n@@ -1196,7 +1205,7 @@ fn mk_enum_deser_body(\n                     },\n                     id: cx.next_id(),\n                 }],\n-                output: @{\n+                output: @ast::Ty {\n                     id: cx.next_id(),\n                     node: ast::ty_infer,\n                     span: span,"}, {"sha": "20f2f16058fd79c044c5c281ac097f218cae9ed4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -194,7 +194,7 @@ fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n             None),\n         span: sp,\n     };\n-    let ty : @ast::Ty = @{ id: cx.next_id(), node: ast::ty_infer, span: sp };\n+    let ty = @ast::Ty { id: cx.next_id(), node: ast::ty_infer, span: sp };\n     let local = @ast::spanned {\n         node: ast::local_ {\n             is_mutbl: mutbl,\n@@ -293,7 +293,7 @@ fn mk_ty_path(cx: ext_ctxt,\n            -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n-    let ty = @{ id: cx.next_id(), node: move ty, span: span };\n+    let ty = @ast::Ty { id: cx.next_id(), node: move ty, span: span };\n     ty\n }\n fn mk_ty_path_global(cx: ext_ctxt,\n@@ -302,7 +302,7 @@ fn mk_ty_path_global(cx: ext_ctxt,\n                   -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n-    let ty = @{ id: cx.next_id(), node: move ty, span: span };\n+    let ty = @ast::Ty { id: cx.next_id(), node: move ty, span: span };\n     ty\n }\n fn mk_simple_ty_path(cx: ext_ctxt,"}, {"sha": "b272348244d51004faf32cb188e7709a33613938", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -140,7 +140,11 @@ fn create_eq_method(cx: ext_ctxt,\n         arg_region,\n         ast::mt { ty: arg_path_type, mutbl: m_imm }\n     );\n-    let arg_type = @{ id: cx.next_id(), node: move arg_type, span: span };\n+    let arg_type = @ast::Ty {\n+        id: cx.next_id(),\n+        node: arg_type,\n+        span: span,\n+    };\n \n     // Create the `other` parameter.\n     let other_ident = cx.ident_of(~\"__other\");\n@@ -150,10 +154,10 @@ fn create_eq_method(cx: ext_ctxt,\n     let bool_ident = cx.ident_of(~\"bool\");\n     let output_type = build::mk_raw_path(span, ~[ bool_ident ]);\n     let output_type = ty_path(output_type, cx.next_id());\n-    let output_type = @{\n+    let output_type = @ast::Ty {\n         id: cx.next_id(),\n-        node: move output_type,\n-        span: span\n+        node: output_type,\n+        span: span,\n     };\n \n     // Create the function declaration.\n@@ -199,7 +203,7 @@ fn create_self_type_with_params(cx: ext_ctxt,\n                                         ~[ type_ident ],\n                                         move self_ty_params);\n     let self_type = ty_path(self_type, cx.next_id());\n-    @{ id: cx.next_id(), node: move self_type, span: span }\n+    @ast::Ty { id: cx.next_id(), node: self_type, span: span }\n }\n \n fn create_derived_impl(cx: ext_ctxt,\n@@ -303,7 +307,7 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n     let f_arg = build::mk_arg(cx, span, f_ident, f_arg_type);\n \n     // Create the type of the return value.\n-    let output_type = @{ id: cx.next_id(), node: ty_nil, span: span };\n+    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n \n     // Create the function declaration.\n     let inputs = ~[ move lsb0_arg, move f_arg ];"}, {"sha": "36ef9ac0cdfbce4f28e4d9c0a633eff09d31abef", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -176,15 +176,19 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn ty_rec(+fields: ~[ast::ty_field]) -> @ast::Ty {\n-        @{id: self.next_id(),\n-          node: ast::ty_rec(fields),\n-          span: dummy_sp()}\n+        @ast::Ty {\n+            id: self.next_id(),\n+            node: ast::ty_rec(fields),\n+            span: dummy_sp(),\n+        }\n     }\n \n     fn ty_infer() -> @ast::Ty {\n-        @{id: self.next_id(),\n-          node: ast::ty_infer,\n-          span: dummy_sp()}\n+        @ast::Ty {\n+            id: self.next_id(),\n+            node: ast::ty_infer,\n+            span: dummy_sp(),\n+        }\n     }\n \n     fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n@@ -340,15 +344,19 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn ty_path_ast_builder(path: @ast::path) -> @ast::Ty {\n-        @{id: self.next_id(),\n-          node: ast::ty_path(path, self.next_id()),\n-          span: path.span}\n+        @ast::Ty {\n+            id: self.next_id(),\n+            node: ast::ty_path(path, self.next_id()),\n+            span: path.span,\n+        }\n     }\n \n     fn ty_nil_ast_builder() -> @ast::Ty {\n-        @{id: self.next_id(),\n-          node: ast::ty_nil,\n-          span: dummy_sp()}\n+        @ast::Ty {\n+            id: self.next_id(),\n+            node: ast::ty_nil,\n+            span: dummy_sp(),\n+        }\n     }\n \n     fn item_ty_poly(name: ident,"}, {"sha": "aad6afbf43427818e28d8bb5c4fba4d04b197397", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -770,7 +770,11 @@ impl ast_fold_fns: ast_fold {\n     }\n     fn fold_ty(&&x: @Ty) -> @Ty {\n         let (n, s) = (self.fold_ty)(x.node, x.span, self as ast_fold);\n-        return @{id: (self.new_id)(x.id), node: n, span: (self.new_span)(s)};\n+        @Ty {\n+            id: (self.new_id)(x.id),\n+            node: n,\n+            span: (self.new_span)(s),\n+        }\n     }\n     fn fold_mod(x: _mod) -> _mod {\n         return (self.fold_mod)(x, self as ast_fold);"}, {"sha": "2db9cdf3c3090b9b52fb88462de7286119f3d107", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 55, "deletions": 27, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdc3fda11b2e341f305c03678a04c6bb01ce635/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8cdc3fda11b2e341f305c03678a04c6bb01ce635", "patch": "@@ -478,17 +478,27 @@ impl Parser {\n         return if self.eat(token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(token::NOT) {\n-                (noreturn, @{id: self.get_id(),\n-                             node: ty_bot,\n-                             span: mk_sp(lo, self.last_span.hi)})\n+                (\n+                    noreturn,\n+                    @Ty {\n+                        id: self.get_id(),\n+                        node: ty_bot,\n+                        span: mk_sp(lo, self.last_span.hi)\n+                    }\n+                )\n             } else {\n                 (return_val, self.parse_ty(false))\n             }\n         } else {\n             let pos = self.span.lo;\n-            (return_val, @{id: self.get_id(),\n-                           node: ty_nil,\n-                           span: mk_sp(pos, pos)})\n+            (\n+                return_val,\n+                @Ty {\n+                    id: self.get_id(),\n+                    node: ty_nil,\n+                    span: mk_sp(pos, pos),\n+                }\n+            )\n         }\n     }\n \n@@ -580,7 +590,7 @@ impl Parser {\n         } else { self.fatal(~\"expected type\"); };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n-        return @{id: self.get_id(), node: t, span: sp};\n+        @Ty {id: self.get_id(), node: t, span: sp}\n     }\n \n     fn parse_box_or_uniq_pointee(\n@@ -731,9 +741,11 @@ impl Parser {\n             let t = if p.eat(token::COLON) {\n                 p.parse_ty(false)\n             } else {\n-                @{id: p.get_id(),\n-                  node: ty_infer,\n-                  span: mk_sp(p.span.lo, p.span.hi)}\n+                @Ty {\n+                    id: p.get_id(),\n+                    node: ty_infer,\n+                    span: mk_sp(p.span.lo, p.span.hi),\n+                }\n             };\n             either::Left({mode: m, ty: t, pat: pat, id: p.get_id()})\n         }\n@@ -1565,7 +1577,7 @@ impl Parser {\n                     ({\n                         {\n                             inputs: ~[],\n-                            output: @{\n+                            output: @Ty {\n                                 id: self.get_id(),\n                                 node: ty_infer,\n                                 span: self.span\n@@ -2150,9 +2162,11 @@ impl Parser {\n                    allow_init: bool) -> @local {\n         let lo = self.span.lo;\n         let pat = self.parse_pat(false);\n-        let mut ty = @{id: self.get_id(),\n-                       node: ty_infer,\n-                       span: mk_sp(lo, lo)};\n+        let mut ty = @Ty {\n+            id: self.get_id(),\n+            node: ty_infer,\n+            span: mk_sp(lo, lo),\n+        };\n         if self.eat(token::COLON) { ty = self.parse_ty(false); }\n         let init = if allow_init { self.parse_initializer() } else { None };\n         @spanned(\n@@ -2430,9 +2444,13 @@ impl Parser {\n     }\n \n     fn mk_ty_path(i: ident) -> @Ty {\n-        @{id: self.get_id(), node: ty_path(\n-            ident_to_path(copy self.last_span, i),\n-            self.get_id()), span: self.last_span}\n+        @Ty {\n+            id: self.get_id(),\n+            node: ty_path(\n+                ident_to_path(copy self.last_span, i),\n+                self.get_id()),\n+            span: self.last_span,\n+        }\n     }\n \n     fn parse_optional_purity() -> ast::purity {\n@@ -2650,7 +2668,7 @@ impl Parser {\n         let output = if self.eat(token::RARROW) {\n             self.parse_ty(false)\n         } else {\n-            @{id: self.get_id(), node: ty_infer, span: self.span}\n+            @Ty { id: self.get_id(), node: ty_infer, span: self.span }\n         };\n         return ({inputs: either::lefts(inputs_captures),\n                  output: output,\n@@ -2733,7 +2751,11 @@ impl Parser {\n     //    impl<T> ~[T] : to_str { ... }\n     fn parse_item_impl() -> item_info {\n         fn wrap_path(p: Parser, pt: @path) -> @Ty {\n-            @{id: p.get_id(), node: ty_path(pt, p.get_id()), span: pt.span}\n+            @Ty {\n+                id: p.get_id(),\n+                node: ty_path(pt, p.get_id()),\n+                span: pt.span,\n+            }\n         }\n \n         // We do two separate paths here: old-style impls and new-style impls.\n@@ -2786,7 +2808,7 @@ impl Parser {\n              idents: ~[i],\n              rp: None,\n              types: do typarams.map |tp| {\n-                @{\n+                @Ty {\n                     id: self.get_id(),\n                     node: ty_path(ident_to_path(s, tp.ident), self.get_id()),\n                     span: s\n@@ -2938,13 +2960,19 @@ impl Parser {\n             self.obsolete(copy self.span, ObsoleteClassMethod);\n             self.parse_method();\n             // bogus value\n-            @spanned(self.span.lo, self.span.hi,\n-                     ast::struct_field_ {\n-                       kind: unnamed_field,\n-                       id: self.get_id(),\n-                       ty: @{id: self.get_id(),\n-                             node: ty_nil,\n-                             span: copy self.span} })\n+            @spanned(\n+                self.span.lo,\n+                self.span.hi,\n+                ast::struct_field_ {\n+                    kind: unnamed_field,\n+                    id: self.get_id(),\n+                    ty: @ast::Ty {\n+                        id: self.get_id(),\n+                        node: ty_nil,\n+                        span: copy self.span,\n+                    }\n+                }\n+            )\n         }\n     }\n "}]}