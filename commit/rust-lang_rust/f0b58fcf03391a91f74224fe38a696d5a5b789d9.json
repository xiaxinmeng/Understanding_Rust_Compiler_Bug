{"sha": "f0b58fcf03391a91f74224fe38a696d5a5b789d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYjU4ZmNmMDMzOTFhOTFmNzQyMjRmZTM4YTY5NmQ1YTViNzg5ZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-11T18:46:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-11T18:46:18Z"}, "message": "Auto merge of #64271 - Centril:non-exhaustive-peel-refs, r=estebank\n\ncheck_match: refactor + improve non-exhaustive diagnostics for default binding modes\n\nRefactor `check_match` a bit with more code-reuse and improve the diagnostics for a non-exhaustive pattern match by peeling off any references from the scrutinee type so that the \"defined here\" label is added in more cases. For example:\n\n```rust\nerror[E0004]: non-exhaustive patterns: `&mut &B` not covered\n --> foo.rs:4:11\n  |\n1 | enum E { A, B }\n  | ---------------\n  | |           |\n  | |           not covered\n  | `E` defined here\n...\n4 |     match x {\n  |           ^ pattern `&mut &B` not covered\n  |\n  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n```\n\nMoreover, wrt. \"defined here\", we give irrefutable pattern matching (i.e. in `let`, `for`, and `fn` parameters) a more consistent treatment in line with `match`.\n\nr? @estebank", "tree": {"sha": "fcfed11712e1af5cad16ef353352914ccfef69d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcfed11712e1af5cad16ef353352914ccfef69d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0b58fcf03391a91f74224fe38a696d5a5b789d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0b58fcf03391a91f74224fe38a696d5a5b789d9", "html_url": "https://github.com/rust-lang/rust/commit/f0b58fcf03391a91f74224fe38a696d5a5b789d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0b58fcf03391a91f74224fe38a696d5a5b789d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe6d05a8b32f5c66c427ca524dbcce5a7145f87e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe6d05a8b32f5c66c427ca524dbcce5a7145f87e", "html_url": "https://github.com/rust-lang/rust/commit/fe6d05a8b32f5c66c427ca524dbcce5a7145f87e"}, {"sha": "20a26055b7afa500e1b00c6e5a3d03a1208c1d00", "url": "https://api.github.com/repos/rust-lang/rust/commits/20a26055b7afa500e1b00c6e5a3d03a1208c1d00", "html_url": "https://github.com/rust-lang/rust/commit/20a26055b7afa500e1b00c6e5a3d03a1208c1d00"}], "stats": {"total": 588, "additions": 429, "deletions": 159}, "files": [{"sha": "78d94df4fa03be353a56fe6b7f6bceee41d60104", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -996,6 +996,24 @@ impl<'tcx> ty::TyS<'tcx> {\n         debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n         r\n     }\n+\n+    /// Peel off all reference types in this type until there are none left.\n+    ///\n+    /// This method is idempotent, i.e. `ty.peel_refs().peel_refs() == ty.peel_refs()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// - `u8` -> `u8`\n+    /// - `&'a mut u8` -> `u8`\n+    /// - `&'a &'b u8` -> `u8`\n+    /// - `&'a *const &'b u8 -> *const &'b u8`\n+    pub fn peel_refs(&'tcx self) -> Ty<'tcx> {\n+        let mut ty = self;\n+        while let Ref(_, inner_ty, _) = ty.sty {\n+            ty = inner_ty;\n+        }\n+        ty\n+    }\n }\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {"}, {"sha": "a6d955f3369100e7b1a007202a5fc0dcb9923c97", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -517,9 +517,9 @@ struct PatternContext<'tcx> {\n pub struct Witness<'tcx>(Vec<Pattern<'tcx>>);\n \n impl<'tcx> Witness<'tcx> {\n-    pub fn single_pattern(&self) -> &Pattern<'tcx> {\n+    pub fn single_pattern(self) -> Pattern<'tcx> {\n         assert_eq!(self.0.len(), 1);\n-        &self.0[0]\n+        self.0.into_iter().next().unwrap()\n     }\n \n     fn push_wild_constructor<'a>("}, {"sha": "161c58a17557966d31c8c7eb5f810e9c4877e299", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 115, "deletions": 107, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -52,7 +52,7 @@ struct MatchVisitor<'a, 'tcx> {\n     signalled_error: SignalledError,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n@@ -89,8 +89,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     }\n }\n \n-\n-impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n+impl PatternContext<'_, '_> {\n     fn report_inlining_errors(&self, pat_span: Span) {\n         for error in &self.errors {\n             match *error {\n@@ -122,7 +121,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n+impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_patterns(&mut self, has_guard: bool, pats: &[P<Pat>]) {\n         check_legality_of_move_bindings(self, has_guard, pats);\n         for pat in pats {\n@@ -265,37 +264,26 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n-            let wild_pattern = Pattern {\n-                ty: pattern_ty,\n-                span: DUMMY_SP,\n-                kind: box PatternKind::Wild,\n-            };\n-            let witness = match is_useful(cx, &pats, &[&wild_pattern], ConstructWitness) {\n-                UsefulWithWitness(witness) => witness,\n-                NotUseful => return,\n-                Useful => bug!()\n+            let witnesses = match check_not_useful(cx, pattern_ty, &pats) {\n+                Ok(_) => return,\n+                Err(err) => err,\n             };\n \n-            let pattern_string = witness[0].single_pattern().to_string();\n+            let joined_patterns = joined_uncovered_patterns(&witnesses);\n             let mut err = struct_span_err!(\n                 self.tcx.sess, pat.span, E0005,\n-                \"refutable pattern in {}: `{}` not covered\",\n-                origin, pattern_string\n+                \"refutable pattern in {}: {} not covered\",\n+                origin, joined_patterns\n             );\n-            let label_msg = match pat.node {\n-                PatKind::Path(hir::QPath::Resolved(None, ref path))\n-                        if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n+            err.span_label(pat.span, match &pat.node {\n+                PatKind::Path(hir::QPath::Resolved(None, path))\n+                    if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as {} {} pattern, not new variable\",\n                             path.res.article(), path.res.descr())\n                 }\n-                _ => format!(\"pattern `{}` not covered\", pattern_string),\n-            };\n-            err.span_label(pat.span, label_msg);\n-            if let ty::Adt(def, _) = pattern_ty.sty {\n-                if let Some(sp) = self.tcx.hir().span_if_local(def.did){\n-                    err.span_label(sp, format!(\"`{}` defined here\", pattern_ty));\n-                }\n-            }\n+                _ => pattern_not_convered_label(&witnesses, &joined_patterns),\n+            });\n+            adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n             err.emit();\n         });\n     }\n@@ -350,9 +338,9 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n }\n \n // Check for unreachable patterns\n-fn check_arms<'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    arms: &[(Vec<(&'a Pattern<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n+fn check_arms<'tcx>(\n+    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+    arms: &[(Vec<(&Pattern<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n     source: hir::MatchSource,\n ) {\n     let mut seen = Matrix::empty();\n@@ -433,104 +421,124 @@ fn check_arms<'a, 'tcx>(\n     }\n }\n \n-fn check_exhaustive<'p, 'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+fn check_not_useful(\n+    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+    ty: Ty<'tcx>,\n+    matrix: &Matrix<'_, 'tcx>,\n+) -> Result<(), Vec<Pattern<'tcx>>> {\n+    let wild_pattern = Pattern { ty, span: DUMMY_SP, kind: box PatternKind::Wild };\n+    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n+        NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n+        UsefulWithWitness(pats) => Err(if pats.is_empty() {\n+            vec![wild_pattern]\n+        } else {\n+            pats.into_iter().map(|w| w.single_pattern()).collect()\n+        }),\n+        Useful => bug!(),\n+    }\n+}\n+\n+fn check_exhaustive<'tcx>(\n+    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n-    matrix: &Matrix<'p, 'tcx>,\n+    matrix: &Matrix<'_, 'tcx>,\n ) {\n-    let wild_pattern = Pattern {\n-        ty: scrut_ty,\n-        span: DUMMY_SP,\n-        kind: box PatternKind::Wild,\n+    let witnesses = match check_not_useful(cx, scrut_ty, matrix) {\n+        Ok(_) => return,\n+        Err(err) => err,\n     };\n-    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n-        UsefulWithWitness(pats) => {\n-            let witnesses = if pats.is_empty() {\n-                vec![&wild_pattern]\n-            } else {\n-                pats.iter().map(|w| w.single_pattern()).collect()\n-            };\n \n-            const LIMIT: usize = 3;\n-            let joined_patterns = match witnesses.len() {\n-                0 => bug!(),\n-                1 => format!(\"`{}`\", witnesses[0]),\n-                2..=LIMIT => {\n-                    let (tail, head) = witnesses.split_last().unwrap();\n-                    let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n-                    format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n-                }\n-                _ => {\n-                    let (head, tail) = witnesses.split_at(LIMIT);\n-                    let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n-                    format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n-                }\n-            };\n+    let joined_patterns = joined_uncovered_patterns(&witnesses);\n+    let mut err = create_e0004(\n+        cx.tcx.sess, sp,\n+        format!(\"non-exhaustive patterns: {} not covered\", joined_patterns),\n+    );\n+    err.span_label(sp, pattern_not_convered_label(&witnesses, &joined_patterns));\n+    adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n+    err.help(\n+        \"ensure that all possible cases are being handled, \\\n+        possibly by adding wildcards or more match arms\"\n+    )\n+    .emit();\n+}\n \n-            let label_text = match witnesses.len() {\n-                1 => format!(\"pattern {} not covered\", joined_patterns),\n-                _ => format!(\"patterns {} not covered\", joined_patterns),\n-            };\n-            let mut err = create_e0004(cx.tcx.sess, sp, format!(\n-                \"non-exhaustive patterns: {} not covered\",\n-                joined_patterns,\n-            ));\n-            err.span_label(sp, label_text);\n-            // point at the definition of non-covered enum variants\n-            if let ty::Adt(def, _) = scrut_ty.sty {\n-                if let Some(sp) = cx.tcx.hir().span_if_local(def.did){\n-                    err.span_label(sp, format!(\"`{}` defined here\", scrut_ty));\n-                }\n-            }\n-            let patterns = witnesses.iter().map(|p| (**p).clone()).collect::<Vec<Pattern<'_>>>();\n-            if patterns.len() < 4 {\n-                for sp in maybe_point_at_variant(cx, scrut_ty, patterns.as_slice()) {\n-                    err.span_label(sp, \"not covered\");\n-                }\n-            }\n-            err.help(\"ensure that all possible cases are being handled, \\\n-                      possibly by adding wildcards or more match arms\");\n-            err.emit();\n+fn joined_uncovered_patterns(witnesses: &[Pattern<'_>]) -> String {\n+    const LIMIT: usize = 3;\n+    match witnesses {\n+        [] => bug!(),\n+        [witness] => format!(\"`{}`\", witness),\n+        [head @ .., tail] if head.len() < LIMIT => {\n+            let head: Vec<_> = head.iter().map(<_>::to_string).collect();\n+            format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n         }\n-        NotUseful => {\n-            // This is good, wildcard pattern isn't reachable\n+        _ => {\n+            let (head, tail) = witnesses.split_at(LIMIT);\n+            let head: Vec<_> = head.iter().map(<_>::to_string).collect();\n+            format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n         }\n-        _ => bug!()\n     }\n }\n \n-fn maybe_point_at_variant(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    ty: Ty<'tcx>,\n-    patterns: &[Pattern<'_>],\n-) -> Vec<Span> {\n+fn pattern_not_convered_label(witnesses: &[Pattern<'_>], joined_patterns: &str) -> String {\n+    format!(\"pattern{} {} not covered\", rustc_errors::pluralise!(witnesses.len()), joined_patterns)\n+}\n+\n+/// Point at the definition of non-covered `enum` variants.\n+fn adt_defined_here(\n+    cx: &MatchCheckCtxt<'_, '_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    ty: Ty<'_>,\n+    witnesses: &[Pattern<'_>],\n+) {\n+    let ty = ty.peel_refs();\n+    if let ty::Adt(def, _) = ty.sty {\n+        if let Some(sp) = cx.tcx.hir().span_if_local(def.did) {\n+            err.span_label(sp, format!(\"`{}` defined here\", ty));\n+        }\n+\n+        if witnesses.len() < 4 {\n+            for sp in maybe_point_at_variant(ty, &witnesses) {\n+                err.span_label(sp, \"not covered\");\n+            }\n+        }\n+    }\n+}\n+\n+fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[Pattern<'_>]) -> Vec<Span> {\n     let mut covered = vec![];\n     if let ty::Adt(def, _) = ty.sty {\n         // Don't point at variants that have already been covered due to other patterns to avoid\n-        // visual clutter\n+        // visual clutter.\n         for pattern in patterns {\n-            let pk: &PatternKind<'_> = &pattern.kind;\n-            if let PatternKind::Variant { adt_def, variant_index, subpatterns, .. } = pk {\n-                if adt_def.did == def.did {\n+            use PatternKind::{AscribeUserType, Deref, Variant, Or, Leaf};\n+            match &*pattern.kind {\n+                AscribeUserType { subpattern, .. } | Deref { subpattern } => {\n+                    covered.extend(maybe_point_at_variant(ty, slice::from_ref(&subpattern)));\n+                }\n+                Variant { adt_def, variant_index, subpatterns, .. } if adt_def.did == def.did => {\n                     let sp = def.variants[*variant_index].ident.span;\n                     if covered.contains(&sp) {\n                         continue;\n                     }\n                     covered.push(sp);\n-                    let subpatterns = subpatterns.iter()\n+\n+                    let pats = subpatterns.iter()\n                         .map(|field_pattern| field_pattern.pattern.clone())\n-                        .collect::<Vec<_>>();\n-                    covered.extend(\n-                        maybe_point_at_variant(cx, ty, subpatterns.as_slice()),\n-                    );\n+                        .collect::<Box<[_]>>();\n+                    covered.extend(maybe_point_at_variant(ty, &pats));\n                 }\n-            }\n-            if let PatternKind::Leaf { subpatterns } = pk {\n-                let subpatterns = subpatterns.iter()\n-                    .map(|field_pattern| field_pattern.pattern.clone())\n-                    .collect::<Vec<_>>();\n-                covered.extend(maybe_point_at_variant(cx, ty, subpatterns.as_slice()));\n+                Leaf { subpatterns } => {\n+                    let pats = subpatterns.iter()\n+                        .map(|field_pattern| field_pattern.pattern.clone())\n+                        .collect::<Box<[_]>>();\n+                    covered.extend(maybe_point_at_variant(ty, &pats));\n+                }\n+                Or { pats } => {\n+                    let pats = pats.iter().cloned().collect::<Box<[_]>>();\n+                    covered.extend(maybe_point_at_variant(ty, &pats));\n+                }\n+                _ => {}\n             }\n         }\n     }\n@@ -627,7 +635,7 @@ struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     bindings_allowed: bool\n }\n \n-impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n+impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n         NestedVisitorMap::None\n     }"}, {"sha": "18b555dc037c2c2853ec862cdecfbeefe7b45107", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -268,7 +268,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 op.node.as_str(), lhs_ty),\n                             );\n                             let mut suggested_deref = false;\n-                            if let Ref(_, mut rty, _) = lhs_ty.sty {\n+                            if let Ref(_, rty, _) = lhs_ty.sty {\n                                 if {\n                                     self.infcx.type_is_copy_modulo_regions(self.param_env,\n                                                                            rty,\n@@ -279,13 +279,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             .is_ok()\n                                 } {\n                                     if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        while let Ref(_, rty_inner, _) = rty.sty {\n-                                            rty = rty_inner;\n-                                        }\n                                         let msg = &format!(\n                                             \"`{}=` can be used on '{}', you can dereference `{}`\",\n                                             op.node.as_str(),\n-                                            rty,\n+                                            rty.peel_refs(),\n                                             lstring,\n                                         );\n                                         err.span_suggestion(\n@@ -361,7 +358,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n \n                             let mut suggested_deref = false;\n-                            if let Ref(_, mut rty, _) = lhs_ty.sty {\n+                            if let Ref(_, rty, _) = lhs_ty.sty {\n                                 if {\n                                     self.infcx.type_is_copy_modulo_regions(self.param_env,\n                                                                            rty,\n@@ -372,17 +369,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             .is_ok()\n                                 } {\n                                     if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        while let Ref(_, rty_inner, _) = rty.sty {\n-                                            rty = rty_inner;\n-                                        }\n-                                        let msg = &format!(\n-                                                \"`{}` can be used on '{}', you can \\\n-                                                dereference `{2}`: `*{2}`\",\n-                                                op.node.as_str(),\n-                                                rty,\n-                                                lstring\n-                                        );\n-                                        err.help(msg);\n+                                        err.help(&format!(\n+                                            \"`{}` can be used on '{}', you can \\\n+                                            dereference `{2}`: `*{2}`\",\n+                                            op.node.as_str(),\n+                                            rty.peel_refs(),\n+                                            lstring\n+                                        ));\n                                         suggested_deref = true;\n                                     }\n                                 }"}, {"sha": "24d2e3ce53937775ce8b336457a0e111f2d0a2b6", "filename": "src/test/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:25:15\n    |\n LL |     A = { let 0 = 0; 0 },\n-   |               ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |               ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n error: aborting due to previous error\n "}, {"sha": "5d59d06f7982ae204da75e934cdc8b9249081084", "filename": "src/test/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:31:24\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n-   |                        ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                        ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n error: aborting due to previous error\n "}, {"sha": "6d74c26f9f7a54eba330d7050bcca3ed70df8f00", "filename": "src/test/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,26 +1,26 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:4:22\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n-   |                      ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                      ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:8:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n-   |                       ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                       ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:13:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:19:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n error: aborting due to 4 previous errors\n "}, {"sha": "60e16aaf895329fe497d05dcf01bf54d68993269", "filename": "src/test/ui/consts/const-pattern-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -9,8 +9,8 @@ use foo::d;\n const a: u8 = 2;\n \n fn main() {\n-    let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n-    let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n-    let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n+    let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n+    let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n+    let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n     fn f() {} // Check that the `NOTE`s still work with an item here (cf. issue #35115).\n }"}, {"sha": "06f5e90d2f1f723cf26dd00249e21a900b98fc49", "filename": "src/test/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,16 +1,16 @@\n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n LL |     let a = 4;\n    |         ^ interpreted as a constant pattern, not new variable\n \n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:13:9\n    |\n LL |     let c = 4;\n    |         ^ interpreted as a constant pattern, not new variable\n \n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:14:9\n    |\n LL |     let d = 4;"}, {"sha": "7f15f02d4d37bb3e96a382d16c8b45f6dddb3335", "filename": "src/test/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in function argument: `&[]` not covered\n+error[E0005]: refutable pattern in function argument: `&[]`, `&[_]` and `&[_, _, _]` not covered\n   --> $DIR/const_let_refutable.rs:3:16\n    |\n LL | const fn slice([a, b]: &[i32]) -> i32 {\n-   |                ^^^^^^ pattern `&[]` not covered\n+   |                ^^^^^^ patterns `&[]`, `&[_]` and `&[_, _, _]` not covered\n \n error[E0723]: can only call other `const fn` within a `const fn`, but `const <&i32 as std::ops::Add>::add` is not stable as `const fn`\n   --> $DIR/const_let_refutable.rs:4:5"}, {"sha": "bf0bd3aca97a4bf26b1809057c42dc51c72a2ee0", "filename": "src/test/ui/consts/match_ice.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -7,6 +7,9 @@ LL |         C => {}\n error[E0004]: non-exhaustive patterns: `&T` not covered\n   --> $DIR/match_ice.rs:15:11\n    |\n+LL | struct T;\n+   | --------- `T` defined here\n+...\n LL |     match K {\n    |           ^ pattern `&T` not covered\n    |"}, {"sha": "7d59d553d88fd98d2463a1ab2375d7200bc0c549", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -3,6 +3,7 @@ error[E0005]: refutable pattern in local binding: `T(_, _)` not covered\n    |\n LL | / enum Helper<T, U> {\n LL | |     T(T, [!; 0]),\n+   | |     - not covered\n LL | |     #[allow(dead_code)]\n LL | |     U(U),\n LL | | }"}, {"sha": "14aea2dc27eea3d9a4036b6063a0dffbc33793c6", "filename": "src/test/ui/for/for-loop-refutable-pattern-error-message.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&std::i32::MIN..=0i32` not covered\n+error[E0005]: refutable pattern in `for` loop binding: `&std::i32::MIN..=0i32` and `&2i32..=std::i32::MAX` not covered\n   --> $DIR/for-loop-refutable-pattern-error-message.rs:2:9\n    |\n LL |     for &1 in [1].iter() {}\n-   |         ^^ pattern `&std::i32::MIN..=0i32` not covered\n+   |         ^^ patterns `&std::i32::MIN..=0i32` and `&2i32..=std::i32::MAX` not covered\n \n error: aborting due to previous error\n "}, {"sha": "5307153cb44039682a68287c278e69b889251f02", "filename": "src/test/ui/issues/issue-15381.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -2,7 +2,7 @@ fn main() {\n     let values: Vec<u8> = vec![1,2,3,4,5,6,7,8];\n \n     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-        //~^ ERROR refutable pattern in `for` loop binding: `&[]` not covered\n+        //~^ ERROR refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not\n         println!(\"y={}\", y);\n         //~^ ERROR borrow of possibly-uninitialized variable: `y`\n     }"}, {"sha": "47a0d514ad8737b34c5f7fe00f7f3e8e104747d7", "filename": "src/test/ui/issues/issue-15381.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&[]` not covered\n+error[E0005]: refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n   --> $DIR/issue-15381.rs:4:9\n    |\n LL |     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-   |         ^^^^^^^^ pattern `&[]` not covered\n+   |         ^^^^^^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n \n error[E0381]: borrow of possibly-uninitialized variable: `y`\n   --> $DIR/issue-15381.rs:6:26"}, {"sha": "813b2409cc8e1748307a1596c84c88e49fce52e5", "filename": "src/test/ui/issues/issue-31561.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fissues%2Fissue-31561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fissues%2Fissue-31561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31561.rs?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -6,5 +6,5 @@ enum Thing {\n \n fn main() {\n     let Thing::Foo(y) = Thing::Foo(1);\n-    //~^ ERROR refutable pattern in local binding: `Bar` not covered\n+    //~^ ERROR refutable pattern in local binding: `Bar` and `Baz` not covered\n }"}, {"sha": "9ec26b024bce24f9cd8e3c2c4abfcc4c810441c6", "filename": "src/test/ui/issues/issue-31561.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,15 +1,17 @@\n-error[E0005]: refutable pattern in local binding: `Bar` not covered\n+error[E0005]: refutable pattern in local binding: `Bar` and `Baz` not covered\n   --> $DIR/issue-31561.rs:8:9\n    |\n LL | / enum Thing {\n LL | |     Foo(u8),\n LL | |     Bar,\n+   | |     --- not covered\n LL | |     Baz\n+   | |     --- not covered\n LL | | }\n    | |_- `Thing` defined here\n ...\n LL |       let Thing::Foo(y) = Thing::Foo(1);\n-   |           ^^^^^^^^^^^^^ pattern `Bar` not covered\n+   |           ^^^^^^^^^^^^^ patterns `Bar` and `Baz` not covered\n \n error: aborting due to previous error\n "}, {"sha": "6f009acbdfe1818ac9984720917a2a5146f3e0d2", "filename": "src/test/ui/match/non-exhaustive-defined-here.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.rs?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -0,0 +1,72 @@\n+// Test the \"defined here\" and \"not covered\" diagnostic hints.\n+// We also make sure that references are peeled off from the scrutinee type\n+// so that the diagnostics work better with default binding modes.\n+\n+#[derive(Clone)]\n+enum E {\n+//~^ `E` defined here\n+//~| `E` defined here\n+//~| `E` defined here\n+//~| `E` defined here\n+//~| `E` defined here\n+//~| `E` defined here\n+    A,\n+    B,\n+    //~^ not covered\n+    //~| not covered\n+    //~| not covered\n+    //~| not covered\n+    //~| not covered\n+    //~| not covered\n+    C\n+    //~^ not covered\n+    //~| not covered\n+    //~| not covered\n+    //~| not covered\n+    //~| not covered\n+    //~| not covered\n+}\n+\n+fn by_val(e: E) {\n+    let e1 = e.clone();\n+    match e1 { //~ ERROR non-exhaustive patterns: `B` and `C` not covered\n+        E::A => {}\n+    }\n+\n+    let E::A = e; //~ ERROR refutable pattern in local binding: `B` and `C` not covered\n+}\n+\n+fn by_ref_once(e: &E) {\n+    match e { //~ ERROR non-exhaustive patterns: `&B` and `&C` not covered\n+        E::A => {}\n+    }\n+\n+    let E::A = e; //~ ERROR refutable pattern in local binding: `&B` and `&C` not covered\n+}\n+\n+fn by_ref_thrice(e: & &mut &E) {\n+    match e { //~ ERROR non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n+        E::A => {}\n+    }\n+\n+    let E::A = e;\n+    //~^ ERROR refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n+}\n+\n+enum Opt {\n+//~^ `Opt` defined here\n+//~| `Opt` defined here\n+    Some(u8),\n+    None,\n+    //~^ not covered\n+}\n+\n+fn ref_pat(e: Opt) {\n+    match e {//~ ERROR non-exhaustive patterns: `None` not covered\n+        Opt::Some(ref _x) => {}\n+    }\n+\n+    let Opt::Some(ref _x) = e; //~ ERROR refutable pattern in local binding: `None` not covered\n+}\n+\n+fn main() {}"}, {"sha": "25b8bbdab2d8e7813d8c7f480aead2dce4f913f2", "filename": "src/test/ui/match/non-exhaustive-defined-here.stderr", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -0,0 +1,170 @@\n+error[E0004]: non-exhaustive patterns: `B` and `C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:32:11\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       match e1 {\n+   |             ^^ patterns `B` and `C` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0005]: refutable pattern in local binding: `B` and `C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:36:9\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       let E::A = e;\n+   |           ^^^^ patterns `B` and `C` not covered\n+\n+error[E0004]: non-exhaustive patterns: `&B` and `&C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:40:11\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       match e {\n+   |             ^ patterns `&B` and `&C` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0005]: refutable pattern in local binding: `&B` and `&C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:44:9\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       let E::A = e;\n+   |           ^^^^ patterns `&B` and `&C` not covered\n+\n+error[E0004]: non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:48:11\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       match e {\n+   |             ^ patterns `&&mut &B` and `&&mut &C` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0005]: refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:52:9\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       let E::A = e;\n+   |           ^^^^ patterns `&&mut &B` and `&&mut &C` not covered\n+\n+error[E0004]: non-exhaustive patterns: `None` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:65:11\n+   |\n+LL | / enum Opt {\n+LL | |\n+LL | |\n+LL | |     Some(u8),\n+LL | |     None,\n+   | |     ---- not covered\n+LL | |\n+LL | | }\n+   | |_- `Opt` defined here\n+...\n+LL |       match e {\n+   |             ^ pattern `None` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0005]: refutable pattern in local binding: `None` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:69:9\n+   |\n+LL | / enum Opt {\n+LL | |\n+LL | |\n+LL | |     Some(u8),\n+LL | |     None,\n+   | |     ---- not covered\n+LL | |\n+LL | | }\n+   | |_- `Opt` defined here\n+...\n+LL |       let Opt::Some(ref _x) = e;\n+   |           ^^^^^^^^^^^^^^^^^ pattern `None` not covered\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0004, E0005.\n+For more information about an error, try `rustc --explain E0004`."}, {"sha": "d4afe17ca748cfeb8c3d0627ab6d004de6750b3c", "filename": "src/test/ui/refutable-pattern-errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frefutable-pattern-errors.rs?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,7 +1,9 @@\n+// ignore-tidy-linelength\n+\n fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n //~^ ERROR refutable pattern in function argument: `(_, _)` not covered\n \n fn main() {\n     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` not covered\n+    //~^ ERROR refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n }"}, {"sha": "3b13e25293d58578f440e5e49323ee427c05e497", "filename": "src/test/ui/refutable-pattern-errors.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -1,14 +1,14 @@\n error[E0005]: refutable pattern in function argument: `(_, _)` not covered\n-  --> $DIR/refutable-pattern-errors.rs:1:9\n+  --> $DIR/refutable-pattern-errors.rs:3:9\n    |\n LL | fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n    |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n \n-error[E0005]: refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` not covered\n-  --> $DIR/refutable-pattern-errors.rs:5:9\n+error[E0005]: refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+  --> $DIR/refutable-pattern-errors.rs:7:9\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-   |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(std::i32::MIN..=0i32, _)` not covered\n+   |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n \n error: aborting due to 2 previous errors\n "}, {"sha": "29ff1dc37608930ae1b13adc60009646b38616ca", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0b58fcf03391a91f74224fe38a696d5a5b789d9/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=f0b58fcf03391a91f74224fe38a696d5a5b789d9", "patch": "@@ -3,6 +3,7 @@ error[E0005]: refutable pattern in local binding: `A(_)` not covered\n    |\n LL | / enum Foo {\n LL | |     A(foo::SecretlyEmpty),\n+   | |     - not covered\n LL | |     B(foo::NotSoSecretlyEmpty),\n LL | |     C(NotSoSecretlyEmpty),\n LL | |     D(u32),"}]}