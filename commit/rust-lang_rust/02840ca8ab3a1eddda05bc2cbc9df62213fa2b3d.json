{"sha": "02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyODQwY2E4YWIzYTFlZGRkYTA1YmMyY2JjOWRmNjIyMTNmYTJiM2Q=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-03-24T03:06:47Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-03-27T00:59:10Z"}, "message": "Remove `no_integrated_as` mode.\n\nSpecifically, remove both `-Z no_integrated_as` and\n`TargetOptions::no_integrated_as`. The latter was only used for the\n`msp430_none_elf` platform, for which it's no longer required.", "tree": {"sha": "bc5af73894e1b4c8bd5c3d87b1960a94cf708bb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc5af73894e1b4c8bd5c3d87b1960a94cf708bb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "html_url": "https://github.com/rust-lang/rust/commit/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62c6006450d8bd33a351673c1f969846d768aab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/62c6006450d8bd33a351673c1f969846d768aab4", "html_url": "https://github.com/rust-lang/rust/commit/62c6006450d8bd33a351673c1f969846d768aab4"}], "stats": {"total": 155, "additions": 26, "deletions": 129}, "files": [{"sha": "77cae038fe52ab8f24d0050bdf3fff1ca7f42fa6", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "patch": "@@ -16,9 +16,7 @@ use crate::ModuleLlvm;\n use log::debug;\n use rustc::bug;\n use rustc::ty::TyCtxt;\n-use rustc_codegen_ssa::back::write::{\n-    run_assembler, BitcodeSection, CodegenContext, EmitObj, ModuleConfig,\n-};\n+use rustc_codegen_ssa::back::write::{BitcodeSection, CodegenContext, EmitObj, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen, RLIB_BYTECODE_EXTENSION};\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -734,53 +732,41 @@ pub(crate) unsafe fn codegen(\n             })?;\n         }\n \n-        let config_emit_object_code = matches!(config.emit_obj, EmitObj::ObjectCode(_));\n-\n-        if config.emit_asm || (config_emit_object_code && config.no_integrated_as) {\n+        if config.emit_asm {\n             let _timer = cgcx\n                 .prof\n                 .generic_activity_with_arg(\"LLVM_module_codegen_emit_asm\", &module.name[..]);\n             let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n-            // We can't use the same module for asm and binary output, because that triggers\n-            // various errors like invalid IR or broken binaries, so we might have to clone the\n-            // module to produce the asm output\n-            let llmod = if config_emit_object_code { llvm::LLVMCloneModule(llmod) } else { llmod };\n+            // We can't use the same module for asm and object code output,\n+            // because that triggers various errors like invalid IR or broken\n+            // binaries. So we must clone the module to produce the asm output\n+            // if we are also producing object code.\n+            let llmod = if let EmitObj::ObjectCode(_) = config.emit_obj {\n+                llvm::LLVMCloneModule(llmod)\n+            } else {\n+                llmod\n+            };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(diag_handler, tm, cpm, llmod, &path, llvm::FileType::AssemblyFile)\n             })?;\n         }\n \n         match config.emit_obj {\n             EmitObj::ObjectCode(_) => {\n-                if !config.no_integrated_as {\n-                    let _timer = cgcx.prof.generic_activity_with_arg(\n-                        \"LLVM_module_codegen_emit_obj\",\n-                        &module.name[..],\n-                    );\n-                    with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                        write_output_file(\n-                            diag_handler,\n-                            tm,\n-                            cpm,\n-                            llmod,\n-                            &obj_out,\n-                            llvm::FileType::ObjectFile,\n-                        )\n-                    })?;\n-                } else {\n-                    let _timer = cgcx.prof.generic_activity_with_arg(\n-                        \"LLVM_module_codegen_asm_to_obj\",\n-                        &module.name[..],\n-                    );\n-                    let assembly =\n-                        cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-                    run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n-\n-                    if !config.emit_asm && !cgcx.save_temps {\n-                        drop(fs::remove_file(&assembly));\n-                    }\n-                }\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    write_output_file(\n+                        diag_handler,\n+                        tm,\n+                        cpm,\n+                        llmod,\n+                        &obj_out,\n+                        llvm::FileType::ObjectFile,\n+                    )\n+                })?;\n             }\n \n             EmitObj::Bitcode => {\n@@ -802,6 +788,7 @@ pub(crate) unsafe fn codegen(\n \n         drop(handlers);\n     }\n+\n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n         config.emit_bc,"}, {"sha": "7833f22097c641e8570cf1b431874d5044b6d4f1", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 65, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "patch": "@@ -1,5 +1,4 @@\n-use super::command::Command;\n-use super::link::{self, get_linker, remove};\n+use super::link::{self, remove};\n use super::linker::LinkerInfo;\n use super::lto::{self, SerializedModule};\n use super::symbol_export::symbol_name_for_instance_in_crate;\n@@ -116,7 +115,6 @@ pub struct ModuleConfig {\n     pub merge_functions: bool,\n     pub inline_threshold: Option<usize>,\n     pub new_llvm_pass_manager: Option<bool>,\n-    pub no_integrated_as: bool,\n }\n \n impl ModuleConfig {\n@@ -140,7 +138,6 @@ impl ModuleConfig {\n             emit_ir: false,\n             emit_asm: false,\n             emit_obj: EmitObj::None,\n-            no_integrated_as: false,\n \n             verify_llvm_ir: false,\n             no_prepopulate_passes: false,\n@@ -202,12 +199,6 @@ impl ModuleConfig {\n     }\n }\n \n-/// Assembler name and command used by codegen when no_integrated_as is enabled\n-pub struct AssemblerCommand {\n-    name: PathBuf,\n-    cmd: Command,\n-}\n-\n // HACK(eddyb) work around `#[derive]` producing wrong bounds for `Clone`.\n pub struct TargetMachineFactory<B: WriteBackendMethods>(\n     pub Arc<dyn Fn() -> Result<B::TargetMachine, String> + Send + Sync>,\n@@ -260,8 +251,6 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub cgu_reuse_tracker: CguReuseTracker,\n     // Channel back to the main control thread to send messages to\n     pub coordinator_send: Sender<Box<dyn Any + Send>>,\n-    // The assembler command if no_integrated_as option is enabled, None otherwise\n-    pub assembler_cmd: Option<Arc<AssemblerCommand>>,\n }\n \n impl<B: WriteBackendMethods> CodegenContext<B> {\n@@ -415,9 +404,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n \n     modules_config.emit_pre_lto_bc = need_pre_lto_bitcode_for_incr_comp(sess);\n \n-    modules_config.no_integrated_as =\n-        tcx.sess.opts.cg.no_integrated_as || tcx.sess.target.target.options.no_integrated_as;\n-\n     for output_type in sess.opts.output_types.keys() {\n         match *output_type {\n             OutputType::Bitcode => {\n@@ -1030,17 +1016,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n     }));\n \n-    let assembler_cmd = if modules_config.no_integrated_as {\n-        // HACK: currently we use linker (gcc) as our assembler\n-        let (linker, flavor) = link::linker_and_flavor(sess);\n-\n-        let (name, mut cmd) = get_linker(sess, &linker, flavor);\n-        cmd.args(&sess.target.target.options.asm_args);\n-        Some(Arc::new(AssemblerCommand { name, cmd }))\n-    } else {\n-        None\n-    };\n-\n     let ol = if tcx.sess.opts.debugging_opts.no_codegen\n         || !tcx.sess.opts.output_types.should_codegen()\n     {\n@@ -1076,7 +1051,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n         target_arch: tcx.sess.target.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n-        assembler_cmd,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -1610,44 +1584,6 @@ fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>\n     });\n }\n \n-pub fn run_assembler<B: ExtraBackendMethods>(\n-    cgcx: &CodegenContext<B>,\n-    handler: &Handler,\n-    assembly: &Path,\n-    object: &Path,\n-) {\n-    let assembler = cgcx.assembler_cmd.as_ref().expect(\"cgcx.assembler_cmd is missing?\");\n-\n-    let pname = &assembler.name;\n-    let mut cmd = assembler.cmd.clone();\n-    cmd.arg(\"-c\").arg(\"-o\").arg(object).arg(assembly);\n-    debug!(\"{:?}\", cmd);\n-\n-    match cmd.output() {\n-        Ok(prog) => {\n-            if !prog.status.success() {\n-                let mut note = prog.stderr.clone();\n-                note.extend_from_slice(&prog.stdout);\n-\n-                handler\n-                    .struct_err(&format!(\n-                        \"linking with `{}` failed: {}\",\n-                        pname.display(),\n-                        prog.status\n-                    ))\n-                    .note(&format!(\"{:?}\", &cmd))\n-                    .note(str::from_utf8(&note[..]).unwrap())\n-                    .emit();\n-                handler.abort_if_errors();\n-            }\n-        }\n-        Err(e) => {\n-            handler.err(&format!(\"could not exec the linker `{}`: {}\", pname.display(), e));\n-            handler.abort_if_errors();\n-        }\n-    }\n-}\n-\n enum SharedEmitterMessage {\n     Diagnostic(Diagnostic),\n     InlineAsmError(u32, String),"}, {"sha": "8a8ba8a96f7289edfa63204601fa4170acbbdb52", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "patch": "@@ -451,10 +451,6 @@ fn test_codegen_options_tracking_hash() {\n     opts.cg.prefer_dynamic = true;\n     assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n-    opts = reference.clone();\n-    opts.cg.no_integrated_as = true;\n-    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n     opts = reference.clone();\n     opts.cg.no_redzone = Some(true);\n     assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());"}, {"sha": "9d49075ebbc8e81043d23dcb926038cf298af9b8", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "patch": "@@ -665,8 +665,6 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"use soft float ABI (*eabihf targets only)\"),\n     prefer_dynamic: bool = (false, parse_bool, [TRACKED],\n         \"prefer dynamic linking to static linking\"),\n-    no_integrated_as: bool = (false, parse_bool, [TRACKED],\n-        \"use an external assembler rather than LLVM's integrated one\"),\n     no_redzone: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"disable the use of the redzone\"),\n     relocation_model: Option<String> = (None, parse_opt_string, [TRACKED],"}, {"sha": "1bc2bf12fad9e39b796186bf2b2568ecc7dd2ce1", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "patch": "@@ -712,11 +712,6 @@ pub struct TargetOptions {\n     // will 'just work'.\n     pub obj_is_bitcode: bool,\n \n-    // LLVM can't produce object files for this target. Instead, we'll make LLVM\n-    // emit assembly and then use `gcc` to turn that assembly into an object\n-    // file\n-    pub no_integrated_as: bool,\n-\n     /// Don't use this field; instead use the `.min_atomic_width()` method.\n     pub min_atomic_width: Option<u64>,\n \n@@ -872,7 +867,6 @@ impl Default for TargetOptions {\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n-            no_integrated_as: false,\n             min_atomic_width: None,\n             max_atomic_width: None,\n             atomic_cas: true,\n@@ -1187,7 +1181,6 @@ impl Target {\n         key!(main_needs_argc_argv, bool);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n-        key!(no_integrated_as, bool);\n         key!(max_atomic_width, Option<u64>);\n         key!(min_atomic_width, Option<u64>);\n         key!(atomic_cas, bool);\n@@ -1415,7 +1408,6 @@ impl ToJson for Target {\n         target_option_val!(main_needs_argc_argv);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n-        target_option_val!(no_integrated_as);\n         target_option_val!(min_atomic_width);\n         target_option_val!(max_atomic_width);\n         target_option_val!(atomic_cas);"}, {"sha": "9a90ac7ccecea2a4044f82d9db9522de18dd599a", "filename": "src/librustc_target/spec/msp430_none_elf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_target%2Fspec%2Fmsp430_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d/src%2Flibrustc_target%2Fspec%2Fmsp430_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmsp430_none_elf.rs?ref=02840ca8ab3a1eddda05bc2cbc9df62213fa2b3d", "patch": "@@ -22,7 +22,6 @@ pub fn target() -> TargetResult {\n             // dependency on this specific gcc.\n             asm_args: vec![\"-mcpu=msp430\".to_string()],\n             linker: Some(\"msp430-elf-gcc\".to_string()),\n-            no_integrated_as: true,\n \n             // There are no atomic CAS instructions available in the MSP430\n             // instruction set, and the LLVM backend doesn't currently support"}, {"sha": "1567b325d4fe19f3624692f79bf6efa7ebf9eec4", "filename": "src/test/run-make-fulldeps/no-integrated-as/Makefile", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2FMakefile?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -1,8 +0,0 @@\n--include ../tools.mk\n-\n-# only-linux\n-# only-x86_64\n-\n-all:\n-\t$(RUSTC) hello.rs -C no_integrated_as\n-\t$(call RUN,hello)"}, {"sha": "e7a11a969c037e00a796aafeff6258501ec15e9a", "filename": "src/test/run-make-fulldeps/no-integrated-as/hello.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2Fhello.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -1,3 +0,0 @@\n-fn main() {\n-    println!(\"Hello, world!\");\n-}"}]}