{"sha": "97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "node_id": "C_kwDOAAsO6NoAKDk3ZDMyODAxMmI5ZWQ5YjdkNDgxYzQwZTg0YWExZjJjNjViMzNlYzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-24T16:18:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-24T16:18:21Z"}, "message": "Auto merge of #111673 - cjgillot:dominator-preprocess, r=cjgillot,tmiasko\n\nPreprocess and cache dominator tree\n\nPreprocessing dominators has a very strong effect for https://github.com/rust-lang/rust/pull/111344.\nThat pass checks that assignments dominate their uses repeatedly. Using the unprocessed dominator tree caused a quadratic runtime (number of bbs x depth of the dominator tree).\n\nThis PR also caches the dominator tree and the pre-processed dominators in the MIR cfg cache.\n\nRebase of https://github.com/rust-lang/rust/pull/107157\ncc `@tmiasko`", "tree": {"sha": "004ab106803c96f912f254b85c7d62b8ee16e453", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/004ab106803c96f912f254b85c7d62b8ee16e453"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "html_url": "https://github.com/rust-lang/rust/commit/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3cbf7c8351dd48dc2e07a1cdc69620f8e40dd2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3cbf7c8351dd48dc2e07a1cdc69620f8e40dd2f", "html_url": "https://github.com/rust-lang/rust/commit/b3cbf7c8351dd48dc2e07a1cdc69620f8e40dd2f"}, {"sha": "7c8f29f02c279acfa7b0c353e2187ad268e25de8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c8f29f02c279acfa7b0c353e2187ad268e25de8", "html_url": "https://github.com/rust-lang/rust/commit/7c8f29f02c279acfa7b0c353e2187ad268e25de8"}], "stats": {"total": 158, "additions": 107, "deletions": 51}, "files": [{"sha": "036391d074da846be9df2f31310b115aaebeec07", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "patch": "@@ -46,7 +46,7 @@ struct InvalidationGenerator<'cx, 'tcx> {\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,\n     body: &'cx Body<'tcx>,\n-    dominators: Dominators<BasicBlock>,\n+    dominators: &'cx Dominators<BasicBlock>,\n     borrow_set: &'cx BorrowSet<'tcx>,\n }\n "}, {"sha": "43c4e1a9d6fd21bdbe8e94d394f46a7e3cf472b1", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "patch": "@@ -43,7 +43,6 @@ use rustc_target::abi::FieldIdx;\n \n use either::Either;\n use smallvec::SmallVec;\n-use std::cell::OnceCell;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::ops::Deref;\n@@ -331,7 +330,6 @@ fn do_mir_borrowck<'tcx>(\n                 used_mut: Default::default(),\n                 used_mut_upvars: SmallVec::new(),\n                 borrow_set: Rc::clone(&borrow_set),\n-                dominators: Default::default(),\n                 upvars: Vec::new(),\n                 local_names: IndexVec::from_elem(None, &promoted_body.local_decls),\n                 region_names: RefCell::default(),\n@@ -360,7 +358,6 @@ fn do_mir_borrowck<'tcx>(\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n         borrow_set: Rc::clone(&borrow_set),\n-        dominators: Default::default(),\n         upvars,\n         local_names,\n         region_names: RefCell::default(),\n@@ -591,9 +588,6 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// The set of borrows extracted from the MIR\n     borrow_set: Rc<BorrowSet<'tcx>>,\n \n-    /// Dominators for MIR\n-    dominators: OnceCell<Dominators<BasicBlock>>,\n-\n     /// Information about upvars not necessarily preserved in types or MIR\n     upvars: Vec<Upvar<'tcx>>,\n \n@@ -2269,7 +2263,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     fn dominators(&self) -> &Dominators<BasicBlock> {\n-        self.dominators.get_or_init(|| self.body.basic_blocks.dominators())\n+        // `BasicBlocks` computes dominators on-demand and caches them.\n+        self.body.basic_blocks.dominators()\n     }\n }\n "}, {"sha": "835074806e90f159acb9b547cfcc38d21073770d", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "patch": "@@ -84,7 +84,7 @@ impl DefLocation {\n \n struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     fx: &'mir FunctionCx<'a, 'tcx, Bx>,\n-    dominators: Dominators<mir::BasicBlock>,\n+    dominators: &'mir Dominators<mir::BasicBlock>,\n     locals: IndexVec<mir::Local, LocalKind>,\n }\n "}, {"sha": "a5db14d9102c44dc199098bd5e5389635e469503", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 85, "deletions": 10, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "patch": "@@ -26,7 +26,7 @@ rustc_index::newtype_index! {\n     struct PreorderIndex {}\n }\n \n-pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n+pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n     // compute the post order index (rank) for each node\n     let mut post_order_rank = IndexVec::from_elem_n(0, graph.num_nodes());\n \n@@ -244,7 +244,10 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n \n     let start_node = graph.start_node();\n     immediate_dominators[start_node] = None;\n-    Dominators { start_node, post_order_rank, immediate_dominators }\n+\n+    let time = compute_access_time(start_node, &immediate_dominators);\n+\n+    Dominators { start_node, post_order_rank, immediate_dominators, time }\n }\n \n /// Evaluate the link-eval virtual forest, providing the currently minimum semi\n@@ -316,6 +319,7 @@ pub struct Dominators<N: Idx> {\n     // possible to get its full list of dominators by looking up the dominator\n     // of each dominator. (See the `impl Iterator for Iter` definition).\n     immediate_dominators: IndexVec<N, Option<N>>,\n+    time: IndexVec<N, Time>,\n }\n \n impl<Node: Idx> Dominators<Node> {\n@@ -333,12 +337,7 @@ impl<Node: Idx> Dominators<Node> {\n     /// See the `impl Iterator for Iter` definition to understand how this works.\n     pub fn dominators(&self, node: Node) -> Iter<'_, Node> {\n         assert!(self.is_reachable(node), \"node {node:?} is not reachable\");\n-        Iter { dominators: self, node: Some(node) }\n-    }\n-\n-    pub fn dominates(&self, dom: Node, node: Node) -> bool {\n-        // FIXME -- could be optimized by using post-order-rank\n-        self.dominators(node).any(|n| n == dom)\n+        Iter { dom_tree: self, node: Some(node) }\n     }\n \n     /// Provide deterministic ordering of nodes such that, if any two nodes have a dominator\n@@ -348,10 +347,22 @@ impl<Node: Idx> Dominators<Node> {\n     pub fn rank_partial_cmp(&self, lhs: Node, rhs: Node) -> Option<Ordering> {\n         self.post_order_rank[rhs].partial_cmp(&self.post_order_rank[lhs])\n     }\n+\n+    /// Returns true if `a` dominates `b`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `b` is unreachable.\n+    pub fn dominates(&self, a: Node, b: Node) -> bool {\n+        let a = self.time[a];\n+        let b = self.time[b];\n+        assert!(b.start != 0, \"node {b:?} is not reachable\");\n+        a.start <= b.start && b.finish <= a.finish\n+    }\n }\n \n pub struct Iter<'dom, Node: Idx> {\n-    dominators: &'dom Dominators<Node>,\n+    dom_tree: &'dom Dominators<Node>,\n     node: Option<Node>,\n }\n \n@@ -360,10 +371,74 @@ impl<'dom, Node: Idx> Iterator for Iter<'dom, Node> {\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(node) = self.node {\n-            self.node = self.dominators.immediate_dominator(node);\n+            self.node = self.dom_tree.immediate_dominator(node);\n             Some(node)\n         } else {\n             None\n         }\n     }\n }\n+\n+/// Describes the number of vertices discovered at the time when processing of a particular vertex\n+/// started and when it finished. Both values are zero for unreachable vertices.\n+#[derive(Copy, Clone, Default, Debug)]\n+struct Time {\n+    start: u32,\n+    finish: u32,\n+}\n+\n+fn compute_access_time<N: Idx>(\n+    start_node: N,\n+    immediate_dominators: &IndexSlice<N, Option<N>>,\n+) -> IndexVec<N, Time> {\n+    // Transpose the dominator tree edges, so that child nodes of vertex v are stored in\n+    // node[edges[v].start..edges[v].end].\n+    let mut edges: IndexVec<N, std::ops::Range<u32>> =\n+        IndexVec::from_elem(0..0, immediate_dominators);\n+    for &idom in immediate_dominators.iter() {\n+        if let Some(idom) = idom {\n+            edges[idom].end += 1;\n+        }\n+    }\n+    let mut m = 0;\n+    for e in edges.iter_mut() {\n+        m += e.end;\n+        e.start = m;\n+        e.end = m;\n+    }\n+    let mut node = IndexVec::from_elem_n(Idx::new(0), m.try_into().unwrap());\n+    for (i, &idom) in immediate_dominators.iter_enumerated() {\n+        if let Some(idom) = idom {\n+            edges[idom].start -= 1;\n+            node[edges[idom].start] = i;\n+        }\n+    }\n+\n+    // Perform a depth-first search of the dominator tree. Record the number of vertices discovered\n+    // when vertex v is discovered first as time[v].start, and when its processing is finished as\n+    // time[v].finish.\n+    let mut time: IndexVec<N, Time> = IndexVec::from_elem(Time::default(), immediate_dominators);\n+    let mut stack = Vec::new();\n+\n+    let mut discovered = 1;\n+    stack.push(start_node);\n+    time[start_node].start = discovered;\n+\n+    while let Some(&i) = stack.last() {\n+        let e = &mut edges[i];\n+        if e.start == e.end {\n+            // Finish processing vertex i.\n+            time[i].finish = discovered;\n+            stack.pop();\n+        } else {\n+            let j = node[e.start];\n+            e.start += 1;\n+            // Start processing vertex j.\n+            discovered += 1;\n+            time[j].start = discovered;\n+            stack.push(j);\n+        }\n+    }\n+\n+    time\n+}"}, {"sha": "9d70dbfa0722120bc7f01738abd2ecc5e82242ab", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "patch": "@@ -27,6 +27,7 @@ struct Cache {\n     switch_sources: OnceCell<SwitchSources>,\n     is_cyclic: OnceCell<bool>,\n     postorder: OnceCell<Vec<BasicBlock>>,\n+    dominators: OnceCell<Dominators<BasicBlock>>,\n }\n \n impl<'tcx> BasicBlocks<'tcx> {\n@@ -41,8 +42,8 @@ impl<'tcx> BasicBlocks<'tcx> {\n         *self.cache.is_cyclic.get_or_init(|| graph::is_cyclic(self))\n     }\n \n-    pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(&self)\n+    pub fn dominators(&self) -> &Dominators<BasicBlock> {\n+        self.cache.dominators.get_or_init(|| dominators(self))\n     }\n \n     /// Returns predecessors for each basic block."}, {"sha": "ea1223fbca6429578865bcda48d9c04e6634f9df", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "patch": "@@ -9,6 +9,7 @@ use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::{self, BasicBlock, BasicBlockData, Terminator, TerminatorKind};\n \n+use std::cmp::Ordering;\n use std::ops::{Index, IndexMut};\n \n const ID_SEPARATOR: &str = \",\";\n@@ -212,8 +213,12 @@ impl CoverageGraph {\n     }\n \n     #[inline(always)]\n-    pub fn dominators(&self) -> &Dominators<BasicCoverageBlock> {\n-        self.dominators.as_ref().unwrap()\n+    pub fn rank_partial_cmp(\n+        &self,\n+        a: BasicCoverageBlock,\n+        b: BasicCoverageBlock,\n+    ) -> Option<Ordering> {\n+        self.dominators.as_ref().unwrap().rank_partial_cmp(a, b)\n     }\n }\n \n@@ -650,26 +655,6 @@ pub(super) fn find_loop_backedges(\n     let mut backedges = IndexVec::from_elem_n(Vec::<BasicCoverageBlock>::new(), num_bcbs);\n \n     // Identify loops by their backedges.\n-    //\n-    // The computational complexity is bounded by: n(s) x d where `n` is the number of\n-    // `BasicCoverageBlock` nodes (the simplified/reduced representation of the CFG derived from the\n-    // MIR); `s` is the average number of successors per node (which is most likely less than 2, and\n-    // independent of the size of the function, so it can be treated as a constant);\n-    // and `d` is the average number of dominators per node.\n-    //\n-    // The average number of dominators depends on the size and complexity of the function, and\n-    // nodes near the start of the function's control flow graph typically have less dominators\n-    // than nodes near the end of the CFG. Without doing a detailed mathematical analysis, I\n-    // think the resulting complexity has the characteristics of O(n log n).\n-    //\n-    // The overall complexity appears to be comparable to many other MIR transform algorithms, and I\n-    // don't expect that this function is creating a performance hot spot, but if this becomes an\n-    // issue, there may be ways to optimize the `dominates` algorithm (as indicated by an\n-    // existing `FIXME` comment in that code), or possibly ways to optimize it's usage here, perhaps\n-    // by keeping track of results for visited `BasicCoverageBlock`s if they can be used to short\n-    // circuit downstream `dominates` checks.\n-    //\n-    // For now, that kind of optimization seems unnecessarily complicated.\n     for (bcb, _) in basic_coverage_blocks.iter_enumerated() {\n         for &successor in &basic_coverage_blocks.successors[bcb] {\n             if basic_coverage_blocks.dominates(successor, bcb) {"}, {"sha": "d27200419e2cbc3288a965764810063b43b0e552", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                         // before the dominated equal spans). When later comparing two spans in\n                         // order, the first will either dominate the second, or they will have no\n                         // dominator relationship.\n-                        self.basic_coverage_blocks.dominators().rank_partial_cmp(a.bcb, b.bcb)\n+                        self.basic_coverage_blocks.rank_partial_cmp(a.bcb, b.bcb)\n                     }\n                 } else {\n                     // Sort hi() in reverse order so shorter spans are attempted after longer spans."}, {"sha": "bf5722b3d00b2c393b98be2541709c04361960fc", "filename": "compiler/rustc_mir_transform/src/ctfe_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs?ref=97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "patch": "@@ -47,7 +47,7 @@ fn has_back_edge(\n         return false;\n     }\n     // Check if any of the dominators of the node are also the node's successor.\n-    doms.dominators(node).any(|dom| node_data.terminator().successors().any(|succ| succ == dom))\n+    node_data.terminator().successors().any(|succ| doms.dominates(succ, node))\n }\n \n fn insert_counter(basic_block_data: &mut BasicBlockData<'_>) {"}, {"sha": "e8e4246b7970fe41c7a5369118d0b6ec968c99ab", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "patch": "@@ -31,11 +31,11 @@ pub struct SsaLocals {\n /// We often encounter MIR bodies with 1 or 2 basic blocks. In those cases, it's unnecessary to\n /// actually compute dominators, we can just compare block indices because bb0 is always the first\n /// block, and in any body all other blocks are always dominated by bb0.\n-struct SmallDominators {\n-    inner: Option<Dominators<BasicBlock>>,\n+struct SmallDominators<'a> {\n+    inner: Option<&'a Dominators<BasicBlock>>,\n }\n \n-impl SmallDominators {\n+impl SmallDominators<'_> {\n     fn dominates(&self, first: Location, second: Location) -> bool {\n         if first.block == second.block {\n             first.statement_index <= second.statement_index\n@@ -198,14 +198,14 @@ enum LocationExtended {\n     Arg,\n }\n \n-struct SsaVisitor {\n-    dominators: SmallDominators,\n+struct SsaVisitor<'a> {\n+    dominators: SmallDominators<'a>,\n     assignments: IndexVec<Local, Set1<LocationExtended>>,\n     assignment_order: Vec<Local>,\n     direct_uses: IndexVec<Local, u32>,\n }\n \n-impl<'tcx> Visitor<'tcx> for SsaVisitor {\n+impl<'tcx> Visitor<'tcx> for SsaVisitor<'_> {\n     fn visit_local(&mut self, local: Local, ctxt: PlaceContext, loc: Location) {\n         match ctxt {\n             PlaceContext::MutatingUse(MutatingUseContext::Projection)"}]}