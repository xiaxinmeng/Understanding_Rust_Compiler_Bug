{"sha": "f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NjRmOWE4Y2Y1MmU2ODZiYTZlNTRiNTk0ZTZiYmJkZDViYzdiMzI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-10T16:27:11Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-16T22:05:56Z"}, "message": "Port the stdlib to the typaram foo<T> syntax.", "tree": {"sha": "24a39688027a41a7a3e7e4a2239cfedf12fb20e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24a39688027a41a7a3e7e4a2239cfedf12fb20e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "html_url": "https://github.com/rust-lang/rust/commit/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8043788e3a71a951892577cbcb623ac94b908677", "url": "https://api.github.com/repos/rust-lang/rust/commits/8043788e3a71a951892577cbcb623ac94b908677", "html_url": "https://github.com/rust-lang/rust/commit/8043788e3a71a951892577cbcb623ac94b908677"}], "stats": {"total": 288, "additions": 144, "deletions": 144}, "files": [{"sha": "03953f40a4264bd6eaeeaaa63f3416c3c09bb7ce", "filename": "src/lib/aio.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -15,11 +15,11 @@ native \"rust\" mod rustrt {\n     fn aio_init();\n     fn aio_run();\n     fn aio_stop();\n-    fn aio_connect(host: *u8, port: int, connected: &_chan[socket]);\n-    fn aio_serve(host: *u8, port: int, acceptChan: &_chan[socket]) -> server;\n-    fn aio_writedata(s: socket, buf: *u8, size: uint, status: &_chan[bool]);\n-    fn aio_read(s: socket, reader: &_chan[[u8]]);\n-    fn aio_close_server(s: server, status: &_chan[bool]);\n+    fn aio_connect(host: *u8, port: int, connected: &_chan<socket>);\n+    fn aio_serve(host: *u8, port: int, acceptChan: &_chan<socket>) -> server;\n+    fn aio_writedata(s: socket, buf: *u8, size: uint, status: &_chan<bool>);\n+    fn aio_read(s: socket, reader: &_chan<[u8]>);\n+    fn aio_close_server(s: server, status: &_chan<bool>);\n     fn aio_close_socket(s: socket);\n     fn aio_is_null_client(s: socket) -> bool;\n }\n@@ -40,36 +40,36 @@ tag socket_event {\n }\n \n tag server_event {\n-    pending(_chan[_chan[socket_event]]);\n+    pending(_chan<_chan<socket_event>>);\n }\n \n tag request {\n     quit;\n-    connect(pending_connection,_chan[socket_event]);\n-    serve(net::ip_addr,int,_chan[server_event],_chan[server]);\n-    write(client,[u8],_chan[bool]);\n-    close_server(server, _chan[bool]);\n+    connect(pending_connection,_chan<socket_event>);\n+    serve(net::ip_addr,int,_chan<server_event>,_chan<server>);\n+    write(client,[u8],_chan<bool>);\n+    close_server(server, _chan<bool>);\n     close_client(client);\n }\n \n-type ctx = _chan[request];\n+type ctx = _chan<request>;\n \n fn ip_to_sbuf(ip: net::ip_addr) -> *u8 {\n     vec::to_ptr(str::bytes(net::format_addr(ip)))\n }\n \n-fn connect_task(ip: net::ip_addr, portnum: int, evt: _chan[socket_event]) {\n-    let connecter: _port[client] = mk_port();\n+fn connect_task(ip: net::ip_addr, portnum: int, evt: _chan<socket_event>) {\n+    let connecter: _port<client> = mk_port();\n     rustrt::aio_connect(ip_to_sbuf(ip), portnum, connecter.mk_chan());\n     let client = connecter.recv();\n     new_client(client, evt);\n }\n \n-fn new_client(client: client, evt: _chan[socket_event]) {\n+fn new_client(client: client, evt: _chan<socket_event>) {\n     // Start the read before notifying about the connect.  This avoids a race\n     // condition where the receiver can close the socket before we start\n     // reading.\n-    let reader: _port[[u8]] = mk_port();\n+    let reader: _port<[u8]> = mk_port();\n     rustrt::aio_read(client, reader.mk_chan());\n \n     send(evt, connected(client));\n@@ -92,18 +92,18 @@ fn new_client(client: client, evt: _chan[socket_event]) {\n     log \"close message sent\";\n }\n \n-fn accept_task(client: client, events: _chan[server_event]) {\n+fn accept_task(client: client, events: _chan<server_event>) {\n     log \"accept task was spawned\";\n-    let p: _port[_chan[socket_event]] = mk_port();\n+    let p: _port<_chan<socket_event>> = mk_port();\n     send(events, pending(p.mk_chan()));\n     let evt = p.recv();\n     new_client(client, evt);\n     log \"done accepting\";\n }\n \n-fn server_task(ip: net::ip_addr, portnum: int, events: _chan[server_event],\n-               server: _chan[server]) {\n-    let accepter: _port[client] = mk_port();\n+fn server_task(ip: net::ip_addr, portnum: int, events: _chan<server_event>,\n+               server: _chan<server>) {\n+    let accepter: _port<client> = mk_port();\n     send(server, rustrt::aio_serve(ip_to_sbuf(ip), portnum,\n                                    accepter.mk_chan()));\n \n@@ -120,9 +120,9 @@ fn server_task(ip: net::ip_addr, portnum: int, events: _chan[server_event],\n     }\n }\n \n-fn request_task(c: _chan[ctx]) {\n+fn request_task(c: _chan<ctx>) {\n     // Create a port to accept IO requests on\n-    let p: _port[request] = mk_port();\n+    let p: _port<request> = mk_port();\n     // Hand of its channel to our spawner\n     send(c, p.mk_chan());\n     log \"uv run task spawned\";\n@@ -160,7 +160,7 @@ fn request_task(c: _chan[ctx]) {\n     }\n }\n \n-fn iotask(c: _chan[ctx]) {\n+fn iotask(c: _chan<ctx>) {\n     log \"io task spawned\";\n     // Initialize before accepting requests\n     rustrt::aio_init();\n@@ -178,7 +178,7 @@ fn iotask(c: _chan[ctx]) {\n }\n \n fn new() -> ctx {\n-    let p: _port[ctx] = mk_port();\n+    let p: _port<ctx> = mk_port();\n     task::_spawn(bind iotask(p.mk_chan()));\n     ret p.recv();\n }"}, {"sha": "01da63635ea749ca11231ac135661821e7543d54", "filename": "src/lib/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -59,7 +59,7 @@ obj _port[~T](raw_port : @port_ptr) {\n     }\n }\n \n-fn mk_port[~T]() -> _port[T] {\n+fn mk_port[~T]() -> _port<T> {\n     _port(@port_ptr(rustrt::new_port(sys::size_of[T]())))\n }\n "}, {"sha": "c3d17314a41a95ae42fb38e65553266bfafd07d9", "filename": "src/lib/deque.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -16,8 +16,8 @@ type t[T] =\n         fn get(int) -> T ;\n     };\n \n-fn create[@T]() -> t[T] {\n-    type cell[T] = option::t[T];\n+fn create[@T]() -> t<T> {\n+    type cell[T] = option::t<T>;\n \n     let initial_capacity: uint = 32u; // 2^5\n      /**\n@@ -26,8 +26,8 @@ fn create[@T]() -> t[T] {\n       */\n \n \n-    fn grow[@T](nelts: uint, lo: uint, elts: &[mutable cell[T]]) ->\n-       [mutable cell[T]] {\n+    fn grow[@T](nelts: uint, lo: uint, elts: &[mutable cell<T>]) ->\n+       [mutable cell<T>] {\n         assert (nelts == vec::len(elts));\n         let rv = ~[mutable];\n \n@@ -42,22 +42,22 @@ fn create[@T]() -> t[T] {\n \n         ret rv;\n     }\n-    fn get[@T](elts: &[mutable cell[T]], i: uint) -> T {\n+    fn get[@T](elts: &[mutable cell<T>], i: uint) -> T {\n         ret alt elts.(i) { option::some(t) { t } _ { fail } };\n     }\n     obj deque[@T](mutable nelts: uint,\n                   mutable lo: uint,\n                   mutable hi: uint,\n-                  mutable elts: [mutable cell[T]]) {\n+                  mutable elts: [mutable cell<T>]) {\n         fn size() -> uint { ret nelts; }\n         fn add_front(t: &T) {\n             let oldlo: uint = lo;\n             if lo == 0u {\n-                lo = vec::len[cell[T]](elts) - 1u;\n+                lo = vec::len[cell<T>](elts) - 1u;\n             } else { lo -= 1u; }\n             if lo == hi {\n                 elts = grow[T](nelts, oldlo, elts);\n-                lo = vec::len[cell[T]](elts) - 1u;\n+                lo = vec::len[cell<T>](elts) - 1u;\n                 hi = nelts;\n             }\n             elts.(lo) = option::some[T](t);\n@@ -70,7 +70,7 @@ fn create[@T]() -> t[T] {\n                 hi = nelts;\n             }\n             elts.(hi) = option::some[T](t);\n-            hi = (hi + 1u) % vec::len[cell[T]](elts);\n+            hi = (hi + 1u) % vec::len[cell<T>](elts);\n             nelts += 1u;\n         }\n \n@@ -81,13 +81,13 @@ fn create[@T]() -> t[T] {\n         fn pop_front() -> T {\n             let t: T = get[T](elts, lo);\n             elts.(lo) = option::none[T];\n-            lo = (lo + 1u) % vec::len[cell[T]](elts);\n+            lo = (lo + 1u) % vec::len[cell<T>](elts);\n             nelts -= 1u;\n             ret t;\n         }\n         fn pop_back() -> T {\n             if hi == 0u {\n-                hi = vec::len[cell[T]](elts) - 1u;\n+                hi = vec::len[cell<T>](elts) - 1u;\n             } else { hi -= 1u; }\n             let t: T = get[T](elts, hi);\n             elts.(hi) = option::none[T];\n@@ -97,11 +97,11 @@ fn create[@T]() -> t[T] {\n         fn peek_front() -> T { ret get[T](elts, lo); }\n         fn peek_back() -> T { ret get[T](elts, hi - 1u); }\n         fn get(i: int) -> T {\n-            let idx: uint = (lo + (i as uint)) % vec::len[cell[T]](elts);\n+            let idx: uint = (lo + (i as uint)) % vec::len[cell<T>](elts);\n             ret get[T](elts, idx);\n         }\n     }\n-    let v: [mutable cell[T]] =\n+    let v: [mutable cell<T>] =\n         vec::init_elt_mut(option::none, initial_capacity);\n     ret deque[T](0u, 0u, 0u, v);\n }"}, {"sha": "cd7fbf9eb3b98b2125ccc04fe2e6fbb9e76f67d9", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -50,7 +50,7 @@ fn doc_at(data: &@[u8], start: uint) -> doc {\n     ret {data: data, start: elt_size.next, end: end};\n }\n \n-fn maybe_get_doc(d: doc, tg: uint) -> option::t[doc] {\n+fn maybe_get_doc(d: doc, tg: uint) -> option::t<doc> {\n     let pos = d.start;\n     while pos < d.end {\n         let elt_tag = vint_at(*d.data, pos);"}, {"sha": "78496bec917953895a6378fa42f5944f0dd9944b", "filename": "src/lib/either.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -6,30 +6,30 @@ import option::none;\n tag t[T, U] { left(T); right(U); }\n \n fn either[T, U, V](f_left: &block(&T) -> V, f_right: &block(&U) -> V,\n-                   value: &t[T, U]) -> V {\n+                   value: &t<T, U>) -> V {\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n-fn lefts[T, U](eithers: &[t[T, U]]) -> [T] {\n+fn lefts[T, U](eithers: &[t<T, U>]) -> [T] {\n     let result: [T] = ~[];\n-    for elt: t[T, U] in eithers {\n+    for elt: t<T, U> in eithers {\n         alt elt { left(l) { result += ~[l] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn rights[T, U](eithers: &[t[T, U]]) -> [U] {\n+fn rights[T, U](eithers: &[t<T, U>]) -> [U] {\n     let result: [U] = ~[];\n-    for elt: t[T, U] in eithers {\n+    for elt: t<T, U> in eithers {\n         alt elt { right(r) { result += ~[r] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn partition[T, U](eithers: &[t[T, U]]) -> {lefts: [T], rights: [U]} {\n+fn partition[T, U](eithers: &[t<T, U>]) -> {lefts: [T], rights: [U]} {\n     let lefts: [T] = ~[];\n     let rights: [U] = ~[];\n-    for elt: t[T, U] in eithers {\n+    for elt: t<T, U> in eithers {\n         alt elt { left(l) { lefts += ~[l] } right(r) { rights += ~[r] } }\n     }\n     ret {lefts: lefts, rights: rights};"}, {"sha": "11239d7ed4281190994ae103a574a02bc515f395", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -60,7 +60,7 @@ mod ct {\n \n     // A formatted conversion from an expression to a string\n     type conv =\n-        {param: option::t[int],\n+        {param: option::t<int>,\n          flags: [flag],\n          width: count,\n          precision: count,\n@@ -105,7 +105,7 @@ mod ct {\n         ret pieces;\n     }\n     fn peek_num(s: str, i: uint, lim: uint) ->\n-       option::t[{num: uint, next: uint}] {\n+       option::t<{num: uint, next: uint}> {\n         if i >= lim { ret none; }\n         let c = s.(i);\n         if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n@@ -135,7 +135,7 @@ mod ct {\n              next: ty.next};\n     }\n     fn parse_parameter(s: str, i: uint, lim: uint) ->\n-       {param: option::t[int], next: uint} {\n+       {param: option::t<int>, next: uint} {\n         if i >= lim { ret {param: none, next: i}; }\n         let num = peek_num(s, i, lim);\n         ret alt num {"}, {"sha": "da660e34dc5629a47efdb92bb402750845082d1c", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -3,7 +3,7 @@ import str::sbuf;\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n-fn getenv(n: str) -> option::t[str] {\n+fn getenv(n: str) -> option::t<str> {\n     let s = os::libc::getenv(str::buf(n));\n     ret if s as int == 0 {\n             option::none[str]\n@@ -19,7 +19,7 @@ fn setenv(n: str, v: str) {\n }\n \n #[cfg(target_os = \"win32\")]\n-fn getenv(n: str) -> option::t[str] {\n+fn getenv(n: str) -> option::t<str> {\n     let nbuf = str::buf(n);\n     let nsize = 256u;\n     while true {"}, {"sha": "eb56b44b4900173848241ae1d88f0e37c1456133", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -75,7 +75,7 @@ fn name_str(nm: name) -> str {\n     ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n }\n \n-fn find_opt(opts: &[opt], nm: name) -> option::t[uint] {\n+fn find_opt(opts: &[opt], nm: name) -> option::t<uint> {\n     let i = 0u;\n     let l = vec::len[opt](opts);\n     while i < l { if opts.(i).name == nm { ret some[uint](i); } i += 1u; }\n@@ -224,7 +224,7 @@ fn opt_strs(m: &match, nm: str) -> [str] {\n     ret acc;\n }\n \n-fn opt_maybe_str(m: &match, nm: str) -> option::t[str] {\n+fn opt_maybe_str(m: &match, nm: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len[optval](vals) == 0u { ret none[str]; }\n     ret alt vals.(0) { val(s) { some[str](s) } _ { none[str] } };\n@@ -234,7 +234,7 @@ fn opt_maybe_str(m: &match, nm: str) -> option::t[str] {\n /// Returns none if the option was not present, `def` if the option was\n /// present but no argument was provided, and the argument if the option was\n /// present and an argument was provided.\n-fn opt_default(m: &match, nm: str, def: str) -> option::t[str] {\n+fn opt_default(m: &match, nm: str, def: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len[optval](vals) == 0u { ret none[str]; }\n     ret alt vals.(0) { val(s) { some[str](s) } _ { some[str](def) } }"}, {"sha": "d10cb2fe33b070f4479136575b4761419d5f5f20", "filename": "src/lib/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -59,7 +59,7 @@ resource FILE_res(f: os::libc::FILE) {\n     os::libc::fclose(f);\n }\n \n-obj FILE_buf_reader(f: os::libc::FILE, res: option::t[@FILE_res]) {\n+obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn read(len: uint) -> [u8] {\n         let buf = ~[];\n         vec::reserve[u8](buf, len);\n@@ -243,7 +243,7 @@ type buf_writer =\n         fn tell() -> uint ;\n     };\n \n-obj FILE_writer(f: os::libc::FILE, res: option::t[@FILE_res]) {\n+obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn write(v: &[u8]) {\n         let len = vec::len[u8](v);\n         let vbuf = vec::to_ptr[u8](v);\n@@ -262,7 +262,7 @@ resource fd_res(fd: int) {\n     os::libc::close(fd);\n }\n \n-obj fd_buf_writer(fd: int, res: option::t[@fd_res]) {\n+obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n     fn write(v: &[u8]) {\n         let len = vec::len[u8](v);\n         let count = 0u;"}, {"sha": "9657a4fe451f3c95c7a4838e112a3956f25b0f8e", "filename": "src/lib/list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -1,9 +1,9 @@\n import option::some;\n import option::none;\n \n-tag list[T] { cons(T, @list[T]); nil; }\n+tag list[T] { cons(T, @list<T>); nil; }\n \n-fn from_vec[@T](v: &[T]) -> list[T] {\n+fn from_vec[@T](v: &[T]) -> list<T> {\n     let l = nil[T];\n     // FIXME: This would be faster and more space efficient if it looped over\n     // a reverse vector iterator. Unfortunately generic iterators seem not to\n@@ -13,7 +13,7 @@ fn from_vec[@T](v: &[T]) -> list[T] {\n     ret l;\n }\n \n-fn foldl[@T, @U](ls_: &list[T], u: &U, f: &block(&T, &U) -> U ) -> U {\n+fn foldl[@T, @U](ls_: &list<T>, u: &U, f: &block(&T, &U) -> U ) -> U {\n     let accum: U = u;\n     let ls = ls_;\n     while true {\n@@ -25,8 +25,8 @@ fn foldl[@T, @U](ls_: &list[T], u: &U, f: &block(&T, &U) -> U ) -> U {\n     ret accum;\n }\n \n-fn find[@T, @U](ls_: &list[T], f: &block(&T) -> option::t[U])\n-    -> option::t[U] {\n+fn find[@T, @U](ls_: &list<T>, f: &block(&T) -> option::t<U>)\n+    -> option::t<U> {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -39,7 +39,7 @@ fn find[@T, @U](ls_: &list[T], f: &block(&T) -> option::t[U])\n     ret none;\n }\n \n-fn has[@T](ls_: &list[T], elt: &T) -> bool {\n+fn has[@T](ls_: &list<T>, elt: &T) -> bool {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -50,26 +50,26 @@ fn has[@T](ls_: &list[T], elt: &T) -> bool {\n     ret false;\n }\n \n-fn length[@T](ls: &list[T]) -> uint {\n+fn length[@T](ls: &list<T>) -> uint {\n     fn count[T](t: &T, u: &uint) -> uint { ret u + 1u; }\n     ret foldl(ls, 0u, count);\n }\n \n-fn cdr[@T](ls: &list[T]) -> list[T] {\n+fn cdr[@T](ls: &list<T>) -> list<T> {\n     alt ls {\n       cons(_, tl) { ret *tl; }\n       nil. { fail \"list empty\" }\n     }\n }\n \n-fn car[@T](ls: &list[T]) -> T {\n+fn car[@T](ls: &list<T>) -> T {\n     alt ls {\n       cons(hd, _) { ret hd; }\n       nil. { fail \"list empty\" }\n     }\n }\n \n-fn append[@T](l: &list[T], m: &list[T]) -> list[T] {\n+fn append[@T](l: &list<T>, m: &list<T>) -> list<T> {\n     alt l {\n       nil. { ret m; }\n       cons(x, xs) {"}, {"sha": "d6135864e5b502422666c0cf7cb6d5b78f2e59e2", "filename": "src/lib/map.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -11,23 +11,23 @@ type hashmap[K, V] =\n         fn insert(&K, &V) -> bool ;\n         fn contains_key(&K) -> bool ;\n         fn get(&K) -> V ;\n-        fn find(&K) -> option::t[V] ;\n-        fn remove(&K) -> option::t[V] ;\n+        fn find(&K) -> option::t<V> ;\n+        fn remove(&K) -> option::t<V> ;\n         fn rehash() ;\n         iter items() -> @{key: K, val: V} ;\n         iter keys() -> K ;\n     };\n-type hashset[K] = hashmap[K, ()];\n+type hashset[K] = hashmap<K, ()>;\n \n-fn set_add[@K](set: hashset[K], key: &K) -> bool { ret set.insert(key, ()); }\n+fn set_add[@K](set: hashset<K>, key: &K) -> bool { ret set.insert(key, ()); }\n \n-fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n+fn mk_hashmap[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n     let initial_capacity: uint = 32u; // 2^5\n \n     let load_factor: util::rational = {num: 3, den: 4};\n     tag bucket[@K, @V] { nil; deleted; some(K, V); }\n-    fn make_buckets[@K, @V](nbkts: uint) -> [mutable (bucket[K, V])] {\n-        ret vec::init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n+    fn make_buckets[@K, @V](nbkts: uint) -> [mutable (bucket<K, V>)] {\n+        ret vec::init_elt_mut[bucket<K, V>](nil[K, V], nbkts);\n     }\n     // Derive two hash functions from the one given by taking the upper\n     // half and lower half of the uint bits.  Our bucket probing\n@@ -53,8 +53,8 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n      * will fail.\n      */\n \n-    fn insert_common[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                             bkts: &[mutable bucket[K, V]], nbkts: uint,\n+    fn insert_common[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>,\n+                             bkts: &[mutable bucket<K, V>], nbkts: uint,\n                              key: &K, val: &V) -> bool {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n@@ -76,9 +76,9 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n         }\n         fail; // full table\n     }\n-    fn find_common[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                           bkts: &[mutable bucket[K, V]], nbkts: uint,\n-                           key: &K) -> option::t[V] {\n+    fn find_common[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>,\n+                           bkts: &[mutable bucket<K, V>], nbkts: uint,\n+                           key: &K) -> option::t<V> {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n@@ -97,10 +97,10 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n         }\n         ret option::none;\n     }\n-    fn rehash[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                      oldbkts: &[mutable bucket[K, V]], noldbkts: uint,\n-                      newbkts: &[mutable bucket[K, V]], nnewbkts: uint) {\n-        for b: bucket[K, V] in oldbkts {\n+    fn rehash[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>,\n+                      oldbkts: &[mutable bucket<K, V>], noldbkts: uint,\n+                      newbkts: &[mutable bucket<K, V>], nnewbkts: uint) {\n+        for b: bucket<K, V> in oldbkts {\n             alt b {\n               some(k_, v_) {\n                 let k = k_;\n@@ -111,9 +111,9 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n             }\n         }\n     }\n-    obj hashmap[@K, @V](hasher: hashfn[K],\n-                        eqer: eqfn[K],\n-                        mutable bkts: [mutable bucket[K, V]],\n+    obj hashmap[@K, @V](hasher: hashfn<K>,\n+                        eqer: eqfn<K>,\n+                        mutable bkts: [mutable bucket<K, V>],\n                         mutable nbkts: uint,\n                         mutable nelts: uint,\n                         lf: util::rational) {\n@@ -146,10 +146,10 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n                   _ { fail }\n                 };\n         }\n-        fn find(key: &K) -> option::t[V] {\n+        fn find(key: &K) -> option::t<V> {\n             be find_common(hasher, eqer, bkts, nbkts, key);\n         }\n-        fn remove(key: &K) -> option::t[V] {\n+        fn remove(key: &K) -> option::t<V> {\n             let i: uint = 0u;\n             let h: uint = hasher(key);\n             while i < nbkts {\n@@ -177,12 +177,12 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n             bkts = newbkts;\n         }\n         iter items() -> @{key: K, val: V} {\n-            for b: bucket[K, V] in bkts {\n+            for b: bucket<K, V> in bkts {\n                 alt b { some(k, v) { put @{key: k, val: v}; } _ { } }\n             }\n         }\n         iter keys() -> K {\n-            for b: bucket[K, V] in bkts {\n+            for b: bucket<K, V> in bkts {\n                 alt b { some(k, _) { put k; } _ { } }\n             }\n         }\n@@ -193,17 +193,17 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n \n // Hash map constructors for basic types\n \n-fn new_str_hash[@V]() -> hashmap[str, V] {\n+fn new_str_hash[@V]() -> hashmap<str, V> {\n     ret mk_hashmap(str::hash, str::eq);\n }\n \n-fn new_int_hash[@V]() -> hashmap[int, V] {\n+fn new_int_hash[@V]() -> hashmap<int, V> {\n     fn hash_int(x: &int) -> uint { ret x as uint; }\n     fn eq_int(a: &int, b: &int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n }\n \n-fn new_uint_hash[@V]() -> hashmap[uint, V] {\n+fn new_uint_hash[@V]() -> hashmap<uint, V> {\n     fn hash_uint(x: &uint) -> uint { ret x; }\n     fn eq_uint(a: &uint, b: &uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);"}, {"sha": "e803c9fc66c66b003afb83cd1528a0a2387c54b4", "filename": "src/lib/option.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -2,33 +2,33 @@\n \n tag t[@T] { none; some(T); }\n \n-fn get[@T](opt: &t[T]) -> T {\n+fn get[@T](opt: &t<T>) -> T {\n     alt opt {\n       some(x) { x }\n       none. { fail \"option none\" }\n     }\n }\n \n-fn map[@T, @U](f: &block(&T) -> U, opt: &t[T]) -> t[U] {\n+fn map[@T, @U](f: &block(&T) -> U, opt: &t<T>) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n \n-fn is_none[@T](opt: &t[T]) -> bool {\n+fn is_none[@T](opt: &t<T>) -> bool {\n     alt opt { none. { true } some(_) { false } }\n }\n \n-fn is_some[@T](opt: &t[T]) -> bool { !is_none(opt) }\n+fn is_some[@T](opt: &t<T>) -> bool { !is_none(opt) }\n \n-fn from_maybe[@T](def: &T, opt: &t[T]) -> T {\n+fn from_maybe[@T](def: &T, opt: &t<T>) -> T {\n     alt opt { some(x) { x } none. { def } }\n }\n \n-fn maybe[@T, @U](def: &U, f: &block(&T) -> U, opt: &t[T]) -> U {\n+fn maybe[@T, @U](def: &U, f: &block(&T) -> U, opt: &t<T>) -> U {\n     alt opt { none. { def } some(t) { f(t) } }\n }\n \n // Can be defined in terms of the above when/if we have const bind.\n-fn may[@T](f: &block(&T), opt: &t[T]) {\n+fn may[@T](f: &block(&T), opt: &t<T>) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }\n "}, {"sha": "16dacf287f6187d58b9d3f8772b9e88085d7ee13", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -17,7 +17,7 @@ fn list_dir(path: str) -> [str] {\n     /*\n     auto dir = os::libc::opendir(str::buf(path));\n     assert (dir as uint != 0u);\n-    let vec[str] result = [];\n+    let vec<str> result = [];\n     while (true) {\n         auto ent = os::libc::readdir(dir);\n         if (ent as int == 0) {"}, {"sha": "bd75efa76a5a59b8472d0cb5063e3b9b98d1b93b", "filename": "src/lib/sio.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fsio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fsio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsio.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -8,9 +8,9 @@ import net;\n \n type ctx = aio::ctx;\n type client = { ctx: ctx, client: aio::client,\n-               evt: _port[aio::socket_event] };\n+               evt: _port<aio::socket_event> };\n type server = { ctx: ctx, server: aio::server,\n-               evt: _port[aio::server_event] };\n+               evt: _port<aio::server_event> };\n \n fn new() -> ctx {\n     ret aio::new();\n@@ -20,7 +20,7 @@ fn destroy(ctx: ctx) {\n     send(ctx, aio::quit);\n }\n \n-fn make_socket(ctx: ctx, p: _port[aio::socket_event]) -> client {\n+fn make_socket(ctx: ctx, p: _port<aio::socket_event>) -> client {\n     let evt: aio::socket_event = p.recv();\n     alt evt {\n       aio::connected(client) {\n@@ -31,7 +31,7 @@ fn make_socket(ctx: ctx, p: _port[aio::socket_event]) -> client {\n }\n \n fn connect_to(ctx: ctx, ip: net::ip_addr, portnum: int) -> client {\n-    let p: _port[aio::socket_event] = mk_port();\n+    let p: _port<aio::socket_event> = mk_port();\n     send(ctx, aio::connect(aio::remote(ip, portnum), p.mk_chan()));\n     ret make_socket(ctx, p);\n }\n@@ -48,8 +48,8 @@ fn read(c: client) -> [u8] {\n }\n \n fn create_server(ctx: ctx, ip: net::ip_addr, portnum: int) -> server {\n-    let evt: _port[aio::server_event] = mk_port();\n-    let p: _port[aio::server] = mk_port();\n+    let evt: _port<aio::server_event> = mk_port();\n+    let p: _port<aio::server> = mk_port();\n     send(ctx, aio::serve(ip, portnum,\n                          evt.mk_chan(), p.mk_chan()));\n     let srv: aio::server = p.recv();\n@@ -60,22 +60,22 @@ fn accept_from(server: server) -> client {\n     let evt: aio::server_event = server.evt.recv();\n     alt evt {\n       aio::pending(callback) {\n-        let p: _port[aio::socket_event] = mk_port();\n+        let p: _port<aio::socket_event> = mk_port();\n         send(callback, p.mk_chan());\n         ret make_socket(server.ctx, p);\n       }\n     }\n }\n \n fn write_data(c: client, data: [u8]) -> bool {\n-    let p: _port[bool] = mk_port();\n+    let p: _port<bool> = mk_port();\n     send(c.ctx, aio::write(c.client, data, p.mk_chan()));\n     ret p.recv();\n }\n \n fn close_server(server: server) {\n     // TODO: make this unit once we learn to send those from native code\n-    let p: _port[bool] = mk_port();\n+    let p: _port<bool> = mk_port();\n     send(server.ctx, aio::close_server(server.server, p.mk_chan()));\n     log \"Waiting for close\";\n     p.recv();"}, {"sha": "682cc47d647d31838ae4fc6922ea8d26f788406f", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -7,38 +7,38 @@ import option::some;\n \n // FIXME: Should not be @; there's a bug somewhere in rustc that requires this\n // to be.\n-type smallintmap[T] = @{mutable v: [mutable option::t[T]]};\n+type smallintmap[T] = @{mutable v: [mutable option::t<T>]};\n \n-fn mk[@T]() -> smallintmap[T] {\n-    let v: [mutable option::t[T]] = ~[mutable];\n+fn mk[@T]() -> smallintmap<T> {\n+    let v: [mutable option::t<T>] = ~[mutable];\n     ret @{mutable v: v};\n }\n \n-fn insert[@T](m: &smallintmap[T], key: uint, val: &T) {\n-    vec::grow_set[option::t[T]](m.v, key, none[T], some[T](val));\n+fn insert[@T](m: &smallintmap<T>, key: uint, val: &T) {\n+    vec::grow_set[option::t<T>](m.v, key, none[T], some[T](val));\n }\n \n-fn find[@T](m: &smallintmap[T], key: uint) -> option::t[T] {\n-    if key < vec::len[option::t[T]](m.v) { ret m.v.(key); }\n+fn find[@T](m: &smallintmap<T>, key: uint) -> option::t<T> {\n+    if key < vec::len[option::t<T>](m.v) { ret m.v.(key); }\n     ret none[T];\n }\n \n-fn get[@T](m: &smallintmap[T], key: uint) -> T {\n+fn get[@T](m: &smallintmap<T>, key: uint) -> T {\n     alt find[T](m, key) {\n       none[T]. { log_err \"smallintmap::get(): key not present\"; fail; }\n       some[T](v) { ret v; }\n     }\n }\n \n-fn contains_key[@T](m: &smallintmap[T], key: uint) -> bool {\n+fn contains_key[@T](m: &smallintmap<T>, key: uint) -> bool {\n     ret !option::is_none(find[T](m, key));\n }\n \n-fn truncate[@T](m: &smallintmap[T], len: uint) {\n-    m.v = vec::slice_mut[option::t[T]](m.v, 0u, len);\n+fn truncate[@T](m: &smallintmap<T>, len: uint) {\n+    m.v = vec::slice_mut[option::t<T>](m.v, 0u, len);\n }\n \n-fn max_key[T](m: &smallintmap[T]) -> uint {\n-    ret vec::len[option::t[T]](m.v);\n+fn max_key[T](m: &smallintmap<T>) -> uint {\n+    ret vec::len[option::t<T>](m.v);\n }\n "}, {"sha": "24f06f550997a8e699780d7d991b01808a4bb3f2", "filename": "src/lib/sort.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -8,8 +8,8 @@ export quick_sort3;\n \n type lteq[T] = block(&T, &T) -> bool ;\n \n-fn merge_sort[@T](le: &lteq[T], v: &[T]) -> [T] {\n-    fn merge[@T](le: &lteq[T], a: &[T], b: &[T]) -> [T] {\n+fn merge_sort[@T](le: &lteq<T>, v: &[T]) -> [T] {\n+    fn merge[@T](le: &lteq<T>, a: &[T], b: &[T]) -> [T] {\n         let rs: [T] = ~[];\n         let a_len: uint = len[T](a);\n         let a_ix: uint = 0u;\n@@ -39,7 +39,7 @@ fn swap[@T](arr: &[mutable T], x: uint, y: uint) {\n     arr.(y) = a;\n }\n \n-fn part[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n+fn part[@T](compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n             right: uint, pivot: uint) -> uint {\n     let pivot_value = arr.(pivot);\n     swap[T](arr, pivot, right);\n@@ -56,7 +56,7 @@ fn part[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n     ret storage_index;\n }\n \n-fn qsort[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n+fn qsort[@T](compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -69,7 +69,7 @@ fn qsort[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n     }\n }\n \n-fn quick_sort[@T](compare_func: &lteq[T], arr: &[mutable T]) {\n+fn quick_sort[@T](compare_func: &lteq<T>, arr: &[mutable T]) {\n     if len[T](arr) == 0u { ret; }\n     qsort[T](compare_func, arr, 0u, len[T](arr) - 1u);\n }\n@@ -79,7 +79,7 @@ fn quick_sort[@T](compare_func: &lteq[T], arr: &[mutable T]) {\n // http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n // According to these slides this is the algorithm of choice for\n // 'randomly ordered keys, abstract compare' & 'small number of key values'\n-fn qsort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n+fn qsort3[@T](compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n               arr: &[mutable T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr.(right);\n@@ -127,7 +127,7 @@ fn qsort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n     qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n-fn quick_sort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n+fn quick_sort3[@T](compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n                    arr: &[mutable T]) {\n     if len[T](arr) == 0u { ret; }\n     qsort3[T](compare_func_lt, compare_func_eq, arr, 0,"}, {"sha": "9cde409df9346eaaa401653d16b3d32eea7089b8", "filename": "src/lib/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -59,13 +59,13 @@ fn test_main_ivec(args: &[str], tests: &[test_desc]) {\n     if !run_tests_console(opts, tests) { fail \"Some tests failed\"; }\n }\n \n-fn test_main(args: &vec[str], tests: &[test_desc]) {\n+fn test_main(args: &vec<str>, tests: &[test_desc]) {\n     test_main_ivec(vec::from_vec(args), tests);\n }\n \n-type test_opts = {filter: option::t[str], run_ignored: bool};\n+type test_opts = {filter: option::t<str>, run_ignored: bool};\n \n-type opt_res = either::t[test_opts, str];\n+type opt_res = either::t<test_opts, str>;\n \n // Parses command line arguments into test options\n fn parse_opts(args: &[str]) : vec::is_not_empty(args) -> opt_res {\n@@ -268,7 +268,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n \n             let filter =\n                 bind fn (test: &test_desc, filter_str: str) ->\n-                        option::t[test_desc] {\n+                        option::t<test_desc> {\n                          if str::find(test.name, filter_str) >= 0 {\n                              ret option::some(test);\n                          } else { ret option::none; }\n@@ -284,7 +284,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n             filtered\n         } else {\n             let filter =\n-                fn (test: &test_desc) -> option::t[test_desc] {\n+                fn (test: &test_desc) -> option::t<test_desc> {\n                     if test.ignore {\n                         ret option::some({name: test.name,\n                                           fn: test.fn,"}, {"sha": "eb52027d4b8575fcb67c821b88a4923ba4f02b44", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -6,7 +6,7 @@ import option::some;\n // A very naive implementation of union-find with unsigned integer nodes.\n // Maintains the invariant that the root of a node is always equal to or less\n // than the node itself.\n-type node = option::t[uint];\n+type node = option::t<uint>;\n \n type ufind = {mutable nodes: [mutable node]};\n "}, {"sha": "f82eec559ed88bb3373af5980378c3608e5f77b8", "filename": "src/lib/vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "patch": "@@ -17,7 +17,7 @@ native \"rust\" mod rustrt {\n                                     count: uint);\n }\n \n-fn from_vec[@T](v: &vec[mutable? T]) -> [T] {\n+fn from_vec[@T](v: &vec<mutable? T>) -> [T] {\n     let iv = ~[];\n     for e in v {\n         iv += ~[e];\n@@ -38,7 +38,7 @@ fn len[T](v: &[mutable? T]) -> uint { ret rusti::ivec_len(v); }\n \n type init_op[T] = fn(uint) -> T ;\n \n-fn init_fn[@T](op: &init_op[T], n_elts: uint) -> [T] {\n+fn init_fn[@T](op: &init_op<T>, n_elts: uint) -> [T] {\n     let v = ~[];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -47,7 +47,7 @@ fn init_fn[@T](op: &init_op[T], n_elts: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_fn_mut[@T](op: &init_op[T], n_elts: uint) -> [mutable T] {\n+fn init_fn_mut[@T](op: &init_op<T>, n_elts: uint) -> [mutable T] {\n     let v = ~[mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -104,7 +104,7 @@ fn tail[@T](v: &[mutable? T]) : is_not_empty(v) -> [mutable? T] {\n }\n \n /// Returns the last element of `v`.\n-fn last[@T](v: &[mutable? T]) -> option::t[T] {\n+fn last[@T](v: &[mutable? T]) -> option::t<T> {\n     if len(v) == 0u { ret none; }\n     ret some(v.(len(v) - 1u));\n }\n@@ -210,7 +210,7 @@ fn map2[@T, @U, @V](f: &block(&T, &U) -> V, v0: &[T], v1: &[U])\n     ret u;\n }\n \n-fn filter_map[@T, @U](f: &block(&T) -> option::t[U],\n+fn filter_map[@T, @U](f: &block(&T) -> option::t<U>,\n                       v: &[mutable? T]) -> [U] {\n     let result = ~[];\n     for elem: T in v {\n@@ -252,18 +252,18 @@ fn count[T](x: &T, v: &[mutable? T]) -> uint {\n     ret cnt;\n }\n \n-fn find[@T](f: &block(&T) -> bool , v: &[T]) -> option::t[T] {\n+fn find[@T](f: &block(&T) -> bool, v: &[T]) -> option::t<T> {\n     for elt: T in v { if f(elt) { ret some(elt); } }\n     ret none;\n }\n \n-fn position[@T](x: &T, v: &[T]) -> option::t[uint] {\n+fn position[@T](x: &T, v: &[T]) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if x == v.(i) { ret some[uint](i); } i += 1u; }\n     ret none[uint];\n }\n \n-fn position_pred[T](f: fn(&T) -> bool , v: &[T]) -> option::t[uint] {\n+fn position_pred[T](f: fn(&T) -> bool, v: &[T]) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if f(v.(i)) { ret some[uint](i); } i += 1u; }\n     ret none[uint];"}]}