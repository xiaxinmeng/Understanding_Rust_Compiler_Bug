{"sha": "dfa4bca88932a9503d0600bfa7ca24e6950935e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYTRiY2E4ODkzMmE5NTAzZDA2MDBiZmE3Y2EyNGU2OTUwOTM1ZTY=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-08-12T21:37:27Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-08-19T22:52:12Z"}, "message": "Rework Arc for FCP of #27718\n\n* Add previously omitted function `Arc::try_unwrap(Self) -> Result<T, Self>`\n* Move `arc.downgrade()` to `Arc::downgrade(&Self)` per conventions.\n* Deprecate `Arc::weak_count` and `Arc::strong_count` for raciness. It is almost\n  impossible to correctly act on these results without a CAS loop on the actual\n  fields.\n* Rename `Arc::make_unique` to `Arc::make_mut` to avoid uniqueness terminology\n  and to clarify relation to `Arc::get_mut`.", "tree": {"sha": "5f00cfcfcb515e27a192bb2b8f5470258615abd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f00cfcfcb515e27a192bb2b8f5470258615abd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfa4bca88932a9503d0600bfa7ca24e6950935e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfa4bca88932a9503d0600bfa7ca24e6950935e6", "html_url": "https://github.com/rust-lang/rust/commit/dfa4bca88932a9503d0600bfa7ca24e6950935e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfa4bca88932a9503d0600bfa7ca24e6950935e6/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "635f7360b6e76d46fb60da18f37401d33dc651ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/635f7360b6e76d46fb60da18f37401d33dc651ce", "html_url": "https://github.com/rust-lang/rust/commit/635f7360b6e76d46fb60da18f37401d33dc651ce"}], "stats": {"total": 189, "additions": 118, "deletions": 71}, "files": [{"sha": "95de2b6abae9ae83533585d4e2dff6f7df3fff43", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 118, "deletions": 71, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/dfa4bca88932a9503d0600bfa7ca24e6950935e6/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfa4bca88932a9503d0600bfa7ca24e6950935e6/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=dfa4bca88932a9503d0600bfa7ca24e6950935e6", "patch": "@@ -136,9 +136,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n /// used to break cycles between `Arc` pointers.\n #[unsafe_no_drop_flag]\n-#[unstable(feature = \"arc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n+#[unstable(feature = \"arc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n pub struct Weak<T: ?Sized> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -162,7 +160,7 @@ struct ArcInner<T: ?Sized> {\n \n     // the value usize::MAX acts as a sentinel for temporarily \"locking\" the\n     // ability to upgrade weak pointers or downgrade strong ones; this is used\n-    // to avoid races in `make_unique` and `get_mut`.\n+    // to avoid races in `make_mut` and `get_mut`.\n     weak: atomic::AtomicUsize,\n \n     data: T,\n@@ -193,6 +191,44 @@ impl<T> Arc<T> {\n         };\n         Arc { _ptr: unsafe { NonZero::new(Box::into_raw(x)) } }\n     }\n+\n+    /// Unwraps the contained value if the `Arc<T>` has only one strong reference.\n+    /// This will succeed even if there are outstanding weak references.\n+    ///\n+    /// Otherwise, an `Err` is returned with the same `Arc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_unique)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(3);\n+    /// assert_eq!(Arc::try_unwrap(x), Ok(3));\n+    ///\n+    /// let x = Arc::new(4);\n+    /// let _y = x.clone();\n+    /// assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"arc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn try_unwrap(this: Self) -> Result<T, Self> {\n+        // See `drop` for why all these atomics are like this\n+        if this.inner().strong.compare_and_swap(1, 0, Release) != 1 { return Err(this) }\n+\n+        atomic::fence(Acquire);\n+\n+        unsafe {\n+            let ptr = *this._ptr;\n+            let elem = ptr::read(&(*ptr).data);\n+\n+            // Make a weak pointer to clean up the implicit strong-weak reference\n+            let _weak = Weak { _ptr: this._ptr };\n+            mem::forget(this);\n+\n+            Ok(elem)\n+        }\n+    }\n }\n \n impl<T: ?Sized> Arc<T> {\n@@ -202,21 +238,18 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// ```\n     /// #![feature(arc_weak)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// let weak_five = five.downgrade();\n+    /// let weak_five = Arc::downgrade(&five);\n     /// ```\n-    #[unstable(feature = \"arc_weak\",\n-               reason = \"Weak pointers may not belong in this module.\",\n-               issue = \"27718\")]\n-    pub fn downgrade(&self) -> Weak<T> {\n+    #[unstable(feature = \"arc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn downgrade(this: &Self) -> Weak<T> {\n         loop {\n             // This Relaxed is OK because we're checking the value in the CAS\n             // below.\n-            let cur = self.inner().weak.load(Relaxed);\n+            let cur = this.inner().weak.load(Relaxed);\n \n             // check if the weak counter is currently \"locked\"; if so, spin.\n             if cur == usize::MAX { continue }\n@@ -228,23 +261,25 @@ impl<T: ?Sized> Arc<T> {\n             // Unlike with Clone(), we need this to be an Acquire read to\n             // synchronize with the write coming from `is_unique`, so that the\n             // events prior to that write happen before this read.\n-            if self.inner().weak.compare_and_swap(cur, cur + 1, Acquire) == cur {\n-                return Weak { _ptr: self._ptr }\n+            if this.inner().weak.compare_and_swap(cur, cur + 1, Acquire) == cur {\n+                return Weak { _ptr: this._ptr }\n             }\n         }\n     }\n \n     /// Get the number of weak references to this value.\n     #[inline]\n-    #[unstable(feature = \"arc_counts\", issue = \"27718\")]\n-    pub fn weak_count(this: &Arc<T>) -> usize {\n+    #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\", issue = \"27718\")]\n+    #[deprecated(since = \"1.4.0\", reason = \"not clearly useful, and racy\")]\n+    pub fn weak_count(this: &Self) -> usize {\n         this.inner().weak.load(SeqCst) - 1\n     }\n \n     /// Get the number of strong references to this value.\n     #[inline]\n-    #[unstable(feature = \"arc_counts\", issue = \"27718\")]\n-    pub fn strong_count(this: &Arc<T>) -> usize {\n+    #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\", issue = \"27718\")]\n+    #[deprecated(since = \"1.4.0\", reason = \"not clearly useful, and racy\")]\n+    pub fn strong_count(this: &Self) -> usize {\n         this.inner().strong.load(SeqCst)\n     }\n \n@@ -332,27 +367,40 @@ impl<T: ?Sized> Deref for Arc<T> {\n }\n \n impl<T: Clone> Arc<T> {\n-    /// Make a mutable reference from the given `Arc<T>`.\n+    #[unstable(feature = \"arc_unique\", reason = \"renamed to Arc::make_mut\", issue = \"27718\")]\n+    #[deprecated(since = \"1.4.0\", reason = \"renamed to Arc::make_mut\")]\n+    pub fn make_unique(this: &mut Self) -> &mut T {\n+        Arc::make_mut(this)\n+    }\n+\n+    /// Make a mutable reference into the given `Arc<T>` by cloning the inner\n+    /// data if the `Arc<T>` doesn't have one strong reference and no weak\n+    /// references.\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the (strong) reference count is greater than one. If\n-    /// we hold the only strong reference, any existing weak references will no\n-    /// longer be upgradeable.\n+    /// This is also referred to as a copy-on-write.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(arc_unique)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n-    /// let mut five = Arc::new(5);\n+    /// let mut data = Arc::new(5);\n+    ///\n+    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n+    /// let mut other_data = data.clone();      // Won't clone inner data\n+    /// *Arc::make_mut(&mut data) += 1;         // Clones inner data\n+    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n+    /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n+    ///\n+    /// // Note: data and other_data now point to different numbers\n+    /// assert_eq!(*data, 8);\n+    /// assert_eq!(*other_data, 12);\n     ///\n-    /// let mut_five = Arc::make_unique(&mut five);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"arc_unique\", issue = \"27718\")]\n-    pub fn make_unique(this: &mut Arc<T>) -> &mut T {\n+    #[unstable(feature = \"arc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn make_mut(this: &mut Self) -> &mut T {\n         // Note that we hold both a strong reference and a weak reference.\n         // Thus, releasing our strong reference only will not, by itself, cause\n         // the memory to be deallocated.\n@@ -407,30 +455,25 @@ impl<T: Clone> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n-    ///\n-    /// Returns `None` if the `Arc<T>` is not unique.\n+    /// Returns a mutable reference to the contained value if the `Arc<T>` has\n+    /// one strong reference and no weak references.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(arc_unique, alloc)]\n-    ///\n-    /// extern crate alloc;\n-    /// # fn main() {\n-    /// use alloc::arc::Arc;\n+    /// #![feature(arc_unique)]\n+    /// use std::sync::Arc;\n     ///\n     /// let mut x = Arc::new(3);\n     /// *Arc::get_mut(&mut x).unwrap() = 4;\n     /// assert_eq!(*x, 4);\n     ///\n     /// let _y = x.clone();\n     /// assert!(Arc::get_mut(&mut x).is_none());\n-    /// # }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"arc_unique\", issue = \"27718\")]\n-    pub fn get_mut(this: &mut Arc<T>) -> Option<&mut T> {\n+    #[unstable(feature = \"arc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if this.is_unique() {\n             // This unsafety is ok because we're guaranteed that the pointer\n             // returned is the *only* pointer that will ever be returned to T. Our\n@@ -542,9 +585,6 @@ impl<T: ?Sized> Drop for Arc<T> {\n     }\n }\n \n-#[unstable(feature = \"arc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n impl<T: ?Sized> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -557,15 +597,15 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// ```\n     /// #![feature(arc_weak)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// let weak_five = five.downgrade();\n+    /// let weak_five = Arc::downgrade(&five);\n     ///\n     /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n     /// ```\n+    #[unstable(feature = \"arc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add because once the count hits 0 it must never be above 0.\n@@ -591,9 +631,7 @@ impl<T: ?Sized> Weak<T> {\n     }\n }\n \n-#[unstable(feature = \"arc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n+#[unstable(feature = \"arc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n impl<T: ?Sized> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -603,10 +641,9 @@ impl<T: ?Sized> Clone for Weak<T> {\n     ///\n     /// ```\n     /// #![feature(arc_weak)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n-    /// let weak_five = Arc::new(5).downgrade();\n+    /// let weak_five = Arc::downgrade(&Arc::new(5));\n     ///\n     /// weak_five.clone();\n     /// ```\n@@ -637,20 +674,19 @@ impl<T: ?Sized> Drop for Weak<T> {\n     ///\n     /// ```\n     /// #![feature(arc_weak)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// {\n     ///     let five = Arc::new(5);\n-    ///     let weak_five = five.downgrade();\n+    ///     let weak_five = Arc::downgrade(&five);\n     ///\n     ///     // stuff\n     ///\n     ///     drop(weak_five); // explicit drop\n     /// }\n     /// {\n     ///     let five = Arc::new(5);\n-    ///     let weak_five = five.downgrade();\n+    ///     let weak_five = Arc::downgrade(&five);\n     ///\n     ///     // stuff\n     ///\n@@ -890,23 +926,35 @@ mod tests {\n         assert!(Arc::get_mut(&mut x).is_none());\n         drop(y);\n         assert!(Arc::get_mut(&mut x).is_some());\n-        let _w = x.downgrade();\n+        let _w = Arc::downgrade(&x);\n         assert!(Arc::get_mut(&mut x).is_none());\n     }\n \n     #[test]\n-    fn test_cowarc_clone_make_unique() {\n+    fn try_unwrap() {\n+        let x = Arc::new(3);\n+        assert_eq!(Arc::try_unwrap(x), Ok(3));\n+        let x = Arc::new(4);\n+        let _y = x.clone();\n+        assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+        let x = Arc::new(5);\n+        let _w = Arc::downgrade(&x);\n+        assert_eq!(Arc::try_unwrap(x), Ok(5));\n+    }\n+\n+    #[test]\n+    fn test_cowarc_clone_make_mut() {\n         let mut cow0 = Arc::new(75);\n         let mut cow1 = cow0.clone();\n         let mut cow2 = cow1.clone();\n \n-        assert!(75 == *Arc::make_unique(&mut cow0));\n-        assert!(75 == *Arc::make_unique(&mut cow1));\n-        assert!(75 == *Arc::make_unique(&mut cow2));\n+        assert!(75 == *Arc::make_mut(&mut cow0));\n+        assert!(75 == *Arc::make_mut(&mut cow1));\n+        assert!(75 == *Arc::make_mut(&mut cow2));\n \n-        *Arc::make_unique(&mut cow0) += 1;\n-        *Arc::make_unique(&mut cow1) += 2;\n-        *Arc::make_unique(&mut cow2) += 3;\n+        *Arc::make_mut(&mut cow0) += 1;\n+        *Arc::make_mut(&mut cow1) += 2;\n+        *Arc::make_mut(&mut cow2) += 3;\n \n         assert!(76 == *cow0);\n         assert!(77 == *cow1);\n@@ -928,8 +976,7 @@ mod tests {\n         assert!(75 == *cow1);\n         assert!(75 == *cow2);\n \n-        *Arc::make_unique(&mut cow0) += 1;\n-\n+        *Arc::make_mut(&mut cow0) += 1;\n         assert!(76 == *cow0);\n         assert!(75 == *cow1);\n         assert!(75 == *cow2);\n@@ -944,12 +991,12 @@ mod tests {\n     #[test]\n     fn test_cowarc_clone_weak() {\n         let mut cow0 = Arc::new(75);\n-        let cow1_weak = cow0.downgrade();\n+        let cow1_weak = Arc::downgrade(&cow0);\n \n         assert!(75 == *cow0);\n         assert!(75 == *cow1_weak.upgrade().unwrap());\n \n-        *Arc::make_unique(&mut cow0) += 1;\n+        *Arc::make_mut(&mut cow0) += 1;\n \n         assert!(76 == *cow0);\n         assert!(cow1_weak.upgrade().is_none());\n@@ -958,14 +1005,14 @@ mod tests {\n     #[test]\n     fn test_live() {\n         let x = Arc::new(5);\n-        let y = x.downgrade();\n+        let y = Arc::downgrade(&x);\n         assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n     fn test_dead() {\n         let x = Arc::new(5);\n-        let y = x.downgrade();\n+        let y = Arc::downgrade(&x);\n         drop(x);\n         assert!(y.upgrade().is_none());\n     }\n@@ -977,7 +1024,7 @@ mod tests {\n         }\n \n         let a = Arc::new(Cycle { x: Mutex::new(None) });\n-        let b = a.clone().downgrade();\n+        let b = Arc::downgrade(&a.clone());\n         *a.x.lock().unwrap() = Some(b);\n \n         // hopefully we don't double-free (or leak)...\n@@ -995,7 +1042,7 @@ mod tests {\n     fn drop_arc_weak() {\n         let mut canary = atomic::AtomicUsize::new(0);\n         let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        let arc_weak = arc.downgrade();\n+        let arc_weak = Arc::downgrade(&arc);\n         assert!(canary.load(Acquire) == 0);\n         drop(arc);\n         assert!(canary.load(Acquire) == 1);\n@@ -1006,7 +1053,7 @@ mod tests {\n     fn test_strong_count() {\n         let a = Arc::new(0u32);\n         assert!(Arc::strong_count(&a) == 1);\n-        let w = a.downgrade();\n+        let w = Arc::downgrade(&a);\n         assert!(Arc::strong_count(&a) == 1);\n         let b = w.upgrade().expect(\"\");\n         assert!(Arc::strong_count(&b) == 2);\n@@ -1024,7 +1071,7 @@ mod tests {\n         let a = Arc::new(0u32);\n         assert!(Arc::strong_count(&a) == 1);\n         assert!(Arc::weak_count(&a) == 0);\n-        let w = a.downgrade();\n+        let w = Arc::downgrade(&a);\n         assert!(Arc::strong_count(&a) == 1);\n         assert!(Arc::weak_count(&a) == 1);\n         let x = w.clone();\n@@ -1036,7 +1083,7 @@ mod tests {\n         let c = a.clone();\n         assert!(Arc::strong_count(&a) == 2);\n         assert!(Arc::weak_count(&a) == 0);\n-        let d = c.downgrade();\n+        let d = Arc::downgrade(&c);\n         assert!(Arc::weak_count(&c) == 1);\n         assert!(Arc::strong_count(&c) == 2);\n \n@@ -1059,7 +1106,7 @@ mod tests {\n     fn test_unsized() {\n         let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n         assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n-        let y = x.clone().downgrade();\n+        let y = Arc::downgrade(&x.clone());\n         drop(x);\n         assert!(y.upgrade().is_none());\n     }"}]}