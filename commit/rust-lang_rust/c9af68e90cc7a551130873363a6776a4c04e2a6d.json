{"sha": "c9af68e90cc7a551130873363a6776a4c04e2a6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YWY2OGU5MGNjN2E1NTExMzA4NzMzNjNhNjc3NmE0YzA0ZTJhNmQ=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2017-11-19T22:35:53Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2017-11-26T15:36:52Z"}, "message": "Replace -Zborrowck-mir with -Zborrowck=mode\n\nwhere mode is one of {ast,mir,compare}.\n\nThis commit only implements the functionality.\nThe tests will be updated in a follow up commit.", "tree": {"sha": "7cacceb88af3e9ae5012ccb89d7eea3e09896809", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cacceb88af3e9ae5012ccb89d7eea3e09896809"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9af68e90cc7a551130873363a6776a4c04e2a6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9af68e90cc7a551130873363a6776a4c04e2a6d", "html_url": "https://github.com/rust-lang/rust/commit/c9af68e90cc7a551130873363a6776a4c04e2a6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9af68e90cc7a551130873363a6776a4c04e2a6d/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ca00a948934766950167e997903a2cc0243c5cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ca00a948934766950167e997903a2cc0243c5cf", "html_url": "https://github.com/rust-lang/rust/commit/2ca00a948934766950167e997903a2cc0243c5cf"}], "stats": {"total": 213, "additions": 160, "deletions": 53}, "files": [{"sha": "97b9d776a57ab77363e077a61191a64533632d5e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c9af68e90cc7a551130873363a6776a4c04e2a6d", "patch": "@@ -362,6 +362,9 @@ top_level_options!(\n \n         debugging_opts: DebuggingOptions [TRACKED],\n         prints: Vec<PrintRequest> [UNTRACKED],\n+        // Determines which borrow checker(s) to run. This is the parsed, sanitized\n+        // version of `debugging_opts.borrowck`, which is just a plain string.\n+        borrowck_mode: BorrowckMode [UNTRACKED],\n         cg: CodegenOptions [TRACKED],\n         // FIXME(mw): We track this for now but it actually doesn't make too\n         //            much sense: The value of this option can stay the same\n@@ -401,6 +404,32 @@ pub enum PrintRequest {\n     NativeStaticLibs,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BorrowckMode {\n+    Ast,\n+    Mir,\n+    Compare,\n+}\n+\n+impl BorrowckMode {\n+    /// Should we emit the AST-based borrow checker errors?\n+    pub fn use_ast(self) -> bool {\n+        match self {\n+            BorrowckMode::Ast => true,\n+            BorrowckMode::Compare => true,\n+            BorrowckMode::Mir => false,\n+        }\n+    }\n+    /// Should we emit the MIR-based borrow checker errors?\n+    pub fn use_mir(self) -> bool {\n+        match self {\n+            BorrowckMode::Ast => false,\n+            BorrowckMode::Compare => true,\n+            BorrowckMode::Mir => true,\n+        }\n+    }\n+}\n+\n pub enum Input {\n     /// Load source from file\n     File(PathBuf),\n@@ -526,6 +555,7 @@ pub fn basic_options() -> Options {\n         incremental: None,\n         debugging_opts: basic_debugging_options(),\n         prints: Vec::new(),\n+        borrowck_mode: BorrowckMode::Ast,\n         cg: basic_codegen_options(),\n         error_format: ErrorOutputType::default(),\n         externs: Externs(BTreeMap::new()),\n@@ -973,8 +1003,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n     emit_end_regions: bool = (false, parse_bool, [UNTRACKED],\n         \"emit EndRegion as part of MIR; enable transforms that solely process EndRegion\"),\n-    borrowck_mir: bool = (false, parse_bool, [UNTRACKED],\n-        \"implicitly treat functions as if they have `#[rustc_mir_borrowck]` attribute\"),\n+    borrowck: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"select which borrowck is used (`ast`, `mir`, or `compare`)\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     count_llvm_insns: bool = (false, parse_bool,\n@@ -1743,6 +1773,15 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         }\n     }));\n \n+    let borrowck_mode = match debugging_opts.borrowck.as_ref().map(|s| &s[..]) {\n+        None | Some(\"ast\") => BorrowckMode::Ast,\n+        Some(\"mir\") => BorrowckMode::Mir,\n+        Some(\"compare\") => BorrowckMode::Compare,\n+        Some(m) => {\n+            early_error(error_format, &format!(\"unknown borrowchk mode `{}`\", m))\n+        },\n+    };\n+\n     if !cg.remark.is_empty() && debuginfo == NoDebugInfo {\n         early_warn(error_format, \"-C remark will not show source locations without \\\n                                 --debuginfo\");\n@@ -1784,6 +1823,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         incremental,\n         debugging_opts,\n         prints,\n+        borrowck_mode,\n         cg,\n         error_format,\n         externs: Externs(externs),"}, {"sha": "227efcf4d6e2198b258dc99082b8f21e2cf3b51b", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c9af68e90cc7a551130873363a6776a4c04e2a6d", "patch": "@@ -416,7 +416,7 @@ impl Session {\n     pub fn emit_end_regions(&self) -> bool {\n         self.opts.debugging_opts.emit_end_regions ||\n             (self.opts.debugging_opts.mir_emit_validate > 0) ||\n-            self.opts.debugging_opts.borrowck_mir\n+            self.opts.borrowck_mode.use_mir()\n     }\n     pub fn lto(&self) -> bool {\n         self.opts.cg.lto || self.target.target.options.requires_lto"}, {"sha": "40837c5e8d699ea8f7d3c094f5ed58f45b4fdd68", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=c9af68e90cc7a551130873363a6776a4c04e2a6d", "patch": "@@ -269,6 +269,17 @@ impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n     {\n         self.tcx.sess.struct_span_err(sp, msg)\n     }\n+\n+    fn cancel_if_wrong_origin<'a>(&'a self,\n+                                mut diag: DiagnosticBuilder<'a>,\n+                                o: Origin)\n+                                -> DiagnosticBuilder<'a>\n+    {\n+        if !o.should_emit_errors(self.tcx.sess.opts.borrowck_mode) {\n+            self.tcx.sess.diagnostic().cancel(&mut diag);\n+        }\n+        diag\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "289636be3217ccf6d1561e2843ad7b3ea1b2239c", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=c9af68e90cc7a551130873363a6776a4c04e2a6d", "patch": "@@ -54,7 +54,7 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n \n     if {\n         !tcx.has_attr(def_id, \"rustc_mir_borrowck\") &&\n-            !tcx.sess.opts.debugging_opts.borrowck_mir &&\n+            !tcx.sess.opts.borrowck_mode.use_mir() &&\n             !tcx.sess.opts.debugging_opts.nll\n     } {\n         return;"}, {"sha": "00248400c553c11fe14aad3bf08643089561c262", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 105, "deletions": 49, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9af68e90cc7a551130873363a6776a4c04e2a6d/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=c9af68e90cc7a551130873363a6776a4c04e2a6d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::ty::{self, TyCtxt};\n+use rustc::session::config::BorrowckMode;\n use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n use syntax_pos::{MultiSpan, Span};\n \n@@ -19,20 +20,34 @@ pub enum Origin { Ast, Mir }\n \n impl fmt::Display for Origin {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Origin::Mir => write!(w, \" (Mir)\"),\n-            Origin::Ast => ty::tls::with_opt(|opt_tcx| {\n-                // If user passed `-Z borrowck-mir`, then include an\n-                // AST origin as part of the error report\n-                if let Some(tcx) = opt_tcx {\n-                    if tcx.sess.opts.debugging_opts.borrowck_mir {\n-                        return write!(w, \" (Ast)\");\n-                    }\n-                }\n-                // otherwise, do not include the origin (i.e., print\n-                // nothing at all)\n-                Ok(())\n-            }),\n+        // If the user passed `-Z borrowck=compare`, then include\n+        // origin info as part of the error report,\n+        // otherwise\n+        let display_origin = ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                tcx.sess.opts.borrowck_mode == BorrowckMode::Compare\n+            } else {\n+                false\n+            }\n+        });\n+        if display_origin {\n+            match *self {\n+                Origin::Mir => write!(w, \" (Mir)\"),\n+                Origin::Ast => write!(w, \" (Ast)\"),\n+            }\n+        } else {\n+            // Print no origin info\n+            Ok(())\n+        }\n+    }\n+}\n+\n+impl Origin {\n+    /// Whether we should emit errors for the origin in the given mode\n+    pub fn should_emit_errors(self, mode: BorrowckMode) -> bool {\n+        match self {\n+            Origin::Ast => mode.use_ast(),\n+            Origin::Mir => mode.use_mir(),\n         }\n     }\n }\n@@ -49,12 +64,23 @@ pub trait BorrowckErrors {\n                                                msg: &str)\n                                                -> DiagnosticBuilder<'a>;\n \n+    /// Cancels the given error if we shouldn't emit errors for a given\n+    /// origin in the current mode.\n+    ///\n+    /// Always make sure that the error gets passed through this function\n+    /// before you return it.\n+    fn cancel_if_wrong_origin<'a>(&'a self,\n+                                diag: DiagnosticBuilder<'a>,\n+                                o: Origin)\n+                                -> DiagnosticBuilder<'a>;\n+\n     fn cannot_move_when_borrowed(&self, span: Span, desc: &str, o: Origin)\n                                  -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0505,\n-                         \"cannot move out of `{}` because it is borrowed{OGN}\",\n-                         desc, OGN=o)\n+        let err = struct_span_err!(self, span, E0505,\n+                                   \"cannot move out of `{}` because it is borrowed{OGN}\",\n+                                   desc, OGN=o);\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_use_when_mutably_borrowed(&self,\n@@ -72,7 +98,7 @@ pub trait BorrowckErrors {\n         err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", borrow_desc));\n         err.span_label(span, format!(\"use of borrowed `{}`\", borrow_desc));\n \n-        err\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_act_on_uninitialized_variable(&self,\n@@ -82,9 +108,10 @@ pub trait BorrowckErrors {\n                                             o: Origin)\n                                             -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0381,\n-                         \"{} of possibly uninitialized variable: `{}`{OGN}\",\n-                         verb, desc, OGN=o)\n+        let err = struct_span_err!(self, span, E0381,\n+                                   \"{} of possibly uninitialized variable: `{}`{OGN}\",\n+                                   verb, desc, OGN=o);\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_mutably_borrow_multiply(&self,\n@@ -118,7 +145,7 @@ pub trait BorrowckErrors {\n                 err.span_label(old_load_end_span, \"first borrow ends here\");\n             }\n         }\n-        err\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_uniquely_borrow_by_two_closures(&self,\n@@ -143,7 +170,7 @@ pub trait BorrowckErrors {\n                 old_load_end_span,\n                 \"borrow from first closure ends here\");\n         }\n-        err\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_uniquely_borrow_by_one_closure(&self,\n@@ -167,7 +194,7 @@ pub trait BorrowckErrors {\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow ends here\");\n         }\n-        err\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_reborrow_already_uniquely_borrowed(&self,\n@@ -192,7 +219,7 @@ pub trait BorrowckErrors {\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow from closure ends here\");\n         }\n-        err\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_reborrow_already_borrowed(&self,\n@@ -216,7 +243,7 @@ pub trait BorrowckErrors {\n         if let Some(old_load_end_span) = old_load_end_span {\n             err.span_label(old_load_end_span, format!(\"{} borrow ends here\", kind_old));\n         }\n-        err\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_assign_to_borrowed(&self, span: Span, borrow_span: Span, desc: &str, o: Origin)\n@@ -229,30 +256,35 @@ pub trait BorrowckErrors {\n         err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", desc));\n         err.span_label(span, format!(\"assignment to borrowed `{}` occurs here\", desc));\n \n-        err\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_move_into_closure(&self, span: Span, desc: &str, o: Origin)\n                                 -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0504,\n-                         \"cannot move `{}` into closure because it is borrowed{OGN}\",\n-                         desc, OGN=o)\n+        let err = struct_span_err!(self, span, E0504,\n+                                   \"cannot move `{}` into closure because it is borrowed{OGN}\",\n+                                   desc, OGN=o);\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_reassign_immutable(&self, span: Span, desc: &str, o: Origin)\n                                  -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0384,\n-                         \"cannot assign twice to immutable variable `{}`{OGN}\",\n-                         desc, OGN=o)\n+        let err = struct_span_err!(self, span, E0384,\n+                                   \"cannot assign twice to immutable variable `{}`{OGN}\",\n+                                   desc, OGN=o);\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_assign(&self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0594,\n-                         \"cannot assign to {}{OGN}\",\n-                         desc, OGN=o)\n+        let err = struct_span_err!(self, span, E0594,\n+                                  \"cannot assign to {}{OGN}\",\n+                                  desc, OGN=o);\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_assign_static(&self, span: Span, desc: &str, o: Origin)\n@@ -270,7 +302,8 @@ pub trait BorrowckErrors {\n         err.span_label(\n             move_from_span,\n             format!(\"cannot move out of {}\", move_from_desc));\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_move_out_of_interior_noncopy(&self,\n@@ -290,7 +323,8 @@ pub trait BorrowckErrors {\n                                         a non-copy {}{OGN}\",\n                                        ty, type_name, OGN=o);\n         err.span_label(move_from_span, \"cannot move out of here\");\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_move_out_of_interior_of_drop(&self,\n@@ -304,7 +338,8 @@ pub trait BorrowckErrors {\n                                         which implements the `Drop` trait{OGN}\",\n                                        container_ty, OGN=o);\n         err.span_label(move_from_span, \"cannot move out of here\");\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_act_on_moved_value(&self,\n@@ -318,7 +353,8 @@ pub trait BorrowckErrors {\n         let err = struct_span_err!(self, use_span, E0382,\n                                    \"{} of {}moved value: `{}`{OGN}\",\n                                    verb, optional_adverb_for_moved, moved_path, OGN=o);\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_partially_reinit_an_uninit_struct(&self,\n@@ -332,7 +368,8 @@ pub trait BorrowckErrors {\n                                    E0383,\n                                    \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n                                    uninit_path, OGN=o);\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn closure_cannot_assign_to_borrowed(&self,\n@@ -343,7 +380,8 @@ pub trait BorrowckErrors {\n     {\n         let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n                                    descr, OGN=o);\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_borrow_path_as_mutable(&self,\n@@ -354,7 +392,8 @@ pub trait BorrowckErrors {\n     {\n         let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n                                    path, OGN=o);\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_borrow_across_generator_yield(&self,\n@@ -369,7 +408,8 @@ pub trait BorrowckErrors {\n                                        \"borrow may still be in use when generator yields{OGN}\",\n                                        OGN=o);\n         err.span_label(yield_span, \"possible yield occurs here\");\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn path_does_not_live_long_enough(&self,\n@@ -380,7 +420,8 @@ pub trait BorrowckErrors {\n     {\n         let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n                                    path, OGN=o);\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn lifetime_too_short_for_reborrow(&self,\n@@ -393,7 +434,8 @@ pub trait BorrowckErrors {\n                                    \"lifetime of {} is too short to guarantee \\\n                                     its contents can be safely reborrowed{OGN}\",\n                                    path, OGN=o);\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_act_on_capture_in_sharable_fn(&self,\n@@ -408,7 +450,8 @@ pub trait BorrowckErrors {\n                                        \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n                                        bad_thing, OGN=o);\n         err.span_help(help_span, help_msg);\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_assign_into_immutable_reference(&self,\n@@ -420,7 +463,8 @@ pub trait BorrowckErrors {\n         let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n                                        bad_thing, OGN=o);\n         err.span_label(span, \"assignment into an immutable reference\");\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n \n     fn cannot_capture_in_long_lived_closure(&self,\n@@ -437,7 +481,8 @@ pub trait BorrowckErrors {\n                                        borrowed_path, OGN=o);\n         err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n             .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));\n-        err\n+\n+        self.cancel_if_wrong_origin(err, o)\n     }\n }\n \n@@ -458,4 +503,15 @@ impl<'b, 'gcx, 'tcx> BorrowckErrors for TyCtxt<'b, 'gcx, 'tcx> {\n     {\n         self.sess.struct_span_err(sp, msg)\n     }\n+\n+    fn cancel_if_wrong_origin<'a>(&'a self,\n+                                mut diag: DiagnosticBuilder<'a>,\n+                                o: Origin)\n+                                -> DiagnosticBuilder<'a>\n+    {\n+        if !o.should_emit_errors(self.sess.opts.borrowck_mode) {\n+            self.sess.diagnostic().cancel(&mut diag);\n+        }\n+        diag\n+    }\n }"}]}