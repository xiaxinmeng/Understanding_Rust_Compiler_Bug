{"sha": "e289b689d4c1af7da5f665321942713cdc3be95d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyODliNjg5ZDRjMWFmN2RhNWY2NjUzMjE5NDI3MTNjZGMzYmU5NWQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-18T21:21:26Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-20T13:44:10Z"}, "message": "TRPL edits: traits\n\nLet's talk about generics first, since we use traits to bound them\nin funtions.\n\nPartially addresses #24325\n\nFixes #24271", "tree": {"sha": "9e1e063c9fdc53571c089d39df3c4d1608450e8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e1e063c9fdc53571c089d39df3c4d1608450e8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e289b689d4c1af7da5f665321942713cdc3be95d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e289b689d4c1af7da5f665321942713cdc3be95d", "html_url": "https://github.com/rust-lang/rust/commit/e289b689d4c1af7da5f665321942713cdc3be95d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e289b689d4c1af7da5f665321942713cdc3be95d/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1646ebd5baae3bc2eea9ace51c3b9bf497dad80e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1646ebd5baae3bc2eea9ace51c3b9bf497dad80e", "html_url": "https://github.com/rust-lang/rust/commit/1646ebd5baae3bc2eea9ace51c3b9bf497dad80e"}], "stats": {"total": 290, "additions": 101, "deletions": 189}, "files": [{"sha": "ec886899e6fe931ddd500676a76e6cd698058bd1", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e289b689d4c1af7da5f665321942713cdc3be95d/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/e289b689d4c1af7da5f665321942713cdc3be95d/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=e289b689d4c1af7da5f665321942713cdc3be95d", "patch": "@@ -34,10 +34,10 @@\n     * [Method Syntax](method-syntax.md)\n     * [Vectors](vectors.md)\n     * [Strings](strings.md)\n+    * [Generics](generics.md)\n     * [Traits](traits.md)\n     * [Operators and Overloading](operators-and-overloading.md)\n     * [Drop](drop.md)\n-    * [Generics](generics.md)\n     * [if let](if-let.md)\n     * [Trait Objects](trait-objects.md)\n     * [Closures](closures.md)"}, {"sha": "7330e42ccf689dd8cbf1fb18d0fac01897c19d79", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 100, "deletions": 188, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/e289b689d4c1af7da5f665321942713cdc3be95d/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/e289b689d4c1af7da5f665321942713cdc3be95d/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=e289b689d4c1af7da5f665321942713cdc3be95d", "patch": "@@ -1,10 +1,9 @@\n % Traits\n \n-Do you remember the `impl` keyword, used to call a function with method\n-syntax?\n+Do you remember the `impl` keyword, used to call a function with [method\n+syntax][methodsyntax]?\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -18,11 +17,12 @@ impl Circle {\n }\n ```\n \n+[methodsyntax]: method-syntax.html\n+\n Traits are similar, except that we define a trait with just the method\n signature, then implement the trait for that struct. Like this:\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -41,20 +41,13 @@ impl HasArea for Circle {\n ```\n \n As you can see, the `trait` block looks very similar to the `impl` block,\n-but we don't define a body, just a type signature. When we `impl` a trait,\n+but we don\u2019t define a body, just a type signature. When we `impl` a trait,\n we use `impl Trait for Item`, rather than just `impl Item`.\n \n-So what's the big deal? Remember the error we were getting with our generic\n-`inverse` function?\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n We can use traits to constrain our generics. Consider this function, which\n does not compile, and gives us a similar error:\n \n-```{rust,ignore}\n+```rust,ignore\n fn print_area<T>(shape: T) {\n     println!(\"This shape has an area of {}\", shape.area());\n }\n@@ -66,11 +59,11 @@ Rust complains:\n error: type `T` does not implement any method in scope named `area`\n ```\n \n-Because `T` can be any type, we can't be sure that it implements the `area`\n-method. But we can add a *trait constraint* to our generic `T`, ensuring\n+Because `T` can be any type, we can\u2019t be sure that it implements the `area`\n+method. But we can add a \u2018trait constraint\u2019 to our generic `T`, ensuring\n that it does:\n \n-```{rust}\n+```rust\n # trait HasArea {\n #     fn area(&self) -> f64;\n # }\n@@ -83,10 +76,9 @@ The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n Because traits define function type signatures, we can be sure that any type\n which implements `HasArea` will have an `.area()` method.\n \n-Here's an extended example of how this works:\n+Here\u2019s an extended example of how this works:\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n trait HasArea {\n     fn area(&self) -> f64;\n }\n@@ -144,10 +136,10 @@ This shape has an area of 3.141593\n This shape has an area of 1\n ```\n \n-As you can see, `print_area` is now generic, but also ensures that we\n-have passed in the correct types. If we pass in an incorrect type:\n+As you can see, `print_area` is now generic, but also ensures that we have\n+passed in the correct types. If we pass in an incorrect type:\n \n-```{rust,ignore}\n+```rust,ignore\n print_area(5);\n ```\n \n@@ -157,11 +149,11 @@ We get a compile-time error:\n error: failed to find an implementation of trait main::HasArea for int\n ```\n \n-So far, we've only added trait implementations to structs, but you can\n-implement a trait for any type. So technically, we _could_ implement\n-`HasArea` for `i32`:\n+So far, we\u2019ve only added trait implementations to structs, but you can\n+implement a trait for any type. So technically, we _could_ implement `HasArea`\n+for `i32`:\n \n-```{rust}\n+```rust\n trait HasArea {\n     fn area(&self) -> f64;\n }\n@@ -181,102 +173,57 @@ It is considered poor style to implement methods on such primitive types, even\n though it is possible.\n \n This may seem like the Wild West, but there are two other restrictions around\n-implementing traits that prevent this from getting out of hand. First, traits\n-must be `use`d in any scope where you wish to use the trait's method. So for\n-example, this does not work:\n+implementing traits that prevent this from getting out of hand. The first is\n+that if the trait isn\u2019t defined in your scope, it doesn\u2019t apply. Here\u2019s an\n+example: the standard library provides a [`Write`][write] trait which adds\n+extra functionality to `File`s, for doing file I/O. By default, a `File`\n+won\u2019t have its methods:\n \n-```{rust,ignore}\n-mod shapes {\n-    use std::f64::consts;\n+[write]: ../std/io/trait.Write.html\n \n-    trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    struct Circle {\n-        x: f64,\n-        y: f64,\n-        radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n-\n-    println!(\"{}\", c.area());\n-}\n+```rust,ignore\n+let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n+let result = f.write(\"whatever\".as_bytes());\n+# result.unwrap(); // ignore the erorr\n ```\n \n-Now that we've moved the structs and traits into their own module, we get an\n-error:\n+Here\u2019s the error:\n \n ```text\n-error: type `shapes::Circle` does not implement any method in scope named `area`\n-```\n+error: type `std::fs::File` does not implement any method in scope named `write`\n \n-If we add a `use` line right above `main` and make the right things public,\n-everything is fine:\n-\n-```{rust}\n-# #![feature(core)]\n-mod shapes {\n-    use std::f64::consts;\n-\n-    pub trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    pub struct Circle {\n-        pub x: f64,\n-        pub y: f64,\n-        pub radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n+let result = f.write(b\u201dwhatever\u201d);\n+               ^~~~~~~~~~~~~~~~~~\n+```\n \n-use shapes::HasArea;\n+We need to `use` the `Write` trait first:\n \n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n+```rust,ignore\n+use std::io::Write;\n \n-    println!(\"{}\", c.area());\n-}\n+let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n+let result = f.write(\"whatever\".as_bytes());\n+# result.unwrap(); // ignore the erorr\n ```\n \n+This will compile without error.\n+\n This means that even if someone does something bad like add methods to `int`,\n-it won't affect you, unless you `use` that trait.\n+it won\u2019t affect you, unless you `use` that trait.\n \n-There's one more restriction on implementing traits. Either the trait or the\n-type you're writing the `impl` for must be inside your crate. So, we could\n-implement the `HasArea` type for `i32`, because `HasArea` is in our crate.  But\n+There\u2019s one more restriction on implementing traits. Either the trait or the\n+type you\u2019re writing the `impl` for must be defined by you. So, we could\n+implement the `HasArea` type for `i32`, because `HasArea` is in our code. But\n if we tried to implement `Float`, a trait provided by Rust, for `i32`, we could\n-not, because both the trait and the type aren't in our crate.\n+not, because neither the trait nor the type are in our code.\n \n One last thing about traits: generic functions with a trait bound use\n-*monomorphization* (*mono*: one, *morph*: form), so they are statically\n-dispatched. What's that mean? Check out the chapter on [trait\n-objects](trait-objects.html) for more.\n+\u2018monomorphization\u2019 (mono: one, morph: form), so they are statically dispatched.\n+What\u2019s that mean? Check out the chapter on [trait objects][to] for more details.\n+\n+[to]: trait-objects.html\n \n-## Multiple trait bounds\n+# Multiple trait bounds\n \n You\u2019ve seen that you can bound a generic type parameter with a trait:\n \n@@ -299,10 +246,10 @@ fn foo<T: Clone + Debug>(x: T) {\n \n `T` now needs to be both `Clone` as well as `Debug`.\n \n-## Where clause\n+# Where clause\n \n Writing functions with only a few generic types and a small number of trait\n-bounds isn't too bad, but as the number increases, the syntax gets increasingly\n+bounds isn\u2019t too bad, but as the number increases, the syntax gets increasingly\n awkward:\n \n ```\n@@ -318,7 +265,7 @@ fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n The name of the function is on the far left, and the parameter list is on the\n far right. The bounds are getting in the way.\n \n-Rust has a solution, and it's called a '`where` clause':\n+Rust has a solution, and it\u2019s called a \u2018`where` clause\u2019:\n \n ```\n use std::fmt::Debug;\n@@ -389,84 +336,9 @@ This shows off the additional feature of `where` clauses: they allow bounds\n where the left-hand side is an arbitrary type (`i32` in this case), not just a\n plain type parameter (like `T`).\n \n-## Our `inverse` Example\n-\n-Back in [Generics](generics.html), we were trying to write code like this:\n-\n-```{rust,ignore}\n-fn inverse<T>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-If we try to compile it, we get this error:\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n-This is because `T` is too generic: we don't know if a random `T` can be\n-compared. For that, we can use trait bounds. It doesn't quite work, but try\n-this:\n-\n-```{rust,ignore}\n-fn inverse<T: PartialEq>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-You should get this error:\n-\n-```text\n-error: mismatched types:\n- expected `T`,\n-    found `_`\n-(expected type parameter,\n-    found floating-point variable)\n-```\n-\n-So this won't work. While our `T` is `PartialEq`, we expected to have another `T`,\n-but instead, we found a floating-point variable. We need a different bound. `Float`\n-to the rescue:\n-\n-```\n-# #![feature(std_misc)]\n-use std::num::Float;\n-\n-fn inverse<T: Float>(x: T) -> Result<T, String> {\n-    if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n-\n-    let one: T = Float::one();\n-    Ok(one / x)\n-}\n-```\n-\n-We've had to replace our generic `0.0` and `1.0` with the appropriate methods\n-from the `Float` trait. Both `f32` and `f64` implement `Float`, so our function\n-works just fine:\n-\n-```\n-# #![feature(std_misc)]\n-# use std::num::Float;\n-# fn inverse<T: Float>(x: T) -> Result<T, String> {\n-#     if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n-#     let one: T = Float::one();\n-#     Ok(one / x)\n-# }\n-println!(\"the inverse of {} is {:?}\", 2.0f32, inverse(2.0f32));\n-println!(\"the inverse of {} is {:?}\", 2.0f64, inverse(2.0f64));\n-\n-println!(\"the inverse of {} is {:?}\", 0.0f32, inverse(0.0f32));\n-println!(\"the inverse of {} is {:?}\", 0.0f64, inverse(0.0f64));\n-```\n-\n-## Default methods\n+# Default methods\n \n-There's one last feature of traits we should cover: default methods. It's\n+There\u2019s one last feature of traits we should cover: default methods. It\u2019s\n easiest just to show an example:\n \n ```rust\n@@ -477,8 +349,8 @@ trait Foo {\n }\n ```\n \n-Implementors of the `Foo` trait need to implement `bar()`, but they don't\n-need to implement `baz()`. They'll get this default behavior. They can\n+Implementors of the `Foo` trait need to implement `bar()`, but they don\u2019t\n+need to implement `baz()`. They\u2019ll get this default behavior. They can\n override the default if they so choose:\n \n ```rust\n@@ -506,3 +378,43 @@ default.baz(); // prints \"We called baz.\"\n let over = OverrideDefault;\n over.baz(); // prints \"Override baz!\"\n ```\n+\n+# Inheritance\n+\n+Sometimes, implementing a trait requires implementing another trait:\n+\n+```rust\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+trait FooBar : Foo {\n+    fn foobar(&self);\n+}\n+```\n+\n+Implementors of `FooBar` must also implement `Foo`, like this:\n+\n+```rust\n+# trait Foo {\n+#     fn foo(&self);\n+# }\n+# trait FooBar : Foo {\n+#     fn foobar(&self);\n+# }\n+struct Baz;\n+\n+impl Foo for Baz {\n+    fn foo(&self) { println!(\"foo\"); }\n+}\n+\n+impl FooBar for Baz {\n+    fn foobar(&self) { println!(\"foobar\"); }\n+}\n+```\n+\n+If we forget to implement `Foo`, Rust will tell us:\n+\n+```text\n+error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]\n+```"}]}