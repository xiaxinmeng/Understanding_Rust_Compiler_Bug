{"sha": "6bd3ab0d8140053475a901ad4e2e80e98955bcb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZDNhYjBkODE0MDA1MzQ3NWE5MDFhZDRlMmU4MGU5ODk1NWJjYjA=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-03-20T07:46:13Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-03-23T18:28:54Z"}, "message": "Implement RFC 909: move thread_local into thread\n\nThis commit implements [RFC\n909](https://github.com/rust-lang/rfcs/pull/909):\n\nThe `std::thread_local` module is now deprecated, and its contents are\navailable directly in `std::thread` as `LocalKey`, `LocalKeyState`, and\n`ScopedKey`.\n\nThe macros remain exactly as they were, which means little if any code\nshould break. Nevertheless, this is technically a:\n\n[breaking-change]\n\nCloses #23547", "tree": {"sha": "b8d6a880328d2fd590634319a047cabe66630632", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8d6a880328d2fd590634319a047cabe66630632"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bd3ab0d8140053475a901ad4e2e80e98955bcb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bd3ab0d8140053475a901ad4e2e80e98955bcb0", "html_url": "https://github.com/rust-lang/rust/commit/6bd3ab0d8140053475a901ad4e2e80e98955bcb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0aad7dd4fad8d7e2e2f877a511a637258949597", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0aad7dd4fad8d7e2e2f877a511a637258949597", "html_url": "https://github.com/rust-lang/rust/commit/b0aad7dd4fad8d7e2e2f877a511a637258949597"}], "stats": {"total": 218, "additions": 127, "deletions": 91}, "files": [{"sha": "970074f79306c0203749866a358c2b8d1905ccd9", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6bd3ab0d8140053475a901ad4e2e80e98955bcb0", "patch": "@@ -249,30 +249,23 @@ pub mod num;\n /* Runtime and platform support */\n \n #[macro_use]\n-pub mod thread_local;\n+pub mod thread;\n \n+pub mod collections;\n pub mod dynamic_lib;\n+pub mod env;\n pub mod ffi;\n-pub mod old_io;\n-pub mod io;\n pub mod fs;\n+pub mod io;\n pub mod net;\n+pub mod old_io;\n+pub mod old_path;\n pub mod os;\n-pub mod env;\n pub mod path;\n-pub mod old_path;\n pub mod process;\n pub mod rand;\n-pub mod time;\n-\n-/* Common data structures */\n-\n-pub mod collections;\n-\n-/* Threads and communication */\n-\n-pub mod thread;\n pub mod sync;\n+pub mod time;\n \n #[macro_use]\n #[path = \"sys/common/mod.rs\"] mod sys_common;\n@@ -305,7 +298,7 @@ mod std {\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]\n     pub use cell; // used for tls!\n-    pub use thread_local; // used for thread_local!\n+    pub use thread; // used for thread_local!\n     pub use marker;  // used for tls!\n     pub use ops; // used for bitflags!\n "}, {"sha": "90526b8f4f318faa941d26c8cdd9be788e2be001", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=6bd3ab0d8140053475a901ad4e2e80e98955bcb0", "patch": "@@ -15,7 +15,7 @@ use core::prelude::*;\n use cell::RefCell;\n use string::String;\n use thread::Thread;\n-use thread_local::State;\n+use thread::LocalKeyState;\n \n struct ThreadInfo {\n     stack_guard: uint,\n@@ -26,7 +26,7 @@ thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(N\n \n impl ThreadInfo {\n     fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R {\n-        if THREAD_INFO.state() == State::Destroyed {\n+        if THREAD_INFO.state() == LocalKeyState::Destroyed {\n             panic!(\"Use of std::thread::current() is not possible after \\\n                     the thread's local data has been destroyed\");\n         }"}, {"sha": "43142d2e5bc0bd097253ec3350cb636956ad2b3e", "filename": "src/libstd/thread/local.rs", "status": "renamed", "additions": 36, "deletions": 63, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=6bd3ab0d8140053475a901ad4e2e80e98955bcb0", "patch": "@@ -9,40 +9,13 @@\n // except according to those terms.\n \n //! Thread local storage\n-//!\n-//! This module provides an implementation of thread local storage for Rust\n-//! programs. Thread local storage is a method of storing data into a global\n-//! variable which each thread in the program will have its own copy of.\n-//! Threads do not share this data, so accesses do not need to be synchronized.\n-//!\n-//! At a high level, this module provides two variants of storage:\n-//!\n-//! * Owning thread local storage. This is a type of thread local key which\n-//!   owns the value that it contains, and will destroy the value when the\n-//!   thread exits. This variant is created with the `thread_local!` macro and\n-//!   can contain any value which is `'static` (no borrowed pointers.\n-//!\n-//! * Scoped thread local storage. This type of key is used to store a reference\n-//!   to a value into local storage temporarily for the scope of a function\n-//!   call. There are no restrictions on what types of values can be placed\n-//!   into this key.\n-//!\n-//! Both forms of thread local storage provide an accessor function, `with`,\n-//! which will yield a shared reference to the value to the specified\n-//! closure. Thread local keys only allow shared access to values as there is no\n-//! way to guarantee uniqueness if a mutable borrow was allowed. Most values\n-//! will want to make use of some form of **interior mutability** through the\n-//! `Cell` or `RefCell` types.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#![unstable(feature = \"thread_local_internals\")]\n \n use prelude::v1::*;\n \n use cell::UnsafeCell;\n \n-#[macro_use]\n-pub mod scoped;\n-\n // Sure wish we had macro hygiene, no?\n #[doc(hidden)]\n #[unstable(feature = \"thread_local_internals\")]\n@@ -95,7 +68,7 @@ pub mod __impl {\n /// });\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Key<T> {\n+pub struct LocalKey<T> {\n     // The key itself may be tagged with #[thread_local], and this `Key` is\n     // stored as a `static`, and it's not valid for a static to reference the\n     // address of another thread_local static. For this reason we kinda wonkily\n@@ -114,15 +87,15 @@ pub struct Key<T> {\n     pub init: fn() -> T,\n }\n \n-/// Declare a new thread local storage key of type `std::thread_local::Key`.\n+/// Declare a new thread local storage key of type `std::thread::LocalKey`.\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n-        static $name: ::std::thread_local::Key<$t> = {\n+        static $name: ::std::thread::LocalKey<$t> = {\n             use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread_local::__impl::KeyInner as __KeyInner;\n+            use std::thread::__local::__impl::KeyInner as __KeyInner;\n             use std::option::Option as __Option;\n             use std::option::Option::None as __None;\n \n@@ -133,13 +106,13 @@ macro_rules! thread_local {\n             fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n                 &__KEY\n             }\n-            ::std::thread_local::Key { inner: __getit, init: __init }\n+            ::std::thread::LocalKey { inner: __getit, init: __init }\n         };\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n-        pub static $name: ::std::thread_local::Key<$t> = {\n+        pub static $name: ::std::thread::LocalKey<$t> = {\n             use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread_local::__impl::KeyInner as __KeyInner;\n+            use std::thread::__local::__impl::KeyInner as __KeyInner;\n             use std::option::Option as __Option;\n             use std::option::Option::None as __None;\n \n@@ -150,7 +123,7 @@ macro_rules! thread_local {\n             fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n                 &__KEY\n             }\n-            ::std::thread_local::Key { inner: __getit, init: __init }\n+            ::std::thread::LocalKey { inner: __getit, init: __init }\n         };\n     );\n }\n@@ -183,36 +156,36 @@ macro_rules! __thread_local_inner {\n         #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n                        not(target_arch = \"aarch64\")),\n                    thread_local)]\n-        static $name: ::std::thread_local::__impl::KeyInner<$t> =\n+        static $name: ::std::thread::__local::__impl::KeyInner<$t> =\n             __thread_local_inner!($init, $t);\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n         #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n                        not(target_arch = \"aarch64\")),\n                    thread_local)]\n-        pub static $name: ::std::thread_local::__impl::KeyInner<$t> =\n+        pub static $name: ::std::thread::__local::__impl::KeyInner<$t> =\n             __thread_local_inner!($init, $t);\n     );\n     ($init:expr, $t:ty) => ({\n         #[cfg(all(any(target_os = \"macos\", target_os = \"linux\"), not(target_arch = \"aarch64\")))]\n-        const _INIT: ::std::thread_local::__impl::KeyInner<$t> = {\n-            ::std::thread_local::__impl::KeyInner {\n+        const _INIT: ::std::thread::__local::__impl::KeyInner<$t> = {\n+            ::std::thread::__local::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: $init },\n                 dtor_registered: ::std::cell::UnsafeCell { value: false },\n                 dtor_running: ::std::cell::UnsafeCell { value: false },\n             }\n         };\n \n         #[cfg(any(not(any(target_os = \"macos\", target_os = \"linux\")), target_arch = \"aarch64\"))]\n-        const _INIT: ::std::thread_local::__impl::KeyInner<$t> = {\n+        const _INIT: ::std::thread::__local::__impl::KeyInner<$t> = {\n             unsafe extern fn __destroy(ptr: *mut u8) {\n-                ::std::thread_local::__impl::destroy_value::<$t>(ptr);\n+                ::std::thread::__local::__impl::destroy_value::<$t>(ptr);\n             }\n \n-            ::std::thread_local::__impl::KeyInner {\n+            ::std::thread::__local::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: $init },\n-                os: ::std::thread_local::__impl::OsStaticKey {\n-                    inner: ::std::thread_local::__impl::OS_INIT_INNER,\n+                os: ::std::thread::__local::__impl::OsStaticKey {\n+                    inner: ::std::thread::__local::__impl::OS_INIT_INNER,\n                     dtor: ::std::option::Option::Some(__destroy as unsafe extern fn(*mut u8)),\n                 },\n             }\n@@ -226,7 +199,7 @@ macro_rules! __thread_local_inner {\n #[unstable(feature = \"std_misc\",\n            reason = \"state querying was recently added\")]\n #[derive(Eq, PartialEq, Copy)]\n-pub enum State {\n+pub enum LocalKeyState {\n     /// All keys are in this state whenever a thread starts. Keys will\n     /// transition to the `Valid` state once the first call to `with` happens\n     /// and the initialization expression succeeds.\n@@ -253,7 +226,7 @@ pub enum State {\n     Destroyed,\n }\n \n-impl<T: 'static> Key<T> {\n+impl<T: 'static> LocalKey<T> {\n     /// Acquire a reference to the value in this TLS key.\n     ///\n     /// This will lazily initialize the value if this thread has not referenced\n@@ -309,16 +282,16 @@ impl<T: 'static> Key<T> {\n     /// any call to `with`.\n     #[unstable(feature = \"std_misc\",\n                reason = \"state querying was recently added\")]\n-    pub fn state(&'static self) -> State {\n+    pub fn state(&'static self) -> LocalKeyState {\n         unsafe {\n             match (self.inner)().get() {\n                 Some(cell) => {\n                     match *cell.get() {\n-                        Some(..) => State::Valid,\n-                        None => State::Uninitialized,\n+                        Some(..) => LocalKeyState::Valid,\n+                        None => LocalKeyState::Uninitialized,\n                     }\n                 }\n-                None => State::Destroyed,\n+                None => LocalKeyState::Destroyed,\n             }\n         }\n     }\n@@ -327,7 +300,7 @@ impl<T: 'static> Key<T> {\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"function renamed to state() and returns more info\")]\n-    pub fn destroyed(&'static self) -> bool { self.state() == State::Destroyed }\n+    pub fn destroyed(&'static self) -> bool { self.state() == LocalKeyState::Destroyed }\n }\n \n #[cfg(all(any(target_os = \"macos\", target_os = \"linux\"), not(target_arch = \"aarch64\")))]\n@@ -553,7 +526,7 @@ mod tests {\n \n     use sync::mpsc::{channel, Sender};\n     use cell::UnsafeCell;\n-    use super::State;\n+    use super::LocalKeyState;\n     use thread;\n \n     struct Foo(Sender<()>);\n@@ -592,21 +565,21 @@ mod tests {\n         struct Foo;\n         impl Drop for Foo {\n             fn drop(&mut self) {\n-                assert!(FOO.state() == State::Destroyed);\n+                assert!(FOO.state() == LocalKeyState::Destroyed);\n             }\n         }\n         fn foo() -> Foo {\n-            assert!(FOO.state() == State::Uninitialized);\n+            assert!(FOO.state() == LocalKeyState::Uninitialized);\n             Foo\n         }\n         thread_local!(static FOO: Foo = foo());\n \n         thread::spawn(|| {\n-            assert!(FOO.state() == State::Uninitialized);\n+            assert!(FOO.state() == LocalKeyState::Uninitialized);\n             FOO.with(|_| {\n-                assert!(FOO.state() == State::Valid);\n+                assert!(FOO.state() == LocalKeyState::Valid);\n             });\n-            assert!(FOO.state() == State::Valid);\n+            assert!(FOO.state() == LocalKeyState::Valid);\n         }).join().ok().unwrap();\n     }\n \n@@ -642,7 +615,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    if K2.state() == State::Destroyed {\n+                    if K2.state() == LocalKeyState::Destroyed {\n                         assert_eq!(HITS, 3);\n                     } else {\n                         if HITS == 1 {\n@@ -658,7 +631,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    assert!(K1.state() != State::Destroyed);\n+                    assert!(K1.state() != LocalKeyState::Destroyed);\n                     assert_eq!(HITS, 2);\n                     K1.with(|s| *s.get() = Some(S1));\n                 }\n@@ -679,7 +652,7 @@ mod tests {\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n-                assert!(K1.state() == State::Destroyed);\n+                assert!(K1.state() == LocalKeyState::Destroyed);\n             }\n         }\n \n@@ -702,7 +675,7 @@ mod tests {\n             fn drop(&mut self) {\n                 let S1(ref tx) = *self;\n                 unsafe {\n-                    if K2.state() != State::Destroyed {\n+                    if K2.state() != LocalKeyState::Destroyed {\n                         K2.with(|s| *s.get() = Some(Foo(tx.clone())));\n                     }\n                 }", "previous_filename": "src/libstd/thread_local/mod.rs"}, {"sha": "57baeb1fb74860a8573a47c36ae4db07b51b79c5", "filename": "src/libstd/thread/mod.rs", "status": "renamed", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=6bd3ab0d8140053475a901ad4e2e80e98955bcb0", "patch": "@@ -138,9 +138,43 @@\n //!   synchronization primitives; the threads already provide basic blocking/signaling.\n //!\n //! * It can be implemented very efficiently on many platforms.\n+//!\n+//! ## Thread-local storage\n+//!\n+//! This module also provides an implementation of thread local storage for Rust\n+//! programs. Thread local storage is a method of storing data into a global\n+//! variable which each thread in the program will have its own copy of.\n+//! Threads do not share this data, so accesses do not need to be synchronized.\n+//!\n+//! At a high level, this module provides two variants of storage:\n+//!\n+//! * Owned thread-local storage. This is a type of thread local key which\n+//!   owns the value that it contains, and will destroy the value when the\n+//!   thread exits. This variant is created with the `thread_local!` macro and\n+//!   can contain any value which is `'static` (no borrowed pointers).\n+//!\n+//! * Scoped thread-local storage. This type of key is used to store a reference\n+//!   to a value into local storage temporarily for the scope of a function\n+//!   call. There are no restrictions on what types of values can be placed\n+//!   into this key.\n+//!\n+//! Both forms of thread local storage provide an accessor function, `with`,\n+//! which will yield a shared reference to the value to the specified\n+//! closure. Thread-local keys only allow shared access to values as there is no\n+//! way to guarantee uniqueness if a mutable borrow was allowed. Most values\n+//! will want to make use of some form of **interior mutability** through the\n+//! `Cell` or `RefCell` types.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::__local::{LocalKey, LocalKeyState};\n+\n+#[unstable(feature = \"scoped_tls\",\n+            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n+                      stabilizing its interface\")]\n+pub use self::__scoped::ScopedKey;\n+\n use prelude::v1::*;\n \n use any::Any;\n@@ -157,6 +191,22 @@ use time::Duration;\n \n #[allow(deprecated)] use old_io::Writer;\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Thread-local storage\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[macro_use]\n+#[doc(hidden)]\n+#[path = \"local.rs\"] pub mod __local;\n+\n+#[macro_use]\n+#[doc(hidden)]\n+#[path = \"scoped.rs\"] pub mod __scoped;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Builder\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Thread configuration. Provides detailed control over the properties\n /// and behavior of new threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -322,6 +372,10 @@ impl Builder {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Free functions\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Spawn a new thread, returning a `JoinHandle` for it.\n ///\n /// The join handle will implicitly *detach* the child thread upon being\n@@ -433,6 +487,10 @@ pub fn park_timeout(duration: Duration) {\n     *guard = false;\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Thread\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// The internal representation of a `Thread` handle\n struct Inner {\n     name: Option<String>,\n@@ -557,6 +615,10 @@ impl thread_info::NewThread for Thread {\n     fn new(name: Option<String>) -> Thread { Thread::new(name) }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// JoinHandle and JoinGuard\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Indicates the manner in which a thread exited.\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n@@ -689,6 +751,10 @@ impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Tests\n+////////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(test)]\n mod test {\n     use prelude::v1::*;", "previous_filename": "src/libstd/thread.rs"}, {"sha": "2a8be2ad82cead5ee3f561d204bcd6b00511db9a", "filename": "src/libstd/thread/scoped.rs", "status": "renamed", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd3ab0d8140053475a901ad4e2e80e98955bcb0/src%2Flibstd%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped.rs?ref=6bd3ab0d8140053475a901ad4e2e80e98955bcb0", "patch": "@@ -38,9 +38,7 @@\n //! });\n //! ```\n \n-#![unstable(feature = \"std_misc\",\n-            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n-                      stabilizing its interface\")]\n+#![unstable(feature = \"thread_local_internals\")]\n \n use prelude::v1::*;\n \n@@ -58,7 +56,10 @@ pub mod __impl {\n /// type `T` scoped to a particular lifetime. Keys provides two methods, `set`\n /// and `with`, both of which currently use closures to control the scope of\n /// their contents.\n-pub struct Key<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n+#[unstable(feature = \"scoped_tls\",\n+           reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n+                     stabilizing its interface\")]\n+pub struct ScopedKey<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n \n /// Declare a new scoped thread local storage key.\n ///\n@@ -86,7 +87,7 @@ macro_rules! __scoped_thread_local_inner {\n                            target_os = \"openbsd\",\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n-        static $name: ::std::thread_local::scoped::Key<$t> =\n+        static $name: ::std::thread::ScopedKey<$t> =\n             __scoped_thread_local_inner!($t);\n     );\n     (pub static $name:ident: $t:ty) => (\n@@ -96,19 +97,19 @@ macro_rules! __scoped_thread_local_inner {\n                            target_os = \"openbsd\",\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n-        pub static $name: ::std::thread_local::scoped::Key<$t> =\n+        pub static $name: ::std::thread::ScopedKey<$t> =\n             __scoped_thread_local_inner!($t);\n     );\n     ($t:ty) => ({\n-        use std::thread_local::scoped::Key as __Key;\n+        use std::thread::ScopedKey as __Key;\n \n         #[cfg(not(any(windows,\n                       target_os = \"android\",\n                       target_os = \"ios\",\n                       target_os = \"openbsd\",\n                       target_arch = \"aarch64\")))]\n         const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::__impl::KeyInner {\n+            inner: ::std::thread::__scoped::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: 0 as *mut _ },\n             }\n         };\n@@ -119,8 +120,8 @@ macro_rules! __scoped_thread_local_inner {\n                   target_os = \"openbsd\",\n                   target_arch = \"aarch64\"))]\n         const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::__impl::KeyInner {\n-                inner: ::std::thread_local::scoped::__impl::OS_INIT,\n+            inner: ::std::thread::__scoped::__impl::KeyInner {\n+                inner: ::std::thread::__scoped::__impl::OS_INIT,\n                 marker: ::std::marker::PhantomData::<::std::cell::Cell<$t>>,\n             }\n         };\n@@ -129,7 +130,10 @@ macro_rules! __scoped_thread_local_inner {\n     })\n }\n \n-impl<T> Key<T> {\n+#[unstable(feature = \"scoped_tls\",\n+           reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n+                     stabilizing its interface\")]\n+impl<T> ScopedKey<T> {\n     /// Insert a value into this scoped thread local storage slot for a\n     /// duration of a closure.\n     ///", "previous_filename": "src/libstd/thread_local/scoped.rs"}]}