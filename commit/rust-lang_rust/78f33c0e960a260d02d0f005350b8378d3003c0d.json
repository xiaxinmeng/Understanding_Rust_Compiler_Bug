{"sha": "78f33c0e960a260d02d0f005350b8378d3003c0d", "node_id": "C_kwDOAAsO6NoAKDc4ZjMzYzBlOTYwYTI2MGQwMmQwZjAwNTM1MGI4Mzc4ZDMwMDNjMGQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-10-10T12:25:14Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-10-10T12:27:05Z"}, "message": "Expand unmatched mbe fragments to reasonable default token trees\n\nCurrently we expand unmatched fragments by not replacing them at all,\nleaving us with `$ident`. This trips up the parser or subsequent macro\ncalls. Instead it makes more sense to replace these with some reasonable\ndefault depending on the fragment kind which should make more recursive\nmacro calls work better for completions.", "tree": {"sha": "8adc8b8b28f8af02d42e14cf059e1596dade9752", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8adc8b8b28f8af02d42e14cf059e1596dade9752"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78f33c0e960a260d02d0f005350b8378d3003c0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78f33c0e960a260d02d0f005350b8378d3003c0d", "html_url": "https://github.com/rust-lang/rust/commit/78f33c0e960a260d02d0f005350b8378d3003c0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78f33c0e960a260d02d0f005350b8378d3003c0d/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "476d0438749e3a5b2669811f9429da79a6628e8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/476d0438749e3a5b2669811f9429da79a6628e8a", "html_url": "https://github.com/rust-lang/rust/commit/476d0438749e3a5b2669811f9429da79a6628e8a"}], "stats": {"total": 191, "additions": 146, "deletions": 45}, "files": [{"sha": "9c92bae6a1962d593219c3d869bb0c454967ec78", "filename": "crates/mbe/src/benchmark.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=78f33c0e960a260d02d0f005350b8378d3003c0d", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n use test_utils::{bench, bench_fixture, skip_slow_tests};\n \n use crate::{\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{MetaVarKind, Op, RepeatKind, Separator},\n     syntax_node_to_token_tree, DeclarativeMacro,\n };\n \n@@ -111,35 +111,35 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n \n     fn collect_from_op(op: &Op, parent: &mut tt::Subtree, seed: &mut usize) {\n         return match op {\n-            Op::Var { kind, .. } => match kind.as_ref().map(|it| it.as_str()) {\n-                Some(\"ident\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"ty\") => parent.token_trees.push(make_ident(\"Foo\")),\n-                Some(\"tt\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"vis\") => parent.token_trees.push(make_ident(\"pub\")),\n-                Some(\"pat\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"path\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"literal\") => parent.token_trees.push(make_literal(\"1\")),\n-                Some(\"expr\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"lifetime\") => {\n+            Op::Var { kind, .. } => match kind.as_ref() {\n+                Some(MetaVarKind::Ident) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Ty) => parent.token_trees.push(make_ident(\"Foo\")),\n+                Some(MetaVarKind::Tt) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Vis) => parent.token_trees.push(make_ident(\"pub\")),\n+                Some(MetaVarKind::Pat) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Path) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Literal) => parent.token_trees.push(make_literal(\"1\")),\n+                Some(MetaVarKind::Expr) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Lifetime) => {\n                     parent.token_trees.push(make_punct('\\''));\n                     parent.token_trees.push(make_ident(\"a\"));\n                 }\n-                Some(\"block\") => {\n+                Some(MetaVarKind::Block) => {\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Brace, None))\n                 }\n-                Some(\"item\") => {\n+                Some(MetaVarKind::Item) => {\n                     parent.token_trees.push(make_ident(\"fn\"));\n                     parent.token_trees.push(make_ident(\"foo\"));\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Parenthesis, None));\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Brace, None));\n                 }\n-                Some(\"meta\") => {\n+                Some(MetaVarKind::Meta) => {\n                     parent.token_trees.push(make_ident(\"foo\"));\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Parenthesis, None));\n                 }\n \n                 None => (),\n-                Some(kind) => panic!(\"Unhandled kind {}\", kind),\n+                Some(kind) => panic!(\"Unhandled kind {:?}\", kind),\n             },\n             Op::Leaf(leaf) => parent.token_trees.push(leaf.clone().into()),\n             Op::Repeat { tokens, kind, separator } => {"}, {"sha": "100ec6bfb93ac17e3cf0006c8c65ed78c5e7b646", "filename": "crates/mbe/src/expander.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander.rs?ref=78f33c0e960a260d02d0f005350b8378d3003c0d", "patch": "@@ -8,7 +8,7 @@ mod transcriber;\n use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n-use crate::{ExpandError, ExpandResult};\n+use crate::{parser::MetaVarKind, ExpandError, ExpandResult};\n \n pub(crate) fn expand_rules(\n     rules: &[crate::Rule],\n@@ -104,6 +104,7 @@ enum Binding {\n     Fragment(Fragment),\n     Nested(Vec<Binding>),\n     Empty,\n+    Missing(MetaVarKind),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "3f656df25f7d4e04398ed1df21bc046dc0c35d2c", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=78f33c0e960a260d02d0f005350b8378d3003c0d", "patch": "@@ -66,7 +66,7 @@ use syntax::SmolStr;\n \n use crate::{\n     expander::{Binding, Bindings, ExpandResult, Fragment},\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{MetaVarKind, Op, RepeatKind, Separator},\n     tt_iter::TtIter,\n     ExpandError, MetaTemplate,\n };\n@@ -119,6 +119,7 @@ pub(super) fn match_(pattern: &MetaTemplate, input: &tt::Subtree) -> Match {\n             .map(|it| match it {\n                 Binding::Fragment(_) => 1,\n                 Binding::Empty => 1,\n+                Binding::Missing(_) => 1,\n                 Binding::Nested(it) => count(it.iter()),\n             })\n             .sum()\n@@ -130,6 +131,7 @@ enum BindingKind {\n     Empty(SmolStr),\n     Optional(SmolStr),\n     Fragment(SmolStr, Fragment),\n+    Missing(SmolStr, MetaVarKind),\n     Nested(usize, usize),\n }\n \n@@ -190,6 +192,10 @@ impl BindingsBuilder {\n             .push(LinkNode::Node(Rc::new(BindingKind::Fragment(var.clone(), fragment))));\n     }\n \n+    fn push_missing(&mut self, idx: &mut BindingsIdx, var: &SmolStr, kind: MetaVarKind) {\n+        self.nodes[idx.0].push(LinkNode::Node(Rc::new(BindingKind::Missing(var.clone(), kind))));\n+    }\n+\n     fn push_nested(&mut self, parent: &mut BindingsIdx, child: &BindingsIdx) {\n         let BindingsIdx(idx, nidx) = self.copy(child);\n         self.nodes[parent.0].push(LinkNode::Node(Rc::new(BindingKind::Nested(idx, nidx))));\n@@ -222,6 +228,9 @@ impl BindingsBuilder {\n                 BindingKind::Fragment(name, fragment) => {\n                     bindings.inner.insert(name.clone(), Binding::Fragment(fragment.clone()));\n                 }\n+                BindingKind::Missing(name, kind) => {\n+                    bindings.inner.insert(name.clone(), Binding::Missing(*kind));\n+                }\n                 BindingKind::Nested(idx, nested_idx) => {\n                     let mut nested_nodes = Vec::new();\n                     self.collect_nested(*idx, *nested_idx, &mut nested_nodes);\n@@ -458,9 +467,9 @@ fn match_loop_inner<'t>(\n                 }\n             }\n             OpDelimited::Op(Op::Var { kind, name, .. }) => {\n-                if let Some(kind) = kind {\n+                if let &Some(kind) = kind {\n                     let mut fork = src.clone();\n-                    let match_res = match_meta_var(kind.as_str(), &mut fork);\n+                    let match_res = match_meta_var(kind, &mut fork);\n                     match match_res.err {\n                         None => {\n                             // Some meta variables are optional (e.g. vis)\n@@ -475,8 +484,15 @@ fn match_loop_inner<'t>(\n                         }\n                         Some(err) => {\n                             res.add_err(err);\n-                            if let Some(fragment) = match_res.value {\n-                                bindings_builder.push_fragment(&mut item.bindings, name, fragment);\n+                            match match_res.value {\n+                                Some(fragment) => bindings_builder.push_fragment(\n+                                    &mut item.bindings,\n+                                    name,\n+                                    fragment,\n+                                ),\n+                                None => {\n+                                    bindings_builder.push_missing(&mut item.bindings, name, kind)\n+                                }\n                             }\n                             item.is_error = true;\n                             error_items.push(item);\n@@ -668,20 +684,20 @@ fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter<'_>) -> Result<(), ExpandError> {\n     }\n }\n \n-fn match_meta_var(kind: &str, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n+fn match_meta_var(kind: MetaVarKind, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n-        \"path\" => parser::PrefixEntryPoint::Path,\n-        \"ty\" => parser::PrefixEntryPoint::Ty,\n+        MetaVarKind::Path => parser::PrefixEntryPoint::Path,\n+        MetaVarKind::Ty => parser::PrefixEntryPoint::Ty,\n         // FIXME: These two should actually behave differently depending on the edition.\n         //\n         // https://doc.rust-lang.org/edition-guide/rust-2021/or-patterns-macro-rules.html\n-        \"pat\" | \"pat_param\" => parser::PrefixEntryPoint::Pat,\n-        \"stmt\" => parser::PrefixEntryPoint::Stmt,\n-        \"block\" => parser::PrefixEntryPoint::Block,\n-        \"meta\" => parser::PrefixEntryPoint::MetaItem,\n-        \"item\" => parser::PrefixEntryPoint::Item,\n-        \"vis\" => parser::PrefixEntryPoint::Vis,\n-        \"expr\" => {\n+        MetaVarKind::Pat | MetaVarKind::PatParam => parser::PrefixEntryPoint::Pat,\n+        MetaVarKind::Stmt => parser::PrefixEntryPoint::Stmt,\n+        MetaVarKind::Block => parser::PrefixEntryPoint::Block,\n+        MetaVarKind::Meta => parser::PrefixEntryPoint::MetaItem,\n+        MetaVarKind::Item => parser::PrefixEntryPoint::Item,\n+        MetaVarKind::Vis => parser::PrefixEntryPoint::Vis,\n+        MetaVarKind::Expr => {\n             // `expr` should not match underscores.\n             // HACK: Macro expansion should not be done using \"rollback and try another alternative\".\n             // rustc [explicitly checks the next token][0].\n@@ -698,17 +714,17 @@ fn match_meta_var(kind: &str, input: &mut TtIter<'_>) -> ExpandResult<Option<Fra\n         }\n         _ => {\n             let tt_result = match kind {\n-                \"ident\" => input\n+                MetaVarKind::Ident => input\n                     .expect_ident()\n                     .map(|ident| tt::Leaf::from(ident.clone()).into())\n                     .map_err(|()| ExpandError::binding_error(\"expected ident\")),\n-                \"tt\" => input\n+                MetaVarKind::Tt => input\n                     .expect_tt()\n                     .map_err(|()| ExpandError::binding_error(\"expected token tree\")),\n-                \"lifetime\" => input\n+                MetaVarKind::Lifetime => input\n                     .expect_lifetime()\n                     .map_err(|()| ExpandError::binding_error(\"expected lifetime\")),\n-                \"literal\" => {\n+                MetaVarKind::Literal => {\n                     let neg = input.eat_char('-');\n                     input\n                         .expect_literal()"}, {"sha": "cbb59ab8e67b5f5278a35c3f5c6c9a7368ad5e14", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=78f33c0e960a260d02d0f005350b8378d3003c0d", "patch": "@@ -6,7 +6,7 @@ use tt::{Delimiter, Subtree};\n \n use crate::{\n     expander::{Binding, Bindings, Fragment},\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{MetaVarKind, Op, RepeatKind, Separator},\n     ExpandError, ExpandResult, MetaTemplate,\n };\n \n@@ -15,7 +15,7 @@ impl Bindings {\n         self.inner.contains_key(name)\n     }\n \n-    fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<&Fragment, ExpandError> {\n+    fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<Fragment, ExpandError> {\n         macro_rules! binding_err {\n             ($($arg:tt)*) => { ExpandError::binding_error(format!($($arg)*)) };\n         }\n@@ -26,6 +26,7 @@ impl Bindings {\n             nesting_state.hit = true;\n             b = match b {\n                 Binding::Fragment(_) => break,\n+                Binding::Missing(_) => break,\n                 Binding::Nested(bs) => bs.get(nesting_state.idx).ok_or_else(|| {\n                     nesting_state.at_end = true;\n                     binding_err!(\"could not find nested binding `{name}`\")\n@@ -37,7 +38,55 @@ impl Bindings {\n             };\n         }\n         match b {\n-            Binding::Fragment(it) => Ok(it),\n+            Binding::Fragment(it) => Ok(it.clone()),\n+            // emit some reasonable default expansion for missing bindings,\n+            // this gives better recovery than emitting the `$fragment-name` verbatim\n+            Binding::Missing(it) => Ok(match it {\n+                MetaVarKind::Stmt => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n+                        id: tt::TokenId::unspecified(),\n+                        char: ';',\n+                        spacing: tt::Spacing::Alone,\n+                    })))\n+                }\n+                MetaVarKind::Block => Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: Some(tt::Delimiter {\n+                        id: tt::TokenId::unspecified(),\n+                        kind: tt::DelimiterKind::Brace,\n+                    }),\n+                    token_trees: vec![],\n+                })),\n+                // FIXME: Meta and Item should get proper defaults\n+                MetaVarKind::Meta | MetaVarKind::Item | MetaVarKind::Tt | MetaVarKind::Vis => {\n+                    Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n+                        delimiter: None,\n+                        token_trees: vec![],\n+                    }))\n+                }\n+                MetaVarKind::Path\n+                | MetaVarKind::Ty\n+                | MetaVarKind::Pat\n+                | MetaVarKind::PatParam\n+                | MetaVarKind::Expr\n+                | MetaVarKind::Ident => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                        text: SmolStr::new_inline(\"missing\"),\n+                        id: tt::TokenId::unspecified(),\n+                    })))\n+                }\n+                MetaVarKind::Lifetime => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                        text: SmolStr::new_inline(\"'missing\"),\n+                        id: tt::TokenId::unspecified(),\n+                    })))\n+                }\n+                MetaVarKind::Literal => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                        text: SmolStr::new_inline(\"\\\"missing\\\"\"),\n+                        id: tt::TokenId::unspecified(),\n+                    })))\n+                }\n+            }),\n             Binding::Nested(_) => {\n                 Err(binding_err!(\"expected simple binding, found nested binding `{name}`\"))\n             }\n@@ -157,7 +206,7 @@ fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandRe\n     } else {\n         ctx.bindings.get(v, &mut ctx.nesting).map_or_else(\n             |e| ExpandResult { value: Fragment::Tokens(tt::TokenTree::empty()), err: Some(e) },\n-            |b| ExpandResult::ok(b.clone()),\n+            |it| ExpandResult::ok(it),\n         )\n     }\n }"}, {"sha": "c4f0fa20d6de03959f3600fd57bf6e52475c2eee", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=78f33c0e960a260d02d0f005350b8378d3003c0d", "patch": "@@ -21,7 +21,7 @@ mod token_map;\n use std::fmt;\n \n use crate::{\n-    parser::{MetaTemplate, Op},\n+    parser::{MetaTemplate, MetaVarKind, Op},\n     tt_iter::TtIter,\n };\n \n@@ -291,9 +291,9 @@ fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n                 // Checks that no repetition which could match an empty token\n                 // https://github.com/rust-lang/rust/blob/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f/src/librustc_expand/mbe/macro_rules.rs#L558\n                 let lsh_is_empty_seq = separator.is_none() && subtree.iter().all(|child_op| {\n-                    match child_op {\n+                    match *child_op {\n                         // vis is optional\n-                        Op::Var { kind: Some(kind), .. } => kind == \"vis\",\n+                        Op::Var { kind: Some(kind), .. } => kind == MetaVarKind::Vis,\n                         Op::Repeat {\n                             kind: parser::RepeatKind::ZeroOrMore | parser::RepeatKind::ZeroOrOne,\n                             .."}, {"sha": "351c359b73c87ea8352a0bb406f7dbb285360849", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f33c0e960a260d02d0f005350b8378d3003c0d/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=78f33c0e960a260d02d0f005350b8378d3003c0d", "patch": "@@ -50,7 +50,7 @@ impl MetaTemplate {\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n-    Var { name: SmolStr, kind: Option<SmolStr>, id: tt::TokenId },\n+    Var { name: SmolStr, kind: Option<MetaVarKind>, id: tt::TokenId },\n     Ignore { name: SmolStr, id: tt::TokenId },\n     Index { depth: u32 },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n@@ -65,6 +65,24 @@ pub(crate) enum RepeatKind {\n     ZeroOrOne,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum MetaVarKind {\n+    Path,\n+    Ty,\n+    Pat,\n+    PatParam,\n+    Stmt,\n+    Block,\n+    Meta,\n+    Item,\n+    Vis,\n+    Expr,\n+    Ident,\n+    Tt,\n+    Lifetime,\n+    Literal,\n+}\n+\n #[derive(Clone, Debug, Eq)]\n pub(crate) enum Separator {\n     Literal(tt::Literal),\n@@ -179,13 +197,30 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n     Ok(res)\n }\n \n-fn eat_fragment_kind(src: &mut TtIter<'_>, mode: Mode) -> Result<Option<SmolStr>, ParseError> {\n+fn eat_fragment_kind(src: &mut TtIter<'_>, mode: Mode) -> Result<Option<MetaVarKind>, ParseError> {\n     if let Mode::Pattern = mode {\n         src.expect_char(':').map_err(|()| ParseError::unexpected(\"missing fragment specifier\"))?;\n         let ident = src\n             .expect_ident()\n             .map_err(|()| ParseError::unexpected(\"missing fragment specifier\"))?;\n-        return Ok(Some(ident.text.clone()));\n+        let kind = match ident.text.as_str() {\n+            \"path\" => MetaVarKind::Path,\n+            \"ty\" => MetaVarKind::Ty,\n+            \"pat\" => MetaVarKind::Pat,\n+            \"pat_param\" => MetaVarKind::PatParam,\n+            \"stmt\" => MetaVarKind::Stmt,\n+            \"block\" => MetaVarKind::Block,\n+            \"meta\" => MetaVarKind::Meta,\n+            \"item\" => MetaVarKind::Item,\n+            \"vis\" => MetaVarKind::Vis,\n+            \"expr\" => MetaVarKind::Expr,\n+            \"ident\" => MetaVarKind::Ident,\n+            \"tt\" => MetaVarKind::Tt,\n+            \"lifetime\" => MetaVarKind::Lifetime,\n+            \"literal\" => MetaVarKind::Literal,\n+            _ => return Ok(None),\n+        };\n+        return Ok(Some(kind));\n     };\n     Ok(None)\n }"}]}