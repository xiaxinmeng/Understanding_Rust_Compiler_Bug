{"sha": "bf6a46db3129b0bf31dc67f06af2e52ece52701a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNmE0NmRiMzEyOWIwYmYzMWRjNjdmMDZhZjJlNTJlY2U1MjcwMWE=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-28T19:21:26Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-28T19:22:07Z"}, "message": "Make fields in `MemoryBlock` public", "tree": {"sha": "202ce2e37985e512df1e0b005a79010aa0a66a58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/202ce2e37985e512df1e0b005a79010aa0a66a58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf6a46db3129b0bf31dc67f06af2e52ece52701a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf6a46db3129b0bf31dc67f06af2e52ece52701a", "html_url": "https://github.com/rust-lang/rust/commit/bf6a46db3129b0bf31dc67f06af2e52ece52701a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf6a46db3129b0bf31dc67f06af2e52ece52701a/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db15fe6b383741ae1cc13cfb62fc1c18f8ff5241", "url": "https://api.github.com/repos/rust-lang/rust/commits/db15fe6b383741ae1cc13cfb62fc1c18f8ff5241", "html_url": "https://github.com/rust-lang/rust/commit/db15fe6b383741ae1cc13cfb62fc1c18f8ff5241"}], "stats": {"total": 179, "additions": 79, "deletions": 100}, "files": [{"sha": "67927629ed3b6ac49415c02fc248edf7b74bccc3", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -169,14 +169,14 @@ unsafe impl AllocRef for Global {\n         unsafe {\n             let size = layout.size();\n             if size == 0 {\n-                Ok(MemoryBlock::new(layout.dangling(), 0))\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             } else {\n                 let raw_ptr = match init {\n                     AllocInit::Uninitialized => alloc(layout),\n                     AllocInit::Zeroed => alloc_zeroed(layout),\n                 };\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock::new(ptr, size))\n+                Ok(MemoryBlock { ptr, size })\n             }\n         }\n     }\n@@ -197,14 +197,14 @@ unsafe impl AllocRef for Global {\n         placement: ReallocPlacement,\n         init: AllocInit,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let old_size = layout.size();\n+        let size = layout.size();\n         debug_assert!(\n-            new_size >= old_size,\n+            new_size >= size,\n             \"`new_size` must be greater than or equal to `memory.size()`\"\n         );\n \n-        if old_size == new_size {\n-            return Ok(MemoryBlock::new(ptr, old_size));\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n         }\n \n         match placement {\n@@ -215,10 +215,11 @@ unsafe impl AllocRef for Global {\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size > old_size` or something similar.\n-                intrinsics::assume(new_size > old_size);\n+                intrinsics::assume(new_size > size);\n                 let ptr = realloc(ptr.as_ptr(), layout, new_size);\n-                let mut memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_size);\n-                memory.init_offset(init, old_size);\n+                let mut memory =\n+                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n+                memory.init_offset(init, size);\n                 Ok(memory)\n             }\n         }\n@@ -232,27 +233,27 @@ unsafe impl AllocRef for Global {\n         new_size: usize,\n         placement: ReallocPlacement,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let old_size = layout.size();\n+        let size = layout.size();\n         debug_assert!(\n-            new_size <= old_size,\n+            new_size <= size,\n             \"`new_size` must be smaller than or equal to `memory.size()`\"\n         );\n \n-        if old_size == new_size {\n-            return Ok(MemoryBlock::new(ptr, old_size));\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n         }\n \n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n                 self.dealloc(ptr, layout);\n-                Ok(MemoryBlock::new(layout.dangling(), 0))\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size < old_size` or something similar.\n-                intrinsics::assume(new_size < old_size);\n+                intrinsics::assume(new_size < size);\n                 let ptr = realloc(ptr.as_ptr(), layout, new_size);\n-                Ok(MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_size))\n+                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n             }\n         }\n     }\n@@ -266,7 +267,7 @@ unsafe impl AllocRef for Global {\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     let layout = Layout::from_size_align_unchecked(size, align);\n     match Global.alloc(layout, AllocInit::Uninitialized) {\n-        Ok(memory) => memory.ptr().as_ptr(),\n+        Ok(memory) => memory.ptr.as_ptr(),\n         Err(_) => handle_alloc_error(layout),\n     }\n }"}, {"sha": "1ad40eca93b69e8c56c9648b3c44a95c9ac7aa9a", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -12,13 +12,13 @@ fn allocate_zeroed() {\n             .alloc(layout.clone(), AllocInit::Zeroed)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n-        let mut i = memory.ptr().cast::<u8>().as_ptr();\n+        let mut i = memory.ptr.cast::<u8>().as_ptr();\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n             i = i.offset(1);\n         }\n-        Global.dealloc(memory.ptr(), layout);\n+        Global.dealloc(memory.ptr, layout);\n     }\n }\n "}, {"sha": "5406956a5288657a8fd70598d05208d364bd1c78", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -198,7 +198,7 @@ impl<T> Box<T> {\n         let ptr = Global\n             .alloc(layout, AllocInit::Uninitialized)\n             .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .ptr()\n+            .ptr\n             .cast();\n         unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n@@ -227,7 +227,7 @@ impl<T> Box<T> {\n         let ptr = Global\n             .alloc(layout, AllocInit::Zeroed)\n             .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .ptr()\n+            .ptr\n             .cast();\n         unsafe { Box::from_raw(ptr.as_ptr()) }\n     }"}, {"sha": "590e82357fb7108b6fa9ce85048030072ea4d792", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -152,8 +152,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n \n             let memory = alloc.alloc(layout, init).unwrap_or_else(|_| handle_alloc_error(layout));\n             Self {\n-                ptr: memory.ptr().cast().into(),\n-                cap: Self::capacity_from_bytes(memory.size()),\n+                ptr: memory.ptr.cast().into(),\n+                cap: Self::capacity_from_bytes(memory.size),\n                 alloc,\n             }\n         }\n@@ -470,8 +470,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n \n     fn set_memory(&mut self, memory: MemoryBlock) {\n-        self.ptr = memory.ptr().cast().into();\n-        self.cap = Self::capacity_from_bytes(memory.size());\n+        self.ptr = memory.ptr.cast().into();\n+        self.cap = Self::capacity_from_bytes(memory.size);\n     }\n \n     /// Single method to handle all possibilities of growing the buffer."}, {"sha": "6a78a7398a692814155c9c9513f572cd98b73905", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -941,7 +941,7 @@ impl<T: ?Sized> Rc<T> {\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n-        let inner = mem_to_rcbox(mem.ptr().as_ptr());\n+        let inner = mem_to_rcbox(mem.ptr.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));"}, {"sha": "111a7651b5e77c235f4cda5adfd4867a96d8a1f8", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -819,7 +819,7 @@ impl<T: ?Sized> Arc<T> {\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n-        let inner = mem_to_arcinner(mem.ptr().as_ptr());\n+        let inner = mem_to_arcinner(mem.ptr.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));"}, {"sha": "62f062b83d75d77c5e34dfc62b2b347501716236", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -26,7 +26,7 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n                                 AllocInit::Uninitialized,\n                             )\n                             .unwrap()\n-                            .ptr()\n+                            .ptr\n                     })\n                     .collect();\n                 for &ptr in &pointers {"}, {"sha": "f2f12a98fa61b3ebb33304e701f9fe850dd010f7", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 20, "deletions": 43, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -42,35 +42,14 @@ pub enum AllocInit {\n }\n \n /// Represents a block of allocated memory returned by an allocator.\n-#[derive(Debug)]\n+#[derive(Debug, Copy, Clone)]\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub struct MemoryBlock {\n-    ptr: NonNull<u8>,\n-    size: usize,\n+    pub ptr: NonNull<u8>,\n+    pub size: usize,\n }\n \n impl MemoryBlock {\n-    /// Creates a new `MemoryBlock` from the specified `ptr` and `size`.\n-    #[inline]\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub const fn new(ptr: NonNull<u8>, size: usize) -> Self {\n-        Self { ptr, size }\n-    }\n-\n-    /// Acquires the underlying `NonNull<u8>` pointer.\n-    #[inline]\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub const fn ptr(&self) -> NonNull<u8> {\n-        self.ptr\n-    }\n-\n-    /// Returns the size of the memory block.\n-    #[inline]\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub const fn size(&self) -> usize {\n-        self.size\n-    }\n-\n     /// Initialize the memory block like specified by `init`.\n     ///\n     /// This behaves like calling [`MemoryBlock::initialize_offset(ptr, layout, 0)`][off].\n@@ -98,12 +77,10 @@ impl MemoryBlock {\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub unsafe fn init_offset(&mut self, init: AllocInit, offset: usize) {\n-        debug_assert!(offset <= self.size(), \"`offset` must be smaller than or equal to `size()`\");\n+        debug_assert!(offset <= self.size, \"`offset` must be smaller than or equal to `size()`\");\n         match init {\n             AllocInit::Uninitialized => (),\n-            AllocInit::Zeroed => {\n-                self.ptr().as_ptr().add(offset).write_bytes(0, self.size() - offset)\n-            }\n+            AllocInit::Zeroed => self.ptr.as_ptr().add(offset).write_bytes(0, self.size - offset),\n         }\n     }\n }\n@@ -246,9 +223,9 @@ pub unsafe trait AllocRef {\n     ///\n     /// * `ptr` must be [*currently allocated*] via this allocator,\n     /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n-    // We can't require that `new_size` is strictly greater than `memory.size()` because of ZSTs.\n+    // We can't require that `new_size` is strictly greater than `memory.size` because of ZSTs.\n     // An alternative would be\n-    // * `new_size must be strictly greater than `memory.size()` or both are zero\n+    // * `new_size must be strictly greater than `memory.size` or both are zero\n     /// * `new_size` must be greater than or equal to `layout.size()`\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n     ///   (i.e., the rounded value must be less than `usize::MAX`).\n@@ -280,19 +257,19 @@ pub unsafe trait AllocRef {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove => {\n-                let old_size = layout.size();\n+                let size = layout.size();\n                 debug_assert!(\n-                    new_size >= old_size,\n+                    new_size >= size,\n                     \"`new_size` must be greater than or equal to `layout.size()`\"\n                 );\n \n-                if new_size == old_size {\n-                    return Ok(MemoryBlock::new(ptr, old_size));\n+                if new_size == size {\n+                    return Ok(MemoryBlock { ptr, size });\n                 }\n \n                 let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n                 let new_memory = self.alloc(new_layout, init)?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr().as_ptr(), old_size);\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n                 self.dealloc(ptr, layout);\n                 Ok(new_memory)\n             }\n@@ -324,10 +301,10 @@ pub unsafe trait AllocRef {\n     ///\n     /// * `ptr` must be [*currently allocated*] via this allocator,\n     /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n-    // We can't require that `new_size` is strictly smaller than `memory.size()` because of ZSTs.\n+    // We can't require that `new_size` is strictly smaller than `memory.size` because of ZSTs.\n     // An alternative would be\n-    // * `new_size must be strictly smaller than `memory.size()` or both are zero\n-    /// * `new_size` must be smaller than or equal to `memory.size()`\n+    // * `new_size must be strictly smaller than `memory.size` or both are zero\n+    /// * `new_size` must be smaller than or equal to `layout.size()`\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n@@ -355,19 +332,19 @@ pub unsafe trait AllocRef {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove => {\n-                let old_size = layout.size();\n+                let size = layout.size();\n                 debug_assert!(\n-                    new_size <= old_size,\n+                    new_size <= size,\n                     \"`new_size` must be smaller than or equal to `layout.size()`\"\n                 );\n \n-                if new_size == old_size {\n-                    return Ok(MemoryBlock::new(ptr, old_size));\n+                if new_size == size {\n+                    return Ok(MemoryBlock { ptr, size });\n                 }\n \n                 let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n                 let new_memory = self.alloc(new_layout, AllocInit::Uninitialized)?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr().as_ptr(), new_size);\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n                 self.dealloc(ptr, layout);\n                 Ok(new_memory)\n             }"}, {"sha": "843c46775af0ce5f1ab6f030f9f8a05a58ee6e58", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -143,14 +143,14 @@ unsafe impl AllocRef for System {\n         unsafe {\n             let size = layout.size();\n             if size == 0 {\n-                Ok(MemoryBlock::new(layout.dangling(), 0))\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             } else {\n                 let raw_ptr = match init {\n                     AllocInit::Uninitialized => GlobalAlloc::alloc(self, layout),\n                     AllocInit::Zeroed => GlobalAlloc::alloc_zeroed(self, layout),\n                 };\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock::new(ptr, size))\n+                Ok(MemoryBlock { ptr, size })\n             }\n         }\n     }\n@@ -171,14 +171,14 @@ unsafe impl AllocRef for System {\n         placement: ReallocPlacement,\n         init: AllocInit,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let old_size = layout.size();\n+        let size = layout.size();\n         debug_assert!(\n-            new_size >= old_size,\n+            new_size >= size,\n             \"`new_size` must be greater than or equal to `memory.size()`\"\n         );\n \n-        if old_size == new_size {\n-            return Ok(MemoryBlock::new(ptr, old_size));\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n         }\n \n         match placement {\n@@ -189,10 +189,11 @@ unsafe impl AllocRef for System {\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size > old_size` or something similar.\n-                intrinsics::assume(new_size > old_size);\n+                intrinsics::assume(new_size > size);\n                 let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                let mut memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_size);\n-                memory.init_offset(init, old_size);\n+                let mut memory =\n+                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n+                memory.init_offset(init, size);\n                 Ok(memory)\n             }\n         }\n@@ -206,27 +207,27 @@ unsafe impl AllocRef for System {\n         new_size: usize,\n         placement: ReallocPlacement,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let old_size = layout.size();\n+        let size = layout.size();\n         debug_assert!(\n-            new_size <= old_size,\n+            new_size <= size,\n             \"`new_size` must be smaller than or equal to `memory.size()`\"\n         );\n \n-        if old_size == new_size {\n-            return Ok(MemoryBlock::new(ptr, old_size));\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n         }\n \n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n                 self.dealloc(ptr, layout);\n-                Ok(MemoryBlock::new(layout.dangling(), 0))\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size < old_size` or something similar.\n-                intrinsics::assume(new_size < old_size);\n+                intrinsics::assume(new_size < size);\n                 let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                Ok(MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_size))\n+                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n             }\n         }\n     }"}, {"sha": "184e4706a4c867077bf86a53495a1a4e54594095", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -38,9 +38,9 @@ fn main() {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n         let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n-        helper::work_with(&memory.ptr());\n+        helper::work_with(&memory.ptr);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory.ptr(), layout);\n+        Global.dealloc(memory.ptr, layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 2);\n \n         let s = String::with_capacity(10);\n@@ -51,8 +51,8 @@ fn main() {\n \n         let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n-        helper::work_with(&memory.ptr());\n-        System.dealloc(memory.ptr(), layout);\n+        helper::work_with(&memory.ptr);\n+        System.dealloc(memory.ptr, layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n     }\n }"}, {"sha": "7de1ab7a5531508111999f8a662c2b11f5d5a191", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -21,15 +21,15 @@ fn main() {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n         let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n-        helper::work_with(&memory.ptr());\n+        helper::work_with(&memory.ptr);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory.ptr(), layout);\n+        Global.dealloc(memory.ptr, layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n         let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n-        helper::work_with(&memory.ptr());\n-        System.dealloc(memory.ptr(), layout);\n+        helper::work_with(&memory.ptr);\n+        System.dealloc(memory.ptr, layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n     }\n }"}, {"sha": "0687a9ce454ccd84362491a6cac5e2e033afaa71", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -46,10 +46,10 @@ unsafe fn test_triangle() -> bool {\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         if PRINT {\n-            println!(\"allocate({:?}) = {:?}\", layout, memory.ptr());\n+            println!(\"allocate({:?}) = {:?}\", layout, memory.ptr);\n         }\n \n-        memory.ptr().cast().as_ptr()\n+        memory.ptr.cast().as_ptr()\n     }\n \n     unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n@@ -82,9 +82,9 @@ unsafe fn test_triangle() -> bool {\n         });\n \n         if PRINT {\n-            println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\", ptr, old, new, memory.ptr());\n+            println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\", ptr, old, new, memory.ptr);\n         }\n-        memory.ptr().cast().as_ptr()\n+        memory.ptr.cast().as_ptr()\n     }\n \n     fn idx_to_size(i: usize) -> usize {"}, {"sha": "380310190be0124a9f229d46b134eb8996d9c9a4", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6a46db3129b0bf31dc67f06af2e52ece52701a/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=bf6a46db3129b0bf31dc67f06af2e52ece52701a", "patch": "@@ -28,7 +28,7 @@ fn alloc(_bcx: &arena) -> &Bcx<'_> {\n         let memory = Global\n             .alloc(layout, AllocInit::Uninitialized)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n-        &*(memory.ptr().as_ptr() as *const _)\n+        &*(memory.ptr.as_ptr() as *const _)\n     }\n }\n "}]}