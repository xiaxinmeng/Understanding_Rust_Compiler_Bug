{"sha": "144afa55a6031bb633c515c1cd20b110c123c5e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NGFmYTU1YTYwMzFiYjYzM2M1MTVjMWNkMjBiMTEwYzEyM2M1ZTU=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-14T20:56:19Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-14T20:56:19Z"}, "message": "Switch introduce_named_lifetime assist to use mutable syntax tree", "tree": {"sha": "4c9be7aea277b314a0a028a7045efe7c969314c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c9be7aea277b314a0a028a7045efe7c969314c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/144afa55a6031bb633c515c1cd20b110c123c5e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/144afa55a6031bb633c515c1cd20b110c123c5e5", "html_url": "https://github.com/rust-lang/rust/commit/144afa55a6031bb633c515c1cd20b110c123c5e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/144afa55a6031bb633c515c1cd20b110c123c5e5/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e80e943824855c5913f20a776b3a5fa959e942", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e80e943824855c5913f20a776b3a5fa959e942", "html_url": "https://github.com/rust-lang/rust/commit/27e80e943824855c5913f20a776b3a5fa959e942"}], "stats": {"total": 183, "additions": 147, "deletions": 36}, "files": [{"sha": "9f4f71d6cc5521e44060c42ad134567c1b18c15e", "filename": "crates/ide_assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/144afa55a6031bb633c515c1cd20b110c123c5e5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144afa55a6031bb633c515c1cd20b110c123c5e5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=144afa55a6031bb633c515c1cd20b110c123c5e5", "patch": "@@ -1,7 +1,8 @@\n use rustc_hash::FxHashSet;\n use syntax::{\n-    ast::{self, GenericParamsOwner, NameOwner},\n-    AstNode, TextRange, TextSize,\n+    ast::{self, edit_in_place::GenericParamsOwnerEdit, make, GenericParamsOwner},\n+    ted::{self, Position},\n+    AstNode, TextRange,\n };\n \n use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n@@ -37,10 +38,12 @@ static ASSIST_LABEL: &str = \"Introduce named lifetime\";\n pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let lifetime =\n         ctx.find_node_at_offset::<ast::Lifetime>().filter(|lifetime| lifetime.text() == \"'_\")?;\n+    let lifetime_loc = lifetime.lifetime_ident_token()?.text_range();\n+\n     if let Some(fn_def) = lifetime.syntax().ancestors().find_map(ast::Fn::cast) {\n-        generate_fn_def_assist(acc, &fn_def, lifetime.lifetime_ident_token()?.text_range())\n+        generate_fn_def_assist(acc, fn_def, lifetime_loc, lifetime)\n     } else if let Some(impl_def) = lifetime.syntax().ancestors().find_map(ast::Impl::cast) {\n-        generate_impl_def_assist(acc, &impl_def, lifetime.lifetime_ident_token()?.text_range())\n+        generate_impl_def_assist(acc, impl_def, lifetime_loc, lifetime)\n     } else {\n         None\n     }\n@@ -49,26 +52,26 @@ pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -\n /// Generate the assist for the fn def case\n fn generate_fn_def_assist(\n     acc: &mut Assists,\n-    fn_def: &ast::Fn,\n+    fn_def: ast::Fn,\n     lifetime_loc: TextRange,\n+    lifetime: ast::Lifetime,\n ) -> Option<()> {\n     let param_list: ast::ParamList = fn_def.param_list()?;\n-    let new_lifetime_param = generate_unique_lifetime_param_name(&fn_def.generic_param_list())?;\n-    let end_of_fn_ident = fn_def.name()?.ident_token()?.text_range().end();\n+    let new_lifetime_param = generate_unique_lifetime_param_name(fn_def.generic_param_list())?;\n     let self_param =\n         // use the self if it's a reference and has no explicit lifetime\n         param_list.self_param().filter(|p| p.lifetime().is_none() && p.amp_token().is_some());\n     // compute the location which implicitly has the same lifetime as the anonymous lifetime\n     let loc_needing_lifetime = if let Some(self_param) = self_param {\n         // if we have a self reference, use that\n-        Some(self_param.name()?.syntax().text_range().start())\n+        Some(NeedsLifetime::SelfParam(self_param))\n     } else {\n         // otherwise, if there's a single reference parameter without a named liftime, use that\n         let fn_params_without_lifetime: Vec<_> = param_list\n             .params()\n             .filter_map(|param| match param.ty() {\n                 Some(ast::Type::RefType(ascribed_type)) if ascribed_type.lifetime().is_none() => {\n-                    Some(ascribed_type.amp_token()?.text_range().end())\n+                    Some(NeedsLifetime::RefType(ascribed_type))\n                 }\n                 _ => None,\n             })\n@@ -81,30 +84,46 @@ fn generate_fn_def_assist(\n         }\n     };\n     acc.add(AssistId(ASSIST_NAME, AssistKind::Refactor), ASSIST_LABEL, lifetime_loc, |builder| {\n-        add_lifetime_param(fn_def, builder, end_of_fn_ident, new_lifetime_param);\n-        builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n-        loc_needing_lifetime.map(|loc| builder.insert(loc, format!(\"'{} \", new_lifetime_param)));\n+        let fn_def = builder.make_ast_mut(fn_def);\n+        let lifetime = builder.make_ast_mut(lifetime);\n+        let loc_needing_lifetime =\n+            loc_needing_lifetime.and_then(|it| it.make_mut(builder).to_position());\n+\n+        add_lifetime_param(fn_def.get_or_create_generic_param_list(), new_lifetime_param);\n+        ted::replace(\n+            lifetime.syntax(),\n+            make_ast_lifetime(new_lifetime_param).clone_for_update().syntax(),\n+        );\n+        loc_needing_lifetime.map(|position| {\n+            ted::insert(position, make_ast_lifetime(new_lifetime_param).clone_for_update().syntax())\n+        });\n     })\n }\n \n /// Generate the assist for the impl def case\n fn generate_impl_def_assist(\n     acc: &mut Assists,\n-    impl_def: &ast::Impl,\n+    impl_def: ast::Impl,\n     lifetime_loc: TextRange,\n+    lifetime: ast::Lifetime,\n ) -> Option<()> {\n-    let new_lifetime_param = generate_unique_lifetime_param_name(&impl_def.generic_param_list())?;\n-    let end_of_impl_kw = impl_def.impl_token()?.text_range().end();\n+    let new_lifetime_param = generate_unique_lifetime_param_name(impl_def.generic_param_list())?;\n     acc.add(AssistId(ASSIST_NAME, AssistKind::Refactor), ASSIST_LABEL, lifetime_loc, |builder| {\n-        add_lifetime_param(impl_def, builder, end_of_impl_kw, new_lifetime_param);\n-        builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n+        let impl_def = builder.make_ast_mut(impl_def);\n+        let lifetime = builder.make_ast_mut(lifetime);\n+\n+        add_lifetime_param(impl_def.get_or_create_generic_param_list(), new_lifetime_param);\n+        ted::replace(\n+            lifetime.syntax(),\n+            make_ast_lifetime(new_lifetime_param).clone_for_update().syntax(),\n+        );\n     })\n }\n \n /// Given a type parameter list, generate a unique lifetime parameter name\n /// which is not in the list\n fn generate_unique_lifetime_param_name(\n-    existing_type_param_list: &Option<ast::GenericParamList>,\n+    existing_type_param_list: Option<ast::GenericParamList>,\n ) -> Option<char> {\n     match existing_type_param_list {\n         Some(type_params) => {\n@@ -118,25 +137,37 @@ fn generate_unique_lifetime_param_name(\n     }\n }\n \n-/// Add the lifetime param to `builder`. If there are type parameters in `type_params_owner`, add it to the end. Otherwise\n-/// add new type params brackets with the lifetime parameter at `new_type_params_loc`.\n-fn add_lifetime_param<TypeParamsOwner: ast::GenericParamsOwner>(\n-    type_params_owner: &TypeParamsOwner,\n-    builder: &mut AssistBuilder,\n-    new_type_params_loc: TextSize,\n-    new_lifetime_param: char,\n-) {\n-    match type_params_owner.generic_param_list() {\n-        // add the new lifetime parameter to an existing type param list\n-        Some(type_params) => {\n-            builder.insert(\n-                (u32::from(type_params.syntax().text_range().end()) - 1).into(),\n-                format!(\", '{}\", new_lifetime_param),\n-            );\n+fn add_lifetime_param(type_params: ast::GenericParamList, new_lifetime_param: char) {\n+    let generic_param =\n+        make::generic_param(format!(\"'{}\", new_lifetime_param), None).clone_for_update();\n+    type_params.add_generic_param(generic_param);\n+}\n+\n+fn make_ast_lifetime(new_lifetime_param: char) -> ast::Lifetime {\n+    make::generic_param(format!(\"'{}\", new_lifetime_param), None)\n+        .syntax()\n+        .descendants()\n+        .find_map(ast::Lifetime::cast)\n+        .unwrap()\n+}\n+\n+enum NeedsLifetime {\n+    SelfParam(ast::SelfParam),\n+    RefType(ast::RefType),\n+}\n+\n+impl NeedsLifetime {\n+    fn make_mut(self, builder: &mut AssistBuilder) -> Self {\n+        match self {\n+            Self::SelfParam(it) => Self::SelfParam(builder.make_ast_mut(it)),\n+            Self::RefType(it) => Self::RefType(builder.make_ast_mut(it)),\n         }\n-        // create a new type param list containing only the new lifetime parameter\n-        None => {\n-            builder.insert(new_type_params_loc, format!(\"<'{}>\", new_lifetime_param));\n+    }\n+\n+    fn to_position(self) -> Option<Position> {\n+        match self {\n+            Self::SelfParam(it) => Some(Position::after(it.amp_token()?)),\n+            Self::RefType(it) => Some(Position::after(it.amp_token()?)),\n         }\n     }\n }\n@@ -312,4 +343,13 @@ mod tests {\n             r#\"fn my_fun<'other, 'a>(self, f: &'a Foo, b: &'other Bar) -> X<'a>\"#,\n         );\n     }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_self_ref_mut() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"fn foo(&mut self) -> &'_$0 ()\"#,\n+            r#\"fn foo<'a>(&'a mut self) -> &'a ()\"#,\n+        );\n+    }\n }"}, {"sha": "27350e2b97910fc7e6f46fb09446ca3f2005b080", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/144afa55a6031bb633c515c1cd20b110c123c5e5/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144afa55a6031bb633c515c1cd20b110c123c5e5/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=144afa55a6031bb633c515c1cd20b110c123c5e5", "patch": "@@ -14,10 +14,21 @@ use crate::{\n use super::NameOwner;\n \n pub trait GenericParamsOwnerEdit: ast::GenericParamsOwner + AstNodeEdit {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList;\n     fn get_or_create_where_clause(&self) -> ast::WhereClause;\n }\n \n impl GenericParamsOwnerEdit for ast::Fn {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        match self.generic_param_list() {\n+            Some(it) => it,\n+            None => {\n+                let position = Position::after(self.name().unwrap().syntax);\n+                create_generic_param_list(position)\n+            }\n+        }\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(ty) = self.ret_type() {\n@@ -34,6 +45,16 @@ impl GenericParamsOwnerEdit for ast::Fn {\n }\n \n impl GenericParamsOwnerEdit for ast::Impl {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        match self.generic_param_list() {\n+            Some(it) => it,\n+            None => {\n+                let position = Position::after(self.impl_token().unwrap());\n+                create_generic_param_list(position)\n+            }\n+        }\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n@@ -48,6 +69,10 @@ impl GenericParamsOwnerEdit for ast::Impl {\n }\n \n impl GenericParamsOwnerEdit for ast::Trait {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        todo!()\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n@@ -62,6 +87,10 @@ impl GenericParamsOwnerEdit for ast::Trait {\n }\n \n impl GenericParamsOwnerEdit for ast::Struct {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        todo!()\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let tfl = self.field_list().and_then(|fl| match fl {\n@@ -84,6 +113,10 @@ impl GenericParamsOwnerEdit for ast::Struct {\n }\n \n impl GenericParamsOwnerEdit for ast::Enum {\n+    fn get_or_create_generic_param_list(&self) -> ast::GenericParamList {\n+        todo!()\n+    }\n+\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(gpl) = self.generic_param_list() {\n@@ -104,6 +137,37 @@ fn create_where_clause(position: Position) {\n     ted::insert(position, where_clause.syntax());\n }\n \n+fn create_generic_param_list(position: Position) -> ast::GenericParamList {\n+    let gpl = make::generic_param_list(empty()).clone_for_update();\n+    ted::insert_raw(position, gpl.syntax());\n+    gpl\n+}\n+\n+impl ast::GenericParamList {\n+    pub fn add_generic_param(&self, generic_param: ast::GenericParam) {\n+        match self.generic_params().last() {\n+            Some(last_param) => {\n+                let mut elems = Vec::new();\n+                if !last_param\n+                    .syntax()\n+                    .siblings_with_tokens(Direction::Next)\n+                    .any(|it| it.kind() == T![,])\n+                {\n+                    elems.push(make::token(T![,]).into());\n+                    elems.push(make::tokens::single_space().into());\n+                };\n+                elems.push(generic_param.syntax().clone().into());\n+                let after_last_param = Position::after(last_param.syntax());\n+                ted::insert_all(after_last_param, elems);\n+            }\n+            None => {\n+                let after_l_angle = Position::after(self.l_angle_token().unwrap());\n+                ted::insert(after_l_angle, generic_param.syntax())\n+            }\n+        }\n+    }\n+}\n+\n impl ast::WhereClause {\n     pub fn add_predicate(&self, predicate: ast::WherePred) {\n         if let Some(pred) = self.predicates().last() {"}, {"sha": "450f2e447ab7ee5b86d8d296560c183bcae931ab", "filename": "crates/syntax/src/ted.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/144afa55a6031bb633c515c1cd20b110c123c5e5/crates%2Fsyntax%2Fsrc%2Fted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144afa55a6031bb633c515c1cd20b110c123c5e5/crates%2Fsyntax%2Fsrc%2Fted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fted.rs?ref=144afa55a6031bb633c515c1cd20b110c123c5e5", "patch": "@@ -165,6 +165,13 @@ fn ws_between(left: &SyntaxElement, right: &SyntaxElement) -> Option<SyntaxToken\n     if right.kind() == T![;] || right.kind() == T![,] {\n         return None;\n     }\n+    if left.kind() == T![<] || right.kind() == T![>] {\n+        return None;\n+    }\n+    if left.kind() == T![&] && right.kind() == SyntaxKind::LIFETIME {\n+        return None;\n+    }\n+\n     if right.kind() == SyntaxKind::USE {\n         let indent = IndentLevel::from_element(left);\n         return Some(make::tokens::whitespace(&format!(\"\\n{}\", indent)));"}]}