{"sha": "7c2e5e35a61adfee1fec69f811f79930bfd2c3b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMmU1ZTM1YTYxYWRmZWUxZmVjNjlmODExZjc5OTMwYmZkMmMzYjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-02-18T10:19:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-02-24T23:40:38Z"}, "message": "Generalize from passing around a single path to the test file to passing\naround a set of paths called `TestPaths`\n\nThis commit is not quite standalone; it basically contains all the\nborrowing plumbing bits, the interesting stuff comes in the next commit.", "tree": {"sha": "841b928d86fab527e93392f0e116b0e52d6e367c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/841b928d86fab527e93392f0e116b0e52d6e367c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9", "html_url": "https://github.com/rust-lang/rust/commit/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef8d426050318934d16d962325ec002eaf0c29d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef8d426050318934d16d962325ec002eaf0c29d", "html_url": "https://github.com/rust-lang/rust/commit/0ef8d426050318934d16d962325ec002eaf0c29d"}], "stats": {"total": 379, "additions": 208, "deletions": 171}, "files": [{"sha": "e29a55bbadc3f2545037f2065aafac46125da09a", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=7c2e5e35a61adfee1fec69f811f79930bfd2c3b9", "patch": "@@ -28,10 +28,12 @@ extern crate log;\n \n use std::env;\n use std::fs;\n+use std::io;\n use std::path::{Path, PathBuf};\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb};\n+use test::TestPaths;\n use util::logv;\n \n pub mod procsrv;\n@@ -267,15 +269,35 @@ pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n     debug!(\"making tests from {:?}\",\n            config.src_base.display());\n     let mut tests = Vec::new();\n-    let dirs = fs::read_dir(&config.src_base).unwrap();\n+    collect_tests_from_dir(config,\n+                           &config.src_base,\n+                           &config.src_base,\n+                           &PathBuf::new(),\n+                           &mut tests)\n+        .unwrap();\n+    tests\n+}\n+\n+fn collect_tests_from_dir(config: &Config,\n+                          base: &Path,\n+                          dir: &Path,\n+                          relative_dir_path: &Path,\n+                          tests: &mut Vec<test::TestDescAndFn>)\n+                          -> io::Result<()> {\n     for file in dirs {\n-        let file = file.unwrap().path();\n-        debug!(\"inspecting file {:?}\", file.display());\n-        if is_test(config, &file) {\n-            tests.push(make_test(config, &file))\n+        let file = try!(file);\n+        let file_path = file.path();\n+        debug!(\"inspecting file {:?}\", file_path.display());\n+        if is_test(config, &file_path) {\n+            let paths = TestPaths {\n+                file: file_path,\n+                base: base.to_path_buf(),\n+                relative_dir: relative_dir_path.to_path_buf(),\n+            };\n+            tests.push(make_test(config, &paths))\n         }\n     }\n-    tests\n+    Ok(())\n }\n \n pub fn is_test(config: &Config, testfile: &Path) -> bool {\n@@ -305,15 +327,14 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n     return valid;\n }\n \n-pub fn make_test(config: &Config, testfile: &Path) -> test::TestDescAndFn\n-{\n+pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn {\n     test::TestDescAndFn {\n         desc: test::TestDesc {\n-            name: make_test_name(config, testfile),\n-            ignore: header::is_test_ignored(config, testfile),\n+            name: make_test_name(config, testpaths),\n+            ignore: header::is_test_ignored(config, &testpaths.file),\n             should_panic: test::ShouldPanic::No,\n         },\n-        testfn: make_test_closure(config, &testfile),\n+        testfn: make_test_closure(config, testpaths),\n     }\n }\n \n@@ -330,11 +351,11 @@ pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n     test::DynTestName(format!(\"[{}] {}\", config.mode, shorten(testfile)))\n }\n \n-pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n-    let config = (*config).clone();\n-    let testfile = testfile.to_path_buf();\n+pub fn make_test_closure(config: &Config, testpaths: &TestPaths) -> test::TestFn {\n+    let config = config.clone();\n+    let testpaths = testpaths.clone();\n     test::DynTestFn(Box::new(move || {\n-        runtest::run(config, &testfile)\n+        runtest::run(config, &testpaths)\n     }))\n }\n "}, {"sha": "601033ff5e8ff9df717a12e390c70e5acd59c6c3", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 166, "deletions": 155, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=7c2e5e35a61adfee1fec69f811f79930bfd2c3b9", "patch": "@@ -15,6 +15,7 @@ use errors;\n use header::TestProps;\n use header;\n use procsrv;\n+use test::TestPaths;\n use util::logv;\n \n use std::env;\n@@ -27,7 +28,7 @@ use std::net::TcpStream;\n use std::path::{Path, PathBuf, Component};\n use std::process::{Command, Output, ExitStatus};\n \n-pub fn run(config: Config, testfile: &Path) {\n+pub fn run(config: Config, testpaths: &TestPaths) {\n     match &*config.target {\n \n         \"arm-linux-androideabi\" | \"aarch64-linux-android\" => {\n@@ -43,21 +44,21 @@ pub fn run(config: Config, testfile: &Path) {\n         // We're going to be dumping a lot of info. Start on a new line.\n         print!(\"\\n\\n\");\n     }\n-    debug!(\"running {:?}\", testfile.display());\n-    let props = header::load_props(&testfile);\n+    debug!(\"running {:?}\", testpaths.file.display());\n+    let props = header::load_props(&testpaths.file);\n     debug!(\"loaded props\");\n     match config.mode {\n-        CompileFail => run_cfail_test(&config, &props, &testfile),\n-        ParseFail => run_cfail_test(&config, &props, &testfile),\n-        RunFail => run_rfail_test(&config, &props, &testfile),\n-        RunPass => run_rpass_test(&config, &props, &testfile),\n-        RunPassValgrind => run_valgrind_test(&config, &props, &testfile),\n-        Pretty => run_pretty_test(&config, &props, &testfile),\n-        DebugInfoGdb => run_debuginfo_gdb_test(&config, &props, &testfile),\n-        DebugInfoLldb => run_debuginfo_lldb_test(&config, &props, &testfile),\n-        Codegen => run_codegen_test(&config, &props, &testfile),\n-        Rustdoc => run_rustdoc_test(&config, &props, &testfile),\n-        CodegenUnits => run_codegen_units_test(&config, &props, &testfile),\n+        CompileFail => run_cfail_test(&config, &props, &testpaths),\n+        ParseFail => run_cfail_test(&config, &props, &testpaths),\n+        RunFail => run_rfail_test(&config, &props, &testpaths),\n+        RunPass => run_rpass_test(&config, &props, &testpaths),\n+        RunPassValgrind => run_valgrind_test(&config, &props, &testpaths),\n+        Pretty => run_pretty_test(&config, &props, &testpaths),\n+        DebugInfoGdb => run_debuginfo_gdb_test(&config, &props, &testpaths),\n+        DebugInfoLldb => run_debuginfo_lldb_test(&config, &props, &testpaths),\n+        Codegen => run_codegen_test(&config, &props, &testpaths),\n+        Rustdoc => run_rustdoc_test(&config, &props, &testpaths),\n+        CodegenUnits => run_codegen_units_test(&config, &props, &testpaths),\n     }\n }\n \n@@ -69,8 +70,8 @@ fn get_output(props: &TestProps, proc_res: &ProcRes) -> String {\n     }\n }\n \n-fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n-    let proc_res = compile_test(config, props, testfile);\n+fn run_cfail_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    let proc_res = compile_test(config, props, testpaths);\n \n     if proc_res.status.success() {\n         fatal_proc_rec(&format!(\"{} test compiled successfully!\", config.mode)[..],\n@@ -84,27 +85,27 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     }\n \n     let output_to_check = get_output(props, &proc_res);\n-    let expected_errors = errors::load_errors(testfile);\n+    let expected_errors = errors::load_errors(&testpaths.file);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n             fatal(\"both error pattern and expected errors specified\");\n         }\n-        check_expected_errors(expected_errors, testfile, &proc_res);\n+        check_expected_errors(expected_errors, testpaths, &proc_res);\n     } else {\n-        check_error_patterns(props, testfile, &output_to_check, &proc_res);\n+        check_error_patterns(props, testpaths, &output_to_check, &proc_res);\n     }\n     check_no_compiler_crash(&proc_res);\n     check_forbid_output(props, &output_to_check, &proc_res);\n }\n \n-fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n-    let proc_res = compile_test(config, props, testfile);\n+fn run_rfail_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    let proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n         fatal_proc_rec(\"compilation failed!\", &proc_res);\n     }\n \n-    let proc_res = exec_compiled_test(config, props, testfile);\n+    let proc_res = exec_compiled_test(config, props, testpaths);\n \n     // The value our Makefile configures valgrind to return on failure\n     const VALGRIND_ERR: i32 = 100;\n@@ -114,7 +115,7 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     let output_to_check = get_output(props, &proc_res);\n     check_correct_failure_status(&proc_res);\n-    check_error_patterns(props, testfile, &output_to_check, &proc_res);\n+    check_error_patterns(props, testpaths, &output_to_check, &proc_res);\n }\n \n fn check_correct_failure_status(proc_res: &ProcRes) {\n@@ -128,42 +129,42 @@ fn check_correct_failure_status(proc_res: &ProcRes) {\n     }\n }\n \n-fn run_rpass_test(config: &Config, props: &TestProps, testfile: &Path) {\n-    let proc_res = compile_test(config, props, testfile);\n+fn run_rpass_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    let proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n         fatal_proc_rec(\"compilation failed!\", &proc_res);\n     }\n \n-    let proc_res = exec_compiled_test(config, props, testfile);\n+    let proc_res = exec_compiled_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n         fatal_proc_rec(\"test run failed!\", &proc_res);\n     }\n }\n \n-fn run_valgrind_test(config: &Config, props: &TestProps, testfile: &Path) {\n+fn run_valgrind_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n     if config.valgrind_path.is_none() {\n         assert!(!config.force_valgrind);\n-        return run_rpass_test(config, props, testfile);\n+        return run_rpass_test(config, props, testpaths);\n     }\n \n-    let mut proc_res = compile_test(config, props, testfile);\n+    let mut proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n         fatal_proc_rec(\"compilation failed!\", &proc_res);\n     }\n \n     let mut new_config = config.clone();\n     new_config.runtool = new_config.valgrind_path.clone();\n-    proc_res = exec_compiled_test(&new_config, props, testfile);\n+    proc_res = exec_compiled_test(&new_config, props, testpaths);\n \n     if !proc_res.status.success() {\n         fatal_proc_rec(\"test run failed!\", &proc_res);\n     }\n }\n \n-fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n+fn run_pretty_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n     if props.pp_exact.is_some() {\n         logv(config, \"testing for exact pretty-printing\".to_owned());\n     } else {\n@@ -174,15 +175,15 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n     let mut src = String::new();\n-    File::open(testfile).unwrap().read_to_string(&mut src).unwrap();\n+    File::open(&testpaths.file).unwrap().read_to_string(&mut src).unwrap();\n     let mut srcs = vec!(src);\n \n     let mut round = 0;\n     while round < rounds {\n         logv(config, format!(\"pretty-printing round {}\", round));\n         let proc_res = print_source(config,\n                                     props,\n-                                    testfile,\n+                                    testpaths,\n                                     srcs[round].to_owned(),\n                                     &props.pretty_mode);\n \n@@ -198,7 +199,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n-            let filepath = testfile.parent().unwrap().join(file);\n+            let filepath = testpaths.file.parent().unwrap().join(file);\n             let mut s = String::new();\n             File::open(&filepath).unwrap().read_to_string(&mut s).unwrap();\n             s\n@@ -220,21 +221,21 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if props.pretty_compare_only { return; }\n \n     // Finally, let's make sure it actually appears to remain valid code\n-    let proc_res = typecheck_source(config, props, testfile, actual);\n+    let proc_res = typecheck_source(config, props, testpaths, actual);\n \n     if !proc_res.status.success() {\n         fatal_proc_rec(\"pretty-printed source does not typecheck\", &proc_res);\n     }\n     if !props.pretty_expanded { return }\n \n     // additionally, run `--pretty expanded` and try to build it.\n-    let proc_res = print_source(config, props, testfile, srcs[round].clone(), \"expanded\");\n+    let proc_res = print_source(config, props, testpaths, srcs[round].clone(), \"expanded\");\n     if !proc_res.status.success() {\n         fatal_proc_rec(\"pretty-printing (expanded) failed\", &proc_res);\n     }\n \n     let ProcRes{ stdout: expanded_src, .. } = proc_res;\n-    let proc_res = typecheck_source(config, props, testfile, expanded_src);\n+    let proc_res = typecheck_source(config, props, testpaths, expanded_src);\n     if !proc_res.status.success() {\n         fatal_proc_rec(\"pretty-printed source (expanded) does not typecheck\",\n                       &proc_res);\n@@ -244,15 +245,15 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     fn print_source(config: &Config,\n                     props: &TestProps,\n-                    testfile: &Path,\n+                    testpaths: &TestPaths,\n                     src: String,\n                     pretty_type: &str) -> ProcRes {\n-        let aux_dir = aux_output_dir_name(config, testfile);\n+        let aux_dir = aux_output_dir_name(config, testpaths);\n         compose_and_run(config,\n-                        testfile,\n+                        testpaths,\n                         make_pp_args(config,\n                                      props,\n-                                     testfile,\n+                                     testpaths,\n                                      pretty_type.to_owned()),\n                         props.exec_env.clone(),\n                         &config.compile_lib_path,\n@@ -262,9 +263,9 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     fn make_pp_args(config: &Config,\n                     props: &TestProps,\n-                    testfile: &Path,\n+                    testpaths: &TestPaths,\n                     pretty_type: String) -> ProcArgs {\n-        let aux_dir = aux_output_dir_name(config, testfile);\n+        let aux_dir = aux_output_dir_name(config, testpaths);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec!(\"-\".to_owned(),\n                             \"-Zunstable-options\".to_owned(),\n@@ -300,13 +301,13 @@ actual:\\n\\\n     }\n \n     fn typecheck_source(config: &Config, props: &TestProps,\n-                        testfile: &Path, src: String) -> ProcRes {\n-        let args = make_typecheck_args(config, props, testfile);\n-        compose_and_run_compiler(config, props, testfile, args, Some(src))\n+                        testpaths: &TestPaths, src: String) -> ProcRes {\n+        let args = make_typecheck_args(config, props, testpaths);\n+        compose_and_run_compiler(config, props, testpaths, args, Some(src))\n     }\n \n-    fn make_typecheck_args(config: &Config, props: &TestProps, testfile: &Path) -> ProcArgs {\n-        let aux_dir = aux_output_dir_name(config, testfile);\n+    fn make_typecheck_args(config: &Config, props: &TestProps, testpaths: &TestPaths) -> ProcArgs {\n+        let aux_dir = aux_output_dir_name(config, testpaths);\n         let target = if props.force_host {\n             &*config.host\n         } else {\n@@ -330,7 +331,7 @@ actual:\\n\\\n     }\n }\n \n-fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n+fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n     let mut config = Config {\n         target_rustcflags: cleanup_debug_info_options(&config.target_rustcflags),\n         host_rustcflags: cleanup_debug_info_options(&config.host_rustcflags),\n@@ -342,16 +343,16 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n         commands,\n         check_lines,\n         breakpoint_lines\n-    } = parse_debugger_commands(testfile, \"gdb\");\n+    } = parse_debugger_commands(testpaths, \"gdb\");\n     let mut cmds = commands.join(\"\\n\");\n \n     // compile test file (it should have 'compile-flags:-g' in the header)\n-    let compiler_run_result = compile_test(config, props, testfile);\n+    let compiler_run_result = compile_test(config, props, testpaths);\n     if !compiler_run_result.status.success() {\n         fatal_proc_rec(\"compilation failed!\", &compiler_run_result);\n     }\n \n-    let exe_file = make_exe_name(config, testfile);\n+    let exe_file = make_exe_name(config, testpaths);\n \n     let debugger_run_result;\n     match &*config.target {\n@@ -369,16 +370,18 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                          config.host, config.target));\n             for line in &breakpoint_lines {\n                 script_str.push_str(&format!(\"break {:?}:{}\\n\",\n-                                             testfile.file_name().unwrap()\n-                                                     .to_string_lossy(),\n+                                             testpaths.file\n+                                                      .file_name()\n+                                                      .unwrap()\n+                                                      .to_string_lossy(),\n                                              *line)[..]);\n             }\n             script_str.push_str(&cmds);\n             script_str.push_str(\"\\nquit\\n\");\n \n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config,\n-                             testfile,\n+                             testpaths,\n                              &script_str,\n                              \"debugger.script\");\n \n@@ -441,7 +444,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 None => fatal(\"cannot find android cross path\")\n             };\n \n-            let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n+            let debugger_script = make_out_name(config, testpaths, \"debugger.script\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let debugger_opts =\n                 vec!(\"-quiet\".to_owned(),\n@@ -531,7 +534,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             // Add line breakpoints\n             for line in &breakpoint_lines {\n                 script_str.push_str(&format!(\"break '{}':{}\\n\",\n-                                             testfile.file_name().unwrap()\n+                                             testpaths.file.file_name().unwrap()\n                                                      .to_string_lossy(),\n                                              *line));\n             }\n@@ -541,7 +544,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config,\n-                             testfile,\n+                             testpaths,\n                              &script_str,\n                              \"debugger.script\");\n \n@@ -550,7 +553,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 if cfg!(windows) {\"gdb.exe\"} else {\"gdb\"}\n             }\n \n-            let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n+            let debugger_script = make_out_name(config, testpaths, \"debugger.script\");\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let debugger_opts =\n@@ -567,7 +570,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             let environment = vec![(\"PYTHONPATH\".to_owned(), rust_pp_module_abs_path)];\n \n             debugger_run_result = compose_and_run(config,\n-                                                  testfile,\n+                                                  testpaths,\n                                                   proc_args,\n                                                   environment,\n                                                   &config.run_lib_path,\n@@ -596,7 +599,7 @@ fn find_rust_src_root(config: &Config) -> Option<PathBuf> {\n     return None;\n }\n \n-fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path) {\n+fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n     if config.lldb_python_dir.is_none() {\n         fatal(\"Can't run LLDB test because LLDB's python path is not set.\");\n     }\n@@ -610,12 +613,12 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     let config = &mut config;\n \n     // compile test file (it should have 'compile-flags:-g' in the header)\n-    let compile_result = compile_test(config, props, testfile);\n+    let compile_result = compile_test(config, props, testpaths);\n     if !compile_result.status.success() {\n         fatal_proc_rec(\"compilation failed!\", &compile_result);\n     }\n \n-    let exe_file = make_exe_name(config, testfile);\n+    let exe_file = make_exe_name(config, testpaths);\n \n     match config.lldb_version {\n         Some(ref version) => {\n@@ -634,7 +637,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n         check_lines,\n         breakpoint_lines,\n         ..\n-    } = parse_debugger_commands(testfile, \"lldb\");\n+    } = parse_debugger_commands(testpaths, \"lldb\");\n \n     // Write debugger script:\n     // We don't want to hang when calling `quit` while the process is still running\n@@ -676,13 +679,14 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     // Write the script into a file\n     debug!(\"script_str = {}\", script_str);\n     dump_output_file(config,\n-                     testfile,\n+                     testpaths,\n                      &script_str,\n                      \"debugger.script\");\n-    let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n+    let debugger_script = make_out_name(config, testpaths, \"debugger.script\");\n \n     // Let LLDB execute the script via lldb_batchmode.py\n     let debugger_run_result = run_lldb(config,\n+                                       testpaths,\n                                        &exe_file,\n                                        &debugger_script,\n                                        &rust_src_root);\n@@ -694,14 +698,15 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     check_debugger_output(&debugger_run_result, &check_lines);\n \n     fn run_lldb(config: &Config,\n+                testpaths: &TestPaths,\n                 test_executable: &Path,\n                 debugger_script: &Path,\n                 rust_src_root: &Path)\n                 -> ProcRes {\n         // Prepare the lldb_batchmode which executes the debugger script\n         let lldb_script_path = rust_src_root.join(\"src/etc/lldb_batchmode.py\");\n         cmd2procres(config,\n-                    test_executable,\n+                    testpaths,\n                     Command::new(&config.python)\n                             .arg(&lldb_script_path)\n                             .arg(test_executable)\n@@ -711,7 +716,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     }\n }\n \n-fn cmd2procres(config: &Config, test_executable: &Path, cmd: &mut Command)\n+fn cmd2procres(config: &Config, testpaths: &TestPaths, cmd: &mut Command)\n               -> ProcRes {\n     let (status, out, err) = match cmd.output() {\n         Ok(Output { status, stdout, stderr }) => {\n@@ -725,7 +730,7 @@ fn cmd2procres(config: &Config, test_executable: &Path, cmd: &mut Command)\n         }\n     };\n \n-    dump_output(config, test_executable, &out, &err);\n+    dump_output(config, testpaths, &out, &err);\n     ProcRes {\n         status: Status::Normal(status),\n         stdout: out,\n@@ -740,7 +745,7 @@ struct DebuggerCommands {\n     breakpoint_lines: Vec<usize>,\n }\n \n-fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n+fn parse_debugger_commands(testpaths: &TestPaths, debugger_prefix: &str)\n                            -> DebuggerCommands {\n     let command_directive = format!(\"{}-command\", debugger_prefix);\n     let check_directive = format!(\"{}-check\", debugger_prefix);\n@@ -749,7 +754,7 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n     let mut commands = vec!();\n     let mut check_lines = vec!();\n     let mut counter = 1;\n-    let reader = BufReader::new(File::open(file_path).unwrap());\n+    let reader = BufReader::new(File::open(&testpaths.file).unwrap());\n     for line in reader.lines() {\n         match line {\n             Ok(line) => {\n@@ -860,11 +865,12 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n }\n \n fn check_error_patterns(props: &TestProps,\n-                        testfile: &Path,\n+                        testpaths: &TestPaths,\n                         output_to_check: &str,\n                         proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(&format!(\"no error pattern specified in {:?}\", testfile.display()));\n+        fatal(&format!(\"no error pattern specified in {:?}\",\n+                       testpaths.file.display()));\n     }\n     let mut next_err_idx = 0;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n@@ -915,7 +921,7 @@ fn check_forbid_output(props: &TestProps,\n }\n \n fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n-                         testfile: &Path,\n+                         testpaths: &TestPaths,\n                          proc_res: &ProcRes) {\n \n     // true if we found the error in question\n@@ -926,7 +932,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError>,\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        format!(\"{}:{}:\", testfile.display(), ee.line)\n+        format!(\"{}:{}:\", testpaths.file.display(), ee.line)\n     }).collect::<Vec<String>>();\n \n     let (expect_help, expect_note) =\n@@ -1142,62 +1148,64 @@ impl fmt::Display for Status {\n }\n \n fn compile_test(config: &Config, props: &TestProps,\n-                testfile: &Path) -> ProcRes {\n-    let aux_dir = aux_output_dir_name(config, testfile);\n+                testpaths: &TestPaths) -> ProcRes {\n+    let aux_dir = aux_output_dir_name(config, testpaths);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let link_args = vec!(\"-L\".to_owned(),\n                          aux_dir.to_str().unwrap().to_owned());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,\n-                                 |a, b| TargetLocation::ThisFile(make_exe_name(a, b)), testfile);\n-    compose_and_run_compiler(config, props, testfile, args, None)\n+                                 |a, b| TargetLocation::ThisFile(make_exe_name(a, b)), testpaths);\n+    compose_and_run_compiler(config, props, testpaths, args, None)\n }\n \n-fn document(config: &Config, props: &TestProps,\n-            testfile: &Path, out_dir: &Path) -> ProcRes {\n+fn document(config: &Config,\n+            props: &TestProps,\n+            testpaths: &TestPaths,\n+            out_dir: &Path)\n+            -> ProcRes {\n     if props.build_aux_docs {\n         for rel_ab in &props.aux_builds {\n-            let abs_ab = config.aux_base.join(rel_ab);\n-            let aux_props = header::load_props(&abs_ab);\n-\n-            let auxres = document(config, &aux_props, &abs_ab, out_dir);\n+            let aux_testpaths = compute_aux_test_paths(config, testpaths, rel_ab);\n+            let aux_props = header::load_props(&aux_testpaths.file);\n+            let auxres = document(config, &aux_props, &aux_testpaths, out_dir);\n             if !auxres.status.success() {\n                 return auxres;\n             }\n         }\n     }\n \n-    let aux_dir = aux_output_dir_name(config, testfile);\n+    let aux_dir = aux_output_dir_name(config, testpaths);\n     let mut args = vec![\"-L\".to_owned(),\n                         aux_dir.to_str().unwrap().to_owned(),\n                         \"-o\".to_owned(),\n                         out_dir.to_str().unwrap().to_owned(),\n-                        testfile.to_str().unwrap().to_owned()];\n+                        testpaths.file.to_str().unwrap().to_owned()];\n     args.extend(split_maybe_args(&props.compile_flags));\n     let args = ProcArgs {\n         prog: config.rustdoc_path.to_str().unwrap().to_owned(),\n         args: args,\n     };\n-    compose_and_run_compiler(config, props, testfile, args, None)\n+    compose_and_run_compiler(config, props, testpaths, args, None)\n }\n \n fn exec_compiled_test(config: &Config, props: &TestProps,\n-                      testfile: &Path) -> ProcRes {\n+                      testpaths: &TestPaths) -> ProcRes {\n \n     let env = props.exec_env.clone();\n \n     match &*config.target {\n \n         \"arm-linux-androideabi\" | \"aarch64-linux-android\" => {\n-            _arm_exec_compiled_test(config, props, testfile, env)\n+            _arm_exec_compiled_test(config, props, testpaths, env)\n         }\n \n         _=> {\n-            let aux_dir = aux_output_dir_name(config, testfile);\n+            let aux_dir = aux_output_dir_name(config, testpaths);\n             compose_and_run(config,\n-                            testfile,\n-                            make_run_args(config, props, testfile),\n+                            testpaths,\n+                            make_run_args(config, props, testpaths),\n                             env,\n                             &config.run_lib_path,\n                             Some(aux_dir.to_str().unwrap()),\n@@ -1207,20 +1215,20 @@ fn exec_compiled_test(config: &Config, props: &TestProps,\n }\n \n fn compose_and_run_compiler(config: &Config, props: &TestProps,\n-                            testfile: &Path, args: ProcArgs,\n+                            testpaths: &TestPaths, args: ProcArgs,\n                             input: Option<String>) -> ProcRes {\n     if !props.aux_builds.is_empty() {\n-        ensure_dir(&aux_output_dir_name(config, testfile));\n+        ensure_dir(&aux_output_dir_name(config, testpaths));\n     }\n \n-    let aux_dir = aux_output_dir_name(config, testfile);\n+    let aux_dir = aux_output_dir_name(config, testpaths);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let extra_link_args = vec![\"-L\".to_owned(),\n                                aux_dir.to_str().unwrap().to_owned()];\n \n     for rel_ab in &props.aux_builds {\n-        let abs_ab = config.aux_base.join(rel_ab);\n-        let aux_props = header::load_props(&abs_ab);\n+        let aux_testpaths = compute_aux_test_paths(config, testpaths, rel_ab);\n+        let aux_props = header::load_props(&aux_testpaths.file);\n         let mut crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n         } else {\n@@ -1247,13 +1255,13 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n                               &aux_props,\n                               crate_type,\n                               |a,b| {\n-                                  let f = make_lib_name(a, b, testfile);\n+                                  let f = make_lib_name(a, &b.file, testpaths);\n                                   let parent = f.parent().unwrap();\n                                   TargetLocation::ThisDirectory(parent.to_path_buf())\n                               },\n-                              &abs_ab);\n+                              &aux_testpaths);\n         let auxres = compose_and_run(config,\n-                                     &abs_ab,\n+                                     &aux_testpaths,\n                                      aux_args,\n                                      Vec::new(),\n                                      &config.compile_lib_path,\n@@ -1262,20 +1270,20 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n         if !auxres.status.success() {\n             fatal_proc_rec(\n                 &format!(\"auxiliary build of {:?} failed to compile: \",\n-                        abs_ab.display()),\n+                        aux_testpaths.file.display()),\n                 &auxres);\n         }\n \n         match &*config.target {\n             \"arm-linux-androideabi\"  | \"aarch64-linux-android\" => {\n-                _arm_push_aux_shared_library(config, testfile);\n+                _arm_push_aux_shared_library(config, testpaths);\n             }\n             _ => {}\n         }\n     }\n \n     compose_and_run(config,\n-                    testfile,\n+                    testpaths,\n                     args,\n                     Vec::new(),\n                     &config.compile_lib_path,\n@@ -1285,16 +1293,17 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n \n fn ensure_dir(path: &Path) {\n     if path.is_dir() { return; }\n-    fs::create_dir(path).unwrap();\n+    fs::create_dir_all(path).unwrap();\n }\n \n-fn compose_and_run(config: &Config, testfile: &Path,\n+fn compose_and_run(config: &Config,\n+                   testpaths: &TestPaths,\n                    ProcArgs{ args, prog }: ProcArgs,\n                    procenv: Vec<(String, String)> ,\n                    lib_path: &str,\n                    aux_path: Option<&str>,\n                    input: Option<String>) -> ProcRes {\n-    return program_output(config, testfile, lib_path,\n+    return program_output(config, testpaths, lib_path,\n                           prog, aux_path, args, procenv, input);\n }\n \n@@ -1307,18 +1316,18 @@ fn make_compile_args<F>(config: &Config,\n                         props: &TestProps,\n                         extras: Vec<String> ,\n                         xform: F,\n-                        testfile: &Path)\n+                        testpaths: &TestPaths)\n                         -> ProcArgs where\n-    F: FnOnce(&Config, &Path) -> TargetLocation,\n+    F: FnOnce(&Config, &TestPaths) -> TargetLocation,\n {\n-    let xform_file = xform(config, testfile);\n+    let xform_file = xform(config, testpaths);\n     let target = if props.force_host {\n         &*config.host\n     } else {\n         &*config.target\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut args = vec!(testfile.to_str().unwrap().to_owned(),\n+    let mut args = vec!(testpaths.file.to_str().unwrap().to_owned(),\n                         \"-L\".to_owned(),\n                         config.build_base.to_str().unwrap().to_owned(),\n                         format!(\"--target={}\", target));\n@@ -1350,15 +1359,15 @@ fn make_compile_args<F>(config: &Config,\n     };\n }\n \n-fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> PathBuf {\n+fn make_lib_name(config: &Config, auxfile: &Path, testpaths: &TestPaths) -> PathBuf {\n     // what we return here is not particularly important, as it\n     // happens; rustc ignores everything except for the directory.\n     let auxname = output_testname(auxfile);\n-    aux_output_dir_name(config, testfile).join(&auxname)\n+    aux_output_dir_name(config, testpaths).join(&auxname)\n }\n \n-fn make_exe_name(config: &Config, testfile: &Path) -> PathBuf {\n-    let mut f = output_base_name(config, testfile);\n+fn make_exe_name(config: &Config, testpaths: &TestPaths) -> PathBuf {\n+    let mut f = output_base_name(config, testpaths);\n     // FIXME: This is using the host architecture exe suffix, not target!\n     if config.target == \"asmjs-unknown-emscripten\" {\n         let mut fname = f.file_name().unwrap().to_os_string();\n@@ -1372,7 +1381,7 @@ fn make_exe_name(config: &Config, testfile: &Path) -> PathBuf {\n     f\n }\n \n-fn make_run_args(config: &Config, props: &TestProps, testfile: &Path)\n+fn make_run_args(config: &Config, props: &TestProps, testpaths: &TestPaths)\n                  -> ProcArgs {\n     // If we've got another tool to run under (valgrind),\n     // then split apart its command\n@@ -1383,7 +1392,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path)\n         args.push(\"nodejs\".to_owned());\n     }\n \n-    let exe_file = make_exe_name(config, testfile);\n+    let exe_file = make_exe_name(config, testpaths);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     args.push(exe_file.to_str().unwrap().to_owned());\n@@ -1415,7 +1424,7 @@ fn split_maybe_args(argstr: &Option<String>) -> Vec<String> {\n     }\n }\n \n-fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: String,\n+fn program_output(config: &Config, testpaths: &TestPaths, lib_path: &str, prog: String,\n                   aux_path: Option<&str>, args: Vec<String>,\n                   env: Vec<(String, String)>,\n                   input: Option<String>) -> ProcRes {\n@@ -1437,7 +1446,7 @@ fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: String\n                      &args,\n                      env,\n                      input).expect(&format!(\"failed to exec `{}`\", prog));\n-    dump_output(config, testfile, &out, &err);\n+    dump_output(config, testpaths, &out, &err);\n     return ProcRes {\n         status: Status::Normal(status),\n         stdout: out,\n@@ -1463,31 +1472,33 @@ fn make_cmdline(libpath: &str, prog: &str, args: &[String]) -> String {\n     }\n }\n \n-fn dump_output(config: &Config, testfile: &Path, out: &str, err: &str) {\n-    dump_output_file(config, testfile, out, \"out\");\n-    dump_output_file(config, testfile, err, \"err\");\n+fn dump_output(config: &Config, testpaths: &TestPaths, out: &str, err: &str) {\n+    dump_output_file(config, testpaths, out, \"out\");\n+    dump_output_file(config, testpaths, err, \"err\");\n     maybe_dump_to_stdout(config, out, err);\n }\n \n-fn dump_output_file(config: &Config, testfile: &Path,\n-                    out: &str, extension: &str) {\n-    let outfile = make_out_name(config, testfile, extension);\n+fn dump_output_file(config: &Config,\n+                    testpaths: &TestPaths,\n+                    out: &str,\n+                    extension: &str) {\n+    let outfile = make_out_name(config, testpaths, extension);\n     File::create(&outfile).unwrap().write_all(out.as_bytes()).unwrap();\n }\n \n-fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> PathBuf {\n-    output_base_name(config, testfile).with_extension(extension)\n+fn make_out_name(config: &Config, testpaths: &TestPaths, extension: &str) -> PathBuf {\n+    output_base_name(config, testpaths).with_extension(extension)\n }\n \n-fn aux_output_dir_name(config: &Config, testfile: &Path) -> PathBuf {\n-    let f = output_base_name(config, testfile);\n+fn aux_output_dir_name(config: &Config, testpaths: &TestPaths) -> PathBuf {\n+    let f = output_base_name(config, testpaths);\n     let mut fname = f.file_name().unwrap().to_os_string();\n     fname.push(&format!(\".{}.libaux\", config.mode));\n     f.with_file_name(&fname)\n }\n \n-fn output_testname(testfile: &Path) -> PathBuf {\n-    PathBuf::from(testfile.file_stem().unwrap())\n+fn output_testname(filepath: &Path) -> PathBuf {\n+    PathBuf::from(filepath.file_stem().unwrap())\n }\n \n fn output_base_name(config: &Config, testfile: &Path) -> PathBuf {\n@@ -1531,10 +1542,10 @@ stderr:\\n\\\n \n fn _arm_exec_compiled_test(config: &Config,\n                            props: &TestProps,\n-                           testfile: &Path,\n+                           testpaths: &TestPaths,\n                            env: Vec<(String, String)>)\n                            -> ProcRes {\n-    let args = make_run_args(config, props, testfile);\n+    let args = make_run_args(config, props, testpaths);\n     let cmdline = make_cmdline(\"\",\n                                &args.prog,\n                                &args.args);\n@@ -1645,7 +1656,7 @@ fn _arm_exec_compiled_test(config: &Config,\n         .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     dump_output(config,\n-                testfile,\n+                testpaths,\n                 &stdout_out,\n                 &stderr_out);\n \n@@ -1657,8 +1668,8 @@ fn _arm_exec_compiled_test(config: &Config,\n     }\n }\n \n-fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n-    let tdir = aux_output_dir_name(config, testfile);\n+fn _arm_push_aux_shared_library(config: &Config, testpaths: &TestPaths) {\n+    let tdir = aux_output_dir_name(config, testpaths);\n \n     let dirs = fs::read_dir(&tdir).unwrap();\n     for file in dirs {\n@@ -1692,8 +1703,8 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n // codegen tests (using FileCheck)\n \n fn compile_test_and_save_ir(config: &Config, props: &TestProps,\n-                                 testfile: &Path) -> ProcRes {\n-    let aux_dir = aux_output_dir_name(config, testfile);\n+                                 testpaths: &TestPaths) -> ProcRes {\n+    let aux_dir = aux_output_dir_name(config, testpaths);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let mut link_args = vec!(\"-L\".to_owned(),\n                              aux_dir.to_str().unwrap().to_owned());\n@@ -1705,34 +1716,34 @@ fn compile_test_and_save_ir(config: &Config, props: &TestProps,\n                                  |a, b| TargetLocation::ThisDirectory(\n                                      output_base_name(a, b).parent()\n                                         .unwrap().to_path_buf()),\n-                                 testfile);\n-    compose_and_run_compiler(config, props, testfile, args, None)\n+                                 testpaths);\n+    compose_and_run_compiler(config, props, testpaths, args, None)\n }\n \n-fn check_ir_with_filecheck(config: &Config, testfile: &Path) -> ProcRes {\n-    let irfile = output_base_name(config, testfile).with_extension(\"ll\");\n+fn check_ir_with_filecheck(config: &Config, testpaths: &TestPaths) -> ProcRes {\n+    let irfile = output_base_name(config, testpaths).with_extension(\"ll\");\n     let prog = config.llvm_bin_path.as_ref().unwrap().join(\"FileCheck\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.to_str().unwrap().to_owned(),\n         args: vec!(format!(\"-input-file={}\", irfile.to_str().unwrap()),\n-                   testfile.to_str().unwrap().to_owned())\n+                   testpaths.file.to_str().unwrap().to_owned())\n     };\n-    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None, None)\n+    compose_and_run(config, testpaths, proc_args, Vec::new(), \"\", None, None)\n }\n \n-fn run_codegen_test(config: &Config, props: &TestProps, testfile: &Path) {\n+fn run_codegen_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n \n     if config.llvm_bin_path.is_none() {\n         fatal(\"missing --llvm-bin-path\");\n     }\n \n-    let mut proc_res = compile_test_and_save_ir(config, props, testfile);\n+    let mut proc_res = compile_test_and_save_ir(config, props, testpaths);\n     if !proc_res.status.success() {\n         fatal_proc_rec(\"compilation failed!\", &proc_res);\n     }\n \n-    proc_res = check_ir_with_filecheck(config, testfile);\n+    proc_res = check_ir_with_filecheck(config, testpaths);\n     if !proc_res.status.success() {\n         fatal_proc_rec(\"verification with 'FileCheck' failed\",\n                       &proc_res);\n@@ -1750,30 +1761,30 @@ fn charset() -> &'static str {\n     }\n }\n \n-fn run_rustdoc_test(config: &Config, props: &TestProps, testfile: &Path) {\n-    let out_dir = output_base_name(config, testfile);\n+fn run_rustdoc_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    let out_dir = output_base_name(config, testpaths);\n     let _ = fs::remove_dir_all(&out_dir);\n     ensure_dir(&out_dir);\n \n-    let proc_res = document(config, props, testfile, &out_dir);\n+    let proc_res = document(config, props, testpaths, &out_dir);\n     if !proc_res.status.success() {\n         fatal_proc_rec(\"rustdoc failed!\", &proc_res);\n     }\n     let root = find_rust_src_root(config).unwrap();\n \n     let res = cmd2procres(config,\n-                          testfile,\n+                          testpaths,\n                           Command::new(&config.python)\n                                   .arg(root.join(\"src/etc/htmldocck.py\"))\n                                   .arg(out_dir)\n-                                  .arg(testfile));\n+                                  .arg(&testpaths.file));\n     if !res.status.success() {\n         fatal_proc_rec(\"htmldocck failed!\", &res);\n     }\n }\n \n-fn run_codegen_units_test(config: &Config, props: &TestProps, testfile: &Path) {\n-    let proc_res = compile_test(config, props, testfile);\n+fn run_codegen_units_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    let proc_res = compile_test(config, props, testpaths);\n \n     if !proc_res.status.success() {\n         fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -1790,7 +1801,7 @@ fn run_codegen_units_test(config: &Config, props: &TestProps, testfile: &Path) {\n         .map(|s| (&s[prefix.len()..]).to_string())\n         .collect();\n \n-    let expected: HashSet<String> = errors::load_errors(testfile)\n+    let expected: HashSet<String> = errors::load_errors(&testpaths.file)\n         .iter()\n         .map(|e| e.msg.trim().to_string())\n         .collect();"}, {"sha": "e82451937d39c2b7089295518c4b7f2ba4a1f3ec", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2e5e35a61adfee1fec69f811f79930bfd2c3b9/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7c2e5e35a61adfee1fec69f811f79930bfd2c3b9", "patch": "@@ -203,7 +203,12 @@ pub struct TestDesc {\n     pub should_panic: ShouldPanic,\n }\n \n-unsafe impl Send for TestDesc {}\n+#[derive(Clone)]\n+pub struct TestPaths {\n+    pub file: PathBuf,         // e.g., compile-test/foo/bar/baz.rs\n+    pub base: PathBuf,         // e.g., compile-test, auxiliary\n+    pub relative_dir: PathBuf, // e.g., foo/bar\n+}\n \n #[derive(Debug)]\n pub struct TestDescAndFn {"}]}