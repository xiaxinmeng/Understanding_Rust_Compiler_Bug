{"sha": "a125ec918fc228fc20da4642d17bc178a99a5d72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMjVlYzkxOGZjMjI4ZmMyMGRhNDY0MmQxN2JjMTc4YTk5YTVkNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-24T10:02:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-24T10:02:18Z"}, "message": "Auto merge of #43907 - euclio:command, r=alexcrichton\n\nUse std::process::Command throughout compile-test\n\nResubmission of #43798.\n\nFixes #43762.\n\nr? @alexcrichton", "tree": {"sha": "401e62ecf9ebf285bc3572125d8783388895982e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/401e62ecf9ebf285bc3572125d8783388895982e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a125ec918fc228fc20da4642d17bc178a99a5d72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a125ec918fc228fc20da4642d17bc178a99a5d72", "html_url": "https://github.com/rust-lang/rust/commit/a125ec918fc228fc20da4642d17bc178a99a5d72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a125ec918fc228fc20da4642d17bc178a99a5d72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a12e4f8098438cbfa65361647742e3c026574cb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a12e4f8098438cbfa65361647742e3c026574cb5", "html_url": "https://github.com/rust-lang/rust/commit/a12e4f8098438cbfa65361647742e3c026574cb5"}, {"sha": "91bfe3f55bddf508624a39eec9da859f911f966c", "url": "https://api.github.com/repos/rust-lang/rust/commits/91bfe3f55bddf508624a39eec9da859f911f966c", "html_url": "https://github.com/rust-lang/rust/commit/91bfe3f55bddf508624a39eec9da859f911f966c"}], "stats": {"total": 691, "additions": 240, "deletions": 451}, "files": [{"sha": "20239e974788bfac32b6fa34aa4ca9ab8e0ab219", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a125ec918fc228fc20da4642d17bc178a99a5d72/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a125ec918fc228fc20da4642d17bc178a99a5d72/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=a125ec918fc228fc20da4642d17bc178a99a5d72", "patch": "@@ -39,7 +39,6 @@ use util::logv;\n \n use self::header::EarlyProps;\n \n-pub mod procsrv;\n pub mod util;\n mod json;\n pub mod header;"}, {"sha": "ffcc60e78529247e1cd3ccd97a78c02d4a10b38f", "filename": "src/tools/compiletest/src/procsrv.rs", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/a12e4f8098438cbfa65361647742e3c026574cb5/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12e4f8098438cbfa65361647742e3c026574cb5/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs?ref=a12e4f8098438cbfa65361647742e3c026574cb5", "patch": "@@ -1,134 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::env;\n-use std::ffi::OsString;\n-use std::io::prelude::*;\n-use std::io;\n-use std::path::PathBuf;\n-use std::process::{Child, Command, ExitStatus, Output, Stdio};\n-\n-/// Get the name of the environment variable that holds dynamic library\n-/// locations\n-pub fn dylib_env_var() -> &'static str {\n-    if cfg!(windows) {\n-        \"PATH\"\n-    } else if cfg!(target_os = \"macos\") {\n-        \"DYLD_LIBRARY_PATH\"\n-    } else if cfg!(target_os = \"haiku\") {\n-        \"LIBRARY_PATH\"\n-    } else {\n-        \"LD_LIBRARY_PATH\"\n-    }\n-}\n-\n-/// Add `lib_path` and `aux_path` (if it is `Some`) to the dynamic library\n-/// env var\n-fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n-    // Need to be sure to put both the lib_path and the aux path in the dylib\n-    // search path for the child.\n-    let var = dylib_env_var();\n-    let mut path = env::split_paths(&env::var_os(var).unwrap_or(OsString::new()))\n-        .collect::<Vec<_>>();\n-    if let Some(p) = aux_path {\n-        path.insert(0, PathBuf::from(p))\n-    }\n-    path.insert(0, PathBuf::from(lib_path));\n-\n-    // Add the new dylib search path var\n-    let newpath = env::join_paths(&path).unwrap();\n-    cmd.env(var, newpath);\n-}\n-\n-/// Represents exit status, stdout and stderr of a completed process\n-pub struct Result {\n-    pub status: ExitStatus,\n-    pub out: String,\n-    pub err: String,\n-}\n-\n-/// Runs a test program\n-///\n-/// # Params\n-///  - `lib_path` Path to search for required library\n-///  - `prog` command to run\n-///  - `aux_path` Optional extra path to search for required\n-///    auxiliary libraries\n-///  - `args` List of arguments to pass to `prog`\n-///  - `env` List of environment variables to set, `.0` is variable name,\n-///    `.1` is value\n-///  - `input` String to be fed as stdin\n-///  - `current_dir` Optional working dir to run command in\n-///\n-pub fn run(lib_path: &str,\n-           prog: &str,\n-           aux_path: Option<&str>,\n-           args: &[String],\n-           env: Vec<(String, String)>,\n-           input: Option<String>,\n-           current_dir: Option<String>)\n-           -> io::Result<Result> {\n-\n-    let mut cmd = Command::new(prog);\n-    cmd.args(args)\n-        .stdout(Stdio::piped())\n-        .stderr(Stdio::piped())\n-        .stdin(Stdio::piped());\n-\n-    add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env {\n-        cmd.env(&key, &val);\n-    }\n-    if let Some(cwd) = current_dir {\n-        cmd.current_dir(cwd);\n-    }\n-\n-    let mut process = cmd.spawn()?;\n-    if let Some(input) = input {\n-        process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n-    }\n-    let Output { status, stdout, stderr } = process.wait_with_output().unwrap();\n-\n-    Ok(Result {\n-        status,\n-        out: String::from_utf8(stdout).unwrap(),\n-        err: String::from_utf8(stderr).unwrap(),\n-    })\n-}\n-\n-/// Same as `run`, but return process rather than waiting on completion\n-pub fn run_background(lib_path: &str,\n-                      prog: &str,\n-                      aux_path: Option<&str>,\n-                      args: &[String],\n-                      env: Vec<(String, String)>,\n-                      input: Option<String>,\n-                      current_dir: Option<String>)\n-                      -> io::Result<Child> {\n-\n-    let mut cmd = Command::new(prog);\n-    cmd.args(args)\n-       .stdin(Stdio::piped())\n-       .stdout(Stdio::piped());\n-    add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env {\n-        cmd.env(&key, &val);\n-    }\n-    if let Some(cwd) = current_dir {\n-        cmd.current_dir(cwd);\n-    }\n-\n-    let mut process = cmd.spawn()?;\n-    if let Some(input) = input {\n-        process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n-    }\n-\n-    Ok(process)\n-}"}, {"sha": "d2a0c776b33e683f4c830b62bd458d2de45cce6a", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 240, "deletions": 316, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/a125ec918fc228fc20da4642d17bc178a99a5d72/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a125ec918fc228fc20da4642d17bc178a99a5d72/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a125ec918fc228fc20da4642d17bc178a99a5d72", "patch": "@@ -17,22 +17,35 @@ use errors::{self, ErrorKind, Error};\n use filetime::FileTime;\n use json;\n use header::TestProps;\n-use procsrv;\n use test::TestPaths;\n use util::logv;\n \n+use std::collections::HashMap;\n use std::collections::HashSet;\n use std::env;\n+use std::ffi::OsString;\n use std::fs::{self, File, create_dir_all};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Output, ExitStatus};\n+use std::process::{Command, Output, ExitStatus, Stdio};\n use std::str;\n-use std::collections::HashMap;\n \n use extract_gdb_version;\n \n+/// The name of the environment variable that holds dynamic library locations.\n+pub fn dylib_env_var() -> &'static str {\n+    if cfg!(windows) {\n+        \"PATH\"\n+    } else if cfg!(target_os = \"macos\") {\n+        \"DYLD_LIBRARY_PATH\"\n+    } else if cfg!(target_os = \"haiku\") {\n+        \"LIBRARY_PATH\"\n+    } else {\n+        \"LD_LIBRARY_PATH\"\n+    }\n+}\n+\n pub fn run(config: Config, testpaths: &TestPaths) {\n     match &*config.target {\n \n@@ -325,37 +338,23 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn print_source(&self,\n-                    src: String,\n-                    pretty_type: &str)\n-                    -> ProcRes {\n+    fn print_source(&self, src: String, pretty_type: &str) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n-        self.compose_and_run(self.make_pp_args(pretty_type.to_owned()),\n-                             self.props.exec_env.clone(),\n+\n+        let mut rustc = Command::new(&self.config.rustc_path);\n+        rustc.arg(\"-\")\n+            .arg(\"-Zunstable-options\")\n+            .args(&[\"--unpretty\", &pretty_type])\n+            .args(&[\"--target\", &self.config.target])\n+            .arg(\"-L\").arg(&aux_dir)\n+            .args(self.split_maybe_args(&self.config.target_rustcflags))\n+            .args(&self.props.compile_flags)\n+            .envs(self.props.exec_env.clone());\n+\n+        self.compose_and_run(rustc,\n                              self.config.compile_lib_path.to_str().unwrap(),\n                              Some(aux_dir.to_str().unwrap()),\n-                             Some(src),\n-                             None)\n-    }\n-\n-    fn make_pp_args(&self,\n-                    pretty_type: String)\n-                    -> ProcArgs {\n-        let aux_dir = self.aux_output_dir_name();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec![\"-\".to_owned(),\n-                            \"-Zunstable-options\".to_owned(),\n-                            \"--unpretty\".to_owned(),\n-                            pretty_type,\n-                            format!(\"--target={}\", self.config.target),\n-                            \"-L\".to_owned(),\n-                            aux_dir.to_str().unwrap().to_owned()];\n-        args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n-        args.extend(self.props.compile_flags.iter().cloned());\n-        ProcArgs {\n-            prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n-            args,\n-        }\n+                             Some(src))\n     }\n \n     fn compare_source(&self,\n@@ -379,45 +378,35 @@ actual:\\n\\\n     }\n \n     fn typecheck_source(&self, src: String) -> ProcRes {\n-        let args = self.make_typecheck_args();\n-        self.compose_and_run_compiler(args, Some(src))\n-    }\n+        let mut rustc = Command::new(&self.config.rustc_path);\n+\n+        let out_dir = self.output_base_name().with_extension(\"pretty-out\");\n+        let _ = fs::remove_dir_all(&out_dir);\n+        create_dir_all(&out_dir).unwrap();\n \n-    fn make_typecheck_args(&self) -> ProcArgs {\n-        let aux_dir = self.aux_output_dir_name();\n         let target = if self.props.force_host {\n             &*self.config.host\n         } else {\n             &*self.config.target\n         };\n \n-        let out_dir = self.output_base_name().with_extension(\"pretty-out\");\n-        let _ = fs::remove_dir_all(&out_dir);\n-        create_dir_all(&out_dir).unwrap();\n+        let aux_dir = self.aux_output_dir_name();\n+\n+        rustc.arg(\"-\")\n+            .arg(\"-Zno-trans\")\n+            .arg(\"--out-dir\").arg(&out_dir)\n+            .arg(&format!(\"--target={}\", target))\n+            .arg(\"-L\").arg(&self.config.build_base)\n+            .arg(\"-L\").arg(aux_dir);\n \n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec![\"-\".to_owned(),\n-                            \"-Zno-trans\".to_owned(),\n-                            \"--out-dir\".to_owned(),\n-                            out_dir.to_str().unwrap().to_owned(),\n-                            format!(\"--target={}\", target),\n-                            \"-L\".to_owned(),\n-                            self.config.build_base.to_str().unwrap().to_owned(),\n-                            \"-L\".to_owned(),\n-                            aux_dir.to_str().unwrap().to_owned()];\n         if let Some(revision) = self.revision {\n-            args.extend(vec![\n-                \"--cfg\".to_string(),\n-                revision.to_string(),\n-            ]);\n-        }\n-        args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n-        args.extend(self.props.compile_flags.iter().cloned());\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        ProcArgs {\n-            prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n-            args,\n+            rustc.args(&[\"--cfg\", revision]);\n         }\n+\n+        rustc.args(self.split_maybe_args(&self.config.target_rustcflags));\n+        rustc.args(&self.props.compile_flags);\n+\n+        self.compose_and_run_compiler(rustc, Some(src))\n     }\n \n     fn run_debuginfo_gdb_test(&self) {\n@@ -500,32 +489,19 @@ actual:\\n\\\n                 debug!(\"script_str = {}\", script_str);\n                 self.dump_output_file(&script_str, \"debugger.script\");\n \n+                let adb_path = &self.config.adb_path;\n \n-                procsrv::run(\"\",\n-                             &self.config.adb_path,\n-                             None,\n-                             &[\n-                                 \"push\".to_owned(),\n-                                 exe_file.to_str().unwrap().to_owned(),\n-                                 self.config.adb_test_dir.clone()\n-                             ],\n-                             Vec::new(),\n-                             None,\n-                             None)\n-                    .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n-\n-                procsrv::run(\"\",\n-                             &self.config.adb_path,\n-                             None,\n-                             &[\n-                                 \"forward\".to_owned(),\n-                                 \"tcp:5039\".to_owned(),\n-                                 \"tcp:5039\".to_owned()\n-                             ],\n-                             Vec::new(),\n-                             None,\n-                             None)\n-                    .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n+                Command::new(adb_path)\n+                    .arg(\"push\")\n+                    .arg(&exe_file)\n+                    .arg(&self.config.adb_test_dir)\n+                    .status()\n+                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n+\n+                Command::new(adb_path)\n+                    .args(&[\"forward\", \"tcp:5039\", \"tcp:5039\"])\n+                    .status()\n+                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n \n                 let adb_arg = format!(\"export LD_LIBRARY_PATH={}; \\\n                                        gdbserver{} :5039 {}/{}\",\n@@ -537,23 +513,17 @@ actual:\\n\\\n                                       .unwrap());\n \n                 debug!(\"adb arg: {}\", adb_arg);\n-                let mut process = procsrv::run_background(\"\",\n-                                                          &self.config.adb_path\n-                                                          ,\n-                                                          None,\n-                                                          &[\n-                                                              \"shell\".to_owned(),\n-                                                              adb_arg.clone()\n-                                                          ],\n-                                                          Vec::new(),\n-                                                          None,\n-                                                          None)\n-                    .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n+                let mut adb = Command::new(adb_path)\n+                    .args(&[\"shell\", &adb_arg])\n+                    .stdout(Stdio::piped())\n+                    .stderr(Stdio::inherit())\n+                    .spawn()\n+                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n \n                 // Wait for the gdbserver to print out \"Listening on port ...\"\n                 // at which point we know that it's started and then we can\n                 // execute the debugger below.\n-                let mut stdout = BufReader::new(process.stdout.take().unwrap());\n+                let mut stdout = BufReader::new(adb.stdout.take().unwrap());\n                 let mut line = String::new();\n                 loop {\n                     line.truncate(0);\n@@ -574,33 +544,29 @@ actual:\\n\\\n \n                 let mut gdb_path = tool_path;\n                 gdb_path.push_str(\"/bin/gdb\");\n-                let procsrv::Result {\n-                    out,\n-                    err,\n-                    status\n-                } = procsrv::run(\"\",\n-                                 &gdb_path,\n-                                 None,\n-                                 &debugger_opts,\n-                                 Vec::new(),\n-                                 None,\n-                                 None)\n+                let Output {\n+                    status,\n+                    stdout,\n+                    stderr\n+                } = Command::new(&gdb_path)\n+                    .args(&debugger_opts)\n+                    .output()\n                     .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n                 let cmdline = {\n-                    let cmdline = self.make_cmdline(\"\",\n-                                                    &format!(\"{}-gdb\", self.config.target),\n-                                                    &debugger_opts);\n+                    let mut gdb = Command::new(&format!(\"{}-gdb\", self.config.target));\n+                    gdb.args(&debugger_opts);\n+                    let cmdline = self.make_cmdline(&gdb, \"\");\n                     logv(self.config, format!(\"executing {}\", cmdline));\n                     cmdline\n                 };\n \n                 debugger_run_result = ProcRes {\n                     status,\n-                    stdout: out,\n-                    stderr: err,\n+                    stdout: String::from_utf8(stdout).unwrap(),\n+                    stderr: String::from_utf8(stderr).unwrap(),\n                     cmdline,\n                 };\n-                if process.kill().is_err() {\n+                if adb.kill().is_err() {\n                     println!(\"Adb process is already finished.\");\n                 }\n             }\n@@ -679,19 +645,14 @@ actual:\\n\\\n                          \"-nx\".to_owned(),\n                          format!(\"-command={}\", debugger_script.to_str().unwrap())];\n \n-                let proc_args = ProcArgs {\n-                    prog: self.config.gdb.as_ref().unwrap().to_owned(),\n-                    args: debugger_opts,\n-                };\n-\n-                let environment = vec![(\"PYTHONPATH\".to_owned(), rust_pp_module_abs_path)];\n+                let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n+                gdb.args(&debugger_opts)\n+                    .env(\"PYTHONPATH\", rust_pp_module_abs_path);\n \n                 debugger_run_result =\n-                    self.compose_and_run(proc_args,\n-                                         environment,\n+                    self.compose_and_run(gdb,\n                                          self.config.run_lib_path.to_str().unwrap(),\n                                          None,\n-                                         None,\n                                          None);\n             }\n         }\n@@ -1154,26 +1115,24 @@ actual:\\n\\\n     }\n \n     fn compile_test(&self) -> ProcRes {\n-        let aux_dir = self.aux_output_dir_name();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut extra_args = vec![\"-L\".to_owned(),\n-                                  aux_dir.to_str().unwrap().to_owned()];\n+        let mut rustc = self.make_compile_args(\n+            &self.testpaths.file, TargetLocation::ThisFile(self.make_exe_name()));\n+\n+        rustc.arg(\"-L\").arg(&self.aux_output_dir_name());\n+\n         match self.config.mode {\n             CompileFail | Ui => {\n                 // compile-fail and ui tests tend to have tons of unused code as\n                 // it's just testing various pieces of the compile, but we don't\n                 // want to actually assert warnings about all this code. Instead\n                 // let's just ignore unused code warnings by defaults and tests\n                 // can turn it back on if needed.\n-                extra_args.push(\"-A\".to_owned());\n-                extra_args.push(\"unused\".to_owned());\n+                rustc.args(&[\"-A\", \"unused\"]);\n             }\n             _ => {}\n         }\n-        let args = self.make_compile_args(extra_args,\n-                                          &self.testpaths.file,\n-                                          TargetLocation::ThisFile(self.make_exe_name()));\n-        self.compose_and_run_compiler(args, None)\n+\n+        self.compose_and_run_compiler(rustc, None)\n     }\n \n     fn document(&self, out_dir: &Path) -> ProcRes {\n@@ -1197,22 +1156,20 @@ actual:\\n\\\n         }\n \n         let aux_dir = self.aux_output_dir_name();\n-        let mut args = vec![\"-L\".to_owned(),\n-                            aux_dir.to_str().unwrap().to_owned(),\n-                            \"-o\".to_owned(),\n-                            out_dir.to_str().unwrap().to_owned(),\n-                            self.testpaths.file.to_str().unwrap().to_owned()];\n-        args.extend(self.props.compile_flags.iter().cloned());\n-        let args = ProcArgs {\n-            prog: self.config.rustdoc_path\n-                .as_ref().expect(\"--rustdoc-path passed\").to_str().unwrap().to_owned(),\n-            args,\n-        };\n-        self.compose_and_run_compiler(args, None)\n+\n+        let rustdoc_path = self.config.rustdoc_path.as_ref().expect(\"--rustdoc-path passed\");\n+        let mut rustdoc = Command::new(rustdoc_path);\n+\n+        rustdoc.arg(\"-L\").arg(aux_dir)\n+            .arg(\"-o\").arg(out_dir)\n+            .arg(&self.testpaths.file)\n+            .args(&self.props.compile_flags);\n+\n+        self.compose_and_run_compiler(rustdoc, None)\n     }\n \n     fn exec_compiled_test(&self) -> ProcRes {\n-        let env = self.props.exec_env.clone();\n+        let env = &self.props.exec_env;\n \n         match &*self.config.target {\n             // This is pretty similar to below, we're transforming:\n@@ -1230,41 +1187,39 @@ actual:\\n\\\n             // the process) and then report back the same result.\n             _ if self.config.remote_test_client.is_some() => {\n                 let aux_dir = self.aux_output_dir_name();\n-                let mut args = self.make_run_args();\n-                let mut program = args.prog.clone();\n+                let ProcArgs { mut prog, args } = self.make_run_args();\n                 if let Ok(entries) = aux_dir.read_dir() {\n                     for entry in entries {\n                         let entry = entry.unwrap();\n                         if !entry.path().is_file() {\n                             continue\n                         }\n-                        program.push_str(\":\");\n-                        program.push_str(entry.path().to_str().unwrap());\n+                        prog.push_str(\":\");\n+                        prog.push_str(entry.path().to_str().unwrap());\n                     }\n                 }\n-                args.args.insert(0, program);\n-                args.args.insert(0, \"run\".to_string());\n-                args.prog = self.config.remote_test_client.clone().unwrap()\n-                                .into_os_string().into_string().unwrap();\n-                self.compose_and_run(args,\n-                                     env,\n+                let mut test_client = Command::new(\n+                    self.config.remote_test_client.as_ref().unwrap());\n+                test_client\n+                    .args(&[\"run\", &prog])\n+                    .args(args)\n+                    .envs(env.clone());\n+                self.compose_and_run(test_client,\n                                      self.config.run_lib_path.to_str().unwrap(),\n                                      Some(aux_dir.to_str().unwrap()),\n-                                     None,\n                                      None)\n             }\n             _ => {\n                 let aux_dir = self.aux_output_dir_name();\n-                let working_dir =\n-                    Some(self.output_base_name()\n-                             .parent().unwrap()\n-                             .to_str().unwrap().to_owned());\n-                self.compose_and_run(self.make_run_args(),\n-                                     env,\n+                let ProcArgs { prog, args } = self.make_run_args();\n+                let mut program = Command::new(&prog);\n+                program.args(args)\n+                    .current_dir(&self.output_base_name().parent().unwrap())\n+                    .envs(env.clone());\n+                self.compose_and_run(program,\n                                      self.config.run_lib_path.to_str().unwrap(),\n                                      Some(aux_dir.to_str().unwrap()),\n-                                     None,\n-                                     working_dir)\n+                                     None)\n             }\n         }\n     }\n@@ -1293,23 +1248,33 @@ actual:\\n\\\n         }\n     }\n \n-    fn compose_and_run_compiler(&self, args: ProcArgs, input: Option<String>) -> ProcRes {\n+    fn compose_and_run_compiler(&self, mut rustc: Command, input: Option<String>) -> ProcRes {\n         if !self.props.aux_builds.is_empty() {\n             create_dir_all(&self.aux_output_dir_name()).unwrap();\n         }\n \n         let aux_dir = self.aux_output_dir_name();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let extra_link_args = vec![\"-L\".to_owned(),\n-                                   aux_dir.to_str().unwrap().to_owned()];\n \n         for rel_ab in &self.props.aux_builds {\n             let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n             let aux_props = self.props.from_aux_file(&aux_testpaths.file,\n                                                      self.revision,\n                                                      self.config);\n-            let mut crate_type = if aux_props.no_prefer_dynamic {\n-                Vec::new()\n+            let aux_output = {\n+                let f = self.make_lib_name(&self.testpaths.file);\n+                let parent = f.parent().unwrap();\n+                TargetLocation::ThisDirectory(parent.to_path_buf())\n+            };\n+            let aux_cx = TestCx {\n+                config: self.config,\n+                props: &aux_props,\n+                testpaths: &aux_testpaths,\n+                revision: self.revision\n+            };\n+            let mut aux_rustc = aux_cx.make_compile_args(&aux_testpaths.file, aux_output);\n+\n+            let crate_type = if aux_props.no_prefer_dynamic {\n+                None\n             } else if (self.config.target.contains(\"musl\") && !aux_props.force_host) ||\n                       self.config.target.contains(\"emscripten\") {\n                 // We primarily compile all auxiliary libraries as dynamic libraries\n@@ -1321,28 +1286,20 @@ actual:\\n\\\n                 // dynamic libraries so we just go back to building a normal library. Note,\n                 // however, that for MUSL if the library is built with `force_host` then\n                 // it's ok to be a dylib as the host should always support dylibs.\n-                vec![\"--crate-type=lib\".to_owned()]\n+                Some(\"lib\")\n             } else {\n-                vec![\"--crate-type=dylib\".to_owned()]\n-            };\n-            crate_type.extend(extra_link_args.clone());\n-            let aux_output = {\n-                let f = self.make_lib_name(&self.testpaths.file);\n-                let parent = f.parent().unwrap();\n-                TargetLocation::ThisDirectory(parent.to_path_buf())\n+                Some(\"dylib\")\n             };\n-            let aux_cx = TestCx {\n-                config: self.config,\n-                props: &aux_props,\n-                testpaths: &aux_testpaths,\n-                revision: self.revision\n-            };\n-            let aux_args = aux_cx.make_compile_args(crate_type, &aux_testpaths.file, aux_output);\n-            let auxres = aux_cx.compose_and_run(aux_args,\n-                                                Vec::new(),\n+\n+            if let Some(crate_type) = crate_type {\n+                aux_rustc.args(&[\"--crate-type\", crate_type]);\n+            }\n+\n+            aux_rustc.arg(\"-L\").arg(&aux_dir);\n+\n+            let auxres = aux_cx.compose_and_run(aux_rustc,\n                                                 aux_cx.config.compile_lib_path.to_str().unwrap(),\n                                                 Some(aux_dir.to_str().unwrap()),\n-                                                None,\n                                                 None);\n             if !auxres.status.success() {\n                 self.fatal_proc_rec(\n@@ -1352,67 +1309,89 @@ actual:\\n\\\n             }\n         }\n \n-        self.compose_and_run(args,\n-                             self.props.rustc_env.clone(),\n+        rustc.envs(self.props.rustc_env.clone());\n+        self.compose_and_run(rustc,\n                              self.config.compile_lib_path.to_str().unwrap(),\n                              Some(aux_dir.to_str().unwrap()),\n-                             input,\n-                             None)\n+                             input)\n     }\n \n     fn compose_and_run(&self,\n-                       ProcArgs{ args, prog }: ProcArgs,\n-                       procenv: Vec<(String, String)> ,\n+                       mut command: Command,\n                        lib_path: &str,\n                        aux_path: Option<&str>,\n-                       input: Option<String>,\n-                       working_dir: Option<String>) -> ProcRes {\n-        self.program_output(lib_path, prog, aux_path, args, procenv, input, working_dir)\n-    }\n+                       input: Option<String>) -> ProcRes {\n+        let cmdline =\n+        {\n+            let cmdline = self.make_cmdline(&command, lib_path);\n+            logv(self.config, format!(\"executing {}\", cmdline));\n+            cmdline\n+        };\n \n-    fn make_compile_args(&self,\n-                         extras: Vec<String> ,\n-                         input_file: &Path,\n-                         output_file: TargetLocation)\n-                         -> ProcArgs\n-    {\n-        let target = if self.props.force_host {\n-            &*self.config.host\n-        } else {\n-            &*self.config.target\n+        command\n+            .stdout(Stdio::piped())\n+            .stderr(Stdio::piped())\n+            .stdin(Stdio::piped());\n+\n+        // Need to be sure to put both the lib_path and the aux path in the dylib\n+        // search path for the child.\n+        let mut path = env::split_paths(&env::var_os(dylib_env_var()).unwrap_or(OsString::new()))\n+            .collect::<Vec<_>>();\n+        if let Some(p) = aux_path {\n+            path.insert(0, PathBuf::from(p))\n+        }\n+        path.insert(0, PathBuf::from(lib_path));\n+\n+        // Add the new dylib search path var\n+        let newpath = env::join_paths(&path).unwrap();\n+        command.env(dylib_env_var(), newpath);\n+\n+        let mut child = command.spawn().expect(&format!(\"failed to exec `{:?}`\", &command));\n+        if let Some(input) = input {\n+            child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n+        }\n+        let Output { status, stdout, stderr } = child.wait_with_output().unwrap();\n+\n+        let result = ProcRes {\n+            status,\n+            stdout: String::from_utf8(stdout).unwrap(),\n+            stderr: String::from_utf8(stderr).unwrap(),\n+            cmdline,\n         };\n \n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec![input_file.to_str().unwrap().to_owned(),\n-                            \"-L\".to_owned(),\n-                            self.config.build_base.to_str().unwrap().to_owned()];\n+        self.dump_output(&result.stdout, &result.stderr);\n+\n+        result\n+    }\n+\n+    fn make_compile_args(&self, input_file: &Path, output_file: TargetLocation) -> Command {\n+        let mut rustc = Command::new(&self.config.rustc_path);\n+        rustc.arg(input_file)\n+            .arg(\"-L\").arg(&self.config.build_base);\n \n         // Optionally prevent default --target if specified in test compile-flags.\n         let custom_target = self.props.compile_flags\n             .iter()\n             .fold(false, |acc, x| acc || x.starts_with(\"--target\"));\n \n         if !custom_target {\n-            args.extend(vec![\n-                format!(\"--target={}\", target),\n-            ]);\n+            let target = if self.props.force_host {\n+                &*self.config.host\n+            } else {\n+                &*self.config.target\n+            };\n+\n+            rustc.arg(&format!(\"--target={}\", target));\n         }\n \n         if let Some(revision) = self.revision {\n-            args.extend(vec![\n-                \"--cfg\".to_string(),\n-                revision.to_string(),\n-            ]);\n+            rustc.args(&[\"--cfg\", revision]);\n         }\n \n         if let Some(ref incremental_dir) = self.props.incremental_dir {\n-            args.extend(vec![\n-                \"-Z\".to_string(),\n-                format!(\"incremental={}\", incremental_dir.display()),\n-            ]);\n+            rustc.args(&[\"-Z\", &format!(\"incremental={}\", incremental_dir.display())]);\n         }\n \n-\n         match self.config.mode {\n             CompileFail |\n             ParseFail |\n@@ -1421,27 +1400,22 @@ actual:\\n\\\n                 // fashion, then you want JSON mode. Old-skool error\n                 // patterns still match the raw compiler output.\n                 if self.props.error_patterns.is_empty() {\n-                    args.extend([\"--error-format\",\n-                                 \"json\"]\n-                                .iter()\n-                                .map(|s| s.to_string()));\n+                    rustc.args(&[\"--error-format\", \"json\"]);\n                 }\n             }\n             MirOpt => {\n-                args.extend([\"-Zdump-mir=all\",\n-                             \"-Zmir-opt-level=3\",\n-                             \"-Zdump-mir-exclude-pass-number\"]\n-                            .iter()\n-                            .map(|s| s.to_string()));\n-\n+                rustc.args(&[\n+                    \"-Zdump-mir=all\",\n+                    \"-Zmir-opt-level=3\",\n+                    \"-Zdump-mir-exclude-pass-number\"]);\n \n                 let mir_dump_dir = self.get_mir_dump_dir();\n                 create_dir_all(mir_dump_dir.as_path()).unwrap();\n                 let mut dir_opt = \"-Zdump-mir-dir=\".to_string();\n                 dir_opt.push_str(mir_dump_dir.to_str().unwrap());\n                 debug!(\"dir_opt: {:?}\", dir_opt);\n \n-                args.push(dir_opt);\n+                rustc.arg(dir_opt);\n             }\n             RunPass |\n             RunFail |\n@@ -1458,32 +1432,28 @@ actual:\\n\\\n             }\n         }\n \n-        args.extend_from_slice(&extras);\n         if !self.props.no_prefer_dynamic {\n-            args.push(\"-C\".to_owned());\n-            args.push(\"prefer-dynamic\".to_owned());\n+            rustc.args(&[\"-C\", \"prefer-dynamic\"]);\n         }\n-        let path = match output_file {\n+\n+        match output_file {\n             TargetLocation::ThisFile(path) => {\n-                args.push(\"-o\".to_owned());\n-                path\n+                rustc.arg(\"-o\").arg(path);\n             }\n             TargetLocation::ThisDirectory(path) => {\n-                args.push(\"--out-dir\".to_owned());\n-                path\n+                rustc.arg(\"--out-dir\").arg(path);\n             }\n-        };\n-        args.push(path.to_str().unwrap().to_owned());\n+        }\n+\n         if self.props.force_host {\n-            args.extend(self.split_maybe_args(&self.config.host_rustcflags));\n+            rustc.args(self.split_maybe_args(&self.config.host_rustcflags));\n         } else {\n-            args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n-        }\n-        args.extend(self.props.compile_flags.iter().cloned());\n-        ProcArgs {\n-            prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n-            args,\n+            rustc.args(self.split_maybe_args(&self.config.target_rustcflags));\n         }\n+\n+        rustc.args(&self.props.compile_flags);\n+\n+        rustc\n     }\n \n     fn make_lib_name(&self, auxfile: &Path) -> PathBuf {\n@@ -1554,58 +1524,20 @@ actual:\\n\\\n         }\n     }\n \n-    fn program_output(&self,\n-                      lib_path: &str,\n-                      prog: String,\n-                      aux_path: Option<&str>,\n-                      args: Vec<String>,\n-                      env: Vec<(String, String)>,\n-                      input: Option<String>,\n-                      working_dir: Option<String>)\n-                      -> ProcRes {\n-        let cmdline =\n-        {\n-            let cmdline = self.make_cmdline(lib_path,\n-                                            &prog,\n-                                            &args);\n-            logv(self.config, format!(\"executing {}\", cmdline));\n-            cmdline\n-        };\n-\n-        let procsrv::Result {\n-            out,\n-            err,\n-            status\n-        } = procsrv::run(lib_path,\n-                         &prog,\n-                         aux_path,\n-                         &args,\n-                         env,\n-                         input,\n-                         working_dir).expect(&format!(\"failed to exec `{}`\", prog));\n-        self.dump_output(&out, &err);\n-        ProcRes {\n-            status,\n-            stdout: out,\n-            stderr: err,\n-            cmdline,\n-        }\n-    }\n-\n-    fn make_cmdline(&self, libpath: &str, prog: &str, args: &[String]) -> String {\n+    fn make_cmdline(&self, command: &Command, libpath: &str) -> String {\n         use util;\n \n         // Linux and mac don't require adjusting the library search path\n         if cfg!(unix) {\n-            format!(\"{} {}\", prog, args.join(\" \"))\n+            format!(\"{:?}\", command)\n         } else {\n             // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n             // for diagnostic purposes\n             fn lib_path_cmd_prefix(path: &str) -> String {\n                 format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n             }\n \n-            format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog, args.join(\" \"))\n+            format!(\"{} {:?}\", lib_path_cmd_prefix(libpath), command)\n         }\n     }\n \n@@ -1723,30 +1655,22 @@ actual:\\n\\\n \n     fn compile_test_and_save_ir(&self) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut link_args = vec![\"-L\".to_owned(),\n-                                 aux_dir.to_str().unwrap().to_owned()];\n-        let llvm_args = vec![\"--emit=llvm-ir\".to_owned(),];\n-        link_args.extend(llvm_args);\n-        let args = self.make_compile_args(link_args,\n-                                          &self.testpaths.file,\n-                                          TargetLocation::ThisDirectory(\n-                                              self.output_base_name().parent()\n-                                                                     .unwrap()\n-                                                                     .to_path_buf()));\n-        self.compose_and_run_compiler(args, None)\n+\n+        let output_file = TargetLocation::ThisDirectory(\n+            self.output_base_name().parent().unwrap().to_path_buf());\n+        let mut rustc = self.make_compile_args(&self.testpaths.file, output_file);\n+        rustc.arg(\"-L\").arg(aux_dir)\n+            .arg(\"--emit=llvm-ir\");\n+\n+        self.compose_and_run_compiler(rustc, None)\n     }\n \n     fn check_ir_with_filecheck(&self) -> ProcRes {\n         let irfile = self.output_base_name().with_extension(\"ll\");\n-        let prog = self.config.llvm_filecheck.as_ref().unwrap();\n-        let proc_args = ProcArgs {\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            prog: prog.to_str().unwrap().to_owned(),\n-            args: vec![format!(\"-input-file={}\", irfile.to_str().unwrap()),\n-                       self.testpaths.file.to_str().unwrap().to_owned()]\n-        };\n-        self.compose_and_run(proc_args, Vec::new(), \"\", None, None, None)\n+        let mut filecheck = Command::new(self.config.llvm_filecheck.as_ref().unwrap());\n+        filecheck.arg(\"--input-file\").arg(irfile)\n+            .arg(&self.testpaths.file);\n+        self.compose_and_run(filecheck, \"\", None, None)\n     }\n \n     fn run_codegen_test(&self) {\n@@ -2179,7 +2103,7 @@ actual:\\n\\\n            .env(\"RUSTDOC\",\n                cwd.join(&self.config.rustdoc_path.as_ref().expect(\"--rustdoc-path passed\")))\n            .env(\"TMPDIR\", &tmpdir)\n-           .env(\"LD_LIB_PATH_ENVVAR\", procsrv::dylib_env_var())\n+           .env(\"LD_LIB_PATH_ENVVAR\", dylib_env_var())\n            .env(\"HOST_RPATH_DIR\", cwd.join(&self.config.compile_lib_path))\n            .env(\"TARGET_RPATH_DIR\", cwd.join(&self.config.run_lib_path))\n            .env(\"LLVM_COMPONENTS\", &self.config.llvm_components)"}]}