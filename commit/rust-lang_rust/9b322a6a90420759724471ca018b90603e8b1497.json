{"sha": "9b322a6a90420759724471ca018b90603e8b1497", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMzIyYTZhOTA0MjA3NTk3MjQ0NzFjYTAxOGI5MDYwM2U4YjE0OTc=", "commit": {"author": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-11-02T19:34:18Z"}, "committer": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-11-02T19:34:18Z"}, "message": "Treat cross-crate unboxed closure def IDs consistently\n\nAlways translate the ID into the local crate ID space since\npresently the only way to encounter an unboxed closure type\nfrom another crate is to inline once of its functions.\n\nThis may need to change if abstract return types are added.\n\nCloses #18543", "tree": {"sha": "133fb09c573a719cb5ad45ff89e44486f68c00c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/133fb09c573a719cb5ad45ff89e44486f68c00c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b322a6a90420759724471ca018b90603e8b1497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b322a6a90420759724471ca018b90603e8b1497", "html_url": "https://github.com/rust-lang/rust/commit/9b322a6a90420759724471ca018b90603e8b1497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b322a6a90420759724471ca018b90603e8b1497/comments", "author": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28f70d34400959cd2e0095d019b53dba244b900b", "url": "https://api.github.com/repos/rust-lang/rust/commits/28f70d34400959cd2e0095d019b53dba244b900b", "html_url": "https://github.com/rust-lang/rust/commit/28f70d34400959cd2e0095d019b53dba244b900b"}], "stats": {"total": 71, "additions": 40, "deletions": 31}, "files": [{"sha": "d475f6ddcbac7226c73a5e4ec0d79171cfd7a520", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b322a6a90420759724471ca018b90603e8b1497/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b322a6a90420759724471ca018b90603e8b1497/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9b322a6a90420759724471ca018b90603e8b1497", "patch": "@@ -56,6 +56,9 @@ pub enum DefIdSource {\n \n     // Identifies a region parameter (`fn foo<'X>() { ... }`).\n     RegionParameter,\n+\n+    // Identifies an unboxed closure\n+    UnboxedClosureSource\n }\n pub type conv_did<'a> =\n     |source: DefIdSource, ast::DefId|: 'a -> ast::DefId;\n@@ -465,7 +468,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def(st, NominalType, |x,y| conv(x,y));\n+          let did = parse_def(st, UnboxedClosureSource, |x,y| conv(x,y));\n           let region = parse_region(st, |x,y| conv(x,y));\n           let substs = parse_substs(st, |x,y| conv(x,y));\n           assert_eq!(next(st), ']');"}, {"sha": "a127566b67ee66c404165d6690338968a4d68d71", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b322a6a90420759724471ca018b90603e8b1497/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b322a6a90420759724471ca018b90603e8b1497/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9b322a6a90420759724471ca018b90603e8b1497", "patch": "@@ -21,7 +21,7 @@ use metadata::encoder as e;\n use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n-use metadata::tydecode::{RegionParameter};\n+use metadata::tydecode::{RegionParameter, UnboxedClosureSource};\n use metadata::tyencode;\n use middle::mem_categorization::Typer;\n use middle::subst;\n@@ -1801,13 +1801,17 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n          * case. We translate them with `tr_def_id()` which will map\n          * the crate numbers back to the original source crate.\n          *\n+         * Unboxed closures are cloned along with the function being\n+         * inlined, and all side tables use interned node IDs, so we\n+         * translate their def IDs accordingly.\n+         *\n          * It'd be really nice to refactor the type repr to not include\n          * def-ids so that all these distinctions were unnecessary.\n          */\n \n         let r = match source {\n             NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n-            TypeParameter => dcx.tr_intern_def_id(did)\n+            TypeParameter | UnboxedClosureSource => dcx.tr_intern_def_id(did)\n         };\n         debug!(\"convert_def_id(source={}, did={})={}\", source, did, r);\n         return r;"}, {"sha": "faeca0b188606168c0018dcd2f4ee00664da35ce", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9b322a6a90420759724471ca018b90603e8b1497/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b322a6a90420759724471ca018b90603e8b1497/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9b322a6a90420759724471ca018b90603e8b1497", "patch": "@@ -4632,35 +4632,37 @@ pub struct UnboxedClosureUpvar {\n // Returns a list of `UnboxedClosureUpvar`s for each upvar.\n pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Substs)\n                               -> Vec<UnboxedClosureUpvar> {\n-    if closure_id.krate == ast::LOCAL_CRATE {\n-        let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n-        match tcx.freevars.borrow().find(&closure_id.node) {\n-            None => vec![],\n-            Some(ref freevars) => {\n-                freevars.iter().map(|freevar| {\n-                    let freevar_def_id = freevar.def.def_id();\n-                    let freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n-                    let mut freevar_ty = freevar_ty.subst(tcx, substs);\n-                    if capture_mode == ast::CaptureByRef {\n-                        let borrow = tcx.upvar_borrow_map.borrow().get_copy(&ty::UpvarId {\n-                            var_id: freevar_def_id.node,\n-                            closure_expr_id: closure_id.node\n-                        });\n-                        freevar_ty = mk_rptr(tcx, borrow.region, ty::mt {\n-                            ty: freevar_ty,\n-                            mutbl: borrow.kind.to_mutbl_lossy()\n-                        });\n-                    }\n-                    UnboxedClosureUpvar {\n-                        def: freevar.def,\n-                        span: freevar.span,\n-                        ty: freevar_ty\n-                    }\n-                }).collect()\n-            }\n+    // Presently an unboxed closure type cannot \"escape\" out of a\n+    // function, so we will only encounter ones that originated in the\n+    // local crate or were inlined into it along with some function.\n+    // This may change if abstract return types of some sort are\n+    // implemented.\n+    assert!(closure_id.krate == ast::LOCAL_CRATE);\n+    let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n+    match tcx.freevars.borrow().find(&closure_id.node) {\n+        None => vec![],\n+        Some(ref freevars) => {\n+            freevars.iter().map(|freevar| {\n+                let freevar_def_id = freevar.def.def_id();\n+                let freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n+                let mut freevar_ty = freevar_ty.subst(tcx, substs);\n+                if capture_mode == ast::CaptureByRef {\n+                    let borrow = tcx.upvar_borrow_map.borrow().get_copy(&ty::UpvarId {\n+                        var_id: freevar_def_id.node,\n+                        closure_expr_id: closure_id.node\n+                    });\n+                    freevar_ty = mk_rptr(tcx, borrow.region, ty::mt {\n+                        ty: freevar_ty,\n+                        mutbl: borrow.kind.to_mutbl_lossy()\n+                    });\n+                }\n+                UnboxedClosureUpvar {\n+                    def: freevar.def,\n+                    span: freevar.span,\n+                    ty: freevar_ty\n+                }\n+            }).collect()\n         }\n-    } else {\n-        tcx.sess.bug(\"unimplemented cross-crate closure upvars\")\n     }\n }\n "}]}