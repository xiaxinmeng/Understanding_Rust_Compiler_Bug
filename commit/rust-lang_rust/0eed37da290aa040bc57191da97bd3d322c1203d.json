{"sha": "0eed37da290aa040bc57191da97bd3d322c1203d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZWQzN2RhMjkwYWEwNDBiYzU3MTkxZGE5N2JkM2QzMjJjMTIwM2Q=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-18T17:40:54Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-18T23:55:42Z"}, "message": "Using const vector slices for more vec functions.", "tree": {"sha": "56ffcf2838b97739c25e13923b99e823c99a74ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56ffcf2838b97739c25e13923b99e823c99a74ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eed37da290aa040bc57191da97bd3d322c1203d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eed37da290aa040bc57191da97bd3d322c1203d", "html_url": "https://github.com/rust-lang/rust/commit/0eed37da290aa040bc57191da97bd3d322c1203d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eed37da290aa040bc57191da97bd3d322c1203d/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f20cae37fd703f344d226170ebe440ab76fe565", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f20cae37fd703f344d226170ebe440ab76fe565", "html_url": "https://github.com/rust-lang/rust/commit/0f20cae37fd703f344d226170ebe440ab76fe565"}], "stats": {"total": 63, "additions": 39, "deletions": 24}, "files": [{"sha": "a53e863f2898bd74f52f6620b8e396a06b74bcb2", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=0eed37da290aa040bc57191da97bd3d322c1203d", "patch": "@@ -652,23 +652,25 @@ fn install_named(c: cargo, wd: str, name: str) {\n \n fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n     alt c.sources.find(src) {\n-        some(s) {\n-            if vec::any(copy s.packages, { |p|\n-                if p.uuid == uuid {\n-                    install_package(c, wd, p);\n-                    true\n-                } else { false }\n-            }) { ret; }\n-        }\n-        _ { }\n+      some(s) {\n+        let packages = copy s.packages;\n+        if vec::any(packages, { |p|\n+            if p.uuid == uuid {\n+                install_package(c, wd, p);\n+                true\n+            } else { false }\n+        }) { ret; }\n+      }\n+      _ { }\n     }\n     error(\"Can't find package \" + src + \"/\" + uuid);\n }\n \n fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n     alt c.sources.find(src) {\n         some(s) {\n-            if vec::any(copy s.packages, { |p|\n+          let packages = copy s.packages;\n+          if vec::any(packages, { |p|\n                 if p.name == name {\n                     install_package(c, wd, p);\n                     true"}, {"sha": "37f0ecb21158858ae6c14cc19caffd4c69c7dc94", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=0eed37da290aa040bc57191da97bd3d322c1203d", "patch": "@@ -33,6 +33,7 @@ export grow;\n export grow_fn;\n export grow_set;\n export map;\n+export mapi;\n export map2;\n export flat_map;\n export filter_map;\n@@ -440,13 +441,23 @@ fn grow_set<T: copy>(&v: [mut T], index: uint, initval: T, val: T) {\n #[doc = \"\n Apply a function to each element of a vector and return the results\n \"]\n-fn map<T, U>(v: [T], f: fn(T) -> U) -> [U] {\n+fn map<T, U>(v: [const T]/&, f: fn(T) -> U) -> [U] {\n     let mut result = [];\n     reserve(result, len(v));\n     for each(v) {|elem| result += [f(elem)]; }\n     ret result;\n }\n \n+#[doc = \"\n+Apply a function to each element of a vector and return the results\n+\"]\n+fn mapi<T, U>(v: [const T]/&, f: fn(uint, T) -> U) -> [U] {\n+    let mut result = [];\n+    reserve(result, len(v));\n+    for eachi(v) {|i, elem| result += [f(i, elem)]; }\n+    ret result;\n+}\n+\n #[doc = \"\n Apply a function to each element of a vector and return a concatenation\n of each result vector\n@@ -537,7 +548,7 @@ fn foldl<T: copy, U>(z: T, v: [const U], p: fn(T, U) -> T) -> T {\n }\n \n #[doc = \"Reduce a vector from right to left\"]\n-fn foldr<T, U: copy>(v: [const T], z: U, p: fn(T, U) -> U) -> U {\n+fn foldr<T, U: copy>(v: [const T]/&, z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n     riter(v) { |elt|\n         accum = p(elt, accum);\n@@ -550,7 +561,7 @@ Return true if a predicate matches any elements\n \n If the vector contains no elements then false is returned.\n \"]\n-fn any<T>(v: [T], f: fn(T) -> bool) -> bool {\n+fn any<T>(v: [const T]/&, f: fn(T) -> bool) -> bool {\n     for each(v) {|elem| if f(elem) { ret true; } }\n     ret false;\n }\n@@ -560,7 +571,7 @@ Return true if a predicate matches any elements in both vectors.\n \n If the vectors contains no elements then false is returned.\n \"]\n-fn any2<T, U>(v0: [const T], v1: [U], f: fn(T, U) -> bool) -> bool {\n+fn any2<T, U>(v0: [const T]/&, v1: [const U]/&, f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n     let mut i = 0u;\n@@ -576,7 +587,7 @@ Return true if a predicate matches all elements\n \n If the vector contains no elements then true is returned.\n \"]\n-fn all<T>(v: [T], f: fn(T) -> bool) -> bool {\n+fn all<T>(v: [const T]/&, f: fn(T) -> bool) -> bool {\n     for each(v) {|elem| if !f(elem) { ret false; } }\n     ret true;\n }\n@@ -586,7 +597,7 @@ Return true if a predicate matches all elements\n \n If the vector contains no elements then true is returned.\n \"]\n-fn alli<T>(v: [T], f: fn(uint, T) -> bool) -> bool {\n+fn alli<T>(v: [const T]/&, f: fn(uint, T) -> bool) -> bool {\n     for eachi(v) {|i, elem| if !f(i, elem) { ret false; } }\n     ret true;\n }\n@@ -596,7 +607,7 @@ Return true if a predicate matches all elements in both vectors.\n \n If the vectors are not the same size then false is returned.\n \"]\n-fn all2<T, U>(v0: [const T], v1: [const U], f: fn(T, U) -> bool) -> bool {\n+fn all2<T, U>(v0: [const T]/&, v1: [const U]/&, f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { ret false; }\n     let mut i = 0u;\n@@ -899,7 +910,7 @@ Iterates over a vector in reverse\n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value.\n \"]\n-fn riter<T>(v: [const T], f: fn(T)) {\n+fn riter<T>(v: [const T]/&, f: fn(T)) {\n     riteri(v) { |_i, v| f(v) }\n }\n \n@@ -909,7 +920,7 @@ Iterates over a vector's elements and indexes in reverse\n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value and index.\n \"]\n-fn riteri<T>(v: [const T], f: fn(uint, T)) {\n+fn riteri<T>(v: [const T]/&, f: fn(uint, T)) {\n     let mut i = len(v);\n     while 0u < i {\n         i -= 1u;\n@@ -1115,8 +1126,7 @@ impl extensions<T> for [T] {\n     and return the results\n     \"]\n     fn mapi<U>(f: fn(uint, T) -> U) -> [U] {\n-        let mut i = 0u;\n-        self.map { |e| i += 1u; f(i - 1u, e) }\n+        mapi(self, f)\n     }\n     #[doc = \"Returns true if the function returns true for all elements.\n "}, {"sha": "bbd4773470e26c38c00da154e22baf08c80d21e7", "filename": "src/librustsyntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fqquote.rs?ref=0eed37da290aa040bc57191da97bd3d322c1203d", "patch": "@@ -257,10 +257,11 @@ fn finish<T: qq_helper>\n                       );\n     let mut rcall = pcall;\n     if (g_len > 0u) {\n+        let gather = copy qcx.gather;\n         rcall = mk_call(cx,sp,\n                         [\"syntax\", \"ext\", \"qquote\", \"replace\"],\n                         [pcall,\n-                         mk_vec_e(cx,sp, vec::map(copy qcx.gather) {|g|\n+                         mk_vec_e(cx,sp, vec::map(gather) {|g|\n                              mk_call(cx,sp,\n                                      [\"syntax\", \"ext\", \"qquote\", g.constr],\n                                      [g.e])}),"}, {"sha": "c48e63a74d83a4dbfcf86ea08378a83ee91cbd57", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=0eed37da290aa040bc57191da97bd3d322c1203d", "patch": "@@ -213,7 +213,8 @@ fn run_tests_console(opts: test_opts,\n \n fn print_failures(st: console_test_state) {\n     st.out.write_line(\"\\nfailures:\");\n-    let failures = vec::map(copy st.failures) {|test| test.name};\n+    let failures = copy st.failures;\n+    let failures = vec::map(failures) {|test| test.name};\n     let failures = sort::merge_sort(str::le, failures);\n     for vec::each(failures) {|name|\n         st.out.write_line(#fmt[\"    %s\", name]);"}, {"sha": "7379c49aa96248915722838d336988afed10b5a5", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eed37da290aa040bc57191da97bd3d322c1203d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0eed37da290aa040bc57191da97bd3d322c1203d", "patch": "@@ -4012,7 +4012,8 @@ fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n     let mut bcx = bcx;\n     alt check cleanup_cx.kind {\n       block_scope({cleanups, _}) {\n-        vec::riter(copy cleanups) {|cu|\n+        let cleanups = copy cleanups;\n+        vec::riter(cleanups) {|cu|\n             alt cu {\n               clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) {\n                 // Some types don't need to be cleaned up during"}]}