{"sha": "ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmODljYzhmMDQyYTk4MGU3MmU5ZDAyNjJjMjY3YmZmZmQ5ZTc1ZmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2020-04-23T18:45:55Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2020-04-29T18:57:26Z"}, "message": "Store LLVM bitcode in object files, not compressed\n\nThis commit is an attempted resurrection of #70458 where LLVM bitcode\nemitted by rustc into rlibs is stored into object file sections rather\nthan in a separate file. The main rationale for doing this is that when\nrustc emits bitcode it will no longer use a custom compression scheme\nwhich makes it both easier to interoperate with existing tools and also\ncuts down on compile time since this compression isn't happening.\n\nThe blocker for this in #70458 turned out to be that native linkers\ndidn't handle the new sections well, causing the sections to either\ntrigger bugs in the linker or actually end up in the final linked\nartifact. This commit attempts to address these issues by ensuring that\nnative linkers ignore the new sections by inserting custom flags with\nmodule-level inline assembly.\n\nNote that this does not currently change the API of the compiler at all.\nThe pre-existing `-C bitcode-in-rlib` flag is co-opted to indicate\nwhether the bitcode should be present in the object file or not.\n\nFinally, note that an important consequence of this commit, which is also\none of its primary purposes, is to enable rustc's `-Clto` bitcode\nloading to load rlibs produced with `-Clinker-plugin-lto`. The goal here\nis that when you're building with LTO Cargo will tell rustc to skip\ncodegen of all intermediate crates and only generate LLVM IR. Today\nrustc will generate both object code and LLVM IR, but the object code is\nlater simply thrown away, wastefully.", "tree": {"sha": "82cc2d96faf8edf01975f5858876c4d16fb9b461", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82cc2d96faf8edf01975f5858876c4d16fb9b461"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "html_url": "https://github.com/rust-lang/rust/commit/ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "413a12909f3b149af17d75268ed4a136afb82c36", "url": "https://api.github.com/repos/rust-lang/rust/commits/413a12909f3b149af17d75268ed4a136afb82c36", "html_url": "https://github.com/rust-lang/rust/commit/413a12909f3b149af17d75268ed4a136afb82c36"}], "stats": {"total": 455, "additions": 189, "deletions": 266}, "files": [{"sha": "14ffe161c91f802e0bb277a1db8bf8a42655f276", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -7,6 +7,32 @@ a version of this list for your exact compiler by running `rustc -C help`.\n \n This option is deprecated and does nothing.\n \n+## bitcode-in-rlib\n+\n+This flag controls whether or not the compiler puts LLVM bitcode into generated\n+rlibs. It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: put bitcode in rlibs (the default).\n+* `n`, `no`, or `off`: omit bitcode from rlibs.\n+\n+LLVM bitcode is only needed when link-time optimization (LTO) is being\n+performed, but it is enabled by default for backwards compatibility reasons.\n+\n+The use of `-C bitcode-in-rlib=no` can significantly improve compile times and\n+reduce generated file sizes. For these reasons, Cargo uses `-C\n+bitcode-in-rlib=no` whenever possible. Likewise, if you are building directly\n+with `rustc` we recommend using `-C bitcode-in-rlib=no` whenever you are not\n+using LTO.\n+\n+If combined with `-C lto`, `-C bitcode-in-rlib=no` will cause `rustc` to abort\n+at start-up, because the combination is invalid.\n+\n+> **Note**: the implementation of this flag today is to enable the\n+> `-Zembed-bitcode` option. When bitcode is embedded into an rlib then all\n+> object files within the rlib will have a special section (typically named\n+> `.llvmbc`, depends on the platform though) which contains LLVM bytecode. This\n+> section of the object file will not appear in the final linked artifact.\n+\n ## code-model\n \n This option lets you choose which code model to use.\n@@ -387,26 +413,6 @@ This also supports the feature `+crt-static` and `-crt-static` to control\n Each target and [`target-cpu`](#target-cpu) has a default set of enabled\n features.\n \n-## bitcode-in-rlib\n-\n-This flag controls whether or not the compiler puts compressed LLVM bitcode\n-into generated rlibs. It takes one of the following values:\n-\n-* `y`, `yes`, `on`, or no value: put bitcode in rlibs (the default).\n-* `n`, `no`, or `off`: omit bitcode from rlibs.\n-\n-LLVM bitcode is only needed when link-time optimization (LTO) is being\n-performed, but it is enabled by default for backwards compatibility reasons.\n-\n-The use of `-C bitcode-in-rlib=no` can significantly improve compile times and\n-reduce generated file sizes. For these reasons, Cargo uses `-C\n-bitcode-in-rlib=no` whenever possible. Likewise, if you are building directly\n-with `rustc` we recommend using `-C bitcode-in-rlib=no` whenever you are not\n-using LTO.\n-\n-If combined with `-C lto`, `-C bitcode-in-rlib=no` will cause `rustc` to abort\n-at start-up, because the combination is invalid.\n-\n [option-emit]: ../command-line-arguments.md#option-emit\n [option-o-optimize]: ../command-line-arguments.md#option-o-optimize\n [profile-guided optimization]: ../profile-guided-optimization.md"}, {"sha": "a115a1e95163e64a9e27626aeae08a0f4e8f0173", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -10,7 +10,7 @@ use std::str;\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind};\n use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n-use rustc_codegen_ssa::{looks_like_rust_object_file, METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n+use rustc_codegen_ssa::{looks_like_rust_object_file, METADATA_FILENAME};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n \n@@ -129,8 +129,8 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n         let obj_start = name.to_owned();\n \n         self.add_archive(rlib, move |fname: &str| {\n-            // Ignore bytecode/metadata files, no matter the name.\n-            if fname.ends_with(RLIB_BYTECODE_EXTENSION) || fname == METADATA_FILENAME {\n+            // Ignore metadata files, no matter the name.\n+            if fname == METADATA_FILENAME {\n                 return true;\n             }\n "}, {"sha": "0c8ce39132abb51283b205432a01ee711b7863e5", "filename": "src/librustc_codegen_llvm/back/bytecode.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -1,141 +0,0 @@\n-//! Management of the encoding of LLVM bytecode into rlibs\n-//!\n-//! This module contains the management of encoding LLVM bytecode into rlibs,\n-//! primarily for the usage in LTO situations. Currently the compiler will\n-//! unconditionally encode LLVM-IR into rlibs regardless of what's happening\n-//! elsewhere, so we currently compress the bytecode via deflate to avoid taking\n-//! up too much space on disk.\n-//!\n-//! After compressing the bytecode we then have the rest of the format to\n-//! basically deal with various bugs in various archive implementations. The\n-//! format currently is:\n-//!\n-//!     RLIB LLVM-BYTECODE OBJECT LAYOUT\n-//!     Version 2\n-//!     Bytes    Data\n-//!     0..10    \"RUST_OBJECT\" encoded in ASCII\n-//!     11..14   format version as little-endian u32\n-//!     15..19   the length of the module identifier string\n-//!     20..n    the module identifier string\n-//!     n..n+8   size in bytes of deflate compressed LLVM bitcode as\n-//!              little-endian u64\n-//!     n+9..    compressed LLVM bitcode\n-//!     ?        maybe a byte to make this whole thing even length\n-\n-use std::io::{Read, Write};\n-use std::ptr;\n-use std::str;\n-\n-use flate2::read::DeflateDecoder;\n-use flate2::write::DeflateEncoder;\n-use flate2::Compression;\n-\n-// This is the \"magic number\" expected at the beginning of a LLVM bytecode\n-// object in an rlib.\n-pub const RLIB_BYTECODE_OBJECT_MAGIC: &[u8] = b\"RUST_OBJECT\";\n-\n-// The version number this compiler will write to bytecode objects in rlibs\n-pub const RLIB_BYTECODE_OBJECT_VERSION: u8 = 2;\n-\n-pub fn encode(identifier: &str, bytecode: &[u8]) -> Vec<u8> {\n-    let mut encoded = Vec::new();\n-\n-    // Start off with the magic string\n-    encoded.extend_from_slice(RLIB_BYTECODE_OBJECT_MAGIC);\n-\n-    // Next up is the version\n-    encoded.extend_from_slice(&[RLIB_BYTECODE_OBJECT_VERSION, 0, 0, 0]);\n-\n-    // Next is the LLVM module identifier length + contents\n-    let identifier_len = identifier.len();\n-    encoded.extend_from_slice(&[\n-        (identifier_len >> 0) as u8,\n-        (identifier_len >> 8) as u8,\n-        (identifier_len >> 16) as u8,\n-        (identifier_len >> 24) as u8,\n-    ]);\n-    encoded.extend_from_slice(identifier.as_bytes());\n-\n-    // Next is the LLVM module deflate compressed, prefixed with its length. We\n-    // don't know its length yet, so fill in 0s\n-    let deflated_size_pos = encoded.len();\n-    encoded.extend_from_slice(&[0, 0, 0, 0, 0, 0, 0, 0]);\n-\n-    let before = encoded.len();\n-    DeflateEncoder::new(&mut encoded, Compression::fast()).write_all(bytecode).unwrap();\n-    let after = encoded.len();\n-\n-    // Fill in the length we reserved space for before\n-    let bytecode_len = (after - before) as u64;\n-    encoded[deflated_size_pos + 0] = (bytecode_len >> 0) as u8;\n-    encoded[deflated_size_pos + 1] = (bytecode_len >> 8) as u8;\n-    encoded[deflated_size_pos + 2] = (bytecode_len >> 16) as u8;\n-    encoded[deflated_size_pos + 3] = (bytecode_len >> 24) as u8;\n-    encoded[deflated_size_pos + 4] = (bytecode_len >> 32) as u8;\n-    encoded[deflated_size_pos + 5] = (bytecode_len >> 40) as u8;\n-    encoded[deflated_size_pos + 6] = (bytecode_len >> 48) as u8;\n-    encoded[deflated_size_pos + 7] = (bytecode_len >> 56) as u8;\n-\n-    // If the number of bytes written to the object so far is odd, add a\n-    // padding byte to make it even. This works around a crash bug in LLDB\n-    // (see issue #15950)\n-    if encoded.len() % 2 == 1 {\n-        encoded.push(0);\n-    }\n-\n-    encoded\n-}\n-\n-pub struct DecodedBytecode<'a> {\n-    identifier: &'a str,\n-    encoded_bytecode: &'a [u8],\n-}\n-\n-impl<'a> DecodedBytecode<'a> {\n-    pub fn new(data: &'a [u8]) -> Result<DecodedBytecode<'a>, &'static str> {\n-        if !data.starts_with(RLIB_BYTECODE_OBJECT_MAGIC) {\n-            return Err(\"magic bytecode prefix not found\");\n-        }\n-        let data = &data[RLIB_BYTECODE_OBJECT_MAGIC.len()..];\n-        if !data.starts_with(&[RLIB_BYTECODE_OBJECT_VERSION, 0, 0, 0]) {\n-            return Err(\"wrong version prefix found in bytecode\");\n-        }\n-        let data = &data[4..];\n-        if data.len() < 4 {\n-            return Err(\"bytecode corrupted\");\n-        }\n-        let identifier_len =\n-            unsafe { u32::from_le(ptr::read_unaligned(data.as_ptr() as *const u32)) as usize };\n-        let data = &data[4..];\n-        if data.len() < identifier_len {\n-            return Err(\"bytecode corrupted\");\n-        }\n-        let identifier = match str::from_utf8(&data[..identifier_len]) {\n-            Ok(s) => s,\n-            Err(_) => return Err(\"bytecode corrupted\"),\n-        };\n-        let data = &data[identifier_len..];\n-        if data.len() < 8 {\n-            return Err(\"bytecode corrupted\");\n-        }\n-        let bytecode_len =\n-            unsafe { u64::from_le(ptr::read_unaligned(data.as_ptr() as *const u64)) as usize };\n-        let data = &data[8..];\n-        if data.len() < bytecode_len {\n-            return Err(\"bytecode corrupted\");\n-        }\n-        let encoded_bytecode = &data[..bytecode_len];\n-\n-        Ok(DecodedBytecode { identifier, encoded_bytecode })\n-    }\n-\n-    pub fn bytecode(&self) -> Vec<u8> {\n-        let mut data = Vec::new();\n-        DeflateDecoder::new(self.encoded_bytecode).read_to_end(&mut data).unwrap();\n-        data\n-    }\n-\n-    pub fn identifier(&self) -> &'a str {\n-        self.identifier\n-    }\n-}"}, {"sha": "e65bdbe171b26c1e39685d7f43e4f22729d68414", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -1,4 +1,3 @@\n-use crate::back::bytecode::DecodedBytecode;\n use crate::back::write::{\n     self, save_temp_bitcode, to_llvm_opt_settings, with_llvm_pmb, DiagnosticHandlers,\n };\n@@ -10,7 +9,7 @@ use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModul\n use rustc_codegen_ssa::back::symbol_export;\n use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n-use rustc_codegen_ssa::{ModuleCodegen, ModuleKind, RLIB_BYTECODE_EXTENSION};\n+use rustc_codegen_ssa::{looks_like_rust_object_file, ModuleCodegen, ModuleKind};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{FatalError, Handler};\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -111,29 +110,46 @@ fn prepare_lto(\n             }\n \n             let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n-            let bytecodes = archive\n+            let obj_files = archive\n                 .iter()\n                 .filter_map(|child| child.ok().and_then(|c| c.name().map(|name| (name, c))))\n-                .filter(|&(name, _)| name.ends_with(RLIB_BYTECODE_EXTENSION));\n-            for (name, data) in bytecodes {\n-                let _timer =\n-                    cgcx.prof.generic_activity_with_arg(\"LLVM_lto_load_upstream_bitcode\", name);\n-                info!(\"adding bytecode {}\", name);\n-                let bc_encoded = data.data();\n-\n-                let (bc, id) = match DecodedBytecode::new(bc_encoded) {\n-                    Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n-                    Err(e) => Err(diag_handler.fatal(&e)),\n-                }?;\n-                let bc = SerializedModule::FromRlib(bc);\n-                upstream_modules.push((bc, CString::new(id).unwrap()));\n+                .filter(|&(name, _)| looks_like_rust_object_file(name));\n+            for (name, child) in obj_files {\n+                info!(\"adding bitcode from {}\", name);\n+                match get_bitcode_slice_from_object_data(child.data()) {\n+                    Ok(data) => {\n+                        let module = SerializedModule::FromRlib(data.to_vec());\n+                        upstream_modules.push((module, CString::new(name).unwrap()));\n+                    }\n+                    Err(msg) => return Err(diag_handler.fatal(&msg)),\n+                }\n             }\n         }\n     }\n \n     Ok((symbol_white_list, upstream_modules))\n }\n \n+fn get_bitcode_slice_from_object_data(obj: &[u8]) -> Result<&[u8], String> {\n+    let mut len = 0;\n+    let data =\n+        unsafe { llvm::LLVMRustGetBitcodeSliceFromObjectData(obj.as_ptr(), obj.len(), &mut len) };\n+    if !data.is_null() {\n+        assert!(len != 0);\n+        let bc = unsafe { slice::from_raw_parts(data, len) };\n+\n+        // `bc` must be a sub-slice of `obj`.\n+        assert!(obj.as_ptr() <= bc.as_ptr());\n+        assert!(bc[bc.len()..bc.len()].as_ptr() <= obj[obj.len()..obj.len()].as_ptr());\n+\n+        Ok(bc)\n+    } else {\n+        assert!(len == 0);\n+        let msg = llvm::last_error().unwrap_or_else(|| \"unknown LLVM error\".to_string());\n+        Err(format!(\"failed to get bitcode from object file for LTO ({})\", msg))\n+    }\n+}\n+\n /// Performs fat LTO by merging all modules into a single one and returning it\n /// for further optimization.\n pub(crate) fn run_fat("}, {"sha": "5f4c122f02c92cbdc2feeff721ecd39b3e05857f", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -1,5 +1,4 @@\n use crate::attributes;\n-use crate::back::bytecode;\n use crate::back::lto::ThinBuffer;\n use crate::back::profiling::{\n     selfprofile_after_pass_callback, selfprofile_before_pass_callback, LlvmSelfProfiler,\n@@ -16,7 +15,7 @@ use crate::ModuleLlvm;\n use log::debug;\n use rustc_codegen_ssa::back::write::{BitcodeSection, CodegenContext, EmitObj, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n-use rustc_codegen_ssa::{CompiledModule, ModuleCodegen, RLIB_BYTECODE_EXTENSION};\n+use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_errors::{FatalError, Handler};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n@@ -669,19 +668,6 @@ pub(crate) unsafe fn codegen(\n                 );\n                 embed_bitcode(cgcx, llcx, llmod, Some(data));\n             }\n-\n-            if config.emit_bc_compressed {\n-                let _timer = cgcx.prof.generic_activity_with_arg(\n-                    \"LLVM_module_codegen_emit_compressed_bitcode\",\n-                    &module.name[..],\n-                );\n-                let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n-                let data = bytecode::encode(&module.name, data);\n-                if let Err(e) = fs::write(&dst, data) {\n-                    let msg = format!(\"failed to write bytecode to {}: {}\", dst.display(), e);\n-                    diag_handler.err(&msg);\n-                }\n-            }\n         } else if config.emit_obj == EmitObj::ObjectCode(BitcodeSection::Marker) {\n             embed_bitcode(cgcx, llcx, llmod, None);\n         }\n@@ -792,7 +778,6 @@ pub(crate) unsafe fn codegen(\n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n         config.emit_bc,\n-        config.emit_bc_compressed,\n         &cgcx.output_filenames,\n     ))\n }\n@@ -847,6 +832,55 @@ unsafe fn embed_bitcode(\n     let section = if is_apple { \"__LLVM,__cmdline\\0\" } else { \".llvmcmd\\0\" };\n     llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n+\n+    // We're adding custom sections to the output object file, but we definitely\n+    // do not want these custom sections to make their way into the final linked\n+    // executable. The purpose of these custom sections is for tooling\n+    // surrounding object files to work with the LLVM IR, if necessary. For\n+    // example rustc's own LTO will look for LLVM IR inside of the object file\n+    // in these sections by default.\n+    //\n+    // To handle this is a bit different depending on the object file format\n+    // used by the backend, broken down into a few different categories:\n+    //\n+    // * Mach-O - this is for macOS. Inspecting the source code for the native\n+    //   linker here shows that the `.llvmbc` and `.llvmcmd` sections are\n+    //   automatically skipped by the linker. In that case there's nothing extra\n+    //   that we need to do here.\n+    //\n+    // * Wasm - the native LLD linker is hard-coded to skip `.llvmbc` and\n+    //   `.llvmcmd` sections, so there's nothing extra we need to do.\n+    //\n+    // * COFF - if we don't do anything the linker will by default copy all\n+    //   these sections to the output artifact, not what we want! To subvert\n+    //   this we want to flag the sections we inserted here as\n+    //   `IMAGE_SCN_LNK_REMOVE`. Unfortunately though LLVM has no native way to\n+    //   do this. Thankfully though we can do this with some inline assembly,\n+    //   which is easy enough to add via module-level global inline asm.\n+    //\n+    // * ELF - this is very similar to COFF above. One difference is that these\n+    //   sections are removed from the output linked artifact when\n+    //   `--gc-sections` is passed, which we pass by default. If that flag isn't\n+    //   passed though then these sections will show up in the final output.\n+    //   Additionally the flag that we need to set here is `SHF_EXCLUDE`.\n+    if is_apple\n+        || cgcx.opts.target_triple.triple().starts_with(\"wasm\")\n+        || cgcx.opts.target_triple.triple().starts_with(\"asmjs\")\n+    {\n+        // nothing to do here\n+    } else if cgcx.opts.target_triple.triple().contains(\"windows\") {\n+        let asm = \"\n+            .section .llvmbc,\\\"n\\\"\n+            .section .llvmcmd,\\\"n\\\"\n+        \";\n+        llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n+    } else {\n+        let asm = \"\n+            .section .llvmbc,\\\"e\\\"\n+            .section .llvmcmd,\\\"e\\\"\n+        \";\n+        llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n+    }\n }\n \n pub unsafe fn with_llvm_pmb("}, {"sha": "5effde444af6fe0257eb2a1e440d538bbc5d7c3a", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -40,7 +40,6 @@ use std::sync::Arc;\n \n mod back {\n     pub mod archive;\n-    pub mod bytecode;\n     pub mod lto;\n     mod profiling;\n     pub mod write;"}, {"sha": "ceeb528430fff52185b33b85bd96ef3d9f4a28cb", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -2138,6 +2138,11 @@ extern \"C\" {\n         len: usize,\n         Identifier: *const c_char,\n     ) -> Option<&Module>;\n+    pub fn LLVMRustGetBitcodeSliceFromObjectData(\n+        Data: *const u8,\n+        len: usize,\n+        out_len: &mut usize,\n+    ) -> *const u8;\n     pub fn LLVMRustThinLTOGetDICompileUnit(\n         M: &Module,\n         CU1: &mut *mut c_void,"}, {"sha": "657dae504b91886df387dc54d734ca8e441aa237", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -18,10 +18,7 @@ use super::archive::ArchiveBuilder;\n use super::command::Command;\n use super::linker::Linker;\n use super::rpath::{self, RPathConfig};\n-use crate::{\n-    looks_like_rust_object_file, CodegenResults, CrateInfo, METADATA_FILENAME,\n-    RLIB_BYTECODE_EXTENSION,\n-};\n+use crate::{looks_like_rust_object_file, CodegenResults, CrateInfo, METADATA_FILENAME};\n \n use cc::windows_registry;\n use tempfile::{Builder as TempFileBuilder, TempDir};\n@@ -130,10 +127,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                     remove(sess, obj);\n                 }\n             }\n-            for obj in codegen_results.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref())\n-            {\n-                remove(sess, obj);\n-            }\n             if let Some(ref metadata_module) = codegen_results.metadata_module {\n                 if let Some(ref obj) = metadata_module.object {\n                     remove(sess, obj);\n@@ -143,9 +136,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                 if let Some(ref obj) = allocator_module.object {\n                     remove(sess, obj);\n                 }\n-                if let Some(ref bc) = allocator_module.bytecode_compressed {\n-                    remove(sess, bc);\n-                }\n             }\n         }\n     });\n@@ -378,14 +368,6 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n             // contain the metadata in a separate file.\n             ab.add_file(&emit_metadata(sess, &codegen_results.metadata, tmpdir));\n \n-            // For LTO purposes, the bytecode of this library is also inserted\n-            // into the archive.\n-            for bytecode in\n-                codegen_results.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref())\n-            {\n-                ab.add_file(bytecode);\n-            }\n-\n             // After adding all files to the archive, we need to update the\n             // symbol table of the archive. This currently dies on macOS (see\n             // #11162), and isn't necessary there anyway\n@@ -1829,7 +1811,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n \n             let mut any_objects = false;\n             for f in archive.src_files() {\n-                if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n+                if f == METADATA_FILENAME {\n                     archive.remove_file(&f);\n                     continue;\n                 }"}, {"sha": "598f56308c00be64b0d87c5216309ffbe54e5400", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -5,7 +5,6 @@ use super::symbol_export::symbol_name_for_instance_in_crate;\n \n use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n-    RLIB_BYTECODE_EXTENSION,\n };\n \n use crate::traits::*;\n@@ -100,7 +99,6 @@ pub struct ModuleConfig {\n     pub emit_pre_lto_bc: bool,\n     pub emit_no_opt_bc: bool,\n     pub emit_bc: bool,\n-    pub emit_bc_compressed: bool,\n     pub emit_ir: bool,\n     pub emit_asm: bool,\n     pub emit_obj: EmitObj,\n@@ -145,9 +143,10 @@ impl ModuleConfig {\n             || sess.opts.cg.linker_plugin_lto.enabled()\n         {\n             EmitObj::Bitcode\n-        } else if sess.opts.debugging_opts.embed_bitcode {\n+        } else if sess.opts.debugging_opts.embed_bitcode || need_crate_bitcode_for_rlib(sess) {\n+            let force_full = need_crate_bitcode_for_rlib(sess);\n             match sess.opts.optimize {\n-                config::OptLevel::No | config::OptLevel::Less => {\n+                config::OptLevel::No | config::OptLevel::Less if !force_full => {\n                     EmitObj::ObjectCode(BitcodeSection::Marker)\n                 }\n                 _ => EmitObj::ObjectCode(BitcodeSection::Full),\n@@ -196,16 +195,6 @@ impl ModuleConfig {\n                 save_temps || sess.opts.output_types.contains_key(&OutputType::Bitcode),\n                 save_temps\n             ),\n-            emit_bc_compressed: match kind {\n-                ModuleKind::Regular | ModuleKind::Allocator => {\n-                    // Emit compressed bitcode files for the crate if we're\n-                    // emitting an rlib. Whenever an rlib is created, the\n-                    // bitcode is inserted into the archive in order to allow\n-                    // LTO against it.\n-                    need_crate_bitcode_for_rlib(sess)\n-                }\n-                ModuleKind::Metadata => false,\n-            },\n             emit_ir: if_regular!(\n                 sess.opts.output_types.contains_key(&OutputType::LlvmAssembly),\n                 false\n@@ -261,7 +250,6 @@ impl ModuleConfig {\n \n     pub fn bitcode_needed(&self) -> bool {\n         self.emit_bc\n-            || self.emit_bc_compressed\n             || self.emit_obj == EmitObj::Bitcode\n             || self.emit_obj == EmitObj::ObjectCode(BitcodeSection::Full)\n     }\n@@ -482,9 +470,6 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n         if let Some(ref path) = module.bytecode {\n             files.push((WorkProductFileKind::Bytecode, path.clone()));\n         }\n-        if let Some(ref path) = module.bytecode_compressed {\n-            files.push((WorkProductFileKind::BytecodeCompressed, path.clone()));\n-        }\n \n         if let Some((id, product)) =\n             copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files)\n@@ -821,7 +806,6 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     let incr_comp_session_dir = cgcx.incr_comp_session_dir.as_ref().unwrap();\n     let mut object = None;\n     let mut bytecode = None;\n-    let mut bytecode_compressed = None;\n     for (kind, saved_file) in &module.source.saved_files {\n         let obj_out = match kind {\n             WorkProductFileKind::Object => {\n@@ -834,14 +818,6 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n                 bytecode = Some(path.clone());\n                 path\n             }\n-            WorkProductFileKind::BytecodeCompressed => {\n-                let path = cgcx\n-                    .output_filenames\n-                    .temp_path(OutputType::Bitcode, Some(&module.name))\n-                    .with_extension(RLIB_BYTECODE_EXTENSION);\n-                bytecode_compressed = Some(path.clone());\n-                path\n-            }\n         };\n         let source_file = in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n         debug!(\n@@ -863,14 +839,12 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n \n     assert_eq!(object.is_some(), module_config.emit_obj != EmitObj::None);\n     assert_eq!(bytecode.is_some(), module_config.emit_bc);\n-    assert_eq!(bytecode_compressed.is_some(), module_config.emit_bc_compressed);\n \n     Ok(WorkItemResult::Compiled(CompiledModule {\n         name: module.name,\n         kind: ModuleKind::Regular,\n         object,\n         bytecode,\n-        bytecode_compressed,\n     }))\n }\n "}, {"sha": "7dc09b595c36ef56420a38db7fe697981c4ce353", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -55,31 +55,18 @@ pub struct ModuleCodegen<M> {\n \n // FIXME(eddyb) maybe include the crate name in this?\n pub const METADATA_FILENAME: &str = \"lib.rmeta\";\n-pub const RLIB_BYTECODE_EXTENSION: &str = \"bc.z\";\n \n impl<M> ModuleCodegen<M> {\n     pub fn into_compiled_module(\n         self,\n         emit_obj: bool,\n         emit_bc: bool,\n-        emit_bc_compressed: bool,\n         outputs: &OutputFilenames,\n     ) -> CompiledModule {\n         let object = emit_obj.then(|| outputs.temp_path(OutputType::Object, Some(&self.name)));\n         let bytecode = emit_bc.then(|| outputs.temp_path(OutputType::Bitcode, Some(&self.name)));\n-        let bytecode_compressed = emit_bc_compressed.then(|| {\n-            outputs\n-                .temp_path(OutputType::Bitcode, Some(&self.name))\n-                .with_extension(RLIB_BYTECODE_EXTENSION)\n-        });\n-\n-        CompiledModule {\n-            name: self.name.clone(),\n-            kind: self.kind,\n-            object,\n-            bytecode,\n-            bytecode_compressed,\n-        }\n+\n+        CompiledModule { name: self.name.clone(), kind: self.kind, object, bytecode }\n     }\n }\n \n@@ -89,7 +76,6 @@ pub struct CompiledModule {\n     pub kind: ModuleKind,\n     pub object: Option<PathBuf>,\n     pub bytecode: Option<PathBuf>,\n-    pub bytecode_compressed: Option<PathBuf>,\n }\n \n pub struct CachedModuleCodegen {"}, {"sha": "3601b9970591658db023dd33b9554f62764a7433", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -21,7 +21,6 @@ pub fn copy_cgu_workproducts_to_incr_comp_cache_dir(\n             let extension = match kind {\n                 WorkProductFileKind::Object => \"o\",\n                 WorkProductFileKind::Bytecode => \"bc\",\n-                WorkProductFileKind::BytecodeCompressed => \"bc.z\",\n             };\n             let file_name = format!(\"{}.{}\", cgu_name, extension);\n             let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);"}, {"sha": "ba3ce16ae36fe7c836ccdc1c8d07de8f04262d6c", "filename": "src/librustc_query_system/dep_graph/graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -868,7 +868,6 @@ pub struct WorkProduct {\n pub enum WorkProductFileKind {\n     Object,\n     Bytecode,\n-    BytecodeCompressed,\n }\n \n #[derive(Clone)]"}, {"sha": "3ba91917e52bd66ac37161ad4a1bc87d32aa2e18", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -1 +1 @@\n-Subproject commit 9f9da27fbdb0ba7d887f8d2521e082f12b009417\n+Subproject commit 3ba91917e52bd66ac37161ad4a1bc87d32aa2e18"}, {"sha": "afdad5650b7110a4019de5f27b8a7770982dacf1", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -13,6 +13,8 @@\n #include \"llvm/IR/AssemblyAnnotationWriter.h\"\n #include \"llvm/IR/IntrinsicInst.h\"\n #include \"llvm/IR/Verifier.h\"\n+#include \"llvm/Object/ObjectFile.h\"\n+#include \"llvm/Object/IRObjectFile.h\"\n #include \"llvm/Passes/PassBuilder.h\"\n #if LLVM_VERSION_GE(9, 0)\n #include \"llvm/Passes/StandardInstrumentations.h\"\n@@ -1478,6 +1480,32 @@ LLVMRustParseBitcodeForLTO(LLVMContextRef Context,\n   return wrap(std::move(*SrcOrError).release());\n }\n \n+// Find the bitcode section in the object file data and return it as a slice.\n+// Fail if the bitcode section is present but empty.\n+//\n+// On success, the return value is the pointer to the start of the slice and\n+// `out_len` is filled with the (non-zero) length. On failure, the return value\n+// is `nullptr` and `out_len` is set to zero.\n+extern \"C\" const char*\n+LLVMRustGetBitcodeSliceFromObjectData(const char *data,\n+                                      size_t len,\n+                                      size_t *out_len) {\n+  *out_len = 0;\n+\n+  StringRef Data(data, len);\n+  MemoryBufferRef Buffer(Data, \"\"); // The id is unused.\n+\n+  Expected<MemoryBufferRef> BitcodeOrError =\n+    object::IRObjectFile::findBitcodeInMemBuffer(Buffer);\n+  if (!BitcodeOrError) {\n+    LLVMRustSetLastError(toString(BitcodeOrError.takeError()).c_str());\n+    return nullptr;\n+  }\n+\n+  *out_len = BitcodeOrError->getBufferSize();\n+  return BitcodeOrError->getBufferStart();\n+}\n+\n // Rewrite all `DICompileUnit` pointers to the `DICompileUnit` specified. See\n // the comment in `back/lto.rs` for why this exists.\n extern \"C\" void"}, {"sha": "d24375b2d0a63cccf8532608a05e44611fde0e72", "filename": "src/test/ui/auxiliary/lto-rustc-loads-linker-plugin.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Ftest%2Fui%2Fauxiliary%2Flto-rustc-loads-linker-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Ftest%2Fui%2Fauxiliary%2Flto-rustc-loads-linker-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Flto-rustc-loads-linker-plugin.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -0,0 +1,6 @@\n+// compile-flags: -Clinker-plugin-lto\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+\n+pub fn foo() {}"}, {"sha": "713b79bae32e625a3cbdbffdedda6795557fc537", "filename": "src/test/ui/lto-duplicate-symbols.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -1,6 +1,6 @@\n warning: Linking globals named 'foo': symbol multiply defined!\n \n-error: failed to load bc of \"lto_duplicate_symbols2.3a1fbbbh-cgu.0\": \n+error: failed to load bc of \"lto-duplicate-symbols2.lto_duplicate_symbols2.3a1fbbbh-cgu.0.rcgu.o\": \n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "6ef1d4540b8d753e5ed60b5554a6439a2c0bd826", "filename": "src/test/ui/lto-rustc-loads-linker-plugin.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Ftest%2Fui%2Flto-rustc-loads-linker-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Ftest%2Fui%2Flto-rustc-loads-linker-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flto-rustc-loads-linker-plugin.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -C lto\n+// aux-build:lto-rustc-loads-linker-plugin.rs\n+// run-pass\n+// no-prefer-dynamic\n+\n+// This test ensures that if a dependency was compiled with\n+// `-Clinker-plugin-lto` then we can compile with `-Clto` and still link against\n+// that upstream rlib. This should work because LTO implies we're not actually\n+// linking against upstream rlibs since we're generating the object code\n+// locally. This test will fail if rustc can't find bytecode in rlibs compiled\n+// with `-Clinker-plugin-lto`.\n+\n+extern crate lto_rustc_loads_linker_plugin;\n+\n+fn main() {\n+    lto_rustc_loads_linker_plugin::foo();\n+}"}, {"sha": "4d54ce32fb5635b83447dcd274f2094a7f650de2", "filename": "src/test/ui/lto-thin-rustc-loads-linker-plugin.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Ftest%2Fui%2Flto-thin-rustc-loads-linker-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef89cc8f042a980e72e9d0262c267bfffd9e75fe/src%2Ftest%2Fui%2Flto-thin-rustc-loads-linker-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flto-thin-rustc-loads-linker-plugin.rs?ref=ef89cc8f042a980e72e9d0262c267bfffd9e75fe", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -C lto=thin\n+// aux-build:lto-rustc-loads-linker-plugin.rs\n+// run-pass\n+// no-prefer-dynamic\n+\n+// Same as the adjacent `lto-thin-rustc-loads-linker-plugin.rs` test, only with\n+// ThinLTO.\n+\n+extern crate lto_rustc_loads_linker_plugin;\n+\n+fn main() {\n+    lto_rustc_loads_linker_plugin::foo();\n+}"}]}