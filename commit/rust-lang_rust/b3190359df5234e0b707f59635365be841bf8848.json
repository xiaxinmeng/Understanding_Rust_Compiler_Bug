{"sha": "b3190359df5234e0b707f59635365be841bf8848", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMTkwMzU5ZGY1MjM0ZTBiNzA3ZjU5NjM1MzY1YmU4NDFiZjg4NDg=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-23T13:48:23Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-23T13:48:23Z"}, "message": "refactor away `get_fat_ptr`", "tree": {"sha": "52e7f6174af423181aa7d97d6ae82c6774c6744b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52e7f6174af423181aa7d97d6ae82c6774c6744b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3190359df5234e0b707f59635365be841bf8848", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX5TKnAAoJEFbW7qD8Z6xG2dEP/36FJZvSuByKhWUvMwKzsgQY\n3I3sb4H++ipEX5MqTfxM76dynv9y5oQcwK5oWmaRj/1d8uaaJZSuMLnalerMvVex\nZN6TrGmr5EuwWLNDRRGNKF1e8LVNO84JqOAdHpI8pezSVn4vprlA2kcNjNGNVkzq\nCumdgovRumCqb1TWNc66tiIiivGKVEv6NbQJKABMjfXjso7cyvfuWP6VmTQ3lPrr\nQGgXzuLuittlriG4Trq0RhBbiS32svgc61zvsumDdwF7FlU26jrvCs95y7XzwHq9\nYHPXEyzaWP6jrBmrZif1ldyXA363Z9ImqWJYGR3mC8J10YjBf2DRdUmCvWaUY7Go\nrDJxPuUsKNZhLGLRRxwHigNnkMEhKhWqf6JT6RMVDB7F0PEFb0D2IjMqtKt1rPVP\nuhMZcTKLFc0mMqj2Or3WV+4g4IrY5Y7lxdigsD/5ZAZV9tfkhtGt2ZFyPllk0Kz4\n5HCu2cfSQLaPbHiXjZZ34J9/kqvy7TUY4phOpuGejtSbKnZPgpV6Z8WGDnSbwstf\n8rzteWmU/6WTH9tDMbTLQT21zOt5gzWtJPfHMSHUQP7o3YfqD33JAfOf+SwgfSAK\nqVLB8ox8opXHkePEuG0ENxzaPKY0Up19/IVEMqKIEw4wFkvzATOHziRUn6xvrpa9\nVHgUfcMr0rfggx+fDxhM\n=krF5\n-----END PGP SIGNATURE-----", "payload": "tree 52e7f6174af423181aa7d97d6ae82c6774c6744b\nparent d743c0784ed487c3329010b77a935eb13b538816\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474638503 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474638503 +0200\n\nrefactor away `get_fat_ptr`"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3190359df5234e0b707f59635365be841bf8848", "html_url": "https://github.com/rust-lang/rust/commit/b3190359df5234e0b707f59635365be841bf8848", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3190359df5234e0b707f59635365be841bf8848/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d743c0784ed487c3329010b77a935eb13b538816", "url": "https://api.github.com/repos/rust-lang/rust/commits/d743c0784ed487c3329010b77a935eb13b538816", "html_url": "https://github.com/rust-lang/rust/commit/d743c0784ed487c3329010b77a935eb13b538816"}], "stats": {"total": 181, "additions": 153, "deletions": 28}, "files": [{"sha": "9e8c2996d2655a678a2c61bdf4132bc147e558c5", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b3190359df5234e0b707f59635365be841bf8848/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3190359df5234e0b707f59635365be841bf8848/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=b3190359df5234e0b707f59635365be841bf8848", "patch": "@@ -579,15 +579,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Ref(_, _, ref lvalue) => {\n                 let lv = self.eval_lvalue(lvalue)?;\n-                let (ptr, extra) = self.get_fat_ptr(dest);\n-                self.memory.write_ptr(ptr, lv.ptr)?;\n                 match lv.extra {\n-                    LvalueExtra::None => {},\n+                    LvalueExtra::None => self.memory.write_ptr(dest, lv.ptr)?,\n                     LvalueExtra::Length(len) => {\n-                        self.memory.write_usize(extra, len)?;\n+                        self.memory.write_primval(dest, PrimVal::SlicePtr(lv.ptr, len))?;\n                     }\n                     LvalueExtra::Vtable(ptr) => {\n-                        self.memory.write_ptr(extra, ptr)?;\n+                        self.memory.write_primval(dest, PrimVal::VtablePtr(lv.ptr, ptr))?;\n                     },\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n@@ -902,21 +900,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     },\n \n                     Deref => {\n-                        let pointee_ty = pointee_type(base_ty).expect(\"Deref of non-pointer\");\n-                        let pointee_ty = self.tcx.struct_tail(pointee_ty);\n-                        let ptr = self.memory.read_ptr(base.ptr)?;\n-                        let extra = match pointee_ty.sty {\n-                            ty::TySlice(_) | ty::TyStr => {\n-                                let (_, extra) = self.get_fat_ptr(base.ptr);\n-                                let len = self.memory.read_usize(extra)?;\n-                                LvalueExtra::Length(len)\n-                            }\n-                            ty::TyTrait(_) => {\n-                                let (_, extra) = self.get_fat_ptr(base.ptr);\n-                                let vtable = self.memory.read_ptr(extra)?;\n-                                LvalueExtra::Vtable(vtable)\n-                            },\n-                            _ => LvalueExtra::None,\n+                        let (ptr, extra) = match self.read_primval(base.ptr, base_ty)? {\n+                            PrimVal::SlicePtr(ptr, n) => (ptr, LvalueExtra::Length(n)),\n+                            PrimVal::VtablePtr(ptr, vptr) => (ptr, LvalueExtra::Vtable(vptr)),\n+                            PrimVal::Ptr(ptr) => (ptr, LvalueExtra::None),\n+                            _ => bug!(\"can't deref non pointer types\"),\n                         };\n                         return Ok(Lvalue { ptr: ptr, extra: extra });\n                     }\n@@ -942,12 +930,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue { ptr: ptr, extra: LvalueExtra::None })\n     }\n \n-    fn get_fat_ptr(&self, ptr: Pointer) -> (Pointer, Pointer) {\n-        assert_eq!(layout::FAT_PTR_ADDR, 0);\n-        assert_eq!(layout::FAT_PTR_EXTRA, 1);\n-        (ptr, ptr.offset(self.memory.pointer_size() as isize))\n-    }\n-\n     fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(lvalue.ty(&self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n     }\n@@ -1038,12 +1020,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 PrimVal::FnPtr(self.memory.create_fn_ptr(def_id, substs, fn_ty))\n             },\n             &ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::FnPtr)?,\n+            &ty::TyBox(ty) |\n             &ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             &ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                let p = self.memory.read_ptr(ptr)?;\n                 if self.type_is_sized(ty) {\n-                    PrimVal::Ptr(self.memory.read_ptr(ptr)?)\n+                    PrimVal::Ptr(p)\n                 } else {\n-                    bug!(\"primitive read of fat pointer type: {:?}\", ty);\n+                    // FIXME: extract the offset to the tail field for `Box<(i64, i32, [u8])>`\n+                    let extra = ptr.offset(self.memory.pointer_size() as isize);\n+                    match self.tcx.struct_tail(ty).sty {\n+                        ty::TyTrait(..) => PrimVal::VtablePtr(p, self.memory.read_ptr(extra)?),\n+                        ty::TySlice(..) |\n+                        ty::TyStr => PrimVal::SlicePtr(p, self.memory.read_usize(extra)?),\n+                        _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n+                    }\n                 }\n             }\n "}, {"sha": "932b571eccdbb8551646ada388f6b9c5e1739ca7", "filename": "tests/run-pass/dst-struct.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b3190359df5234e0b707f59635365be841bf8848/tests%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3190359df5234e0b707f59635365be841bf8848/tests%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-struct.rs?ref=b3190359df5234e0b707f59635365be841bf8848", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![allow(unused_features)]\n+#![feature(box_syntax)]\n+\n+struct Fat<T: ?Sized> {\n+    f1: isize,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.ptr;\n+    assert_eq!(x.ptr.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.ptr[1], 2);\n+    assert_eq!(x.f1, 5);\n+    assert_eq!(x.f2, \"some str\");\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.ptr;\n+    let bar = Bar;\n+    assert_eq!(x.ptr.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.ptr[1].to_bar(), bar);\n+    assert_eq!(x.f1, 5);\n+    assert_eq!(x.f2, \"some str\");\n+}\n+\n+fn foo3(x: &Fat<Fat<[isize]>>) {\n+    let y = &x.ptr.ptr;\n+    assert_eq!(x.f1, 5);\n+    assert_eq!(x.f2, \"some str\");\n+    assert_eq!(x.ptr.f1, 8);\n+    assert_eq!(x.ptr.f2, \"deep str\");\n+    assert_eq!(x.ptr.ptr.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.ptr.ptr[1], 2);\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    f5.ptr[1] = 34;\n+    assert_eq!(f5.ptr[0], 1);\n+    assert_eq!(f5.ptr[1], 34);\n+    assert_eq!(f5.ptr[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    assert!(f5.ptr.is_empty());\n+    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    assert!(f5.ptr.is_empty());\n+\n+    // Deeply nested.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+    foo3(&f1);\n+    let f2 = &f1;\n+    foo3(f2);\n+    let f3: &Fat<Fat<[isize]>> = f2;\n+    foo3(f3);\n+    let f4: &Fat<Fat<[isize]>> = &f1;\n+    foo3(f4);\n+    let f5: &Fat<Fat<[isize]>> =\n+        &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+    foo3(f5);\n+\n+    // Box.\n+    let f1 = Box::new([1, 2, 3]);\n+    assert_eq!((*f1)[1], 2);\n+    let f2: Box<[isize]> = f1;\n+    assert_eq!((*f2)[1], 2);\n+\n+    // Nested Box.\n+    let f1 : Box<Fat<[isize; 3]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&*f1);\n+    let f2 : Box<Fat<[isize]>> = f1;\n+    foo(&*f2);\n+\n+    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n+    let f3 : Box<Fat<[isize]>> =\n+        Box::<Fat<[_; 3]>>::new(Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] });\n+    foo(&*f3);\n+}"}]}