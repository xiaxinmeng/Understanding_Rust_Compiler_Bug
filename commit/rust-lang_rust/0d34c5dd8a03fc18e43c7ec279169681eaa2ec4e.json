{"sha": "0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMzRjNWRkOGEwM2ZjMThlNDNjN2VjMjc5MTY5NjgxZWFhMmVjNGU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-31T07:03:00Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-07T04:33:06Z"}, "message": "Use the node id from the `Restricted` variant when checking accessibility\nin `typeck` and in `privacy::PrivacyVisitor`.", "tree": {"sha": "9aee2ff05675f45905b044ee06098f0bb0281777", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9aee2ff05675f45905b044ee06098f0bb0281777"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "html_url": "https://github.com/rust-lang/rust/commit/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "html_url": "https://github.com/rust-lang/rust/commit/bb66d91c98d83ac5fc453f120ef4a810bc8939a5"}], "stats": {"total": 76, "additions": 34, "deletions": 42}, "files": [{"sha": "fc1c4aeb226012b09c0d33ad314e00497eb38822", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "patch": "@@ -440,18 +440,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn private_item_is_visible_from(&self, item: NodeId, block: NodeId) -> bool {\n-        // A private item is visible from everything in its nearest module parent.\n-        let visibility = self.get_module_parent(item);\n-        let mut block_ancestor = self.get_module_parent(block);\n-        loop {\n-            if block_ancestor == visibility { return true }\n-            let block_ancestor_parent = self.get_module_parent(block_ancestor);\n-            if block_ancestor_parent == block_ancestor { return false }\n-            block_ancestor = block_ancestor_parent;\n-        }\n-    }\n-\n     /// Returns the nearest enclosing scope. A scope is an item or block.\n     /// FIXME it is not clear to me that all items qualify as scopes - statics\n     /// and associated types probably shouldn't, for example. Behaviour in this"}, {"sha": "c3e1f38180a6c02ffed4a378126b5eadd465bee6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "patch": "@@ -290,6 +290,26 @@ impl Visibility {\n             hir::Inherited => Visibility::Restricted(tcx.map.get_module_parent(id)),\n         }\n     }\n+\n+    /// Returns true if an item with this visibility is accessible from the given block.\n+    pub fn is_accessible_from(self, block: NodeId, map: &ast_map::Map) -> bool {\n+        let restriction = match self {\n+            // Public items are visible everywhere.\n+            Visibility::Public => return true,\n+            // Private items from other crates are visible nowhere.\n+            Visibility::PrivateExternal => return false,\n+            // Restricted items are visible in an arbitrary local module.\n+            Visibility::Restricted(module) => module,\n+        };\n+\n+        let mut block_ancestor = map.get_module_parent(block);\n+        loop {\n+            if block_ancestor == restriction { return true }\n+            let block_ancestor_parent = map.get_module_parent(block_ancestor);\n+            if block_ancestor_parent == block_ancestor { return false }\n+            block_ancestor = block_ancestor_parent;\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "3b9dc4a4814d523669622f4ed49586192ad1d24d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "patch": "@@ -382,26 +382,18 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    fn item_is_visible(&self, did: DefId) -> bool {\n-        let is_public = match self.tcx.map.as_local_node_id(did) {\n-            Some(node_id) => self.tcx.map.expect_item(node_id).vis == hir::Public,\n-            None => self.tcx.sess.cstore.visibility(did) == ty::Visibility::Public,\n-        };\n-        is_public || self.private_accessible(did)\n-    }\n-\n-    /// True if `did` is private-accessible\n-    fn private_accessible(&self, did: DefId) -> bool {\n+    fn item_is_accessible(&self, did: DefId) -> bool {\n         match self.tcx.map.as_local_node_id(did) {\n-            Some(node_id) => self.tcx.map.private_item_is_visible_from(node_id, self.curitem),\n-            None => false,\n-        }\n+            Some(node_id) =>\n+                ty::Visibility::from_hir(&self.tcx.map.expect_item(node_id).vis, node_id, self.tcx),\n+            None => self.tcx.sess.cstore.visibility(did),\n+        }.is_accessible_from(self.curitem, &self.tcx.map)\n     }\n \n     // Checks that a field is in scope.\n     fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n         if def.adt_kind() == ty::AdtKind::Struct &&\n-                field.vis != ty::Visibility::Public && !self.private_accessible(def.did) {\n+           !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n             span_err!(self.tcx.sess, span, E0451, \"field `{}` of struct `{}` is private\",\n                       field.name, self.tcx.item_path_str(def.did));\n         }\n@@ -412,7 +404,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match self.tcx.impl_or_trait_item(method_def_id).container() {\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            ty::TraitContainer(trait_def_id) if !self.item_is_visible(trait_def_id) => {\n+            ty::TraitContainer(trait_def_id) if !self.item_is_accessible(trait_def_id) => {\n                 let msg = format!(\"source trait `{}` is private\",\n                                   self.tcx.item_path_str(trait_def_id));\n                 self.tcx.sess.span_err(span, &msg);\n@@ -464,7 +456,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != ty::Visibility::Public && !self.private_accessible(def.did)\n+                        !f.vis.is_accessible_from(self.curitem, &self.tcx.map)\n                     });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,"}, {"sha": "31d95af4fbb9c4b416b25d031f4b9cf58fcc35cf", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "patch": "@@ -16,7 +16,7 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use rustc::ty::subst;\n use rustc::traits;\n-use rustc::ty::{self, TyCtxt, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable, Visibility};\n+use rustc::ty::{self, TyCtxt, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use rustc::infer;\n \n@@ -343,7 +343,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let def = pick.item.def();\n \n     if let probe::InherentImplPick = pick.kind {\n-        if pick.item.vis() != Visibility::Public && !fcx.private_item_is_visible(def.def_id()) {\n+        if !pick.item.vis().is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n             fcx.tcx().sess.span_err(span, &msg);\n         }"}, {"sha": "0ffbbfea84ef0c5c946e18ce335bf3b26212926e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "patch": "@@ -20,7 +20,7 @@ use hir::def::Def;\n use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n-use rustc::ty::{self, NoPreference, Ty, TyCtxt, ToPolyTraitRef, TraitRef, TypeFoldable, Visibility};\n+use rustc::ty::{self, NoPreference, Ty, TyCtxt, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -412,7 +412,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        if item.vis() != Visibility::Public && !self.fcx.private_item_is_visible(item.def_id()) {\n+        if !item.vis().is_accessible_from(self.fcx.body_id, &self.tcx().map) {\n             self.private_candidate = Some(item.def());\n             return\n         }"}, {"sha": "45877d7099bbf70de70ed88ecbb0b4c3bc973ddb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "patch": "@@ -2054,13 +2054,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n     }\n-\n-    fn private_item_is_visible(&self, def_id: DefId) -> bool {\n-        match self.tcx().map.as_local_node_id(def_id) {\n-            Some(node_id) => self.tcx().map.private_item_is_visible_from(node_id, self.body_id),\n-            None => false, // Private items from other crates are never visible\n-        }\n-    }\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n@@ -2966,8 +2959,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     debug!(\"struct named {:?}\",  base_t);\n                     if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n                         let field_ty = fcx.field_ty(expr.span, field, substs);\n-                        if field.vis == Visibility::Public ||\n-                           fcx.private_item_is_visible(base_def.did) {\n+                        if field.vis.is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n                             return Some(field_ty);\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3079,7 +3071,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 debug!(\"tuple struct named {:?}\",  base_t);\n                 if let Some(field) = base_def.struct_variant().fields.get(idx.node) {\n                     let field_ty = fcx.field_ty(expr.span, field, substs);\n-                    if field.vis == Visibility::Public || fcx.private_item_is_visible(base_def.did) {\n+                    if field.vis.is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n                         return Some(field_ty);\n                     }\n                     private_candidate = Some((base_def.did, field_ty));"}]}