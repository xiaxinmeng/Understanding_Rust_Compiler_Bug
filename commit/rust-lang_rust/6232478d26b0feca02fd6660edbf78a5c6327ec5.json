{"sha": "6232478d26b0feca02fd6660edbf78a5c6327ec5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMzI0NzhkMjZiMGZlY2EwMmZkNjY2MGVkYmY3OGE1YzYzMjdlYzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-04T02:05:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-04T02:05:00Z"}, "message": "Auto merge of #51334 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #51288 (Remove rustdoc-specific is_import field from HIR)\n - #51299 (const fn integer operations)\n - #51317 (Allow enabling incremental via config.toml)\n - #51323 (Generate br for all two target SwitchInts)\n - #51326 (Various minor slice iterator cleanups)\n - #51329 (Remove the unused `-Z trans-time-graph` flag.)\n\nFailed merges:", "tree": {"sha": "103b1d3cf99fe8bdc4e2eb8c8020a8ab7e09dc63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/103b1d3cf99fe8bdc4e2eb8c8020a8ab7e09dc63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6232478d26b0feca02fd6660edbf78a5c6327ec5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6232478d26b0feca02fd6660edbf78a5c6327ec5", "html_url": "https://github.com/rust-lang/rust/commit/6232478d26b0feca02fd6660edbf78a5c6327ec5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6232478d26b0feca02fd6660edbf78a5c6327ec5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01a9b30c332810ad0c570e8fed91f956417dec3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a9b30c332810ad0c570e8fed91f956417dec3a", "html_url": "https://github.com/rust-lang/rust/commit/01a9b30c332810ad0c570e8fed91f956417dec3a"}, {"sha": "dd1096f2e71adb3bafbedaa355564abb4e55cc7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1096f2e71adb3bafbedaa355564abb4e55cc7e", "html_url": "https://github.com/rust-lang/rust/commit/dd1096f2e71adb3bafbedaa355564abb4e55cc7e"}], "stats": {"total": 414, "additions": 363, "deletions": 51}, "files": [{"sha": "5054a8f44b971174adef42ff8a281fbfd857fc26", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -279,6 +279,9 @@\n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n \n+# Whether to always use incremental compilation when building rustc\n+#incremental = false\n+\n # Build rustc with experimental parallelization\n #experimental-parallel-queries = false\n "}, {"sha": "47feb8a8ab66d51c30733139b79f1fa2c53baf35", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -303,6 +303,7 @@ struct Rust {\n     dist_src: Option<bool>,\n     quiet_tests: Option<bool>,\n     test_miri: Option<bool>,\n+    incremental: Option<bool>,\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n@@ -529,6 +530,10 @@ impl Config {\n             set(&mut config.rust_dist_src, rust.dist_src);\n             set(&mut config.quiet_tests, rust.quiet_tests);\n             set(&mut config.test_miri, rust.test_miri);\n+            // in the case \"false\" is set explicitly, do not overwrite the command line args\n+            if let Some(true) = rust.incremental {\n+                config.incremental = true;\n+            }\n             set(&mut config.wasm_syscall, rust.wasm_syscall);\n             set(&mut config.lld_enabled, rust.lld);\n             config.rustc_parallel_queries = rust.experimental_parallel_queries.unwrap_or(false);"}, {"sha": "b27552651a08743cc7e8d12aea8c530d038bec4c", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -81,6 +81,7 @@\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n+#![feature(const_int_ops)]\n #![feature(core_float)]\n #![feature(custom_attribute)]\n #![feature(doc_cfg)]"}, {"sha": "26dd08b10b9b8778cb64b810a33022589eef60d9", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 280, "deletions": 14, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -267,6 +267,16 @@ $EndFeature, \"\n ```\n \"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n         }\n@@ -282,6 +292,18 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentatio\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n@@ -302,6 +324,18 @@ assert_eq!(n.leading_zeros(), 0);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn leading_zeros(self) -> u32 {\n+                (self as $UnsignedT).leading_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn leading_zeros(self) -> u32 {\n                 (self as $UnsignedT).leading_zeros()\n@@ -322,6 +356,18 @@ assert_eq!(n.trailing_zeros(), 2);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn trailing_zeros(self) -> u32 {\n+                (self as $UnsignedT).trailing_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn trailing_zeros(self) -> u32 {\n                 (self as $UnsignedT).trailing_zeros()\n@@ -396,6 +442,16 @@ $EndFeature, \"\n         /// assert_eq!(m, 21760);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(not(stage0))]\n+        #[rustc_const_unstable(feature = \"const_int_ops\")]\n+        #[inline]\n+        pub const fn swap_bytes(self) -> Self {\n+            (self as $UnsignedT).swap_bytes() as Self\n+        }\n+\n+        /// Dummy docs. See !stage0 documentation.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         #[inline]\n         pub fn swap_bytes(self) -> Self {\n             (self as $UnsignedT).swap_bytes() as Self\n@@ -447,6 +503,25 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn from_be(x: Self) -> Self {\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn from_be(x: Self) -> Self {\n                 if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -473,6 +548,25 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn from_le(x: Self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn from_le(x: Self) -> Self {\n                 if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -499,6 +593,25 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn to_be(self) -> Self { // or not to be?\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn to_be(self) -> Self { // or not to be?\n                 if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -525,6 +638,25 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn to_le(self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn to_le(self) -> Self {\n                 if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n@@ -1943,6 +2075,19 @@ impl isize {\n     int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\" }\n }\n \n+// Emits the correct `cttz` call, depending on the size of the type.\n+macro_rules! uint_cttz_call {\n+    // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n+    // emits two conditional moves on x86_64. By promoting the value to\n+    // u16 and setting bit 8, we get better code without any conditional\n+    // operations.\n+    // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n+    // pending, remove this workaround once LLVM generates better code\n+    // for cttz8.\n+    ($value:expr, 8) => { intrinsics::cttz($value as u16 | 0x100) };\n+    ($value:expr, $_BITS:expr) => { intrinsics::cttz($value) }\n+}\n+\n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr) => {\n@@ -2020,6 +2165,18 @@ Basic usage:\n assert_eq!(n.count_ones(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn count_ones(self) -> u32 {\n+                unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn count_ones(self) -> u32 {\n                 unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n@@ -2037,6 +2194,18 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n@@ -2056,6 +2225,18 @@ Basic usage:\n assert_eq!(n.leading_zeros(), 2);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn leading_zeros(self) -> u32 {\n+                unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn leading_zeros(self) -> u32 {\n                 unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n@@ -2076,22 +2257,21 @@ Basic usage:\n assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn trailing_zeros(self) -> u32 {\n+                unsafe { uint_cttz_call!(self, $BITS) as u32 }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn trailing_zeros(self) -> u32 {\n-                // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n-                // emits two conditional moves on x86_64. By promoting the value to\n-                // u16 and setting bit 8, we get better code without any conditional\n-                // operations.\n-                // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n-                // pending, remove this workaround once LLVM generates better code\n-                // for cttz8.\n-                unsafe {\n-                    if $BITS == 8 {\n-                        intrinsics::cttz(self as u16 | 0x100) as u32\n-                    } else {\n-                        intrinsics::cttz(self) as u32\n-                    }\n-                }\n+                unsafe { uint_cttz_call!(self, $BITS) as u32 }\n             }\n         }\n \n@@ -2167,6 +2347,16 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n         /// assert_eq!(m, 21760);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(not(stage0))]\n+        #[rustc_const_unstable(feature = \"const_int_ops\")]\n+        #[inline]\n+        pub const fn swap_bytes(self) -> Self {\n+            unsafe { intrinsics::bswap(self as $ActualT) as Self }\n+        }\n+\n+        /// Dummy docs. See !stage0 documentation.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         #[inline]\n         pub fn swap_bytes(self) -> Self {\n             unsafe { intrinsics::bswap(self as $ActualT) as Self }\n@@ -2218,6 +2408,25 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn from_be(x: Self) -> Self {\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn from_be(x: Self) -> Self {\n                 if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -2244,6 +2453,25 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn from_le(x: Self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn from_le(x: Self) -> Self {\n                 if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -2270,6 +2498,25 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn to_be(self) -> Self { // or not to be?\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn to_be(self) -> Self { // or not to be?\n                 if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -2296,6 +2543,25 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n+            #[inline]\n+            pub const fn to_le(self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             #[inline]\n             pub fn to_le(self) -> Self {\n                 if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }"}, {"sha": "c5792d62aa92c16f30d8095f10ad856d4b54896c", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -2541,6 +2541,12 @@ macro_rules! iterator {\n                 accum\n             }\n         }\n+\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n+        impl<'a, T> FusedIterator for $name<'a, T> {}\n+\n+        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+        unsafe impl<'a, T> TrustedLen for $name<'a, T> {}\n     }\n }\n \n@@ -2667,12 +2673,6 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n     }\n }\n \n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for Iter<'a, T> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, T> TrustedLen for Iter<'a, T> {}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n@@ -2734,9 +2734,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n-    /// to consume the iterator. Consider using the `Slice` and\n-    /// `SliceMut` implementations for obtaining slices with more\n-    /// restricted lifetimes that do not consume the iterator.\n+    /// to consume the iterator.\n     ///\n     /// # Examples\n     ///\n@@ -2795,13 +2793,6 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for IterMut<'a, T> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, T> TrustedLen for IterMut<'a, T> {}\n-\n-\n // Return the number of elements of `T` from `start` to `end`.\n // Return the arithmetic difference if `T` is zero size.\n #[inline(always)]\n@@ -3399,6 +3390,9 @@ impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for Windows<'a, T> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Windows<'a, T> {}\n \n@@ -3518,6 +3512,9 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for Chunks<'a, T> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Chunks<'a, T> {}\n \n@@ -3634,6 +3631,9 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for ChunksMut<'a, T> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for ChunksMut<'a, T> {}\n \n@@ -3744,6 +3744,9 @@ impl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for ExactChunks<'a, T> {}\n+\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n \n@@ -3841,6 +3844,9 @@ impl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for ExactChunksMut<'a, T> {}\n+\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n "}, {"sha": "0adbdbe99333f1c2dd4e7f109f865f37fecc4c60", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -134,9 +134,6 @@ pub struct Export {\n     /// The visibility of the export.\n     /// We include non-`pub` exports for hygienic macros that get used from extern crates.\n     pub vis: ty::Visibility,\n-    /// True if from a `use` or and `extern crate`.\n-    /// Used in rustdoc.\n-    pub is_import: bool,\n }\n \n impl CtorKind {"}, {"sha": "a781fc7240ab3882394c651dcadbda484e0d94c7", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -1115,8 +1115,7 @@ impl_stable_hash_for!(struct hir::def::Export {\n     ident,\n     def,\n     vis,\n-    span,\n-    is_import\n+    span\n });\n \n impl<'a> HashStable<StableHashingContext<'a>>"}, {"sha": "2c8f021c6a520b4d719e4820410a87b071b08b9f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -1304,8 +1304,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"enable polonius-based borrow-checker\"),\n     codegen_time_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"generate a graphical HTML report of time spent in codegen and LLVM\"),\n-    trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"generate a graphical HTML report of time spent in trans and LLVM\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n     inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "14d20b6dbe2973a53597fbf2579ee9a9f473bddf", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -191,14 +191,23 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n                 let discr = self.codegen_operand(&bx, discr);\n-                if switch_ty == bx.tcx().types.bool {\n+                if targets.len() == 2 {\n+                    // If there are two targets, emit br instead of switch\n                     let lltrue = llblock(self, targets[0]);\n                     let llfalse = llblock(self, targets[1]);\n-                    if let [0] = values[..] {\n-                        bx.cond_br(discr.immediate(), llfalse, lltrue);\n+                    if switch_ty == bx.tcx().types.bool {\n+                        // Don't generate trivial icmps when switching on bool\n+                        if let [0] = values[..] {\n+                            bx.cond_br(discr.immediate(), llfalse, lltrue);\n+                        } else {\n+                            assert_eq!(&values[..], &[1]);\n+                            bx.cond_br(discr.immediate(), lltrue, llfalse);\n+                        }\n                     } else {\n-                        assert_eq!(&values[..], &[1]);\n-                        bx.cond_br(discr.immediate(), lltrue, llfalse);\n+                        let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n+                        let llval = C_uint_big(switch_llty, values[0]);\n+                        let cmp = bx.icmp(llvm::IntEQ, discr.immediate(), llval);\n+                        bx.cond_br(cmp, lltrue, llfalse);\n                     }\n                 } else {\n                     let (otherwise, targets) = targets.split_last().unwrap();"}, {"sha": "fd00cde375b90054fcef50854f0509f1102ba581", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -665,7 +665,6 @@ impl<'a, 'tcx> CrateMetadata {\n                         def: def,\n                         vis: ty::Visibility::Public,\n                         span: DUMMY_SP,\n-                        is_import: false,\n                     });\n                 }\n             }\n@@ -705,7 +704,6 @@ impl<'a, 'tcx> CrateMetadata {\n                                     ident: Ident::from_interned_str(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n-                                    is_import: false,\n                                 });\n                             }\n                         }\n@@ -722,8 +720,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n                     let ident = Ident::from_interned_str(name);\n                     let vis = self.get_visibility(child_index);\n-                    let is_import = false;\n-                    callback(def::Export { def, ident, vis, span, is_import });\n+                    callback(def::Export { def, ident, vis, span });\n                     // For non-re-export structs and variants add their constructors to children.\n                     // Re-export lists automatically contain constructors when necessary.\n                     match def {\n@@ -734,7 +731,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                 callback(def::Export {\n                                     def: ctor_def,\n                                     vis: self.get_visibility(ctor_def_id.index),\n-                                    ident, span, is_import,\n+                                    ident, span,\n                                 });\n                             }\n                         }\n@@ -744,7 +741,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             let ctor_kind = self.get_ctor_kind(child_index);\n                             let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n                             let vis = self.get_visibility(child_index);\n-                            callback(def::Export { def: ctor_def, ident, vis, span, is_import });\n+                            callback(def::Export { def: ctor_def, ident, vis, span });\n                         }\n                         _ => {}\n                     }"}, {"sha": "fe6909f7591592b676614abeb523c94dd04cf70e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -803,7 +803,6 @@ impl<'a> Resolver<'a> {\n                     def: def,\n                     vis: ty::Visibility::Public,\n                     span: item.span,\n-                    is_import: false,\n                 });\n             } else {\n                 self.unused_macros.insert(def_id);"}, {"sha": "c44f330128a2323cf28b69c5be869ccef4746b49", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -1008,7 +1008,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         def: def,\n                         span: binding.span,\n                         vis: binding.vis,\n-                        is_import: true,\n                     });\n                 }\n             }"}, {"sha": "4c773fc1dd78b7e1b7ae29b0fc8c489a836cd918", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -68,7 +68,8 @@ impl<'a, 'tcx, 'rcx> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n         }\n \n         for item in self.cx.tcx.item_children(def_id).iter() {\n-            if !item.is_import || item.vis == Visibility::Public {\n+            if self.cx.tcx.def_key(item.def.def_id()).parent.map_or(false, |d| d == def_id.index) ||\n+                item.vis == Visibility::Public {\n                 self.visit_item(item.def);\n             }\n         }"}, {"sha": "fa34b49210a6a5b90341da4a932df66a92341bea", "filename": "src/test/run-pass/const-endianess.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Ftest%2Frun-pass%2Fconst-endianess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6232478d26b0feca02fd6660edbf78a5c6327ec5/src%2Ftest%2Frun-pass%2Fconst-endianess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-endianess.rs?ref=6232478d26b0feca02fd6660edbf78a5c6327ec5", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_int_ops)]\n+#![feature(test)]\n+\n+extern crate test;\n+use test::black_box as b;\n+\n+const BE_U32: u32 = 55u32.to_be();\n+const LE_U32: u32 = 55u32.to_le();\n+\n+\n+fn main() {\n+    assert_eq!(BE_U32, b(55u32).to_be());\n+    assert_eq!(LE_U32, b(55u32).to_le());\n+\n+    #[cfg(not(target_arch = \"asmjs\"))]\n+    {\n+        const BE_U128: u128 = 999999u128.to_be();\n+        const LE_I128: i128 = -999999i128.to_le();\n+        assert_eq!(BE_U128, b(999999u128).to_be());\n+        assert_eq!(LE_I128, b(-999999i128).to_le());\n+    }\n+}"}]}