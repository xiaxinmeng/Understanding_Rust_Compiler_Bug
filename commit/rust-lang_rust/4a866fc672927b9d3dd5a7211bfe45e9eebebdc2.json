{"sha": "4a866fc672927b9d3dd5a7211bfe45e9eebebdc2", "node_id": "C_kwDOAAsO6NoAKDRhODY2ZmM2NzI5MjdiOWQzZGQ1YTcyMTFiZmU0NWU5ZWViZWJkYzI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-04T19:09:32Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-04T19:23:25Z"}, "message": "Simplify", "tree": {"sha": "3f7ac6187a85fb306e0070f1f78aefa16c818742", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f7ac6187a85fb306e0070f1f78aefa16c818742"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2", "html_url": "https://github.com/rust-lang/rust/commit/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/32bf7af83e3d6f201ebea87006f9c33bbc211f7b", "html_url": "https://github.com/rust-lang/rust/commit/32bf7af83e3d6f201ebea87006f9c33bbc211f7b"}], "stats": {"total": 98, "additions": 40, "deletions": 58}, "files": [{"sha": "6d3c2c2c4670c41f9ab6b701c063a87c0d8ffd87", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=4a866fc672927b9d3dd5a7211bfe45e9eebebdc2", "patch": "@@ -237,7 +237,7 @@ pub struct Mark {\n }\n \n /// The body of an item (function, const etc.).\n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n     pub exprs: Arena<Expr>,\n     pub pats: Arena<Pat>,\n@@ -353,7 +353,7 @@ impl Body {\n     ) -> impl Iterator<Item = (BlockId, Arc<DefMap>)> + '_ {\n         self.block_scopes\n             .iter()\n-            .map(move |block| (*block, db.block_def_map(*block).expect(\"block ID without DefMap\")))\n+            .map(move |&block| (block, db.block_def_map(block).expect(\"block ID without DefMap\")))\n     }\n \n     pub fn pattern_representative(&self, pat: PatId) -> PatId {"}, {"sha": "46b2ba8a254e2e8506792712f41af1956500885e", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 28, "deletions": 46, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=4a866fc672927b9d3dd5a7211bfe45e9eebebdc2", "patch": "@@ -97,6 +97,8 @@ pub(super) fn lower(\n         },\n         expander,\n         statements_in_scope: Vec::new(),\n+        name_to_pat_grouping: Default::default(),\n+        is_lowering_inside_or_pat: false,\n     }\n     .collect(params, body)\n }\n@@ -107,6 +109,9 @@ struct ExprCollector<'a> {\n     body: Body,\n     source_map: BodySourceMap,\n     statements_in_scope: Vec<Statement>,\n+    // a poor-mans union-find?\n+    name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n+    is_lowering_inside_or_pat: bool,\n }\n \n impl ExprCollector<'_> {\n@@ -706,14 +711,12 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        let mut name_to_pat = FxHashMap::default();\n-        let pat_id = self.collect_pat_(&mut name_to_pat, false, pat);\n-        for pats in name_to_pat.into_values() {\n+        let pat_id = self.collect_pat_(pat);\n+        for (_, pats) in self.name_to_pat_grouping.drain() {\n             let pats = Arc::<[_]>::from(pats);\n-            for &pat in &*pats {\n-                self.body.or_pats.insert(pat, pats.clone());\n-            }\n+            self.body.or_pats.extend(pats.iter().map(|&pat| (pat, pats.clone())));\n         }\n+        self.is_lowering_inside_or_pat = false;\n         pat_id\n     }\n \n@@ -724,21 +727,15 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_pat_(\n-        &mut self,\n-        name_to_pat: &mut FxHashMap<Name, Vec<PatId>>,\n-        in_or_pat: bool,\n-        pat: ast::Pat,\n-    ) -> PatId {\n+    fn collect_pat_(&mut self, pat: ast::Pat) -> PatId {\n         let pattern = match &pat {\n             ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n \n-                let key = in_or_pat.then(|| name.clone());\n+                let key = self.is_lowering_inside_or_pat.then(|| name.clone());\n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n-                let subpat =\n-                    bp.pat().map(|subpat| self.collect_pat_(name_to_pat, in_or_pat, subpat));\n+                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat));\n                 let pattern = if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n                     // This could also be a single-segment path pattern. To\n                     // decide that, we need to try resolving the name.\n@@ -774,14 +771,14 @@ impl ExprCollector<'_> {\n                 let ptr = AstPtr::new(&pat);\n                 let pat = self.alloc_pat(pattern, Either::Left(ptr));\n                 if let Some(key) = key {\n-                    name_to_pat.entry(key).or_default().push(pat);\n+                    self.name_to_pat_grouping.entry(key).or_default().push(pat);\n                 }\n                 return pat;\n             }\n             ast::Pat::TupleStructPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let (args, ellipsis) = self.collect_tuple_pat(name_to_pat, in_or_pat, p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n@@ -795,12 +792,13 @@ impl ExprCollector<'_> {\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::OrPat(p) => {\n-                let pats = p.pats().map(|p| self.collect_pat_(name_to_pat, true, p)).collect();\n+                self.is_lowering_inside_or_pat = true;\n+                let pats = p.pats().map(|p| self.collect_pat_(p)).collect();\n                 Pat::Or(pats)\n             }\n-            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(name_to_pat, in_or_pat, p.pat()),\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat()),\n             ast::Pat::TuplePat(p) => {\n-                let (args, ellipsis) = self.collect_tuple_pat(name_to_pat, in_or_pat, p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n                 Pat::Tuple { args, ellipsis }\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n@@ -813,7 +811,7 @@ impl ExprCollector<'_> {\n                     .fields()\n                     .filter_map(|f| {\n                         let ast_pat = f.pat()?;\n-                        let pat = self.collect_pat_(name_to_pat, in_or_pat, ast_pat);\n+                        let pat = self.collect_pat_(ast_pat);\n                         let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n@@ -832,15 +830,9 @@ impl ExprCollector<'_> {\n \n                 // FIXME properly handle `RestPat`\n                 Pat::Slice {\n-                    prefix: prefix\n-                        .into_iter()\n-                        .map(|p| self.collect_pat_(name_to_pat, in_or_pat, p))\n-                        .collect(),\n-                    slice: slice.map(|p| self.collect_pat_(name_to_pat, in_or_pat, p)),\n-                    suffix: suffix\n-                        .into_iter()\n-                        .map(|p| self.collect_pat_(name_to_pat, in_or_pat, p))\n-                        .collect(),\n+                    prefix: prefix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n+                    slice: slice.map(|p| self.collect_pat_(p)),\n+                    suffix: suffix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n                 }\n             }\n             ast::Pat::LiteralPat(lit) => {\n@@ -863,7 +855,7 @@ impl ExprCollector<'_> {\n                 Pat::Missing\n             }\n             ast::Pat::BoxPat(boxpat) => {\n-                let inner = self.collect_pat_opt_(name_to_pat, in_or_pat, boxpat.pat());\n+                let inner = self.collect_pat_opt_(boxpat.pat());\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n@@ -879,7 +871,7 @@ impl ExprCollector<'_> {\n                     let macro_ptr = AstPtr::new(&call);\n                     let mut pat = None;\n                     self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n-                        pat = Some(this.collect_pat_opt_(name_to_pat, in_or_pat, expanded_pat));\n+                        pat = Some(this.collect_pat_opt_(expanded_pat));\n                     });\n \n                     match pat {\n@@ -896,31 +888,21 @@ impl ExprCollector<'_> {\n         self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n-    fn collect_pat_opt_(\n-        &mut self,\n-        name_to_pat: &mut FxHashMap<Name, Vec<PatId>>,\n-        in_or_pat: bool,\n-        pat: Option<ast::Pat>,\n-    ) -> PatId {\n+    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat_(name_to_pat, in_or_pat, pat),\n+            Some(pat) => self.collect_pat_(pat),\n             None => self.missing_pat(),\n         }\n     }\n \n-    fn collect_tuple_pat(\n-        &mut self,\n-        name_to_pat: &mut FxHashMap<Name, Vec<PatId>>,\n-        in_or_pat: bool,\n-        args: AstChildren<ast::Pat>,\n-    ) -> (Box<[PatId]>, Option<usize>) {\n+    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n         // We want to skip the `..` pattern here, since we account for it above.\n         let args = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n-            .map(|p| self.collect_pat_(name_to_pat, in_or_pat, p))\n+            .map(|p| self.collect_pat_(p))\n             .collect();\n \n         (args, ellipsis)"}, {"sha": "5724090e636811f8fd3b4380cc1255ad2e0e5b0d", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=4a866fc672927b9d3dd5a7211bfe45e9eebebdc2", "patch": "@@ -1071,7 +1071,7 @@ fn function(field: u32) {\n         check_with_config(\n             r#\"\n fn foo() {\n-    let x = 5;\n+    let x$0 = 5;\n     let y = x * 2;\n }\n \"#,\n@@ -1091,7 +1091,7 @@ fn foo() {\n         check_with_config(\n             r#\"\n fn foo() {\n-    let x = 5;\n+    let x$0 = 5;\n     let y = x * 2;\n \n     loop {\n@@ -1108,7 +1108,7 @@ fn foo() {\n     let x = 5;\n     let y = x * 2;\n \n-    loop {\n+    loop$0 {\n //  ^^^^\n         break;\n //      ^^^^^\n@@ -1131,7 +1131,7 @@ fn foo() {\n         check_with_config(\n             r#\"\n async fn foo() {\n-    let x = 5;\n+    let x$0 = 5;\n     let y = x * 2;\n \n     0.await;\n@@ -1147,7 +1147,7 @@ async fn foo() {\n         let x = 5;\n         let y = x * 2;\n \n-        0.await;\n+        0.await$0;\n //        ^^^^^\n }\n \"#,\n@@ -1167,7 +1167,7 @@ async fn foo() {\n         check_with_config(\n             r#\"\n fn foo() -> i32 {\n-    let x = 5;\n+    let x$0 = 5;\n     let y = x * 2;\n \n     if true {\n@@ -1182,7 +1182,7 @@ fn foo() -> i32 {\n \n         check_with_config(\n             r#\"\n-fn foo() -> i32 {\n+fn foo() ->$0 i32 {\n     let x = 5;\n     let y = x * 2;\n \n@@ -1211,7 +1211,7 @@ fn foo() -> i32 {\n             r#\"\n fn foo() {\n     loop {\n-        break;\n+        break$0;\n     }\n }\n \"#,\n@@ -1230,7 +1230,7 @@ fn foo() {\n \n         check_with_config(\n             r#\"\n-async fn foo() {\n+async$0 fn foo() {\n     0.await;\n }\n \"#,\n@@ -1249,7 +1249,7 @@ async fn foo() {\n \n         check_with_config(\n             r#\"\n-fn foo() -> i32 {\n+fn foo() ->$0 i32 {\n     if true {\n         return -1;\n     }"}]}