{"sha": "e1968dd6120935055e138ab10c6e0a3f3f2288b9", "node_id": "C_kwDOAAsO6NoAKGUxOTY4ZGQ2MTIwOTM1MDU1ZTEzOGFiMTBjNmUwYTNmM2YyMjg4Yjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-03T13:50:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-03T13:50:22Z"}, "message": "Auto merge of #2747 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "ba3fe5528a05e3125c20931e1c5f1fac21eeeb6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba3fe5528a05e3125c20931e1c5f1fac21eeeb6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1968dd6120935055e138ab10c6e0a3f3f2288b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1968dd6120935055e138ab10c6e0a3f3f2288b9", "html_url": "https://github.com/rust-lang/rust/commit/e1968dd6120935055e138ab10c6e0a3f3f2288b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1968dd6120935055e138ab10c6e0a3f3f2288b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1010099fe359e4a01ebd873e3bdb2d66b60bc3ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed", "html_url": "https://github.com/rust-lang/rust/commit/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed"}, {"sha": "794cc0854a36f445307f8010a0ad8698da0bf5ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/794cc0854a36f445307f8010a0ad8698da0bf5ed", "html_url": "https://github.com/rust-lang/rust/commit/794cc0854a36f445307f8010a0ad8698da0bf5ed"}], "stats": {"total": 17669, "additions": 12080, "deletions": 5589}, "files": [{"sha": "d732075fb2d07fb84f1873ac7221f64f52a47947", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -8,9 +8,9 @@ members](https://rust-lang.zulipchat.com/#narrow/stream/122652-new-members)\n Zulip stream. We have lots of docs below of how to get started on your own, but\n the Zulip stream is the best place to *ask* for help.\n \n-Documentation for contributing to Rust is located in the [Guide to Rustc Development](https://rustc-dev-guide.rust-lang.org/),\n-commonly known as the [rustc-dev-guide]. Despite the name, this guide documents\n-not just how to develop rustc (the Rust compiler), but also how to contribute to the standard library and rustdoc.\n+Documentation for contributing to the compiler or tooling is located in the [Guide to Rustc\n+Development][rustc-dev-guide], commonly known as the [rustc-dev-guide]. Documentation for the\n+standard library in the [Standard library developers Guide][std-dev-guide], commonly known as the [std-dev-guide].\n \n ## About the [rustc-dev-guide]\n \n@@ -35,6 +35,7 @@ refer to [this section][contributing-bug-reports] and [open an issue][issue temp\n \n [Contributing to Rust]: https://rustc-dev-guide.rust-lang.org/contributing.html#contributing-to-rust\n [rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n+[std-dev-guide]: https://std-dev-guide.rust-lang.org/\n [contributing-bug-reports]: https://rustc-dev-guide.rust-lang.org/contributing.html#bug-reports\n [issue template]: https://github.com/rust-lang/rust/issues/new/choose\n [internals]: https://internals.rust-lang.org"}, {"sha": "f99e58e59b8e55d48bcb40f6153be3a1ed397531", "filename": "Cargo.lock", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2675,9 +2675,9 @@ dependencies = [\n \n [[package]]\n name = \"owo-colors\"\n-version = \"3.4.0\"\n+version = \"3.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"decf7381921fea4dcb2549c5667eda59b3ec297ab7e2b5fc33eac69d2e7da87b\"\n+checksum = \"c1b04fb49957986fdce4d6ee7a65027d55d4b6d2265e5848bbb507b58ccfdb6f\"\n \n [[package]]\n name = \"packed_simd_2\"\n@@ -5203,9 +5203,9 @@ dependencies = [\n \n [[package]]\n name = \"termcolor\"\n-version = \"1.1.2\"\n+version = \"1.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2dfed899f0eb03f32ee8c6a0aabdb8a7949659e3466561fc0adf54e26d88c5f4\"\n+checksum = \"bab24d30b911b2376f3a13cc2cd443142f0c81dda04c118693e35b3835757755\"\n dependencies = [\n  \"winapi-util\",\n ]\n@@ -5309,6 +5309,7 @@ dependencies = [\n  \"lazy_static\",\n  \"miropt-test-tools\",\n  \"regex\",\n+ \"termcolor\",\n  \"walkdir\",\n ]\n "}, {"sha": "ac39435a8c7fb9338a0f278452e2d8ff8afa525d", "filename": "README.md", "status": "modified", "additions": 65, "deletions": 63, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -5,12 +5,8 @@ standard library, and documentation.\n \n [Rust]: https://www.rust-lang.org\n \n-**Note: this README is for _users_ rather than _contributors_.\n-If you wish to _contribute_ to the compiler, you should read the\n-[Getting Started][gettingstarted] section of the rustc-dev-guide instead.\n-You can ask for help in the [#new members Zulip stream][new-members].**\n-\n-[new-members]: https://rust-lang.zulipchat.com/#narrow/stream/122652-new-members\n+**Note: this README is for _users_ rather than _contributors_.**\n+If you wish to _contribute_ to the compiler, you should read [CONTRIBUTING.md](CONTRIBUTING.md) instead.\n \n ## Quick Start\n \n@@ -24,22 +20,23 @@ Read [\"Installation\"] from [The Book].\n The Rust build system uses a Python script called `x.py` to build the compiler,\n which manages the bootstrapping process. It lives at the root of the project.\n \n-The `x.py` command can be run directly on most systems in the following format:\n+The `x.py` command can be run directly on most Unix systems in the following format:\n \n ```sh\n ./x.py <subcommand> [flags]\n ```\n \n-This is how the documentation and examples assume you are running `x.py`.\n-\n-Systems such as Ubuntu 20.04 LTS do not create the necessary `python` command by default when Python is installed that allows `x.py` to be run directly. In that case, you can either create a symlink for `python` (Ubuntu provides the `python-is-python3` package for this), or run `x.py` using Python itself:\n+This is how the documentation and examples assume you are running `x.py`. Some alternative ways are:\n \n ```sh\n-# Python 3\n-python3 x.py <subcommand> [flags]\n+# On a Unix shell if you don't have the necessary `python3` command\n+./x <subcommand> [flags]\n \n-# Python 2.7\n-python2.7 x.py <subcommand> [flags]\n+# On the Windows Command Prompt (if .py files are configured to run Python)\n+x.py <subcommand> [flags]\n+\n+# You can also run Python yourself, e.g.:\n+python x.py <subcommand> [flags]\n ```\n \n More information about `x.py` can be found\n@@ -48,20 +45,37 @@ by running it with the `--help` flag or reading the [rustc dev guide][rustcguide\n [gettingstarted]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n [rustcguidebuild]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n \n-### Building on a Unix-like system\n-1. Make sure you have installed the dependencies:\n+### Dependencies\n+\n+Make sure you have installed the dependencies:\n \n-   * `g++` 5.1 or later or `clang++` 3.5 or later\n    * `python` 3 or 2.7\n-   * GNU `make` 3.81 or later\n-   * `cmake` 3.13.4 or later\n-   * `ninja`\n-   * `curl`\n    * `git`\n-   * `ssl` which comes in `libssl-dev` or `openssl-devel`\n+   * A C compiler (when building for the host, `cc` is enough; cross-compiling may need additional compilers)\n+   * `curl` (not needed on Windows)\n    * `pkg-config` if you are compiling on Linux and targeting Linux\n+   * `libiconv` (already included with glibc on Debian-based distros)\n+\n+To build cargo, you'll also need OpenSSL (`libssl-dev` or `openssl-devel` on most Unix distros).\n+\n+If building LLVM from source, you'll need additional tools:\n+\n+* `g++`, `clang++`, or MSVC with versions listed on\n+  [LLVM's documentation](https://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library)\n+* `ninja`, or GNU `make` 3.81 or later (ninja is recommended, especially on Windows)\n+* `cmake` 3.13.4 or later\n+* `libstdc++-static` may be required on some Linux distributions such as Fedora and Ubuntu\n+\n+On tier 1 or tier 2 with host tools platforms, you can also choose to download LLVM by setting `llvm.download-ci-llvm = true`.\n+Otherwise, you'll need LLVM installed and `llvm-config` in your path.\n+See [the rustc-dev-guide for more info][sysllvm].\n+\n+[sysllvm]: https://rustc-dev-guide.rust-lang.org/building/new-target.html#using-pre-built-llvm\n+\n+\n+### Building on a Unix-like system\n \n-2. Clone the [source] with `git`:\n+1. Clone the [source] with `git`:\n \n    ```sh\n    git clone https://github.com/rust-lang/rust.git\n@@ -70,38 +84,49 @@ by running it with the `--help` flag or reading the [rustc dev guide][rustcguide\n \n [source]: https://github.com/rust-lang/rust\n \n-3. Configure the build settings:\n+2. Configure the build settings:\n \n     The Rust build system uses a file named `config.toml` in the root of the\n     source tree to determine various configuration settings for the build.\n-    Copy the default `config.toml.example` to `config.toml` to get started.\n+    Set up the defaults intended for distros to get started. You can see a full list of options\n+    in `config.toml.example`.\n \n     ```sh\n-    cp config.toml.example config.toml\n+    printf 'profile = \"user\" \\nchangelog-seen = 2 \\n' > config.toml\n     ```\n \n     If you plan to use `x.py install` to create an installation, it is recommended\n     that you set the `prefix` value in the `[install]` section to a directory.\n \n-    Create an install directory if you are not installing in the default directory.\n-\n-4. Build and install:\n+3. Build and install:\n \n     ```sh\n     ./x.py build && ./x.py install\n     ```\n \n     When complete, `./x.py install` will place several programs into\n     `$PREFIX/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n-    API-documentation tool. This install does not include [Cargo],\n-    Rust's package manager. To build and install Cargo, you may\n-    run `./x.py install cargo` or set the `build.extended` key in\n-    `config.toml` to `true` to build and install all tools.\n+    API-documentation tool. If you've set `profile = \"user\"` or `build.extended = true`, it will\n+    also include [Cargo], Rust's package manager.\n \n [Cargo]: https://github.com/rust-lang/cargo\n \n ### Building on Windows\n \n+On Windows, we suggest using [winget] to install dependencies by running the following in a terminal:\n+\n+```powershell\n+winget install -e Python.Python.3\n+winget install -e Kitware.CMake\n+winget install -e Git.Git\n+```\n+\n+Then edit your system's `PATH` variable and add: `C:\\Program Files\\CMake\\bin`. See\n+[this guide on editing the system `PATH`](https://www.java.com/en/download/help/path.html) from the\n+Java documentation.\n+\n+[winget]: https://github.com/microsoft/winget-cli\n+\n There are two prominent ABIs in use on Windows: the native (MSVC) ABI used by\n Visual Studio and the GNU ABI used by the GCC toolchain. Which version of Rust\n you need depends largely on what C/C++ libraries you want to interoperate with.\n@@ -190,7 +215,7 @@ Windows build triples are:\n     - `x86_64-pc-windows-msvc`\n \n The build triple can be specified by either specifying `--build=<triple>` when\n-invoking `x.py` commands, or by copying the `config.toml` file (as described\n+invoking `x.py` commands, or by creating a `config.toml` file (as described\n in [Installing From Source](#installing-from-source)), and modifying the\n `build` option under the `[build]` section.\n \n@@ -204,9 +229,7 @@ configure script and makefile (the latter of which just invokes `x.py`).\n make && sudo make install\n ```\n \n-When using the configure script, the generated `config.mk` file may override the\n-`config.toml` file. To go back to the `config.toml` file, delete the generated\n-`config.mk` file.\n+`configure` generates a `config.toml` which can also be used with normal `x.py` invocations.\n \n ## Building Documentation\n \n@@ -227,41 +250,20 @@ precompiled \"snapshot\" version of itself (made in an earlier stage of\n development). As such, source builds require an Internet connection to\n fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n-Snapshot binaries are currently built and tested on several platforms:\n-\n-| Platform / Architecture                     | x86 | x86_64 |\n-|---------------------------------------------|-----|--------|\n-| Windows (7, 8, 10, ...)                     | \u2713   | \u2713      |\n-| Linux (kernel 3.2, glibc 2.17 or later)     | \u2713   | \u2713      |\n-| macOS (10.7 Lion or later)                  | (\\*) | \u2713      |\n-\n-(\\*): Apple dropped support for running 32-bit binaries starting from macOS 10.15 and iOS 11.\n-Due to this decision from Apple, the targets are no longer useful to our users.\n-Please read [our blog post][macx32] for more info.\n-\n-[macx32]: https://blog.rust-lang.org/2020/01/03/reducing-support-for-32-bit-apple-targets.html\n+See https://doc.rust-lang.org/nightly/rustc/platform-support.html for a list of supported platforms.\n+Only \"host tools\" platforms have a pre-compiled snapshot binary available; to compile for a platform\n+without host tools you must cross-compile.\n \n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work.\n \n ## Getting Help\n \n-The Rust community congregates in a few places:\n-\n-* [Stack Overflow] - Direct questions about using the language.\n-* [users.rust-lang.org] - General discussion and broader questions.\n-* [/r/rust] - News and general discussion.\n-\n-[Stack Overflow]: https://stackoverflow.com/questions/tagged/rust\n-[/r/rust]: https://reddit.com/r/rust\n-[users.rust-lang.org]: https://users.rust-lang.org/\n+See https://www.rust-lang.org/community for a list of chat platforms and forums.\n \n ## Contributing\n \n-If you are interested in contributing to the Rust project, please take a look\n-at the [Getting Started][gettingstarted] guide in the [rustc-dev-guide].\n-\n-[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org\n+See [CONTRIBUTING.md](CONTRIBUTING.md).\n \n ## License\n "}, {"sha": "c1b26ca0925380293e9fca902bf60119b53d4dcf", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -572,7 +572,7 @@ impl Pat {\n             PatKind::MacCall(mac) => TyKind::MacCall(mac.clone()),\n             // `&mut? P` can be reinterpreted as `&mut? T` where `T` is `P` reparsed as a type.\n             PatKind::Ref(pat, mutbl) => {\n-                pat.to_ty().map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?\n+                pat.to_ty().map(|ty| TyKind::Ref(None, MutTy { ty, mutbl: *mutbl }))?\n             }\n             // A slice/array pattern `[P]` can be reparsed as `[T]`, an unsized array,\n             // when `P` can be reparsed as a type `T`.\n@@ -1193,7 +1193,7 @@ impl Expr {\n             ExprKind::Paren(expr) => expr.to_ty().map(TyKind::Paren)?,\n \n             ExprKind::AddrOf(BorrowKind::Ref, mutbl, expr) => {\n-                expr.to_ty().map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?\n+                expr.to_ty().map(|ty| TyKind::Ref(None, MutTy { ty, mutbl: *mutbl }))?\n             }\n \n             ExprKind::Repeat(expr, expr_len) => {\n@@ -2031,7 +2031,7 @@ impl Clone for Ty {\n impl Ty {\n     pub fn peel_refs(&self) -> &Self {\n         let mut final_ty = self;\n-        while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n+        while let TyKind::Ref(_, MutTy { ty, .. }) = &final_ty.kind {\n             final_ty = ty;\n         }\n         final_ty\n@@ -2058,7 +2058,7 @@ pub enum TyKind {\n     /// A raw pointer (`*const T` or `*mut T`).\n     Ptr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`).\n-    Rptr(Option<Lifetime>, MutTy),\n+    Ref(Option<Lifetime>, MutTy),\n     /// A bare function (e.g., `fn(usize) -> bool`).\n     BareFn(P<BareFnTy>),\n     /// The never type (`!`).\n@@ -2286,7 +2286,7 @@ impl Param {\n             if ident.name == kw::SelfLower {\n                 return match self.ty.kind {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n-                    TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.kind.is_implicit_self() => {\n+                    TyKind::Ref(lt, MutTy { ref ty, mutbl }) if ty.kind.is_implicit_self() => {\n                         Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n                     _ => Some(respan(\n@@ -2319,7 +2319,7 @@ impl Param {\n                 Mutability::Not,\n                 P(Ty {\n                     id: DUMMY_NODE_ID,\n-                    kind: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl }),\n+                    kind: TyKind::Ref(lt, MutTy { ty: infer_ty, mutbl }),\n                     span,\n                     tokens: None,\n                 }),\n@@ -2743,8 +2743,19 @@ impl Item {\n /// `extern` qualifier on a function item or function type.\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub enum Extern {\n+    /// No explicit extern keyword was used\n+    ///\n+    /// E.g. `fn foo() {}`\n     None,\n+    /// An explicit extern keyword was used, but with implicit ABI\n+    ///\n+    /// E.g. `extern fn foo() {}`\n+    ///\n+    /// This is just `extern \"C\"` (see `rustc_target::spec::abi::Abi::FALLBACK`)\n     Implicit(Span),\n+    /// An explicit extern keyword was used with an explicit ABI\n+    ///\n+    /// E.g. `extern \"C\" fn foo() {}`\n     Explicit(StrLit, Span),\n }\n \n@@ -2763,9 +2774,13 @@ impl Extern {\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct FnHeader {\n+    /// The `unsafe` keyword, if any\n     pub unsafety: Unsafe,\n+    /// The `async` keyword, if any\n     pub asyncness: Async,\n+    /// The `const` keyword, if any\n     pub constness: Const,\n+    /// The `extern` keyword and corresponding ABI string, if any\n     pub ext: Extern,\n }\n "}, {"sha": "c572171e8f44393c65f7eba5ce499cd2e8286672", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -459,7 +459,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err | TyKind::Never | TyKind::CVarArgs => {}\n         TyKind::Slice(ty) => vis.visit_ty(ty),\n         TyKind::Ptr(mt) => vis.visit_mt(mt),\n-        TyKind::Rptr(lt, mt) => {\n+        TyKind::Ref(lt, mt) => {\n             visit_opt(lt, |lt| noop_visit_lifetime(lt, vis));\n             vis.visit_mt(mt);\n         }"}, {"sha": "5b6cf30fa96e37f416ba2edcf8cc1545d4731118", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -379,6 +379,10 @@ impl Token {\n         }\n     }\n \n+    pub fn is_range_separator(&self) -> bool {\n+        [DotDot, DotDotDot, DotDotEq].contains(&self.kind)\n+    }\n+\n     pub fn is_op(&self) -> bool {\n         match self.kind {\n             Eq | Lt | Le | EqEq | Ne | Ge | Gt | AndAnd | OrOr | Not | Tilde | BinOp(_)"}, {"sha": "df7145a722a46e52c9de6072d6467d7a525f0b09", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -92,7 +92,7 @@ impl<'a> FnKind<'a> {\n #[derive(Copy, Clone, Debug)]\n pub enum LifetimeCtxt {\n     /// Appears in a reference type.\n-    Rptr,\n+    Ref,\n     /// Appears as a bound on a type or another lifetime.\n     Bound,\n     /// Appears as a generic argument.\n@@ -396,8 +396,8 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n     match &typ.kind {\n         TyKind::Slice(ty) | TyKind::Paren(ty) => visitor.visit_ty(ty),\n         TyKind::Ptr(mutable_type) => visitor.visit_ty(&mutable_type.ty),\n-        TyKind::Rptr(opt_lifetime, mutable_type) => {\n-            walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Rptr);\n+        TyKind::Ref(opt_lifetime, mutable_type) => {\n+            walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Ref);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n         TyKind::Tup(tuple_element_types) => {"}, {"sha": "b6b242bfc27fcc371e6bb19e93bbcd91d1e7faec", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -259,8 +259,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         body.as_deref(),\n                     );\n \n-                    let mut itctx = ImplTraitContext::Universal;\n-                    let (generics, decl) = this.lower_generics(generics, id, &mut itctx, |this| {\n+                    let itctx = ImplTraitContext::Universal;\n+                    let (generics, decl) = this.lower_generics(generics, id, &itctx, |this| {\n                         let ret_id = asyncness.opt_return_id();\n                         this.lower_fn_decl(&decl, id, *fn_sig_span, FnDeclKind::Fn, ret_id)\n                     });\n@@ -369,9 +369,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // method, it will not be considered an in-band\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n-                let mut itctx = ImplTraitContext::Universal;\n+                let itctx = ImplTraitContext::Universal;\n                 let (generics, (trait_ref, lowered_ty)) =\n-                    self.lower_generics(ast_generics, id, &mut itctx, |this| {\n+                    self.lower_generics(ast_generics, id, &itctx, |this| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n@@ -590,9 +590,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             kind: match &i.kind {\n                 ForeignItemKind::Fn(box Fn { sig, generics, .. }) => {\n                     let fdec = &sig.decl;\n-                    let mut itctx = ImplTraitContext::Universal;\n+                    let itctx = ImplTraitContext::Universal;\n                     let (generics, (fn_dec, fn_args)) =\n-                        self.lower_generics(generics, i.id, &mut itctx, |this| {\n+                        self.lower_generics(generics, i.id, &itctx, |this| {\n                             (\n                                 // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(\n@@ -1184,8 +1184,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         is_async: Option<(NodeId, Span)>,\n     ) -> (&'hir hir::Generics<'hir>, hir::FnSig<'hir>) {\n         let header = self.lower_fn_header(sig.header);\n-        let mut itctx = ImplTraitContext::Universal;\n-        let (generics, decl) = self.lower_generics(generics, id, &mut itctx, |this| {\n+        let itctx = ImplTraitContext::Universal;\n+        let (generics, decl) = self.lower_generics(generics, id, &itctx, |this| {\n             this.lower_fn_decl(&sig.decl, id, sig.span, kind, is_async)\n         });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })\n@@ -1316,6 +1316,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 param.id,\n                 &param.kind,\n                 &param.bounds,\n+                param.colon_span,\n+                generics.span,\n                 itctx,\n                 PredicateOrigin::GenericParam,\n             )\n@@ -1365,6 +1367,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         kind: &GenericParamKind,\n         bounds: &[GenericBound],\n+        colon_span: Option<Span>,\n+        parent_span: Span,\n         itctx: &ImplTraitContext,\n         origin: PredicateOrigin,\n     ) -> Option<hir::WherePredicate<'hir>> {\n@@ -1377,21 +1381,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let ident = self.lower_ident(ident);\n         let param_span = ident.span;\n-        let span = bounds\n-            .iter()\n-            .fold(Some(param_span.shrink_to_hi()), |span: Option<Span>, bound| {\n-                let bound_span = bound.span();\n-                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n-                // as we use this method to get a span appropriate for suggestions.\n-                if !bound_span.can_be_used_for_suggestions() {\n-                    None\n-                } else if let Some(span) = span {\n-                    Some(span.to(bound_span))\n-                } else {\n-                    Some(bound_span)\n-                }\n-            })\n-            .unwrap_or(param_span.shrink_to_hi());\n+\n+        // Reconstruct the span of the entire predicate from the individual generic bounds.\n+        let span_start = colon_span.unwrap_or_else(|| param_span.shrink_to_hi());\n+        let span = bounds.iter().fold(span_start, |span_accum, bound| {\n+            match bound.span().find_ancestor_inside(parent_span) {\n+                Some(bound_span) => span_accum.to(bound_span),\n+                None => span_accum,\n+            }\n+        });\n+        let span = self.lower_span(span);\n+\n         match kind {\n             GenericParamKind::Const { .. } => None,\n             GenericParamKind::Type { .. } => {"}, {"sha": "83174afdb12ef907cc8cc81ed094612abe3f449e", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -776,7 +776,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Intercept all spans entering HIR.\n     /// Mark a span as relative to the current owning item.\n     fn lower_span(&self, span: Span) -> Span {\n-        if self.tcx.sess.opts.unstable_opts.incremental_relative_spans {\n+        if self.tcx.sess.opts.incremental_relative_spans() {\n             span.with_parent(Some(self.current_hir_id_owner.def_id))\n         } else {\n             // Do not make spans relative when not using incremental compilation.\n@@ -1238,7 +1238,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::Err => hir::TyKind::Err,\n             TyKind::Slice(ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n-            TyKind::Rptr(region, mt) => {\n+            TyKind::Ref(region, mt) => {\n                 let region = region.unwrap_or_else(|| {\n                     let id = if let Some(LifetimeRes::ElidedAnchor { start, end }) =\n                         self.resolver.get_lifetime_res(t.id)\n@@ -1252,7 +1252,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     Lifetime { ident: Ident::new(kw::UnderscoreLifetime, span), id }\n                 });\n                 let lifetime = self.lower_lifetime(&region);\n-                hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n+                hir::TyKind::Ref(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(f) => {\n                 let generic_params = self.lower_lifetime_binder(t.id, &f.generic_params);\n@@ -1656,9 +1656,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // Lowers a function declaration.\n     //\n     // `decl`: the unlowered (AST) function declaration.\n-    // `fn_def_id`: if `Some`, impl Trait arguments are lowered into generic parameters on the\n-    //      given DefId, otherwise impl Trait is disallowed. Must be `Some` if\n-    //      `make_ret_async` is also `Some`.\n+    // `fn_node_id`: `impl Trait` arguments are lowered into generic parameters on the given `NodeId`.\n     // `make_ret_async`: if `Some`, converts `-> T` into `-> impl Future<Output = T>` in the\n     //      return type. This is used for `async fn` declarations. The `NodeId` is the ID of the\n     //      return type `impl Trait` item, and the `Span` points to the `async` keyword.\n@@ -1773,7 +1771,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // Given we are only considering `ImplicitSelf` types, we needn't consider\n                     // the case where we have a mutable pattern to a reference as that would\n                     // no longer be an `ImplicitSelf`.\n-                    TyKind::Rptr(_, mt) if mt.ty.kind.is_implicit_self() => match mt.mutbl {\n+                    TyKind::Ref(_, mt) if mt.ty.kind.is_implicit_self() => match mt.mutbl {\n                         hir::Mutability::Not => hir::ImplicitSelfKind::ImmRef,\n                         hir::Mutability::Mut => hir::ImplicitSelfKind::MutRef,\n                     },\n@@ -1789,7 +1787,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     //     type OpaqueTy<generics_from_parent_fn> = impl Future<Output = T>;\n     //\n     // `output`: unlowered output type (`T` in `-> T`)\n-    // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n+    // `fn_node_id`: `NodeId` of the parent function (used to create child impl trait definition)\n     // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created\n     #[instrument(level = \"debug\", skip(self))]\n     fn lower_async_fn_ret_ty(\n@@ -2031,15 +2029,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         output: &FnRetTy,\n         span: Span,\n-        mut nested_impl_trait_context: ImplTraitContext,\n+        nested_impl_trait_context: ImplTraitContext,\n     ) -> hir::GenericBound<'hir> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n         let output_ty = match output {\n             FnRetTy::Ty(ty) => {\n                 // Not `OpaqueTyOrigin::AsyncFn`: that's only used for the\n                 // `impl Future` opaque type that `async fn` implicitly\n                 // generates.\n-                self.lower_ty(ty, &mut nested_impl_trait_context)\n+                self.lower_ty(ty, &nested_impl_trait_context)\n             }\n             FnRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n         };\n@@ -2247,14 +2245,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> (hir::GenericParam<'hir>, Option<hir::WherePredicate<'hir>>, hir::TyKind<'hir>) {\n         // Add a definition for the in-band `Param`.\n         let def_id = self.local_def_id(node_id);\n+        let span = self.lower_span(span);\n \n         // Set the name to `impl Bound1 + Bound2`.\n         let param = hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n             def_id,\n             name: ParamName::Plain(self.lower_ident(ident)),\n             pure_wrt_drop: false,\n-            span: self.lower_span(span),\n+            span,\n             kind: hir::GenericParamKind::Type { default: None, synthetic: true },\n             colon_span: None,\n         };\n@@ -2264,6 +2263,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             node_id,\n             &GenericParamKind::Type { default: None },\n             bounds,\n+            /* colon_span */ None,\n+            span,\n             &ImplTraitContext::Universal,\n             hir::PredicateOrigin::ImplTrait,\n         );\n@@ -2273,7 +2274,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let ty = hir::TyKind::Path(hir::QPath::Resolved(\n             None,\n             self.arena.alloc(hir::Path {\n-                span: self.lower_span(span),\n+                span,\n                 res,\n                 segments:\n                     arena_vec![self; hir::PathSegment::new(self.lower_ident(ident), hir_id, res)],"}, {"sha": "3989fc486193e6d25922c6100b0ba91917f17e6d", "filename": "compiler/rustc_ast_lowering/src/lifetime_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -83,7 +83,7 @@ impl<'ast> Visitor<'ast> for LifetimeCollectVisitor<'ast> {\n                 visit::walk_ty(self, t);\n                 self.current_binders.pop();\n             }\n-            TyKind::Rptr(None, _) => {\n+            TyKind::Ref(None, _) => {\n                 self.record_elided_anchor(t.id, t.span);\n                 visit::walk_ty(self, t);\n             }"}, {"sha": "06d885a45fb7d9c015620804e806972aa8480364", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             qself,\n                             path,\n                             ParamMode::Optional,\n-                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         );\n                         let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n                         break hir::PatKind::TupleStruct(qpath, pats, ddpos);\n@@ -53,7 +53,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             qself,\n                             path,\n                             ParamMode::Optional,\n-                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         );\n                         break hir::PatKind::Path(qpath);\n                     }\n@@ -63,7 +63,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             qself,\n                             path,\n                             ParamMode::Optional,\n-                            &mut ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         );\n \n                         let fs = self.arena.alloc_from_iter(fields.iter().map(|f| {"}, {"sha": "104cdd3a8e119476c4a6f527e9f5dcd21eb9fe20", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1025,7 +1025,7 @@ impl<'a> State<'a> {\n                 self.word(\"*\");\n                 self.print_mt(mt, true);\n             }\n-            ast::TyKind::Rptr(lifetime, mt) => {\n+            ast::TyKind::Ref(lifetime, mt) => {\n                 self.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n                 self.print_mt(mt, false);"}, {"sha": "e4942f9b666e0e837389503cd2d1099895b318da", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -12,7 +12,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         place: &str,\n         borrow_place: &str,\n         value_place: &str,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         self.infcx.tcx.sess.create_err(crate::session_diagnostics::MoveBorrow {\n             place,\n             span,\n@@ -28,7 +28,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         desc: &str,\n         borrow_span: Span,\n         borrow_desc: &str,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n@@ -50,7 +50,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         old_loan_span: Span,\n         old_opt_via: &str,\n         old_load_end_span: Option<Span>,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let via =\n             |msg: &str| if msg.is_empty() { \"\".to_string() } else { format!(\" (via {})\", msg) };\n         let mut err = struct_span_err!(\n@@ -98,7 +98,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         desc: &str,\n         old_loan_span: Span,\n         old_load_end_span: Option<Span>,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n@@ -269,7 +269,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         span: Span,\n         desc: &str,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0594, \"cannot assign to {}\", desc)\n     }\n \n@@ -348,7 +348,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         span: Span,\n         path: &str,\n         reason: &str,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{}\", path, reason,)\n     }\n \n@@ -359,7 +359,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         immutable_place: &str,\n         immutable_section: &str,\n         action: &str,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let mut err = struct_span_err!(\n             self,\n             mutate_span,\n@@ -378,7 +378,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         span: Span,\n         yield_span: Span,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n@@ -392,7 +392,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     pub(crate) fn cannot_borrow_across_destructor(\n         &self,\n         borrow_span: Span,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         struct_span_err!(\n             self,\n             borrow_span,\n@@ -405,7 +405,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         span: Span,\n         path: &str,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0597, \"{} does not live long enough\", path,)\n     }\n \n@@ -415,7 +415,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         return_kind: &str,\n         reference_desc: &str,\n         path_desc: &str,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n@@ -440,7 +440,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         closure_kind: &str,\n         borrowed_path: &str,\n         capture_span: Span,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let mut err = struct_span_err!(\n             self,\n             closure_span,\n@@ -458,14 +458,14 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     pub(crate) fn thread_local_value_does_not_live_long_enough(\n         &self,\n         span: Span,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0712, \"thread-local variable borrowed past end of function\",)\n     }\n \n     pub(crate) fn temporary_value_borrowed_for_too_long(\n         &self,\n         span: Span,\n-    ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0716, \"temporary value dropped while borrowed\",)\n     }\n "}, {"sha": "3c3cb8c6b9c2ac4fa1eaeebdff4fc9f64dce5805", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -194,7 +194,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 if !seen_spans.contains(&move_span) {\n                     if !closure {\n-                        self.suggest_ref_or_clone(mpi, move_span, &mut err, &mut in_pattern);\n+                        self.suggest_ref_or_clone(\n+                            mpi,\n+                            move_span,\n+                            &mut err,\n+                            &mut in_pattern,\n+                            move_spans,\n+                        );\n                     }\n \n                     self.explain_captures(\n@@ -312,6 +318,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         move_span: Span,\n         err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n         in_pattern: &mut bool,\n+        move_spans: UseSpans<'_>,\n     ) {\n         struct ExpressionFinder<'hir> {\n             expr_span: Span,\n@@ -440,6 +447,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ) = call_expr.kind\n                     {\n                         // Do not suggest `.clone()` in a `for` loop, we already suggest borrowing.\n+                    } else if let UseSpans::FnSelfUse {\n+                        kind: CallKind::Normal { .. },\n+                        ..\n+                    } = move_spans {\n+                        // We already suggest cloning for these cases in `explain_captures`.\n                     } else {\n                         self.suggest_cloning(err, ty, move_span);\n                     }\n@@ -2669,7 +2681,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             // Need to use the `rustc_middle::ty` types to compare against the\n                             // `return_region`. Then use the `rustc_hir` type to get only\n                             // the lifetime span.\n-                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].kind {\n+                            if let hir::TyKind::Ref(lifetime, _) = &fn_decl.inputs[index].kind {\n                                 // With access to the lifetime, we can get\n                                 // the span of it.\n                                 arguments.push((*argument, lifetime.ident.span));\n@@ -2690,7 +2702,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let return_ty = sig.output().skip_binder();\n                 let mut return_span = fn_decl.output.span();\n                 if let hir::FnRetTy::Return(ty) = &fn_decl.output {\n-                    if let hir::TyKind::Rptr(lifetime, _) = ty.kind {\n+                    if let hir::TyKind::Ref(lifetime, _) = ty.kind {\n                         return_span = lifetime.ident.span;\n                     }\n                 }"}, {"sha": "63b16aa95a6a5d4b333ba255063685d37104e292", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, Namespace};\n use rustc_hir::GeneratorKind;\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{LateBoundRegionConversionTime, TyCtxtInferExt};\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::{\n     AggregateKind, Constant, FakeReadCause, Field, Local, LocalInfo, LocalKind, Location, Operand,\n@@ -18,7 +18,10 @@ use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n-use rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::{\n+    type_known_to_meet_bound_modulo_regions, Obligation, ObligationCause,\n+};\n \n use super::borrow_set::BorrowData;\n use super::MirBorrowckCtxt;\n@@ -1066,18 +1069,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 CallKind::Normal { self_arg, desugaring, method_did } => {\n                     let self_arg = self_arg.unwrap();\n+                    let tcx = self.infcx.tcx;\n                     if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n-                        let ty = moved_place.ty(self.body, self.infcx.tcx).ty;\n-                        let suggest = match self.infcx.tcx.get_diagnostic_item(sym::IntoIterator) {\n+                        let ty = moved_place.ty(self.body, tcx).ty;\n+                        let suggest = match tcx.get_diagnostic_item(sym::IntoIterator) {\n                             Some(def_id) => {\n                                 let infcx = self.infcx.tcx.infer_ctxt().build();\n                                 type_known_to_meet_bound_modulo_regions(\n                                     &infcx,\n                                     self.param_env,\n-                                    infcx.tcx.mk_imm_ref(\n-                                        infcx.tcx.lifetimes.re_erased,\n-                                        infcx.tcx.erase_regions(ty),\n-                                    ),\n+                                    tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.erase_regions(ty)),\n                                     def_id,\n                                     DUMMY_SP,\n                                 )\n@@ -1133,8 +1134,44 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 place_name, partially_str, loop_message\n                             ),\n                         );\n+                        let infcx = tcx.infer_ctxt().build();\n+                        let ty = tcx.erase_regions(moved_place.ty(self.body, tcx).ty);\n+                        if let ty::Adt(def, substs) = ty.kind()\n+                            && Some(def.did()) == tcx.lang_items().pin_type()\n+                            && let ty::Ref(_, _, hir::Mutability::Mut) = substs.type_at(0).kind()\n+                            && let self_ty = infcx.replace_bound_vars_with_fresh_vars(\n+                                fn_call_span,\n+                                LateBoundRegionConversionTime::FnCall,\n+                                tcx.fn_sig(method_did).input(0),\n+                            )\n+                            && infcx.can_eq(self.param_env, ty, self_ty).is_ok()\n+                        {\n+                            err.span_suggestion_verbose(\n+                                fn_call_span.shrink_to_lo(),\n+                                \"consider reborrowing the `Pin` instead of moving it\",\n+                                \"as_mut().\".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                        if let Some(clone_trait) = tcx.lang_items().clone_trait()\n+                            && let trait_ref = tcx.mk_trait_ref(clone_trait, [ty])\n+                            && let o = Obligation::new(\n+                                tcx,\n+                                ObligationCause::dummy(),\n+                                self.param_env,\n+                                ty::Binder::dummy(trait_ref),\n+                            )\n+                            && infcx.predicate_must_hold_modulo_regions(&o)\n+                        {\n+                            err.span_suggestion_verbose(\n+                                fn_call_span.shrink_to_lo(),\n+                                \"you can `clone` the value and consume it, but this might not be \\\n+                                 your desired behavior\",\n+                                \"clone().\".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n                     }\n-                    let tcx = self.infcx.tcx;\n                     // Avoid pointing to the same function in multiple different\n                     // error messages.\n                     if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span) {"}, {"sha": "6f6d1b01bd4294a7f95195f858e0266a8a6f9c45", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 81, "deletions": 42, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -180,6 +180,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // the verbs used in some diagnostic messages.\n         let act;\n         let acted_on;\n+        let mut suggest = true;\n+        let mut mut_error = None;\n+        let mut count = 1;\n \n         let span = match error_access {\n             AccessKind::Mutate => {\n@@ -194,15 +197,50 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 let borrow_spans = self.borrow_spans(span, location);\n                 let borrow_span = borrow_spans.args_or_use();\n-                err = self.cannot_borrow_path_as_mutable_because(borrow_span, &item_msg, &reason);\n-                borrow_spans.var_span_label(\n-                    &mut err,\n-                    format!(\n-                        \"mutable borrow occurs due to use of {} in closure\",\n-                        self.describe_any_place(access_place.as_ref()),\n-                    ),\n-                    \"mutable\",\n-                );\n+                match the_place_err {\n+                    PlaceRef { local, projection: [] }\n+                        if self.body.local_decls[local].can_be_made_mutable() =>\n+                    {\n+                        let span = self.body.local_decls[local].source_info.span;\n+                        mut_error = Some(span);\n+                        if let Some((buffer, c)) = self.get_buffered_mut_error(span) {\n+                            // We've encountered a second (or more) attempt to mutably borrow an\n+                            // immutable binding, so the likely problem is with the binding\n+                            // declaration, not the use. We collect these in a single diagnostic\n+                            // and make the binding the primary span of the error.\n+                            err = buffer;\n+                            count = c + 1;\n+                            if count == 2 {\n+                                err.replace_span_with(span, false);\n+                                err.span_label(span, \"not mutable\");\n+                            }\n+                            suggest = false;\n+                        } else {\n+                            err = self.cannot_borrow_path_as_mutable_because(\n+                                borrow_span,\n+                                &item_msg,\n+                                &reason,\n+                            );\n+                        }\n+                    }\n+                    _ => {\n+                        err = self.cannot_borrow_path_as_mutable_because(\n+                            borrow_span,\n+                            &item_msg,\n+                            &reason,\n+                        );\n+                    }\n+                }\n+                if suggest {\n+                    borrow_spans.var_span_label(\n+                        &mut err,\n+                        format!(\n+                            \"mutable borrow occurs due to use of {} in closure\",\n+                            self.describe_any_place(access_place.as_ref()),\n+                        ),\n+                        \"mutable\",\n+                    );\n+                }\n                 borrow_span\n             }\n         };\n@@ -276,7 +314,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 pat_span: _,\n                             },\n                         )))) => {\n-                            err.span_note(sp, \"the binding is already a mutable borrow\");\n+                            if suggest {\n+                                err.span_note(sp, \"the binding is already a mutable borrow\");\n+                            }\n                         }\n                         _ => {\n                             err.span_note(\n@@ -333,16 +373,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let local_decl = &self.body.local_decls[local];\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n-                err.span_suggestion(\n-                    local_decl.source_info.span,\n-                    \"consider changing this to be mutable\",\n-                    format!(\"mut {}\", self.local_names[local].unwrap()),\n-                    Applicability::MachineApplicable,\n-                );\n-                let tcx = self.infcx.tcx;\n-                if let ty::Closure(id, _) = *the_place_err.ty(self.body, tcx).ty.kind() {\n-                    self.show_mutating_upvar(tcx, id.expect_local(), the_place_err, &mut err);\n+                if count < 10 {\n+                    err.span_label(span, format!(\"cannot {act}\"));\n+                }\n+                if suggest {\n+                    err.span_suggestion_verbose(\n+                        local_decl.source_info.span.shrink_to_lo(),\n+                        \"consider changing this to be mutable\",\n+                        \"mut \".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    let tcx = self.infcx.tcx;\n+                    if let ty::Closure(id, _) = *the_place_err.ty(self.body, tcx).ty.kind() {\n+                        self.show_mutating_upvar(tcx, id.expect_local(), the_place_err, &mut err);\n+                    }\n                 }\n             }\n \n@@ -357,7 +401,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 let captured_place = &self.upvars[upvar_index.index()].place;\n \n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n \n                 let upvar_hir_id = captured_place.get_root_variable();\n \n@@ -397,7 +441,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .span_to_snippet(span)\n                     .map_or(false, |snippet| snippet.starts_with(\"&mut \")) =>\n             {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n                 err.span_suggestion(\n                     span,\n                     \"try removing `&mut` here\",\n@@ -409,7 +453,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n                 if self.body.local_decls[local].is_ref_for_guard() =>\n             {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n                 err.note(\n                     \"variables bound in patterns are immutable until the end of the pattern guard\",\n                 );\n@@ -537,7 +581,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             Some((true, err_help_span, suggested_code)) => {\n                                 let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n                                 if !is_trait_sig {\n-                                    err.span_suggestion(\n+                                    err.span_suggestion_verbose(\n                                         err_help_span,\n                                         &format!(\n                                             \"consider changing this to be a mutable {pointer_desc}\"\n@@ -546,7 +590,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                         Applicability::MachineApplicable,\n                                     );\n                                 } else if let Some(x) = local_trait {\n-                                    err.span_suggestion(\n+                                    err.span_suggestion_verbose(\n                                         x,\n                                         &format!(\n                                             \"consider changing that to be a mutable {pointer_desc}\"\n@@ -569,24 +613,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         err.span_label(\n                             span,\n                             format!(\n-                                \"`{NAME}` is a `{SIGIL}` {DESC}, \\\n-                                so the data it refers to cannot be {ACTED_ON}\",\n-                                NAME = name,\n-                                SIGIL = pointer_sigil,\n-                                DESC = pointer_desc,\n-                                ACTED_ON = acted_on\n+                                \"`{name}` is a `{pointer_sigil}` {pointer_desc}, \\\n+                                 so the data it refers to cannot be {acted_on}\",\n                             ),\n                         );\n                     }\n                     _ => {\n                         err.span_label(\n                             span,\n-                            format!(\n-                                \"cannot {ACT} through `{SIGIL}` {DESC}\",\n-                                ACT = act,\n-                                SIGIL = pointer_sigil,\n-                                DESC = pointer_desc\n-                            ),\n+                            format!(\"cannot {act} through `{pointer_sigil}` {pointer_desc}\"),\n                         );\n                     }\n                 }\n@@ -605,13 +640,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Some(BorrowedContentSource::OverloadedDeref(ty)) => {\n                         err.help(&format!(\n                             \"trait `DerefMut` is required to modify through a dereference, \\\n-                                but it is not implemented for `{ty}`\",\n+                             but it is not implemented for `{ty}`\",\n                         ));\n                     }\n                     Some(BorrowedContentSource::OverloadedIndex(ty)) => {\n                         err.help(&format!(\n                             \"trait `IndexMut` is required to modify indexed content, \\\n-                                but it is not implemented for `{ty}`\",\n+                             but it is not implemented for `{ty}`\",\n                         ));\n                         self.suggest_map_index_mut_alternatives(ty, &mut err, span);\n                     }\n@@ -620,11 +655,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             _ => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n             }\n         }\n \n-        self.buffer_error(err);\n+        if let Some(span) = mut_error {\n+            self.buffer_mut_error(span, err, count);\n+        } else {\n+            self.buffer_error(err);\n+        }\n     }\n \n     fn suggest_map_index_mut_alternatives(&self, ty: Ty<'tcx>, err: &mut Diagnostic, span: Span) {\n@@ -1209,7 +1248,7 @@ fn get_mut_span_in_struct_field<'tcx>(\n         // Now we're dealing with the actual struct that we're going to suggest a change to,\n         // we can expect a field that is an immutable reference to a type.\n         && let hir::Node::Field(field) = node\n-        && let hir::TyKind::Rptr(lt, hir::MutTy { mutbl: hir::Mutability::Not, ty }) = field.ty.kind\n+        && let hir::TyKind::Ref(lt, hir::MutTy { mutbl: hir::Mutability::Not, ty }) = field.ty.kind\n     {\n         return Some(lt.ident.span.between(ty.span));\n     }"}, {"sha": "dbd4cac7b1432f2e3785838144f09e49a41a4c2b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -493,10 +493,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 //\n                 //     &\n                 //     - let's call the lifetime of this reference `'1`\n-                (\n-                    ty::Ref(region, referent_ty, _),\n-                    hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n-                ) => {\n+                (ty::Ref(region, referent_ty, _), hir::TyKind::Ref(_lifetime, referent_hir_ty)) => {\n                     if region.to_region_vid() == needle_fr {\n                         // Just grab the first character, the `&`.\n                         let source_map = self.infcx.tcx.sess.source_map();"}, {"sha": "ae1bea008b6cede53a067e4a3dddf619752478ce", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2270,6 +2270,7 @@ mod error {\n         /// same primary span come out in a consistent order.\n         buffered_move_errors:\n             BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'tcx>, DiagnosticBuilder<'tcx, ErrorGuaranteed>)>,\n+        buffered_mut_errors: FxHashMap<Span, (DiagnosticBuilder<'tcx, ErrorGuaranteed>, usize)>,\n         /// Diagnostics to be reported buffer.\n         buffered: Vec<Diagnostic>,\n         /// Set to Some if we emit an error during borrowck\n@@ -2281,6 +2282,7 @@ mod error {\n             BorrowckErrors {\n                 tcx,\n                 buffered_move_errors: BTreeMap::new(),\n+                buffered_mut_errors: Default::default(),\n                 buffered: Default::default(),\n                 tainted_by_errors: None,\n             }\n@@ -2331,12 +2333,34 @@ mod error {\n             }\n         }\n \n+        pub fn get_buffered_mut_error(\n+            &mut self,\n+            span: Span,\n+        ) -> Option<(DiagnosticBuilder<'tcx, ErrorGuaranteed>, usize)> {\n+            self.errors.buffered_mut_errors.remove(&span)\n+        }\n+\n+        pub fn buffer_mut_error(\n+            &mut self,\n+            span: Span,\n+            t: DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+            count: usize,\n+        ) {\n+            self.errors.buffered_mut_errors.insert(span, (t, count));\n+        }\n+\n         pub fn emit_errors(&mut self) -> Option<ErrorGuaranteed> {\n             // Buffer any move errors that we collected and de-duplicated.\n             for (_, (_, diag)) in std::mem::take(&mut self.errors.buffered_move_errors) {\n                 // We have already set tainted for this error, so just buffer it.\n                 diag.buffer(&mut self.errors.buffered);\n             }\n+            for (_, (mut diag, count)) in std::mem::take(&mut self.errors.buffered_mut_errors) {\n+                if count > 10 {\n+                    diag.note(&format!(\"...and {} other attempted mutable borrows\", count - 10));\n+                }\n+                diag.buffer(&mut self.errors.buffered);\n+            }\n \n             if !self.errors.buffered.is_empty() {\n                 self.errors.buffered.sort_by_key(|diag| diag.sort_span);"}, {"sha": "8fa43f8528cca2a6b0f7b1b1e96c633ae7761adc", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -37,31 +37,30 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // those.\n         //\n         // e.g., `|x: FxHashMap<_, &'static u32>| ...`\n-        let user_provided_sig;\n-        if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n-            user_provided_sig = None;\n+        let user_provided_sig = if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n+            None\n         } else {\n             let typeck_results = self.tcx().typeck(mir_def_id);\n-            user_provided_sig =\n-                typeck_results.user_provided_sigs.get(&mir_def_id).map(|user_provided_poly_sig| {\n-                    // Instantiate the canonicalized variables from\n-                    // user-provided signature (e.g., the `_` in the code\n-                    // above) with fresh variables.\n-                    let poly_sig = self.instantiate_canonical_with_fresh_inference_vars(\n-                        body.span,\n-                        &user_provided_poly_sig,\n-                    );\n-\n-                    // Replace the bound items in the fn sig with fresh\n-                    // variables, so that they represent the view from\n-                    // \"inside\" the closure.\n-                    self.infcx.replace_bound_vars_with_fresh_vars(\n-                        body.span,\n-                        LateBoundRegionConversionTime::FnCall,\n-                        poly_sig,\n-                    )\n-                });\n-        }\n+\n+            typeck_results.user_provided_sigs.get(&mir_def_id).map(|user_provided_poly_sig| {\n+                // Instantiate the canonicalized variables from\n+                // user-provided signature (e.g., the `_` in the code\n+                // above) with fresh variables.\n+                let poly_sig = self.instantiate_canonical_with_fresh_inference_vars(\n+                    body.span,\n+                    &user_provided_poly_sig,\n+                );\n+\n+                // Replace the bound items in the fn sig with fresh\n+                // variables, so that they represent the view from\n+                // \"inside\" the closure.\n+                self.infcx.replace_bound_vars_with_fresh_vars(\n+                    body.span,\n+                    LateBoundRegionConversionTime::FnCall,\n+                    poly_sig,\n+                )\n+            })\n+        };\n \n         debug!(?normalized_input_tys, ?body.local_decls);\n "}, {"sha": "5b1b7e6804c86d7235d0597e074901dba8fa0b37", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -117,8 +117,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         // `let names: &'static _ = &[\"field1\", \"field2\"];`\n         let names_let = if is_struct {\n             let lt_static = Some(cx.lifetime_static(span));\n-            let ty_static_ref =\n-                cx.ty_rptr(span, cx.ty_infer(span), lt_static, ast::Mutability::Not);\n+            let ty_static_ref = cx.ty_ref(span, cx.ty_infer(span), lt_static, ast::Mutability::Not);\n             Some(cx.stmt_let_ty(\n                 span,\n                 false,\n@@ -138,13 +137,13 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         );\n         let ty_slice = cx.ty(\n             span,\n-            ast::TyKind::Slice(cx.ty_rptr(span, ty_dyn_debug, None, ast::Mutability::Not)),\n+            ast::TyKind::Slice(cx.ty_ref(span, ty_dyn_debug, None, ast::Mutability::Not)),\n         );\n         let values_let = cx.stmt_let_ty(\n             span,\n             false,\n             Ident::new(sym::values, span),\n-            Some(cx.ty_rptr(span, ty_slice, None, ast::Mutability::Not)),\n+            Some(cx.ty_ref(span, ty_slice, None, ast::Mutability::Not)),\n             cx.expr_array_ref(span, value_exprs),\n         );\n "}, {"sha": "c6f5f5d080706be7d41c7c52d8840edf6b545b42", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -97,7 +97,7 @@ impl Ty {\n         match self {\n             Ref(ty, mutbl) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n-                cx.ty_rptr(span, raw_ty, None, *mutbl)\n+                cx.ty_ref(span, raw_ty, None, *mutbl)\n             }\n             Path(p) => p.to_ty(cx, span, self_ty, self_generics),\n             Self_ => cx.ty_path(self.to_path(cx, span, self_ty, self_generics)),"}, {"sha": "84d06b69a9d976c3d7c260dfe723693139dfe80b", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -30,7 +30,7 @@ pub fn expand_option_env<'cx>(\n                 sp,\n                 true,\n                 cx.std_path(&[sym::option, sym::Option, sym::None]),\n-                vec![GenericArg::Type(cx.ty_rptr(\n+                vec![GenericArg::Type(cx.ty_ref(\n                     sp,\n                     cx.ty_ident(sp, Ident::new(sym::str, sp)),\n                     Some(lt),"}, {"sha": "21c8caa658f24422567d56bf8474f5b9c6104d22", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -349,7 +349,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n         .item_static(\n             span,\n             Ident::new(sym::_DECLS, span),\n-            cx.ty_rptr(\n+            cx.ty_ref(\n                 span,\n                 cx.ty(\n                     span,"}, {"sha": "95baa95b02183601ff022eaac84e1f3b9622ae07", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -102,10 +102,10 @@ pub fn uwtable_attr(llcx: &llvm::Context) -> &Attribute {\n \n pub fn frame_pointer_type_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n     let mut fp = cx.sess().target.frame_pointer;\n+    let opts = &cx.sess().opts;\n     // \"mcount\" function relies on stack pointer.\n     // See <https://sourceware.org/binutils/docs/gprof/Implementation.html>.\n-    if cx.sess().instrument_mcount() || matches!(cx.sess().opts.cg.force_frame_pointers, Some(true))\n-    {\n+    if opts.unstable_opts.instrument_mcount || matches!(opts.cg.force_frame_pointers, Some(true)) {\n         fp = FramePointer::Always;\n     }\n     let attr_value = match fp {\n@@ -119,7 +119,7 @@ pub fn frame_pointer_type_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attr\n /// Tell LLVM what instrument function to insert.\n #[inline]\n fn instrument_function_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n-    if cx.sess().instrument_mcount() {\n+    if cx.sess().opts.unstable_opts.instrument_mcount {\n         // Similar to `clang -pg` behavior. Handled by the\n         // `post-inline-ee-instrument` LLVM pass.\n "}, {"sha": "e23c88b62c14b4bb92ff0be5078120a0e16ecc79", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -203,7 +203,7 @@ pub fn target_machine_factory(\n         sess.opts.unstable_opts.trap_unreachable.unwrap_or(sess.target.trap_unreachable);\n     let emit_stack_size_section = sess.opts.unstable_opts.emit_stack_sizes;\n \n-    let asm_comments = sess.asm_comments();\n+    let asm_comments = sess.opts.unstable_opts.asm_comments;\n     let relax_elf_relocations =\n         sess.opts.unstable_opts.relax_elf_relocations.unwrap_or(sess.target.relax_elf_relocations);\n "}, {"sha": "79b243f73d1a0598925e0ee69c1657c40c89e968", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -81,10 +81,10 @@ unsafe fn configure_llvm(sess: &Session) {\n         };\n         // Set the llvm \"program name\" to make usage and invalid argument messages more clear.\n         add(\"rustc -Cllvm-args=\\\"...\\\" with\", true);\n-        if sess.time_llvm_passes() {\n+        if sess.opts.unstable_opts.time_llvm_passes {\n             add(\"-time-passes\", false);\n         }\n-        if sess.print_llvm_passes() {\n+        if sess.opts.unstable_opts.print_llvm_passes {\n             add(\"-debug-pass=Structure\", false);\n         }\n         if sess.target.generate_arange_section"}, {"sha": "1a7de1a184a9c1b642c3d8bdbbe67f964323753c", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1899,7 +1899,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n         // FIXME: time_llvm_passes support - does this use a global context or\n         // something?\n-        if sess.codegen_units() == 1 && sess.time_llvm_passes() {\n+        if sess.codegen_units() == 1 && sess.opts.unstable_opts.time_llvm_passes {\n             self.backend.print_pass_timings()\n         }\n "}, {"sha": "8b34be3858006f763849e55cb4954dd5c764464a", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -681,7 +681,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     });\n \n     let mut total_codegen_time = Duration::new(0, 0);\n-    let start_rss = tcx.sess.time_passes().then(|| get_resident_set_size());\n+    let start_rss = tcx.sess.opts.unstable_opts.time_passes.then(|| get_resident_set_size());\n \n     // The non-parallel compiler can only translate codegen units to LLVM IR\n     // on a single thread, leading to a staircase effect where the N LLVM\n@@ -781,7 +781,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n-    if tcx.sess.time_passes() {\n+    if tcx.sess.opts.unstable_opts.time_passes {\n         let end_rss = get_resident_set_size();\n \n         print_time_passes_entry("}, {"sha": "b0fa7745667360d642a4fbd8c89ea0a71c6ef8d5", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2,6 +2,7 @@ use rustc_ast::{ast, MetaItemKind, NestedMetaItem};\n use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::{lang_items, weak_lang_items::WEAK_LANG_ITEMS, LangItem};\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -60,6 +61,21 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n \n     let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n \n+    // In some cases, attribute are only valid on functions, but it's the `check_attr`\n+    // pass that check that they aren't used anywhere else, rather this module.\n+    // In these cases, we bail from performing further checks that are only meaningful for\n+    // functions (such as calling `fn_sig`, which ICEs if given a non-function). We also\n+    // report a delayed bug, just in case `check_attr` isn't doing its job.\n+    let validate_fn_only_attr = |attr_sp| -> bool {\n+        let def_kind = tcx.def_kind(did);\n+        if let DefKind::Fn | DefKind::AssocFn | DefKind::Variant | DefKind::Ctor(..) = def_kind {\n+            true\n+        } else {\n+            tcx.sess.delay_span_bug(attr_sp, \"this attribute can only be applied to functions\");\n+            false\n+        }\n+    };\n+\n     let mut inline_span = None;\n     let mut link_ordinal_span = None;\n     let mut no_sanitize_span = None;\n@@ -197,7 +213,9 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                 }\n             }\n         } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. }) {\n+            if validate_fn_only_attr(attr.span)\n+                && !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. })\n+            {\n                 struct_span_err!(\n                     tcx.sess,\n                     attr.span,\n@@ -214,7 +232,10 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n         } else if attr.has_name(sym::thread_local) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n         } else if attr.has_name(sym::track_caller) {\n-            if !tcx.is_closure(did.to_def_id()) && tcx.fn_sig(did).abi() != abi::Abi::Rust {\n+            if !tcx.is_closure(did.to_def_id())\n+                && validate_fn_only_attr(attr.span)\n+                && tcx.fn_sig(did).abi() != abi::Abi::Rust\n+            {\n                 struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n                     .emit();\n             }"}, {"sha": "3ae6c531b4453bedb7b466291d3ef6bd6726ea07", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -509,7 +509,7 @@ pub fn compute_debuginfo_vtable_name<'tcx>(\n         visited.clear();\n         push_generic_params_internal(tcx, trait_ref.substs, &mut vtable_name, &mut visited);\n     } else {\n-        vtable_name.push_str(\"_\");\n+        vtable_name.push('_');\n     }\n \n     push_close_angle_bracket(cpp_like_debuginfo, &mut vtable_name);"}, {"sha": "978aff511bfa74d07f2ecbcc4a20aa3155d2e62d", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -637,7 +637,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.set_debug_loc(bx, terminator.source_info);\n \n         // Obtain the panic entry point.\n-        let (fn_abi, llfn) = common::build_langcall(bx, Some(span), LangItem::PanicNoUnwind);\n+        let (fn_abi, llfn) = common::build_langcall(bx, Some(span), LangItem::PanicCannotUnwind);\n \n         // Codegen the actual panic invoke/call.\n         let merging_succ = helper.do_call(self, bx, fn_abi, llfn, &[], None, None, &[], false);\n@@ -698,19 +698,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     })\n                 });\n                 let msg = bx.const_str(&msg_str);\n-                let location = self.get_caller_location(bx, source_info).immediate();\n \n                 // Obtain the panic entry point.\n                 let (fn_abi, llfn) =\n-                    common::build_langcall(bx, Some(source_info.span), LangItem::Panic);\n+                    common::build_langcall(bx, Some(source_info.span), LangItem::PanicNounwind);\n \n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n                     self,\n                     bx,\n                     fn_abi,\n                     llfn,\n-                    &[msg.0, msg.1, location],\n+                    &[msg.0, msg.1],\n                     target.as_ref().map(|bb| (ReturnDest::Nothing, *bb)),\n                     cleanup,\n                     &[],\n@@ -1665,7 +1664,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let llpersonality = self.cx.eh_personality();\n             bx.cleanup_landing_pad(llpersonality);\n \n-            let (fn_abi, fn_ptr) = common::build_langcall(&bx, None, LangItem::PanicNoUnwind);\n+            let (fn_abi, fn_ptr) = common::build_langcall(&bx, None, LangItem::PanicCannotUnwind);\n             let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n             let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &[], None);"}, {"sha": "04ce701452b90de0c346efd4b8c8250f0e6d76f9", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -216,12 +216,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     return Err(Unpromotable);\n                 }\n \n-                // We cannot promote things that need dropping, since the promoted value\n-                // would not get dropped.\n-                if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n-                    return Err(Unpromotable);\n-                }\n-\n                 Ok(())\n             }\n             _ => bug!(),\n@@ -262,13 +256,17 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 }\n             }\n         } else {\n-            let span = self.body.local_decls[local].source_info.span;\n-            span_bug!(span, \"{:?} not promotable, qualif_local shouldn't have been called\", local);\n+            false\n         }\n     }\n \n     fn validate_local(&mut self, local: Local) -> Result<(), Unpromotable> {\n         if let TempState::Defined { location: loc, uses, valid } = self.temps[local] {\n+            // We cannot promote things that need dropping, since the promoted value\n+            // would not get dropped.\n+            if self.qualif_local::<qualifs::NeedsDrop>(local) {\n+                return Err(Unpromotable);\n+            }\n             valid.or_else(|_| {\n                 let ok = {\n                     let block = &self.body[loc.block];"}, {"sha": "c63caa06818f26e2f3f263d778c140ae5fc588aa", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,6 +1,7 @@\n use crate::stable_hasher::{HashStable, StableHasher, StableOrd};\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n+use std::fmt::Debug;\n use std::mem;\n use std::ops::{Bound, Index, IndexMut, RangeBounds};\n \n@@ -16,7 +17,7 @@ pub use index_map::SortedIndexMultiMap;\n /// stores data in a more compact way. It also supports accessing contiguous\n /// ranges of elements as a slice, and slices of already sorted elements can be\n /// inserted efficiently.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Encodable, Decodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n pub struct SortedMap<K, V> {\n     data: Vec<(K, V)>,\n }\n@@ -314,5 +315,11 @@ impl<K: HashStable<CTX> + StableOrd, V: HashStable<CTX>, CTX> HashStable<CTX> fo\n     }\n }\n \n+impl<K: Debug, V: Debug> Debug for SortedMap<K, V> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_map().entries(self.data.iter().map(|(a, b)| (a, b))).finish()\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "ae4836645fa41311215aaa39166c4c439766709e", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -223,7 +223,7 @@ pub trait ToStableHashKey<HCX> {\n /// stable across compilation session boundaries. More formally:\n ///\n /// ```txt\n-/// Ord::cmp(a1, b1) == Ord:cmp(a2, b2)\n+/// Ord::cmp(a1, b1) == Ord::cmp(a2, b2)\n ///    where a2 = decode(encode(a1, context1), context2)\n ///          b2 = decode(encode(b1, context1), context2)\n /// ```"}, {"sha": "30179e978725c2ba38f9157f8744accad2194882", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -653,7 +653,7 @@ fn print_crate_info(\n     for req in &sess.opts.prints {\n         match *req {\n             TargetList => {\n-                let mut targets = rustc_target::spec::TARGETS.iter().copied().collect::<Vec<_>>();\n+                let mut targets = rustc_target::spec::TARGETS.to_vec();\n                 targets.sort_unstable();\n                 println!(\"{}\", targets.join(\"\\n\"));\n             }\n@@ -1199,8 +1199,8 @@ static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send +\n             };\n \n             // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n-            // Don't do this for `ExplicitBug`, which has an unhelpful message and backtrace.\n-            if !info.payload().is::<rustc_errors::ExplicitBug>() {\n+            // Don't do this for `GoodPathBug`, which already emits its own more useful backtrace.\n+            if !info.payload().is::<rustc_errors::GoodPathBug>() {\n                 (*DEFAULT_HOOK)(info);\n \n                 // Separate the output with an empty line\n@@ -1237,7 +1237,9 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n \n     // a .span_bug or .bug call has already printed what\n     // it wants to print.\n-    if !info.payload().is::<rustc_errors::ExplicitBug>() {\n+    if !info.payload().is::<rustc_errors::ExplicitBug>()\n+        && !info.payload().is::<rustc_errors::GoodPathBug>()\n+    {\n         let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n         handler.emit_diagnostic(&mut d);\n     }"}, {"sha": "3fba2cf57494deb0dd74572e90d59578424b5305", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -244,6 +244,7 @@ E0457: include_str!(\"./error_codes/E0457.md\"),\n E0458: include_str!(\"./error_codes/E0458.md\"),\n E0459: include_str!(\"./error_codes/E0459.md\"),\n E0460: include_str!(\"./error_codes/E0460.md\"),\n+E0461: include_str!(\"./error_codes/E0461.md\"),\n E0462: include_str!(\"./error_codes/E0462.md\"),\n E0463: include_str!(\"./error_codes/E0463.md\"),\n E0464: include_str!(\"./error_codes/E0464.md\"),\n@@ -275,10 +276,12 @@ E0509: include_str!(\"./error_codes/E0509.md\"),\n E0510: include_str!(\"./error_codes/E0510.md\"),\n E0511: include_str!(\"./error_codes/E0511.md\"),\n E0512: include_str!(\"./error_codes/E0512.md\"),\n+E0514: include_str!(\"./error_codes/E0514.md\"),\n E0515: include_str!(\"./error_codes/E0515.md\"),\n E0516: include_str!(\"./error_codes/E0516.md\"),\n E0517: include_str!(\"./error_codes/E0517.md\"),\n E0518: include_str!(\"./error_codes/E0518.md\"),\n+E0519: include_str!(\"./error_codes/E0519.md\"),\n E0520: include_str!(\"./error_codes/E0520.md\"),\n E0521: include_str!(\"./error_codes/E0521.md\"),\n E0522: include_str!(\"./error_codes/E0522.md\"),\n@@ -595,8 +598,7 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0421, // merged into 531\n //  E0427, // merged into 530\n //  E0456, // plugin `..` is not available for triple `..`\n-    E0461, // couldn't find crate `..` with expected target triple ..\n-    E0465, // multiple .. candidates for `..` found\n+//  E0465, // removed: merged with E0464\n //  E0467, // removed\n //  E0470, // removed\n //  E0471, // constant evaluation error (in pattern)\n@@ -615,8 +617,6 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0488, // lifetime of variable does not enclose its declaration\n //  E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n-    E0514, // metadata version mismatch\n-    E0519, // local crate and dependency have same (crate-name, disambiguator)\n     E0523, // two dependencies have same (crate-name, disambiguator) but different SVH\n //  E0526, // shuffle indices are not constant\n //  E0540, // multiple rustc_deprecated attributes"}, {"sha": "33105c43ccfe7391c48424c4ed6b387370141c7e", "filename": "compiler/rustc_error_codes/src/error_codes/E0461.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0461.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0461.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0461.md?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -0,0 +1,30 @@\n+Couldn't find crate `..` with expected target triple `..`.\n+\n+Example of erroneous code:\n+\n+`a.rs`\n+```ignore (cannot-link-with-other-tests)\n+#![crate_type = \"lib\"]\n+\n+fn foo() {}\n+```\n+\n+`main.rs`\n+```ignore (cannot-link-with-other-tests)\n+extern crate a;\n+\n+fn main() {\n+    a::foo();\n+}\n+```\n+\n+`a.rs` is then compiled with `--target powerpc-unknown-linux-gnu` and `b.rs`\n+with `--target x86_64-unknown-linux-gnu`. `a.rs` is compiled into a binary\n+format incompatible with `b.rs`; PowerPC and x86 are totally different\n+architectures. This issue also extends to any difference in target triples, as\n+`std` is operating-system specific.\n+\n+This error can be fixed by:\n+ * Using [Cargo](../cargo/index.html), the Rust package manager, automatically\n+   fixing this issue.\n+ * Recompiling either crate so that they target a consistent target triple."}, {"sha": "ce2bbc5c5056c4a3d5748b495b4890c1536c322c", "filename": "compiler/rustc_error_codes/src/error_codes/E0514.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0514.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0514.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0514.md?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -0,0 +1,33 @@\n+Dependency compiled with different version of `rustc`.\n+\n+Example of erroneous code:\n+\n+`a.rs`\n+```ignore (cannot-link-with-other-tests)\n+// compiled with stable `rustc`\n+\n+#[crate_type = \"lib\"]\n+```\n+\n+`b.rs`\n+```ignore (cannot-link-with-other-tests)\n+// compiled with nightly `rustc`\n+\n+#[crate_type = \"lib\"]\n+\n+extern crate a; // error: found crate `a` compiled by an incompatible version\n+                //        of rustc\n+```\n+\n+This error is caused when the version of `rustc` used to compile a crate, as\n+stored in the binary's metadata, differs from the version of one of its\n+dependencies. Many parts of Rust binaries are considered unstable. For\n+instance, the Rust ABI is not stable between compiler versions. This means that\n+the compiler cannot be sure about *how* to call a function between compiler\n+versions, and therefore this error occurs.\n+\n+This error can be fixed by:\n+ * Using [Cargo](../cargo/index.html), the Rust package manager and\n+   [Rustup](https://rust-lang.github.io/rustup/), the Rust toolchain installer,\n+   automatically fixing this issue.\n+ * Recompiling the crates with a uniform `rustc` version."}, {"sha": "12876e2ad75fcc92c34885a567292945b7335e78", "filename": "compiler/rustc_error_codes/src/error_codes/E0519.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0519.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0519.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0519.md?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -0,0 +1,40 @@\n+The current crate is indistinguishable from one of its dependencies, in terms\n+of metadata.\n+\n+Example of erroneous code:\n+\n+`a.rs`\n+```ignore (cannot-link-with-other-tests)\n+#![crate_name = \"a\"]\n+#![crate_type = \"lib\"]\n+\n+pub fn foo() {}\n+```\n+\n+`b.rs`\n+```ignore (cannot-link-with-other-tests)\n+#![crate_name = \"a\"]\n+#![crate_type = \"lib\"]\n+\n+// error: the current crate is indistinguishable from one of its dependencies:\n+//        it has the same crate-name `a` and was compiled with the same\n+//        `-C metadata` arguments. This will result in symbol conflicts between\n+//        the two.\n+extern crate a;\n+\n+pub fn foo() {}\n+\n+fn bar() {\n+    a::foo(); // is this calling the local crate or the dependency?\n+}\n+```\n+\n+The above example compiles two crates with exactly the same name and\n+`crate_type` (plus any other metadata). This causes an error because it becomes\n+impossible for the compiler to distinguish between symbols (`pub` item names).\n+\n+This error can be fixed by:\n+ * Using [Cargo](../cargo/index.html), the Rust package manager, automatically\n+   fixing this issue.\n+ * Recompiling the crate with different metadata (different name/\n+   `crate_type`)."}, {"sha": "79b8b417257045a6b60f244acf4f4a0f7acc35d5", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -4,6 +4,11 @@ metadata_rlib_required =\n metadata_lib_required =\n     crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n \n+metadata_rustc_lib_required =\n+    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n+    .note = only .rmeta files are distributed for `rustc_private` crates other than `rustc_driver`\n+    .help = try adding `extern crate rustc_driver;` at the top level of this crate\n+\n metadata_crate_dep_multiple =\n     cannot satisfy dependencies so `{$crate_name}` only shows up once\n     .help = having upstream crates all available in one format will likely make this go away\n@@ -196,11 +201,7 @@ metadata_extern_location_not_file =\n     extern location for {$crate_name} is not a file: {$location}\n \n metadata_multiple_candidates =\n-    multiple {$flavor} candidates for `{$crate_name}` found\n-\n-metadata_multiple_matching_crates =\n-    multiple matching crates for `{$crate_name}`\n-    .note = candidates:{$candidates}\n+    multiple candidates for `{$flavor}` dependency `{$crate_name}` found\n \n metadata_symbol_conflicts_current =\n     the current crate is indistinguishable from one of its dependencies: it has the same crate-name `{$crate_name}` and was compiled with the same `-C metadata` arguments. This will result in symbol conflicts between the two."}, {"sha": "3401978caf5f0f305b0f6128baf0ac79c6f73784", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -365,3 +365,6 @@ parse_invalid_identifier_with_leading_number = expected identifier, found number\n \n parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of `fn`\n     .suggestion = replace `fn` with `impl` here\n+\n+parse_expected_fn_path_found_fn_keyword = expected identifier, found keyword `fn`\n+    .suggestion = use `Fn` to refer to the trait"}, {"sha": "e19a6fe0ee9bff2d5a0a5c28a7ace6c976c2fa9a", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -365,12 +365,12 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn replace_span_with(&mut self, after: Span) -> &mut Self {\n+    pub fn replace_span_with(&mut self, after: Span, keep_label: bool) -> &mut Self {\n         let before = self.span.clone();\n         self.set_span(after);\n         for span_label in before.span_labels() {\n             if let Some(label) = span_label.label {\n-                if span_label.is_primary {\n+                if span_label.is_primary && keep_label {\n                     self.span.push_span_label(after, label);\n                 } else {\n                     self.span.push_span_label(span_label.span, label);"}, {"sha": "0ca200abe19fb381097e2386bcf408c0863135ef", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -845,18 +845,34 @@ impl EmitterWriter {\n         // 3 | |\n         // 4 | | }\n         //   | |_^ test\n-        if let [ann] = &line.annotations[..] {\n+        let mut buffer_ops = vec![];\n+        let mut annotations = vec![];\n+        let mut short_start = true;\n+        for ann in &line.annotations {\n             if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n                 if source_string.chars().take(ann.start_col).all(|c| c.is_whitespace()) {\n                     let style = if ann.is_primary {\n                         Style::UnderlinePrimary\n                     } else {\n                         Style::UnderlineSecondary\n                     };\n-                    buffer.putc(line_offset, width_offset + depth - 1, '/', style);\n-                    return vec![(depth, style)];\n+                    annotations.push((depth, style));\n+                    buffer_ops.push((line_offset, width_offset + depth - 1, '/', style));\n+                } else {\n+                    short_start = false;\n+                    break;\n                 }\n+            } else if let AnnotationType::MultilineLine(_) = ann.annotation_type {\n+            } else {\n+                short_start = false;\n+                break;\n+            }\n+        }\n+        if short_start {\n+            for (y, x, c, s) in buffer_ops {\n+                buffer.putc(y, x, c, s);\n             }\n+            return annotations;\n         }\n \n         // We want to display like this:"}, {"sha": "136c360201e61a925049b941997d039544c34e9f", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 76, "deletions": 64, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -40,12 +40,13 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::HashStableContext;\n use rustc_span::{Loc, Span};\n \n+use std::any::Any;\n use std::borrow::Cow;\n+use std::fmt;\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n use std::panic;\n use std::path::Path;\n-use std::{error, fmt};\n \n use termcolor::{Color, ColorSpec};\n \n@@ -361,16 +362,11 @@ pub use rustc_span::fatal_error::{FatalError, FatalErrorMarker};\n \n /// Signifies that the compiler died with an explicit call to `.bug`\n /// or `.span_bug` rather than a failed assertion, etc.\n-#[derive(Copy, Clone, Debug)]\n pub struct ExplicitBug;\n \n-impl fmt::Display for ExplicitBug {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"parser internal bug\")\n-    }\n-}\n-\n-impl error::Error for ExplicitBug {}\n+/// Signifies that the compiler died with an explicit call to `.delay_good_path_bug`\n+/// rather than a failed assertion, etc.\n+pub struct GoodPathBug;\n \n pub use diagnostic::{\n     AddToDiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId,\n@@ -473,10 +469,12 @@ pub enum StashKey {\n     CallAssocMethod,\n }\n \n-fn default_track_diagnostic(_: &Diagnostic) {}\n+fn default_track_diagnostic(d: &mut Diagnostic, f: &mut dyn FnMut(&mut Diagnostic)) {\n+    (*f)(d)\n+}\n \n-pub static TRACK_DIAGNOSTICS: AtomicRef<fn(&Diagnostic)> =\n-    AtomicRef::new(&(default_track_diagnostic as fn(&_)));\n+pub static TRACK_DIAGNOSTICS: AtomicRef<fn(&mut Diagnostic, &mut dyn FnMut(&mut Diagnostic))> =\n+    AtomicRef::new(&(default_track_diagnostic as _));\n \n #[derive(Copy, Clone, Default)]\n pub struct HandlerFlags {\n@@ -507,7 +505,11 @@ impl Drop for HandlerInner {\n \n         if !self.has_errors() {\n             let bugs = std::mem::replace(&mut self.delayed_span_bugs, Vec::new());\n-            self.flush_delayed(bugs, \"no errors encountered even though `delay_span_bug` issued\");\n+            self.flush_delayed(\n+                bugs,\n+                \"no errors encountered even though `delay_span_bug` issued\",\n+                ExplicitBug,\n+            );\n         }\n \n         // FIXME(eddyb) this explains what `delayed_good_path_bugs` are!\n@@ -520,6 +522,7 @@ impl Drop for HandlerInner {\n             self.flush_delayed(\n                 bugs.into_iter().map(DelayedDiagnostic::decorate),\n                 \"no warnings or errors encountered even though `delayed_good_path_bugs` issued\",\n+                GoodPathBug,\n             );\n         }\n \n@@ -653,17 +656,19 @@ impl Handler {\n     /// Retrieve a stashed diagnostic with `steal_diagnostic`.\n     pub fn stash_diagnostic(&self, span: Span, key: StashKey, diag: Diagnostic) {\n         let mut inner = self.inner.borrow_mut();\n-        inner.stash((span, key), diag);\n+        inner.stash((span.with_parent(None), key), diag);\n     }\n \n     /// Steal a previously stashed diagnostic with the given `Span` and [`StashKey`] as the key.\n     pub fn steal_diagnostic(&self, span: Span, key: StashKey) -> Option<DiagnosticBuilder<'_, ()>> {\n         let mut inner = self.inner.borrow_mut();\n-        inner.steal((span, key)).map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n+        inner\n+            .steal((span.with_parent(None), key))\n+            .map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n     }\n \n     pub fn has_stashed_diagnostic(&self, span: Span, key: StashKey) -> bool {\n-        self.inner.borrow().stashed_diagnostics.get(&(span, key)).is_some()\n+        self.inner.borrow().stashed_diagnostics.get(&(span.with_parent(None), key)).is_some()\n     }\n \n     /// Emit all stashed diagnostics.\n@@ -1203,7 +1208,11 @@ impl Handler {\n     pub fn flush_delayed(&self) {\n         let mut inner = self.inner.lock();\n         let bugs = std::mem::replace(&mut inner.delayed_span_bugs, Vec::new());\n-        inner.flush_delayed(bugs, \"no errors encountered even though `delay_span_bug` issued\");\n+        inner.flush_delayed(\n+            bugs,\n+            \"no errors encountered even though `delay_span_bug` issued\",\n+            ExplicitBug,\n+        );\n     }\n }\n \n@@ -1212,8 +1221,8 @@ impl HandlerInner {\n         self.taught_diagnostics.insert(code.clone())\n     }\n \n-    fn force_print_diagnostic(&mut self, mut db: Diagnostic) {\n-        self.emitter.emit_diagnostic(&mut db);\n+    fn force_print_diagnostic(&mut self, db: Diagnostic) {\n+        self.emitter.emit_diagnostic(&db);\n     }\n \n     /// Emit all stashed diagnostics.\n@@ -1288,67 +1297,69 @@ impl HandlerInner {\n             && !diagnostic.is_force_warn()\n         {\n             if diagnostic.has_future_breakage() {\n-                (*TRACK_DIAGNOSTICS)(diagnostic);\n+                (*TRACK_DIAGNOSTICS)(diagnostic, &mut |_| {});\n             }\n             return None;\n         }\n \n-        (*TRACK_DIAGNOSTICS)(diagnostic);\n-\n         if matches!(diagnostic.level, Level::Expect(_) | Level::Allow) {\n+            (*TRACK_DIAGNOSTICS)(diagnostic, &mut |_| {});\n             return None;\n         }\n \n-        if let Some(ref code) = diagnostic.code {\n-            self.emitted_diagnostic_codes.insert(code.clone());\n-        }\n-\n-        let already_emitted = |this: &mut Self| {\n-            let mut hasher = StableHasher::new();\n-            diagnostic.hash(&mut hasher);\n-            let diagnostic_hash = hasher.finish();\n-            !this.emitted_diagnostics.insert(diagnostic_hash)\n-        };\n+        let mut guaranteed = None;\n+        (*TRACK_DIAGNOSTICS)(diagnostic, &mut |diagnostic| {\n+            if let Some(ref code) = diagnostic.code {\n+                self.emitted_diagnostic_codes.insert(code.clone());\n+            }\n \n-        // Only emit the diagnostic if we've been asked to deduplicate or\n-        // haven't already emitted an equivalent diagnostic.\n-        if !(self.flags.deduplicate_diagnostics && already_emitted(self)) {\n-            debug!(?diagnostic);\n-            debug!(?self.emitted_diagnostics);\n-            let already_emitted_sub = |sub: &mut SubDiagnostic| {\n-                debug!(?sub);\n-                if sub.level != Level::OnceNote {\n-                    return false;\n-                }\n+            let already_emitted = |this: &mut Self| {\n                 let mut hasher = StableHasher::new();\n-                sub.hash(&mut hasher);\n+                diagnostic.hash(&mut hasher);\n                 let diagnostic_hash = hasher.finish();\n-                debug!(?diagnostic_hash);\n-                !self.emitted_diagnostics.insert(diagnostic_hash)\n+                !this.emitted_diagnostics.insert(diagnostic_hash)\n             };\n \n-            diagnostic.children.drain_filter(already_emitted_sub).for_each(|_| {});\n-\n-            self.emitter.emit_diagnostic(diagnostic);\n-            if diagnostic.is_error() {\n-                self.deduplicated_err_count += 1;\n-            } else if let Warning(_) = diagnostic.level {\n-                self.deduplicated_warn_count += 1;\n+            // Only emit the diagnostic if we've been asked to deduplicate or\n+            // haven't already emitted an equivalent diagnostic.\n+            if !(self.flags.deduplicate_diagnostics && already_emitted(self)) {\n+                debug!(?diagnostic);\n+                debug!(?self.emitted_diagnostics);\n+                let already_emitted_sub = |sub: &mut SubDiagnostic| {\n+                    debug!(?sub);\n+                    if sub.level != Level::OnceNote {\n+                        return false;\n+                    }\n+                    let mut hasher = StableHasher::new();\n+                    sub.hash(&mut hasher);\n+                    let diagnostic_hash = hasher.finish();\n+                    debug!(?diagnostic_hash);\n+                    !self.emitted_diagnostics.insert(diagnostic_hash)\n+                };\n+\n+                diagnostic.children.drain_filter(already_emitted_sub).for_each(|_| {});\n+\n+                self.emitter.emit_diagnostic(diagnostic);\n+                if diagnostic.is_error() {\n+                    self.deduplicated_err_count += 1;\n+                } else if let Warning(_) = diagnostic.level {\n+                    self.deduplicated_warn_count += 1;\n+                }\n             }\n-        }\n-        if diagnostic.is_error() {\n-            if matches!(diagnostic.level, Level::Error { lint: true }) {\n-                self.bump_lint_err_count();\n+            if diagnostic.is_error() {\n+                if matches!(diagnostic.level, Level::Error { lint: true }) {\n+                    self.bump_lint_err_count();\n+                } else {\n+                    self.bump_err_count();\n+                }\n+\n+                guaranteed = Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n             } else {\n-                self.bump_err_count();\n+                self.bump_warn_count();\n             }\n+        });\n \n-            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n-        } else {\n-            self.bump_warn_count();\n-\n-            None\n-        }\n+        guaranteed\n     }\n \n     fn emit_artifact_notification(&mut self, path: &Path, artifact_type: &str) {\n@@ -1580,6 +1591,7 @@ impl HandlerInner {\n         &mut self,\n         bugs: impl IntoIterator<Item = Diagnostic>,\n         explanation: impl Into<DiagnosticMessage> + Copy,\n+        panic_with: impl Any + Send + 'static,\n     ) {\n         let mut no_bugs = true;\n         for mut bug in bugs {\n@@ -1607,7 +1619,7 @@ impl HandlerInner {\n \n         // Panic with `ExplicitBug` to avoid \"unexpected panic\" messages.\n         if !no_bugs {\n-            panic::panic_any(ExplicitBug);\n+            panic::panic_any(panic_with);\n         }\n     }\n "}, {"sha": "93b3af4ab973df72f3577c846ab34511cec49adf", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -87,14 +87,14 @@ impl<'a> ExtCtxt<'a> {\n         self.anon_const(span, ast::ExprKind::Path(None, self.path_ident(span, ident)))\n     }\n \n-    pub fn ty_rptr(\n+    pub fn ty_ref(\n         &self,\n         span: Span,\n         ty: P<ast::Ty>,\n         lifetime: Option<ast::Lifetime>,\n         mutbl: ast::Mutability,\n     ) -> P<ast::Ty> {\n-        self.ty(span, ast::TyKind::Rptr(lifetime, self.ty_mt(ty, mutbl)))\n+        self.ty(span, ast::TyKind::Ref(lifetime, self.ty_mt(ty, mutbl)))\n     }\n \n     pub fn ty_ptr(&self, span: Span, ty: P<ast::Ty>, mutbl: ast::Mutability) -> P<ast::Ty> {\n@@ -626,7 +626,7 @@ impl<'a> ExtCtxt<'a> {\n \n     // Builds `#[name = val]`.\n     //\n-    // Note: `span` is used for both the identifer and the value.\n+    // Note: `span` is used for both the identifier and the value.\n     pub fn attr_name_value_str(&self, name: Symbol, val: Symbol, span: Span) -> ast::Attribute {\n         let g = &self.sess.parse_sess.attr_id_generator;\n         attr::mk_attr_name_value_str(g, ast::AttrStyle::Outer, name, val, span)"}, {"sha": "5d47c1ed363fbf0463ddde0118bba718d9ca10ec", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -587,7 +587,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 .resolver\n                 .visit_ast_fragment_with_placeholders(self.cx.current_expansion.id, &fragment);\n \n-            if self.cx.sess.opts.unstable_opts.incremental_relative_spans {\n+            if self.cx.sess.opts.incremental_relative_spans() {\n                 for (invoc, _) in invocations.iter_mut() {\n                     let expn_id = invoc.expansion_data.id;\n                     let parent_def = self.cx.resolver.invocation_parent(expn_id);"}, {"sha": "3a38d7a966960bb8857ebe489d959a4cabdbe65f", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -43,7 +43,7 @@ pub(super) fn failed_to_match_macro<'cx>(\n         return result;\n     }\n \n-    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n+    let Some(BestFailure { token, msg: label, remaining_matcher, .. }) = tracker.best_failure else {\n         return DummyResult::any(sp);\n     };\n \n@@ -95,11 +95,24 @@ struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n     cx: &'a mut ExtCtxt<'cx>,\n     remaining_matcher: Option<&'matcher MatcherLoc>,\n     /// Which arm's failure should we report? (the one furthest along)\n-    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n+    best_failure: Option<BestFailure>,\n     root_span: Span,\n     result: Option<Box<dyn MacResult + 'cx>>,\n }\n \n+struct BestFailure {\n+    token: Token,\n+    position_in_tokenstream: usize,\n+    msg: &'static str,\n+    remaining_matcher: MatcherLoc,\n+}\n+\n+impl BestFailure {\n+    fn is_better_position(&self, position: usize) -> bool {\n+        position > self.position_in_tokenstream\n+    }\n+}\n+\n impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n     fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n         if self.remaining_matcher.is_none()\n@@ -119,18 +132,25 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n                     \"should not collect detailed info for successful macro match\",\n                 );\n             }\n-            Failure(token, msg) => match self.best_failure {\n-                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n-                _ => {\n-                    self.best_failure = Some((\n-                        token.clone(),\n+            Failure(token, approx_position, msg) => {\n+                debug!(?token, ?msg, \"a new failure of an arm\");\n+\n+                if self\n+                    .best_failure\n+                    .as_ref()\n+                    .map_or(true, |failure| failure.is_better_position(*approx_position))\n+                {\n+                    self.best_failure = Some(BestFailure {\n+                        token: token.clone(),\n+                        position_in_tokenstream: *approx_position,\n                         msg,\n-                        self.remaining_matcher\n+                        remaining_matcher: self\n+                            .remaining_matcher\n                             .expect(\"must have collected matcher already\")\n                             .clone(),\n-                    ))\n+                    })\n                 }\n-            },\n+            }\n             Error(err_sp, msg) => {\n                 let span = err_sp.substitute_dummy(self.root_span);\n                 self.cx.struct_span_err(span, msg).emit();\n@@ -178,12 +198,12 @@ pub(super) fn emit_frag_parse_err(\n         );\n         if !e.span.is_dummy() {\n             // early end of macro arm (#52866)\n-            e.replace_span_with(parser.token.span.shrink_to_hi());\n+            e.replace_span_with(parser.token.span.shrink_to_hi(), true);\n         }\n     }\n     if e.span.is_dummy() {\n         // Get around lack of span in error (#30128)\n-        e.replace_span_with(site_span);\n+        e.replace_span_with(site_span, true);\n         if !parser.sess.source_map().is_imported(arm_span) {\n             e.span_label(arm_span, \"in this macro arm\");\n         }"}, {"sha": "df1c1834c1dc0d48b64c14c13e3c3ae950acd97a", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -310,7 +310,8 @@ pub(crate) enum ParseResult<T> {\n     Success(T),\n     /// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected\n     /// end of macro invocation. Otherwise, it indicates that no rules expected the given token.\n-    Failure(Token, &'static str),\n+    /// The usize is the approximate position of the token in the input token stream.\n+    Failure(Token, usize, &'static str),\n     /// Fatal error (malformed macro?). Abort compilation.\n     Error(rustc_span::Span, String),\n     ErrorReported(ErrorGuaranteed),\n@@ -455,6 +456,7 @@ impl TtParser {\n         &mut self,\n         matcher: &'matcher [MatcherLoc],\n         token: &Token,\n+        approx_position: usize,\n         track: &mut T,\n     ) -> Option<NamedParseResult> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n@@ -598,6 +600,7 @@ impl TtParser {\n                         token::Eof,\n                         if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },\n                     ),\n+                    approx_position,\n                     \"missing tokens in macro arguments\",\n                 ),\n             })\n@@ -627,7 +630,12 @@ impl TtParser {\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            let res = self.parse_tt_inner(matcher, &parser.token, track);\n+            let res = self.parse_tt_inner(\n+                matcher,\n+                &parser.token,\n+                parser.approx_token_stream_pos(),\n+                track,\n+            );\n             if let Some(res) = res {\n                 return res;\n             }\n@@ -642,6 +650,7 @@ impl TtParser {\n                     // parser: syntax error.\n                     return Failure(\n                         parser.token.clone(),\n+                        parser.approx_token_stream_pos(),\n                         \"no rules expected this token in macro call\",\n                     );\n                 }"}, {"sha": "fbb806fe81b2fb01cbde5c36b0762ed81811488c", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -326,8 +326,8 @@ pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n \n                 return Ok((i, named_matches));\n             }\n-            Failure(_, _) => {\n-                trace!(\"Failed to match arm, trying the next one\");\n+            Failure(_, reached_position, _) => {\n+                trace!(%reached_position, \"Failed to match arm, trying the next one\");\n                 // Try the next arm.\n             }\n             Error(_, _) => {\n@@ -432,7 +432,7 @@ pub fn compile_declarative_macro(\n     let argument_map =\n         match tt_parser.parse_tt(&mut Cow::Owned(parser), &argument_gram, &mut NoopTracker) {\n             Success(m) => m,\n-            Failure(token, msg) => {\n+            Failure(token, _, msg) => {\n                 let s = parse_failure_msg(&token);\n                 let sp = token.span.substitute_dummy(def.span);\n                 let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);\n@@ -1166,11 +1166,7 @@ fn check_matcher_core<'tt>(\n                                     err.note(&format!(\n                                         \"{}{} or {}\",\n                                         msg,\n-                                        ts[..ts.len() - 1]\n-                                            .iter()\n-                                            .copied()\n-                                            .collect::<Vec<_>>()\n-                                            .join(\", \"),\n+                                        ts[..ts.len() - 1].to_vec().join(\", \"),\n                                         ts[ts.len() - 1],\n                                     ));\n                                 }"}, {"sha": "e2f30fb89b91e9b3dd12943a7741fa9e6d9a1ade", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -194,7 +194,7 @@ declare_features! (\n     /// Allows irrefutable patterns in `if let` and `while let` statements (RFC 2086).\n     (accepted, irrefutable_let_patterns, \"1.33.0\", Some(44495), None),\n     /// Allows `#[instruction_set(_)]` attribute.\n-    (accepted, isa_attribute, \"CURRENT_RUSTC_VERSION\", Some(74727), None),\n+    (accepted, isa_attribute, \"1.67.0\", Some(74727), None),\n     /// Allows some increased flexibility in the name resolution rules,\n     /// especially around globs and shadowing (RFC 1560).\n     (accepted, item_like_imports, \"1.15.0\", Some(35120), None),\n@@ -240,7 +240,7 @@ declare_features! (\n     /// Allows specifying the bundle link modifier\n     (accepted, native_link_modifiers_bundle, \"1.63.0\", Some(81490), None),\n     /// Allows specifying the verbatim link modifier\n-    (accepted, native_link_modifiers_verbatim, \"CURRENT_RUSTC_VERSION\", Some(81490), None),\n+    (accepted, native_link_modifiers_verbatim, \"1.67.0\", Some(81490), None),\n     /// Allows specifying the whole-archive link modifier\n     (accepted, native_link_modifiers_whole_archive, \"1.61.0\", Some(81490), None),\n     /// Allows using non lexical lifetimes (RFC 2094)."}, {"sha": "beade4d44da84e6f4bb7610cf59e4c356fa51b85", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -383,7 +383,7 @@ declare_features! (\n     /// Allows `#[doc(masked)]`.\n     (active, doc_masked, \"1.21.0\", Some(44027), None),\n     /// Allows `dyn* Trait` objects.\n-    (incomplete, dyn_star, \"1.65.0\", Some(91611), None),\n+    (incomplete, dyn_star, \"1.65.0\", Some(102425), None),\n     /// Allows `X..Y` patterns.\n     (active, exclusive_range_pattern, \"1.11.0\", Some(37854), None),\n     /// Allows exhaustive pattern matching on types that contain uninhabited types.\n@@ -418,7 +418,7 @@ declare_features! (\n     /// Allows `impl Trait` as output type in `Fn` traits in return position of functions.\n     (active, impl_trait_in_fn_trait_return, \"1.64.0\", Some(99697), None),\n     /// Allows referencing `Self` and projections in impl-trait.\n-    (active, impl_trait_projections, \"CURRENT_RUSTC_VERSION\", Some(103532), None),\n+    (active, impl_trait_projections, \"1.67.0\", Some(103532), None),\n     /// Allows using imported `main` function\n     (active, imported_main, \"1.53.0\", Some(28937), None),\n     /// Allows associated types in inherent impls.\n@@ -505,7 +505,7 @@ declare_features! (\n     /// Allows lints part of the strict provenance effort.\n     (active, strict_provenance, \"1.61.0\", Some(95228), None),\n     /// Allows string patterns to dereference values to match them.\n-    (active, string_deref_patterns, \"CURRENT_RUSTC_VERSION\", Some(87121), None),\n+    (active, string_deref_patterns, \"1.67.0\", Some(87121), None),\n     /// Allows the use of `#[target_feature]` on safe functions.\n     (active, target_feature_11, \"1.45.0\", Some(69098), None),\n     /// Allows using `#[thread_local]` on `static` items."}, {"sha": "034f06bb889b61f47022102f0fcfe8abe9d5d5cc", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -854,7 +854,11 @@ impl fmt::Debug for OwnerNodes<'_> {\n                 &self\n                     .nodes\n                     .iter_enumerated()\n-                    .map(|(id, parented_node)| (id, parented_node.as_ref().map(|node| node.parent)))\n+                    .map(|(id, parented_node)| {\n+                        let parented_node = parented_node.as_ref().map(|node| node.parent);\n+\n+                        debug_fn(move |f| write!(f, \"({id:?}, {parented_node:?})\"))\n+                    })\n                     .collect::<Vec<_>>(),\n             )\n             .field(\"bodies\", &self.bodies)\n@@ -2431,7 +2435,7 @@ impl<'hir> Ty<'hir> {\n \n     pub fn peel_refs(&self) -> &Self {\n         let mut final_ty = self;\n-        while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n+        while let TyKind::Ref(_, MutTy { ty, .. }) = &final_ty.kind {\n             final_ty = ty;\n         }\n         final_ty\n@@ -2588,7 +2592,7 @@ pub enum TyKind<'hir> {\n     /// A raw pointer (i.e., `*const T` or `*mut T`).\n     Ptr(MutTy<'hir>),\n     /// A reference (i.e., `&'a T` or `&'a mut T`).\n-    Rptr(&'hir Lifetime, MutTy<'hir>),\n+    Ref(&'hir Lifetime, MutTy<'hir>),\n     /// A bare function (e.g., `fn(usize) -> bool`).\n     BareFn(&'hir BareFnTy<'hir>),\n     /// The never type (`!`).\n@@ -3609,16 +3613,19 @@ mod size_asserts {\n     static_assert_size!(Res, 12);\n     static_assert_size!(Stmt<'_>, 32);\n     static_assert_size!(StmtKind<'_>, 16);\n-    // tidy-alphabetical-end\n-    // FIXME: move the tidy directive to the end after the next bootstrap bump\n-    #[cfg(bootstrap)]\n-    static_assert_size!(TraitItem<'_>, 88);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(TraitItem<'_>, 80);\n-    #[cfg(bootstrap)]\n-    static_assert_size!(TraitItemKind<'_>, 48);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(TraitItemKind<'_>, 40);\n     static_assert_size!(Ty<'_>, 48);\n     static_assert_size!(TyKind<'_>, 32);\n+    // tidy-alphabetical-end\n+}\n+\n+fn debug_fn(f: impl Fn(&mut fmt::Formatter<'_>) -> fmt::Result) -> impl fmt::Debug {\n+    struct DebugFn<F>(F);\n+    impl<F: Fn(&mut fmt::Formatter<'_>) -> fmt::Result> fmt::Debug for DebugFn<F> {\n+        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            (self.0)(fmt)\n+        }\n+    }\n+    DebugFn(f)\n }"}, {"sha": "5d05adfb55654efb9184d872b62427aea6eefef3", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,14 +1,21 @@\n use crate::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_ID};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableOrd, ToStableHashKey};\n use rustc_span::{def_id::DefPathHash, HashStableContext};\n-use std::fmt;\n+use std::fmt::{self, Debug};\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[derive(Encodable, Decodable)]\n pub struct OwnerId {\n     pub def_id: LocalDefId,\n }\n \n+impl Debug for OwnerId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Example: DefId(0:1 ~ aa[7697]::{use#0})\n+        Debug::fmt(&self.def_id, f)\n+    }\n+}\n+\n impl From<OwnerId> for HirId {\n     fn from(owner: OwnerId) -> HirId {\n         HirId { owner, local_id: ItemLocalId::from_u32(0) }\n@@ -60,14 +67,22 @@ impl<CTX: HashStableContext> ToStableHashKey<CTX> for OwnerId {\n /// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[derive(Encodable, Decodable, HashStable_Generic)]\n #[rustc_pass_by_value]\n pub struct HirId {\n     pub owner: OwnerId,\n     pub local_id: ItemLocalId,\n }\n \n+impl Debug for HirId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Example: HirId(DefId(0:1 ~ aa[7697]::{use#0}).10)\n+        // Don't use debug_tuple to always keep this on one line.\n+        write!(f, \"HirId({:?}.{:?})\", self.owner, self.local_id)\n+    }\n+}\n+\n impl HirId {\n     /// Signal local id which should never be used.\n     pub const INVALID: HirId ="}, {"sha": "6c475b659eba0a87aaf65d8959dae479bbcac42c", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -809,7 +809,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n     match typ.kind {\n         TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n         TyKind::Ptr(ref mutable_type) => visitor.visit_ty(mutable_type.ty),\n-        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n+        TyKind::Ref(ref lifetime, ref mutable_type) => {\n             visitor.visit_lifetime(lifetime);\n             visitor.visit_ty(mutable_type.ty)\n         }"}, {"sha": "3474fab34f00b1e70bb777ac1f43adaf783369ad", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -146,7 +146,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n }\n \n language_item_table! {\n-//  Variant name,            Name,                     Method name,                Target                  Generic requirements;\n+//  Variant name,            Name,                     Getter method name,         Target                  Generic requirements;\n     Sized,                   sym::sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);\n     Unsize,                  sym::unsize,              unsize_trait,               Target::Trait,          GenericRequirement::Minimum(1);\n     /// Trait injected by `#[derive(PartialEq)]`, (i.e. \"Partial EQ\").\n@@ -232,14 +232,15 @@ language_item_table! {\n     // is required to define it somewhere. Additionally, there are restrictions on crates that use\n     // a weak lang item, but do not have it defined.\n     Panic,                   sym::panic,               panic_fn,                   Target::Fn,             GenericRequirement::Exact(0);\n+    PanicNounwind,           sym::panic_nounwind,      panic_nounwind,             Target::Fn,             GenericRequirement::Exact(0);\n     PanicFmt,                sym::panic_fmt,           panic_fmt,                  Target::Fn,             GenericRequirement::None;\n     PanicDisplay,            sym::panic_display,       panic_display,              Target::Fn,             GenericRequirement::None;\n     ConstPanicFmt,           sym::const_panic_fmt,     const_panic_fmt,            Target::Fn,             GenericRequirement::None;\n     PanicBoundsCheck,        sym::panic_bounds_check,  panic_bounds_check_fn,      Target::Fn,             GenericRequirement::Exact(0);\n     PanicInfo,               sym::panic_info,          panic_info,                 Target::Struct,         GenericRequirement::None;\n     PanicLocation,           sym::panic_location,      panic_location,             Target::Struct,         GenericRequirement::None;\n     PanicImpl,               sym::panic_impl,          panic_impl,                 Target::Fn,             GenericRequirement::None;\n-    PanicNoUnwind,           sym::panic_no_unwind,     panic_no_unwind,            Target::Fn,             GenericRequirement::Exact(0);\n+    PanicCannotUnwind,       sym::panic_cannot_unwind, panic_cannot_unwind,        Target::Fn,             GenericRequirement::Exact(0);\n     /// libstd panic entry point. Necessary for const eval to be able to catch it\n     BeginPanic,              sym::begin_panic,         begin_panic_fn,             Target::Fn,             GenericRequirement::None;\n "}, {"sha": "d7ab942665b33aa032a7137efb4392f55d763f98", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2626,7 +2626,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let e = self\n                     .tcx()\n                     .sess\n-                    .delay_span_bug(path.span, \"path with `Res:Err` but no error emitted\");\n+                    .delay_span_bug(path.span, \"path with `Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);\n                 self.tcx().ty_error_with_guaranteed(e)\n             }\n@@ -2657,7 +2657,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Ptr(ref mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut { ty: self.ast_ty_to_ty(mt.ty), mutbl: mt.mutbl })\n             }\n-            hir::TyKind::Rptr(ref region, ref mt) => {\n+            hir::TyKind::Ref(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(?r);\n                 let t = self.ast_ty_to_ty_inner(mt.ty, true, false);"}, {"sha": "28cd18bbb8e854d7162bdd310f972024e2fd6906", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,8 +1,8 @@\n use crate::check::intrinsicck::InlineAsmCtxt;\n use crate::errors::LinkageType;\n \n-use super::compare_method::check_type_bounds;\n-use super::compare_method::{compare_impl_method, compare_ty_impl};\n+use super::compare_impl_item::check_type_bounds;\n+use super::compare_impl_item::{compare_impl_method, compare_impl_ty};\n use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n@@ -468,7 +468,7 @@ fn check_opaque_meets_bounds<'tcx>(\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {\n             let outlives_environment = OutlivesEnvironment::new(param_env);\n-            infcx.check_region_obligations_and_report_errors(\n+            let _ = infcx.check_region_obligations_and_report_errors(\n                 defining_use_anchor,\n                 &outlives_environment,\n             );\n@@ -774,7 +774,7 @@ fn check_impl_items_against_trait<'tcx>(\n         let impl_item_full = tcx.hir().impl_item(impl_item.id);\n         match impl_item_full.kind {\n             hir::ImplItemKind::Const(..) => {\n-                let _ = tcx.compare_assoc_const_impl_item_with_trait_item((\n+                let _ = tcx.compare_impl_const((\n                     impl_item.id.owner_id.def_id,\n                     ty_impl_item.trait_item_def_id.unwrap(),\n                 ));\n@@ -791,7 +791,7 @@ fn check_impl_items_against_trait<'tcx>(\n             }\n             hir::ImplItemKind::Type(impl_ty) => {\n                 let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                compare_ty_impl(\n+                compare_impl_ty(\n                     tcx,\n                     &ty_impl_item,\n                     impl_ty.span,\n@@ -1060,10 +1060,8 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>)\n \n     if adt.variants().len() != 1 {\n         bad_variant_count(tcx, adt, tcx.def_span(adt.did()), adt.did());\n-        if adt.variants().is_empty() {\n-            // Don't bother checking the fields. No variants (and thus no fields) exist.\n-            return;\n-        }\n+        // Don't bother checking the fields.\n+        return;\n     }\n \n     // For each field, figure out if it's known to be a ZST and align(1), with \"known\""}, {"sha": "a767338ab85ccbb7a0a75a040e777c73dd5442c7", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "renamed", "additions": 53, "deletions": 20, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -34,7 +34,7 @@ use std::iter;\n /// - `impl_m_span`: span to use for reporting errors\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n-pub(crate) fn compare_impl_method<'tcx>(\n+pub(super) fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     trait_m: &ty::AssocItem,\n@@ -71,7 +71,7 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n-    if let Err(_) = compare_predicate_entailment(\n+    if let Err(_) = compare_method_predicate_entailment(\n         tcx,\n         impl_m,\n         impl_m_span,\n@@ -150,7 +150,7 @@ pub(crate) fn compare_impl_method<'tcx>(\n /// Finally we register each of these predicates as an obligation and check that\n /// they hold.\n #[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n-fn compare_predicate_entailment<'tcx>(\n+fn compare_method_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n@@ -337,7 +337,7 @@ fn compare_predicate_entailment<'tcx>(\n     if !errors.is_empty() {\n         match check_implied_wf {\n             CheckImpliedWfMode::Check => {\n-                return compare_predicate_entailment(\n+                return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n                     impl_m_span,\n@@ -374,7 +374,7 @@ fn compare_predicate_entailment<'tcx>(\n         // becomes a hard error (i.e. ideally we'd just call `resolve_regions_and_report_errors`\n         match check_implied_wf {\n             CheckImpliedWfMode::Check => {\n-                return compare_predicate_entailment(\n+                return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n                     impl_m_span,\n@@ -407,7 +407,7 @@ enum CheckImpliedWfMode {\n     /// re-check with `Skip`, and emit a lint if it succeeds.\n     Check,\n     /// Skips checking implied well-formedness of the impl method, but will emit\n-    /// a lint if the `compare_predicate_entailment` succeeded. This means that\n+    /// a lint if the `compare_method_predicate_entailment` succeeded. This means that\n     /// the reason that we had failed earlier during `Check` was due to the impl\n     /// having stronger requirements than the trait.\n     Skip,\n@@ -441,8 +441,41 @@ fn compare_asyncness<'tcx>(\n     Ok(())\n }\n \n+/// Given a method def-id in an impl, compare the method signature of the impl\n+/// against the trait that it's implementing. In doing so, infer the hidden types\n+/// that this method's signature provides to satisfy each return-position `impl Trait`\n+/// in the trait signature.\n+///\n+/// The method is also responsible for making sure that the hidden types for each\n+/// RPITIT actually satisfy the bounds of the `impl Trait`, i.e. that if we infer\n+/// `impl Trait = Foo`, that `Foo: Trait` holds.\n+///\n+/// For example, given the sample code:\n+///\n+/// ```\n+/// #![feature(return_position_impl_trait_in_trait)]\n+///\n+/// use std::ops::Deref;\n+///\n+/// trait Foo {\n+///     fn bar() -> impl Deref<Target = impl Sized>;\n+///              // ^- RPITIT #1        ^- RPITIT #2\n+/// }\n+///\n+/// impl Foo for () {\n+///     fn bar() -> Box<String> { Box::new(String::new()) }\n+/// }\n+/// ```\n+///\n+/// The hidden types for the RPITITs in `bar` would be inferred to:\n+///     * `impl Deref` (RPITIT #1) = `Box<String>`\n+///     * `impl Sized` (RPITIT #2) = `String`\n+///\n+/// The relationship between these two types is straightforward in this case, but\n+/// may be more tenuously connected via other `impl`s and normalization rules for\n+/// cases of more complicated nested RPITITs.\n #[instrument(skip(tcx), level = \"debug\", ret)]\n-pub fn collect_trait_impl_trait_tys<'tcx>(\n+pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed> {\n@@ -550,13 +583,13 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     // Unify the whole function signature. We need to do this to fully infer\n     // the lifetimes of the return type, but do this after unifying just the\n     // return types, since we want to avoid duplicating errors from\n-    // `compare_predicate_entailment`.\n+    // `compare_method_predicate_entailment`.\n     match ocx.eq(&cause, param_env, trait_fty, impl_fty) {\n         Ok(()) => {}\n         Err(terr) => {\n-            // This function gets called during `compare_predicate_entailment` when normalizing a\n+            // This function gets called during `compare_method_predicate_entailment` when normalizing a\n             // signature that contains RPITIT. When the method signatures don't match, we have to\n-            // emit an error now because `compare_predicate_entailment` will not report the error\n+            // emit an error now because `compare_method_predicate_entailment` will not report the error\n             // when normalization fails.\n             let emitted = report_trait_method_mismatch(\n                 infcx,\n@@ -589,7 +622,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     infcx.check_region_obligations_and_report_errors(\n         impl_m.def_id.expect_local(),\n         &outlives_environment,\n-    );\n+    )?;\n \n     let mut collected_tys = FxHashMap::default();\n     for (def_id, (ty, substs)) in collector.types {\n@@ -1516,8 +1549,8 @@ fn compare_generic_param_kinds<'tcx>(\n     Ok(())\n }\n \n-/// Use `tcx.compare_assoc_const_impl_item_with_trait_item` instead\n-pub(crate) fn raw_compare_const_impl(\n+/// Use `tcx.compare_impl_const` instead\n+pub(super) fn compare_impl_const_raw(\n     tcx: TyCtxt<'_>,\n     (impl_const_item_def, trait_const_item_def): (LocalDefId, DefId),\n ) -> Result<(), ErrorGuaranteed> {\n@@ -1617,13 +1650,13 @@ pub(crate) fn raw_compare_const_impl(\n         return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None));\n     }\n \n-    // FIXME return `ErrorReported` if region obligations error?\n     let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx.check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment);\n+    infcx.check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment)?;\n+\n     Ok(())\n }\n \n-pub(crate) fn compare_ty_impl<'tcx>(\n+pub(super) fn compare_impl_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n     impl_ty_span: Span,\n@@ -1645,7 +1678,7 @@ pub(crate) fn compare_ty_impl<'tcx>(\n     })();\n }\n \n-/// The equivalent of [compare_predicate_entailment], but for associated types\n+/// The equivalent of [compare_method_predicate_entailment], but for associated types\n /// instead of associated functions.\n fn compare_type_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -1730,7 +1763,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     infcx.check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),\n         &outlives_environment,\n-    );\n+    )?;\n \n     Ok(())\n }\n@@ -1749,7 +1782,7 @@ fn compare_type_predicate_entailment<'tcx>(\n /// from the impl could be overridden). We also can't normalize generic\n /// associated types (yet) because they contain bound parameters.\n #[instrument(level = \"debug\", skip(tcx))]\n-pub fn check_type_bounds<'tcx>(\n+pub(super) fn check_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ty: &ty::AssocItem,\n     impl_ty: &ty::AssocItem,\n@@ -1944,7 +1977,7 @@ pub fn check_type_bounds<'tcx>(\n     infcx.check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),\n         &outlives_environment,\n-    );\n+    )?;\n \n     let constraints = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n     for (key, value) in constraints {", "previous_filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs"}, {"sha": "382c3f5294511a40c364060f7b050773bcad737f", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -63,7 +63,7 @@ a type parameter).\n */\n \n mod check;\n-mod compare_method;\n+mod compare_impl_item;\n pub mod dropck;\n pub mod intrinsic;\n pub mod intrinsicck;\n@@ -94,7 +94,7 @@ use std::num::NonZeroU32;\n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n-use self::compare_method::collect_trait_impl_trait_tys;\n+use self::compare_impl_item::collect_return_position_impl_trait_in_trait_tys;\n use self::region::region_scope_tree;\n \n pub fn provide(providers: &mut Providers) {\n@@ -103,8 +103,8 @@ pub fn provide(providers: &mut Providers) {\n         adt_destructor,\n         check_mod_item_types,\n         region_scope_tree,\n-        collect_trait_impl_trait_tys,\n-        compare_assoc_const_impl_item_with_trait_item: compare_method::raw_compare_const_impl,\n+        collect_return_position_impl_trait_in_trait_tys,\n+        compare_impl_const: compare_impl_item::compare_impl_const_raw,\n         ..*providers\n     };\n }"}, {"sha": "0d1aa39c5d956bdb5d423780f5883f8a846326d3", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -115,7 +115,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     let outlives_environment =\n         OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n \n-    infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n+    let _ = infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n@@ -291,7 +291,7 @@ fn check_trait_item(tcx: TyCtxt<'_>, trait_item: &hir::TraitItem<'_>) {\n         // Do some rudimentary sanity checking to avoid an ICE later (issue #83471).\n         if let Some(hir::FnSig { decl, span, .. }) = method_sig {\n             if let [self_ty, _] = decl.inputs {\n-                if !matches!(self_ty.kind, hir::TyKind::Rptr(_, _)) {\n+                if !matches!(self_ty.kind, hir::TyKind::Ref(_, _)) {\n                     tcx.sess\n                         .struct_span_err(\n                             self_ty.span,\n@@ -410,10 +410,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                             tcx,\n                             param_env,\n                             item_hir_id,\n-                            tcx.explicit_item_bounds(item_def_id)\n-                                .iter()\n-                                .copied()\n-                                .collect::<Vec<_>>(),\n+                            tcx.explicit_item_bounds(item_def_id).to_vec(),\n                             &FxIndexSet::default(),\n                             gat_def_id.def_id,\n                             gat_generics,"}, {"sha": "bfedf63da97a878b25202f9da6f204ee7e77c111", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -325,7 +325,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n                 // Finally, resolve all regions.\n                 let outlives_env = OutlivesEnvironment::new(param_env);\n-                infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+                let _ = infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n             }\n         }\n         _ => {\n@@ -565,7 +565,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n     // Finally, resolve all regions.\n     let outlives_env = OutlivesEnvironment::new(param_env);\n-    infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+    let _ = infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n \n     CoerceUnsizedInfo { custom_kind: kind }\n }"}, {"sha": "e8b3f139623ed56ce750a81dc1a6765f0fc2fd62", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -53,7 +53,7 @@ fn do_orphan_check_impl<'tcx>(\n             sp,\n             item.span,\n             tr.path.span,\n-            trait_ref.self_ty(),\n+            trait_ref,\n             impl_.self_ty.span,\n             &impl_.generics,\n             err,\n@@ -154,11 +154,12 @@ fn emit_orphan_check_error<'tcx>(\n     sp: Span,\n     full_impl_span: Span,\n     trait_span: Span,\n-    self_ty: Ty<'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n     self_ty_span: Span,\n     generics: &hir::Generics<'tcx>,\n     err: traits::OrphanCheckErr<'tcx>,\n ) -> Result<!, ErrorGuaranteed> {\n+    let self_ty = trait_ref.self_ty();\n     Err(match err {\n         traits::OrphanCheckErr::NonLocalInputType(tys) => {\n             let msg = match self_ty.kind() {\n@@ -187,7 +188,14 @@ fn emit_orphan_check_error<'tcx>(\n                 let msg = |ty: &str, postfix: &str| {\n                     format!(\"{ty} is not defined in the current crate{postfix}\")\n                 };\n-                let this = |name: &str| msg(\"this\", &format!(\" because {name} are always foreign\"));\n+\n+                let this = |name: &str| {\n+                    if !trait_ref.def_id.is_local() && !is_target_ty {\n+                        msg(\"this\", &format!(\" because this is a foreign trait\"))\n+                    } else {\n+                        msg(\"this\", &format!(\" because {name} are always foreign\"))\n+                    }\n+                };\n                 let msg = match &ty.kind() {\n                     ty::Slice(_) => this(\"slices\"),\n                     ty::Array(..) => this(\"arrays\"),"}, {"sha": "1ff7429e415f89f8bac36cabf1064f2e20f61466", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -24,14 +24,18 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericParamKind, Node};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n use rustc_middle::ty::{self, AdtKind, Const, IsSuggestable, ToPredicate, Ty, TyCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n+use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n+use rustc_trait_selection::traits::ObligationCtxt;\n use std::iter;\n \n mod generics_of;\n@@ -1059,7 +1063,7 @@ fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n             is_suggestable_infer_ty(ty) || matches!(length, hir::ArrayLen::Infer(_, _))\n         }\n         Tup(tys) => tys.iter().any(is_suggestable_infer_ty),\n-        Ptr(mut_ty) | Rptr(_, mut_ty) => is_suggestable_infer_ty(mut_ty.ty),\n+        Ptr(mut_ty) | Ref(_, mut_ty) => is_suggestable_infer_ty(mut_ty.ty),\n         OpaqueDef(_, generic_args, _) => are_suggestable_generic_args(generic_args),\n         Path(hir::QPath::TypeRelative(ty, segment)) => {\n             is_suggestable_infer_ty(ty) || are_suggestable_generic_args(segment.args().args)\n@@ -1224,7 +1228,17 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n                 // to prevent the user from getting a papercut while trying to use the unique closure\n                 // syntax (e.g. `[closure@src/lib.rs:2:5: 2:9]`).\n                 diag.help(\"consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\");\n-                diag.note(\"for more information on `Fn` traits and closure types, see https://doc.rust-lang.org/book/ch13-01-closures.html\");\n+                diag.note(\n+                    \"for more information on `Fn` traits and closure types, see \\\n+                     https://doc.rust-lang.org/book/ch13-01-closures.html\",\n+                );\n+            } else if let Some(i_ty) = suggest_impl_iterator(tcx, ret_ty, ty.span, hir_id, def_id) {\n+                diag.span_suggestion(\n+                    ty.span,\n+                    \"replace with an appropriate return type\",\n+                    format!(\"impl Iterator<Item = {}>\", i_ty),\n+                    Applicability::MachineApplicable,\n+                );\n             }\n             diag.emit();\n \n@@ -1242,6 +1256,51 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n     }\n }\n \n+fn suggest_impl_iterator<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ret_ty: Ty<'tcx>,\n+    span: Span,\n+    hir_id: hir::HirId,\n+    def_id: LocalDefId,\n+) -> Option<Ty<'tcx>> {\n+    let Some(iter_trait) = tcx.get_diagnostic_item(sym::Iterator) else { return None; };\n+    let Some(iterator_item) = tcx.get_diagnostic_item(sym::IteratorItem) else { return None; };\n+    if !tcx\n+        .infer_ctxt()\n+        .build()\n+        .type_implements_trait(iter_trait, [ret_ty], tcx.param_env(def_id))\n+        .must_apply_modulo_regions()\n+    {\n+        return None;\n+    }\n+    let infcx = tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n+    // Find the type of `Iterator::Item`.\n+    let origin = TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n+    let ty_var = infcx.next_ty_var(origin);\n+    let projection = ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::Projection(\n+        ty::ProjectionPredicate {\n+            projection_ty: tcx.mk_alias_ty(iterator_item, tcx.mk_substs([ret_ty.into()].iter())),\n+            term: ty_var.into(),\n+        },\n+    )));\n+    // Add `<ret_ty as Iterator>::Item = _` obligation.\n+    ocx.register_obligation(crate::traits::Obligation::misc(\n+        tcx,\n+        span,\n+        hir_id,\n+        tcx.param_env(def_id),\n+        projection,\n+    ));\n+    if ocx.select_where_possible().is_empty()\n+        && let item_ty = infcx.resolve_vars_if_possible(ty_var)\n+        && item_ty.is_suggestable(tcx, false)\n+    {\n+        return Some(item_ty);\n+    }\n+    None\n+}\n+\n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n     let item = tcx.hir().expect_item(def_id.expect_local());"}, {"sha": "fb519d6731df929f7a875c92e2a212ceb7ea3c0d", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -617,7 +617,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     LifetimeName::Error => {}\n                 }\n             }\n-            hir::TyKind::Rptr(ref lifetime_ref, ref mt) => {\n+            hir::TyKind::Ref(ref lifetime_ref, ref mt) => {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: self.map.defs.get(&lifetime_ref.hir_id).cloned(),"}, {"sha": "4bd55a5483147e6c3709f91239dbf31a132c7790", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -5,6 +5,7 @@ use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{HirId, Node};\n use rustc_middle::hir::nested_filter;\n+use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n@@ -907,10 +908,10 @@ fn infer_placeholder_type<'a>(\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n-                    err.span_note(\n+                    with_forced_trimmed_paths!(err.span_note(\n                         tcx.hir().body(body_id).value.span,\n-                        &format!(\"however, the inferred type `{}` cannot be named\", ty),\n-                    );\n+                        &format!(\"however, the inferred type `{ty}` cannot be named\"),\n+                    ));\n                 }\n             }\n \n@@ -931,10 +932,10 @@ fn infer_placeholder_type<'a>(\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    diag.span_note(\n+                    with_forced_trimmed_paths!(diag.span_note(\n                         tcx.hir().body(body_id).value.span,\n-                        &format!(\"however, the inferred type `{}` cannot be named\", ty),\n-                    );\n+                        &format!(\"however, the inferred type `{ty}` cannot be named\"),\n+                    ));\n                 }\n             }\n "}, {"sha": "1aae9e0bd20af762ef80b5c88c1c98996c7aa3f6", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -81,7 +81,6 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, translate_substs, wf, ObligationCtxt};\n-use tracing::instrument;\n \n pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n@@ -182,7 +181,7 @@ fn get_impl_substs(\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n     let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n-    infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n+    let _ = infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);\n         tcx.sess.emit_err(SubstsOnOverriddenImpl { span });"}, {"sha": "24a67cc14c4fed5e4af9fda9e817aa67a42af97e", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -307,7 +307,7 @@ impl<'a> State<'a> {\n                 self.word(\"*\");\n                 self.print_mt(mt, true);\n             }\n-            hir::TyKind::Rptr(ref lifetime, ref mt) => {\n+            hir::TyKind::Ref(ref lifetime, ref mt) => {\n                 self.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n                 self.print_mt(mt, false);"}, {"sha": "829913d278d06233d4c6997da67f003b2f586fb0", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n             if let Some(ok) = self.lookup_method_in_trait(\n-                call_expr.span,\n+                self.misc(call_expr.span),\n                 method_name,\n                 trait_def_id,\n                 adjusted_ty,"}, {"sha": "3fb14e31ea116582a19da7981a7acc039e50abd6", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -171,6 +171,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n+            // Best-effort try to unify these types -- we're already on the error path,\n+            // so this will have the side-effect of making sure we have no ambiguities\n+            // due to `[type error]` and `_` not coercing together.\n+            let _ = self.commit_if_ok(|_| self.at(&self.cause, self.param_env).eq(a, b));\n             return success(vec![], self.fcx.tcx.ty_error(), vec![]);\n         }\n "}, {"sha": "1360383a75a958d80ca77a32a80c5d3700f6af65", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 227, "deletions": 1, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,5 +1,6 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -30,14 +31,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        _error: Option<TypeError<'tcx>>,\n+        error: Option<TypeError<'tcx>>,\n     ) {\n         if expr_ty == expected {\n             return;\n         }\n \n+        self.annotate_alternative_method_deref(err, expr, error);\n+\n         // Use `||` to give these suggestions a precedence\n         let _ = self.suggest_missing_parentheses(err, expr)\n+            || self.suggest_remove_last_method_call(err, expr, expected)\n             || self.suggest_associated_const(err, expr, expected)\n             || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n             || self.suggest_option_to_bool(err, expr, expr_ty, expected)\n@@ -70,6 +74,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n+        self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n     }\n \n     /// Requires that the two types unify, and prints an error message if\n@@ -315,6 +320,162 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn annotate_alternative_method_deref(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        error: Option<TypeError<'tcx>>,\n+    ) {\n+        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        let Some(TypeError::Sorts(ExpectedFound { expected, .. })) = error else {return;};\n+        let Some(hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Assign(lhs, rhs, _), ..\n+                })) = self.tcx.hir().find(parent) else {return; };\n+        if rhs.hir_id != expr.hir_id || expected.is_closure() {\n+            return;\n+        }\n+        let hir::ExprKind::Unary(hir::UnOp::Deref, deref) = lhs.kind else { return; };\n+        let hir::ExprKind::MethodCall(path, base, args, _) = deref.kind else { return; };\n+        let Some(self_ty) = self.typeck_results.borrow().expr_ty_adjusted_opt(base) else { return; };\n+\n+        let Ok(pick) = self\n+            .probe_for_name(\n+                probe::Mode::MethodCall,\n+                path.ident,\n+                probe::IsSuggestion(true),\n+                self_ty,\n+                deref.hir_id,\n+                probe::ProbeScope::TraitsInScope,\n+            ) else {\n+                return;\n+            };\n+        let in_scope_methods = self.probe_for_name_many(\n+            probe::Mode::MethodCall,\n+            path.ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            deref.hir_id,\n+            probe::ProbeScope::TraitsInScope,\n+        );\n+        let other_methods_in_scope: Vec<_> =\n+            in_scope_methods.iter().filter(|c| c.item.def_id != pick.item.def_id).collect();\n+\n+        let all_methods = self.probe_for_name_many(\n+            probe::Mode::MethodCall,\n+            path.ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            deref.hir_id,\n+            probe::ProbeScope::AllTraits,\n+        );\n+        let suggestions: Vec<_> = all_methods\n+            .into_iter()\n+            .filter(|c| c.item.def_id != pick.item.def_id)\n+            .map(|c| {\n+                let m = c.item;\n+                let substs = ty::InternalSubsts::for_item(self.tcx, m.def_id, |param, _| {\n+                    self.var_for_def(deref.span, param)\n+                });\n+                vec![\n+                    (\n+                        deref.span.until(base.span),\n+                        format!(\n+                            \"{}({}\",\n+                            with_no_trimmed_paths!(\n+                                self.tcx.def_path_str_with_substs(m.def_id, substs,)\n+                            ),\n+                            match self.tcx.fn_sig(m.def_id).input(0).skip_binder().kind() {\n+                                ty::Ref(_, _, hir::Mutability::Mut) => \"&mut \",\n+                                ty::Ref(_, _, _) => \"&\",\n+                                _ => \"\",\n+                            },\n+                        ),\n+                    ),\n+                    match &args[..] {\n+                        [] => (base.span.shrink_to_hi().with_hi(deref.span.hi()), \")\".to_string()),\n+                        [first, ..] => (base.span.between(first.span), \", \".to_string()),\n+                    },\n+                ]\n+            })\n+            .collect();\n+        if suggestions.is_empty() {\n+            return;\n+        }\n+        let mut path_span: MultiSpan = path.ident.span.into();\n+        path_span.push_span_label(\n+            path.ident.span,\n+            with_no_trimmed_paths!(format!(\n+                \"refers to `{}`\",\n+                self.tcx.def_path_str(pick.item.def_id),\n+            )),\n+        );\n+        let container_id = pick.item.container_id(self.tcx);\n+        let container = with_no_trimmed_paths!(self.tcx.def_path_str(container_id));\n+        for def_id in pick.import_ids {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+            path_span.push_span_label(\n+                self.tcx.hir().span(hir_id),\n+                format!(\"`{container}` imported here\"),\n+            );\n+        }\n+        let tail = with_no_trimmed_paths!(match &other_methods_in_scope[..] {\n+            [] => return,\n+            [candidate] => format!(\n+                \"the method of the same name on {} `{}`\",\n+                match candidate.kind {\n+                    probe::CandidateKind::InherentImplCandidate(..) => \"the inherent impl for\",\n+                    _ => \"trait\",\n+                },\n+                self.tcx.def_path_str(candidate.item.container_id(self.tcx))\n+            ),\n+            [.., last] if other_methods_in_scope.len() < 5 => {\n+                format!(\n+                    \"the methods of the same name on {} and `{}`\",\n+                    other_methods_in_scope[..other_methods_in_scope.len() - 1]\n+                        .iter()\n+                        .map(|c| format!(\n+                            \"`{}`\",\n+                            self.tcx.def_path_str(c.item.container_id(self.tcx))\n+                        ))\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    self.tcx.def_path_str(last.item.container_id(self.tcx))\n+                )\n+            }\n+            _ => format!(\n+                \"the methods of the same name on {} other traits\",\n+                other_methods_in_scope.len()\n+            ),\n+        });\n+        err.span_note(\n+            path_span,\n+            &format!(\n+                \"the `{}` call is resolved to the method in `{container}`, shadowing {tail}\",\n+                path.ident,\n+            ),\n+        );\n+        if suggestions.len() > other_methods_in_scope.len() {\n+            err.note(&format!(\n+                \"additionally, there are {} other available methods that aren't in scope\",\n+                suggestions.len() - other_methods_in_scope.len()\n+            ));\n+        }\n+        err.multipart_suggestions(\n+            &format!(\n+                \"you might have meant to call {}; you can use the fully-qualified path to call {} \\\n+                 explicitly\",\n+                if suggestions.len() == 1 {\n+                    \"the other method\"\n+                } else {\n+                    \"one of the other methods\"\n+                },\n+                if suggestions.len() == 1 { \"it\" } else { \"one of them\" },\n+            ),\n+            suggestions,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// If the expected type is an enum (Issue #55250) with any variants whose\n     /// sole field is of the found type, suggest such variants. (Issue #42764)\n     fn suggest_compatible_variants(\n@@ -1447,4 +1608,69 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => false,\n         }\n     }\n+\n+    /// Identify when the user has written `foo..bar()` instead of `foo.bar()`.\n+    pub fn check_for_range_as_method_call(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        checked_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) {\n+        if !hir::is_range_literal(expr) {\n+            return;\n+        }\n+        let hir::ExprKind::Struct(\n+            hir::QPath::LangItem(LangItem::Range, ..),\n+            [start, end],\n+            _,\n+        ) = expr.kind else { return; };\n+        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        if let Some(hir::Node::ExprField(_)) = self.tcx.hir().find(parent) {\n+            // Ignore `Foo { field: a..Default::default() }`\n+            return;\n+        }\n+        let mut expr = end.expr;\n+        while let hir::ExprKind::MethodCall(_, rcvr, ..) = expr.kind {\n+            // Getting to the root receiver and asserting it is a fn call let's us ignore cases in\n+            // `src/test/ui/methods/issues/issue-90315.stderr`.\n+            expr = rcvr;\n+        }\n+        let hir::ExprKind::Call(method_name, _) = expr.kind else { return; };\n+        let ty::Adt(adt, _) = checked_ty.kind() else { return; };\n+        if self.tcx.lang_items().range_struct() != Some(adt.did()) {\n+            return;\n+        }\n+        if let ty::Adt(adt, _) = expected_ty.kind()\n+            && self.tcx.lang_items().range_struct() == Some(adt.did())\n+        {\n+            return;\n+        }\n+        // Check if start has method named end.\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = method_name.kind else { return; };\n+        let [hir::PathSegment { ident, .. }] = p.segments else { return; };\n+        let self_ty = self.typeck_results.borrow().expr_ty(start.expr);\n+        let Ok(_pick) = self.probe_for_name(\n+            probe::Mode::MethodCall,\n+            *ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            expr.hir_id,\n+            probe::ProbeScope::AllTraits,\n+        ) else { return; };\n+        let mut sugg = \".\";\n+        let mut span = start.expr.span.between(end.expr.span);\n+        if span.lo() + BytePos(2) == span.hi() {\n+            // There's no space between the start, the range op and the end, suggest removal which\n+            // will be more noticeable than the replacement of `..` with `.`.\n+            span = span.with_lo(span.lo() + BytePos(1));\n+            sugg = \"\";\n+        }\n+        err.span_suggestion_verbose(\n+            span,\n+            \"you likely meant to write a method call instead of a range\",\n+            sugg,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n }"}, {"sha": "b8b4e873663100fbc3820820333ed3409ec67557", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -395,7 +395,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             E0614,\n                             \"type `{oprnd_t}` cannot be dereferenced\",\n                         );\n-                        let sp = tcx.sess.source_map().start_point(expr.span);\n+                        let sp = tcx.sess.source_map().start_point(expr.span).with_parent(None);\n                         if let Some(sp) =\n                             tcx.sess.parse_sess.ambiguous_block_expr_parse.borrow().get(&sp)\n                         {"}, {"sha": "d342d96a10fad74a3dd8feb6ff80eda3f74ba0e6", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1307,7 +1307,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Type check the initializer.\n         if let Some(ref init) = decl.init {\n             let init_ty = self.check_decl_initializer(decl.hir_id, decl.pat, &init);\n-            self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, decl_ty, init_ty);\n+            self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, init_ty);\n         }\n \n         // Does the expected pattern type originate from an expression and what is the span?\n@@ -1322,7 +1322,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Type check the pattern. Override if necessary to avoid knock-on errors.\n         self.check_pat_top(&decl.pat, decl_ty, ty_span, origin_expr);\n         let pat_ty = self.node_ty(decl.pat.hir_id);\n-        self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, decl_ty, pat_ty);\n+        self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, pat_ty);\n \n         if let Some(blk) = decl.els {\n             let previous_diverges = self.diverges.get();\n@@ -1627,14 +1627,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         hir_id: hir::HirId,\n         pat: &'tcx hir::Pat<'tcx>,\n-        decl_ty: Ty<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n         if ty.references_error() {\n             // Override the types everywhere with `err()` to avoid knock on errors.\n-            self.write_ty(hir_id, ty);\n-            self.write_ty(pat.hir_id, ty);\n-            let local_ty = LocalTy { decl_ty, revealed_ty: ty };\n+            let err = self.tcx.ty_error();\n+            self.write_ty(hir_id, err);\n+            self.write_ty(pat.hir_id, err);\n+            let local_ty = LocalTy { decl_ty: err, revealed_ty: err };\n             self.locals.borrow_mut().insert(hir_id, local_ty);\n             self.locals.borrow_mut().insert(pat.hir_id, local_ty);\n         }"}, {"sha": "322e11c978f48cd3ef2026a07e30f6228678b97d", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::ty::{\n     TypeVisitable,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n@@ -329,6 +330,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn suggest_remove_last_method_call(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expected: Ty<'tcx>,\n+    ) -> bool {\n+        if let hir::ExprKind::MethodCall(hir::PathSegment { ident: method, .. }, recv_expr, &[], _) = expr.kind &&\n+            let Some(recv_ty) = self.typeck_results.borrow().expr_ty_opt(recv_expr) &&\n+            self.can_coerce(recv_ty, expected) {\n+                let span = if let Some(recv_span) = recv_expr.span.find_ancestor_inside(expr.span) {\n+                    expr.span.with_lo(recv_span.hi())\n+                } else {\n+                    expr.span.with_lo(method.span.lo() - rustc_span::BytePos(1))\n+                };\n+                err.span_suggestion_verbose(\n+                    span,\n+                    \"try removing the method call\",\n+                    \"\",\n+                    Applicability::MachineApplicable,\n+                );\n+                return true;\n+            }\n+        false\n+    }\n+\n     pub fn suggest_deref_ref_or_into(\n         &self,\n         err: &mut Diagnostic,\n@@ -948,7 +974,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n     ) -> bool {\n-        let sp = self.tcx.sess.source_map().start_point(expr.span);\n+        let sp = self.tcx.sess.source_map().start_point(expr.span).with_parent(None);\n         if let Some(sp) = self.tcx.sess.parse_sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n             // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`\n             err.subdiagnostic(ExprParenthesesNeeded::surrounding(*sp));\n@@ -1234,6 +1260,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 true\n             }\n+            ExprKind::Lit(Spanned {\n+                node: rustc_ast::LitKind::Int(lit, rustc_ast::LitIntType::Unsuffixed),\n+                span,\n+            }) => {\n+                let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) else { return false; };\n+                if !(snippet.starts_with(\"0x\") || snippet.starts_with(\"0X\")) {\n+                    return false;\n+                }\n+                if snippet.len() <= 5 || !snippet.is_char_boundary(snippet.len() - 3) {\n+                    return false;\n+                }\n+                let (_, suffix) = snippet.split_at(snippet.len() - 3);\n+                let value = match suffix {\n+                    \"f32\" => (lit - 0xf32) / (16 * 16 * 16),\n+                    \"f64\" => (lit - 0xf64) / (16 * 16 * 16),\n+                    _ => return false,\n+                };\n+                err.span_suggestions(\n+                    expr.span,\n+                    \"rewrite this as a decimal floating point literal, or use `as` to turn a hex literal into a float\",\n+                    [format!(\"0x{value:X} as {suffix}\"), format!(\"{value}_{suffix}\")],\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n             _ => false,\n         }\n     }"}, {"sha": "b9b27e8627aff7024bd75538500b368ee1e93280", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 18, "deletions": 122, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -11,7 +11,7 @@ pub use self::suggest::SelfSource;\n pub use self::MethodError::*;\n \n use crate::errors::OpMethodGenericParams;\n-use crate::{Expectation, FnCtxt};\n+use crate::FnCtxt;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(super) fn obligation_for_method(\n         &self,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n@@ -282,71 +282,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            self.var_for_def(span, param)\n-        });\n-\n-        let trait_ref = self.tcx.mk_trait_ref(trait_def_id, substs);\n-\n-        // Construct an obligation\n-        let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        (\n-            traits::Obligation::misc(\n-                self.tcx,\n-                span,\n-                self.body_id,\n-                self.param_env,\n-                poly_trait_ref.without_const(),\n-            ),\n-            substs,\n-        )\n-    }\n-\n-    pub(super) fn obligation_for_op_method(\n-        &self,\n-        span: Span,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        opt_input_type: Option<Ty<'tcx>>,\n-        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        expected: Expectation<'tcx>,\n-    ) -> (traits::Obligation<'tcx, ty::Predicate<'tcx>>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>)\n-    {\n-        // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime | GenericParamDefKind::Const { .. } => {}\n-                GenericParamDefKind::Type { .. } => {\n-                    if param.index == 0 {\n-                        return self_ty.into();\n-                    } else if let Some(input_type) = opt_input_type {\n-                        return input_type.into();\n-                    }\n-                }\n-            }\n-            self.var_for_def(span, param)\n+            self.var_for_def(cause.span, param)\n         });\n \n         let trait_ref = self.tcx.mk_trait_ref(trait_def_id, substs);\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        let output_ty = expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n-\n         (\n             traits::Obligation::new(\n                 self.tcx,\n-                traits::ObligationCause::new(\n-                    span,\n-                    self.body_id,\n-                    traits::BinOp {\n-                        rhs_span: opt_input_expr.map(|expr| expr.span),\n-                        is_lit: opt_input_expr\n-                            .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                        output_ty,\n-                    },\n-                ),\n+                cause,\n                 self.param_env,\n-                poly_trait_ref,\n+                poly_trait_ref.without_const(),\n             ),\n             substs,\n         )\n@@ -357,69 +305,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// In particular, it doesn't really do any probing: it simply constructs\n     /// an obligation for a particular trait with the given self type and checks\n     /// whether that trait is implemented.\n-    #[instrument(level = \"debug\", skip(self, span))]\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn lookup_method_in_trait(\n         &self,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         m_name: Ident,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         let (obligation, substs) =\n-            self.obligation_for_method(span, trait_def_id, self_ty, opt_input_types);\n-        self.construct_obligation_for_trait(\n-            span,\n-            m_name,\n-            trait_def_id,\n-            obligation,\n-            substs,\n-            None,\n-            false,\n-        )\n-    }\n-\n-    pub(super) fn lookup_op_method_in_trait(\n-        &self,\n-        span: Span,\n-        m_name: Ident,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        opt_input_type: Option<Ty<'tcx>>,\n-        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        expected: Expectation<'tcx>,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        let (obligation, substs) = self.obligation_for_op_method(\n-            span,\n-            trait_def_id,\n-            self_ty,\n-            opt_input_type,\n-            opt_input_expr,\n-            expected,\n-        );\n-        self.construct_obligation_for_trait(\n-            span,\n-            m_name,\n-            trait_def_id,\n-            obligation,\n-            substs,\n-            opt_input_expr,\n-            true,\n-        )\n+            self.obligation_for_method(cause, trait_def_id, self_ty, opt_input_types);\n+        self.construct_obligation_for_trait(m_name, trait_def_id, obligation, substs)\n     }\n \n     // FIXME(#18741): it seems likely that we can consolidate some of this\n     // code with the other method-lookup code. In particular, the second half\n     // of this method is basically the same as confirmation.\n     fn construct_obligation_for_trait(\n         &self,\n-        span: Span,\n         m_name: Ident,\n         trait_def_id: DefId,\n         obligation: traits::PredicateObligation<'tcx>,\n         substs: &'tcx ty::List<ty::subst::GenericArg<'tcx>>,\n-        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        is_op: bool,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(?obligation);\n \n@@ -435,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let Some(method_item) = self.associated_value(trait_def_id, m_name) else {\n             tcx.sess.delay_span_bug(\n-                span,\n+                obligation.cause.span,\n                 \"operator trait does not have corresponding operator method\",\n             );\n             return None;\n@@ -461,24 +369,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // with bound regions.\n         let fn_sig = tcx.bound_fn_sig(def_id);\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n-        let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig);\n-\n-        let cause = if is_op {\n-            ObligationCause::new(\n-                span,\n-                self.body_id,\n-                traits::BinOp {\n-                    rhs_span: opt_input_expr.map(|expr| expr.span),\n-                    is_lit: opt_input_expr\n-                        .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                    output_ty: None,\n-                },\n-            )\n-        } else {\n-            traits::ObligationCause::misc(span, self.body_id)\n-        };\n+        let fn_sig =\n+            self.replace_bound_vars_with_fresh_vars(obligation.cause.span, infer::FnCall, fn_sig);\n \n-        let InferOk { value, obligations: o } = self.at(&cause, self.param_env).normalize(fn_sig);\n+        let InferOk { value, obligations: o } =\n+            self.at(&obligation.cause, self.param_env).normalize(fn_sig);\n         let fn_sig = {\n             obligations.extend(o);\n             value\n@@ -494,15 +389,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // any late-bound regions appearing in its bounds.\n         let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n \n-        let InferOk { value, obligations: o } = self.at(&cause, self.param_env).normalize(bounds);\n+        let InferOk { value, obligations: o } =\n+            self.at(&obligation.cause, self.param_env).normalize(bounds);\n         let bounds = {\n             obligations.extend(o);\n             value\n         };\n \n         assert!(!bounds.has_escaping_bound_vars());\n \n-        let predicates_cause = cause.clone();\n+        let predicates_cause = obligation.cause.clone();\n         obligations.extend(traits::predicates_for_generics(\n             move |_, _| predicates_cause.clone(),\n             self.param_env,\n@@ -517,7 +413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         obligations.push(traits::Obligation::new(\n             tcx,\n-            cause,\n+            obligation.cause,\n             self.param_env,\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(method_ty.into())),\n         ));"}, {"sha": "1afaae0e0209dfa9c176b69259ba9e92bda286cc", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> Deref for ProbeContext<'a, 'tcx> {\n }\n \n #[derive(Debug, Clone)]\n-struct Candidate<'tcx> {\n+pub(crate) struct Candidate<'tcx> {\n     // Candidates are (I'm not quite sure, but they are mostly) basically\n     // some metadata on top of a `ty::AssocItem` (without substs).\n     //\n@@ -131,13 +131,13 @@ struct Candidate<'tcx> {\n     // if `T: Sized`.\n     xform_self_ty: Ty<'tcx>,\n     xform_ret_ty: Option<Ty<'tcx>>,\n-    item: ty::AssocItem,\n-    kind: CandidateKind<'tcx>,\n-    import_ids: SmallVec<[LocalDefId; 1]>,\n+    pub(crate) item: ty::AssocItem,\n+    pub(crate) kind: CandidateKind<'tcx>,\n+    pub(crate) import_ids: SmallVec<[LocalDefId; 1]>,\n }\n \n #[derive(Debug, Clone)]\n-enum CandidateKind<'tcx> {\n+pub(crate) enum CandidateKind<'tcx> {\n     InherentImplCandidate(\n         SubstsRef<'tcx>,\n         // Normalize obligations\n@@ -322,6 +322,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(crate) fn probe_for_name_many(\n+        &self,\n+        mode: Mode,\n+        item_name: Ident,\n+        is_suggestion: IsSuggestion,\n+        self_ty: Ty<'tcx>,\n+        scope_expr_id: hir::HirId,\n+        scope: ProbeScope,\n+    ) -> Vec<Candidate<'tcx>> {\n+        self.probe_op(\n+            item_name.span,\n+            mode,\n+            Some(item_name),\n+            None,\n+            is_suggestion,\n+            self_ty,\n+            scope_expr_id,\n+            scope,\n+            |probe_cx| {\n+                Ok(probe_cx\n+                    .inherent_candidates\n+                    .into_iter()\n+                    .chain(probe_cx.extension_candidates)\n+                    .collect())\n+            },\n+        )\n+        .unwrap()\n+    }\n+\n     fn probe_op<OP, R>(\n         &'a self,\n         span: Span,\n@@ -943,6 +973,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             });\n         } else {\n             debug_assert!(self.tcx.is_trait(trait_def_id));\n+            if self.tcx.trait_is_auto(trait_def_id) {\n+                return;\n+            }\n             for item in self.impl_or_trait_item(trait_def_id) {\n                 // Check whether `trait_def_id` defines a method with suitable name.\n                 if !self.has_applicable_self(&item) {"}, {"sha": "7053c180685cbe9da258856cc75ba3b18c0e9487", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -339,7 +339,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &mut err, item_name, rcvr_ty, cal, span,\n                     );\n                 }\n-                if let Some(span) = tcx.resolutions(()).confused_type_with_std_module.get(&span) {\n+                if let Some(span) =\n+                    tcx.resolutions(()).confused_type_with_std_module.get(&span.with_parent(None))\n+                {\n                     err.span_suggestion(\n                         span.shrink_to_lo(),\n                         \"you are looking for the module in `std`, not the primitive type\",\n@@ -2306,6 +2308,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         _ => false,\n                     }\n                 }) && (type_is_local || info.def_id.is_local())\n+                    && !self.tcx.trait_is_auto(info.def_id)\n                     && self\n                         .associated_value(info.def_id, item_name)\n                         .filter(|item| {"}, {"sha": "78cea1f4d8d3e199295d83834e2e33398b5d2851", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -12,14 +12,16 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::FulfillmentError;\n+use rustc_trait_selection::traits::{self, FulfillmentError};\n use rustc_type_ir::sty::TyKind::*;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -48,8 +50,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if self\n                     .lookup_op_method(\n                         lhs_deref_ty,\n-                        Some(rhs_ty),\n-                        Some(rhs),\n+                        Some((rhs, rhs_ty)),\n                         Op::Binary(op, IsAssign::Yes),\n                         expected,\n                     )\n@@ -60,8 +61,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if self\n                         .lookup_op_method(\n                             lhs_ty,\n-                            Some(rhs_ty),\n-                            Some(rhs),\n+                            Some((rhs, rhs_ty)),\n                             Op::Binary(op, IsAssign::Yes),\n                             expected,\n                         )\n@@ -248,8 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result = self.lookup_op_method(\n             lhs_ty,\n-            Some(rhs_ty_var),\n-            Some(rhs_expr),\n+            Some((rhs_expr, rhs_ty_var)),\n             Op::Binary(op, is_assign),\n             expected,\n         );\n@@ -382,8 +381,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if self\n                         .lookup_op_method(\n                             lhs_deref_ty,\n-                            Some(rhs_ty),\n-                            Some(rhs_expr),\n+                            Some((rhs_expr, rhs_ty)),\n                             Op::Binary(op, is_assign),\n                             expected,\n                         )\n@@ -410,8 +408,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let is_compatible = |lhs_ty, rhs_ty| {\n                     self.lookup_op_method(\n                         lhs_ty,\n-                        Some(rhs_ty),\n-                        Some(rhs_expr),\n+                        Some((rhs_expr, rhs_ty)),\n                         Op::Binary(op, is_assign),\n                         expected,\n                     )\n@@ -471,8 +468,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let errors = self\n                             .lookup_op_method(\n                                 lhs_ty,\n-                                Some(rhs_ty),\n-                                Some(rhs_expr),\n+                                Some((rhs_expr, rhs_ty)),\n                                 Op::Binary(op, is_assign),\n                                 expected,\n                             )\n@@ -492,6 +488,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             if let Some(output_def_id) = output_def_id\n                                                 && let Some(trait_def_id) = trait_def_id\n                                                 && self.tcx.parent(output_def_id) == trait_def_id\n+                                                && output_ty.is_suggestable(self.tcx, false)\n                                             {\n                                                 Some((\"Output\", *output_ty))\n                                             } else {\n@@ -625,7 +622,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         assert!(op.is_by_value());\n-        match self.lookup_op_method(operand_ty, None, None, Op::Unary(op, ex.span), expected) {\n+        match self.lookup_op_method(operand_ty, None, Op::Unary(op, ex.span), expected) {\n             Ok(method) => {\n                 self.write_method_call(ex.hir_id, method);\n                 method.sig.output()\n@@ -660,7 +657,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n \n-                    let sp = self.tcx.sess.source_map().start_point(ex.span);\n+                    let sp = self.tcx.sess.source_map().start_point(ex.span).with_parent(None);\n                     if let Some(sp) =\n                         self.tcx.sess.parse_sess.ambiguous_block_expr_parse.borrow().get(&sp)\n                     {\n@@ -712,8 +709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn lookup_op_method(\n         &self,\n         lhs_ty: Ty<'tcx>,\n-        other_ty: Option<Ty<'tcx>>,\n-        other_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        opt_rhs: Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)>,\n         op: Op,\n         expected: Expectation<'tcx>,\n     ) -> Result<MethodCallee<'tcx>, Vec<FulfillmentError<'tcx>>> {\n@@ -742,20 +738,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Op::Unary(..) => 0,\n             },\n         ) {\n+            self.tcx\n+                .sess\n+                .delay_span_bug(span, \"operator didn't have the right number of generic args\");\n             return Err(vec![]);\n         }\n \n         let opname = Ident::with_dummy_span(opname);\n+        let input_types =\n+            opt_rhs.as_ref().map(|(_, ty)| std::slice::from_ref(ty)).unwrap_or_default();\n+        let cause = self.cause(\n+            span,\n+            traits::BinOp {\n+                rhs_span: opt_rhs.map(|(expr, _)| expr.span),\n+                is_lit: opt_rhs\n+                    .map_or(false, |(expr, _)| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                output_ty: expected.only_has_type(self),\n+            },\n+        );\n+\n         let method = trait_did.and_then(|trait_did| {\n-            self.lookup_op_method_in_trait(\n-                span,\n-                opname,\n-                trait_did,\n-                lhs_ty,\n-                other_ty,\n-                other_ty_expr,\n-                expected,\n-            )\n+            self.lookup_method_in_trait(cause.clone(), opname, trait_did, lhs_ty, Some(input_types))\n         });\n \n         match (method, trait_did) {\n@@ -766,14 +769,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             (None, None) => Err(vec![]),\n             (None, Some(trait_did)) => {\n-                let (obligation, _) = self.obligation_for_op_method(\n-                    span,\n-                    trait_did,\n-                    lhs_ty,\n-                    other_ty,\n-                    other_ty_expr,\n-                    expected,\n-                );\n+                let (obligation, _) =\n+                    self.obligation_for_method(cause, trait_did, lhs_ty, Some(input_types));\n                 Err(rustc_trait_selection::traits::fully_solve_obligation(self, obligation))\n             }\n         }"}, {"sha": "28e959b7c6a193e03340c766aa530daad2e762d8", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1013,7 +1013,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (res, opt_ty, segments) =\n             self.resolve_ty_and_res_fully_qualified_call(qpath, pat.hir_id, pat.span);\n         if res == Res::Err {\n-            let e = tcx.sess.delay_span_bug(pat.span, \"`Res:Err` but no error emitted\");\n+            let e = tcx.sess.delay_span_bug(pat.span, \"`Res::Err` but no error emitted\");\n             self.set_tainted_by_errors(e);\n             on_error(e);\n             return tcx.ty_error_with_guaranteed(e);\n@@ -1921,7 +1921,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n-        let (rptr_ty, inner_ty) = if self.check_dereferenceable(pat.span, expected, inner) {\n+        let (ref_ty, inner_ty) = if self.check_dereferenceable(pat.span, expected, inner) {\n             // `demand::subtype` would be good enough, but using `eqtype` turns\n             // out to be equally general. See (note_1) for details.\n \n@@ -1936,25 +1936,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         kind: TypeVariableOriginKind::TypeInference,\n                         span: inner.span,\n                     });\n-                    let rptr_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n-                    debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, rptr_ty);\n-                    let err = self.demand_eqtype_pat_diag(pat.span, expected, rptr_ty, ti);\n+                    let ref_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n+                    debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, ref_ty);\n+                    let err = self.demand_eqtype_pat_diag(pat.span, expected, ref_ty, ti);\n \n                     // Look for a case like `fn foo(&foo: u32)` and suggest\n                     // `fn foo(foo: &u32)`\n                     if let Some(mut err) = err {\n                         self.borrow_pat_suggestion(&mut err, pat);\n                         err.emit();\n                     }\n-                    (rptr_ty, inner_ty)\n+                    (ref_ty, inner_ty)\n                 }\n             }\n         } else {\n             let err = tcx.ty_error();\n             (err, err)\n         };\n         self.check_pat(inner, inner_ty, def_bm, ti);\n-        rptr_ty\n+        ref_ty\n     }\n \n     /// Create a reference type with a fresh region variable."}, {"sha": "a0f048fc09b9b017101fb4f59f7602f2ec4bd09d", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -225,7 +225,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         imm_tr.and_then(|trait_did| {\n             self.lookup_method_in_trait(\n-                span,\n+                self.misc(span),\n                 Ident::with_dummy_span(imm_op),\n                 trait_did,\n                 base_ty,\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         mut_tr.and_then(|trait_did| {\n             self.lookup_method_in_trait(\n-                span,\n+                self.misc(span),\n                 Ident::with_dummy_span(mut_op),\n                 trait_did,\n                 base_ty,"}, {"sha": "4430acf34db9ac1549eaeea8bd916ca4d5aede45", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -369,8 +369,8 @@ impl AddToDiagnostic for AddLifetimeParamsSuggestion<'_> {\n     {\n         let mut mk_suggestion = || {\n             let (\n-                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n-                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sup, _), .. },\n+                hir::Ty { kind: hir::TyKind::Ref(lifetime_sub, _), .. },\n+                hir::Ty { kind: hir::TyKind::Ref(lifetime_sup, _), .. },\n             ) = (self.ty_sub, self.ty_sup) else {\n                 return false;\n             };"}, {"sha": "7222eb7768203fffe33c9082b5ca806cd87e824f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -729,15 +729,15 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                             format!(\"this and all prior arms are found to be of type `{}`\", t),\n                         );\n                     }\n-                    let outer_error_span = if any_multiline_arm {\n+                    let outer = if any_multiline_arm || !source_map.is_multiline(cause.span) {\n                         // Cover just `match` and the scrutinee expression, not\n                         // the entire match body, to reduce diagram noise.\n                         cause.span.shrink_to_lo().to(scrut_span)\n                     } else {\n                         cause.span\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n-                    err.span_label(outer_error_span, msg);\n+                    err.span_label(outer, msg);\n                     self.suggest_remove_semi_or_return_binding(\n                         err,\n                         prior_arm_block_id,\n@@ -1836,7 +1836,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n         // In some (most?) cases cause.body_id points to actual body, but in some cases\n         // it's an actual definition. According to the comments (e.g. in\n-        // rustc_hir_analysis/check/compare_method.rs:compare_predicate_entailment) the latter\n+        // rustc_hir_analysis/check/compare_impl_item.rs:compare_predicate_entailment) the latter\n         // is relied upon by some other code. This might (or might not) need cleanup.\n         let body_owner_def_id =\n             self.tcx.hir().opt_local_def_id(cause.body_id).unwrap_or_else(|| {"}, {"sha": "39f4d5022598d05acfd70ba263fb04c2c239826c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -96,8 +96,8 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                 }\n             }\n \n-            hir::TyKind::Rptr(ref lifetime, _) => {\n-                // the lifetime of the TyRptr\n+            hir::TyKind::Ref(ref lifetime, _) => {\n+                // the lifetime of the Ref\n                 let hir_id = lifetime.hir_id;\n                 match (self.tcx.named_region(hir_id), self.bound_region) {\n                     // Find the index of the named region that was part of the"}, {"sha": "dc1dc8989221cf969c79ecbd0b904ee1d99aba6b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -147,7 +147,7 @@ impl<'tcx> Visitor<'tcx> for TypeParamSpanVisitor<'tcx> {\n \n     fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n         match arg.kind {\n-            hir::TyKind::Rptr(_, ref mut_ty) => {\n+            hir::TyKind::Ref(_, ref mut_ty) => {\n                 // We don't want to suggest looking into borrowing `&T` or `&Self`.\n                 hir::intravisit::walk_ty(self, mut_ty.ty);\n                 return;"}, {"sha": "d91ef882bc4b8e93da9d28dc49bc3fce328ca8f1", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 84, "deletions": 39, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2,11 +2,14 @@ use crate::errors::RegionOriginNote;\n use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n use crate::infer::{self, SubregionOrigin};\n use rustc_errors::{\n-    fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    fluent, struct_span_err, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder,\n+    ErrorGuaranteed,\n };\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::{self, Region};\n+use rustc_middle::ty::{self, IsSuggestable, Region};\n+use rustc_span::symbol::kw;\n \n use super::ObligationCauseAsDiagArg;\n \n@@ -313,55 +316,38 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 );\n                 err\n             }\n-            infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => self\n-                .report_extra_impl_obligation(\n+            infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => {\n+                let mut err = self.report_extra_impl_obligation(\n                     span,\n                     impl_item_def_id,\n                     trait_item_def_id,\n                     &format!(\"`{}: {}`\", sup, sub),\n-                ),\n+                );\n+                // We should only suggest rewriting the `where` clause if the predicate is within that `where` clause\n+                if let Some(generics) = self.tcx.hir().get_generics(impl_item_def_id)\n+                    && generics.where_clause_span.contains(span)\n+                {\n+                    self.suggest_copy_trait_method_bounds(\n+                        trait_item_def_id,\n+                        impl_item_def_id,\n+                        &mut err,\n+                    );\n+                }\n+                err\n+            }\n             infer::CheckAssociatedTypeBounds { impl_item_def_id, trait_item_def_id, parent } => {\n                 let mut err = self.report_concrete_failure(*parent, sub, sup);\n-\n                 let trait_item_span = self.tcx.def_span(trait_item_def_id);\n                 let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n                 err.span_label(\n                     trait_item_span,\n                     format!(\"definition of `{}` from trait\", item_name),\n                 );\n-\n-                let trait_predicates = self.tcx.explicit_predicates_of(trait_item_def_id);\n-                let impl_predicates = self.tcx.explicit_predicates_of(impl_item_def_id);\n-\n-                let impl_predicates: rustc_data_structures::fx::FxHashSet<_> =\n-                    impl_predicates.predicates.into_iter().map(|(pred, _)| pred).collect();\n-                let clauses: Vec<_> = trait_predicates\n-                    .predicates\n-                    .into_iter()\n-                    .filter(|&(pred, _)| !impl_predicates.contains(pred))\n-                    .map(|(pred, _)| format!(\"{}\", pred))\n-                    .collect();\n-\n-                if !clauses.is_empty() {\n-                    let generics = self.tcx.hir().get_generics(impl_item_def_id).unwrap();\n-                    let where_clause_span = generics.tail_span_for_predicate_suggestion();\n-\n-                    let suggestion = format!(\n-                        \"{} {}\",\n-                        generics.add_where_or_trailing_comma(),\n-                        clauses.join(\", \"),\n-                    );\n-                    err.span_suggestion(\n-                        where_clause_span,\n-                        &format!(\n-                            \"try copying {} from the trait\",\n-                            if clauses.len() > 1 { \"these clauses\" } else { \"this clause\" }\n-                        ),\n-                        suggestion,\n-                        rustc_errors::Applicability::MaybeIncorrect,\n-                    );\n-                }\n-\n+                self.suggest_copy_trait_method_bounds(\n+                    trait_item_def_id,\n+                    impl_item_def_id,\n+                    &mut err,\n+                );\n                 err\n             }\n             infer::AscribeUserTypeProvePredicate(span) => {\n@@ -388,6 +374,65 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n+    pub fn suggest_copy_trait_method_bounds(\n+        &self,\n+        trait_item_def_id: DefId,\n+        impl_item_def_id: LocalDefId,\n+        err: &mut Diagnostic,\n+    ) {\n+        // FIXME(compiler-errors): Right now this is only being used for region\n+        // predicate mismatches. Ideally, we'd use it for *all* predicate mismatches,\n+        // but right now it's not really very smart when it comes to implicit `Sized`\n+        // predicates and bounds on the trait itself.\n+\n+        let Some(impl_def_id) =\n+            self.tcx.associated_item(impl_item_def_id).impl_container(self.tcx) else { return; };\n+        let Some(trait_ref) = self\n+            .tcx\n+            .impl_trait_ref(impl_def_id)\n+            else { return; };\n+        let trait_substs = trait_ref\n+            // Replace the explicit self type with `Self` for better suggestion rendering\n+            .with_self_ty(self.tcx, self.tcx.mk_ty_param(0, kw::SelfUpper))\n+            .substs;\n+        let trait_item_substs =\n+            ty::InternalSubsts::identity_for_item(self.tcx, impl_item_def_id.to_def_id())\n+                .rebase_onto(self.tcx, impl_def_id, trait_substs);\n+\n+        let Ok(trait_predicates) = self\n+            .tcx\n+            .bound_explicit_predicates_of(trait_item_def_id)\n+            .map_bound(|p| p.predicates)\n+            .subst_iter_copied(self.tcx, trait_item_substs)\n+            .map(|(pred, _)| {\n+                if pred.is_suggestable(self.tcx, false) {\n+                    Ok(pred.to_string())\n+                } else {\n+                    Err(())\n+                }\n+            })\n+            .collect::<Result<Vec<_>, ()>>() else { return; };\n+\n+        let Some(generics) = self.tcx.hir().get_generics(impl_item_def_id) else { return; };\n+\n+        if trait_predicates.is_empty() {\n+            err.span_suggestion_verbose(\n+                generics.where_clause_span,\n+                \"remove the `where` clause\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            let space = if generics.where_clause_span.is_empty() { \" \" } else { \"\" };\n+            err.span_suggestion_verbose(\n+                generics.where_clause_span,\n+                \"copy the `where` clause predicates from the trait\",\n+                format!(\"{space}where {}\", trait_predicates.join(\", \")),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n     pub(super) fn report_placeholder_failure(\n         &self,\n         placeholder_origin: SubregionOrigin<'tcx>,"}, {"sha": "41b115f3377ac879d7287aa3910dcdf492221fc7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_region.rs", "status": "removed", "additions": 0, "deletions": 427, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs?ref=1010099fe359e4a01ebd873e3bdb2d66b60bc3ed", "patch": "@@ -1,427 +0,0 @@\n-use crate::errors::RegionOriginNote;\n-use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n-use crate::infer::{self, SubregionOrigin};\n-use rustc_errors::{\n-    fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-};\n-use rustc_middle::traits::ObligationCauseCode;\n-use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::{self, Region};\n-\n-use super::ObligationCauseAsDiagArg;\n-\n-impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n-        match *origin {\n-            infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n-                span: trace.cause.span,\n-                requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n-                expected_found: self.values_str(trace.values),\n-            }\n-            .add_to_diagnostic(err),\n-            infer::Reborrow(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_reborrow }.add_to_diagnostic(err)\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_reborrow,\n-                    name: &var_name.to_string(),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-            infer::RelateObjectBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n-                    .add_to_diagnostic(err);\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_data_borrowed,\n-                    name: &self.ty_to_string(ty),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_reference_outlives_referent,\n-                    name: &self.ty_to_string(ty),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-            infer::RelateParamBound(span, ty, opt_span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_relate_param_bound,\n-                    name: &self.ty_to_string(ty),\n-                    continues: opt_span.is_some(),\n-                }\n-                .add_to_diagnostic(err);\n-                if let Some(span) = opt_span {\n-                    RegionOriginNote::Plain { span, msg: fluent::infer_relate_param_bound_2 }\n-                        .add_to_diagnostic(err);\n-                }\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_relate_region_param_bound }\n-                    .add_to_diagnostic(err);\n-            }\n-            infer::CompareImplItemObligation { span, .. } => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_compare_impl_item_obligation }\n-                    .add_to_diagnostic(err);\n-            }\n-            infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n-                self.note_region_origin(err, &parent);\n-            }\n-            infer::AscribeUserTypeProvePredicate(span) => {\n-                RegionOriginNote::Plain {\n-                    span,\n-                    msg: fluent::infer_ascribe_user_type_prove_predicate,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-        }\n-    }\n-\n-    pub(super) fn report_concrete_failure(\n-        &self,\n-        origin: SubregionOrigin<'tcx>,\n-        sub: Region<'tcx>,\n-        sup: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        match origin {\n-            infer::Subtype(box trace) => {\n-                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                let mut err = self.report_and_explain_type_error(trace, terr);\n-                match (*sub, *sup) {\n-                    (ty::RePlaceholder(_), ty::RePlaceholder(_)) => {}\n-                    (ty::RePlaceholder(_), _) => {\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            &mut err,\n-                            \"\",\n-                            sup,\n-                            \" doesn't meet the lifetime requirements\",\n-                            None,\n-                        );\n-                    }\n-                    (_, ty::RePlaceholder(_)) => {\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            &mut err,\n-                            \"the required lifetime does not necessarily outlive \",\n-                            sub,\n-                            \"\",\n-                            None,\n-                        );\n-                    }\n-                    _ => {\n-                        note_and_explain_region(self.tcx, &mut err, \"\", sup, \"...\", None);\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            &mut err,\n-                            \"...does not necessarily outlive \",\n-                            sub,\n-                            \"\",\n-                            None,\n-                        );\n-                    }\n-                }\n-                err\n-            }\n-            infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0312,\n-                    \"lifetime of reference outlives lifetime of borrowed content...\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...the reference is valid for \",\n-                    sub,\n-                    \"...\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...but the borrowed content is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0313,\n-                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n-                    var_name\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...the borrowed pointer is valid for \",\n-                    sub,\n-                    \"...\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    &format!(\"...but `{}` is only valid for \", var_name),\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0476,\n-                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n-                     object type\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"object type is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"source pointer is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::RelateParamBound(span, ty, opt_span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0477,\n-                    \"the type `{}` does not fulfill the required lifetime\",\n-                    self.ty_to_string(ty)\n-                );\n-                match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                }\n-                err\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"lifetime parameter instantiated with \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but lifetime parameter must outlive \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0490,\n-                    \"a value of type `{}` is borrowed for too long\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"the type is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but the borrow lasts for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0491,\n-                    \"in type `{}`, reference has a longer lifetime than the data it references\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"the pointer is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but the referenced data is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => self\n-                .report_extra_impl_obligation(\n-                    span,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                    &format!(\"`{}: {}`\", sup, sub),\n-                ),\n-            infer::CheckAssociatedTypeBounds { impl_item_def_id, trait_item_def_id, parent } => {\n-                let mut err = self.report_concrete_failure(*parent, sub, sup);\n-\n-                let trait_item_span = self.tcx.def_span(trait_item_def_id);\n-                let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n-                err.span_label(\n-                    trait_item_span,\n-                    format!(\"definition of `{}` from trait\", item_name),\n-                );\n-\n-                let trait_predicates = self.tcx.explicit_predicates_of(trait_item_def_id);\n-                let impl_predicates = self.tcx.explicit_predicates_of(impl_item_def_id);\n-\n-                let impl_predicates: rustc_data_structures::fx::FxHashSet<_> =\n-                    impl_predicates.predicates.into_iter().map(|(pred, _)| pred).collect();\n-                let clauses: Vec<_> = trait_predicates\n-                    .predicates\n-                    .into_iter()\n-                    .filter(|&(pred, _)| !impl_predicates.contains(pred))\n-                    .map(|(pred, _)| format!(\"{}\", pred))\n-                    .collect();\n-\n-                if !clauses.is_empty() {\n-                    let generics = self.tcx.hir().get_generics(impl_item_def_id).unwrap();\n-                    let where_clause_span = generics.tail_span_for_predicate_suggestion();\n-\n-                    let suggestion = format!(\n-                        \"{} {}\",\n-                        generics.add_where_or_trailing_comma(),\n-                        clauses.join(\", \"),\n-                    );\n-                    err.span_suggestion(\n-                        where_clause_span,\n-                        &format!(\n-                            \"try copying {} from the trait\",\n-                            if clauses.len() > 1 { \"these clauses\" } else { \"this clause\" }\n-                        ),\n-                        suggestion,\n-                        rustc_errors::Applicability::MaybeIncorrect,\n-                    );\n-                }\n-\n-                err\n-            }\n-            infer::AscribeUserTypeProvePredicate(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"lifetime instantiated with \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but lifetime must outlive \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-        }\n-    }\n-\n-    pub(super) fn report_placeholder_failure(\n-        &self,\n-        placeholder_origin: SubregionOrigin<'tcx>,\n-        sub: Region<'tcx>,\n-        sup: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        // I can't think how to do better than this right now. -nikomatsakis\n-        debug!(?placeholder_origin, ?sub, ?sup, \"report_placeholder_failure\");\n-        match placeholder_origin {\n-            infer::Subtype(box ref trace)\n-                if matches!(\n-                    &trace.cause.code().peel_derives(),\n-                    ObligationCauseCode::BindingObligation(..)\n-                        | ObligationCauseCode::ExprBindingObligation(..)\n-                ) =>\n-            {\n-                // Hack to get around the borrow checker because trace.cause has an `Rc`.\n-                if let ObligationCauseCode::BindingObligation(_, span)\n-                | ObligationCauseCode::ExprBindingObligation(_, span, ..) =\n-                    &trace.cause.code().peel_derives()\n-                {\n-                    let span = *span;\n-                    let mut err = self.report_concrete_failure(placeholder_origin, sub, sup);\n-                    err.span_note(span, \"the lifetime requirement is introduced here\");\n-                    err\n-                } else {\n-                    unreachable!()\n-                }\n-            }\n-            infer::Subtype(box trace) => {\n-                let terr = TypeError::RegionsPlaceholderMismatch;\n-                return self.report_and_explain_type_error(trace, terr);\n-            }\n-            _ => return self.report_concrete_failure(placeholder_origin, sub, sup),\n-        }\n-    }\n-}"}, {"sha": "b17a465eb38311c6dc3fada6037af41b5044db69", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1693,7 +1693,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         &self,\n         generic_param_scope: LocalDefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Option<ErrorGuaranteed> {\n+    ) -> Result<(), ErrorGuaranteed> {\n         let errors = self.resolve_regions(outlives_env);\n \n         if let None = self.tainted_by_errors() {\n@@ -1705,9 +1705,14 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             self.report_region_errors(generic_param_scope, &errors);\n         }\n \n-        (!errors.is_empty()).then(|| {\n-            self.tcx.sess.delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\")\n-        })\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(self\n+                .tcx\n+                .sess\n+                .delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\"))\n+        }\n     }\n \n     // [Note-Type-error-reporting]"}, {"sha": "2ccbd164faaf16d1926814d2319190848bb0cee7", "filename": "compiler/rustc_infer/src/infer/note.rs", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs?ref=1010099fe359e4a01ebd873e3bdb2d66b60bc3ed", "patch": "@@ -1,203 +0,0 @@\n-impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    fn note_error_origin(\n-        &self,\n-        err: &mut Diagnostic,\n-        cause: &ObligationCause<'tcx>,\n-        exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n-        terr: TypeError<'tcx>,\n-    ) {\n-        match *cause.code() {\n-            ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n-                let ty = self.resolve_vars_if_possible(root_ty);\n-                if !matches!(ty.kind(), ty::Infer(ty::InferTy::TyVar(_) | ty::InferTy::FreshTy(_)))\n-                {\n-                    // don't show type `_`\n-                    if span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n-                        && let ty::Adt(def, substs) = ty.kind()\n-                        && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n-                    {\n-                        err.span_label(span, format!(\"this is an iterator with items of type `{}`\", substs.type_at(0)));\n-                    } else {\n-                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n-                }\n-                }\n-                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n-                    && ty.is_box() && ty.boxed_ty() == found\n-                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-                {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider dereferencing the boxed value\",\n-                        format!(\"*{}\", snippet),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n-                err.span_label(span, \"expected due to this\");\n-            }\n-            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                arm_block_id,\n-                arm_span,\n-                arm_ty,\n-                prior_arm_block_id,\n-                prior_arm_span,\n-                prior_arm_ty,\n-                source,\n-                ref prior_arms,\n-                scrut_hir_id,\n-                opt_suggest_box_span,\n-                scrut_span,\n-                ..\n-            }) => match source {\n-                hir::MatchSource::TryDesugar => {\n-                    if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n-                        let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n-                        let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n-                            let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n-                            self.typeck_results.as_ref().and_then(|typeck_results| {\n-                                typeck_results.expr_ty_opt(arg_expr)\n-                            })\n-                        } else {\n-                            bug!(\"try desugaring w/out call expr as scrutinee\");\n-                        };\n-\n-                        match scrut_ty {\n-                            Some(ty) if expected == ty => {\n-                                let source_map = self.tcx.sess.source_map();\n-                                err.span_suggestion(\n-                                    source_map.end_point(cause.span),\n-                                    \"try removing this `?`\",\n-                                    \"\",\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // `prior_arm_ty` can be `!`, `expected` will have better info when present.\n-                    let t = self.resolve_vars_if_possible(match exp_found {\n-                        Some(ty::error::ExpectedFound { expected, .. }) => expected,\n-                        _ => prior_arm_ty,\n-                    });\n-                    let source_map = self.tcx.sess.source_map();\n-                    let mut any_multiline_arm = source_map.is_multiline(arm_span);\n-                    if prior_arms.len() <= 4 {\n-                        for sp in prior_arms {\n-                            any_multiline_arm |= source_map.is_multiline(*sp);\n-                            err.span_label(*sp, format!(\"this is found to be of type `{}`\", t));\n-                        }\n-                    } else if let Some(sp) = prior_arms.last() {\n-                        any_multiline_arm |= source_map.is_multiline(*sp);\n-                        err.span_label(\n-                            *sp,\n-                            format!(\"this and all prior arms are found to be of type `{}`\", t),\n-                        );\n-                    }\n-                    let outer_error_span = if any_multiline_arm {\n-                        // Cover just `match` and the scrutinee expression, not\n-                        // the entire match body, to reduce diagram noise.\n-                        cause.span.shrink_to_lo().to(scrut_span)\n-                    } else {\n-                        cause.span\n-                    };\n-                    let msg = \"`match` arms have incompatible types\";\n-                    err.span_label(outer_error_span, msg);\n-                    self.suggest_remove_semi_or_return_binding(\n-                        err,\n-                        prior_arm_block_id,\n-                        prior_arm_ty,\n-                        prior_arm_span,\n-                        arm_block_id,\n-                        arm_ty,\n-                        arm_span,\n-                    );\n-                    if let Some(ret_sp) = opt_suggest_box_span {\n-                        // Get return type span and point to it.\n-                        self.suggest_boxing_for_return_impl_trait(\n-                            err,\n-                            ret_sp,\n-                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n-                        );\n-                    }\n-                }\n-            },\n-            ObligationCauseCode::IfExpression(box IfExpressionCause {\n-                then_id,\n-                else_id,\n-                then_ty,\n-                else_ty,\n-                outer_span,\n-                opt_suggest_box_span,\n-            }) => {\n-                let then_span = self.find_block_span_from_hir_id(then_id);\n-                let else_span = self.find_block_span_from_hir_id(else_id);\n-                err.span_label(then_span, \"expected because of this\");\n-                if let Some(sp) = outer_span {\n-                    err.span_label(sp, \"`if` and `else` have incompatible types\");\n-                }\n-                self.suggest_remove_semi_or_return_binding(\n-                    err,\n-                    Some(then_id),\n-                    then_ty,\n-                    then_span,\n-                    Some(else_id),\n-                    else_ty,\n-                    else_span,\n-                );\n-                if let Some(ret_sp) = opt_suggest_box_span {\n-                    self.suggest_boxing_for_return_impl_trait(\n-                        err,\n-                        ret_sp,\n-                        [then_span, else_span].into_iter(),\n-                    );\n-                }\n-            }\n-            ObligationCauseCode::LetElse => {\n-                err.help(\"try adding a diverging expression, such as `return` or `panic!(..)`\");\n-                err.help(\"...or use `match` instead of `let...else`\");\n-            }\n-            _ => {\n-                if let ObligationCauseCode::BindingObligation(_, span)\n-                | ObligationCauseCode::ExprBindingObligation(_, span, ..)\n-                = cause.code().peel_derives()\n-                    && let TypeError::RegionsPlaceholderMismatch = terr\n-                {\n-                    err.span_note( * span,\n-                    \"the lifetime requirement is introduced here\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> InferCtxt<'tcx> {\n-    /// Given a [`hir::Block`], get the span of its last expression or\n-    /// statement, peeling off any inner blocks.\n-    pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n-        let block = block.innermost_block();\n-        if let Some(expr) = &block.expr {\n-            expr.span\n-        } else if let Some(stmt) = block.stmts.last() {\n-            // possibly incorrect trailing `;` in the else arm\n-            stmt.span\n-        } else {\n-            // empty block; point at its entirety\n-            block.span\n-        }\n-    }\n-\n-    /// Given a [`hir::HirId`] for a block, get the span of its last expression\n-    /// or statement, peeling off any inner blocks.\n-    pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n-        match self.tcx.hir().get(hir_id) {\n-            hir::Node::Block(blk) => self.find_block_span(blk),\n-            // The parser was in a weird state if either of these happen, but\n-            // it's better not to panic.\n-            hir::Node::Expr(e) => e.span,\n-            _ => rustc_span::DUMMY_SP,\n-        }\n-    }\n-}"}, {"sha": "f71c39dc0d26a33e82fd144c4fa84fd4d60c3d7b", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -178,7 +178,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         generic_param_scope: LocalDefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Option<ErrorGuaranteed> {\n+    ) -> Result<(), ErrorGuaranteed> {\n         self.process_registered_region_obligations(\n             outlives_env.region_bound_pairs(),\n             outlives_env.param_env,"}, {"sha": "ee0552d77ceee8080eab5dd43ed6f63f115a2e9f", "filename": "compiler/rustc_interface/src/callbacks.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -10,6 +10,7 @@\n //! origin crate when the `TyCtxt` is not present in TLS.\n \n use rustc_errors::{Diagnostic, TRACK_DIAGNOSTICS};\n+use rustc_middle::dep_graph::TaskDepsRef;\n use rustc_middle::ty::tls;\n use std::fmt;\n \n@@ -26,14 +27,22 @@ fn track_span_parent(def_id: rustc_span::def_id::LocalDefId) {\n /// This is a callback from `rustc_ast` as it cannot access the implicit state\n /// in `rustc_middle` otherwise. It is used when diagnostic messages are\n /// emitted and stores them in the current query, if there is one.\n-fn track_diagnostic(diagnostic: &Diagnostic) {\n+fn track_diagnostic(diagnostic: &mut Diagnostic, f: &mut dyn FnMut(&mut Diagnostic)) {\n     tls::with_context_opt(|icx| {\n         if let Some(icx) = icx {\n             if let Some(diagnostics) = icx.diagnostics {\n                 let mut diagnostics = diagnostics.lock();\n                 diagnostics.extend(Some(diagnostic.clone()));\n+                std::mem::drop(diagnostics);\n             }\n+\n+            // Diagnostics are tracked, we can ignore the dependency.\n+            let icx = tls::ImplicitCtxt { task_deps: TaskDepsRef::Ignore, ..icx.clone() };\n+            return tls::enter_context(&icx, move |_| (*f)(diagnostic));\n         }\n+\n+        // In any other case, invoke diagnostics anyway.\n+        (*f)(diagnostic);\n     })\n }\n \n@@ -55,5 +64,5 @@ fn def_id_debug(def_id: rustc_hir::def_id::DefId, f: &mut fmt::Formatter<'_>) ->\n pub fn setup_callbacks() {\n     rustc_span::SPAN_TRACK.swap(&(track_span_parent as fn(_)));\n     rustc_hir::def_id::DEF_ID_DEBUG.swap(&(def_id_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n-    TRACK_DIAGNOSTICS.swap(&(track_diagnostic as fn(&_)));\n+    TRACK_DIAGNOSTICS.swap(&(track_diagnostic as _));\n }"}, {"sha": "eb3baba999b9cc49b463ad782abf276b766f5cee", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -652,7 +652,6 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(future_incompat_test, true);\n     untracked!(hir_stats, true);\n     untracked!(identify_regions, true);\n-    untracked!(incremental_ignore_spans, true);\n     untracked!(incremental_info, true);\n     untracked!(incremental_verify_ich, true);\n     untracked!(input_stats, true);\n@@ -737,6 +736,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(fuel, Some((\"abc\".to_string(), 99)));\n     tracked!(function_sections, Some(false));\n     tracked!(human_readable_cgu_names, true);\n+    tracked!(incremental_ignore_spans, true);\n     tracked!(inline_in_all_cgus, Some(true));\n     tracked!(inline_mir, Some(true));\n     tracked!(inline_mir_hint_threshold, Some(123));"}, {"sha": "4c65fca29b89721542148dcfadf447bee9f7048b", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -851,7 +851,7 @@ impl Cursor<'_> {\n     }\n \n     // Eats the identifier. Note: succeeds on `_`, which isn't a valid\n-    // identifer.\n+    // identifier.\n     fn eat_identifier(&mut self) {\n         if !is_id_start(self.first()) {\n             return;"}, {"sha": "cdb901b7f8603b65329e31ff6e14e7385db6c222", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 85, "deletions": 63, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2184,30 +2184,36 @@ impl ExplicitOutlivesRequirements {\n         tcx: TyCtxt<'tcx>,\n         bounds: &hir::GenericBounds<'_>,\n         inferred_outlives: &[ty::Region<'tcx>],\n+        predicate_span: Span,\n     ) -> Vec<(usize, Span)> {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         bounds\n             .iter()\n             .enumerate()\n             .filter_map(|(i, bound)| {\n-                if let hir::GenericBound::Outlives(lifetime) = bound {\n-                    let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                        Some(Region::EarlyBound(def_id)) => inferred_outlives.iter().any(|r| {\n-                            if let ty::ReEarlyBound(ebr) = **r {\n-                                ebr.def_id == def_id\n-                            } else {\n-                                false\n-                            }\n-                        }),\n-                        _ => false,\n-                    };\n-                    is_inferred.then_some((i, bound.span()))\n-                } else {\n-                    None\n+                let hir::GenericBound::Outlives(lifetime) = bound else {\n+                    return None;\n+                };\n+\n+                let is_inferred = match tcx.named_region(lifetime.hir_id) {\n+                    Some(Region::EarlyBound(def_id)) => inferred_outlives\n+                        .iter()\n+                        .any(|r| matches!(**r, ty::ReEarlyBound(ebr) if { ebr.def_id == def_id })),\n+                    _ => false,\n+                };\n+\n+                if !is_inferred {\n+                    return None;\n                 }\n+\n+                let span = bound.span().find_ancestor_inside(predicate_span)?;\n+                if in_external_macro(tcx.sess, span) {\n+                    return None;\n+                }\n+\n+                Some((i, span))\n             })\n-            .filter(|(_, span)| !in_external_macro(tcx.sess, *span))\n             .collect()\n     }\n \n@@ -2273,9 +2279,9 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         let def_id = item.owner_id.def_id;\n-        if let hir::ItemKind::Struct(_, ref hir_generics)\n-        | hir::ItemKind::Enum(_, ref hir_generics)\n-        | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n+        if let hir::ItemKind::Struct(_, hir_generics)\n+        | hir::ItemKind::Enum(_, hir_generics)\n+        | hir::ItemKind::Union(_, hir_generics) = item.kind\n         {\n             let inferred_outlives = cx.tcx.inferred_outlives_of(def_id);\n             if inferred_outlives.is_empty() {\n@@ -2290,53 +2296,58 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             let mut dropped_predicate_count = 0;\n             let num_predicates = hir_generics.predicates.len();\n             for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n-                let (relevant_lifetimes, bounds, span, in_where_clause) = match where_predicate {\n-                    hir::WherePredicate::RegionPredicate(predicate) => {\n-                        if let Some(Region::EarlyBound(region_def_id)) =\n-                            cx.tcx.named_region(predicate.lifetime.hir_id)\n-                        {\n-                            (\n-                                Self::lifetimes_outliving_lifetime(\n-                                    inferred_outlives,\n-                                    region_def_id,\n-                                ),\n-                                &predicate.bounds,\n-                                predicate.span,\n-                                predicate.in_where_clause,\n-                            )\n-                        } else {\n-                            continue;\n-                        }\n-                    }\n-                    hir::WherePredicate::BoundPredicate(predicate) => {\n-                        // FIXME we can also infer bounds on associated types,\n-                        // and should check for them here.\n-                        match predicate.bounded_ty.kind {\n-                            hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                                let Res::Def(DefKind::TyParam, def_id) = path.res else {\n-                                    continue\n-                                };\n-                                let index = ty_generics.param_def_id_to_index[&def_id];\n+                let (relevant_lifetimes, bounds, predicate_span, in_where_clause) =\n+                    match where_predicate {\n+                        hir::WherePredicate::RegionPredicate(predicate) => {\n+                            if let Some(Region::EarlyBound(region_def_id)) =\n+                                cx.tcx.named_region(predicate.lifetime.hir_id)\n+                            {\n                                 (\n-                                    Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                    Self::lifetimes_outliving_lifetime(\n+                                        inferred_outlives,\n+                                        region_def_id,\n+                                    ),\n                                     &predicate.bounds,\n                                     predicate.span,\n-                                    predicate.origin == PredicateOrigin::WhereClause,\n+                                    predicate.in_where_clause,\n                                 )\n-                            }\n-                            _ => {\n+                            } else {\n                                 continue;\n                             }\n                         }\n-                    }\n-                    _ => continue,\n-                };\n+                        hir::WherePredicate::BoundPredicate(predicate) => {\n+                            // FIXME we can also infer bounds on associated types,\n+                            // and should check for them here.\n+                            match predicate.bounded_ty.kind {\n+                                hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n+                                    let Res::Def(DefKind::TyParam, def_id) = path.res else {\n+                                    continue;\n+                                };\n+                                    let index = ty_generics.param_def_id_to_index[&def_id];\n+                                    (\n+                                        Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                        &predicate.bounds,\n+                                        predicate.span,\n+                                        predicate.origin == PredicateOrigin::WhereClause,\n+                                    )\n+                                }\n+                                _ => {\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+                        _ => continue,\n+                    };\n                 if relevant_lifetimes.is_empty() {\n                     continue;\n                 }\n \n-                let bound_spans =\n-                    self.collect_outlives_bound_spans(cx.tcx, bounds, &relevant_lifetimes);\n+                let bound_spans = self.collect_outlives_bound_spans(\n+                    cx.tcx,\n+                    bounds,\n+                    &relevant_lifetimes,\n+                    predicate_span,\n+                );\n                 bound_count += bound_spans.len();\n \n                 let drop_predicate = bound_spans.len() == bounds.len();\n@@ -2345,15 +2356,15 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 }\n \n                 if drop_predicate && !in_where_clause {\n-                    lint_spans.push(span);\n+                    lint_spans.push(predicate_span);\n                 } else if drop_predicate && i + 1 < num_predicates {\n                     // If all the bounds on a predicate were inferable and there are\n                     // further predicates, we want to eat the trailing comma.\n                     let next_predicate_span = hir_generics.predicates[i + 1].span();\n-                    where_lint_spans.push(span.to(next_predicate_span.shrink_to_lo()));\n+                    where_lint_spans.push(predicate_span.to(next_predicate_span.shrink_to_lo()));\n                 } else {\n                     where_lint_spans.extend(self.consolidate_outlives_bound_spans(\n-                        span.shrink_to_lo(),\n+                        predicate_span.shrink_to_lo(),\n                         bounds,\n                         bound_spans,\n                     ));\n@@ -2374,24 +2385,35 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     } else {\n                         hir_generics.span.shrink_to_hi().to(where_span)\n                     };\n-                lint_spans.push(full_where_span);\n+\n+                // Due to macro expansions, the `full_where_span` might not actually contain all predicates.\n+                if where_lint_spans.iter().all(|&sp| full_where_span.contains(sp)) {\n+                    lint_spans.push(full_where_span);\n+                } else {\n+                    lint_spans.extend(where_lint_spans);\n+                }\n             } else {\n                 lint_spans.extend(where_lint_spans);\n             }\n \n             if !lint_spans.is_empty() {\n+                // Do not automatically delete outlives requirements from macros.\n+                let applicability = if lint_spans.iter().all(|sp| sp.can_be_used_for_suggestions())\n+                {\n+                    Applicability::MachineApplicable\n+                } else {\n+                    Applicability::MaybeIncorrect\n+                };\n+\n                 cx.struct_span_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n                     fluent::lint_builtin_explicit_outlives,\n                     |lint| {\n                         lint.set_arg(\"count\", bound_count).multipart_suggestion(\n                             fluent::suggestion,\n-                            lint_spans\n-                                .into_iter()\n-                                .map(|span| (span, String::new()))\n-                                .collect::<Vec<_>>(),\n-                            Applicability::MachineApplicable,\n+                            lint_spans.into_iter().map(|span| (span, String::new())).collect(),\n+                            applicability,\n                         )\n                     },\n                 );"}, {"sha": "a16bb7f1a5f47aaaf3e1b5105c3e16c3090c1866", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -355,14 +355,12 @@ impl LintStore {\n                     sub: RequestedLevel { level, lint_name },\n                 });\n             }\n-            CheckLintNameResult::Tool(result) => {\n-                if let Err((Some(_), new_name)) = result {\n-                    sess.emit_warning(CheckNameDeprecated {\n-                        lint_name: lint_name.clone(),\n-                        new_name,\n-                        sub: RequestedLevel { level, lint_name },\n-                    });\n-                }\n+            CheckLintNameResult::Tool(Err((Some(_), new_name))) => {\n+                sess.emit_warning(CheckNameDeprecated {\n+                    lint_name: lint_name.clone(),\n+                    new_name,\n+                    sub: RequestedLevel { level, lint_name },\n+                });\n             }\n             CheckLintNameResult::NoTool => {\n                 sess.emit_err(CheckNameUnknownTool {"}, {"sha": "22caadfab177d40b087c2ecee4433eaa078809a8", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -22,7 +22,7 @@ declare_lint_pass!(PassByValue => [PASS_BY_VALUE]);\n impl<'tcx> LateLintPass<'tcx> for PassByValue {\n     fn check_ty(&mut self, cx: &LateContext<'_>, ty: &'tcx hir::Ty<'tcx>) {\n         match &ty.kind {\n-            TyKind::Rptr(_, hir::MutTy { ty: inner_ty, mutbl: hir::Mutability::Not }) => {\n+            TyKind::Ref(_, hir::MutTy { ty: inner_ty, mutbl: hir::Mutability::Not }) => {\n                 if let Some(impl_did) = cx.tcx.impl_of_method(ty.hir_id.owner.to_def_id()) {\n                     if cx.tcx.impl_trait_ref(impl_did).is_some() {\n                         return;"}, {"sha": "a7a5234049fe63db04d6789e5a509238dd4346ae", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1142,6 +1142,7 @@ impl UnusedDelimLint for UnusedBraces {\n                             && !cx.sess().source_map().is_multiline(value.span)\n                             && value.attrs.is_empty()\n                             && !value.span.from_expansion()\n+                            && !inner.span.from_expansion()\n                         {\n                             self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n                         }"}, {"sha": "28317d6cea02a599a0a0cddf1a164911eba33332", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -3581,7 +3581,7 @@ declare_lint! {\n     /// fn main() {\n     ///     let x: String = \"3\".try_into().unwrap();\n     ///     //                  ^^^^^^^^\n-    ///     // This call to try_into matches both Foo:try_into and TryInto::try_into as\n+    ///     // This call to try_into matches both Foo::try_into and TryInto::try_into as\n     ///     // `TryInto` has been added to the Rust prelude in 2021 edition.\n     ///     println!(\"{x}\");\n     /// }"}, {"sha": "cee4ba56a9d8f863180eefcb1c3bb4e7745ae23c", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -54,7 +54,7 @@\n use crate::creader::CStore;\n use crate::errors::{\n     BadPanicStrategy, CrateDepMultiple, IncompatiblePanicInDropStrategy, LibRequired,\n-    RequiredPanicStrategy, RlibRequired, TwoPanicRuntimes,\n+    RequiredPanicStrategy, RlibRequired, RustcLibRequired, TwoPanicRuntimes,\n };\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -224,7 +224,12 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n                     Linkage::Static => \"rlib\",\n                     _ => \"dylib\",\n                 };\n-                sess.emit_err(LibRequired { crate_name: tcx.crate_name(cnum), kind: kind });\n+                let crate_name = tcx.crate_name(cnum);\n+                if crate_name.as_str().starts_with(\"rustc_\") {\n+                    sess.emit_err(RustcLibRequired { crate_name, kind });\n+                } else {\n+                    sess.emit_err(LibRequired { crate_name, kind });\n+                }\n             }\n         }\n     }"}, {"sha": "02c03114eb67f637cf5b1236e0d25d1310239019", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -24,6 +24,14 @@ pub struct LibRequired<'a> {\n     pub kind: &'a str,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(metadata_rustc_lib_required)]\n+#[help]\n+pub struct RustcLibRequired<'a> {\n+    pub crate_name: Symbol,\n+    pub kind: &'a str,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(metadata_crate_dep_multiple)]\n #[help]\n@@ -486,25 +494,15 @@ impl IntoDiagnostic<'_> for MultipleCandidates {\n         let mut diag = handler.struct_err(rustc_errors::fluent::metadata_multiple_candidates);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"flavor\", self.flavor);\n-        diag.code(error_code!(E0465));\n+        diag.code(error_code!(E0464));\n         diag.set_span(self.span);\n         for (i, candidate) in self.candidates.iter().enumerate() {\n-            diag.span_note(self.span, &format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n+            diag.note(&format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n         }\n         diag\n     }\n }\n \n-#[derive(Diagnostic)]\n-#[diag(metadata_multiple_matching_crates, code = \"E0464\")]\n-#[note]\n-pub struct MultipleMatchingCrates {\n-    #[primary_span]\n-    pub span: Span,\n-    pub crate_name: Symbol,\n-    pub candidates: String,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(metadata_symbol_conflicts_current, code = \"E0519\")]\n pub struct SymbolConflictsCurrent {"}, {"sha": "92dc5bd41cbab45ae3ac84031c10d63b2f0b01c9", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -216,9 +216,8 @@ use crate::creader::Library;\n use crate::errors::{\n     CannotFindCrate, CrateLocationUnknownType, DlError, ExternLocationNotExist,\n     ExternLocationNotFile, FoundStaticlib, IncompatibleRustc, InvalidMetadataFiles,\n-    LibFilenameForm, MultipleCandidates, MultipleMatchingCrates, NewerCrateVersion,\n-    NoCrateWithTriple, NoDylibPlugin, NonAsciiName, StableCrateIdCollision, SymbolConflictsCurrent,\n-    SymbolConflictsOthers,\n+    LibFilenameForm, MultipleCandidates, NewerCrateVersion, NoCrateWithTriple, NoDylibPlugin,\n+    NonAsciiName, StableCrateIdCollision, SymbolConflictsCurrent, SymbolConflictsOthers,\n };\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n@@ -240,7 +239,6 @@ use rustc_target::spec::{Target, TargetTriple};\n \n use snap::read::FrameDecoder;\n use std::borrow::Cow;\n-use std::fmt::Write as _;\n use std::io::{Read, Result as IoResult, Write};\n use std::path::{Path, PathBuf};\n use std::{cmp, fmt, fs};\n@@ -482,7 +480,22 @@ impl<'a> CrateLocator<'a> {\n         match libraries.len() {\n             0 => Ok(None),\n             1 => Ok(Some(libraries.into_iter().next().unwrap().1)),\n-            _ => Err(CrateError::MultipleMatchingCrates(self.crate_name, libraries)),\n+            _ => {\n+                let mut libraries: Vec<_> = libraries.into_values().collect();\n+\n+                libraries.sort_by_cached_key(|lib| lib.source.paths().next().unwrap().clone());\n+                let candidates = libraries\n+                    .iter()\n+                    .map(|lib| lib.source.paths().next().unwrap().clone())\n+                    .collect::<Vec<_>>();\n+\n+                Err(CrateError::MultipleCandidates(\n+                    self.crate_name,\n+                    // these are the same for all candidates\n+                    get_flavor_from_path(candidates.first().unwrap()),\n+                    candidates,\n+                ))\n+            }\n         }\n     }\n \n@@ -882,17 +895,22 @@ pub fn list_file_metadata(\n     metadata_loader: &dyn MetadataLoader,\n     out: &mut dyn Write,\n ) -> IoResult<()> {\n+    let flavor = get_flavor_from_path(path);\n+    match get_metadata_section(target, flavor, path, metadata_loader) {\n+        Ok(metadata) => metadata.list_crate_metadata(out),\n+        Err(msg) => write!(out, \"{}\\n\", msg),\n+    }\n+}\n+\n+fn get_flavor_from_path(path: &Path) -> CrateFlavor {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n-    let flavor = if filename.ends_with(\".rlib\") {\n+\n+    if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n     } else if filename.ends_with(\".rmeta\") {\n         CrateFlavor::Rmeta\n     } else {\n         CrateFlavor::Dylib\n-    };\n-    match get_metadata_section(target, flavor, path, metadata_loader) {\n-        Ok(metadata) => metadata.list_crate_metadata(out),\n-        Err(msg) => write!(out, \"{}\\n\", msg),\n     }\n }\n \n@@ -931,7 +949,6 @@ pub(crate) enum CrateError {\n     ExternLocationNotExist(Symbol, PathBuf),\n     ExternLocationNotFile(Symbol, PathBuf),\n     MultipleCandidates(Symbol, CrateFlavor, Vec<PathBuf>),\n-    MultipleMatchingCrates(Symbol, FxHashMap<Svh, Library>),\n     SymbolConflictsCurrent(Symbol),\n     SymbolConflictsOthers(Symbol),\n     StableCrateIdCollision(Symbol, Symbol),\n@@ -972,37 +989,7 @@ impl CrateError {\n                 sess.emit_err(ExternLocationNotFile { span, crate_name, location: &loc });\n             }\n             CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n-                sess.emit_err(MultipleCandidates { span, flavor: flavor, crate_name, candidates });\n-            }\n-            CrateError::MultipleMatchingCrates(crate_name, libraries) => {\n-                let mut libraries: Vec<_> = libraries.into_values().collect();\n-                // Make ordering of candidates deterministic.\n-                // This has to `clone()` to work around lifetime restrictions with `sort_by_key()`.\n-                // `sort_by()` could be used instead, but this is in the error path,\n-                // so the performance shouldn't matter.\n-                libraries.sort_by_cached_key(|lib| lib.source.paths().next().unwrap().clone());\n-                let candidates = libraries\n-                    .iter()\n-                    .map(|lib| {\n-                        let crate_name = lib.metadata.get_root().name();\n-                        let crate_name = crate_name.as_str();\n-                        let mut paths = lib.source.paths();\n-\n-                        // This `unwrap()` should be okay because there has to be at least one\n-                        // source file. `CrateSource`'s docs confirm that too.\n-                        let mut s = format!(\n-                            \"\\ncrate `{}`: {}\",\n-                            crate_name,\n-                            paths.next().unwrap().display()\n-                        );\n-                        let padding = 8 + crate_name.len();\n-                        for path in paths {\n-                            write!(s, \"\\n{:>padding$}\", path.display(), padding = padding).unwrap();\n-                        }\n-                        s\n-                    })\n-                    .collect::<String>();\n-                sess.emit_err(MultipleMatchingCrates { span, crate_name, candidates });\n+                sess.emit_err(MultipleCandidates { span, crate_name, flavor, candidates });\n             }\n             CrateError::SymbolConflictsCurrent(root_name) => {\n                 sess.emit_err(SymbolConflictsCurrent { span, crate_name: root_name });"}, {"sha": "e167bbf57e62253b97551159e99fb7c4f515716f", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -223,7 +223,7 @@ provide! { tcx, def_id, other, cdata,\n     generator_kind => { table }\n     trait_def => { table }\n     deduced_param_attrs => { table }\n-    collect_trait_impl_trait_tys => {\n+    collect_return_position_impl_trait_in_trait_tys => {\n         Ok(cdata\n             .root\n             .tables"}, {"sha": "214a5842233bb19101e89c4462393845f02b43ce", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -76,7 +76,7 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     symbol_table: FxHashMap<Symbol, usize>,\n }\n \n-/// If the current crate is a proc-macro, returns early with `Lazy:empty()`.\n+/// If the current crate is a proc-macro, returns early with `LazyArray::empty()`.\n /// This is useful for skipping the encoding of things that aren't needed\n /// for proc-macro crates.\n macro_rules! empty_proc_macro {\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let computed_total_bytes: usize = stats.iter().map(|(_, size)| size).sum();\n         assert_eq!(total_bytes, computed_total_bytes);\n \n-        if tcx.sess.meta_stats() {\n+        if tcx.sess.opts.unstable_opts.meta_stats {\n             self.opaque.flush();\n \n             // Rewind and re-read all the metadata to count the zero bytes we wrote.\n@@ -1197,7 +1197,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n             }\n             if should_encode_trait_impl_trait_tys(tcx, def_id)\n-                && let Ok(table) = self.tcx.collect_trait_impl_trait_tys(def_id)\n+                && let Ok(table) = self.tcx.collect_return_position_impl_trait_in_trait_tys(def_id)\n             {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n@@ -1564,7 +1564,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-                    if let Some(mut an) = trait_def.ancestors(self.tcx, def_id).ok() {\n+                    if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n                         if let Some(specialization_graph::Node::Impl(parent)) = an.nth(1) {\n                             self.tables.impl_parent.set(def_id.index, parent.into());\n                         }"}, {"sha": "d799d3a5ad7799cb9f12656376b8185d448a39fa", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -704,12 +704,10 @@ impl<'hir> Map<'hir> {\n     pub fn get_return_block(self, id: HirId) -> Option<HirId> {\n         let mut iter = self.parent_iter(id).peekable();\n         let mut ignore_tail = false;\n-        if let Some(node) = self.find(id) {\n-            if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = node {\n-                // When dealing with `return` statements, we don't care about climbing only tail\n-                // expressions.\n-                ignore_tail = true;\n-            }\n+        if let Some(Node::Expr(Expr { kind: ExprKind::Ret(_), .. })) = self.find(id) {\n+            // When dealing with `return` statements, we don't care about climbing only tail\n+            // expressions.\n+            ignore_tail = true;\n         }\n         while let Some((hir_id, node)) = iter.next() {\n             if let (Some((_, next_node)), false) = (iter.peek(), ignore_tail) {\n@@ -1162,7 +1160,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n         hir_body_hash.hash_stable(&mut hcx, &mut stable_hasher);\n         upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n         source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n-        if tcx.sess.opts.unstable_opts.incremental_relative_spans {\n+        if tcx.sess.opts.incremental_relative_spans() {\n             let definitions = tcx.definitions_untracked();\n             let mut owner_spans: Vec<_> = krate\n                 .owners"}, {"sha": "a633201e3d9ae82091808f6684ebee834eb5434a", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -160,9 +160,13 @@ pub fn provide(providers: &mut Providers) {\n         } else if let Node::TraitItem(&TraitItem {\n             kind: TraitItemKind::Fn(_, TraitFn::Required(idents)),\n             ..\n+        })\n+        | Node::ForeignItem(&ForeignItem {\n+            kind: ForeignItemKind::Fn(_, idents, _),\n+            ..\n         }) = hir.get(hir_id)\n         {\n-            tcx.arena.alloc_slice(idents)\n+            idents\n         } else {\n             span_bug!(hir.span(hir_id), \"fn_arg_names: unexpected item {:?}\", id);\n         }"}, {"sha": "a89e6566d56affcb6dfeddb285a18e373bf3c663", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2894,7 +2894,7 @@ fn pretty_print_const_value<'tcx>(\n                 if let Some(contents) = tcx.try_destructure_mir_constant(\n                     ty::ParamEnv::reveal_all().and(ConstantKind::Val(ct, ty)),\n                 ) {\n-                    let fields = contents.fields.iter().copied().collect::<Vec<_>>();\n+                    let fields = contents.fields.to_vec();\n                     match *ty.kind() {\n                         ty::Array(..) => {\n                             fmt.write_str(\"[\")?;"}, {"sha": "438f36373ca91b0682484f1052eefd7ad1aa889a", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,4 +1,4 @@\n-use smallvec::{smallvec, SmallVec};\n+use smallvec::SmallVec;\n \n use super::{BasicBlock, InlineAsmOperand, Operand, SourceInfo, TerminatorKind};\n use rustc_ast::InlineAsmTemplatePiece;"}, {"sha": "37db2274f678fa0ab42f94847d6f43fed9155f91", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -169,7 +169,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query collect_trait_impl_trait_tys(key: DefId)\n+    query collect_return_position_impl_trait_in_trait_tys(key: DefId)\n         -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>\n     {\n         desc { \"comparing an impl and trait method signature, inferring any hidden `impl Trait` types in the process\" }\n@@ -2117,7 +2117,7 @@ rustc_queries! {\n         desc { \"checking to see if `{}` permits being left zeroed\", key.ty }\n     }\n \n-    query compare_assoc_const_impl_item_with_trait_item(\n+    query compare_impl_const(\n         key: (LocalDefId, DefId)\n     ) -> Result<(), ErrorGuaranteed> {\n         desc { |tcx| \"checking assoc const `{}` has the same type as trait item\", tcx.def_path_str(key.0.to_def_id()) }"}, {"sha": "cc53659f827986d7ff4b7a72163730bcb8a5f5eb", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -641,11 +641,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty::EarlyBinder(self.type_of(def_id))\n     }\n \n-    pub fn bound_trait_impl_trait_tys(\n+    pub fn bound_return_position_impl_trait_in_trait_tys(\n         self,\n         def_id: DefId,\n     ) -> ty::EarlyBinder<Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>> {\n-        ty::EarlyBinder(self.collect_trait_impl_trait_tys(def_id))\n+        ty::EarlyBinder(self.collect_return_position_impl_trait_in_trait_tys(def_id))\n     }\n \n     pub fn bound_fn_sig(self, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'tcx>> {"}, {"sha": "708a5e4d059e8acdab8166081f1c6c4d54fee151", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -4,7 +4,7 @@\n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, Ty};\n use rustc_data_structures::sso::SsoHashSet;\n-use smallvec::{self, SmallVec};\n+use smallvec::SmallVec;\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n // avoid heap allocations."}, {"sha": "4219e6280ebbca481424a6b7ee3bbef6ed25d41c", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,6 +1,7 @@\n //! Inlining pass for MIR functions\n use crate::deref_separator::deref_finder;\n use rustc_attr::InlineAttr;\n+use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -27,6 +28,8 @@ const RESUME_PENALTY: usize = 45;\n \n const UNKNOWN_SIZE_COST: usize = 10;\n \n+const TOP_DOWN_DEPTH_LIMIT: usize = 5;\n+\n pub struct Inline;\n \n #[derive(Copy, Clone, Debug)]\n@@ -86,8 +89,13 @@ fn inline<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) -> bool {\n \n     let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n-    let mut this =\n-        Inliner { tcx, param_env, codegen_fn_attrs: tcx.codegen_fn_attrs(def_id), changed: false };\n+    let mut this = Inliner {\n+        tcx,\n+        param_env,\n+        codegen_fn_attrs: tcx.codegen_fn_attrs(def_id),\n+        history: Vec::new(),\n+        changed: false,\n+    };\n     let blocks = BasicBlock::new(0)..body.basic_blocks.next_index();\n     this.process_blocks(body, blocks);\n     this.changed\n@@ -98,12 +106,26 @@ struct Inliner<'tcx> {\n     param_env: ParamEnv<'tcx>,\n     /// Caller codegen attributes.\n     codegen_fn_attrs: &'tcx CodegenFnAttrs,\n+    /// Stack of inlined instances.\n+    /// We only check the `DefId` and not the substs because we want to\n+    /// avoid inlining cases of polymorphic recursion.\n+    /// The number of `DefId`s is finite, so checking history is enough\n+    /// to ensure that we do not loop endlessly while inlining.\n+    history: Vec<DefId>,\n     /// Indicates that the caller body has been modified.\n     changed: bool,\n }\n \n impl<'tcx> Inliner<'tcx> {\n     fn process_blocks(&mut self, caller_body: &mut Body<'tcx>, blocks: Range<BasicBlock>) {\n+        // How many callsites in this body are we allowed to inline? We need to limit this in order\n+        // to prevent super-linear growth in MIR size\n+        let inline_limit = match self.history.len() {\n+            0 => usize::MAX,\n+            1..=TOP_DOWN_DEPTH_LIMIT => 1,\n+            _ => return,\n+        };\n+        let mut inlined_count = 0;\n         for bb in blocks {\n             let bb_data = &caller_body[bb];\n             if bb_data.is_cleanup {\n@@ -122,12 +144,16 @@ impl<'tcx> Inliner<'tcx> {\n                     debug!(\"not-inlined {} [{}]\", callsite.callee, reason);\n                     continue;\n                 }\n-                Ok(_) => {\n+                Ok(new_blocks) => {\n                     debug!(\"inlined {}\", callsite.callee);\n                     self.changed = true;\n-                    // We could process the blocks returned by `try_inlining` here. However, that\n-                    // leads to exponential compile times due to the top-down nature of this kind\n-                    // of inlining.\n+                    inlined_count += 1;\n+                    if inlined_count == inline_limit {\n+                        return;\n+                    }\n+                    self.history.push(callsite.callee.def_id());\n+                    self.process_blocks(caller_body, new_blocks);\n+                    self.history.pop();\n                 }\n             }\n         }\n@@ -289,7 +315,7 @@ impl<'tcx> Inliner<'tcx> {\n     ) -> Option<CallSite<'tcx>> {\n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n-        if let TerminatorKind::Call { ref func, target, .. } = terminator.kind {\n+        if let TerminatorKind::Call { ref func, target, fn_span, .. } = terminator.kind {\n             let func_ty = func.ty(caller_body, self.tcx);\n             if let ty::FnDef(def_id, substs) = *func_ty.kind() {\n                 // To resolve an instance its substs have to be fully normalized.\n@@ -301,15 +327,14 @@ impl<'tcx> Inliner<'tcx> {\n                     return None;\n                 }\n \n+                if self.history.contains(&callee.def_id()) {\n+                    return None;\n+                }\n+\n                 let fn_sig = self.tcx.bound_fn_sig(def_id).subst(self.tcx, substs);\n+                let source_info = SourceInfo { span: fn_span, ..terminator.source_info };\n \n-                return Some(CallSite {\n-                    callee,\n-                    fn_sig,\n-                    block: bb,\n-                    target,\n-                    source_info: terminator.source_info,\n-                });\n+                return Some(CallSite { callee, fn_sig, block: bb, target, source_info });\n             }\n         }\n "}, {"sha": "59cc500a99da7267f91fa56cadd0fb131246f2eb", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -843,7 +843,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::TerminatorKind::Abort { .. } => {\n                 let instance = Instance::mono(\n                     tcx,\n-                    tcx.require_lang_item(LangItem::PanicNoUnwind, Some(source)),\n+                    tcx.require_lang_item(LangItem::PanicCannotUnwind, Some(source)),\n                 );\n                 if should_codegen_locally(tcx, &instance) {\n                     self.output.push(create_fn_mono_item(tcx, instance, source));"}, {"sha": "4f25fc71314ea1ae738d29bc4ceff7bc61695c2a", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -305,7 +305,7 @@ where\n                 );\n             }\n \n-            let _ = writeln!(s, \"\");\n+            let _ = writeln!(s);\n         }\n \n         std::mem::take(s)"}, {"sha": "574591529f33194f240067c2a420ba18923b7223", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1229,3 +1229,11 @@ pub(crate) struct FnTypoWithImpl {\n     #[suggestion(applicability = \"maybe-incorrect\", code = \"impl\", style = \"verbose\")]\n     pub fn_span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_fn_path_found_fn_keyword)]\n+pub(crate) struct ExpectedFnPathFoundFnKeyword {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"Fn\", style = \"verbose\")]\n+    pub fn_token_span: Span,\n+}"}, {"sha": "b3231f55bc6e64375960c8e09b56b2ebccb19587", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -31,7 +31,8 @@ use rustc_ast::{\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n-    fluent, Applicability, DiagnosticBuilder, DiagnosticMessage, Handler, MultiSpan, PResult,\n+    fluent, Applicability, DiagnosticBuilder, DiagnosticMessage, FatalError, Handler, MultiSpan,\n+    PResult,\n };\n use rustc_errors::{pluralize, Diagnostic, ErrorGuaranteed, IntoDiagnostic};\n use rustc_session::errors::ExprParenthesesNeeded;\n@@ -41,7 +42,6 @@ use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n use std::mem::take;\n use std::ops::{Deref, DerefMut};\n use thin_vec::{thin_vec, ThinVec};\n-use tracing::{debug, trace};\n \n /// Creates a placeholder argument.\n pub(super) fn dummy_arg(ident: Ident) -> Param {\n@@ -1230,7 +1230,7 @@ impl<'a> Parser<'a> {\n         let sum_span = ty.span.to(self.prev_token.span);\n \n         let sub = match &ty.kind {\n-            TyKind::Rptr(lifetime, mut_ty) => {\n+            TyKind::Ref(lifetime, mut_ty) => {\n                 let sum_with_parens = pprust::to_string(|s| {\n                     s.s.word(\"&\");\n                     s.print_opt_lifetime(lifetime);\n@@ -2557,6 +2557,75 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n+    pub fn is_diff_marker(&mut self, long_kind: &TokenKind, short_kind: &TokenKind) -> bool {\n+        (0..3).all(|i| self.look_ahead(i, |tok| tok == long_kind))\n+            && self.look_ahead(3, |tok| tok == short_kind)\n+    }\n+\n+    fn diff_marker(&mut self, long_kind: &TokenKind, short_kind: &TokenKind) -> Option<Span> {\n+        if self.is_diff_marker(long_kind, short_kind) {\n+            let lo = self.token.span;\n+            for _ in 0..4 {\n+                self.bump();\n+            }\n+            return Some(lo.to(self.prev_token.span));\n+        }\n+        None\n+    }\n+\n+    pub fn recover_diff_marker(&mut self) {\n+        let Some(start) = self.diff_marker(&TokenKind::BinOp(token::Shl), &TokenKind::Lt) else {\n+            return;\n+        };\n+        let mut spans = Vec::with_capacity(3);\n+        spans.push(start);\n+        let mut middlediff3 = None;\n+        let mut middle = None;\n+        let mut end = None;\n+        loop {\n+            if self.token.kind == TokenKind::Eof {\n+                break;\n+            }\n+            if let Some(span) = self.diff_marker(&TokenKind::OrOr, &TokenKind::BinOp(token::Or)) {\n+                middlediff3 = Some(span);\n+            }\n+            if let Some(span) = self.diff_marker(&TokenKind::EqEq, &TokenKind::Eq) {\n+                middle = Some(span);\n+            }\n+            if let Some(span) = self.diff_marker(&TokenKind::BinOp(token::Shr), &TokenKind::Gt) {\n+                spans.push(span);\n+                end = Some(span);\n+                break;\n+            }\n+            self.bump();\n+        }\n+        let mut err = self.struct_span_err(spans, \"encountered diff marker\");\n+        err.span_label(start, \"after this is the code before the merge\");\n+        if let Some(middle) = middlediff3 {\n+            err.span_label(middle, \"\");\n+        }\n+        if let Some(middle) = middle {\n+            err.span_label(middle, \"\");\n+        }\n+        if let Some(end) = end {\n+            err.span_label(end, \"above this are the incoming code changes\");\n+        }\n+        err.help(\n+            \"if you're having merge conflicts after pulling new code, the top section is the code \\\n+             you already had and the bottom section is the remote code\",\n+        );\n+        err.help(\n+            \"if you're in the middle of a rebase, the top section is the code being rebased onto \\\n+             and the bottom section is the code coming from the current commit being rebased\",\n+        );\n+        err.note(\n+            \"for an explanation on these markers from the `git` documentation, visit \\\n+             <https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging#_checking_out_conflicts>\",\n+        );\n+        err.emit();\n+        FatalError.raise()\n+    }\n+\n     /// Parse and throw away a parenthesized comma separated\n     /// sequence of patterns until `)` is reached.\n     fn skip_pat_list(&mut self) -> PResult<'a, ()> {"}, {"sha": "1fc1ffd6cb6ed39e70463a7743fc48d8c9fabecd", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -182,7 +182,7 @@ impl<'a> Parser<'a> {\n                 LhsExpr::AttributesParsed(attrs) => Some(attrs),\n                 _ => None,\n             };\n-            if [token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token.kind) {\n+            if self.token.is_range_separator() {\n                 return self.parse_prefix_range_expr(attrs);\n             } else {\n                 self.parse_prefix_expr(attrs)?\n@@ -514,7 +514,7 @@ impl<'a> Parser<'a> {\n         }\n \n         debug_assert!(\n-            [token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token.kind),\n+            self.token.is_range_separator(),\n             \"parse_prefix_range_expr: token {:?} is not DotDot/DotDotEq\",\n             self.token\n         );\n@@ -899,7 +899,11 @@ impl<'a> Parser<'a> {\n         let has_lifetime = self.token.is_lifetime() && self.look_ahead(1, |t| t != &token::Colon);\n         let lifetime = has_lifetime.then(|| self.expect_lifetime()); // For recovery, see below.\n         let (borrow_kind, mutbl) = self.parse_borrow_modifiers(lo);\n-        let expr = self.parse_prefix_expr(None);\n+        let expr = if self.token.is_range_separator() {\n+            self.parse_prefix_range_expr(None)\n+        } else {\n+            self.parse_prefix_expr(None)\n+        };\n         let (hi, expr) = self.interpolated_or_expr_span(expr)?;\n         let span = lo.to(hi);\n         if let Some(lt) = lifetime {\n@@ -3035,6 +3039,7 @@ impl<'a> Parser<'a> {\n     /// Parses `ident (COLON expr)?`.\n     fn parse_expr_field(&mut self) -> PResult<'a, ExprField> {\n         let attrs = self.parse_outer_attributes()?;\n+        self.recover_diff_marker();\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             let lo = this.token.span;\n "}, {"sha": "a958c294930ef4094c2299b080f6bba921b23f30", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -24,7 +24,6 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n use std::mem;\n use thin_vec::ThinVec;\n-use tracing::debug;\n \n impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main entry point for the parser.\n@@ -99,7 +98,9 @@ impl<'a> Parser<'a> {\n         fn_parse_mode: FnParseMode,\n         force_collect: ForceCollect,\n     ) -> PResult<'a, Option<Item>> {\n+        self.recover_diff_marker();\n         let attrs = self.parse_outer_attributes()?;\n+        self.recover_diff_marker();\n         self.parse_item_common(attrs, true, false, fn_parse_mode, force_collect)\n     }\n \n@@ -705,6 +706,7 @@ impl<'a> Parser<'a> {\n             if self.recover_doc_comment_before_brace() {\n                 continue;\n             }\n+            self.recover_diff_marker();\n             match parse_item(self) {\n                 Ok(None) => {\n                     let mut is_unnecessary_semicolon = !items.is_empty()\n@@ -1040,8 +1042,11 @@ impl<'a> Parser<'a> {\n     /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n     /// ```\n     fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n-        self.parse_delim_comma_seq(Delimiter::Brace, |p| Ok((p.parse_use_tree()?, DUMMY_NODE_ID)))\n-            .map(|(r, _)| r)\n+        self.parse_delim_comma_seq(Delimiter::Brace, |p| {\n+            p.recover_diff_marker();\n+            Ok((p.parse_use_tree()?, DUMMY_NODE_ID))\n+        })\n+        .map(|(r, _)| r)\n     }\n \n     fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {\n@@ -1380,7 +1385,9 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_enum_variant(&mut self) -> PResult<'a, Option<Variant>> {\n+        self.recover_diff_marker();\n         let variant_attrs = self.parse_outer_attributes()?;\n+        self.recover_diff_marker();\n         self.collect_tokens_trailing_token(\n             variant_attrs,\n             ForceCollect::No,\n@@ -1574,9 +1581,32 @@ impl<'a> Parser<'a> {\n         self.parse_paren_comma_seq(|p| {\n             let attrs = p.parse_outer_attributes()?;\n             p.collect_tokens_trailing_token(attrs, ForceCollect::No, |p, attrs| {\n+                let mut snapshot = None;\n+                if p.is_diff_marker(&TokenKind::BinOp(token::Shl), &TokenKind::Lt) {\n+                    // Account for `<<<<<<<` diff markers. We can't proactively error here because\n+                    // that can be a valid type start, so we snapshot and reparse only we've\n+                    // encountered another parse error.\n+                    snapshot = Some(p.create_snapshot_for_diagnostic());\n+                }\n                 let lo = p.token.span;\n-                let vis = p.parse_visibility(FollowedByType::Yes)?;\n-                let ty = p.parse_ty()?;\n+                let vis = match p.parse_visibility(FollowedByType::Yes) {\n+                    Ok(vis) => vis,\n+                    Err(err) => {\n+                        if let Some(ref mut snapshot) = snapshot {\n+                            snapshot.recover_diff_marker();\n+                        }\n+                        return Err(err);\n+                    }\n+                };\n+                let ty = match p.parse_ty() {\n+                    Ok(ty) => ty,\n+                    Err(err) => {\n+                        if let Some(ref mut snapshot) = snapshot {\n+                            snapshot.recover_diff_marker();\n+                        }\n+                        return Err(err);\n+                    }\n+                };\n \n                 Ok((\n                     FieldDef {\n@@ -1597,7 +1627,9 @@ impl<'a> Parser<'a> {\n \n     /// Parses an element of a struct declaration.\n     fn parse_field_def(&mut self, adt_ty: &str) -> PResult<'a, FieldDef> {\n+        self.recover_diff_marker();\n         let attrs = self.parse_outer_attributes()?;\n+        self.recover_diff_marker();\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             let lo = this.token.span;\n             let vis = this.parse_visibility(FollowedByType::No)?;\n@@ -2424,10 +2456,11 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n-    fn parse_fn_params(&mut self, req_name: ReqName) -> PResult<'a, Vec<Param>> {\n+    pub(super) fn parse_fn_params(&mut self, req_name: ReqName) -> PResult<'a, Vec<Param>> {\n         let mut first_param = true;\n         // Parse the arguments, starting out with `self` being allowed...\n         let (mut params, _) = self.parse_paren_comma_seq(|p| {\n+            p.recover_diff_marker();\n             let param = p.parse_param_general(req_name, first_param).or_else(|mut e| {\n                 e.emit();\n                 let lo = p.prev_token.span;\n@@ -2465,7 +2498,6 @@ impl<'a> Parser<'a> {\n             };\n             let (pat, ty) = if is_name_required || this.is_named_param() {\n                 debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n-\n                 let (pat, colon) = this.parse_fn_param_pat_colon()?;\n                 if !colon {\n                     let mut err = this.unexpected::<()>().unwrap_err();"}, {"sha": "49d3198153953f226f326a211297bc8b54e33f0a", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -317,7 +317,7 @@ impl TokenCursor {\n         // required to wrap the text. E.g.\n         // - `abc d` is wrapped as `r\"abc d\"` (num_of_hashes = 0)\n         // - `abc \"d\"` is wrapped as `r#\"abc \"d\"\"#` (num_of_hashes = 1)\n-        // - `abc \"##d##\"` is wrapped as `r###\"abc \"d\"\"###` (num_of_hashes = 3)\n+        // - `abc \"##d##\"` is wrapped as `r###\"abc ##\"d\"##\"###` (num_of_hashes = 3)\n         let mut num_of_hashes = 0;\n         let mut count = 0;\n         for ch in data.as_str().chars() {\n@@ -1499,6 +1499,10 @@ impl<'a> Parser<'a> {\n     pub fn clear_expected_tokens(&mut self) {\n         self.expected_tokens.clear();\n     }\n+\n+    pub fn approx_token_stream_pos(&self) -> usize {\n+        self.token_cursor.num_next_calls\n+    }\n }\n \n pub(crate) fn make_unclosed_delims_error("}, {"sha": "0b057f2f577fe73e85489bf75063576cdf3c5d72", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -491,17 +491,6 @@ impl<'a> Parser<'a> {\n \n         if let PatKind::Ident(_, _, sub @ None) = &mut rhs.kind {\n             // The user inverted the order, so help them fix that.\n-            let mut applicability = Applicability::MachineApplicable;\n-            // FIXME(bindings_after_at): Remove this code when stabilizing the feature.\n-            lhs.walk(&mut |p| match p.kind {\n-                // `check_match` is unhappy if the subpattern has a binding anywhere.\n-                PatKind::Ident(..) => {\n-                    applicability = Applicability::MaybeIncorrect;\n-                    false // Short-circuit.\n-                }\n-                _ => true,\n-            });\n-\n             let lhs_span = lhs.span;\n             // Move the LHS into the RHS as a subpattern.\n             // The RHS is now the full pattern.\n@@ -510,7 +499,12 @@ impl<'a> Parser<'a> {\n             self.struct_span_err(sp, \"pattern on wrong side of `@`\")\n                 .span_label(lhs_span, \"pattern on the left, should be on the right\")\n                 .span_label(rhs.span, \"binding on the right, should be on the left\")\n-                .span_suggestion(sp, \"switch the order\", pprust::pat_to_string(&rhs), applicability)\n+                .span_suggestion(\n+                    sp,\n+                    \"switch the order\",\n+                    pprust::pat_to_string(&rhs),\n+                    Applicability::MachineApplicable,\n+                )\n                 .emit();\n         } else {\n             // The special case above doesn't apply so we may have e.g. `A(x) @ B(y)`."}, {"sha": "0daae457d30224caee7db8d154d93c01537c167e", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -531,13 +531,23 @@ impl<'a> Parser<'a> {\n         recover: AttemptLocalParseRecovery,\n     ) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n+        let mut snapshot = None;\n         while !self.eat(&token::CloseDelim(Delimiter::Brace)) {\n             if self.token == token::Eof {\n                 break;\n             }\n+            if self.is_diff_marker(&TokenKind::BinOp(token::Shl), &TokenKind::Lt) {\n+                // Account for `<<<<<<<` diff markers. We can't proactively error here because\n+                // that can be a valid path start, so we snapshot and reparse only we've\n+                // encountered another parse error.\n+                snapshot = Some(self.create_snapshot_for_diagnostic());\n+            }\n             let stmt = match self.parse_full_stmt(recover) {\n                 Err(mut err) if recover.yes() => {\n                     self.maybe_annotate_with_ascription(&mut err, false);\n+                    if let Some(ref mut snapshot) = snapshot {\n+                        snapshot.recover_diff_marker();\n+                    }\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n                     Some(self.mk_stmt_err(self.token.span))"}, {"sha": "a6f702e5428694aa4077eeae5363c905674c030e", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 157, "deletions": 5, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,8 +1,9 @@\n use super::{Parser, PathStyle, TokenType};\n \n-use crate::errors::{FnPtrWithGenerics, FnPtrWithGenericsSugg};\n+use crate::errors::{ExpectedFnPathFoundFnKeyword, FnPtrWithGenerics, FnPtrWithGenericsSugg};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n+use ast::DUMMY_NODE_ID;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::util::case::Case;\n@@ -12,7 +13,9 @@ use rustc_ast::{\n };\n use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::Symbol;\n+use thin_vec::thin_vec;\n \n /// Any `?` or `~const` modifiers that appear at the start of a bound.\n struct BoundModifiers {\n@@ -501,7 +504,7 @@ impl<'a> Parser<'a> {\n             self.bump_with((dyn_tok, dyn_tok_sp));\n         }\n         let ty = self.parse_ty_no_plus()?;\n-        Ok(TyKind::Rptr(opt_lifetime, MutTy { ty, mutbl }))\n+        Ok(TyKind::Ref(opt_lifetime, MutTy { ty, mutbl }))\n     }\n \n     // Parses the `typeof(EXPR)`.\n@@ -613,6 +616,25 @@ impl<'a> Parser<'a> {\n     /// Parses an `impl B0 + ... + Bn` type.\n     fn parse_impl_ty(&mut self, impl_dyn_multi: &mut bool) -> PResult<'a, TyKind> {\n         // Always parse bounds greedily for better error recovery.\n+        if self.token.is_lifetime() {\n+            self.look_ahead(1, |t| {\n+                if let token::Ident(symname, _) = t.kind {\n+                    // parse pattern with \"'a Sized\" we're supposed to give suggestion like\n+                    // \"'a + Sized\"\n+                    self.struct_span_err(\n+                        self.token.span,\n+                        &format!(\"expected `+` between lifetime and {}\", symname),\n+                    )\n+                    .span_suggestion_verbose(\n+                        self.token.span.shrink_to_hi(),\n+                        \"add `+`\",\n+                        \" +\",\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n+                }\n+            })\n+        }\n         let bounds = self.parse_generic_bounds(None)?;\n         *impl_dyn_multi = bounds.len() > 1 || self.prev_token.kind == TokenKind::BinOp(token::Plus);\n         Ok(TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds))\n@@ -911,8 +933,20 @@ impl<'a> Parser<'a> {\n         has_parens: bool,\n         modifiers: BoundModifiers,\n     ) -> PResult<'a, GenericBound> {\n-        let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-        let path = self.parse_path(PathStyle::Type)?;\n+        let mut lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+        let mut path = if self.token.is_keyword(kw::Fn)\n+            && self.look_ahead(1, |tok| tok.kind == TokenKind::OpenDelim(Delimiter::Parenthesis))\n+            && let Some(path) = self.recover_path_from_fn()\n+        {\n+            path\n+        } else {\n+            self.parse_path(PathStyle::Type)?\n+        };\n+\n+        if self.may_recover() && self.token == TokenKind::OpenDelim(Delimiter::Parenthesis) {\n+            self.recover_fn_trait_with_lifetime_params(&mut path, &mut lifetime_defs)?;\n+        }\n+\n         if has_parens {\n             if self.token.is_like_plus() {\n                 // Someone has written something like `&dyn (Trait + Other)`. The correct code\n@@ -941,6 +975,38 @@ impl<'a> Parser<'a> {\n         Ok(GenericBound::Trait(poly_trait, modifier))\n     }\n \n+    // recovers a `Fn(..)` parenthesized-style path from `fn(..)`\n+    fn recover_path_from_fn(&mut self) -> Option<ast::Path> {\n+        let fn_token_span = self.token.span;\n+        self.bump();\n+        let args_lo = self.token.span;\n+        let snapshot = self.create_snapshot_for_diagnostic();\n+        match self.parse_fn_decl(|_| false, AllowPlus::No, RecoverReturnSign::OnlyFatArrow) {\n+            Ok(decl) => {\n+                self.sess.emit_err(ExpectedFnPathFoundFnKeyword { fn_token_span });\n+                Some(ast::Path {\n+                    span: fn_token_span.to(self.prev_token.span),\n+                    segments: thin_vec![ast::PathSegment {\n+                        ident: Ident::new(Symbol::intern(\"Fn\"), fn_token_span),\n+                        id: DUMMY_NODE_ID,\n+                        args: Some(P(ast::GenericArgs::Parenthesized(ast::ParenthesizedArgs {\n+                            span: args_lo.to(self.prev_token.span),\n+                            inputs: decl.inputs.iter().map(|a| a.ty.clone()).collect(),\n+                            inputs_span: args_lo.until(decl.output.span()),\n+                            output: decl.output.clone(),\n+                        }))),\n+                    }],\n+                    tokens: None,\n+                })\n+            }\n+            Err(diag) => {\n+                diag.cancel();\n+                self.restore_snapshot(snapshot);\n+                None\n+            }\n+        }\n+    }\n+\n     /// Optionally parses `for<$generic_params>`.\n     pub(super) fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n         if self.eat_keyword(kw::For) {\n@@ -955,6 +1021,92 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Recover from `Fn`-family traits (Fn, FnMut, FnOnce) with lifetime arguments\n+    /// (e.g. `FnOnce<'a>(&'a str) -> bool`). Up to generic arguments have already\n+    /// been eaten.\n+    fn recover_fn_trait_with_lifetime_params(\n+        &mut self,\n+        fn_path: &mut ast::Path,\n+        lifetime_defs: &mut Vec<GenericParam>,\n+    ) -> PResult<'a, ()> {\n+        let fn_path_segment = fn_path.segments.last_mut().unwrap();\n+        let generic_args = if let Some(p_args) = &fn_path_segment.args {\n+            p_args.clone().into_inner()\n+        } else {\n+            // Normally it wouldn't come here because the upstream should have parsed\n+            // generic parameters (otherwise it's impossible to call this function).\n+            return Ok(());\n+        };\n+        let lifetimes =\n+            if let ast::GenericArgs::AngleBracketed(ast::AngleBracketedArgs { span: _, args }) =\n+                &generic_args\n+            {\n+                args.into_iter()\n+                    .filter_map(|arg| {\n+                        if let ast::AngleBracketedArg::Arg(generic_arg) = arg\n+                            && let ast::GenericArg::Lifetime(lifetime) = generic_arg {\n+                            Some(lifetime)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .collect()\n+            } else {\n+                Vec::new()\n+            };\n+        // Only try to recover if the trait has lifetime params.\n+        if lifetimes.is_empty() {\n+            return Ok(());\n+        }\n+\n+        // Parse `(T, U) -> R`.\n+        let inputs_lo = self.token.span;\n+        let inputs: Vec<_> =\n+            self.parse_fn_params(|_| false)?.into_iter().map(|input| input.ty).collect();\n+        let inputs_span = inputs_lo.to(self.prev_token.span);\n+        let output = self.parse_ret_ty(AllowPlus::No, RecoverQPath::No, RecoverReturnSign::No)?;\n+        let args = ast::ParenthesizedArgs {\n+            span: fn_path_segment.span().to(self.prev_token.span),\n+            inputs,\n+            inputs_span,\n+            output,\n+        }\n+        .into();\n+        *fn_path_segment =\n+            ast::PathSegment { ident: fn_path_segment.ident, args, id: ast::DUMMY_NODE_ID };\n+\n+        // Convert parsed `<'a>` in `Fn<'a>` into `for<'a>`.\n+        let mut generic_params = lifetimes\n+            .iter()\n+            .map(|lt| GenericParam {\n+                id: lt.id,\n+                ident: lt.ident,\n+                attrs: ast::AttrVec::new(),\n+                bounds: Vec::new(),\n+                is_placeholder: false,\n+                kind: ast::GenericParamKind::Lifetime,\n+                colon_span: None,\n+            })\n+            .collect::<Vec<GenericParam>>();\n+        lifetime_defs.append(&mut generic_params);\n+\n+        let generic_args_span = generic_args.span();\n+        let mut err =\n+            self.struct_span_err(generic_args_span, \"`Fn` traits cannot take lifetime parameters\");\n+        let snippet = format!(\n+            \"for<{}> \",\n+            lifetimes.iter().map(|lt| lt.ident.as_str()).intersperse(\", \").collect::<String>(),\n+        );\n+        let before_fn_path = fn_path.span.shrink_to_lo();\n+        err.multipart_suggestion(\n+            \"consider using a higher-ranked trait bound instead\",\n+            vec![(generic_args_span, \"\".to_owned()), (before_fn_path, snippet)],\n+            Applicability::MaybeIncorrect,\n+        )\n+        .emit();\n+        Ok(())\n+    }\n+\n     pub(super) fn check_lifetime(&mut self) -> bool {\n         self.expected_tokens.push(TokenType::Lifetime);\n         self.token.is_lifetime()"}, {"sha": "9f2aaca0acffeb51918141703183caf02e4f6e77", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 127, "deletions": 50, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -20,6 +20,7 @@ pub use Flag::*;\n pub use Piece::*;\n pub use Position::*;\n \n+use rustc_lexer::unescape;\n use std::iter;\n use std::str;\n use std::string;\n@@ -38,6 +39,31 @@ impl InnerSpan {\n     }\n }\n \n+/// The location and before/after width of a character whose width has changed from its source code\n+/// representation\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub struct InnerWidthMapping {\n+    /// Index of the character in the source\n+    pub position: usize,\n+    /// The inner width in characters\n+    pub before: usize,\n+    /// The transformed width in characters\n+    pub after: usize,\n+}\n+\n+impl InnerWidthMapping {\n+    pub fn new(position: usize, before: usize, after: usize) -> InnerWidthMapping {\n+        InnerWidthMapping { position, before, after }\n+    }\n+}\n+\n+/// Whether the input string is a literal. If yes, it contains the inner width mappings.\n+#[derive(Clone, PartialEq, Eq)]\n+enum InputStringKind {\n+    NotALiteral,\n+    Literal { width_mappings: Vec<InnerWidthMapping> },\n+}\n+\n /// The type of format string that we are parsing.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum ParseMode {\n@@ -200,8 +226,8 @@ pub struct Parser<'a> {\n     style: Option<usize>,\n     /// Start and end byte offset of every successfully parsed argument\n     pub arg_places: Vec<InnerSpan>,\n-    /// Characters that need to be shifted\n-    skips: Vec<usize>,\n+    /// Characters whose length has been changed from their in-code representation\n+    width_map: Vec<InnerWidthMapping>,\n     /// Span of the last opening brace seen, used for error reporting\n     last_opening_brace: Option<InnerSpan>,\n     /// Whether the source string is comes from `println!` as opposed to `format!` or `print!`\n@@ -224,7 +250,7 @@ impl<'a> Iterator for Parser<'a> {\n                 '{' => {\n                     let curr_last_brace = self.last_opening_brace;\n                     let byte_pos = self.to_span_index(pos);\n-                    let lbrace_end = self.to_span_index(pos + 1);\n+                    let lbrace_end = InnerOffset(byte_pos.0 + self.to_span_width(pos));\n                     self.last_opening_brace = Some(byte_pos.to(lbrace_end));\n                     self.cur.next();\n                     if self.consume('{') {\n@@ -233,12 +259,15 @@ impl<'a> Iterator for Parser<'a> {\n                         Some(String(self.string(pos + 1)))\n                     } else {\n                         let arg = self.argument(lbrace_end);\n-                        if let Some(rbrace_byte_idx) = self.must_consume('}') {\n-                            let lbrace_inner_offset = self.to_span_index(pos);\n-                            let rbrace_inner_offset = self.to_span_index(rbrace_byte_idx);\n+                        if let Some(rbrace_pos) = self.must_consume('}') {\n                             if self.is_literal {\n+                                let lbrace_byte_pos = self.to_span_index(pos);\n+                                let rbrace_byte_pos = self.to_span_index(rbrace_pos);\n+\n+                                let width = self.to_span_width(rbrace_pos);\n+\n                                 self.arg_places.push(\n-                                    lbrace_inner_offset.to(InnerOffset(rbrace_inner_offset.0 + 1)),\n+                                    lbrace_byte_pos.to(InnerOffset(rbrace_byte_pos.0 + width)),\n                                 );\n                             }\n                         } else {\n@@ -285,7 +314,11 @@ impl<'a> Parser<'a> {\n         append_newline: bool,\n         mode: ParseMode,\n     ) -> Parser<'a> {\n-        let (skips, is_literal) = find_skips_from_snippet(snippet, style);\n+        let input_string_kind = find_width_map_from_snippet(s, snippet, style);\n+        let (width_map, is_literal) = match input_string_kind {\n+            InputStringKind::Literal { width_mappings } => (width_mappings, true),\n+            InputStringKind::NotALiteral => (Vec::new(), false),\n+        };\n         Parser {\n             mode,\n             input: s,\n@@ -294,7 +327,7 @@ impl<'a> Parser<'a> {\n             curarg: 0,\n             style,\n             arg_places: vec![],\n-            skips,\n+            width_map,\n             last_opening_brace: None,\n             append_newline,\n             is_literal,\n@@ -367,21 +400,34 @@ impl<'a> Parser<'a> {\n         None\n     }\n \n+    fn remap_pos(&self, mut pos: usize) -> InnerOffset {\n+        for width in &self.width_map {\n+            if pos > width.position {\n+                pos += width.before - width.after;\n+            } else if pos == width.position && width.after == 0 {\n+                pos += width.before;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        InnerOffset(pos)\n+    }\n+\n     fn to_span_index(&self, pos: usize) -> InnerOffset {\n-        let mut pos = pos;\n         // This handles the raw string case, the raw argument is the number of #\n         // in r###\"...\"### (we need to add one because of the `r`).\n         let raw = self.style.map_or(0, |raw| raw + 1);\n-        for skip in &self.skips {\n-            if pos > *skip {\n-                pos += 1;\n-            } else if pos == *skip && raw == 0 {\n-                pos += 1;\n-            } else {\n-                break;\n-            }\n+        let pos = self.remap_pos(pos);\n+        InnerOffset(raw + pos.0 + 1)\n+    }\n+\n+    fn to_span_width(&self, pos: usize) -> usize {\n+        let pos = self.remap_pos(pos);\n+        match self.width_map.iter().find(|w| w.position == pos.0) {\n+            Some(w) => w.before,\n+            None => 1,\n         }\n-        InnerOffset(raw + pos + 1)\n     }\n \n     fn span(&self, start_pos: usize, end_pos: usize) -> InnerSpan {\n@@ -809,59 +855,75 @@ impl<'a> Parser<'a> {\n /// Finds the indices of all characters that have been processed and differ between the actual\n /// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n /// in order to properly synthesise the intra-string `Span`s for error diagnostics.\n-fn find_skips_from_snippet(\n+fn find_width_map_from_snippet(\n+    input: &str,\n     snippet: Option<string::String>,\n     str_style: Option<usize>,\n-) -> (Vec<usize>, bool) {\n+) -> InputStringKind {\n     let snippet = match snippet {\n         Some(ref s) if s.starts_with('\"') || s.starts_with(\"r\\\"\") || s.starts_with(\"r#\") => s,\n-        _ => return (vec![], false),\n+        _ => return InputStringKind::NotALiteral,\n     };\n \n     if str_style.is_some() {\n-        return (vec![], true);\n+        return InputStringKind::Literal { width_mappings: Vec::new() };\n     }\n \n+    // Strip quotes.\n     let snippet = &snippet[1..snippet.len() - 1];\n \n+    // Macros like `println` add a newline at the end. That technically doens't make them \"literals\" anymore, but it's fine\n+    // since we will never need to point our spans there, so we lie about it here by ignoring it.\n+    // Since there might actually be newlines in the source code, we need to normalize away all trailing newlines.\n+    // If we only trimmed it off the input, `format!(\"\\n\")` would cause a mismatch as here we they actually match up.\n+    // Alternatively, we could just count the trailing newlines and only trim one from the input if they don't match up.\n+    let input_no_nl = input.trim_end_matches('\\n');\n+    let Ok(unescaped) = unescape_string(snippet) else {\n+        return InputStringKind::NotALiteral;\n+    };\n+\n+    let unescaped_no_nl = unescaped.trim_end_matches('\\n');\n+\n+    if unescaped_no_nl != input_no_nl {\n+        // The source string that we're pointing at isn't our input, so spans pointing at it will be incorrect.\n+        // This can for example happen with proc macros that respan generated literals.\n+        return InputStringKind::NotALiteral;\n+    }\n+\n     let mut s = snippet.char_indices();\n-    let mut skips = vec![];\n+    let mut width_mappings = vec![];\n     while let Some((pos, c)) = s.next() {\n         match (c, s.clone().next()) {\n             // skip whitespace and empty lines ending in '\\\\'\n-            ('\\\\', Some((next_pos, '\\n'))) => {\n-                skips.push(pos);\n-                skips.push(next_pos);\n+            ('\\\\', Some((_, '\\n'))) => {\n                 let _ = s.next();\n+                let mut width = 2;\n \n-                while let Some((pos, c)) = s.clone().next() {\n+                while let Some((_, c)) = s.clone().next() {\n                     if matches!(c, ' ' | '\\n' | '\\t') {\n-                        skips.push(pos);\n+                        width += 1;\n                         let _ = s.next();\n                     } else {\n                         break;\n                     }\n                 }\n+\n+                width_mappings.push(InnerWidthMapping::new(pos, width, 0));\n             }\n-            ('\\\\', Some((next_pos, 'n' | 't' | 'r' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n-                skips.push(next_pos);\n+            ('\\\\', Some((_, 'n' | 't' | 'r' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n+                width_mappings.push(InnerWidthMapping::new(pos, 2, 1));\n                 let _ = s.next();\n             }\n             ('\\\\', Some((_, 'x'))) => {\n-                for _ in 0..3 {\n-                    // consume `\\xAB` literal\n-                    if let Some((pos, _)) = s.next() {\n-                        skips.push(pos);\n-                    } else {\n-                        break;\n-                    }\n-                }\n+                // consume `\\xAB` literal\n+                s.nth(2);\n+                width_mappings.push(InnerWidthMapping::new(pos, 4, 1));\n             }\n             ('\\\\', Some((_, 'u'))) => {\n-                if let Some((pos, _)) = s.next() {\n-                    skips.push(pos);\n-                }\n-                if let Some((next_pos, next_c)) = s.next() {\n+                let mut width = 2;\n+                let _ = s.next();\n+\n+                if let Some((_, next_c)) = s.next() {\n                     if next_c == '{' {\n                         // consume up to 6 hexanumeric chars\n                         let digits_len =\n@@ -881,31 +943,46 @@ fn find_skips_from_snippet(\n                         let required_skips = digits_len.saturating_sub(len_utf8.saturating_sub(1));\n \n                         // skip '{' and '}' also\n-                        for pos in (next_pos..).take(required_skips + 2) {\n-                            skips.push(pos)\n-                        }\n+                        width += required_skips + 2;\n \n                         s.nth(digits_len);\n                     } else if next_c.is_digit(16) {\n-                        skips.push(next_pos);\n+                        width += 1;\n+\n                         // We suggest adding `{` and `}` when appropriate, accept it here as if\n                         // it were correct\n                         let mut i = 0; // consume up to 6 hexanumeric chars\n-                        while let (Some((next_pos, c)), _) = (s.next(), i < 6) {\n+                        while let (Some((_, c)), _) = (s.next(), i < 6) {\n                             if c.is_digit(16) {\n-                                skips.push(next_pos);\n+                                width += 1;\n                             } else {\n                                 break;\n                             }\n                             i += 1;\n                         }\n                     }\n                 }\n+\n+                width_mappings.push(InnerWidthMapping::new(pos, width, 1));\n             }\n             _ => {}\n         }\n     }\n-    (skips, true)\n+\n+    InputStringKind::Literal { width_mappings }\n+}\n+\n+fn unescape_string(string: &str) -> Result<string::String, unescape::EscapeError> {\n+    let mut buf = string::String::new();\n+    let mut error = Ok(());\n+    unescape::unescape_literal(string, unescape::Mode::Str, &mut |_, unescaped_char| {\n+        match unescaped_char {\n+            Ok(c) => buf.push(c),\n+            Err(err) => error = Err(err),\n+        }\n+    });\n+\n+    error.map(|_| buf)\n }\n \n // Assert a reasonable size for `Piece`"}, {"sha": "c59c06ac31ed7ca11f82b8d649fd8e14f997c40b", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1090,9 +1090,7 @@ impl CheckAttrVisitor<'_> {\n                                     errors::DocTestUnknownInclude {\n                                         path,\n                                         value: value.to_string(),\n-                                        inner: (attr.style == AttrStyle::Inner)\n-                                            .then_some(\"!\")\n-                                            .unwrap_or(\"\"),\n+                                        inner: if attr.style == AttrStyle::Inner { \"!\" } else { \"\" },\n                                         sugg: (attr.meta().unwrap().span, applicability),\n                                     }\n                                 );"}, {"sha": "b86d2316820cec75ab3fa744079775fa22151d6c", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -324,7 +324,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n                 Slice,\n                 Array,\n                 Ptr,\n-                Rptr,\n+                Ref,\n                 BareFn,\n                 Never,\n                 Tup,\n@@ -580,7 +580,7 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n                 Slice,\n                 Array,\n                 Ptr,\n-                Rptr,\n+                Ref,\n                 BareFn,\n                 Never,\n                 Tup,"}, {"sha": "2d243e13cc21249a6679d1e298be44dce69c7024", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -34,7 +34,6 @@ use rustc_query_system::query::*;\n pub use rustc_query_system::query::{deadlock, QueryContext};\n \n pub use rustc_query_system::query::QueryConfig;\n-pub(crate) use rustc_query_system::query::QueryVTable;\n \n mod on_disk_cache;\n pub use on_disk_cache::OnDiskCache;"}, {"sha": "535445e70bc15c519afd3abd47164c09b010af63", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -493,28 +493,32 @@ macro_rules! define_queries {\n                 &tcx.query_caches.$name\n             }\n \n+            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Stored {\n+                tcx.$name(key)\n+            }\n+\n             #[inline]\n-            fn make_vtable(tcx: QueryCtxt<'tcx>, key: &Self::Key) ->\n-                QueryVTable<QueryCtxt<'tcx>, Self::Key, Self::Value>\n-            {\n-                let compute = get_provider!([$($modifiers)*][tcx, $name, key]);\n-                let cache_on_disk = Self::cache_on_disk(tcx.tcx, key);\n-                QueryVTable {\n-                    anon: is_anon!([$($modifiers)*]),\n-                    eval_always: is_eval_always!([$($modifiers)*]),\n-                    depth_limit: depth_limit!([$($modifiers)*]),\n-                    feedable: feedable!([$($modifiers)*]),\n-                    dep_kind: dep_graph::DepKind::$name,\n-                    hash_result: hash_result!([$($modifiers)*]),\n-                    handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n-                    compute,\n-                    try_load_from_disk: if cache_on_disk { should_ever_cache_on_disk!([$($modifiers)*]) } else { None },\n-                }\n+            // key is only sometimes used\n+            #[allow(unused_variables)]\n+            fn compute(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> fn(TyCtxt<'tcx>, Self::Key) -> Self::Value {\n+                get_provider!([$($modifiers)*][qcx, $name, key])\n             }\n \n-            fn execute_query(tcx: TyCtxt<'tcx>, k: Self::Key) -> Self::Stored {\n-                tcx.$name(k)\n+            #[inline]\n+            fn try_load_from_disk(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n+                let cache_on_disk = Self::cache_on_disk(qcx.tcx, key);\n+                if cache_on_disk { should_ever_cache_on_disk!([$($modifiers)*]) } else { None }\n             }\n+\n+            const ANON: bool = is_anon!([$($modifiers)*]);\n+            const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n+            const DEPTH_LIMIT: bool = depth_limit!([$($modifiers)*]);\n+            const FEEDABLE: bool = feedable!([$($modifiers)*]);\n+\n+            const DEP_KIND: rustc_middle::dep_graph::DepKind = dep_graph::DepKind::$name;\n+            const HANDLE_CYCLE_ERROR: rustc_query_system::HandleCycleError = handle_cycle_error!([$($modifiers)*]);\n+\n+            const HASH_RESULT: rustc_query_system::query::HashResult<QueryCtxt<'tcx>, Self> = hash_result!([$($modifiers)*]);\n         })*\n \n         #[allow(nonstandard_style)]"}, {"sha": "0b1ff5d709fe904e96dd3703ba79966817af37c0", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -634,7 +634,7 @@ impl<K: DepKind> DepGraph<K> {\n         if dep_node_debug.borrow().contains_key(&dep_node) {\n             return;\n         }\n-        let debug_str = debug_str_gen();\n+        let debug_str = self.with_ignore(debug_str_gen);\n         dep_node_debug.borrow_mut().insert(dep_node, debug_str);\n     }\n \n@@ -829,7 +829,9 @@ impl<K: DepKind> DepGraph<K> {\n         );\n \n         if !side_effects.is_empty() {\n-            self.emit_side_effects(qcx, data, dep_node_index, side_effects);\n+            self.with_query_deserialization(|| {\n+                self.emit_side_effects(qcx, data, dep_node_index, side_effects)\n+            });\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map."}, {"sha": "8c0330e438de4724711816ed47742d1e5537aee1", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,7 +1,6 @@\n //! Query configuration and description traits.\n \n-use crate::dep_graph::DepNode;\n-use crate::dep_graph::SerializedDepNodeIndex;\n+use crate::dep_graph::{DepNode, DepNodeParams, SerializedDepNodeIndex};\n use crate::error::HandleCycleError;\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n@@ -11,10 +10,16 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n use std::hash::Hash;\n \n+pub type HashResult<Qcx, Q> =\n+    Option<fn(&mut StableHashingContext<'_>, &<Q as QueryConfig<Qcx>>::Value) -> Fingerprint>;\n+\n+pub type TryLoadFromDisk<Qcx, Q> =\n+    Option<fn(Qcx, SerializedDepNodeIndex) -> Option<<Q as QueryConfig<Qcx>>::Value>>;\n+\n pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n-    type Key: Eq + Hash + Clone + Debug;\n+    type Key: DepNodeParams<Qcx::DepContext> + Eq + Hash + Clone + Debug;\n     type Value: Debug;\n     type Stored: Debug + Clone + std::borrow::Borrow<Self::Value>;\n \n@@ -30,39 +35,27 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     where\n         Qcx: 'a;\n \n-    // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn make_vtable(tcx: Qcx, key: &Self::Key) -> QueryVTable<Qcx, Self::Key, Self::Value>;\n-\n     fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Stored;\n-}\n \n-#[derive(Copy, Clone)]\n-pub struct QueryVTable<Qcx: QueryContext, K, V> {\n-    pub anon: bool,\n-    pub dep_kind: Qcx::DepKind,\n-    pub eval_always: bool,\n-    pub depth_limit: bool,\n-    pub feedable: bool,\n-\n-    pub compute: fn(Qcx::DepContext, K) -> V,\n-    pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n-    pub handle_cycle_error: HandleCycleError,\n-    // NOTE: this is also `None` if `cache_on_disk()` returns false, not just if it's unsupported by the query\n-    pub try_load_from_disk: Option<fn(Qcx, SerializedDepNodeIndex) -> Option<V>>,\n-}\n+    fn compute(tcx: Qcx, key: &Self::Key) -> fn(Qcx::DepContext, Self::Key) -> Self::Value;\n \n-impl<Qcx: QueryContext, K, V> QueryVTable<Qcx, K, V> {\n-    pub(crate) fn to_dep_node(&self, tcx: Qcx::DepContext, key: &K) -> DepNode<Qcx::DepKind>\n-    where\n-        K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n-    {\n-        DepNode::construct(tcx, self.dep_kind, key)\n-    }\n+    fn try_load_from_disk(qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self>;\n+\n+    const ANON: bool;\n+    const EVAL_ALWAYS: bool;\n+    const DEPTH_LIMIT: bool;\n+    const FEEDABLE: bool;\n+\n+    const DEP_KIND: Qcx::DepKind;\n+    const HANDLE_CYCLE_ERROR: HandleCycleError;\n+\n+    const HASH_RESULT: HashResult<Qcx, Self>;\n \n-    pub(crate) fn compute(&self, tcx: Qcx::DepContext, key: K) -> V {\n-        (self.compute)(tcx, key)\n+    // Just here for convernience and checking that the key matches the kind, don't override this.\n+    fn construct_dep_node(tcx: Qcx::DepContext, key: &Self::Key) -> DepNode<Qcx::DepKind> {\n+        DepNode::construct(tcx, Self::DEP_KIND, key)\n     }\n }"}, {"sha": "d308af192076051ef23b0098f3375e39791a879a", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -12,7 +12,7 @@ pub use self::caches::{\n };\n \n mod config;\n-pub use self::config::{QueryConfig, QueryVTable};\n+pub use self::config::{HashResult, QueryConfig, TryLoadFromDisk};\n \n use crate::dep_graph::DepKind;\n use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};"}, {"sha": "da1ac6a5fb227dd48daf9c075a238a2ebbf4b773", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 49, "deletions": 64, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2,10 +2,9 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n-use crate::query::config::QueryVTable;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n use crate::values::Value;\n@@ -361,44 +360,42 @@ where\n     })\n }\n \n-fn try_execute_query<Qcx, C>(\n+fn try_execute_query<Q, Qcx>(\n     qcx: Qcx,\n-    state: &QueryState<C::Key, Qcx::DepKind>,\n-    cache: &C,\n+    state: &QueryState<Q::Key, Qcx::DepKind>,\n+    cache: &Q::Cache,\n     span: Span,\n-    key: C::Key,\n+    key: Q::Key,\n     dep_node: Option<DepNode<Qcx::DepKind>>,\n-    query: &QueryVTable<Qcx, C::Key, C::Value>,\n-) -> (C::Stored, Option<DepNodeIndex>)\n+) -> (Q::Stored, Option<DepNodeIndex>)\n where\n-    C: QueryCache,\n-    C::Key: Clone + DepNodeParams<Qcx::DepContext>,\n-    C::Value: Value<Qcx::DepContext, Qcx::DepKind>,\n-    C::Stored: Debug + std::borrow::Borrow<C::Value>,\n+    Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    match JobOwner::<'_, C::Key, Qcx::DepKind>::try_start(&qcx, state, span, key.clone()) {\n+    match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(qcx, key.clone(), dep_node, query, job.id);\n-            if query.feedable {\n+            let (result, dep_node_index) =\n+                execute_job::<Q, Qcx>(qcx, key.clone(), dep_node, job.id);\n+            if Q::FEEDABLE {\n                 // We may have put a value inside the cache from inside the execution.\n                 // Verify that it has the same hash as what we have now, to ensure consistency.\n                 let _ = cache.lookup(&key, |cached_result, _| {\n-                    let hasher = query.hash_result.expect(\"feedable forbids no_hash\");\n+                    let hasher = Q::HASH_RESULT.expect(\"feedable forbids no_hash\");\n+\n                     let old_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, cached_result.borrow()));\n                     let new_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, &result));\n                     debug_assert_eq!(\n                         old_hash, new_hash,\n                         \"Computed query value for {:?}({:?}) is inconsistent with fed value,\\ncomputed={:#?}\\nfed={:#?}\",\n-                        query.dep_kind, key, result, cached_result,\n+                        Q::DEP_KIND, key, result, cached_result,\n                     );\n                 });\n             }\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(qcx, error, query.handle_cycle_error, cache);\n+            let result = mk_cycle(qcx, error, Q::HANDLE_CYCLE_ERROR, cache);\n             (result, None)\n         }\n         #[cfg(parallel_compiler)]\n@@ -417,40 +414,38 @@ where\n     }\n }\n \n-fn execute_job<Qcx, K, V>(\n+fn execute_job<Q, Qcx>(\n     qcx: Qcx,\n-    key: K,\n+    key: Q::Key,\n     mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n-    query: &QueryVTable<Qcx, K, V>,\n     job_id: QueryJobId,\n-) -> (V, DepNodeIndex)\n+) -> (Q::Value, DepNodeIndex)\n where\n-    K: Clone + DepNodeParams<Qcx::DepContext>,\n-    V: Debug,\n+    Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n     let dep_graph = qcx.dep_context().dep_graph();\n \n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = qcx.dep_context().profiler().query_provider();\n-        let result = qcx.start_query(job_id, query.depth_limit, None, || {\n-            query.compute(*qcx.dep_context(), key)\n+        let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || {\n+            Q::compute(qcx, &key)(*qcx.dep_context(), key)\n         });\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n         return (result, dep_node_index);\n     }\n \n-    if !query.anon && !query.eval_always {\n+    if !Q::ANON && !Q::EVAL_ALWAYS {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node =\n-            dep_node_opt.get_or_insert_with(|| query.to_dep_node(*qcx.dep_context(), &key));\n+            dep_node_opt.get_or_insert_with(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n \n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         if let Some(ret) = qcx.start_query(job_id, false, None, || {\n-            try_load_from_disk_and_cache_in_memory(qcx, &key, &dep_node, query)\n+            try_load_from_disk_and_cache_in_memory::<Q, Qcx>(qcx, &key, &dep_node)\n         }) {\n             return ret;\n         }\n@@ -460,18 +455,19 @@ where\n     let diagnostics = Lock::new(ThinVec::new());\n \n     let (result, dep_node_index) =\n-        qcx.start_query(job_id, query.depth_limit, Some(&diagnostics), || {\n-            if query.anon {\n-                return dep_graph.with_anon_task(*qcx.dep_context(), query.dep_kind, || {\n-                    query.compute(*qcx.dep_context(), key)\n+        qcx.start_query(job_id, Q::DEPTH_LIMIT, Some(&diagnostics), || {\n+            if Q::ANON {\n+                return dep_graph.with_anon_task(*qcx.dep_context(), Q::DEP_KIND, || {\n+                    Q::compute(qcx, &key)(*qcx.dep_context(), key)\n                 });\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n-                dep_node_opt.unwrap_or_else(|| query.to_dep_node(*qcx.dep_context(), &key));\n+                dep_node_opt.unwrap_or_else(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n \n-            dep_graph.with_task(dep_node, *qcx.dep_context(), key, query.compute, query.hash_result)\n+            let task = Q::compute(qcx, &key);\n+            dep_graph.with_task(dep_node, *qcx.dep_context(), key, task, Q::HASH_RESULT)\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -480,7 +476,7 @@ where\n     let side_effects = QuerySideEffects { diagnostics };\n \n     if std::intrinsics::unlikely(!side_effects.is_empty()) {\n-        if query.anon {\n+        if Q::ANON {\n             qcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         } else {\n             qcx.store_side_effects(dep_node_index, side_effects);\n@@ -490,16 +486,14 @@ where\n     (result, dep_node_index)\n }\n \n-fn try_load_from_disk_and_cache_in_memory<Qcx, K, V>(\n+fn try_load_from_disk_and_cache_in_memory<Q, Qcx>(\n     qcx: Qcx,\n-    key: &K,\n+    key: &Q::Key,\n     dep_node: &DepNode<Qcx::DepKind>,\n-    query: &QueryVTable<Qcx, K, V>,\n-) -> Option<(V, DepNodeIndex)>\n+) -> Option<(Q::Value, DepNodeIndex)>\n where\n-    K: Clone,\n+    Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n-    V: Debug,\n {\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n@@ -511,7 +505,7 @@ where\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n-    if let Some(try_load_from_disk) = query.try_load_from_disk {\n+    if let Some(try_load_from_disk) = Q::try_load_from_disk(qcx, &key) {\n         let prof_timer = qcx.dep_context().profiler().incr_cache_loading();\n \n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n@@ -545,7 +539,7 @@ where\n             if std::intrinsics::unlikely(\n                 try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, Q::HASH_RESULT);\n             }\n \n             return Some((result, dep_node_index));\n@@ -565,7 +559,7 @@ where\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| query.compute(*qcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| Q::compute(qcx, key)(*qcx.dep_context(), key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -578,7 +572,7 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, Q::HASH_RESULT);\n \n     Some((result, dep_node_index))\n }\n@@ -699,23 +693,19 @@ fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result:\n ///\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n-fn ensure_must_run<Qcx, K, V>(\n-    qcx: Qcx,\n-    key: &K,\n-    query: &QueryVTable<Qcx, K, V>,\n-) -> (bool, Option<DepNode<Qcx::DepKind>>)\n+fn ensure_must_run<Q, Qcx>(qcx: Qcx, key: &Q::Key) -> (bool, Option<DepNode<Qcx::DepKind>>)\n where\n-    K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n+    Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    if query.eval_always {\n+    if Q::EVAL_ALWAYS {\n         return (true, None);\n     }\n \n     // Ensuring an anonymous query makes no sense\n-    assert!(!query.anon);\n+    assert!(!Q::ANON);\n \n-    let dep_node = query.to_dep_node(*qcx.dep_context(), key);\n+    let dep_node = Q::construct_dep_node(*qcx.dep_context(), key);\n \n     let dep_graph = qcx.dep_context().dep_graph();\n     match dep_graph.try_mark_green(qcx, &dep_node) {\n@@ -746,13 +736,11 @@ pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode)\n where\n     D: DepKind,\n     Q: QueryConfig<Qcx>,\n-    Q::Key: DepNodeParams<Qcx::DepContext>,\n     Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n-    let query = Q::make_vtable(qcx, &key);\n     let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run(qcx, &key, &query);\n+        let (must_run, dep_node) = ensure_must_run::<Q, _>(qcx, &key);\n         if !must_run {\n             return None;\n         }\n@@ -761,14 +749,13 @@ where\n         None\n     };\n \n-    let (result, dep_node_index) = try_execute_query(\n+    let (result, dep_node_index) = try_execute_query::<Q, Qcx>(\n         qcx,\n         Q::query_state(qcx),\n         Q::query_cache(qcx),\n         span,\n         key,\n         dep_node,\n-        &query,\n     );\n     if let Some(dep_node_index) = dep_node_index {\n         qcx.dep_context().dep_graph().read_index(dep_node_index)\n@@ -780,7 +767,6 @@ pub fn force_query<Q, Qcx, D>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepK\n where\n     D: DepKind,\n     Q: QueryConfig<Qcx>,\n-    Q::Key: DepNodeParams<Qcx::DepContext>,\n     Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n@@ -798,9 +784,8 @@ where\n         Err(()) => {}\n     }\n \n-    let query = Q::make_vtable(qcx, &key);\n     let state = Q::query_state(qcx);\n-    debug_assert!(!query.anon);\n+    debug_assert!(!Q::ANON);\n \n-    try_execute_query(qcx, state, cache, DUMMY_SP, key, Some(dep_node), &query);\n+    try_execute_query::<Q, _>(qcx, state, cache, DUMMY_SP, key, Some(dep_node));\n }"}, {"sha": "c44635b85f8f0b82bc5e52a66c50f6d747f4388b", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -16,7 +16,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::{DiagnosticArgValue, DiagnosticId, IntoDiagnosticArg};\n+use rustc_errors::{Applicability, DiagnosticArgValue, DiagnosticId, IntoDiagnosticArg};\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n@@ -536,6 +536,9 @@ struct DiagnosticMetadata<'ast> {\n     in_assignment: Option<&'ast Expr>,\n     is_assign_rhs: bool,\n \n+    /// Used to detect possible `.` -> `..` typo when calling methods.\n+    in_range: Option<(&'ast Expr, &'ast Expr)>,\n+\n     /// If we are currently in a trait object definition. Used to point at the bounds when\n     /// encountering a struct or enum.\n     current_trait_object: Option<&'ast [ast::GenericBound]>,\n@@ -648,7 +651,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         let prev = self.diagnostic_metadata.current_trait_object;\n         let prev_ty = self.diagnostic_metadata.current_type_path;\n         match ty.kind {\n-            TyKind::Rptr(None, _) => {\n+            TyKind::Ref(None, _) => {\n                 // Elided lifetime in reference: we resolve as if there was some lifetime `'_` with\n                 // NodeId `ty.id`.\n                 // This span will be used in case of elision failure.\n@@ -2001,7 +2004,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         impl<'a> Visitor<'a> for SelfVisitor<'_, '_> {\n             fn visit_ty(&mut self, ty: &'a Ty) {\n                 trace!(\"SelfVisitor considering ty={:?}\", ty);\n-                if let TyKind::Rptr(lt, ref mt) = ty.kind && self.is_self_ty(&mt.ty) {\n+                if let TyKind::Ref(lt, ref mt) = ty.kind && self.is_self_ty(&mt.ty) {\n                     let lt_id = if let Some(lt) = lt {\n                         lt.id\n                     } else {\n@@ -3320,17 +3323,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         );\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn smart_resolve_path_fragment(\n         &mut self,\n         qself: &Option<P<QSelf>>,\n         path: &[Segment],\n         source: PathSource<'ast>,\n         finalize: Finalize,\n     ) -> PartialRes {\n-        debug!(\n-            \"smart_resolve_path_fragment(qself={:?}, path={:?}, finalize={:?})\",\n-            qself, path, finalize,\n-        );\n         let ns = source.namespace();\n \n         let Finalize { node_id, path_span, .. } = finalize;\n@@ -3341,8 +3341,28 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n                 let def_id = this.parent_scope.module.nearest_parent_mod();\n                 let instead = res.is_some();\n-                let suggestion =\n-                    if res.is_none() { this.report_missing_type_error(path) } else { None };\n+                let suggestion = if let Some((start, end)) = this.diagnostic_metadata.in_range\n+                    && path[0].ident.span.lo() == end.span.lo()\n+                {\n+                    let mut sugg = \".\";\n+                    let mut span = start.span.between(end.span);\n+                    if span.lo() + BytePos(2) == span.hi() {\n+                        // There's no space between the start, the range op and the end, suggest\n+                        // removal which will look better.\n+                        span = span.with_lo(span.lo() + BytePos(1));\n+                        sugg = \"\";\n+                    }\n+                    Some((\n+                        span,\n+                        \"you might have meant to write `.` instead of `..`\",\n+                        sugg.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    ))\n+                } else if res.is_none() {\n+                    this.report_missing_type_error(path)\n+                } else {\n+                    None\n+                };\n \n                 this.r.use_injections.push(UseError {\n                     err,\n@@ -4005,6 +4025,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.visit_expr(rhs);\n                 self.diagnostic_metadata.is_assign_rhs = false;\n             }\n+            ExprKind::Range(Some(ref start), Some(ref end), RangeLimits::HalfOpen) => {\n+                self.diagnostic_metadata.in_range = Some((start, end));\n+                self.resolve_expr(start, Some(expr));\n+                self.resolve_expr(end, Some(expr));\n+                self.diagnostic_metadata.in_range = None;\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "74522f185422d45eb948d01335284ff0e457427b", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1554,7 +1554,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         fn extract_node_id(t: &Ty) -> Option<NodeId> {\n             match t.kind {\n                 TyKind::Path(None, _) => Some(t.id),\n-                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n+                TyKind::Ref(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future.\n@@ -2189,7 +2189,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 Some(LifetimeUseSet::One { use_span, use_ctxt }) => {\n                     debug!(?param.ident, ?param.ident.span, ?use_span);\n \n-                    let elidable = matches!(use_ctxt, LifetimeCtxt::Rptr);\n+                    let elidable = matches!(use_ctxt, LifetimeCtxt::Ref);\n \n                     let deletion_span = deletion_span();\n                     self.r.lint_buffer.buffer_lint_with_diagnostic("}, {"sha": "5a1bcb8fdc87be9a82047dbed9040ee4e3c17afd", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -165,7 +165,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                 let text = format!(\"{}{}\", prefix, nested.text);\n                 Ok(replace_text(nested, text))\n             }\n-            hir::TyKind::Rptr(ref lifetime, ref mt) => {\n+            hir::TyKind::Ref(ref lifetime, ref mt) => {\n                 let mut prefix = \"&\".to_owned();\n                 prefix.push_str(&lifetime.ident.to_string());\n                 prefix.push(' ');"}, {"sha": "02e3992a6a940d5b6a53c723fdba5c624f979c03", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -787,6 +787,12 @@ impl Options {\n     pub fn get_symbol_mangling_version(&self) -> SymbolManglingVersion {\n         self.cg.symbol_mangling_version.unwrap_or(SymbolManglingVersion::Legacy)\n     }\n+\n+    #[allow(rustc::bad_opt_access)]\n+    pub fn incremental_relative_spans(&self) -> bool {\n+        self.unstable_opts.incremental_relative_spans\n+            || (self.unstable_features.is_nightly_build() && self.incremental.is_some())\n+    }\n }\n \n impl UnstableOptions {"}, {"sha": "9bf581ff73d23c01d918df44afa709605f93c28b", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1214,7 +1214,6 @@ options! {\n         \"only allow the listed language features to be enabled in code (space separated)\"),\n     always_encode_mir: bool = (false, parse_bool, [TRACKED],\n         \"encode MIR of all functions into the crate metadata (default: no)\"),\n-    #[rustc_lint_opt_deny_field_access(\"use `Session::asm_comments` instead of this field\")]\n     asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior) (default: no)\"),\n     assert_incr_state: Option<String> = (None, parse_opt_string, [UNTRACKED],\n@@ -1333,11 +1332,12 @@ options! {\n         \"generate human-readable, predictable names for codegen units (default: no)\"),\n     identify_regions: bool = (false, parse_bool, [UNTRACKED],\n         \"display unnamed regions as `'<id>`, using a non-ident unique id (default: no)\"),\n-    incremental_ignore_spans: bool = (false, parse_bool, [UNTRACKED],\n+    incremental_ignore_spans: bool = (false, parse_bool, [TRACKED],\n         \"ignore spans during ICH computation -- used for testing (default: no)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof) \\\n         (default: no)\"),\n+    #[rustc_lint_opt_deny_field_access(\"use `Session::incremental_relative_spans` instead of this field\")]\n     incremental_relative_spans: bool = (false, parse_bool, [TRACKED],\n         \"hash spans relative to their parent item for incr. comp. (default: no)\"),\n     incremental_verify_ich: bool = (false, parse_bool, [UNTRACKED],\n@@ -1363,7 +1363,6 @@ options! {\n         `=except-unused-generics`\n         `=except-unused-functions`\n         `=off` (default)\"),\n-    #[rustc_lint_opt_deny_field_access(\"use `Session::instrument_mcount` instead of this field\")]\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n@@ -1392,7 +1391,6 @@ options! {\n     merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n         \"control the operation of the MergeFunctions LLVM pass, taking \\\n         the same values as the target option of the same name\"),\n-    #[rustc_lint_opt_deny_field_access(\"use `Session::meta_stats` instead of this field\")]\n     meta_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather metadata statistics (default: no)\"),\n     mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n@@ -1469,7 +1467,6 @@ options! {\n         See #77382 and #74551.\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"make rustc print the total optimization fuel used by a crate\"),\n-    #[rustc_lint_opt_deny_field_access(\"use `Session::print_llvm_passes` instead of this field\")]\n     print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"print the LLVM optimization passes being run (default: no)\"),\n     print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n@@ -1583,10 +1580,8 @@ options! {\n     #[rustc_lint_opt_deny_field_access(\"use `Session::threads` instead of this field\")]\n     threads: usize = (1, parse_threads, [UNTRACKED],\n         \"use a thread pool with N threads\"),\n-    #[rustc_lint_opt_deny_field_access(\"use `Session::time_llvm_passes` instead of this field\")]\n     time_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each LLVM pass (default: no)\"),\n-    #[rustc_lint_opt_deny_field_access(\"use `Session::time_passes` instead of this field\")]\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass (default: no)\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::tls_model` instead of this field\")]"}, {"sha": "4a3d29414d6e598f2b24efe90835e626f916b34a", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -976,34 +976,10 @@ impl Session {\n         self.opts.unstable_opts.verbose\n     }\n \n-    pub fn instrument_mcount(&self) -> bool {\n-        self.opts.unstable_opts.instrument_mcount\n-    }\n-\n-    pub fn time_passes(&self) -> bool {\n-        self.opts.unstable_opts.time_passes\n-    }\n-\n-    pub fn time_llvm_passes(&self) -> bool {\n-        self.opts.unstable_opts.time_llvm_passes\n-    }\n-\n-    pub fn meta_stats(&self) -> bool {\n-        self.opts.unstable_opts.meta_stats\n-    }\n-\n-    pub fn asm_comments(&self) -> bool {\n-        self.opts.unstable_opts.asm_comments\n-    }\n-\n     pub fn verify_llvm_ir(&self) -> bool {\n         self.opts.unstable_opts.verify_llvm_ir || option_env!(\"RUSTC_VERIFY_LLVM_IR\").is_some()\n     }\n \n-    pub fn print_llvm_passes(&self) -> bool {\n-        self.opts.unstable_opts.print_llvm_passes\n-    }\n-\n     pub fn binary_dep_depinfo(&self) -> bool {\n         self.opts.unstable_opts.binary_dep_depinfo\n     }"}, {"sha": "4e70dfb614782e015325fb216133bba7d8eeda82", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -104,6 +104,10 @@ fn assert_default_hashing_controls<CTX: HashStableContext>(ctx: &CTX, msg: &str)\n         // `-Z incremental-ignore-spans` option. Normally, this option is disabled,\n         // which will cause us to require that this method always be called with `Span` hashing\n         // enabled.\n+        //\n+        // Span hashing can also be disabled without `-Z incremental-ignore-spans`.\n+        // This is the case for instance when building a hash for name mangling.\n+        // Such configuration must not be used for metadata.\n         HashingControls { hash_spans }\n             if hash_spans == !ctx.unstable_opts_incremental_ignore_spans() => {}\n         other => panic!(\"Attempted hashing of {msg} with non-default HashingControls: {:?}\", other),\n@@ -316,6 +320,7 @@ impl ExpnId {\n             // Stop going up the backtrace once include! is encountered\n             if expn_data.is_root()\n                 || expn_data.kind == ExpnKind::Macro(MacroKind::Bang, sym::include)\n+                || expn_data.kind == ExpnKind::Inlined\n             {\n                 break;\n             }"}, {"sha": "bee4b0a2332b55022ef570f0a6cb102b93de9b92", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -796,6 +796,9 @@ impl Span {\n \n     /// Returns a `Span` that would enclose both `self` and `end`.\n     ///\n+    /// Note that this can also be used to extend the span \"backwards\":\n+    /// `start.to(end)` and `end.to(start)` return the same `Span`.\n+    ///\n     /// ```text\n     ///     ____             ___\n     ///     self lorem ipsum end"}, {"sha": "fa09b4faa441f3b83d50809c92b426e708784b89", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -964,45 +964,40 @@ impl SourceMap {\n \n     /// Finds the width of the character, either before or after the end of provided span,\n     /// depending on the `forwards` parameter.\n+    #[instrument(skip(self, sp))]\n     fn find_width_of_character_at_span(&self, sp: Span, forwards: bool) -> u32 {\n         let sp = sp.data();\n \n         if sp.lo == sp.hi && !forwards {\n-            debug!(\"find_width_of_character_at_span: early return empty span\");\n+            debug!(\"early return empty span\");\n             return 1;\n         }\n \n         let local_begin = self.lookup_byte_offset(sp.lo);\n         let local_end = self.lookup_byte_offset(sp.hi);\n-        debug!(\n-            \"find_width_of_character_at_span: local_begin=`{:?}`, local_end=`{:?}`\",\n-            local_begin, local_end\n-        );\n+        debug!(\"local_begin=`{:?}`, local_end=`{:?}`\", local_begin, local_end);\n \n         if local_begin.sf.start_pos != local_end.sf.start_pos {\n-            debug!(\"find_width_of_character_at_span: begin and end are in different files\");\n+            debug!(\"begin and end are in different files\");\n             return 1;\n         }\n \n         let start_index = local_begin.pos.to_usize();\n         let end_index = local_end.pos.to_usize();\n-        debug!(\n-            \"find_width_of_character_at_span: start_index=`{:?}`, end_index=`{:?}`\",\n-            start_index, end_index\n-        );\n+        debug!(\"start_index=`{:?}`, end_index=`{:?}`\", start_index, end_index);\n \n         // Disregard indexes that are at the start or end of their spans, they can't fit bigger\n         // characters.\n         if (!forwards && end_index == usize::MIN) || (forwards && start_index == usize::MAX) {\n-            debug!(\"find_width_of_character_at_span: start or end of span, cannot be multibyte\");\n+            debug!(\"start or end of span, cannot be multibyte\");\n             return 1;\n         }\n \n         let source_len = (local_begin.sf.end_pos - local_begin.sf.start_pos).to_usize();\n-        debug!(\"find_width_of_character_at_span: source_len=`{:?}`\", source_len);\n+        debug!(\"source_len=`{:?}`\", source_len);\n         // Ensure indexes are also not malformed.\n         if start_index > end_index || end_index > source_len - 1 {\n-            debug!(\"find_width_of_character_at_span: source indexes are malformed\");\n+            debug!(\"source indexes are malformed\");\n             return 1;\n         }\n \n@@ -1017,10 +1012,10 @@ impl SourceMap {\n         } else {\n             return 1;\n         };\n-        debug!(\"find_width_of_character_at_span: snippet=`{:?}`\", snippet);\n+        debug!(\"snippet=`{:?}`\", snippet);\n \n         let mut target = if forwards { end_index + 1 } else { end_index - 1 };\n-        debug!(\"find_width_of_character_at_span: initial target=`{:?}`\", target);\n+        debug!(\"initial target=`{:?}`\", target);\n \n         while !snippet.is_char_boundary(target - start_index) && target < source_len {\n             target = if forwards {\n@@ -1033,9 +1028,9 @@ impl SourceMap {\n                     }\n                 }\n             };\n-            debug!(\"find_width_of_character_at_span: target=`{:?}`\", target);\n+            debug!(\"target=`{:?}`\", target);\n         }\n-        debug!(\"find_width_of_character_at_span: final target=`{:?}`\", target);\n+        debug!(\"final target=`{:?}`\", target);\n \n         if forwards { (target - end_index) as u32 } else { (end_index - target) as u32 }\n     }"}, {"sha": "d48c4f7e5a8119f1c84f2a9b32d043dcab05e898", "filename": "compiler/rustc_span/src/span_encoding.rs", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -4,7 +4,7 @@\n // The encoding format for inline spans were obtained by optimizing over crates in rustc/libstd.\n // See https://internals.rust-lang.org/t/rfc-compiler-refactoring-spans/1357/28\n \n-use crate::def_id::LocalDefId;\n+use crate::def_id::{DefIndex, LocalDefId};\n use crate::hygiene::SyntaxContext;\n use crate::SPAN_TRACK;\n use crate::{BytePos, SpanData};\n@@ -13,8 +13,8 @@ use rustc_data_structures::fx::FxIndexSet;\n \n /// A compressed span.\n ///\n-/// Whereas [`SpanData`] is 12 bytes, which is a bit too big to stick everywhere, `Span`\n-/// is a form that only takes up 8 bytes, with less space for the length and\n+/// Whereas [`SpanData`] is 16 bytes, which is a bit too big to stick everywhere, `Span`\n+/// is a form that only takes up 8 bytes, with less space for the length, parent and\n /// context. The vast majority (99.9%+) of `SpanData` instances will fit within\n /// those 8 bytes; any `SpanData` whose fields don't fit into a `Span` are\n /// stored in a separate interner table, and the `Span` will index into that\n@@ -25,7 +25,7 @@ use rustc_data_structures::fx::FxIndexSet;\n /// slower because only 80--90% of spans could be stored inline (even less in\n /// very large crates) and so the interner was used a lot more.\n ///\n-/// Inline (compressed) format:\n+/// Inline (compressed) format with no parent:\n /// - `span.base_or_index == span_data.lo`\n /// - `span.len_or_tag == len == span_data.hi - span_data.lo` (must be `<= MAX_LEN`)\n /// - `span.ctxt_or_tag == span_data.ctxt` (must be `<= MAX_CTXT`)\n@@ -35,6 +35,12 @@ use rustc_data_structures::fx::FxIndexSet;\n /// - `span.len_or_tag == LEN_TAG` (high bit set, all other bits are zero)\n /// - `span.ctxt_or_tag == span_data.ctxt` (must be `<= MAX_CTXT`)\n ///\n+/// Inline (compressed) format with root context:\n+/// - `span.base_or_index == span_data.lo`\n+/// - `span.len_or_tag == len == span_data.hi - span_data.lo` (must be `<= MAX_LEN`)\n+/// - `span.len_or_tag` has top bit (`PARENT_MASK`) set\n+/// - `span.ctxt == span_data.parent` (must be `<= MAX_CTXT`)\n+///\n /// Interned format:\n /// - `span.base_or_index == index` (indexes into the interner table)\n /// - `span.len_or_tag == LEN_TAG` (high bit set, all other bits are zero)\n@@ -73,7 +79,8 @@ pub struct Span {\n     ctxt_or_tag: u16,\n }\n \n-const LEN_TAG: u16 = 0b1000_0000_0000_0000;\n+const LEN_TAG: u16 = 0b1111_1111_1111_1111;\n+const PARENT_MASK: u16 = 0b1000_0000_0000_0000;\n const MAX_LEN: u32 = 0b0111_1111_1111_1111;\n const CTXT_TAG: u32 = 0b1111_1111_1111_1111;\n const MAX_CTXT: u32 = CTXT_TAG - 1;\n@@ -95,16 +102,32 @@ impl Span {\n \n         let (base, len, ctxt2) = (lo.0, hi.0 - lo.0, ctxt.as_u32());\n \n-        if len <= MAX_LEN && ctxt2 <= MAX_CTXT && parent.is_none() {\n-            // Inline format.\n-            Span { base_or_index: base, len_or_tag: len as u16, ctxt_or_tag: ctxt2 as u16 }\n-        } else {\n-            // Interned format.\n-            let index =\n-                with_span_interner(|interner| interner.intern(&SpanData { lo, hi, ctxt, parent }));\n-            let ctxt_or_tag = if ctxt2 <= MAX_CTXT { ctxt2 } else { CTXT_TAG } as u16;\n-            Span { base_or_index: index, len_or_tag: LEN_TAG, ctxt_or_tag }\n+        if len <= MAX_LEN && ctxt2 <= MAX_CTXT {\n+            let len_or_tag = len as u16;\n+            debug_assert_eq!(len_or_tag & PARENT_MASK, 0);\n+\n+            if let Some(parent) = parent {\n+                // Inline format with parent.\n+                let len_or_tag = len_or_tag | PARENT_MASK;\n+                let parent2 = parent.local_def_index.as_u32();\n+                if ctxt2 == SyntaxContext::root().as_u32() && parent2 <= MAX_CTXT {\n+                    return Span { base_or_index: base, len_or_tag, ctxt_or_tag: parent2 as u16 };\n+                }\n+            } else {\n+                // Inline format with ctxt.\n+                return Span {\n+                    base_or_index: base,\n+                    len_or_tag: len as u16,\n+                    ctxt_or_tag: ctxt2 as u16,\n+                };\n+            }\n         }\n+\n+        // Interned format.\n+        let index =\n+            with_span_interner(|interner| interner.intern(&SpanData { lo, hi, ctxt, parent }));\n+        let ctxt_or_tag = if ctxt2 <= MAX_CTXT { ctxt2 } else { CTXT_TAG } as u16;\n+        Span { base_or_index: index, len_or_tag: LEN_TAG, ctxt_or_tag }\n     }\n \n     #[inline]\n@@ -122,12 +145,25 @@ impl Span {\n     pub fn data_untracked(self) -> SpanData {\n         if self.len_or_tag != LEN_TAG {\n             // Inline format.\n-            debug_assert!(self.len_or_tag as u32 <= MAX_LEN);\n-            SpanData {\n-                lo: BytePos(self.base_or_index),\n-                hi: BytePos(self.base_or_index + self.len_or_tag as u32),\n-                ctxt: SyntaxContext::from_u32(self.ctxt_or_tag as u32),\n-                parent: None,\n+            if self.len_or_tag & PARENT_MASK == 0 {\n+                debug_assert!(self.len_or_tag as u32 <= MAX_LEN);\n+                SpanData {\n+                    lo: BytePos(self.base_or_index),\n+                    hi: BytePos(self.base_or_index + self.len_or_tag as u32),\n+                    ctxt: SyntaxContext::from_u32(self.ctxt_or_tag as u32),\n+                    parent: None,\n+                }\n+            } else {\n+                let len = self.len_or_tag & !PARENT_MASK;\n+                debug_assert!(len as u32 <= MAX_LEN);\n+                let parent =\n+                    LocalDefId { local_def_index: DefIndex::from_u32(self.ctxt_or_tag as u32) };\n+                SpanData {\n+                    lo: BytePos(self.base_or_index),\n+                    hi: BytePos(self.base_or_index + len as u32),\n+                    ctxt: SyntaxContext::root(),\n+                    parent: Some(parent),\n+                }\n             }\n         } else {\n             // Interned format.\n@@ -141,8 +177,14 @@ impl Span {\n     pub fn ctxt(self) -> SyntaxContext {\n         let ctxt_or_tag = self.ctxt_or_tag as u32;\n         if ctxt_or_tag <= MAX_CTXT {\n-            // Inline format or interned format with inline ctxt.\n-            SyntaxContext::from_u32(ctxt_or_tag)\n+            if self.len_or_tag == LEN_TAG || self.len_or_tag & PARENT_MASK == 0 {\n+                // Inline format or interned format with inline ctxt.\n+                SyntaxContext::from_u32(ctxt_or_tag)\n+            } else {\n+                // Inline format or interned format with inline parent.\n+                // We know that the SyntaxContext is root.\n+                SyntaxContext::root()\n+            }\n         } else {\n             // Interned format.\n             let index = self.base_or_index;"}, {"sha": "85510fa2c660c53c700764823d1150eb3721927e", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -213,6 +213,7 @@ symbols! {\n         Is,\n         ItemContext,\n         Iterator,\n+        IteratorItem,\n         Layout,\n         Left,\n         LinkedList,\n@@ -1041,14 +1042,15 @@ symbols! {\n         panic_2021,\n         panic_abort,\n         panic_bounds_check,\n+        panic_cannot_unwind,\n         panic_display,\n         panic_fmt,\n         panic_handler,\n         panic_impl,\n         panic_implementation,\n         panic_info,\n         panic_location,\n-        panic_no_unwind,\n+        panic_nounwind,\n         panic_runtime,\n         panic_str,\n         panic_unwind,"}, {"sha": "e9b85705086b55fc81aea67c4faf66436da0ce56", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -164,6 +164,7 @@ fn encode_const<'tcx>(\n \n /// Encodes a FnSig using the Itanium C++ ABI with vendor extended type qualifiers and types for\n /// Rust types that are not used at the FFI boundary.\n+#[instrument(level = \"trace\", skip(tcx, dict))]\n fn encode_fnsig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fn_sig: &FnSig<'tcx>,\n@@ -653,6 +654,7 @@ fn encode_ty<'tcx>(\n // Transforms a ty:Ty for being encoded and used in the substitution dictionary. It transforms all\n // c_void types into unit types unconditionally, and generalizes all pointers if\n // TransformTyOptions::GENERALIZE_POINTERS option is set.\n+#[instrument(level = \"trace\", skip(tcx))]\n fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptions) -> Ty<'tcx> {\n     let mut ty = ty;\n \n@@ -698,7 +700,7 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n                     !is_zst\n                 });\n                 if let Some(field) = field {\n-                    let ty0 = tcx.type_of(field.did);\n+                    let ty0 = tcx.bound_type_of(field.did).subst(tcx, substs);\n                     // Generalize any repr(transparent) user-defined type that is either a pointer\n                     // or reference, and either references itself or any other type that contains or\n                     // references itself, to avoid a reference cycle.\n@@ -827,6 +829,7 @@ fn transform_substs<'tcx>(\n \n /// Returns a type metadata identifier for the specified FnAbi using the Itanium C++ ABI with vendor\n /// extended type qualifiers and types for Rust types that are not used at the FFI boundary.\n+#[instrument(level = \"trace\", skip(tcx))]\n pub fn typeid_for_fnabi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fn_abi: &FnAbi<'tcx, Ty<'tcx>>,"}, {"sha": "4512db49403d73602628c40dd6469c99cc58ae25", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2291,7 +2291,7 @@ impl Target {\n                     } else {\n                         return Some(Err(format!(\n                             \"'{}' is not a valid value for lld-flavor. \\\n-                             Use 'darwin', 'gnu', 'link' or 'wasm.\",\n+                             Use 'darwin', 'gnu', 'link' or 'wasm'.\",\n                             s)))\n                     }\n                     Some(Ok(()))"}, {"sha": "8a08c7533aa1e16eaf4d8cdfb2f439b27a146c5d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2771,7 +2771,7 @@ impl<'v> Visitor<'v> for FindTypeParam {\n         // and suggest `T: ?Sized` regardless of their obligations. This is fine because the errors\n         // in that case should make what happened clear enough.\n         match ty.kind {\n-            hir::TyKind::Ptr(_) | hir::TyKind::Rptr(..) | hir::TyKind::TraitObject(..) => {}\n+            hir::TyKind::Ptr(_) | hir::TyKind::Ref(..) | hir::TyKind::TraitObject(..) => {}\n             hir::TyKind::Path(hir::QPath::Resolved(None, path))\n                 if path.segments.len() == 1 && path.segments[0].ident.name == self.param =>\n             {"}, {"sha": "7c21a1047bcbfc5c3a04de884663780a3b56f66f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1291,29 +1291,25 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         if let ObligationCauseCode::AwaitableExpr(hir_id) = obligation.cause.code().peel_derives() {\n             let hir = self.tcx.hir();\n-            if let Some(node) = hir_id.and_then(|hir_id| hir.find(hir_id)) {\n-                if let hir::Node::Expr(expr) = node {\n-                    // FIXME: use `obligation.predicate.kind()...trait_ref.self_ty()` to see if we have `()`\n-                    // and if not maybe suggest doing something else? If we kept the expression around we\n-                    // could also check if it is an fn call (very likely) and suggest changing *that*, if\n-                    // it is from the local crate.\n-                    err.span_suggestion(\n-                        span,\n-                        \"remove the `.await`\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n-                    // FIXME: account for associated `async fn`s.\n-                    if let hir::Expr { span, kind: hir::ExprKind::Call(base, _), .. } = expr {\n-                        if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) =\n-                            obligation.predicate.kind().skip_binder()\n-                        {\n-                            err.span_label(\n-                                *span,\n-                                &format!(\"this call returns `{}`\", pred.self_ty()),\n-                            );\n-                        }\n-                        if let Some(typeck_results) = &self.typeck_results\n+            if let Some(hir::Node::Expr(expr)) = hir_id.and_then(|hir_id| hir.find(hir_id)) {\n+                // FIXME: use `obligation.predicate.kind()...trait_ref.self_ty()` to see if we have `()`\n+                // and if not maybe suggest doing something else? If we kept the expression around we\n+                // could also check if it is an fn call (very likely) and suggest changing *that*, if\n+                // it is from the local crate.\n+                err.span_suggestion(\n+                    span,\n+                    \"remove the `.await`\",\n+                    \"\",\n+                    Applicability::MachineApplicable,\n+                );\n+                // FIXME: account for associated `async fn`s.\n+                if let hir::Expr { span, kind: hir::ExprKind::Call(base, _), .. } = expr {\n+                    if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) =\n+                        obligation.predicate.kind().skip_binder()\n+                    {\n+                        err.span_label(*span, &format!(\"this call returns `{}`\", pred.self_ty()));\n+                    }\n+                    if let Some(typeck_results) = &self.typeck_results\n                             && let ty = typeck_results.expr_ty_adjusted(base)\n                             && let ty::FnDef(def_id, _substs) = ty.kind()\n                             && let Some(hir::Node::Item(hir::Item { ident, span, vis_span, .. })) =\n@@ -1339,7 +1335,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 );\n                             }\n                         }\n-                    }\n                 }\n             }\n         }\n@@ -2519,6 +2514,15 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ObligationCauseCode::VariableType(hir_id) => {\n                 let parent_node = self.tcx.hir().get_parent_node(hir_id);\n                 match self.tcx.hir().find(parent_node) {\n+                    Some(Node::Local(hir::Local { ty: Some(ty), .. })) => {\n+                        err.span_suggestion_verbose(\n+                            ty.span.shrink_to_lo(),\n+                            \"consider borrowing here\",\n+                            \"&\",\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.note(\"all local variables must have a statically known size\");\n+                    }\n                     Some(Node::Local(hir::Local {\n                         init: Some(hir::Expr { kind: hir::ExprKind::Index(_, _), span, .. }),\n                         ..\n@@ -2688,7 +2692,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // Don't print the tuple of capture types\n                 'print: {\n                     if !is_upvar_tys_infer_tuple {\n-                        let msg = format!(\"required because it appears within the type `{}`\", ty);\n+                        let msg = with_forced_trimmed_paths!(format!(\n+                            \"required because it appears within the type `{ty}`\",\n+                        ));\n                         match ty.kind() {\n                             ty::Adt(def, _) => match self.tcx.opt_item_ident(def.did()) {\n                                 Some(ident) => err.span_note(ident.span, &msg),\n@@ -2729,7 +2735,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 let mut msg =\n                                     \"required because it captures the following types: \".to_owned();\n                                 for ty in bound_tys.skip_binder() {\n-                                    write!(msg, \"`{}`, \", ty).unwrap();\n+                                    with_forced_trimmed_paths!(write!(msg, \"`{}`, \", ty).unwrap());\n                                 }\n                                 err.note(msg.trim_end_matches(\", \"))\n                             }\n@@ -2740,7 +2746,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 let kind = tcx.generator_kind(def_id).unwrap().descr();\n                                 err.span_note(\n                                     sp,\n-                                    &format!(\"required because it's used within this {}\", kind),\n+                                    with_forced_trimmed_paths!(&format!(\n+                                        \"required because it's used within this {kind}\",\n+                                    )),\n                                 )\n                             }\n                             ty::Closure(def_id, _) => err.span_note(\n@@ -2964,7 +2972,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     let expr_ty = with_forced_trimmed_paths!(self.ty_to_string(expr_ty));\n                     err.span_label(\n                         expr_span,\n-                        format!(\"return type was inferred to be `{expr_ty}` here\"),\n+                        with_forced_trimmed_paths!(format!(\n+                            \"return type was inferred to be `{expr_ty}` here\",\n+                        )),\n                     );\n                 }\n             }\n@@ -3227,7 +3237,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         })) = call_node\n         {\n             if Some(rcvr.span) == err.span.primary_span() {\n-                err.replace_span_with(path.ident.span);\n+                err.replace_span_with(path.ident.span, true);\n             }\n         }\n         if let Some(Node::Expr(hir::Expr {"}, {"sha": "f7614997585cf910c1173db7d58b9e610e11af59", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2284,7 +2284,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         obligation.param_env,\n         cause.clone(),\n         obligation.recursion_depth + 1,\n-        tcx.bound_trait_impl_trait_tys(impl_fn_def_id)\n+        tcx.bound_return_position_impl_trait_in_trait_tys(impl_fn_def_id)\n             .map_bound(|tys| {\n                 tys.map_or_else(|_| tcx.ty_error(), |tys| tys[&obligation.predicate.def_id])\n             })"}, {"sha": "466641ea6df3b46b7331159a346a400687a37079", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -12,8 +12,8 @@ use rustc_index::bit_set::GrowableBitSet;\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n use rustc_middle::ty::{\n-    self, GenericArg, GenericArgKind, GenericParamDefKind, InternalSubsts, SubstsRef,\n-    ToPolyTraitRef, ToPredicate, Ty, TyCtxt,\n+    self, Binder, GenericArg, GenericArgKind, GenericParamDefKind, InternalSubsts, SubstsRef,\n+    ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt,\n };\n use rustc_span::def_id::DefId;\n \n@@ -98,8 +98,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplSource::Future(vtable_future)\n             }\n \n-            FnPointerCandidate { .. } => {\n-                let data = self.confirm_fn_pointer_candidate(obligation)?;\n+            FnPointerCandidate { is_const } => {\n+                let data = self.confirm_fn_pointer_candidate(obligation, is_const)?;\n                 ImplSource::FnPointer(data)\n             }\n \n@@ -597,17 +597,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_fn_pointer_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n+        is_const: bool,\n     ) -> Result<ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n     {\n         debug!(?obligation, \"confirm_fn_pointer_candidate\");\n \n+        let tcx = self.tcx();\n         let self_ty = self\n             .infcx\n             .shallow_resolve(obligation.self_ty().no_bound_vars())\n             .expect(\"fn pointer should not capture bound vars from predicate\");\n-        let sig = self_ty.fn_sig(self.tcx());\n+        let sig = self_ty.fn_sig(tcx);\n         let trait_ref = closure_trait_ref_and_return_type(\n-            self.tcx(),\n+            tcx,\n             obligation.predicate.def_id(),\n             self_ty,\n             sig,\n@@ -616,9 +618,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         .map_bound(|(trait_ref, _)| trait_ref);\n \n         let mut nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n+        let cause = obligation.derived_cause(BuiltinDerivedObligation);\n+\n+        if obligation.is_const() && !is_const {\n+            // function is a trait method\n+            if let ty::FnDef(def_id, substs) = self_ty.kind() && let Some(trait_id) = tcx.trait_of_item(*def_id) {\n+                let trait_ref = TraitRef::from_method(tcx, trait_id, *substs);\n+                let poly_trait_pred = Binder::dummy(trait_ref).with_constness(ty::BoundConstness::ConstIfConst);\n+                let obligation = Obligation::new(tcx, cause.clone(), obligation.param_env, poly_trait_pred);\n+                nested.push(obligation);\n+            }\n+        }\n \n         // Confirm the `type Output: Sized;` bound that is present on `FnOnce`\n-        let cause = obligation.derived_cause(BuiltinDerivedObligation);\n         let output_ty = self.infcx.replace_bound_vars_with_placeholders(sig.output());\n         let output_ty = normalize_with_depth_to(\n             self,"}, {"sha": "760b4585f4e195fd95349960f7bb579c021794c2", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1374,6 +1374,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     FutureCandidate => {}\n                     // FnDef where the function is const\n                     FnPointerCandidate { is_const: true } => {}\n+                    FnPointerCandidate { is_const: false } => {\n+                        if let ty::FnDef(def_id, _) = obligation.self_ty().skip_binder().kind() && tcx.trait_of_item(*def_id).is_some() {\n+                            // Trait methods are not seen as const unless the trait is implemented as const.\n+                            // We do not filter that out in here, but nested obligations will be needed to confirm this.\n+                        } else {\n+                            continue\n+                        }\n+                    }\n                     ConstDestructCandidate(_) => {}\n                     _ => {\n                         // reject all other types of candidates"}, {"sha": "b5df583e3f4cbb94d5fb2e38aa1b7cab2ffd1d0a", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,6 +1,5 @@\n use rustc_errors::Diagnostic;\n use rustc_span::Span;\n-use smallvec::smallvec;\n use smallvec::SmallVec;\n \n use rustc_data_structures::fx::FxHashSet;"}, {"sha": "73d2d278f93f3bb0886c518448ba59ccd25c402c", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -273,9 +273,11 @@ fn adjust_for_rust_scalar<'tcx>(\n                 | PointerKind::UniqueBorrowed\n                 | PointerKind::UniqueBorrowedPinned => false,\n                 PointerKind::UniqueOwned => noalias_for_box,\n-                PointerKind::Frozen => !is_return,\n+                PointerKind::Frozen => true,\n             };\n-            if no_alias {\n+            // We can never add `noalias` in return position; that LLVM attribute has some very surprising semantics\n+            // (see <https://github.com/rust-lang/unsafe-code-guidelines/issues/385#issuecomment-1368055745>).\n+            if no_alias && !is_return {\n                 attrs.set(ArgAttribute::NoAlias);\n             }\n "}, {"sha": "8d46ba320fc031d56044b43e3a4225e711c02bfc", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -194,7 +194,7 @@ fn resolve_associated_item<'tcx>(\n                 && trait_item_id != leaf_def.item.def_id\n                 && let Some(leaf_def_item) = leaf_def.item.def_id.as_local()\n             {\n-                tcx.compare_assoc_const_impl_item_with_trait_item((\n+                tcx.compare_impl_const((\n                     leaf_def_item,\n                     trait_item_id,\n                 ))?;"}, {"sha": "a2fdec6fbfe7b18b3c0ae48fc9956935c885c8d6", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -23,7 +23,7 @@ extern \"Rust\" {\n     // These are the magic symbols to call the global allocator.  rustc generates\n     // them to call `__rg_alloc` etc. if there is a `#[global_allocator]` attribute\n     // (the code expanding that attribute macro generates those functions), or to call\n-    // the default implementations in libstd (`__rdl_alloc` etc. in `library/std/src/alloc.rs`)\n+    // the default implementations in std (`__rdl_alloc` etc. in `library/std/src/alloc.rs`)\n     // otherwise.\n     // The rustc fork of LLVM 14 and earlier also special-cases these function names to be able to optimize them\n     // like `malloc`, `realloc`, and `free`, respectively.\n@@ -404,19 +404,6 @@ pub mod __alloc_error_handler {\n     pub unsafe fn __rdl_oom(size: usize, _align: usize) -> ! {\n         panic!(\"memory allocation of {size} bytes failed\")\n     }\n-\n-    #[cfg(bootstrap)]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe fn __rg_oom(size: usize, align: usize) -> ! {\n-        use crate::alloc::Layout;\n-\n-        let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n-        extern \"Rust\" {\n-            #[lang = \"oom\"]\n-            fn oom_impl(layout: Layout) -> !;\n-        }\n-        unsafe { oom_impl(layout) }\n-    }\n }\n \n /// Specialize clones into pre-allocated, uninitialized memory."}, {"sha": "a563b2587236c57abdec2689aac5f1e1127cbde4", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -158,7 +158,6 @@ use core::hash::{Hash, Hasher};\n #[cfg(not(no_global_oom_handling))]\n use core::iter::FromIterator;\n use core::iter::{FusedIterator, Iterator};\n-#[cfg(not(bootstrap))]\n use core::marker::Tuple;\n use core::marker::{Destruct, Unpin, Unsize};\n use core::mem;\n@@ -954,7 +953,7 @@ impl<T: ?Sized> Box<T> {\n     /// [`Layout`]: crate::Layout\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n-    #[must_use = \"call `drop(from_raw(ptr))` if you intend to drop the `Box`\"]\n+    #[must_use = \"call `drop(Box::from_raw(ptr))` if you intend to drop the `Box`\"]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n         unsafe { Self::from_raw_in(raw, Global) }\n     }\n@@ -1981,17 +1980,6 @@ impl<I: ExactSizeIterator + ?Sized, A: Allocator> ExactSizeIterator for Box<I, A\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator + ?Sized, A: Allocator> FusedIterator for Box<I, A> {}\n \n-#[cfg(bootstrap)]\n-#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<Args, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n-    type Output = <F as FnOnce<Args>>::Output;\n-\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output {\n-        <F as FnOnce<Args>>::call_once(*self, args)\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args: Tuple, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n     type Output = <F as FnOnce<Args>>::Output;\n@@ -2001,31 +1989,13 @@ impl<Args: Tuple, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F\n     }\n }\n \n-#[cfg(bootstrap)]\n-#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<Args, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n-        <F as FnMut<Args>>::call_mut(self, args)\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args: Tuple, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n         <F as FnMut<Args>>::call_mut(self, args)\n     }\n }\n \n-#[cfg(bootstrap)]\n-#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<Args, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n-    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {\n-        <F as Fn<Args>>::call(self, args)\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args: Tuple, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {"}, {"sha": "fe08e0e10e818440c1e1cc9f3b05ae25748c18bb", "filename": "library/alloc/src/collections/binary_heap/tests.rs", "status": "modified", "additions": 74, "deletions": 24, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,8 +1,8 @@\n use super::*;\n use crate::boxed::Box;\n+use crate::testing::crash_test::{CrashTestDummy, Panic};\n use std::iter::TrustedLen;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicU32, Ordering};\n \n #[test]\n fn test_iterator() {\n@@ -291,33 +291,83 @@ fn test_drain_sorted() {\n \n #[test]\n fn test_drain_sorted_leak() {\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-\n-    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    struct D(u32, bool);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            DROPS.fetch_add(1, Ordering::SeqCst);\n-\n-            if self.1 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let d0 = CrashTestDummy::new(0);\n+    let d1 = CrashTestDummy::new(1);\n+    let d2 = CrashTestDummy::new(2);\n+    let d3 = CrashTestDummy::new(3);\n+    let d4 = CrashTestDummy::new(4);\n+    let d5 = CrashTestDummy::new(5);\n     let mut q = BinaryHeap::from(vec![\n-        D(0, false),\n-        D(1, false),\n-        D(2, false),\n-        D(3, true),\n-        D(4, false),\n-        D(5, false),\n+        d0.spawn(Panic::Never),\n+        d1.spawn(Panic::Never),\n+        d2.spawn(Panic::Never),\n+        d3.spawn(Panic::InDrop),\n+        d4.spawn(Panic::Never),\n+        d5.spawn(Panic::Never),\n     ]);\n \n-    catch_unwind(AssertUnwindSafe(|| drop(q.drain_sorted()))).ok();\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_sorted()))).unwrap_err();\n+\n+    assert_eq!(d0.dropped(), 1);\n+    assert_eq!(d1.dropped(), 1);\n+    assert_eq!(d2.dropped(), 1);\n+    assert_eq!(d3.dropped(), 1);\n+    assert_eq!(d4.dropped(), 1);\n+    assert_eq!(d5.dropped(), 1);\n+    assert!(q.is_empty());\n+}\n \n-    assert_eq!(DROPS.load(Ordering::SeqCst), 6);\n+#[test]\n+fn test_drain_forget() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+    let mut q =\n+        BinaryHeap::from(vec![a.spawn(Panic::Never), b.spawn(Panic::Never), c.spawn(Panic::Never)]);\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        let mut it = q.drain();\n+        it.next();\n+        mem::forget(it);\n+    }))\n+    .unwrap();\n+    // Behaviour after leaking is explicitly unspecified and order is arbitrary,\n+    // so it's fine if these start failing, but probably worth knowing.\n+    assert!(q.is_empty());\n+    assert_eq!(a.dropped() + b.dropped() + c.dropped(), 1);\n+    assert_eq!(a.dropped(), 0);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 1);\n+    drop(q);\n+    assert_eq!(a.dropped(), 0);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 1);\n+}\n+\n+#[test]\n+fn test_drain_sorted_forget() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+    let mut q =\n+        BinaryHeap::from(vec![a.spawn(Panic::Never), b.spawn(Panic::Never), c.spawn(Panic::Never)]);\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        let mut it = q.drain_sorted();\n+        it.next();\n+        mem::forget(it);\n+    }))\n+    .unwrap();\n+    // Behaviour after leaking is explicitly unspecified,\n+    // so it's fine if these start failing, but probably worth knowing.\n+    assert_eq!(q.len(), 2);\n+    assert_eq!(a.dropped(), 0);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 1);\n+    drop(q);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n }\n \n #[test]"}, {"sha": "700b1463bfd51f961e8b7bb2cb43e991c9473d4e", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,12 +1,12 @@\n-use super::super::testing::crash_test::{CrashTestDummy, Panic};\n-use super::super::testing::ord_chaos::{Cyclic3, Governed, Governor};\n-use super::super::testing::rng::DeterministicRng;\n use super::Entry::{Occupied, Vacant};\n use super::*;\n use crate::boxed::Box;\n use crate::fmt::Debug;\n use crate::rc::Rc;\n use crate::string::{String, ToString};\n+use crate::testing::crash_test::{CrashTestDummy, Panic};\n+use crate::testing::ord_chaos::{Cyclic3, Governed, Governor};\n+use crate::testing::rng::DeterministicRng;\n use crate::vec::Vec;\n use std::cmp::Ordering;\n use std::convert::TryFrom;"}, {"sha": "7552f2fc04ce8baf63f9db30ff7c7e07b254e542", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -21,6 +21,3 @@ trait Recover<Q: ?Sized> {\n     fn take(&mut self, key: &Q) -> Option<Self::Key>;\n     fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;\n }\n-\n-#[cfg(test)]\n-mod testing;"}, {"sha": "6912466448fab444c6860425ba5970a41ef75a8b", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -318,7 +318,10 @@ impl<BorrowType: marker::BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type>\n     pub fn ascend(\n         self,\n     ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n-        let _ = BorrowType::TRAVERSAL_PERMIT;\n+        const {\n+            assert!(BorrowType::TRAVERSAL_PERMIT);\n+        }\n+\n         // We need to use raw pointers to nodes because, if BorrowType is marker::ValMut,\n         // there might be outstanding mutable references to values that we must not invalidate.\n         let leaf_ptr: *const _ = Self::as_leaf_ptr(&self);\n@@ -1003,7 +1006,10 @@ impl<BorrowType: marker::BorrowType, K, V>\n     /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n     /// both, upon success, do nothing.\n     pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-        let _ = BorrowType::TRAVERSAL_PERMIT;\n+        const {\n+            assert!(BorrowType::TRAVERSAL_PERMIT);\n+        }\n+\n         // We need to use raw pointers to nodes because, if BorrowType is\n         // marker::ValMut, there might be outstanding mutable references to\n         // values that we must not invalidate. There's no worry accessing the\n@@ -1666,17 +1672,17 @@ pub mod marker {\n     pub struct ValMut<'a>(PhantomData<&'a mut ()>);\n \n     pub trait BorrowType {\n-        // If node references of this borrow type allow traversing to other\n-        // nodes in the tree, this constant can be evaluated. Thus reading it\n-        // serves as a compile-time assertion.\n-        const TRAVERSAL_PERMIT: () = ();\n+        /// If node references of this borrow type allow traversing to other\n+        /// nodes in the tree, this constant is set to `true`. It can be used\n+        /// for a compile-time assertion.\n+        const TRAVERSAL_PERMIT: bool = true;\n     }\n     impl BorrowType for Owned {\n-        // Reject evaluation, because traversal isn't needed. Instead traversal\n-        // happens using the result of `borrow_mut`.\n-        // By disabling traversal, and only creating new references to roots,\n-        // we know that every reference of the `Owned` type is to a root node.\n-        const TRAVERSAL_PERMIT: () = panic!();\n+        /// Reject traversal, because it isn't needed. Instead traversal\n+        /// happens using the result of `borrow_mut`.\n+        /// By disabling traversal, and only creating new references to roots,\n+        /// we know that every reference of the `Owned` type is to a root node.\n+        const TRAVERSAL_PERMIT: bool = false;\n     }\n     impl BorrowType for Dying {}\n     impl<'a> BorrowType for Immut<'a> {}"}, {"sha": "7b8d41a603176b07a1e3a6b648ab9cbac577f14d", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,6 +1,6 @@\n-use super::super::testing::crash_test::{CrashTestDummy, Panic};\n-use super::super::testing::rng::DeterministicRng;\n use super::*;\n+use crate::testing::crash_test::{CrashTestDummy, Panic};\n+use crate::testing::rng::DeterministicRng;\n use crate::vec::Vec;\n use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};"}, {"sha": "5d5af22bb292fcecb63aa65bf80c3f9a551c6732", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use crate::testing::crash_test::{CrashTestDummy, Panic};\n use crate::vec::Vec;\n \n use std::panic::{catch_unwind, AssertUnwindSafe};\n@@ -984,35 +985,34 @@ fn drain_filter_complex() {\n \n #[test]\n fn drain_filter_drop_panic_leak() {\n-    static mut DROPS: i32 = 0;\n-\n-    struct D(bool);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-\n-            if self.0 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let d0 = CrashTestDummy::new(0);\n+    let d1 = CrashTestDummy::new(1);\n+    let d2 = CrashTestDummy::new(2);\n+    let d3 = CrashTestDummy::new(3);\n+    let d4 = CrashTestDummy::new(4);\n+    let d5 = CrashTestDummy::new(5);\n+    let d6 = CrashTestDummy::new(6);\n+    let d7 = CrashTestDummy::new(7);\n     let mut q = LinkedList::new();\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_front(D(false));\n-    q.push_front(D(true));\n-    q.push_front(D(false));\n-\n-    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).ok();\n-\n-    assert_eq!(unsafe { DROPS }, 8);\n+    q.push_back(d3.spawn(Panic::Never));\n+    q.push_back(d4.spawn(Panic::Never));\n+    q.push_back(d5.spawn(Panic::Never));\n+    q.push_back(d6.spawn(Panic::Never));\n+    q.push_back(d7.spawn(Panic::Never));\n+    q.push_front(d2.spawn(Panic::Never));\n+    q.push_front(d1.spawn(Panic::InDrop));\n+    q.push_front(d0.spawn(Panic::Never));\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).unwrap_err();\n+\n+    assert_eq!(d0.dropped(), 1);\n+    assert_eq!(d1.dropped(), 1);\n+    assert_eq!(d2.dropped(), 1);\n+    assert_eq!(d3.dropped(), 1);\n+    assert_eq!(d4.dropped(), 1);\n+    assert_eq!(d5.dropped(), 1);\n+    assert_eq!(d6.dropped(), 1);\n+    assert_eq!(d7.dropped(), 1);\n     assert!(q.is_empty());\n }\n "}, {"sha": "9857f0516baa217f84fc0e66223c4e53bf0da7a4", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -3,7 +3,7 @@\n //! This library provides smart pointers and collections for managing\n //! heap-allocated values.\n //!\n-//! This library, like libcore, normally doesn\u2019t need to be used directly\n+//! This library, like core, normally doesn\u2019t need to be used directly\n //! since its contents are re-exported in the [`std` crate](../std/index.html).\n //! Crates that use the `#![no_std]` attribute however will typically\n //! not depend on `std`, so they\u2019d use this crate instead.\n@@ -75,7 +75,7 @@\n ))]\n #![no_std]\n #![needs_allocator]\n-// To run liballoc tests without x.py without ending up with two copies of liballoc, Miri needs to be\n+// To run alloc tests without x.py without ending up with two copies of alloc, Miri needs to be\n // able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n // rustc itself never sets the feature, so this line has no affect there.\n #![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n@@ -122,6 +122,7 @@\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n #![feature(hasher_prefixfree_extras)]\n+#![feature(inline_const)]\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n #![feature(iter_next_chunk)]\n@@ -152,7 +153,7 @@\n #![feature(trusted_len)]\n #![feature(trusted_random_access)]\n #![feature(try_trait_v2)]\n-#![cfg_attr(not(bootstrap), feature(tuple_trait))]\n+#![feature(tuple_trait)]\n #![feature(unchecked_math)]\n #![feature(unicode_internals)]\n #![feature(unsize)]\n@@ -206,6 +207,8 @@\n extern crate std;\n #[cfg(test)]\n extern crate test;\n+#[cfg(test)]\n+mod testing;\n \n // Module with internal macros used by other modules (needs to be included before other modules).\n #[macro_use]"}, {"sha": "4cfb2def09804ed3387b899c756f4712b26c52fa", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -653,7 +653,7 @@ impl [u8] {\n ///\n /// ```error\n /// error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predica\n-///    --> src/liballoc/slice.rs:608:6\n+///    --> library/alloc/src/slice.rs:608:6\n ///     |\n /// 608 | impl<T: Clone, V: Borrow<[T]>> Concat for [V] {\n ///     |      ^ unconstrained type parameter"}, {"sha": "24f1b3a1c87509888ff5cc3dacf45679732942c0", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -363,7 +363,7 @@ use crate::vec::Vec;\n /// [`as_str()`]: String::as_str\n #[derive(PartialOrd, Eq, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(all(not(bootstrap), not(test)), lang = \"String\")]\n+#[cfg_attr(not(test), lang = \"String\")]\n pub struct String {\n     vec: Vec<u8>,\n }\n@@ -2678,7 +2678,7 @@ impl From<&String> for String {\n     }\n }\n \n-// note: test pulls in libstd, which causes errors here\n+// note: test pulls in std, which causes errors here\n #[cfg(not(test))]\n #[stable(feature = \"string_from_box\", since = \"1.18.0\")]\n impl From<Box<str>> for String {"}, {"sha": "bcf5f5f72510e199093cf978e87411166e3003bc", "filename": "library/alloc/src/testing/crash_test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Ftesting%2Fcrash_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Ftesting%2Fcrash_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftesting%2Fcrash_test.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "previous_filename": "library/alloc/src/collections/btree/testing/crash_test.rs"}, {"sha": "7a094f8a59522216ad1891e2beac432695737300", "filename": "library/alloc/src/testing/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Ftesting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Ftesting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftesting%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "previous_filename": "library/alloc/src/collections/btree/testing/mod.rs"}, {"sha": "96ce7c15790463b3770285f6395859d64ea9afdc", "filename": "library/alloc/src/testing/ord_chaos.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Ftesting%2Ford_chaos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Ftesting%2Ford_chaos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftesting%2Ford_chaos.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "previous_filename": "library/alloc/src/collections/btree/testing/ord_chaos.rs"}, {"sha": "ecf543bee035a38a9adc7f08360c5c57876290c7", "filename": "library/alloc/src/testing/rng.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Ftesting%2Frng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Ftesting%2Frng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftesting%2Frng.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "previous_filename": "library/alloc/src/collections/btree/testing/rng.rs"}, {"sha": "1da73862d4a924634e73146b9b4c6fb2b1508698", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -166,7 +166,7 @@ mod spec_extend;\n /// vec[0] = 7;\n /// assert_eq!(vec[0], 7);\n ///\n-/// vec.extend([1, 2, 3].iter().copied());\n+/// vec.extend([1, 2, 3]);\n ///\n /// for x in &vec {\n ///     println!(\"{x}\");\n@@ -3191,7 +3191,7 @@ where\n     }\n }\n \n-// note: test pulls in libstd, which causes errors here\n+// note: test pulls in std, which causes errors here\n #[cfg(not(test))]\n #[stable(feature = \"vec_from_box\", since = \"1.18.0\")]\n impl<T, A: Allocator> From<Box<[T], A>> for Vec<T, A> {\n@@ -3209,7 +3209,7 @@ impl<T, A: Allocator> From<Box<[T], A>> for Vec<T, A> {\n     }\n }\n \n-// note: test pulls in libstd, which causes errors here\n+// note: test pulls in std, which causes errors here\n #[cfg(not(no_global_oom_handling))]\n #[cfg(not(test))]\n #[stable(feature = \"box_from_vec\", since = \"1.20.0\")]"}, {"sha": "879e32b3fa309ce7190f94dc8fd167e9900a4229", "filename": "library/alloc/tests/autotraits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Ftests%2Fautotraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Ftests%2Fautotraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fautotraits.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -32,7 +32,7 @@ fn test_btree_map() {\n     //         spawn(f());\n     //     }\n     //\n-    // where with some unintentionally overconstrained Send impls in liballoc's\n+    // where with some unintentionally overconstrained Send impls in alloc's\n     // internals, the future might incorrectly not be Send even though every\n     // single type involved in the program is Send and Sync.\n     require_send_sync(async {"}, {"sha": "87adcead8f62d69ba7dbcdcb4c5f331aa276b414", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -7,7 +7,9 @@ use std::borrow::Cow;\n use std::cell::Cell;\n use std::collections::TryReserveErrorKind::*;\n use std::fmt::Debug;\n+use std::hint;\n use std::iter::InPlaceIterable;\n+use std::mem;\n use std::mem::{size_of, swap};\n use std::ops::Bound::*;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n@@ -1107,8 +1109,31 @@ fn test_into_iter_drop_allocator() {\n \n #[test]\n fn test_into_iter_zst() {\n-    for _ in vec![[0u64; 0]].into_iter() {}\n-    for _ in vec![[0u64; 0]; 5].into_iter().rev() {}\n+    #[derive(Debug, Clone)]\n+    struct AlignedZstWithDrop([u64; 0]);\n+    impl Drop for AlignedZstWithDrop {\n+        fn drop(&mut self) {\n+            let addr = self as *mut _ as usize;\n+            assert!(hint::black_box(addr) % mem::align_of::<u64>() == 0);\n+        }\n+    }\n+\n+    const C: AlignedZstWithDrop = AlignedZstWithDrop([0u64; 0]);\n+\n+    for _ in vec![C].into_iter() {}\n+    for _ in vec![C; 5].into_iter().rev() {}\n+\n+    let mut it = vec![C, C].into_iter();\n+    it.advance_by(1).unwrap();\n+    drop(it);\n+\n+    let mut it = vec![C, C].into_iter();\n+    it.next_chunk::<1>().unwrap();\n+    drop(it);\n+\n+    let mut it = vec![C, C].into_iter();\n+    it.next_chunk::<4>().unwrap_err();\n+    drop(it);\n }\n \n #[test]"}, {"sha": "9ca4947ed8f8bb7978870a8a6c01880f7b1d8bdc", "filename": "library/core/src/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -148,7 +148,7 @@\n //! ```\n //!\n //! In this example, if the concrete type of `obj` in `use_my_trait` is `SomeConcreteType`, then\n-//! the `get_context_ref` call will return a reference to `obj.some_string` with type `&String`.\n+//! the `get_context_by_ref` call will return a reference to `obj.some_string` with type `&String`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "129213fde7491c8ef02040003c6dc7314af694de", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -807,7 +807,8 @@ impl<T> RefCell<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value in either `RefCell` is currently borrowed.\n+    /// Panics if the value in either `RefCell` is currently borrowed, or\n+    /// if `self` and `other` point to the same `RefCell`.\n     ///\n     /// # Examples\n     ///\n@@ -1193,7 +1194,7 @@ impl<T: Default> Default for RefCell<T> {\n impl<T: ?Sized + PartialEq> PartialEq for RefCell<T> {\n     /// # Panics\n     ///\n-    /// Panics if the value in either `RefCell` is currently borrowed.\n+    /// Panics if the value in either `RefCell` is currently mutably borrowed.\n     #[inline]\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n@@ -1207,39 +1208,39 @@ impl<T: ?Sized + Eq> Eq for RefCell<T> {}\n impl<T: ?Sized + PartialOrd> PartialOrd for RefCell<T> {\n     /// # Panics\n     ///\n-    /// Panics if the value in either `RefCell` is currently borrowed.\n+    /// Panics if the value in either `RefCell` is currently mutably borrowed.\n     #[inline]\n     fn partial_cmp(&self, other: &RefCell<T>) -> Option<Ordering> {\n         self.borrow().partial_cmp(&*other.borrow())\n     }\n \n     /// # Panics\n     ///\n-    /// Panics if the value in either `RefCell` is currently borrowed.\n+    /// Panics if the value in either `RefCell` is currently mutably borrowed.\n     #[inline]\n     fn lt(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() < *other.borrow()\n     }\n \n     /// # Panics\n     ///\n-    /// Panics if the value in either `RefCell` is currently borrowed.\n+    /// Panics if the value in either `RefCell` is currently mutably borrowed.\n     #[inline]\n     fn le(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() <= *other.borrow()\n     }\n \n     /// # Panics\n     ///\n-    /// Panics if the value in either `RefCell` is currently borrowed.\n+    /// Panics if the value in either `RefCell` is currently mutably borrowed.\n     #[inline]\n     fn gt(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() > *other.borrow()\n     }\n \n     /// # Panics\n     ///\n-    /// Panics if the value in either `RefCell` is currently borrowed.\n+    /// Panics if the value in either `RefCell` is currently mutably borrowed.\n     #[inline]\n     fn ge(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() >= *other.borrow()\n@@ -1250,7 +1251,7 @@ impl<T: ?Sized + PartialOrd> PartialOrd for RefCell<T> {\n impl<T: ?Sized + Ord> Ord for RefCell<T> {\n     /// # Panics\n     ///\n-    /// Panics if the value in either `RefCell` is currently borrowed.\n+    /// Panics if the value in either `RefCell` is currently mutably borrowed.\n     #[inline]\n     fn cmp(&self, other: &RefCell<T>) -> Ordering {\n         self.borrow().cmp(&*other.borrow())\n@@ -1783,7 +1784,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// until the reference expires. As a special exception, given an `&T`, any part of it that is\n /// inside an `UnsafeCell<_>` may be deallocated during the lifetime of the reference, after the\n /// last time the reference is used (dereferenced or reborrowed). Since you cannot deallocate a part\n-/// of what a reference points to, this means the memory an `&T` points to can be deallocted only if\n+/// of what a reference points to, this means the memory an `&T` points to can be deallocated only if\n /// *every part of it* (including padding) is inside an `UnsafeCell`.\n ///\n ///     However, whenever a `&UnsafeCell<T>` is constructed or dereferenced, it must still point to\n@@ -1993,7 +1994,7 @@ impl<T: ?Sized> UnsafeCell<T> {\n     #[rustc_const_stable(feature = \"const_unsafecell_get\", since = \"1.32.0\")]\n     pub const fn get(&self) -> *mut T {\n         // We can just cast the pointer from `UnsafeCell<T>` to `T` because of\n-        // #[repr(transparent)]. This exploits libstd's special status, there is\n+        // #[repr(transparent)]. This exploits std's special status, there is\n         // no guarantee for user code that this will work in future versions of the compiler!\n         self as *const UnsafeCell<T> as *const T as *mut T\n     }\n@@ -2051,7 +2052,7 @@ impl<T: ?Sized> UnsafeCell<T> {\n     #[rustc_const_stable(feature = \"unsafe_cell_raw_get\", since = \"1.56.0\")]\n     pub const fn raw_get(this: *const Self) -> *mut T {\n         // We can just cast the pointer from `UnsafeCell<T>` to `T` because of\n-        // #[repr(transparent)]. This exploits libstd's special status, there is\n+        // #[repr(transparent)]. This exploits std's special status, there is\n         // no guarantee for user code that this will work in future versions of the compiler!\n         this as *const T as *mut T\n     }"}, {"sha": "65d12c25c51a48a13c7ddb7de65e233447764827", "filename": "library/core/src/cell/lazy.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -35,7 +35,7 @@ pub struct LazyCell<T, F = fn() -> T> {\n     init: Cell<Option<F>>,\n }\n \n-impl<T, F> LazyCell<T, F> {\n+impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n     /// Creates a new lazy value with the given initializing function.\n     ///\n     /// # Examples\n@@ -51,13 +51,12 @@ impl<T, F> LazyCell<T, F> {\n     ///\n     /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new(init: F) -> LazyCell<T, F> {\n         LazyCell { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n     }\n-}\n \n-impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n     /// Forces the evaluation of this lazy value and returns a reference to\n     /// the result.\n     ///\n@@ -75,6 +74,7 @@ impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n     /// assert_eq!(LazyCell::force(&lazy), &92);\n     /// assert_eq!(&*lazy, &92);\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn force(this: &LazyCell<T, F>) -> &T {\n         this.cell.get_or_init(|| match this.init.take() {\n@@ -87,6 +87,7 @@ impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T, F: FnOnce() -> T> Deref for LazyCell<T, F> {\n     type Target = T;\n+    #[inline]\n     fn deref(&self) -> &T {\n         LazyCell::force(self)\n     }\n@@ -95,6 +96,7 @@ impl<T, F: FnOnce() -> T> Deref for LazyCell<T, F> {\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Default> Default for LazyCell<T> {\n     /// Creates a new lazy value using `Default` as the initializing function.\n+    #[inline]\n     fn default() -> LazyCell<T> {\n         LazyCell::new(T::default)\n     }"}, {"sha": "7757068a4f2b97cbdbf606c90078e1d0fc3925ff", "filename": "library/core/src/cell/once.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -37,15 +37,17 @@ pub struct OnceCell<T> {\n \n impl<T> OnceCell<T> {\n     /// Creates a new empty cell.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    #[inline]\n     #[must_use]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new() -> OnceCell<T> {\n         OnceCell { inner: UnsafeCell::new(None) }\n     }\n \n     /// Gets the reference to the underlying value.\n     ///\n     /// Returns `None` if the cell is empty.\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get(&self) -> Option<&T> {\n         // SAFETY: Safe due to `inner`'s invariant\n@@ -55,6 +57,7 @@ impl<T> OnceCell<T> {\n     /// Gets the mutable reference to the underlying value.\n     ///\n     /// Returns `None` if the cell is empty.\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_mut(&mut self) -> Option<&mut T> {\n         self.inner.get_mut().as_mut()\n@@ -82,6 +85,7 @@ impl<T> OnceCell<T> {\n     ///\n     /// assert!(cell.get().is_some());\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn set(&self, value: T) -> Result<(), T> {\n         // SAFETY: Safe because we cannot have overlapping mutable borrows\n@@ -123,6 +127,7 @@ impl<T> OnceCell<T> {\n     /// let value = cell.get_or_init(|| unreachable!());\n     /// assert_eq!(value, &92);\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_or_init<F>(&self, f: F) -> &T\n     where\n@@ -205,6 +210,7 @@ impl<T> OnceCell<T> {\n     /// cell.set(\"hello\".to_string()).unwrap();\n     /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn into_inner(self) -> Option<T> {\n         // Because `into_inner` takes `self` by value, the compiler statically verifies\n@@ -233,6 +239,7 @@ impl<T> OnceCell<T> {\n     /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n     /// assert_eq!(cell.get(), None);\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn take(&mut self) -> Option<T> {\n         mem::take(self).into_inner()\n@@ -241,6 +248,7 @@ impl<T> OnceCell<T> {\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T> Default for OnceCell<T> {\n+    #[inline]\n     fn default() -> Self {\n         Self::new()\n     }\n@@ -258,6 +266,7 @@ impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Clone> Clone for OnceCell<T> {\n+    #[inline]\n     fn clone(&self) -> OnceCell<T> {\n         let res = OnceCell::new();\n         if let Some(value) = self.get() {\n@@ -272,6 +281,7 @@ impl<T: Clone> Clone for OnceCell<T> {\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: PartialEq> PartialEq for OnceCell<T> {\n+    #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.get() == other.get()\n     }\n@@ -283,6 +293,7 @@ impl<T: Eq> Eq for OnceCell<T> {}\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T> const From<T> for OnceCell<T> {\n     /// Creates a new `OnceCell<T>` which already contains the given `value`.\n+    #[inline]\n     fn from(value: T) -> Self {\n         OnceCell { inner: UnsafeCell::new(Some(value)) }\n     }"}, {"sha": "eeb08803040879e86838543411d0f6bd2fcb2fca", "filename": "library/core/src/char/decode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fdecode.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -67,7 +67,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n             }\n \n             // all ok, so lets decode it.\n-            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            let c = (((u & 0x3ff) as u32) << 10 | (u2 & 0x3ff) as u32) + 0x1_0000;\n             // SAFETY: we checked that it's a legal unicode value\n             Some(Ok(unsafe { from_u32_unchecked(c) }))\n         }"}, {"sha": "3e7383b4cd199fa5996a6429a2151819d5a5b55b", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -140,7 +140,7 @@ impl char {\n     /// assert_eq!(None, c);\n     /// ```\n     #[stable(feature = \"assoc_char_funcs\", since = \"1.52.0\")]\n-    #[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_char_convert\", since = \"1.67.0\")]\n     #[must_use]\n     #[inline]\n     pub const fn from_u32(i: u32) -> Option<char> {\n@@ -241,7 +241,7 @@ impl char {\n     /// let _c = char::from_digit(1, 37);\n     /// ```\n     #[stable(feature = \"assoc_char_funcs\", since = \"1.52.0\")]\n-    #[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_char_convert\", since = \"1.67.0\")]\n     #[must_use]\n     #[inline]\n     pub const fn from_digit(num: u32, radix: u32) -> Option<char> {\n@@ -338,7 +338,7 @@ impl char {\n     /// let _ = '1'.to_digit(37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_char_convert\", since = \"1.67.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n     #[inline]"}, {"sha": "af98059cf42c3e36d882e031ed7a2bd770a10c9f", "filename": "library/core/src/char/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -110,7 +110,7 @@ pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::Into\n \n /// Converts a `u32` to a `char`. Use [`char::from_u32`] instead.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[rustc_const_stable(feature = \"const_char_convert\", since = \"1.67.0\")]\n #[must_use]\n #[inline]\n pub const fn from_u32(i: u32) -> Option<char> {\n@@ -130,7 +130,7 @@ pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n \n /// Converts a digit in the given radix to a `char`. Use [`char::from_digit`] instead.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_stable(feature = \"const_char_convert\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[rustc_const_stable(feature = \"const_char_convert\", since = \"1.67.0\")]\n #[must_use]\n #[inline]\n pub const fn from_digit(num: u32, radix: u32) -> Option<char> {"}, {"sha": "ebf5baa3c020bf898a68c25094675f4f0422e81d", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -24,8 +24,6 @@\n \n use crate::const_closure::ConstFnMutClosure;\n use crate::marker::Destruct;\n-#[cfg(bootstrap)]\n-use crate::marker::StructuralPartialEq;\n \n use self::Ordering::*;\n \n@@ -333,7 +331,7 @@ pub struct AssertParamIsEq<T: Eq + ?Sized> {\n /// assert_eq!(Ordering::Greater, result);\n /// ```\n #[derive(Clone, Copy, Eq, Debug, Hash)]\n-#[cfg_attr(not(bootstrap), derive_const(PartialOrd, Ord, PartialEq))]\n+#[derive_const(PartialOrd, Ord, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(i8)]\n pub enum Ordering {\n@@ -800,9 +798,12 @@ pub trait Ord: Eq + PartialOrd<Self> {\n         Self: Sized,\n         Self: ~const Destruct,\n     {\n-        // HACK(fee1-dead): go back to using `self.max_by(other, Ord::cmp)`\n-        // when trait methods are allowed to be used when a const closure is\n-        // expected.\n+        #[cfg(not(bootstrap))]\n+        {\n+            max_by(self, other, Ord::cmp)\n+        }\n+\n+        #[cfg(bootstrap)]\n         match self.cmp(&other) {\n             Ordering::Less | Ordering::Equal => other,\n             Ordering::Greater => self,\n@@ -827,9 +828,12 @@ pub trait Ord: Eq + PartialOrd<Self> {\n         Self: Sized,\n         Self: ~const Destruct,\n     {\n-        // HACK(fee1-dead): go back to using `self.min_by(other, Ord::cmp)`\n-        // when trait methods are allowed to be used when a const closure is\n-        // expected.\n+        #[cfg(not(bootstrap))]\n+        {\n+            min_by(self, other, Ord::cmp)\n+        }\n+\n+        #[cfg(bootstrap)]\n         match self.cmp(&other) {\n             Ordering::Less | Ordering::Equal => self,\n             Ordering::Greater => other,\n@@ -879,40 +883,6 @@ pub macro Ord($item:item) {\n     /* compiler built-in */\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(bootstrap)]\n-impl StructuralPartialEq for Ordering {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-#[cfg(bootstrap)]\n-impl const PartialEq for Ordering {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        (*self as i32).eq(&(*other as i32))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-#[cfg(bootstrap)]\n-impl const Ord for Ordering {\n-    #[inline]\n-    fn cmp(&self, other: &Ordering) -> Ordering {\n-        (*self as i32).cmp(&(*other as i32))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-#[cfg(bootstrap)]\n-impl const PartialOrd for Ordering {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n-        (*self as i32).partial_cmp(&(*other as i32))\n-    }\n-}\n-\n /// Trait for types that form a [partial order](https://en.wikipedia.org/wiki/Partial_order).\n ///\n /// The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using"}, {"sha": "97900a4862f5653fc49c537fdc95c3690d71d9a0", "filename": "library/core/src/const_closure.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fconst_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fconst_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconst_closure.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,5 +1,4 @@\n use crate::marker::Destruct;\n-#[cfg(not(bootstrap))]\n use crate::marker::Tuple;\n \n /// Struct representing a closure with mutably borrowed data.\n@@ -46,33 +45,6 @@ impl<'a, CapturedData: ?Sized, Function> ConstFnMutClosure<&'a mut CapturedData,\n \n macro_rules! impl_fn_mut_tuple {\n     ($($var:ident)*) => {\n-        #[cfg(bootstrap)]\n-        #[allow(unused_parens)]\n-        impl<'a, $($var,)* ClosureArguments, Function, ClosureReturnValue> const\n-            FnOnce<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n-        where\n-            Function: ~const Fn(($(&mut $var),*), ClosureArguments) -> ClosureReturnValue + ~const Destruct,\n-        {\n-            type Output = ClosureReturnValue;\n-\n-            extern \"rust-call\" fn call_once(mut self, args: ClosureArguments) -> Self::Output {\n-            self.call_mut(args)\n-            }\n-        }\n-        #[cfg(bootstrap)]\n-        #[allow(unused_parens)]\n-        impl<'a, $($var,)* ClosureArguments, Function, ClosureReturnValue> const\n-            FnMut<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n-        where\n-            Function: ~const Fn(($(&mut $var),*), ClosureArguments)-> ClosureReturnValue + ~const Destruct,\n-        {\n-            extern \"rust-call\" fn call_mut(&mut self, args: ClosureArguments) -> Self::Output {\n-                #[allow(non_snake_case)]\n-                let ($($var),*) = &mut self.data;\n-                (self.func)(($($var),*), args)\n-            }\n-        }\n-        #[cfg(not(bootstrap))]\n         #[allow(unused_parens)]\n         impl<'a, $($var,)* ClosureArguments: Tuple, Function, ClosureReturnValue> const\n             FnOnce<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n@@ -85,7 +57,6 @@ macro_rules! impl_fn_mut_tuple {\n             self.call_mut(args)\n             }\n         }\n-        #[cfg(not(bootstrap))]\n         #[allow(unused_parens)]\n         impl<'a, $($var,)* ClosureArguments: Tuple, Function, ClosureReturnValue> const\n             FnMut<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>"}, {"sha": "51e6a76cea848c540ac8a6beda22fa434c7a6e88", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -558,7 +558,7 @@ impl Display for Arguments<'_> {\n ///\n /// Derived `Debug` formats are not stable, and so may change with future Rust\n /// versions. Additionally, `Debug` implementations of types provided by the\n-/// standard library (`libstd`, `libcore`, `liballoc`, etc.) are not stable, and\n+/// standard library (`std`, `core`, `alloc`, etc.) are not stable, and\n /// may also change with future Rust versions.\n ///\n /// # Examples"}, {"sha": "5bfe001de46e3775f456a9c42c026b0b4230e253", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -44,7 +44,7 @@ pub use poll_fn::{poll_fn, PollFn};\n ///    non-Send/Sync as well, and we don't want that.\n ///\n /// It also simplifies the HIR lowering of `.await`.\n-#[cfg_attr(not(bootstrap), lang = \"ResumeTy\")]\n+#[lang = \"ResumeTy\"]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Debug, Copy, Clone)]\n@@ -61,7 +61,6 @@ unsafe impl Sync for ResumeTy {}\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n // This is `const` to avoid extra errors after we recover from `const async fn`\n-#[cfg_attr(bootstrap, lang = \"from_generator\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[rustc_const_unstable(feature = \"gen_future\", issue = \"50547\")]\n@@ -113,10 +112,10 @@ pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n     unsafe { &mut *cx.0.as_ptr().cast() }\n }\n \n-#[cfg_attr(not(bootstrap), lang = \"identity_future\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]\n+#[lang = \"identity_future\"]\n pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n     f\n }"}, {"sha": "a315a28fb0d943f24deb882e1cdf8937637c5315", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -55,7 +55,6 @@\n #![allow(missing_docs)]\n \n use crate::marker::DiscriminantKind;\n-#[cfg(not(bootstrap))]\n use crate::marker::Tuple;\n use crate::mem;\n \n@@ -2175,66 +2174,6 @@ extern \"rust-intrinsic\" {\n     /// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n     /// which violates the principle that a `const fn` must behave the same at\n     /// compile-time and at run-time. The unsafe code in crate B is fine.\n-    #[cfg(bootstrap)]\n-    #[rustc_const_unstable(feature = \"const_eval_select\", issue = \"none\")]\n-    pub fn const_eval_select<ARG, F, G, RET>(arg: ARG, called_in_const: F, called_at_rt: G) -> RET\n-    where\n-        G: FnOnce<ARG, Output = RET>,\n-        F: FnOnce<ARG, Output = RET>;\n-\n-    /// Selects which function to call depending on the context.\n-    ///\n-    /// If this function is evaluated at compile-time, then a call to this\n-    /// intrinsic will be replaced with a call to `called_in_const`. It gets\n-    /// replaced with a call to `called_at_rt` otherwise.\n-    ///\n-    /// # Type Requirements\n-    ///\n-    /// The two functions must be both function items. They cannot be function\n-    /// pointers or closures. The first function must be a `const fn`.\n-    ///\n-    /// `arg` will be the tupled arguments that will be passed to either one of\n-    /// the two functions, therefore, both functions must accept the same type of\n-    /// arguments. Both functions must return RET.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The two functions must behave observably equivalent. Safe code in other\n-    /// crates may assume that calling a `const fn` at compile-time and at run-time\n-    /// produces the same result. A function that produces a different result when\n-    /// evaluated at run-time, or has any other observable side-effects, is\n-    /// *unsound*.\n-    ///\n-    /// Here is an example of how this could cause a problem:\n-    /// ```no_run\n-    /// #![feature(const_eval_select)]\n-    /// #![feature(core_intrinsics)]\n-    /// use std::hint::unreachable_unchecked;\n-    /// use std::intrinsics::const_eval_select;\n-    ///\n-    /// // Crate A\n-    /// pub const fn inconsistent() -> i32 {\n-    ///     fn runtime() -> i32 { 1 }\n-    ///     const fn compiletime() -> i32 { 2 }\n-    ///\n-    ///     unsafe {\n-    //          // \u26a0 This code violates the required equivalence of `compiletime`\n-    ///         // and `runtime`.\n-    ///         const_eval_select((), compiletime, runtime)\n-    ///     }\n-    /// }\n-    ///\n-    /// // Crate B\n-    /// const X: i32 = inconsistent();\n-    /// let x = inconsistent();\n-    /// if x != X { unsafe { unreachable_unchecked(); }}\n-    /// ```\n-    ///\n-    /// This code causes Undefined Behavior when being run, since the\n-    /// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n-    /// which violates the principle that a `const fn` must behave the same at\n-    /// compile-time and at run-time. The unsafe code in crate B is fine.\n-    #[cfg(not(bootstrap))]\n     #[rustc_const_unstable(feature = \"const_eval_select\", issue = \"none\")]\n     pub fn const_eval_select<ARG: Tuple, F, G, RET>(\n         arg: ARG,\n@@ -2281,7 +2220,7 @@ macro_rules! assert_unsafe_precondition {\n             fn runtime$(<$($tt)*>)?($($i:$ty),*) {\n                 if !$e {\n                     // don't unwind to reduce impact on code size\n-                    ::core::panicking::panic_str_nounwind(\n+                    ::core::panicking::panic_nounwind(\n                         concat!(\"unsafe precondition(s) violated: \", $name)\n                     );\n                 }"}, {"sha": "399d54f18c5b3803b7b4d3fc69da33dccbf8e692", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -60,7 +60,8 @@\n //!\n //! # Examples\n //!\n-//! ```rust\n+#![cfg_attr(bootstrap, doc = \"```rust,compile_fail\")]\n+#![cfg_attr(not(bootstrap), doc = \"```rust\")]\n //! #![feature(core_intrinsics, custom_mir)]\n //!\n //! extern crate core;\n@@ -291,7 +292,8 @@ define!(\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    #[cfg_attr(bootstrap, doc = \"```rust,compile_fail\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```rust\")]\n     /// #![feature(custom_mir, core_intrinsics)]\n     ///\n     /// extern crate core;"}, {"sha": "617dfd12383fb649e9e76ab8f9fed16e06ecec6b", "filename": "library/core/src/iter/sources/empty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -22,17 +22,12 @@ pub const fn empty<T>() -> Empty<T> {\n     Empty(marker::PhantomData)\n }\n \n-// Newtype for use in `PhantomData` to avoid\n-// > error: const-stable function cannot use `#[feature(const_fn_fn_ptr_basics)]`\n-// in `const fn empty<T>()` above.\n-struct FnReturning<T>(fn() -> T);\n-\n /// An iterator that yields nothing.\n ///\n /// This `struct` is created by the [`empty()`] function. See its documentation for more.\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-pub struct Empty<T>(marker::PhantomData<FnReturning<T>>);\n+pub struct Empty<T>(marker::PhantomData<fn() -> T>);\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<T> fmt::Debug for Empty<T> {"}, {"sha": "fc4d4bff24f33f4a9d58a2953dd9ef562b75cf2b", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -66,6 +66,7 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub trait Iterator {\n     /// The type of the elements being iterated over.\n+    #[rustc_diagnostic_item = \"IteratorItem\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n@@ -803,7 +804,7 @@ pub trait Iterator {\n     /// (0..5).map(|x| x * 2 + 1)\n     ///       .for_each(move |x| tx.send(x).unwrap());\n     ///\n-    /// let v: Vec<_> =  rx.iter().collect();\n+    /// let v: Vec<_> = rx.iter().collect();\n     /// assert_eq!(v, vec![1, 3, 5, 7, 9]);\n     /// ```\n     ///\n@@ -1380,8 +1381,8 @@ pub trait Iterator {\n         Take::new(self, n)\n     }\n \n-    /// An iterator adapter similar to [`fold`] that holds internal state and\n-    /// produces a new iterator.\n+    /// An iterator adapter which, like [`fold`], holds internal state, but\n+    /// unlike [`fold`], produces a new iterator.\n     ///\n     /// [`fold`]: Iterator::fold\n     ///\n@@ -1393,20 +1394,25 @@ pub trait Iterator {\n     ///\n     /// On iteration, the closure will be applied to each element of the\n     /// iterator and the return value from the closure, an [`Option`], is\n-    /// yielded by the iterator.\n+    /// returned by the `next` method. Thus the closure can return\n+    /// `Some(value)` to yield `value`, or `None` to end the iteration.\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// let a = [1, 2, 3];\n+    /// let a = [1, 2, 3, 4];\n     ///\n     /// let mut iter = a.iter().scan(1, |state, &x| {\n-    ///     // each iteration, we'll multiply the state by the element\n+    ///     // each iteration, we'll multiply the state by the element ...\n     ///     *state = *state * x;\n     ///\n-    ///     // then, we'll yield the negation of the state\n+    ///     // ... and terminate if the state exceeds 6\n+    ///     if *state > 6 {\n+    ///         return None;\n+    ///     }\n+    ///     // ... else yield the negation of the state\n     ///     Some(-*state)\n     /// });\n     ///\n@@ -2653,7 +2659,10 @@ pub trait Iterator {\n     /// argument is a double reference. You can see this effect in the\n     /// examples below, with `&&x`.\n     ///\n+    /// If you need the index of the element, see [`position()`].\n+    ///\n     /// [`Some(element)`]: Some\n+    /// [`position()`]: Iterator::position\n     ///\n     /// # Examples\n     ///"}, {"sha": "0e3fef4ead31aefd1703f83966fffe0ce6ecb6af", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -38,18 +38,18 @@\n //!    which do not trigger a panic can be assured that this function is never\n //!    called. The `lang` attribute is called `eh_personality`.\n \n-// Since libcore defines many fundamental lang items, all tests live in a\n-// separate crate, libcoretest, to avoid bizarre issues.\n+// Since core defines many fundamental lang items, all tests live in a\n+// separate crate, libcoretest (library/core/tests), to avoid bizarre issues.\n //\n // Here we explicitly #[cfg]-out this whole crate when testing. If we don't do\n // this, both the generated test artifact and the linked libtest (which\n-// transitively includes libcore) will both define the same set of lang items,\n+// transitively includes core) will both define the same set of lang items,\n // and this will cause the E0152 \"found duplicate lang item\" error. See\n // discussion in #50466 for details.\n //\n // This cfg won't affect doc tests.\n #![cfg(not(test))]\n-// To run libcore tests without x.py without ending up with two copies of libcore, Miri needs to be\n+// To run core tests without x.py without ending up with two copies of core, Miri needs to be\n // able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n // rustc itself never sets the feature, so this line has no affect there.\n #![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n@@ -194,7 +194,7 @@\n #![feature(const_refs_to_cell)]\n #![feature(decl_macro)]\n #![feature(deprecated_suggestion)]\n-#![cfg_attr(not(bootstrap), feature(derive_const))]\n+#![feature(derive_const)]\n #![feature(doc_cfg)]\n #![feature(doc_notable_trait)]\n #![feature(rustdoc_internals)]\n@@ -309,7 +309,7 @@ pub mod f64;\n #[macro_use]\n pub mod num;\n \n-/* The libcore prelude, not as all-encompassing as the libstd prelude */\n+/* The core prelude, not as all-encompassing as the std prelude */\n \n pub mod prelude;\n \n@@ -376,12 +376,12 @@ mod const_closure;\n #[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n pub mod primitive;\n \n-// Pull in the `core_arch` crate directly into libcore. The contents of\n+// Pull in the `core_arch` crate directly into core. The contents of\n // `core_arch` are in a different repository: rust-lang/stdarch.\n //\n-// `core_arch` depends on libcore, but the contents of this module are\n+// `core_arch` depends on core, but the contents of this module are\n // set up in such a way that directly pulling it here works such that the\n-// crate uses the this crate as its libcore.\n+// crate uses the this crate as its core.\n #[path = \"../../stdarch/crates/core_arch/src/mod.rs\"]\n #[allow(\n     missing_docs,\n@@ -400,12 +400,12 @@ mod core_arch;\n #[stable(feature = \"simd_arch\", since = \"1.27.0\")]\n pub mod arch;\n \n-// Pull in the `core_simd` crate directly into libcore. The contents of\n+// Pull in the `core_simd` crate directly into core. The contents of\n // `core_simd` are in a different repository: rust-lang/portable-simd.\n //\n-// `core_simd` depends on libcore, but the contents of this module are\n+// `core_simd` depends on core, but the contents of this module are\n // set up in such a way that directly pulling it here works such that the\n-// crate uses this crate as its libcore.\n+// crate uses this crate as its core.\n #[path = \"../../portable-simd/crates/core_simd/src/mod.rs\"]\n #[allow(missing_debug_implementations, dead_code, unsafe_op_in_unsafe_fn, unused_unsafe)]\n #[allow(rustdoc::bare_urls)]"}, {"sha": "cfc1cabe229e59d45005e49120752a4998554421", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1461,7 +1461,6 @@ pub(crate) mod builtin {\n     /// [the reference]: ../../../reference/attributes/derive.html\n     #[unstable(feature = \"derive_const\", issue = \"none\")]\n     #[rustc_builtin_macro]\n-    #[cfg(not(bootstrap))]\n     pub macro derive_const($item:item) {\n         /* compiler built-in */\n     }\n@@ -1516,7 +1515,6 @@ pub(crate) mod builtin {\n     /// Attribute macro applied to a function to register it as a handler for allocation failure.\n     ///\n     /// See also [`std::alloc::handle_alloc_error`](../../../std/alloc/fn.handle_alloc_error.html).\n-    #[cfg(not(bootstrap))]\n     #[unstable(feature = \"alloc_error_handler\", issue = \"51540\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n@@ -1553,7 +1551,6 @@ pub(crate) mod builtin {\n         issue = \"23416\",\n         reason = \"placeholder syntax for type ascription\"\n     )]\n-    #[cfg(not(bootstrap))]\n     pub macro type_ascribe($expr:expr, $ty:ty) {\n         /* compiler built-in */\n     }"}, {"sha": "c0fb954ce2d9d39c0a291902a021894ca820db2d", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -96,7 +96,7 @@ unsafe impl<T: Sync + ?Sized> Send for &T {}\n )]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n #[rustc_specialization_trait]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Sized {\n     // Empty.\n }\n@@ -128,7 +128,7 @@ pub trait Sized {\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"unsize\", issue = \"18598\")]\n #[lang = \"unsize\"]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n@@ -695,7 +695,7 @@ impl<T: ?Sized> StructuralEq for PhantomData<T> {}\n     reason = \"this trait is unlikely to ever be stabilized, use `mem::discriminant` instead\"\n )]\n #[lang = \"discriminant_kind\"]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait DiscriminantKind {\n     /// The type of the discriminant, which must satisfy the trait\n     /// bounds required by `mem::Discriminant`.\n@@ -796,7 +796,7 @@ impl<T: ?Sized> Unpin for *mut T {}\n #[lang = \"destruct\"]\n #[rustc_on_unimplemented(message = \"can't drop `{Self}`\", append_const_msg)]\n #[const_trait]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Destruct {}\n \n /// A marker for tuple types.\n@@ -806,12 +806,12 @@ pub trait Destruct {}\n #[unstable(feature = \"tuple_trait\", issue = \"none\")]\n #[lang = \"tuple_trait\"]\n #[rustc_on_unimplemented(message = \"`{Self}` is not a tuple\")]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Tuple {}\n \n /// A marker for things\n #[unstable(feature = \"pointer_sized_trait\", issue = \"none\")]\n-#[cfg_attr(not(bootstrap), lang = \"pointer_sized\")]\n+#[lang = \"pointer_sized\"]\n #[rustc_on_unimplemented(\n     message = \"`{Self}` needs to be a pointer-sized type\",\n     label = \"`{Self}` needs to be a pointer-sized type\""}, {"sha": "1308b0770b848a80aed914166b90616241f09b29", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -428,7 +428,7 @@ impl f32 {\n         self != self\n     }\n \n-    // FIXME(#50145): `abs` is publicly unavailable in libcore due to\n+    // FIXME(#50145): `abs` is publicly unavailable in core due to\n     // concerns about portability, so this implementation is for\n     // private use internally.\n     #[inline]"}, {"sha": "2a22c4302b91bd97ecb97c823b6de0a51bc48508", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -427,7 +427,7 @@ impl f64 {\n         self != self\n     }\n \n-    // FIXME(#50145): `abs` is publicly unavailable in libcore due to\n+    // FIXME(#50145): `abs` is publicly unavailable in core due to\n     // concerns about portability, so this implementation is for\n     // private use internally.\n     #[inline]"}, {"sha": "57096f4397436359d84f12b354598eb7f673f48c", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2290,8 +2290,8 @@ macro_rules! int_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n@@ -2313,8 +2313,8 @@ macro_rules! int_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n@@ -2335,8 +2335,8 @@ macro_rules! int_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n@@ -2360,8 +2360,8 @@ macro_rules! int_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2396,8 +2396,8 @@ macro_rules! int_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2420,8 +2420,8 @@ macro_rules! int_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "fbda8f82b1bd906726775816fc920de7abb30c4b", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -462,8 +462,8 @@ macro_rules! nonzero_unsigned_operations {\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(8).unwrap().ilog2(), 3);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(9).unwrap().ilog2(), 3);\")]\n                 /// ```\n-                #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-                #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+                #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n                 #[must_use = \"this returns the result of the operation, \\\n                               without modifying the original\"]\n                 #[inline]\n@@ -486,8 +486,8 @@ macro_rules! nonzero_unsigned_operations {\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(100).unwrap().ilog10(), 2);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(101).unwrap().ilog10(), 2);\")]\n                 /// ```\n-                #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-                #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+                #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n                 #[must_use = \"this returns the result of the operation, \\\n                               without modifying the original\"]\n                 #[inline]\n@@ -1253,7 +1253,7 @@ macro_rules! nonzero_bits {\n                 ///\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::BITS, \", stringify!($Int), \"::BITS);\")]\n                 /// ```\n-                #[stable(feature = \"nonzero_bits\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[stable(feature = \"nonzero_bits\", since = \"1.67.0\")]\n                 pub const BITS: u32 = <$Int>::BITS;\n             }\n         )+"}, {"sha": "1c97c46862833a2e2c351c69649f782ac18a6b97", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -703,8 +703,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n@@ -726,8 +726,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n@@ -748,8 +748,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n@@ -773,8 +773,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -809,8 +809,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -831,8 +831,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n         /// ```\n-        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n-        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "b7e1aee9d84d123be63137e0ea81b026e7d855c7", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,4 +1,3 @@\n-#[cfg(not(bootstrap))]\n use crate::marker::Tuple;\n \n /// The version of the call operator that takes an immutable receiver.\n@@ -54,87 +53,6 @@ use crate::marker::Tuple;\n /// let double = |x| x * 2;\n /// assert_eq!(call_with_one(double), 2);\n /// ```\n-#[cfg(bootstrap)]\n-#[lang = \"fn\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[rustc_on_unimplemented(\n-    on(\n-        Args = \"()\",\n-        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n-    ),\n-    on(\n-        _Self = \"unsafe fn\",\n-        note = \"unsafe function cannot be called generically without an unsafe block\",\n-        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n-        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n-    ),\n-    message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n-    label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n-)]\n-#[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use = \"closures are lazy and do nothing unless called\"]\n-#[const_trait]\n-pub trait Fn<Args>: FnMut<Args> {\n-    /// Performs the call operation.\n-    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n-    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-}\n-\n-/// The version of the call operator that takes an immutable receiver.\n-///\n-/// Instances of `Fn` can be called repeatedly without mutating state.\n-///\n-/// *This trait (`Fn`) is not to be confused with [function pointers]\n-/// (`fn`).*\n-///\n-/// `Fn` is implemented automatically by closures which only take immutable\n-/// references to captured variables or don't capture anything at all, as well\n-/// as (safe) [function pointers] (with some caveats, see their documentation\n-/// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n-/// implements `Fn`, too.\n-///\n-/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n-/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n-/// is expected.\n-///\n-/// Use `Fn` as a bound when you want to accept a parameter of function-like\n-/// type and need to call it repeatedly and without mutating state (e.g., when\n-/// calling it concurrently). If you do not need such strict requirements, use\n-/// [`FnMut`] or [`FnOnce`] as bounds.\n-///\n-/// See the [chapter on closures in *The Rust Programming Language*][book] for\n-/// some more information on this topic.\n-///\n-/// Also of note is the special syntax for `Fn` traits (e.g.\n-/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n-/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n-///\n-/// [book]: ../../book/ch13-01-closures.html\n-/// [function pointers]: fn\n-/// [nomicon]: ../../nomicon/hrtb.html\n-///\n-/// # Examples\n-///\n-/// ## Calling a closure\n-///\n-/// ```\n-/// let square = |x| x * x;\n-/// assert_eq!(square(5), 25);\n-/// ```\n-///\n-/// ## Using a `Fn` parameter\n-///\n-/// ```\n-/// fn call_with_one<F>(func: F) -> usize\n-///     where F: Fn(usize) -> usize {\n-///     func(1)\n-/// }\n-///\n-/// let double = |x| x * 2;\n-/// assert_eq!(call_with_one(double), 2);\n-/// ```\n-#[cfg(not(bootstrap))]\n #[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -222,95 +140,6 @@ pub trait Fn<Args: Tuple>: FnMut<Args> {\n ///\n /// assert_eq!(x, 5);\n /// ```\n-#[cfg(bootstrap)]\n-#[lang = \"fn_mut\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[rustc_on_unimplemented(\n-    on(\n-        Args = \"()\",\n-        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n-    ),\n-    on(\n-        _Self = \"unsafe fn\",\n-        note = \"unsafe function cannot be called generically without an unsafe block\",\n-        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n-        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n-    ),\n-    message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n-    label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n-)]\n-#[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use = \"closures are lazy and do nothing unless called\"]\n-#[const_trait]\n-pub trait FnMut<Args>: FnOnce<Args> {\n-    /// Performs the call operation.\n-    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-}\n-\n-/// The version of the call operator that takes a mutable receiver.\n-///\n-/// Instances of `FnMut` can be called repeatedly and may mutate state.\n-///\n-/// `FnMut` is implemented automatically by closures which take mutable\n-/// references to captured variables, as well as all types that implement\n-/// [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n-/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n-/// implements `FnMut`, too.\n-///\n-/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n-/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n-/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n-///\n-/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n-/// type and need to call it repeatedly, while allowing it to mutate state.\n-/// If you don't want the parameter to mutate state, use [`Fn`] as a\n-/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n-///\n-/// See the [chapter on closures in *The Rust Programming Language*][book] for\n-/// some more information on this topic.\n-///\n-/// Also of note is the special syntax for `Fn` traits (e.g.\n-/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n-/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n-///\n-/// [book]: ../../book/ch13-01-closures.html\n-/// [function pointers]: fn\n-/// [nomicon]: ../../nomicon/hrtb.html\n-///\n-/// # Examples\n-///\n-/// ## Calling a mutably capturing closure\n-///\n-/// ```\n-/// let mut x = 5;\n-/// {\n-///     let mut square_x = || x *= x;\n-///     square_x();\n-/// }\n-/// assert_eq!(x, 25);\n-/// ```\n-///\n-/// ## Using a `FnMut` parameter\n-///\n-/// ```\n-/// fn do_twice<F>(mut func: F)\n-///     where F: FnMut()\n-/// {\n-///     func();\n-///     func();\n-/// }\n-///\n-/// let mut x: usize = 1;\n-/// {\n-///     let add_two_to_x = || x += 2;\n-///     do_twice(add_two_to_x);\n-/// }\n-///\n-/// assert_eq!(x, 5);\n-/// ```\n-#[cfg(not(bootstrap))]\n #[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -390,92 +219,6 @@ pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n ///\n /// // `consume_and_return_x` can no longer be invoked at this point\n /// ```\n-#[cfg(bootstrap)]\n-#[lang = \"fn_once\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[rustc_on_unimplemented(\n-    on(\n-        Args = \"()\",\n-        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n-    ),\n-    on(\n-        _Self = \"unsafe fn\",\n-        note = \"unsafe function cannot be called generically without an unsafe block\",\n-        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n-        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n-    ),\n-    message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n-    label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\"\n-)]\n-#[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use = \"closures are lazy and do nothing unless called\"]\n-#[const_trait]\n-pub trait FnOnce<Args> {\n-    /// The returned type after the call operator is used.\n-    #[lang = \"fn_once_output\"]\n-    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n-    type Output;\n-\n-    /// Performs the call operation.\n-    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-}\n-\n-/// The version of the call operator that takes a by-value receiver.\n-///\n-/// Instances of `FnOnce` can be called, but might not be callable multiple\n-/// times. Because of this, if the only thing known about a type is that it\n-/// implements `FnOnce`, it can only be called once.\n-///\n-/// `FnOnce` is implemented automatically by closures that might consume captured\n-/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n-/// [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n-///\n-/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n-/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n-///\n-/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n-/// type and only need to call it once. If you need to call the parameter\n-/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n-/// state, use [`Fn`].\n-///\n-/// See the [chapter on closures in *The Rust Programming Language*][book] for\n-/// some more information on this topic.\n-///\n-/// Also of note is the special syntax for `Fn` traits (e.g.\n-/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n-/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n-///\n-/// [book]: ../../book/ch13-01-closures.html\n-/// [function pointers]: fn\n-/// [nomicon]: ../../nomicon/hrtb.html\n-///\n-/// # Examples\n-///\n-/// ## Using a `FnOnce` parameter\n-///\n-/// ```\n-/// fn consume_with_relish<F>(func: F)\n-///     where F: FnOnce() -> String\n-/// {\n-///     // `func` consumes its captured variables, so it cannot be run more\n-///     // than once.\n-///     println!(\"Consumed: {}\", func());\n-///\n-///     println!(\"Delicious!\");\n-///\n-///     // Attempting to invoke `func()` again will throw a `use of moved\n-///     // value` error for `func`.\n-/// }\n-///\n-/// let x = String::from(\"x\");\n-/// let consume_and_return_x = move || x;\n-/// consume_with_relish(consume_and_return_x);\n-///\n-/// // `consume_and_return_x` can no longer be invoked at this point\n-/// ```\n-#[cfg(not(bootstrap))]\n #[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -507,68 +250,6 @@ pub trait FnOnce<Args: Tuple> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n-#[cfg(bootstrap)]\n-mod impls {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const Fn<A> for &F\n-    where\n-        F: ~const Fn<A>,\n-    {\n-        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n-            (**self).call(args)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const FnMut<A> for &F\n-    where\n-        F: ~const Fn<A>,\n-    {\n-        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n-            (**self).call(args)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const FnOnce<A> for &F\n-    where\n-        F: ~const Fn<A>,\n-    {\n-        type Output = F::Output;\n-\n-        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n-            (*self).call(args)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const FnMut<A> for &mut F\n-    where\n-        F: ~const FnMut<A>,\n-    {\n-        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n-            (*self).call_mut(args)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const FnOnce<A> for &mut F\n-    where\n-        F: ~const FnMut<A>,\n-    {\n-        type Output = F::Output;\n-        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n-            (*self).call_mut(args)\n-        }\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n mod impls {\n     use crate::marker::Tuple;\n "}, {"sha": "8338a5d7e5a2199bb1f2a88b378e78c4f189f091", "filename": "library/core/src/panic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -90,14 +90,14 @@ pub macro unreachable_2021 {\n     ),\n }\n \n-/// An internal trait used by libstd to pass data from libstd to `panic_unwind`\n-/// and other panic runtimes. Not intended to be stabilized any time soon, do\n-/// not use.\n+/// An internal trait used by std to pass data from std to `panic_unwind` and\n+/// other panic runtimes. Not intended to be stabilized any time soon, do not\n+/// use.\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n #[doc(hidden)]\n pub unsafe trait BoxMeUp {\n     /// Take full ownership of the contents.\n-    /// The return type is actually `Box<dyn Any + Send>`, but we cannot use `Box` in libcore.\n+    /// The return type is actually `Box<dyn Any + Send>`, but we cannot use `Box` in core.\n     ///\n     /// After this method got called, only some dummy default value is left in `self`.\n     /// Calling this method twice, or calling `get` after calling this method, is an error."}, {"sha": "0d385c9d1874435ed2bca34ac02c58dfa3554d58", "filename": "library/core/src/panic/panic_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -157,7 +157,7 @@ impl fmt::Display for PanicInfo<'_> {\n             write!(formatter, \"'{}', \", payload)?\n         }\n         // NOTE: we cannot use downcast_ref::<String>() here\n-        // since String is not available in libcore!\n+        // since String is not available in core!\n         // The payload is a String when `std::panic!` is called with multiple arguments,\n         // but in that case the message is also available.\n "}, {"sha": "0146a3c2fbf7f02ddbc70f4c26343eb058faa5ba", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,8 +1,8 @@\n-//! Panic support for libcore\n+//! Panic support for core\n //!\n //! The core library cannot define panicking, but it does *declare* panicking. This\n-//! means that the functions inside of libcore are allowed to panic, but to be\n-//! useful an upstream crate must define panicking for libcore to use. The current\n+//! means that the functions inside of core are allowed to panic, but to be\n+//! useful an upstream crate must define panicking for core to use. The current\n //! interface for panicking is:\n //!\n //! ```\n@@ -13,7 +13,7 @@\n //! This definition allows for panicking with any general message, but it does not\n //! allow for failing with a `Box<Any>` value. (`PanicInfo` just contains a `&(dyn Any + Send)`,\n //! for which we fill in a dummy value in `PanicInfo::internal_constructor`.)\n-//! The reason for this is that libcore is not allowed to allocate.\n+//! The reason for this is that core is not allowed to allocate.\n //!\n //! This module contains a few other panicking functions, but these are just the\n //! necessary lang items for the compiler. All panics are funneled through this\n@@ -64,12 +64,13 @@ pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n     unsafe { panic_impl(&pi) }\n }\n \n-/// Like panic_fmt, but without unwinding and track_caller to reduce the impact on codesize.\n-/// Also just works on `str`, as a `fmt::Arguments` needs more space to be passed.\n+/// Like `panic`, but without unwinding and track_caller to reduce the impact on codesize.\n+/// (No `fmt` variant as a `fmt::Arguments` needs more space to be passed.)\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n+#[cfg_attr(not(bootstrap), lang = \"panic_nounwind\")] // needed by codegen for non-unwinding panics\n #[rustc_nounwind]\n-pub fn panic_str_nounwind(msg: &'static str) -> ! {\n+pub fn panic_nounwind(msg: &'static str) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         super::intrinsics::abort()\n     }\n@@ -93,7 +94,7 @@ pub fn panic_str_nounwind(msg: &'static str) -> ! {\n // Next we define a bunch of higher-level wrappers that all bottom out in the two core functions\n // above.\n \n-/// The underlying implementation of libcore's `panic!` macro when no formatting is used.\n+/// The underlying implementation of core's `panic!` macro when no formatting is used.\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n@@ -153,10 +154,11 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n /// any extra arguments (including those synthesized by track_caller).\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[lang = \"panic_no_unwind\"] // needed by codegen for panic in nounwind function\n+#[cfg_attr(bootstrap, lang = \"panic_no_unwind\")] // needed by codegen for panic in nounwind function\n+#[cfg_attr(not(bootstrap), lang = \"panic_cannot_unwind\")] // needed by codegen for panic in nounwind function\n #[rustc_nounwind]\n-fn panic_no_unwind() -> ! {\n-    panic_str_nounwind(\"panic in a function that cannot unwind\")\n+fn panic_cannot_unwind() -> ! {\n+    panic_nounwind(\"panic in a function that cannot unwind\")\n }\n \n /// This function is used instead of panic_fmt in const eval."}, {"sha": "12f762ef1932c7f1bd352fb038d6f1d43c313eaa", "filename": "library/core/src/prelude/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,8 +1,8 @@\n-//! The libcore prelude\n+//! The core prelude\n //!\n-//! This module is intended for users of libcore which do not link to libstd as\n-//! well. This module is imported by default when `#![no_std]` is used in the\n-//! same manner as the standard library's prelude.\n+//! This module is intended for users of core which do not link to std as well.\n+//! This module is imported by default when `#![no_std]` is used in the same\n+//! manner as the standard library's prelude.\n \n #![stable(feature = \"core_prelude\", since = \"1.4.0\")]\n "}, {"sha": "10525a16f3a66ebd8970cf8a13afb23351c6d22a", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -75,14 +75,12 @@ pub use crate::macros::builtin::{RustcDecodable, RustcEncodable};\n \n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use crate::macros::builtin::alloc_error_handler;\n-#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use crate::macros::builtin::{bench, derive, global_allocator, test, test_case};\n+pub use crate::macros::builtin::{\n+    alloc_error_handler, bench, derive, global_allocator, test, test_case,\n+};\n \n #[unstable(feature = \"derive_const\", issue = \"none\")]\n-#[cfg(not(bootstrap))]\n pub use crate::macros::builtin::derive_const;\n \n #[unstable(\n@@ -104,5 +102,4 @@ pub use crate::macros::builtin::cfg_eval;\n     issue = \"23416\",\n     reason = \"placeholder syntax for type ascription\"\n )]\n-#[cfg(not(bootstrap))]\n pub use crate::macros::builtin::type_ascribe;"}, {"sha": "2123147c7e44c1779226bf2b9bce9783bffb990a", "filename": "library/core/src/ptr/alignment.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -10,8 +10,7 @@ use crate::{cmp, fmt, hash, mem, num};\n /// are likely not to be supported by actual allocators and linkers.\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n #[derive(Copy, Clone, Eq)]\n-#[cfg_attr(bootstrap, derive(PartialEq))]\n-#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n+#[derive_const(PartialEq)]\n #[repr(transparent)]\n pub struct Alignment(AlignmentEnum);\n \n@@ -203,8 +202,7 @@ type AlignmentEnum = AlignmentEnum32;\n type AlignmentEnum = AlignmentEnum64;\n \n #[derive(Copy, Clone, Eq)]\n-#[cfg_attr(bootstrap, derive(PartialEq))]\n-#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n+#[derive_const(PartialEq)]\n #[repr(u16)]\n enum AlignmentEnum16 {\n     _Align1Shl0 = 1 << 0,\n@@ -226,8 +224,7 @@ enum AlignmentEnum16 {\n }\n \n #[derive(Copy, Clone, Eq)]\n-#[cfg_attr(bootstrap, derive(PartialEq))]\n-#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n+#[derive_const(PartialEq)]\n #[repr(u32)]\n enum AlignmentEnum32 {\n     _Align1Shl0 = 1 << 0,\n@@ -265,8 +262,7 @@ enum AlignmentEnum32 {\n }\n \n #[derive(Copy, Clone, Eq)]\n-#[cfg_attr(bootstrap, derive(PartialEq))]\n-#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n+#[derive_const(PartialEq)]\n #[repr(u64)]\n enum AlignmentEnum64 {\n     _Align1Shl0 = 1 << 0,"}, {"sha": "0a74c03d70f3a6cf17c95e9a059d49f2960f0945", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n-use crate::intrinsics;\n+use crate::intrinsics::{self, const_eval_select};\n use crate::mem;\n use crate::slice::{self, SliceIndex};\n \n@@ -34,12 +34,23 @@ impl<T: ?Sized> *const T {\n     #[rustc_const_unstable(feature = \"const_ptr_is_null\", issue = \"74939\")]\n     #[inline]\n     pub const fn is_null(self) -> bool {\n-        // Compare via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        match (self as *const u8).guaranteed_eq(null()) {\n-            None => false,\n-            Some(res) => res,\n+        #[inline]\n+        fn runtime_impl(ptr: *const u8) -> bool {\n+            ptr.addr() == 0\n         }\n+\n+        #[inline]\n+        const fn const_impl(ptr: *const u8) -> bool {\n+            // Compare via a cast to a thin pointer, so fat pointers are only\n+            // considering their \"data\" part for null-ness.\n+            match (ptr).guaranteed_eq(null_mut()) {\n+                None => false,\n+                Some(res) => res,\n+            }\n+        }\n+\n+        // SAFETY: The two versions are equivalent at runtime.\n+        unsafe { const_eval_select((self as *const u8,), const_impl, runtime_impl) }\n     }\n \n     /// Casts to a pointer of another type.\n@@ -1350,26 +1361,6 @@ impl<T: ?Sized> *const T {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n \n-        #[cfg(bootstrap)]\n-        {\n-            fn rt_impl<T>(p: *const T, align: usize) -> usize {\n-                // SAFETY: `align` has been checked to be a power of 2 above\n-                unsafe { align_offset(p, align) }\n-            }\n-\n-            const fn ctfe_impl<T>(_: *const T, _: usize) -> usize {\n-                usize::MAX\n-            }\n-\n-            // SAFETY:\n-            // It is permissible for `align_offset` to always return `usize::MAX`,\n-            // algorithm correctness can not depend on `align_offset` returning non-max values.\n-            //\n-            // As such the behaviour can't change after replacing `align_offset` with `usize::MAX`, only performance can.\n-            unsafe { intrinsics::const_eval_select((self, align), ctfe_impl, rt_impl) }\n-        }\n-\n-        #[cfg(not(bootstrap))]\n         {\n             // SAFETY: `align` has been checked to be a power of 2 above\n             unsafe { align_offset(self, align) }\n@@ -1406,8 +1397,7 @@ impl<T: ?Sized> *const T {\n     /// is never aligned if cast to a type with a stricter alignment than the reference's\n     /// underlying allocation.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1433,8 +1423,7 @@ impl<T: ?Sized> *const T {\n     /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n     /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1460,8 +1449,7 @@ impl<T: ?Sized> *const T {\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1537,8 +1525,7 @@ impl<T: ?Sized> *const T {\n     /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n     /// cannot be stricter aligned than the reference's underlying allocation.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1563,8 +1550,7 @@ impl<T: ?Sized> *const T {\n     /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n     /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1588,8 +1574,7 @@ impl<T: ?Sized> *const T {\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1613,11 +1598,22 @@ impl<T: ?Sized> *const T {\n             panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n-        // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n-        // The cast to `()` is used to\n-        //   1. deal with fat pointers; and\n-        //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n-        self.cast::<()>().align_offset(align) == 0\n+        #[inline]\n+        fn runtime_impl(ptr: *const (), align: usize) -> bool {\n+            ptr.addr() & (align - 1) == 0\n+        }\n+\n+        #[inline]\n+        const fn const_impl(ptr: *const (), align: usize) -> bool {\n+            // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n+            // The cast to `()` is used to\n+            //   1. deal with fat pointers; and\n+            //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n+            ptr.align_offset(align) == 0\n+        }\n+\n+        // SAFETY: The two versions are equivalent at runtime.\n+        unsafe { const_eval_select((self.cast::<()>(), align), const_impl, runtime_impl) }\n     }\n }\n "}, {"sha": "2ea032d4affe052abb3898f2182ccccb241040b5", "filename": "library/core/src/ptr/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -50,7 +50,7 @@ use crate::hash::{Hash, Hasher};\n ///\n /// [`to_raw_parts`]: *const::to_raw_parts\n #[lang = \"pointee_trait\"]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Pointee {\n     /// The type for metadata in pointers and references to `Self`.\n     #[lang = \"metadata_type\"]"}, {"sha": "5f30029eaa07d5c8d9be41bd6a6f221e13b0b43e", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -516,6 +516,27 @@ pub const fn null<T: ?Sized + Thin>() -> *const T {\n     from_raw_parts(invalid(0), ())\n }\n \n+/// Creates a null mutable raw pointer.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let p: *mut i32 = ptr::null_mut();\n+/// assert!(p.is_null());\n+/// ```\n+#[inline(always)]\n+#[must_use]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_promotable]\n+#[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.24.0\")]\n+#[rustc_allow_const_fn_unstable(ptr_metadata)]\n+#[rustc_diagnostic_item = \"ptr_null_mut\"]\n+pub const fn null_mut<T: ?Sized + Thin>() -> *mut T {\n+    from_raw_parts_mut(invalid_mut(0), ())\n+}\n+\n /// Creates an invalid pointer with the given address.\n ///\n /// This is different from `addr as *const T`, which creates a pointer that picks up a previously\n@@ -663,25 +684,26 @@ where\n     addr as *mut T\n }\n \n-/// Creates a null mutable raw pointer.\n+/// Convert a reference to a raw pointer.\n ///\n-/// # Examples\n-///\n-/// ```\n-/// use std::ptr;\n+/// This is equivalent to `r as *const T`, but is a bit safer since it will never silently change\n+/// type or mutability, in particular if the code is refactored.\n+#[inline(always)]\n+#[must_use]\n+#[unstable(feature = \"ptr_from_ref\", issue = \"106116\")]\n+pub fn from_ref<T: ?Sized>(r: &T) -> *const T {\n+    r\n+}\n+\n+/// Convert a mutable reference to a raw pointer.\n ///\n-/// let p: *mut i32 = ptr::null_mut();\n-/// assert!(p.is_null());\n-/// ```\n+/// This is equivalent to `r as *mut T`, but is a bit safer since it will never silently change\n+/// type or mutability, in particular if the code is refactored.\n #[inline(always)]\n #[must_use]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_promotable]\n-#[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.24.0\")]\n-#[rustc_allow_const_fn_unstable(ptr_metadata)]\n-#[rustc_diagnostic_item = \"ptr_null_mut\"]\n-pub const fn null_mut<T: ?Sized + Thin>() -> *mut T {\n-    from_raw_parts_mut(invalid_mut(0), ())\n+#[unstable(feature = \"ptr_from_ref\", issue = \"106116\")]\n+pub fn from_mut<T: ?Sized>(r: &mut T) -> *mut T {\n+    r\n }\n \n /// Forms a raw slice from a pointer and a length."}, {"sha": "d70fb70c79fa4dc6dacc84297e67a062235bd8d8", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n-use crate::intrinsics;\n+use crate::intrinsics::{self, const_eval_select};\n use crate::slice::{self, SliceIndex};\n \n impl<T: ?Sized> *mut T {\n@@ -33,12 +33,23 @@ impl<T: ?Sized> *mut T {\n     #[rustc_const_unstable(feature = \"const_ptr_is_null\", issue = \"74939\")]\n     #[inline]\n     pub const fn is_null(self) -> bool {\n-        // Compare via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        match (self as *mut u8).guaranteed_eq(null_mut()) {\n-            None => false,\n-            Some(res) => res,\n+        #[inline]\n+        fn runtime_impl(ptr: *mut u8) -> bool {\n+            ptr.addr() == 0\n         }\n+\n+        #[inline]\n+        const fn const_impl(ptr: *mut u8) -> bool {\n+            // Compare via a cast to a thin pointer, so fat pointers are only\n+            // considering their \"data\" part for null-ness.\n+            match (ptr).guaranteed_eq(null_mut()) {\n+                None => false,\n+                Some(res) => res,\n+            }\n+        }\n+\n+        // SAFETY: The two versions are equivalent at runtime.\n+        unsafe { const_eval_select((self as *mut u8,), const_impl, runtime_impl) }\n     }\n \n     /// Casts to a pointer of another type.\n@@ -1618,26 +1629,6 @@ impl<T: ?Sized> *mut T {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n \n-        #[cfg(bootstrap)]\n-        {\n-            fn rt_impl<T>(p: *mut T, align: usize) -> usize {\n-                // SAFETY: `align` has been checked to be a power of 2 above\n-                unsafe { align_offset(p, align) }\n-            }\n-\n-            const fn ctfe_impl<T>(_: *mut T, _: usize) -> usize {\n-                usize::MAX\n-            }\n-\n-            // SAFETY:\n-            // It is permissible for `align_offset` to always return `usize::MAX`,\n-            // algorithm correctness can not depend on `align_offset` returning non-max values.\n-            //\n-            // As such the behaviour can't change after replacing `align_offset` with `usize::MAX`, only performance can.\n-            unsafe { intrinsics::const_eval_select((self, align), ctfe_impl, rt_impl) }\n-        }\n-\n-        #[cfg(not(bootstrap))]\n         {\n             // SAFETY: `align` has been checked to be a power of 2 above\n             unsafe { align_offset(self, align) }\n@@ -1674,8 +1665,7 @@ impl<T: ?Sized> *mut T {\n     /// is never aligned if cast to a type with a stricter alignment than the reference's\n     /// underlying allocation.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     /// #![feature(const_mut_refs)]\n@@ -1702,8 +1692,7 @@ impl<T: ?Sized> *mut T {\n     /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n     /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1730,8 +1719,7 @@ impl<T: ?Sized> *mut T {\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1807,8 +1795,7 @@ impl<T: ?Sized> *mut T {\n     /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n     /// cannot be stricter aligned than the reference's underlying allocation.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     /// #![feature(const_mut_refs)]\n@@ -1834,8 +1821,7 @@ impl<T: ?Sized> *mut T {\n     /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n     /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1860,8 +1846,7 @@ impl<T: ?Sized> *mut T {\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1885,11 +1870,22 @@ impl<T: ?Sized> *mut T {\n             panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n-        // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n-        // The cast to `()` is used to\n-        //   1. deal with fat pointers; and\n-        //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n-        self.cast::<()>().align_offset(align) == 0\n+        #[inline]\n+        fn runtime_impl(ptr: *mut (), align: usize) -> bool {\n+            ptr.addr() & (align - 1) == 0\n+        }\n+\n+        #[inline]\n+        const fn const_impl(ptr: *mut (), align: usize) -> bool {\n+            // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n+            // The cast to `()` is used to\n+            //   1. deal with fat pointers; and\n+            //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n+            ptr.align_offset(align) == 0\n+        }\n+\n+        // SAFETY: The two versions are equivalent at runtime.\n+        unsafe { const_eval_select((self.cast::<()>(), align), const_impl, runtime_impl) }\n     }\n }\n "}, {"sha": "b8c0c3fd9493285b10117fb8ede4d341ee733607", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -3,7 +3,7 @@\n //! This module contains a sorting algorithm based on Orson Peters' pattern-defeating quicksort,\n //! published at: <https://github.com/orlp/pdqsort>\n //!\n-//! Unstable sorting is compatible with libcore because it doesn't allocate memory, unlike our\n+//! Unstable sorting is compatible with core because it doesn't allocate memory, unlike our\n //! stable sorting implementation.\n \n use crate::cmp;"}, {"sha": "ab2f8520ecb33d969a479891fdca82997b90144e", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -368,7 +368,7 @@ impl str {\n     #[inline(always)]\n     pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n         // SAFETY: the cast from `&str` to `&[u8]` is safe since `str`\n-        // has the same layout as `&[u8]` (only libstd can make this guarantee).\n+        // has the same layout as `&[u8]` (only std can make this guarantee).\n         // The pointer dereference is safe since it comes from a mutable reference which\n         // is guaranteed to be valid for writes.\n         unsafe { &mut *(self as *mut str as *mut [u8]) }"}, {"sha": "25b61c0e66641d9beaf8a11fd88afef387317ae4", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -9,7 +9,7 @@ use crate::task::Ready;\n /// scheduled to receive a wakeup instead.\n #[must_use = \"this `Poll` may be a `Pending` variant, which should be handled\"]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n-#[cfg_attr(not(bootstrap), lang = \"Poll\")]\n+#[lang = \"Poll\"]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready."}, {"sha": "a4425fd234a4e22ad79ee3dfd4418464d80723ae", "filename": "library/core/src/task/wake.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -181,6 +181,9 @@ pub struct Context<'a> {\n     // are contravariant while return-position lifetimes are\n     // covariant).\n     _marker: PhantomData<fn(&'a ()) -> &'a ()>,\n+    // Ensure `Context` is `!Send` and `!Sync` in order to allow\n+    // for future `!Send` and / or `!Sync` fields.\n+    _marker2: PhantomData<*mut ()>,\n }\n \n impl<'a> Context<'a> {\n@@ -190,7 +193,7 @@ impl<'a> Context<'a> {\n     #[must_use]\n     #[inline]\n     pub const fn from_waker(waker: &'a Waker) -> Self {\n-        Context { waker, _marker: PhantomData }\n+        Context { waker, _marker: PhantomData, _marker2: PhantomData }\n     }\n \n     /// Returns a reference to the [`Waker`] for the current task."}, {"sha": "e1faa407d54c55206b50477caba6e89482592d1f", "filename": "library/core/src/unicode/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Fsrc%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Funicode%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -17,7 +17,7 @@ mod unicode_data;\n #[stable(feature = \"unicode_version\", since = \"1.45.0\")]\n pub const UNICODE_VERSION: (u8, u8, u8) = unicode_data::UNICODE_VERSION;\n \n-// For use in liballoc, not re-exported in libstd.\n+// For use in alloc, not re-exported in std.\n pub use unicode_data::{\n     case_ignorable::lookup as Case_Ignorable, cased::lookup as Cased, conversions,\n };"}, {"sha": "a8f6b7ebb925029d799c1b74af314c2f815937c1", "filename": "library/core/tests/any.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fany.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -131,7 +131,6 @@ fn distinct_type_names() {\n     assert_ne!(type_name_of_val(Velocity), type_name_of_val(Velocity(0.0, -9.8)),);\n }\n \n-#[cfg(not(bootstrap))]\n #[test]\n fn dyn_type_name() {\n     trait Foo {"}, {"sha": "ac0b2ca168b237133727fcfccab3470844cf4563", "filename": "library/core/tests/char.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fchar.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -306,6 +306,10 @@ fn test_decode_utf16() {\n     }\n     check(&[0xD800, 0x41, 0x42], &[Err(0xD800), Ok('A'), Ok('B')]);\n     check(&[0xD800, 0], &[Err(0xD800), Ok('\\0')]);\n+    check(&[0xD800], &[Err(0xD800)]);\n+    check(&[0xD840, 0xDC00], &[Ok('\\u{20000}')]);\n+    check(&[0xD840, 0xD840, 0xDC00], &[Err(0xD840), Ok('\\u{20000}')]);\n+    check(&[0xDC00, 0xD840], &[Err(0xDC00), Err(0xD840)]);\n }\n \n #[test]"}, {"sha": "c7c3c479b71db92af495eaa0407940efcdd622e9", "filename": "library/core/tests/lazy.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flazy.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -106,6 +106,12 @@ fn lazy_new() {\n     assert_eq!(called.get(), 1);\n }\n \n+// Check that we can infer `T` from closure's type.\n+#[test]\n+fn lazy_type_inference() {\n+    let _ = LazyCell::new(|| ());\n+}\n+\n #[test]\n fn aliasing_in_get() {\n     let x = OnceCell::new();"}, {"sha": "f7740a114e738d84f86b87a083cd92b82d5dc1ad", "filename": "library/core/tests/mem.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fmem.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -77,7 +77,6 @@ fn align_of_val_basic() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))] // stage 0 doesn't have the fix yet, so the test fails\n fn align_of_val_raw_packed() {\n     #[repr(C, packed)]\n     struct B {"}, {"sha": "80d30f14c66b24d137dbbea5270566051eda363e", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -359,7 +359,6 @@ fn align_offset_zst() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_zst_const() {\n     const {\n         // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n@@ -397,7 +396,6 @@ fn align_offset_stride_one() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_stride_one_const() {\n     const {\n         // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n@@ -493,7 +491,6 @@ fn align_offset_various_strides() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_various_strides_const() {\n     const unsafe fn test_stride<T>(ptr: *const T, numptr: usize, align: usize) {\n         let mut expected = usize::MAX;\n@@ -561,7 +558,6 @@ fn align_offset_various_strides_const() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_with_provenance_const() {\n     const {\n         // On some platforms (e.g. msp430-none-elf), the alignment of `i32` is less than 4.\n@@ -681,7 +677,6 @@ fn align_offset_issue_103361() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_issue_103361_const() {\n     #[cfg(target_pointer_width = \"64\")]\n     const SIZE: usize = 1 << 47;\n@@ -715,7 +710,6 @@ fn is_aligned() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn is_aligned_const() {\n     const {\n         let data = 42;\n@@ -734,18 +728,6 @@ fn is_aligned_const() {\n     }\n }\n \n-#[test]\n-#[cfg(bootstrap)]\n-fn is_aligned_const() {\n-    const {\n-        let data = 42;\n-        let ptr: *const i32 = &data;\n-        // The bootstrap compiler always returns false for is_aligned.\n-        assert!(!ptr.is_aligned());\n-        assert!(!ptr.is_aligned_to(1));\n-    }\n-}\n-\n #[test]\n fn offset_from() {\n     let mut a = [0; 5];\n@@ -825,7 +807,7 @@ fn ptr_metadata_bounds() {\n     }\n     // \"Synthetic\" trait impls generated by the compiler like those of `Pointee`\n     // are not checked for bounds of associated type.\n-    // So with a buggy libcore we could have both:\n+    // So with a buggy core we could have both:\n     // * `<dyn Display as Pointee>::Metadata == DynMetadata`\n     // * `DynMetadata: !PartialEq`\n     // \u2026 and cause an ICE here:"}, {"sha": "f5066343af20a78d41475aa65ca67c1fa17200df", "filename": "library/core/tests/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fstr.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1 +1 @@\n-// All `str` tests live in liballoc/tests\n+// All `str` tests live in library/alloc/tests/str.rs"}, {"sha": "163b34c9648529463304ec451c8cbff083d2159c", "filename": "library/core/tests/task.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fcore%2Ftests%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftask.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,4 +1,4 @@\n-use core::task::{Context, Poll, RawWaker, RawWakerVTable, Waker};\n+use core::task::{Poll, RawWaker, RawWakerVTable, Waker};\n \n #[test]\n fn poll_const() {\n@@ -21,9 +21,5 @@ fn waker_const() {\n \n     static WAKER: Waker = unsafe { Waker::from_raw(VOID_WAKER) };\n \n-    static CONTEXT: Context<'static> = Context::from_waker(&WAKER);\n-\n-    static WAKER_REF: &'static Waker = CONTEXT.waker();\n-\n-    WAKER_REF.wake_by_ref();\n+    WAKER.wake_by_ref();\n }"}, {"sha": "a3cebf99c5342c3078f2565b3dbb336ca5fd59cf", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -61,7 +61,7 @@ pub unsafe fn __rust_start_panic(_payload: *mut &mut dyn BoxMeUp) -> u32 {\n             //\n             // https://docs.microsoft.com/en-us/cpp/intrinsics/fastfail\n             //\n-            // Note: this is the same implementation as in libstd's `abort_internal`\n+            // Note: this is the same implementation as in std's `abort_internal`\n             unsafe fn abort() -> ! {\n                 #[allow(unused)]\n                 const FAST_FAIL_FATAL_APP_EXIT: usize = 7;\n@@ -89,7 +89,7 @@ pub unsafe fn __rust_start_panic(_payload: *mut &mut dyn BoxMeUp) -> u32 {\n // This... is a bit of an oddity. The tl;dr; is that this is required to link\n // correctly, the longer explanation is below.\n //\n-// Right now the binaries of libcore/libstd that we ship are all compiled with\n+// Right now the binaries of core/std that we ship are all compiled with\n // `-C panic=unwind`. This is done to ensure that the binaries are maximally\n // compatible with as many situations as possible. The compiler, however,\n // requires a \"personality function\" for all functions compiled with `-C\n@@ -109,7 +109,7 @@ pub unsafe fn __rust_start_panic(_payload: *mut &mut dyn BoxMeUp) -> u32 {\n // library just defines this symbol so there's at least some personality\n // somewhere.\n //\n-// Essentially this symbol is just defined to get wired up to libcore/libstd\n+// Essentially this symbol is just defined to get wired up to core/std\n // binaries, but it should never be called as we don't link in an unwinding\n // runtime at all.\n pub mod personalities {"}, {"sha": "ea3c9a7a663c23d6bfc66d7a5c4c1420ec28c122", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -82,11 +82,11 @@ cfg_if::cfg_if! {\n }\n \n extern \"C\" {\n-    /// Handler in libstd called when a panic object is dropped outside of\n+    /// Handler in std called when a panic object is dropped outside of\n     /// `catch_unwind`.\n     fn __rust_drop_panic() -> !;\n \n-    /// Handler in libstd called when a foreign exception is caught.\n+    /// Handler in std called when a foreign exception is caught.\n     fn __rust_foreign_exception() -> !;\n }\n "}, {"sha": "52a08cad9110fa18316478ad300f27788706ee5a", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -356,7 +356,7 @@ impl<I, O> Clone for Client<I, O> {\n \n fn maybe_install_panic_hook(force_show_panics: bool) {\n     // Hide the default panic output within `proc_macro` expansions.\n-    // NB. the server can't do this because it may use a different libstd.\n+    // NB. the server can't do this because it may use a different std.\n     static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n     HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n         let prev = panic::take_hook();"}, {"sha": "17bd0a1b33646643e724ae73a00ac38b34033f4e", "filename": "library/proc_macro/src/bridge/fxhash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -15,9 +15,9 @@ use std::ops::BitXor;\n /// Type alias for a hashmap using the `fx` hash algorithm.\n pub type FxHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FxHasher>>;\n \n-/// A speedy hash algorithm for use within rustc. The hashmap in liballoc\n-/// by default uses SipHash which isn't quite as speedy as we want. In the\n-/// compiler we're not really worried about DOS attempts, so we use a fast\n+/// A speedy hash algorithm for use within rustc. The hashmap in alloc by\n+/// default uses SipHash which isn't quite as speedy as we want. In the compiler\n+/// we're not really worried about DOS attempts, so we use a fast\n /// non-cryptographic hash.\n ///\n /// This is the same as the algorithm used by Firefox -- which is a homespun"}, {"sha": "2ea87d866ff3eaf584973afab015d989e0a364c1", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -112,7 +112,7 @@ macro_rules! define_dispatcher_impl {\n                                 $name::$method(server, $($arg),*)\n                             };\n                             // HACK(eddyb) don't use `panic::catch_unwind` in a panic.\n-                            // If client and server happen to use the same `libstd`,\n+                            // If client and server happen to use the same `std`,\n                             // `catch_unwind` asserts that the panic counter was 0,\n                             // even when the closure passed to it didn't panic.\n                             let r = if thread::panicking() {"}, {"sha": "87db7af44ae09590625561b3b0d26340131f403b", "filename": "library/rustc-std-workspace-alloc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Frustc-std-workspace-alloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Frustc-std-workspace-alloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Frustc-std-workspace-alloc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -3,7 +3,7 @@\n \n // See rustc-std-workspace-core for why this crate is needed.\n \n-// Rename the crate to avoid conflicting with the alloc module in liballoc.\n+// Rename the crate to avoid conflicting with the alloc module in alloc.\n extern crate alloc as foo;\n \n pub use foo::*;"}, {"sha": "7543ffadd4140f5dc99441e5d3a57674252362d2", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -23,10 +23,10 @@\n //!\n //! ## Platform support\n //!\n-//! Not all platforms that libstd compiles for support capturing backtraces.\n-//! Some platforms simply do nothing when capturing a backtrace. To check\n-//! whether the platform supports capturing backtraces you can consult the\n-//! `BacktraceStatus` enum as a result of `Backtrace::status`.\n+//! Not all platforms that std compiles for support capturing backtraces. Some\n+//! platforms simply do nothing when capturing a backtrace. To check whether the\n+//! platform supports capturing backtraces you can consult the `BacktraceStatus`\n+//! enum as a result of `Backtrace::status`.\n //!\n //! Like above with accuracy platform support is done on a best effort basis.\n //! Sometimes libraries might not be available at runtime or something may go"}, {"sha": "601c01c2128c816757c103d3a04f3c4c0dd8646c", "filename": "library/std/src/io/error/repr_bitpacked.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -166,7 +166,7 @@ impl Repr {\n         // `new_unchecked` is safe.\n         let res = Self(unsafe { NonNull::new_unchecked(tagged) }, PhantomData);\n         // quickly smoke-check we encoded the right thing (This generally will\n-        // only run in libstd's tests, unless the user uses -Zbuild-std)\n+        // only run in std's tests, unless the user uses -Zbuild-std)\n         debug_assert!(matches!(res.data(), ErrorData::Custom(_)), \"repr(custom) encoding failed\");\n         res\n     }\n@@ -177,7 +177,7 @@ impl Repr {\n         // Safety: `TAG_OS` is not zero, so the result of the `|` is not 0.\n         let res = Self(unsafe { NonNull::new_unchecked(ptr::invalid_mut(utagged)) }, PhantomData);\n         // quickly smoke-check we encoded the right thing (This generally will\n-        // only run in libstd's tests, unless the user uses -Zbuild-std)\n+        // only run in std's tests, unless the user uses -Zbuild-std)\n         debug_assert!(\n             matches!(res.data(), ErrorData::Os(c) if c == code),\n             \"repr(os) encoding failed for {code}\"\n@@ -191,7 +191,7 @@ impl Repr {\n         // Safety: `TAG_SIMPLE` is not zero, so the result of the `|` is not 0.\n         let res = Self(unsafe { NonNull::new_unchecked(ptr::invalid_mut(utagged)) }, PhantomData);\n         // quickly smoke-check we encoded the right thing (This generally will\n-        // only run in libstd's tests, unless the user uses -Zbuild-std)\n+        // only run in std's tests, unless the user uses -Zbuild-std)\n         debug_assert!(\n             matches!(res.data(), ErrorData::Simple(k) if k == kind),\n             \"repr(simple) encoding failed {:?}\",\n@@ -348,7 +348,7 @@ fn kind_from_prim(ek: u32) -> Option<ErrorKind> {\n // that our encoding relies on for correctness and soundness. (Some of these are\n // a bit overly thorough/cautious, admittedly)\n //\n-// If any of these are hit on a platform that libstd supports, we should likely\n+// If any of these are hit on a platform that std supports, we should likely\n // just use `repr_unpacked.rs` there instead (unless the fix is easy).\n macro_rules! static_assert {\n     ($condition:expr) => {"}, {"sha": "de528e85368cbf5ed6b471b7411f4e3b97b53ca4", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -2137,8 +2137,10 @@ pub trait BufRead: Read {\n     }\n \n     /// Read all bytes until a newline (the `0xA` byte) is reached, and append\n-    /// them to the provided buffer. You do not need to clear the buffer before\n-    /// appending.\n+    /// them to the provided `String` buffer.\n+    ///\n+    /// Previous content of the buffer will be preserved. To avoid appending to\n+    /// the buffer, you need to [`clear`] it first.\n     ///\n     /// This function will read bytes from the underlying stream until the\n     /// newline delimiter (the `0xA` byte) or EOF is found. Once found, all bytes\n@@ -2151,9 +2153,11 @@ pub trait BufRead: Read {\n     ///\n     /// This function is blocking and should be used carefully: it is possible for\n     /// an attacker to continuously send bytes without ever sending a newline\n-    /// or EOF.\n+    /// or EOF. You can use [`take`] to limit the maximum number of bytes read.\n     ///\n     /// [`Ok(0)`]: Ok\n+    /// [`clear`]: String::clear\n+    /// [`take`]: crate::io::Read::take\n     ///\n     /// # Errors\n     ///"}, {"sha": "14bfef4c7aad9bbefea6e896a749d2a67d8480f3", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -10,9 +10,8 @@ use crate::fmt;\n use crate::fs::File;\n use crate::io::{self, BufReader, IoSlice, IoSliceMut, LineWriter, Lines};\n use crate::sync::atomic::{AtomicBool, Ordering};\n-use crate::sync::{Arc, Mutex, MutexGuard, OnceLock};\n+use crate::sync::{Arc, Mutex, MutexGuard, OnceLock, ReentrantMutex, ReentrantMutexGuard};\n use crate::sys::stdio;\n-use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n \n type LocalStream = Arc<Mutex<Vec<u8>>>;\n "}, {"sha": "13dfd41abbf84ddd42b8d17dd138dd2beb3c367d", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -202,7 +202,7 @@\n     no_global_oom_handling,\n     not(no_global_oom_handling)\n ))]\n-// To run libstd tests without x.py without ending up with two copies of libstd, Miri needs to be\n+// To run std tests without x.py without ending up with two copies of std, Miri needs to be\n // able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n // rustc itself never sets the feature, so this line has no affect there.\n #![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n@@ -532,7 +532,7 @@ pub mod process;\n pub mod sync;\n pub mod time;\n \n-// Pull in `std_float` crate  into libstd. The contents of\n+// Pull in `std_float` crate  into std. The contents of\n // `std_float` are in a different repository: rust-lang/portable-simd.\n #[path = \"../../portable-simd/crates/std_float/src/lib.rs\"]\n #[allow(missing_debug_implementations, dead_code, unsafe_op_in_unsafe_fn, unused_unsafe)]\n@@ -602,15 +602,15 @@ mod personality;\n #[allow(dead_code, unused_attributes, fuzzy_provenance_casts)]\n mod backtrace_rs;\n \n-// Re-export macros defined in libcore.\n+// Re-export macros defined in core.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated, deprecated_in_future)]\n pub use core::{\n     assert_eq, assert_ne, debug_assert, debug_assert_eq, debug_assert_ne, matches, todo, r#try,\n     unimplemented, unreachable, write, writeln,\n };\n \n-// Re-export built-in macros defined through libcore.\n+// Re-export built-in macros defined through core.\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow(deprecated)]\n pub use core::{"}, {"sha": "07f08c1b5869d314ef0924f5345b5780b936b8c3", "filename": "library/std/src/net/ip_addr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1195,6 +1195,9 @@ impl Ipv6Addr {\n \n     /// An IPv6 address representing localhost: `::1`.\n     ///\n+    /// This corresponds to constant `IN6ADDR_LOOPBACK_INIT` or `in6addr_loopback` in other\n+    /// languages.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1203,11 +1206,15 @@ impl Ipv6Addr {\n     /// let addr = Ipv6Addr::LOCALHOST;\n     /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n     /// ```\n+    #[doc(alias = \"IN6ADDR_LOOPBACK_INIT\")]\n+    #[doc(alias = \"in6addr_loopback\")]\n     #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n     pub const LOCALHOST: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n \n     /// An IPv6 address representing the unspecified address: `::`\n     ///\n+    /// This corresponds to constant `IN6ADDR_ANY_INIT` or `in6addr_any` in other languages.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1216,6 +1223,8 @@ impl Ipv6Addr {\n     /// let addr = Ipv6Addr::UNSPECIFIED;\n     /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n     /// ```\n+    #[doc(alias = \"IN6ADDR_ANY_INIT\")]\n+    #[doc(alias = \"in6addr_any\")]\n     #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n     pub const UNSPECIFIED: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0);\n "}, {"sha": "9fa8f5702a8438b59c756f161d8a91df943f5337", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -114,6 +114,9 @@ where\n /// aborting the process as well. This function *only* catches unwinding panics,\n /// not those that abort the process.\n ///\n+/// Note that if a custom panic hook has been set, it will be invoked before\n+/// the panic is caught, before unwinding.\n+///\n /// Also note that unwinding into Rust code with a foreign exception (e.g.\n /// an exception thrown from C++ code) is undefined behavior.\n ///"}, {"sha": "b30dd8eecd84c210d709d998cd15a95e77b5d2dc", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -517,7 +517,7 @@ pub fn panicking() -> bool {\n     !panic_count::count_is_zero()\n }\n \n-/// Entry point of panics from the libcore crate (`panic_impl` lang item).\n+/// Entry point of panics from the core crate (`panic_impl` lang item).\n #[cfg(not(test))]\n #[panic_handler]\n pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n@@ -699,7 +699,11 @@ fn rust_panic_with_hook(\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming\n         // unwinding or otherwise exiting the thread cleanly.\n-        rtprintpanic!(\"thread panicked while panicking. aborting.\\n\");\n+        if !can_unwind {\n+            rtprintpanic!(\"thread caused non-unwinding panic. aborting.\\n\");\n+        } else {\n+            rtprintpanic!(\"thread panicked while panicking. aborting.\\n\");\n+        }\n         crate::sys::abort_internal();\n     }\n "}, {"sha": "19d8f1edaf4c91087036159194f1c6f8b67034c0", "filename": "library/std/src/path.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -306,7 +306,7 @@ unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n     // This casts are safe as OsStr is internally a wrapper around [u8] on all\n     // platforms.\n     //\n-    // Note that currently this relies on the special knowledge that libstd has;\n+    // Note that currently this relies on the special knowledge that std has;\n     // these types are single-element structs but are not marked\n     // repr(transparent) or repr(C) which would make these casts not allowable\n     // outside std.\n@@ -1246,6 +1246,9 @@ impl PathBuf {\n     ///   and `path` is not empty, the new path is normalized: all references\n     ///   to `.` and `..` are removed.\n     ///\n+    /// Consider using [`Path::join`] if you need a new `PathBuf` instead of\n+    /// using this function on a cloned `PathBuf`.\n+    ///\n     /// # Examples\n     ///\n     /// Pushing a relative path extends the existing path:\n@@ -1411,14 +1414,29 @@ impl PathBuf {\n         self.push(file_name);\n     }\n \n-    /// Updates [`self.extension`] to `extension`.\n+    /// Updates [`self.extension`] to `Some(extension)` or to `None` if\n+    /// `extension` is empty.\n     ///\n     /// Returns `false` and does nothing if [`self.file_name`] is [`None`],\n     /// returns `true` and updates the extension otherwise.\n     ///\n     /// If [`self.extension`] is [`None`], the extension is added; otherwise\n     /// it is replaced.\n     ///\n+    /// If `extension` is the empty string, [`self.extension`] will be [`None`]\n+    /// afterwards, not `Some(\"\")`.\n+    ///\n+    /// # Caveats\n+    ///\n+    /// The new `extension` may contain dots and will be used in its entirety,\n+    /// but only the part after the final dot will be reflected in\n+    /// [`self.extension`].\n+    ///\n+    /// If the file stem contains internal dots and `extension` is empty, part\n+    /// of the old file stem will be considered the new [`self.extension`].\n+    ///\n+    /// See the examples below.\n+    ///\n     /// [`self.file_name`]: Path::file_name\n     /// [`self.extension`]: Path::extension\n     ///\n@@ -1432,8 +1450,20 @@ impl PathBuf {\n     /// p.set_extension(\"force\");\n     /// assert_eq!(Path::new(\"/feel/the.force\"), p.as_path());\n     ///\n-    /// p.set_extension(\"dark_side\");\n-    /// assert_eq!(Path::new(\"/feel/the.dark_side\"), p.as_path());\n+    /// p.set_extension(\"dark.side\");\n+    /// assert_eq!(Path::new(\"/feel/the.dark.side\"), p.as_path());\n+    ///\n+    /// p.set_extension(\"cookie\");\n+    /// assert_eq!(Path::new(\"/feel/the.dark.cookie\"), p.as_path());\n+    ///\n+    /// p.set_extension(\"\");\n+    /// assert_eq!(Path::new(\"/feel/the.dark\"), p.as_path());\n+    ///\n+    /// p.set_extension(\"\");\n+    /// assert_eq!(Path::new(\"/feel/the\"), p.as_path());\n+    ///\n+    /// p.set_extension(\"\");\n+    /// assert_eq!(Path::new(\"/feel/the\"), p.as_path());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool {"}, {"sha": "2aefd7c513dc8d88421600a69b408a23a5b10aa7", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -59,14 +59,12 @@ pub use core::prelude::v1::{RustcDecodable, RustcEncodable};\n \n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use core::prelude::v1::alloc_error_handler;\n-#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use core::prelude::v1::{bench, derive, global_allocator, test, test_case};\n+pub use core::prelude::v1::{\n+    alloc_error_handler, bench, derive, global_allocator, test, test_case,\n+};\n \n #[unstable(feature = \"derive_const\", issue = \"none\")]\n-#[cfg(not(bootstrap))]\n pub use core::prelude::v1::derive_const;\n \n // Do not `doc(no_inline)` either.\n@@ -91,7 +89,6 @@ pub use core::prelude::v1::cfg_eval;\n     issue = \"23416\",\n     reason = \"placeholder syntax for type ascription\"\n )]\n-#[cfg(not(bootstrap))]\n pub use core::prelude::v1::type_ascribe;\n \n // The file so far is equivalent to src/libcore/prelude/v1.rs,"}, {"sha": "62ce2cb33dc55e9df04055a0efc1efe67512e497", "filename": "library/std/src/process.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1038,6 +1038,15 @@ impl fmt::Debug for Command {\n     /// Format the program and arguments of a Command for display. Any\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n+    ///\n+    /// The default format approximates a shell invocation of the program along with its\n+    /// arguments. It does not include most of the other command properties. The output is not guaranteed to work\n+    /// (e.g. due to lack of shell-escaping or differences in path resolution)\n+    /// On some platforms you can use [the alternate syntax] to show more fields.\n+    ///\n+    /// Note that the debug implementation is platform-specific.\n+    ///\n+    /// [the alternate syntax]: fmt#sign0\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.inner.fmt(f)\n     }\n@@ -2155,18 +2164,11 @@ pub fn id() -> u32 {\n /// to provide similar functionality.\n #[cfg_attr(not(test), lang = \"termination\")]\n #[stable(feature = \"termination_trait_lib\", since = \"1.61.0\")]\n-#[rustc_on_unimplemented(\n-    on(\n-        all(not(bootstrap), cause = \"MainFunctionType\"),\n-        message = \"`main` has invalid return type `{Self}`\",\n-        label = \"`main` can only return types that implement `{Termination}`\"\n-    ),\n-    on(\n-        bootstrap,\n-        message = \"`main` has invalid return type `{Self}`\",\n-        label = \"`main` can only return types that implement `{Termination}`\"\n-    )\n-)]\n+#[rustc_on_unimplemented(on(\n+    cause = \"MainFunctionType\",\n+    message = \"`main` has invalid return type `{Self}`\",\n+    label = \"`main` can only return types that implement `{Termination}`\"\n+))]\n pub trait Termination {\n     /// Is called to get the representation of the value as status code.\n     /// This status code is returned to the operating system."}, {"sha": "b4f6cc2dabae39362ac35aca3631f871a2c47a37", "filename": "library/std/src/process/tests.rs", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -417,6 +417,100 @@ fn env_empty() {\n     assert!(p.is_ok());\n }\n \n+#[test]\n+#[cfg(not(windows))]\n+#[cfg_attr(any(target_os = \"emscripten\", target_env = \"sgx\"), ignore)]\n+fn main() {\n+    const PIDFD: &'static str =\n+        if cfg!(target_os = \"linux\") { \"    create_pidfd: false,\\n\" } else { \"\" };\n+\n+    let mut command = Command::new(\"some-boring-name\");\n+\n+    assert_eq!(format!(\"{command:?}\"), format!(r#\"\"some-boring-name\"\"#));\n+\n+    assert_eq!(\n+        format!(\"{command:#?}\"),\n+        format!(\n+            r#\"Command {{\n+    program: \"some-boring-name\",\n+    args: [\n+        \"some-boring-name\",\n+    ],\n+{PIDFD}}}\"#\n+        )\n+    );\n+\n+    command.args(&[\"1\", \"2\", \"3\"]);\n+\n+    assert_eq!(format!(\"{command:?}\"), format!(r#\"\"some-boring-name\" \"1\" \"2\" \"3\"\"#));\n+\n+    assert_eq!(\n+        format!(\"{command:#?}\"),\n+        format!(\n+            r#\"Command {{\n+    program: \"some-boring-name\",\n+    args: [\n+        \"some-boring-name\",\n+        \"1\",\n+        \"2\",\n+        \"3\",\n+    ],\n+{PIDFD}}}\"#\n+        )\n+    );\n+\n+    crate::os::unix::process::CommandExt::arg0(&mut command, \"exciting-name\");\n+\n+    assert_eq!(\n+        format!(\"{command:?}\"),\n+        format!(r#\"[\"some-boring-name\"] \"exciting-name\" \"1\" \"2\" \"3\"\"#)\n+    );\n+\n+    assert_eq!(\n+        format!(\"{command:#?}\"),\n+        format!(\n+            r#\"Command {{\n+    program: \"some-boring-name\",\n+    args: [\n+        \"exciting-name\",\n+        \"1\",\n+        \"2\",\n+        \"3\",\n+    ],\n+{PIDFD}}}\"#\n+        )\n+    );\n+\n+    let mut command_with_env_and_cwd = Command::new(\"boring-name\");\n+    command_with_env_and_cwd.current_dir(\"/some/path\").env(\"FOO\", \"bar\");\n+    assert_eq!(\n+        format!(\"{command_with_env_and_cwd:?}\"),\n+        r#\"cd \"/some/path\" && FOO=\"bar\" \"boring-name\"\"#\n+    );\n+    assert_eq!(\n+        format!(\"{command_with_env_and_cwd:#?}\"),\n+        format!(\n+            r#\"Command {{\n+    program: \"boring-name\",\n+    args: [\n+        \"boring-name\",\n+    ],\n+    env: CommandEnv {{\n+        clear: false,\n+        vars: {{\n+            \"FOO\": Some(\n+                \"bar\",\n+            ),\n+        }},\n+    }},\n+    cwd: Some(\n+        \"/some/path\",\n+    ),\n+{PIDFD}}}\"#\n+        )\n+    );\n+}\n+\n // See issue #91991\n #[test]\n #[cfg(windows)]"}, {"sha": "f1eeb75be7c4d805fa009b935a7fd5f809bc5217", "filename": "library/std/src/rt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Frt.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -139,9 +139,9 @@ fn lang_start_internal(\n     // mechanism itself.\n     //\n     // There are a couple of instances where unwinding can begin. First is inside of the\n-    // `rt::init`, `rt::cleanup` and similar functions controlled by libstd. In those instances a\n-    // panic is a libstd implementation bug. A quite likely one too, as there isn't any way to\n-    // prevent libstd from accidentally introducing a panic to these functions. Another is from\n+    // `rt::init`, `rt::cleanup` and similar functions controlled by bstd. In those instances a\n+    // panic is a std implementation bug. A quite likely one too, as there isn't any way to\n+    // prevent std from accidentally introducing a panic to these functions. Another is from\n     // user code from `main` or, more nefariously, as described in e.g. issue #86030.\n     // SAFETY: Only called once during runtime initialization.\n     panic::catch_unwind(move || unsafe { init(argc, argv, sigpipe) }).map_err(rt_abort)?;"}, {"sha": "4a15305301d69714badce18702986f90be660e18", "filename": "library/std/src/sync/lazy_lock.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -46,17 +46,15 @@ pub struct LazyLock<T, F = fn() -> T> {\n     cell: OnceLock<T>,\n     init: Cell<Option<F>>,\n }\n-\n-impl<T, F> LazyLock<T, F> {\n+impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     /// Creates a new lazy value with the given initializing\n     /// function.\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new(f: F) -> LazyLock<T, F> {\n         LazyLock { cell: OnceLock::new(), init: Cell::new(Some(f)) }\n     }\n-}\n \n-impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     /// Forces the evaluation of this lazy value and\n     /// returns a reference to result. This is equivalent\n     /// to the `Deref` impl, but is explicit.\n@@ -73,6 +71,7 @@ impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     /// assert_eq!(LazyLock::force(&lazy), &92);\n     /// assert_eq!(&*lazy, &92);\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn force(this: &LazyLock<T, F>) -> &T {\n         this.cell.get_or_init(|| match this.init.take() {\n@@ -85,6 +84,8 @@ impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T, F: FnOnce() -> T> Deref for LazyLock<T, F> {\n     type Target = T;\n+\n+    #[inline]\n     fn deref(&self) -> &T {\n         LazyLock::force(self)\n     }\n@@ -93,6 +94,7 @@ impl<T, F: FnOnce() -> T> Deref for LazyLock<T, F> {\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Default> Default for LazyLock<T> {\n     /// Creates a new lazy value using `Default` as the initializing function.\n+    #[inline]\n     fn default() -> LazyLock<T> {\n         LazyLock::new(T::default)\n     }"}, {"sha": "a5d4e25c5962a77885dcc906e5a7e8ae4babbc45", "filename": "library/std/src/sync/lazy_lock/tests.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock%2Ftests.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -136,6 +136,12 @@ fn sync_lazy_poisoning() {\n     }\n }\n \n+// Check that we can infer `T` from closure's type.\n+#[test]\n+fn lazy_type_inference() {\n+    let _ = LazyCell::new(|| ());\n+}\n+\n #[test]\n fn is_sync_send() {\n     fn assert_traits<T: Send + Sync>() {}"}, {"sha": "ba20bab87a40dacf90ae63288fe060d12166bb84", "filename": "library/std/src/sync/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -177,6 +177,8 @@ pub use self::lazy_lock::LazyLock;\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub use self::once_lock::OnceLock;\n \n+pub(crate) use self::remutex::{ReentrantMutex, ReentrantMutexGuard};\n+\n pub mod mpsc;\n \n mod barrier;\n@@ -187,4 +189,5 @@ mod mutex;\n mod once;\n mod once_lock;\n mod poison;\n+mod remutex;\n mod rwlock;"}, {"sha": "e030c55ce8f6161753b3e517535fef6f49861344", "filename": "library/std/src/sync/mpmc/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -136,7 +136,7 @@ impl Backoff {\n         }\n     }\n \n-    /// Returns `true` if exponential backoff has completed and blocking the thread is advised.\n+    /// Returns `true` if quadratic backoff has completed and blocking the thread is advised.\n     #[inline]\n     pub fn is_completed(&self) -> bool {\n         self.step.get() > YIELD_LIMIT"}, {"sha": "ed339ca5df669991f3aec60d9e85f6e597918ad6", "filename": "library/std/src/sync/once_lock.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -61,8 +61,9 @@ pub struct OnceLock<T> {\n \n impl<T> OnceLock<T> {\n     /// Creates a new empty cell.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    #[inline]\n     #[must_use]\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new() -> OnceLock<T> {\n         OnceLock {\n             once: Once::new(),\n@@ -75,6 +76,7 @@ impl<T> OnceLock<T> {\n     ///\n     /// Returns `None` if the cell is empty, or being initialized. This\n     /// method never blocks.\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get(&self) -> Option<&T> {\n         if self.is_initialized() {\n@@ -88,6 +90,7 @@ impl<T> OnceLock<T> {\n     /// Gets the mutable reference to the underlying value.\n     ///\n     /// Returns `None` if the cell is empty. This method never blocks.\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_mut(&mut self) -> Option<&mut T> {\n         if self.is_initialized() {\n@@ -125,6 +128,7 @@ impl<T> OnceLock<T> {\n     ///     assert_eq!(CELL.get(), Some(&92));\n     /// }\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn set(&self, value: T) -> Result<(), T> {\n         let mut value = Some(value);\n@@ -164,6 +168,7 @@ impl<T> OnceLock<T> {\n     /// let value = cell.get_or_init(|| unreachable!());\n     /// assert_eq!(value, &92);\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_or_init<F>(&self, f: F) -> &T\n     where\n@@ -203,6 +208,7 @@ impl<T> OnceLock<T> {\n     /// assert_eq!(value, Ok(&92));\n     /// assert_eq!(cell.get(), Some(&92))\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n     where\n@@ -241,6 +247,7 @@ impl<T> OnceLock<T> {\n     /// cell.set(\"hello\".to_string()).unwrap();\n     /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn into_inner(mut self) -> Option<T> {\n         self.take()\n@@ -267,6 +274,7 @@ impl<T> OnceLock<T> {\n     /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n     /// assert_eq!(cell.get(), None);\n     /// ```\n+    #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn take(&mut self) -> Option<T> {\n         if self.is_initialized() {\n@@ -315,6 +323,7 @@ impl<T> OnceLock<T> {\n     /// # Safety\n     ///\n     /// The value must be initialized\n+    #[inline]\n     unsafe fn get_unchecked(&self) -> &T {\n         debug_assert!(self.is_initialized());\n         (&*self.value.get()).assume_init_ref()\n@@ -323,6 +332,7 @@ impl<T> OnceLock<T> {\n     /// # Safety\n     ///\n     /// The value must be initialized\n+    #[inline]\n     unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n         debug_assert!(self.is_initialized());\n         (&mut *self.value.get()).assume_init_mut()\n@@ -360,6 +370,7 @@ impl<T> const Default for OnceLock<T> {\n     ///     assert_eq!(OnceLock::<()>::new(), OnceLock::default());\n     /// }\n     /// ```\n+    #[inline]\n     fn default() -> OnceLock<T> {\n         OnceLock::new()\n     }\n@@ -377,6 +388,7 @@ impl<T: fmt::Debug> fmt::Debug for OnceLock<T> {\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: Clone> Clone for OnceLock<T> {\n+    #[inline]\n     fn clone(&self) -> OnceLock<T> {\n         let cell = Self::new();\n         if let Some(value) = self.get() {\n@@ -408,6 +420,7 @@ impl<T> From<T> for OnceLock<T> {\n     /// Ok(())\n     /// # }\n     /// ```\n+    #[inline]\n     fn from(value: T) -> Self {\n         let cell = Self::new();\n         match cell.set(value) {\n@@ -419,6 +432,7 @@ impl<T> From<T> for OnceLock<T> {\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: PartialEq> PartialEq for OnceLock<T> {\n+    #[inline]\n     fn eq(&self, other: &OnceLock<T>) -> bool {\n         self.get() == other.get()\n     }\n@@ -429,6 +443,7 @@ impl<T: Eq> Eq for OnceLock<T> {}\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n unsafe impl<#[may_dangle] T> Drop for OnceLock<T> {\n+    #[inline]\n     fn drop(&mut self) {\n         if self.is_initialized() {\n             // SAFETY: The cell is initialized and being dropped, so it can't"}, {"sha": "4c054da64714cf1ecd1fe9e136854dde7eb08c0d", "filename": "library/std/src/sync/remutex.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "previous_filename": "library/std/src/sys_common/remutex.rs"}, {"sha": "fc553081d42278b3db24ef2a331534bdab96ffdc", "filename": "library/std/src/sync/remutex/tests.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fremutex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsync%2Fremutex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fremutex%2Ftests.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,6 +1,6 @@\n+use super::{ReentrantMutex, ReentrantMutexGuard};\n use crate::cell::RefCell;\n use crate::sync::Arc;\n-use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread;\n \n #[test]", "previous_filename": "library/std/src/sys_common/remutex/tests.rs"}, {"sha": "535703be33f06474724a37802df9b6d6fb4f7353", "filename": "library/std/src/sys/itron/thread.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -119,7 +119,7 @@ impl Thread {\n \n             let old_lifecycle = inner\n                 .lifecycle\n-                .swap(LIFECYCLE_EXITED_OR_FINISHED_OR_JOIN_FINALIZE, Ordering::Release);\n+                .swap(LIFECYCLE_EXITED_OR_FINISHED_OR_JOIN_FINALIZE, Ordering::AcqRel);\n \n             match old_lifecycle {\n                 LIFECYCLE_DETACHED => {\n@@ -129,9 +129,9 @@ impl Thread {\n \n                     // In this case, `*p_inner`'s ownership has been moved to\n                     // us, and we are responsible for dropping it. The acquire\n-                    // ordering is not necessary because the parent thread made\n-                    // no memory access needing synchronization since the call\n-                    // to `acre_tsk`.\n+                    // ordering ensures that the swap operation that wrote\n+                    // `LIFECYCLE_DETACHED` happens-before `Box::from_raw(\n+                    // p_inner)`.\n                     // Safety: See above.\n                     let _ = unsafe { Box::from_raw(p_inner) };\n \n@@ -151,6 +151,9 @@ impl Thread {\n                     // Since the parent might drop `*inner` and terminate us as\n                     // soon as it sees `JOIN_FINALIZE`, the release ordering\n                     // must be used in the above `swap` call.\n+                    //\n+                    // To make the task referred to by `parent_tid` visible, we\n+                    // must use the acquire ordering in the above `swap` call.\n \n                     // [JOINING \u2192 JOIN_FINALIZE]\n                     // Wake up the parent task.\n@@ -218,11 +221,15 @@ impl Thread {\n \n         let current_task = current_task as usize;\n \n-        match inner.lifecycle.swap(current_task, Ordering::Acquire) {\n+        match inner.lifecycle.swap(current_task, Ordering::AcqRel) {\n             LIFECYCLE_INIT => {\n                 // [INIT \u2192 JOINING]\n                 // The child task will transition the state to `JOIN_FINALIZE`\n                 // and wake us up.\n+                //\n+                // To make the task referred to by `current_task` visible from\n+                // the child task's point of view, we must use the release\n+                // ordering in the above `swap` call.\n                 loop {\n                     expect_success_aborting(unsafe { abi::slp_tsk() }, &\"slp_tsk\");\n                     // To synchronize with the child task's memory accesses to\n@@ -267,15 +274,15 @@ impl Drop for Thread {\n         let inner = unsafe { self.p_inner.as_ref() };\n \n         // Detach the thread.\n-        match inner.lifecycle.swap(LIFECYCLE_DETACHED_OR_JOINED, Ordering::Acquire) {\n+        match inner.lifecycle.swap(LIFECYCLE_DETACHED_OR_JOINED, Ordering::AcqRel) {\n             LIFECYCLE_INIT => {\n                 // [INIT \u2192 DETACHED]\n                 // When the time comes, the child will figure out that no\n                 // one will ever join it.\n                 // The ownership of `*p_inner` is moved to the child thread.\n-                // However, the release ordering is not necessary because we\n-                // made no memory access needing synchronization since the call\n-                // to `acre_tsk`.\n+                // The release ordering ensures that the above swap operation on\n+                // `lifecycle` happens-before the child thread's\n+                // `Box::from_raw(p_inner)`.\n             }\n             LIFECYCLE_FINISHED => {\n                 // [FINISHED \u2192 JOINED]"}, {"sha": "9865a945bad1d17389586da7633767f04eba3991", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -34,7 +34,7 @@ pub mod process;\n pub mod stdio;\n pub mod thread;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n \n mod condvar;"}, {"sha": "1608b8cb642dc858ba13482b2d1f5c72a0ba6bfa", "filename": "library/std/src/sys/sgx/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -65,9 +65,9 @@ mod task_queue {\n /// execution. The signal is sent once all TLS destructors have finished at\n /// which point no new thread locals should be created.\n pub mod wait_notify {\n-    use super::super::thread_parker::Parker;\n     use crate::pin::Pin;\n     use crate::sync::Arc;\n+    use crate::sys_common::thread_parking::Parker;\n \n     pub struct Notifier(Arc<Parker>);\n \n@@ -87,14 +87,14 @@ pub mod wait_notify {\n         /// called, this will return immediately, otherwise the current thread\n         /// is blocked until notified.\n         pub fn wait(self) {\n-            // This is not actually `unsafe`, but it uses the `Parker` API,\n-            // which needs `unsafe` on some platforms.\n+            // SAFETY:\n+            // This is only ever called on one thread.\n             unsafe { Pin::new(&*self.0).park() }\n         }\n     }\n \n     pub fn new() -> (Notifier, Waiter) {\n-        let inner = Arc::new(Parker::new_internal());\n+        let inner = Arc::new(Parker::new());\n         (Notifier(inner.clone()), Waiter(inner))\n     }\n }"}, {"sha": "1c55bcffb1e8c2dc3650e918177026d9b7cc2250", "filename": "library/std/src/sys/sgx/thread_parker.rs", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs?ref=1010099fe359e4a01ebd873e3bdb2d66b60bc3ed", "patch": "@@ -1,107 +0,0 @@\n-//! Thread parking based on SGX events.\n-\n-use super::abi::{thread, usercalls};\n-use crate::io::ErrorKind;\n-use crate::pin::Pin;\n-use crate::ptr::{self, NonNull};\n-use crate::sync::atomic::AtomicPtr;\n-use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n-use crate::time::Duration;\n-use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n-\n-// The TCS structure must be page-aligned (this is checked by EENTER), so these cannot\n-// be valid pointers\n-const EMPTY: *mut u8 = ptr::invalid_mut(1);\n-const NOTIFIED: *mut u8 = ptr::invalid_mut(2);\n-\n-pub struct Parker {\n-    /// The park state. One of EMPTY, NOTIFIED or a TCS address.\n-    /// A state change to NOTIFIED must be done with release ordering\n-    /// and be observed with acquire ordering so that operations after\n-    /// `thread::park` returns will not occur before the unpark message\n-    /// was sent.\n-    state: AtomicPtr<u8>,\n-}\n-\n-impl Parker {\n-    /// Construct the thread parker. The UNIX parker implementation\n-    /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n-        unsafe { parker.write(Parker::new_internal()) }\n-    }\n-\n-    pub(super) fn new_internal() -> Parker {\n-        Parker { state: AtomicPtr::new(EMPTY) }\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let mut prev = EMPTY;\n-            loop {\n-                // Guard against changing TCS addresses by always setting the state to\n-                // the current value.\n-                let tcs = thread::current().as_ptr();\n-                if self.state.compare_exchange(prev, tcs, Relaxed, Acquire).is_ok() {\n-                    let event = usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n-                    assert!(event & EV_UNPARK == EV_UNPARK);\n-                    prev = tcs;\n-                } else {\n-                    // The state was definitely changed by another thread at this point.\n-                    // The only time this occurs is when the state is changed to NOTIFIED.\n-                    // We observed this change with acquire ordering, so we can simply\n-                    // change the state to EMPTY with a relaxed store.\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // At this point, the token was definately read with acquire ordering,\n-        // so this can be a relaxed store.\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n-        let tcs = thread::current().as_ptr();\n-\n-        if self.state.load(Acquire) != NOTIFIED {\n-            if self.state.compare_exchange(EMPTY, tcs, Relaxed, Acquire).is_ok() {\n-                match usercalls::wait(EV_UNPARK, timeout) {\n-                    Ok(event) => assert!(event & EV_UNPARK == EV_UNPARK),\n-                    Err(e) => {\n-                        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n-                    }\n-                }\n-\n-                // Swap to provide acquire ordering even if the timeout occurred\n-                // before the token was set. This situation can result in spurious\n-                // wakeups on the next call to `park_timeout`, but it is better to let\n-                // those be handled by the user than do some perhaps unnecessary, but\n-                // always expensive guarding.\n-                self.state.swap(EMPTY, Acquire);\n-                return;\n-            }\n-        }\n-\n-        // The token was already read with `acquire` ordering, this can be a store.\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // This implementation doesn't require `Pin`, but other implementations do.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-\n-        if !matches!(state, EMPTY | NOTIFIED) {\n-            // There is a thread waiting, wake it up.\n-            let tcs = NonNull::new(state).unwrap();\n-            // This will fail if the thread has already terminated or its TCS is destroyed\n-            // by the time the signal is sent, but that is fine. If another thread receives\n-            // the same TCS, it will receive this notification as a spurious wakeup, but\n-            // all users of `wait` should and (internally) do guard against those where\n-            // necessary.\n-            let _ = usercalls::send(EV_UNPARK, Some(tcs));\n-        }\n-    }\n-}"}, {"sha": "0006cd4f1be2502a1bdc182be8fb37d3981effde", "filename": "library/std/src/sys/sgx/thread_parking.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -0,0 +1,23 @@\n+use super::abi::usercalls;\n+use crate::io::ErrorKind;\n+use crate::time::Duration;\n+use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n+\n+pub type ThreadId = fortanix_sgx_abi::Tcs;\n+\n+pub use super::abi::thread::current;\n+\n+pub fn park(_hint: usize) {\n+    usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n+}\n+\n+pub fn park_timeout(dur: Duration, _hint: usize) {\n+    let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n+    if let Err(e) = usercalls::wait(EV_UNPARK, timeout) {\n+        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n+    }\n+}\n+\n+pub fn unpark(tid: ThreadId, _hint: usize) {\n+    let _ = usercalls::send(EV_UNPARK, Some(tid));\n+}"}, {"sha": "0f704994f550ab5810857a8ca26179ba26ea561f", "filename": "library/std/src/sys/unix/android.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fandroid.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,7 +1,7 @@\n //! Android ABI-compatibility module\n //!\n-//! The ABI of Android has changed quite a bit over time, and libstd attempts to\n-//! be both forwards and backwards compatible as much as possible. We want to\n+//! The ABI of Android has changed quite a bit over time, and std attempts to be\n+//! both forwards and backwards compatible as much as possible. We want to\n //! always work with the most recent version of Android, but we also want to\n //! work with older versions of Android for whenever projects need to.\n //!"}, {"sha": "aea0c26ee8b60e8a2045208b6228a0dc5812d7b5", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1754,11 +1754,11 @@ mod remove_dir_impl {\n     use crate::sys::{cvt, cvt_r};\n \n     #[cfg(not(any(\n-        target_os = \"linux\",\n+        all(target_os = \"linux\", target_env = \"gnu\"),\n         all(target_os = \"macos\", not(target_arch = \"aarch64\"))\n     )))]\n     use libc::{fdopendir, openat, unlinkat};\n-    #[cfg(target_os = \"linux\")]\n+    #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n     use libc::{fdopendir, openat64 as openat, unlinkat};\n     #[cfg(all(target_os = \"macos\", not(target_arch = \"aarch64\")))]\n     use macos_weak::{fdopendir, openat, unlinkat};"}, {"sha": "0f7107122b7e86ecbba33e56b46efcd52ef2fcbc", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -61,9 +61,9 @@ use crate::ptr;\n use crate::sync::atomic::{AtomicBool, AtomicU8, Ordering};\n use crate::sys::cvt;\n use crate::sys::weak::syscall;\n-#[cfg(not(target_os = \"linux\"))]\n+#[cfg(not(all(target_os = \"linux\", target_env = \"gnu\")))]\n use libc::sendfile as sendfile64;\n-#[cfg(target_os = \"linux\")]\n+#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n use libc::sendfile64;\n use libc::{EBADF, EINVAL, ENOSYS, EOPNOTSUPP, EOVERFLOW, EPERM, EXDEV};\n "}, {"sha": "30a96be14300a8f8c07fb2f81cf52af12e640ef6", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -40,7 +40,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n \n #[cfg(target_os = \"espidf\")]\n@@ -95,9 +95,9 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n         )))]\n         'poll: {\n             use crate::sys::os::errno;\n-            #[cfg(not(target_os = \"linux\"))]\n+            #[cfg(not(all(target_os = \"linux\", target_env = \"gnu\")))]\n             use libc::open as open64;\n-            #[cfg(target_os = \"linux\")]\n+            #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n             use libc::open64;\n             let pfds: &mut [_] = &mut [\n                 libc::pollfd { fd: 0, events: 0, revents: 0 },\n@@ -143,9 +143,9 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n         )))]\n         {\n             use crate::sys::os::errno;\n-            #[cfg(not(target_os = \"linux\"))]\n+            #[cfg(not(all(target_os = \"linux\", target_env = \"gnu\")))]\n             use libc::open as open64;\n-            #[cfg(target_os = \"linux\")]\n+            #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n             use libc::open64;\n             for fd in 0..3 {\n                 if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n@@ -164,7 +164,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n     unsafe fn reset_sigpipe(#[allow(unused_variables)] sigpipe: u8) {\n         #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\", target_os = \"horizon\")))]\n         {\n-            // We don't want to add this as a public type to libstd, nor do we\n+            // We don't want to add this as a public type to std, nor do we\n             // want to `include!` a file from the compiler (which would break\n             // Miri and xargo for example), so we choose to duplicate these\n             // constants from `compiler/rustc_session/src/config/sigpipe.rs`.\n@@ -184,12 +184,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n                 sigpipe::SIG_DFL => (true, Some(libc::SIG_DFL)),\n                 _ => unreachable!(),\n             };\n-            // The bootstrap compiler doesn't know about sigpipe::DEFAULT, and always passes in\n-            // SIG_IGN. This causes some tests to fail because they expect SIGPIPE to be reset to\n-            // default on process spawning (which doesn't happen if #[unix_sigpipe] is specified).\n-            // Since we can't differentiate between the cases here, treat SIG_IGN as DEFAULT\n-            // unconditionally.\n-            if sigpipe_attr_specified && !(cfg!(bootstrap) && sigpipe == sigpipe::SIG_IGN) {\n+            if sigpipe_attr_specified {\n                 UNIX_SIGPIPE_ATTR_SPECIFIED.store(true, crate::sync::atomic::Ordering::Relaxed);\n             }\n             if let Some(handler) = handler {"}, {"sha": "c86f80972a69de412dd1ac0a26561353df056f1a", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -512,7 +512,7 @@ impl FromRawFd for Socket {\n // A workaround for this bug is to call the res_init libc function, to clear\n // the cached configs. Unfortunately, while we believe glibc's implementation\n // of res_init is thread-safe, we know that other implementations are not\n-// (https://github.com/rust-lang/rust/issues/43592). Code here in libstd could\n+// (https://github.com/rust-lang/rust/issues/43592). Code here in std could\n // try to synchronize its res_init calls with a Mutex, but that wouldn't\n // protect programs that call into libc in other ways. So instead of calling\n // res_init unconditionally, we call it only when we detect we're linking"}, {"sha": "afd03d79c0ba6cef9747d003c760adfc07f2c721", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -144,6 +144,7 @@ pub enum ChildStdio {\n     Null,\n }\n \n+#[derive(Debug)]\n pub enum Stdio {\n     Inherit,\n     Null,\n@@ -510,16 +511,68 @@ impl ChildStdio {\n }\n \n impl fmt::Debug for Command {\n+    // show all attributes but `self.closures` which does not implement `Debug`\n+    // and `self.argv` which is not useful for debugging\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.program != self.args[0] {\n-            write!(f, \"[{:?}] \", self.program)?;\n-        }\n-        write!(f, \"{:?}\", self.args[0])?;\n+        if f.alternate() {\n+            let mut debug_command = f.debug_struct(\"Command\");\n+            debug_command.field(\"program\", &self.program).field(\"args\", &self.args);\n+            if !self.env.is_unchanged() {\n+                debug_command.field(\"env\", &self.env);\n+            }\n+\n+            if self.cwd.is_some() {\n+                debug_command.field(\"cwd\", &self.cwd);\n+            }\n+            if self.uid.is_some() {\n+                debug_command.field(\"uid\", &self.uid);\n+            }\n+            if self.gid.is_some() {\n+                debug_command.field(\"gid\", &self.gid);\n+            }\n+\n+            if self.groups.is_some() {\n+                debug_command.field(\"groups\", &self.groups);\n+            }\n+\n+            if self.stdin.is_some() {\n+                debug_command.field(\"stdin\", &self.stdin);\n+            }\n+            if self.stdout.is_some() {\n+                debug_command.field(\"stdout\", &self.stdout);\n+            }\n+            if self.stderr.is_some() {\n+                debug_command.field(\"stderr\", &self.stderr);\n+            }\n+            if self.pgroup.is_some() {\n+                debug_command.field(\"pgroup\", &self.pgroup);\n+            }\n+\n+            #[cfg(target_os = \"linux\")]\n+            {\n+                debug_command.field(\"create_pidfd\", &self.create_pidfd);\n+            }\n \n-        for arg in &self.args[1..] {\n-            write!(f, \" {:?}\", arg)?;\n+            debug_command.finish()\n+        } else {\n+            if let Some(ref cwd) = self.cwd {\n+                write!(f, \"cd {cwd:?} && \")?;\n+            }\n+            for (key, value_opt) in self.get_envs() {\n+                if let Some(value) = value_opt {\n+                    write!(f, \"{}={value:?} \", key.to_string_lossy())?;\n+                }\n+            }\n+            if self.program != self.args[0] {\n+                write!(f, \"[{:?}] \", self.program)?;\n+            }\n+            write!(f, \"{:?}\", self.args[0])?;\n+\n+            for arg in &self.args[1..] {\n+                write!(f, \" {:?}\", arg)?;\n+            }\n+            Ok(())\n         }\n-        Ok(())\n     }\n }\n "}, {"sha": "b59d4ba26afb9b3d4d7259bc85a87f6955564741", "filename": "library/std/src/sys/unix/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstack_overflow.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -45,9 +45,9 @@ mod imp {\n     use crate::thread;\n \n     use libc::MAP_FAILED;\n-    #[cfg(not(target_os = \"linux\"))]\n+    #[cfg(not(all(target_os = \"linux\", target_env = \"gnu\")))]\n     use libc::{mmap as mmap64, munmap};\n-    #[cfg(target_os = \"linux\")]\n+    #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n     use libc::{mmap64, munmap};\n     use libc::{sigaction, sighandler_t, SA_ONSTACK, SA_SIGINFO, SIGBUS, SIG_DFL};\n     use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};"}, {"sha": "b251949bda207e1bf0fcfa99750e7311f4412dce", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -505,7 +505,7 @@ mod cgroups {\n                     let limit = raw_quota.next()?;\n                     let period = raw_quota.next()?;\n                     match (limit.parse::<usize>(), period.parse::<usize>()) {\n-                        (Ok(limit), Ok(period)) => {\n+                        (Ok(limit), Ok(period)) if period > 0 => {\n                             quota = quota.min(limit / period);\n                         }\n                         _ => {}\n@@ -565,7 +565,7 @@ mod cgroups {\n                 let period = parse_file(\"cpu.cfs_period_us\");\n \n                 match (limit, period) {\n-                    (Some(limit), Some(period)) => quota = quota.min(limit / period),\n+                    (Some(limit), Some(period)) if period > 0 => quota = quota.min(limit / period),\n                     _ => {}\n                 }\n \n@@ -653,9 +653,9 @@ pub mod guard {\n ))]\n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n-    #[cfg(not(target_os = \"linux\"))]\n+    #[cfg(not(all(target_os = \"linux\", target_env = \"gnu\")))]\n     use libc::{mmap as mmap64, mprotect};\n-    #[cfg(target_os = \"linux\")]\n+    #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n     use libc::{mmap64, mprotect};\n     use libc::{MAP_ANON, MAP_FAILED, MAP_FIXED, MAP_PRIVATE, PROT_NONE, PROT_READ, PROT_WRITE};\n "}, {"sha": "7657605b52f0d99d70db8599d5cb5d5b32d86be2", "filename": "library/std/src/sys/unix/thread_parker/netbsd.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1010099fe359e4a01ebd873e3bdb2d66b60bc3ed/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs?ref=1010099fe359e4a01ebd873e3bdb2d66b60bc3ed", "patch": "@@ -1,113 +0,0 @@\n-use crate::ffi::{c_int, c_void};\n-use crate::pin::Pin;\n-use crate::ptr::{null, null_mut};\n-use crate::sync::atomic::{\n-    AtomicU64,\n-    Ordering::{Acquire, Relaxed, Release},\n-};\n-use crate::time::Duration;\n-use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n-\n-extern \"C\" {\n-    fn ___lwp_park60(\n-        clock_id: clockid_t,\n-        flags: c_int,\n-        ts: *mut timespec,\n-        unpark: lwpid_t,\n-        hint: *const c_void,\n-        unparkhint: *const c_void,\n-    ) -> c_int;\n-    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n-}\n-\n-/// The thread is not parked and the token is not available.\n-///\n-/// Zero cannot be a valid LWP id, since it is used as empty value for the unpark\n-/// argument in _lwp_park.\n-const EMPTY: u64 = 0;\n-/// The token is available. Do not park anymore.\n-const NOTIFIED: u64 = u64::MAX;\n-\n-pub struct Parker {\n-    /// The parker state. Contains either one of the two state values above or the LWP\n-    /// id of the parked thread.\n-    state: AtomicU64,\n-}\n-\n-impl Parker {\n-    pub unsafe fn new(parker: *mut Parker) {\n-        parker.write(Parker { state: AtomicU64::new(EMPTY) })\n-    }\n-\n-    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        // If the token has already been made available, we can skip\n-        // a bit of work, so check for it here.\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let parked = _lwp_self() as u64;\n-            let hint = self.state.as_mut_ptr().cast();\n-            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n-                // Loop to guard against spurious wakeups.\n-                loop {\n-                    ___lwp_park60(0, 0, null_mut(), 0, hint, null());\n-                    if self.state.load(Acquire) == NOTIFIED {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // At this point, the change to NOTIFIED has always been observed with acquire\n-        // ordering, so we can just use a relaxed store here (instead of a swap).\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let parked = _lwp_self() as u64;\n-            let hint = self.state.as_mut_ptr().cast();\n-            let mut timeout = timespec {\n-                // Saturate so that the operation will definitely time out\n-                // (even if it is after the heat death of the universe).\n-                tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n-                tv_nsec: dur.subsec_nanos().into(),\n-            };\n-\n-            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n-                // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n-                // above.\n-                ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, hint, null());\n-                // Use a swap to get acquire ordering even if the token was set after\n-                // the timeout occurred.\n-                self.state.swap(EMPTY, Acquire);\n-                return;\n-            }\n-        }\n-\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // Does not actually need `Pin`, but the pthread implementation does.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-        if !matches!(state, EMPTY | NOTIFIED) {\n-            let lwp = state as lwpid_t;\n-            let hint = self.state.as_mut_ptr().cast();\n-\n-            // If the parking thread terminated and did not actually park, this will\n-            // probably return an error, which is OK. In the worst case, another\n-            // thread has received the same LWP id. It will then receive a spurious\n-            // wakeup, but those are allowable per the API contract. The same reasoning\n-            // applies if a timeout occurred before this call, but the state was not\n-            // yet reset.\n-\n-            // SAFETY:\n-            // The syscall has no invariants to hold. Only unsafe because it is an\n-            // extern function.\n-            unsafe {\n-                _lwp_unpark(lwp, hint);\n-            }\n-        }\n-    }\n-}"}, {"sha": "b709fada3b4a805f1421f7c408f9ac266caf9115", "filename": "library/std/src/sys/unix/thread_parking/darwin.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -46,7 +46,7 @@ unsafe impl Sync for Parker {}\n unsafe impl Send for Parker {}\n \n impl Parker {\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         let semaphore = dispatch_semaphore_create(0);\n         assert!(\n             !semaphore.is_null(),", "previous_filename": "library/std/src/sys/unix/thread_parker/darwin.rs"}, {"sha": "185333c072f49246d1315347e1040da660f1ad59", "filename": "library/std/src/sys/unix/thread_parking/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -24,7 +24,7 @@ cfg_if::cfg_if! {\n         pub use darwin::Parker;\n     } else if #[cfg(target_os = \"netbsd\")] {\n         mod netbsd;\n-        pub use netbsd::Parker;\n+        pub use netbsd::{current, park, park_timeout, unpark, ThreadId};\n     } else {\n         mod pthread;\n         pub use pthread::Parker;", "previous_filename": "library/std/src/sys/unix/thread_parker/mod.rs"}, {"sha": "3be08122138ab249790f19cf3c21566ee254fcf8", "filename": "library/std/src/sys/unix/thread_parking/netbsd.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -0,0 +1,52 @@\n+use crate::ffi::{c_int, c_void};\n+use crate::ptr;\n+use crate::time::Duration;\n+use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n+\n+extern \"C\" {\n+    fn ___lwp_park60(\n+        clock_id: clockid_t,\n+        flags: c_int,\n+        ts: *mut timespec,\n+        unpark: lwpid_t,\n+        hint: *const c_void,\n+        unparkhint: *const c_void,\n+    ) -> c_int;\n+    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n+}\n+\n+pub type ThreadId = lwpid_t;\n+\n+#[inline]\n+pub fn current() -> ThreadId {\n+    unsafe { _lwp_self() }\n+}\n+\n+#[inline]\n+pub fn park(hint: usize) {\n+    unsafe {\n+        ___lwp_park60(0, 0, ptr::null_mut(), 0, ptr::invalid(hint), ptr::null());\n+    }\n+}\n+\n+pub fn park_timeout(dur: Duration, hint: usize) {\n+    let mut timeout = timespec {\n+        // Saturate so that the operation will definitely time out\n+        // (even if it is after the heat death of the universe).\n+        tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n+        tv_nsec: dur.subsec_nanos().into(),\n+    };\n+\n+    // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n+    // above.\n+    unsafe {\n+        ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, ptr::invalid(hint), ptr::null());\n+    }\n+}\n+\n+#[inline]\n+pub fn unpark(tid: ThreadId, hint: usize) {\n+    unsafe {\n+        _lwp_unpark(tid, ptr::invalid(hint));\n+    }\n+}"}, {"sha": "082d25e68f587ad9a424b076b348a2814b011894", "filename": "library/std/src/sys/unix/thread_parking/pthread.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -44,7 +44,8 @@ unsafe fn wait_timeout(\n         target_os = \"macos\",\n         target_os = \"ios\",\n         target_os = \"watchos\",\n-        target_os = \"espidf\"\n+        target_os = \"espidf\",\n+        target_os = \"horizon\",\n     ))]\n     let (now, dur) = {\n         use crate::cmp::min;\n@@ -70,7 +71,8 @@ unsafe fn wait_timeout(\n         target_os = \"macos\",\n         target_os = \"ios\",\n         target_os = \"watchos\",\n-        target_os = \"espidf\"\n+        target_os = \"espidf\",\n+        target_os = \"horizon\",\n     )))]\n     let (now, dur) = {\n         use crate::sys::time::Timespec;\n@@ -97,7 +99,7 @@ impl Parker {\n     ///\n     /// # Safety\n     /// The constructed parker must never be moved.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         // Use the default mutex implementation to allow for simpler initialization.\n         // This could lead to undefined behaviour when deadlocking. This is avoided\n         // by not deadlocking. Note in particular the unlocking operation before any", "previous_filename": "library/std/src/sys/unix/thread_parker/pthread.rs"}, {"sha": "62ffee70becc3d2d56ba87446d2f3b28ea290643", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,9 +1,8 @@\n //! Support for \"weak linkage\" to symbols on Unix\n //!\n-//! Some I/O operations we do in libstd require newer versions of OSes but we\n-//! need to maintain binary compatibility with older releases for now. In order\n-//! to use the new functionality when available we use this module for\n-//! detection.\n+//! Some I/O operations we do in std require newer versions of OSes but we need\n+//! to maintain binary compatibility with older releases for now. In order to\n+//! use the new functionality when available we use this module for detection.\n //!\n //! One option to use here is weak linkage, but that is unfortunately only\n //! really workable with ELF. Otherwise, use dlsym to get the symbol value at\n@@ -29,7 +28,7 @@ use crate::ptr;\n use crate::sync::atomic::{self, AtomicPtr, Ordering};\n \n // We can use true weak linkage on ELF targets.\n-#[cfg(all(not(any(target_os = \"macos\", target_os = \"ios\")), not(bootstrap)))]\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n pub(crate) macro weak {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n         let ref $name: ExternWeak<unsafe extern \"C\" fn($($t),*) -> $ret> = {\n@@ -43,30 +42,14 @@ pub(crate) macro weak {\n     )\n }\n \n-#[cfg(all(not(any(target_os = \"macos\", target_os = \"ios\")), bootstrap))]\n-pub(crate) macro weak {\n-    (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n-        let ref $name: ExternWeak<unsafe extern \"C\" fn($($t),*) -> $ret> = {\n-            extern \"C\" {\n-                #[linkage = \"extern_weak\"]\n-                static $name: *const libc::c_void;\n-            }\n-            #[allow(unused_unsafe)]\n-            ExternWeak::new(unsafe { $name })\n-        };\n-    )\n-}\n-\n // On non-ELF targets, use the dlsym approximation of weak linkage.\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n pub(crate) use self::dlsym as weak;\n \n-#[cfg(not(bootstrap))]\n pub(crate) struct ExternWeak<F: Copy> {\n     weak_ptr: Option<F>,\n }\n \n-#[cfg(not(bootstrap))]\n impl<F: Copy> ExternWeak<F> {\n     #[inline]\n     pub(crate) fn new(weak_ptr: Option<F>) -> Self {\n@@ -79,34 +62,6 @@ impl<F: Copy> ExternWeak<F> {\n     }\n }\n \n-#[cfg(bootstrap)]\n-pub(crate) struct ExternWeak<F> {\n-    weak_ptr: *const libc::c_void,\n-    _marker: PhantomData<F>,\n-}\n-\n-#[cfg(bootstrap)]\n-impl<F> ExternWeak<F> {\n-    #[inline]\n-    pub(crate) fn new(weak_ptr: *const libc::c_void) -> Self {\n-        ExternWeak { weak_ptr, _marker: PhantomData }\n-    }\n-}\n-\n-#[cfg(bootstrap)]\n-impl<F> ExternWeak<F> {\n-    #[inline]\n-    pub(crate) fn get(&self) -> Option<F> {\n-        unsafe {\n-            if self.weak_ptr.is_null() {\n-                None\n-            } else {\n-                Some(mem::transmute_copy::<*const libc::c_void, F>(&self.weak_ptr))\n-            }\n-        }\n-    }\n-}\n-\n pub(crate) macro dlsym {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n          dlsym!(fn $name($($t),*) -> $ret, stringify!($name));"}, {"sha": "77359abe429950869a9c82bbb5477e1a2f3cd6af", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -33,7 +33,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n cfg_if::cfg_if! {\n     if #[cfg(not(target_vendor = \"uwp\"))] {"}, {"sha": "5d43676adbb11f0428d99c796fe58eaa3b3b2c45", "filename": "library/std/src/sys/windows/thread_parking.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -97,7 +97,7 @@ const NOTIFIED: i8 = 1;\n impl Parker {\n     /// Construct the Windows parker. The UNIX parker implementation\n     /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Self { state: AtomicI8::new(EMPTY) });\n     }\n ", "previous_filename": "library/std/src/sys/windows/thread_parker.rs"}, {"sha": "f1d804ef40c0e60786d568a4249bb80e42f63b91", "filename": "library/std/src/sys_common/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -20,7 +20,7 @@ pub fn lock() -> impl Drop {\n /// Prints the current backtrace.\n pub fn print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n     // There are issues currently linking libbacktrace into tests, and in\n-    // general during libstd's own unit tests we're not testing this path. In\n+    // general during std's own unit tests we're not testing this path. In\n     // test mode immediately return here to optimize away any references to the\n     // libbacktrace symbols\n     if cfg!(test) {\n@@ -111,7 +111,7 @@ unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::\n }\n \n /// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`. Note that\n-/// this is only inline(never) when backtraces in libstd are enabled, otherwise\n+/// this is only inline(never) when backtraces in std are enabled, otherwise\n /// it's fine to optimize away.\n #[cfg_attr(feature = \"backtrace\", inline(never))]\n pub fn __rust_begin_short_backtrace<F, T>(f: F) -> T\n@@ -127,7 +127,7 @@ where\n }\n \n /// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`. Note that\n-/// this is only inline(never) when backtraces in libstd are enabled, otherwise\n+/// this is only inline(never) when backtraces in std are enabled, otherwise\n /// it's fine to optimize away.\n #[cfg_attr(feature = \"backtrace\", inline(never))]\n pub fn __rust_end_short_backtrace<F, T>(f: F) -> T"}, {"sha": "6b24b0e9aa8be85129f6a62bfb074db63d39e7ec", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -27,11 +27,10 @@ pub mod lazy_box;\n pub mod memchr;\n pub mod once;\n pub mod process;\n-pub mod remutex;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local_dtor;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod wstr;\n pub mod wtf8;\n "}, {"sha": "18883048daef195b2f99a82b0dbdea3e36698e5b", "filename": "library/std/src/sys_common/process.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fprocess.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -4,12 +4,13 @@\n use crate::collections::BTreeMap;\n use crate::env;\n use crate::ffi::{OsStr, OsString};\n+use crate::fmt;\n use crate::io;\n use crate::sys::pipe::read2;\n use crate::sys::process::{EnvKey, ExitStatus, Process, StdioPipes};\n \n // Stores a set of changes to an environment\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct CommandEnv {\n     clear: bool,\n     saw_path: bool,\n@@ -22,6 +23,14 @@ impl Default for CommandEnv {\n     }\n }\n \n+impl fmt::Debug for CommandEnv {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut debug_command_env = f.debug_struct(\"CommandEnv\");\n+        debug_command_env.field(\"clear\", &self.clear).field(\"vars\", &self.vars);\n+        debug_command_env.finish()\n+    }\n+}\n+\n impl CommandEnv {\n     // Capture the current environment with these changes applied\n     pub fn capture(&self) -> BTreeMap<EnvKey, OsString> {"}, {"sha": "2672a2a75b017bc4cec15931f3f68cfad622f7ea", "filename": "library/std/src/sys_common/thread_local_key.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -117,10 +117,14 @@ pub struct Key {\n /// This value specifies no destructor by default.\n pub const INIT: StaticKey = StaticKey::new(None);\n \n+// Define a sentinel value that is unlikely to be returned\n+// as a TLS key (but it may be returned).\n+const KEY_SENTVAL: usize = 0;\n+\n impl StaticKey {\n     #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n     pub const fn new(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> StaticKey {\n-        StaticKey { key: atomic::AtomicUsize::new(0), dtor }\n+        StaticKey { key: atomic::AtomicUsize::new(KEY_SENTVAL), dtor }\n     }\n \n     /// Gets the value associated with this TLS key\n@@ -144,31 +148,36 @@ impl StaticKey {\n     #[inline]\n     unsafe fn key(&self) -> imp::Key {\n         match self.key.load(Ordering::Relaxed) {\n-            0 => self.lazy_init() as imp::Key,\n+            KEY_SENTVAL => self.lazy_init() as imp::Key,\n             n => n as imp::Key,\n         }\n     }\n \n     unsafe fn lazy_init(&self) -> usize {\n-        // POSIX allows the key created here to be 0, but the compare_exchange\n-        // below relies on using 0 as a sentinel value to check who won the\n+        // POSIX allows the key created here to be KEY_SENTVAL, but the compare_exchange\n+        // below relies on using KEY_SENTVAL as a sentinel value to check who won the\n         // race to set the shared TLS key. As far as I know, there is no\n         // guaranteed value that cannot be returned as a posix_key_create key,\n         // so there is no value we can initialize the inner key with to\n         // prove that it has not yet been set. As such, we'll continue using a\n-        // value of 0, but with some gyrations to make sure we have a non-0\n+        // value of KEY_SENTVAL, but with some gyrations to make sure we have a non-KEY_SENTVAL\n         // value returned from the creation routine.\n         // FIXME: this is clearly a hack, and should be cleaned up.\n         let key1 = imp::create(self.dtor);\n-        let key = if key1 != 0 {\n+        let key = if key1 as usize != KEY_SENTVAL {\n             key1\n         } else {\n             let key2 = imp::create(self.dtor);\n             imp::destroy(key1);\n             key2\n         };\n-        rtassert!(key != 0);\n-        match self.key.compare_exchange(0, key as usize, Ordering::SeqCst, Ordering::SeqCst) {\n+        rtassert!(key as usize != KEY_SENTVAL);\n+        match self.key.compare_exchange(\n+            KEY_SENTVAL,\n+            key as usize,\n+            Ordering::SeqCst,\n+            Ordering::SeqCst,\n+        ) {\n             // The CAS succeeded, so we've created the actual key\n             Ok(_) => key as usize,\n             // If someone beat us to the punch, use their key instead"}, {"sha": "588e7b27826f6633ed6ba4c6b8f8f95192c52aac", "filename": "library/std/src/sys_common/thread_parking/futex.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -35,7 +35,7 @@ pub struct Parker {\n impl Parker {\n     /// Construct the futex parker. The UNIX parker implementation\n     /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Self { state: AtomicU32::new(EMPTY) });\n     }\n ", "previous_filename": "library/std/src/sys_common/thread_parker/futex.rs"}, {"sha": "3209bffe353ed81b775a8b7869789824d1a052b1", "filename": "library/std/src/sys_common/thread_parking/generic.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -19,7 +19,7 @@ pub struct Parker {\n impl Parker {\n     /// Construct the generic parker. The UNIX parker implementation\n     /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Parker {\n             state: AtomicUsize::new(EMPTY),\n             lock: Mutex::new(()),", "previous_filename": "library/std/src/sys_common/thread_parker/generic.rs"}, {"sha": "e98169597c378011d3e044251d69e813fbd119f6", "filename": "library/std/src/sys_common/thread_parking/id.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -0,0 +1,108 @@\n+//! Thread parking using thread ids.\n+//!\n+//! Some platforms (notably NetBSD) have thread parking primitives whose semantics\n+//! match those offered by `thread::park`, with the difference that the thread to\n+//! be unparked is referenced by a platform-specific thread id. Since the thread\n+//! parker is constructed before that id is known, an atomic state variable is used\n+//! to manage the park state and propagate the thread id. This also avoids platform\n+//! calls in the case where `unpark` is called before `park`.\n+\n+use crate::cell::UnsafeCell;\n+use crate::pin::Pin;\n+use crate::sync::atomic::{\n+    fence, AtomicI8,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::thread_parking::{current, park, park_timeout, unpark, ThreadId};\n+use crate::time::Duration;\n+\n+pub struct Parker {\n+    state: AtomicI8,\n+    tid: UnsafeCell<Option<ThreadId>>,\n+}\n+\n+const PARKED: i8 = -1;\n+const EMPTY: i8 = 0;\n+const NOTIFIED: i8 = 1;\n+\n+impl Parker {\n+    pub fn new() -> Parker {\n+        Parker { state: AtomicI8::new(EMPTY), tid: UnsafeCell::new(None) }\n+    }\n+\n+    /// Create a new thread parker. UNIX requires this to happen in-place.\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n+        parker.write(Parker::new())\n+    }\n+\n+    /// # Safety\n+    /// * must always be called from the same thread\n+    /// * must be called before the state is set to PARKED\n+    unsafe fn init_tid(&self) {\n+        // The field is only ever written to from this thread, so we don't need\n+        // synchronization to read it here.\n+        if self.tid.get().read().is_none() {\n+            // Because this point is only reached once, before the state is set\n+            // to PARKED for the first time, the non-atomic write here can not\n+            // conflict with reads by other threads.\n+            self.tid.get().write(Some(current()));\n+            // Ensure that the write can be observed by all threads reading the\n+            // state. Synchronizes with the acquire barrier in `unpark`.\n+            fence(Release);\n+        }\n+    }\n+\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        self.init_tid();\n+\n+        // Changes NOTIFIED to EMPTY and EMPTY to PARKED.\n+        let mut state = self.state.fetch_sub(1, Acquire).wrapping_sub(1);\n+        if state == PARKED {\n+            // Loop to guard against spurious wakeups.\n+            while state == PARKED {\n+                park(self.state.as_mut_ptr().addr());\n+                state = self.state.load(Acquire);\n+            }\n+\n+            // Since the state change has already been observed with acquire\n+            // ordering, the state can be reset with a relaxed store instead\n+            // of a swap.\n+            self.state.store(EMPTY, Relaxed);\n+        }\n+    }\n+\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        self.init_tid();\n+\n+        let state = self.state.fetch_sub(1, Acquire).wrapping_sub(1);\n+        if state == PARKED {\n+            park_timeout(dur, self.state.as_mut_ptr().addr());\n+            // Swap to ensure that we observe all state changes with acquire\n+            // ordering, even if the state has been changed after the timeout\n+            // occured.\n+            self.state.swap(EMPTY, Acquire);\n+        }\n+    }\n+\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+        if state == PARKED {\n+            // Synchronize with the release fence in `init_tid` to observe the\n+            // write to `tid`.\n+            fence(Acquire);\n+            // # Safety\n+            // The thread id is initialized before the state is set to `PARKED`\n+            // for the first time and is not written to from that point on\n+            // (negating the need for an atomic read).\n+            let tid = unsafe { self.tid.get().read().unwrap_unchecked() };\n+            // It is possible that the waiting thread woke up because of a timeout\n+            // and terminated before this call is made. This call then returns an\n+            // error or wakes up an unrelated thread. The platform API and\n+            // environment does allow this, however.\n+            unpark(tid, self.state.as_mut_ptr().addr());\n+        }\n+    }\n+}\n+\n+unsafe impl Send for Parker {}\n+unsafe impl Sync for Parker {}"}, {"sha": "0ead6633c3501bd5302a4f11c3865267cd6b5d8d", "filename": "library/std/src/sys_common/thread_parking/mod.rs", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -11,13 +11,17 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         pub use futex::Parker;\n+    } else if #[cfg(any(\n+        target_os = \"netbsd\",\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+    ))] {\n+        mod id;\n+        pub use id::Parker;\n     } else if #[cfg(target_os = \"solid_asp3\")] {\n         mod wait_flag;\n         pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n-        pub use crate::sys::thread_parker::Parker;\n-    } else if #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] {\n-        pub use crate::sys::thread_parker::Parker;\n+        pub use crate::sys::thread_parking::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;", "previous_filename": "library/std/src/sys_common/thread_parker/mod.rs"}, {"sha": "d0f8899a94eb8507ff233f5d8321bf576fc8827e", "filename": "library/std/src/sys_common/thread_parking/wait_flag.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -41,7 +41,7 @@ pub struct Parker {\n impl Parker {\n     /// Construct a parker for the current thread. The UNIX parker\n     /// implementation requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Parker { state: AtomicI8::new(EMPTY), wait_flag: WaitFlag::new() })\n     }\n ", "previous_filename": "library/std/src/sys_common/thread_parker/wait_flag.rs"}, {"sha": "b30bb7b77efb25bdc1e7e43358eaa3c702a8779b", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -905,9 +905,8 @@ pub mod statik {\n pub mod fast {\n     use super::lazy::LazyKeyInner;\n     use crate::cell::Cell;\n-    use crate::fmt;\n-    use crate::mem;\n     use crate::sys::thread_local_dtor::register_dtor;\n+    use crate::{fmt, mem, panic};\n \n     #[derive(Copy, Clone)]\n     enum DtorState {\n@@ -950,7 +949,7 @@ pub mod fast {\n \n         // note that this is just a publicly-callable function only for the\n         // const-initialized form of thread locals, basically a way to call the\n-        // free `register_dtor` function defined elsewhere in libstd.\n+        // free `register_dtor` function defined elsewhere in std.\n         pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n             unsafe {\n                 register_dtor(a, dtor);\n@@ -1028,10 +1027,15 @@ pub mod fast {\n         // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n         // causes future calls to `get` to run `try_initialize_drop` again,\n         // which will now fail, and return `None`.\n-        unsafe {\n+        //\n+        // Wrap the call in a catch to ensure unwinding is caught in the event\n+        // a panic takes place in a destructor.\n+        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| unsafe {\n             let value = (*ptr).inner.take();\n             (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n             drop(value);\n+        })) {\n+            rtabort!(\"thread local panicked on drop\");\n         }\n     }\n }\n@@ -1044,10 +1048,8 @@ pub mod fast {\n pub mod os {\n     use super::lazy::LazyKeyInner;\n     use crate::cell::Cell;\n-    use crate::fmt;\n-    use crate::marker;\n-    use crate::ptr;\n     use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n+    use crate::{fmt, marker, panic, ptr};\n \n     /// Use a regular global static to store this key; the state provided will then be\n     /// thread-local.\n@@ -1137,12 +1139,17 @@ pub mod os {\n         //\n         // Note that to prevent an infinite loop we reset it back to null right\n         // before we return from the destructor ourselves.\n-        unsafe {\n+        //\n+        // Wrap the call in a catch to ensure unwinding is caught in the event\n+        // a panic takes place in a destructor.\n+        if let Err(_) = panic::catch_unwind(|| unsafe {\n             let ptr = Box::from_raw(ptr as *mut Value<T>);\n             let key = ptr.key;\n             key.os.set(ptr::invalid_mut(1));\n             drop(ptr);\n             key.os.set(ptr::null_mut());\n+        }) {\n+            rtabort!(\"thread local panicked on drop\");\n         }\n     }\n }"}, {"sha": "7acda8e98f18fcf75bf3b8f97334832b949bb0f6", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -173,7 +173,7 @@ use crate::sync::Arc;\n use crate::sys::thread as imp;\n use crate::sys_common::thread;\n use crate::sys_common::thread_info;\n-use crate::sys_common::thread_parker::Parker;\n+use crate::sys_common::thread_parking::Parker;\n use crate::sys_common::{AsInner, IntoInner};\n use crate::time::Duration;\n \n@@ -1216,7 +1216,7 @@ impl Thread {\n             let ptr = Arc::get_mut_unchecked(&mut arc).as_mut_ptr();\n             addr_of_mut!((*ptr).name).write(name);\n             addr_of_mut!((*ptr).id).write(ThreadId::new());\n-            Parker::new(addr_of_mut!((*ptr).parker));\n+            Parker::new_in_place(addr_of_mut!((*ptr).parker));\n             Pin::new_unchecked(arc.assume_init())\n         };\n "}, {"sha": "1a2c125566139d11370637b368d3d954314586ff", "filename": "library/std/tests/run-time-detect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Ftests%2Frun-time-detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Fstd%2Ftests%2Frun-time-detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Ftests%2Frun-time-detect.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,9 +1,8 @@\n-//! These tests just check that the macros are available in libstd.\n+//! These tests just check that the macros are available in std.\n \n #![cfg_attr(\n     any(\n         all(target_arch = \"arm\", any(target_os = \"linux\", target_os = \"android\")),\n-        all(bootstrap, target_arch = \"aarch64\", any(target_os = \"linux\", target_os = \"android\")),\n         all(target_arch = \"powerpc\", target_os = \"linux\"),\n         all(target_arch = \"powerpc64\", target_os = \"linux\"),\n     ),"}, {"sha": "036a35869a5b277568968990ac228a0fe28b80e5", "filename": "library/unwind/src/libunwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Funwind%2Fsrc%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/library%2Funwind%2Fsrc%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flibunwind.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -88,7 +88,7 @@ pub type _Unwind_Exception_Cleanup_Fn =\n     extern \"C\" fn(unwind_code: _Unwind_Reason_Code, exception: *mut _Unwind_Exception);\n \n // FIXME: The `#[link]` attributes on `extern \"C\"` block marks those symbols declared in\n-// the block are reexported in dylib build of libstd. This is needed when build rustc with\n+// the block are reexported in dylib build of std. This is needed when build rustc with\n // feature `llvm-libunwind', as no other cdylib will provided those _Unwind_* symbols.\n // However the `link` attribute is duplicated multiple times and does not just export symbol,\n // a better way to manually export symbol would be another attribute like `#[export]`."}, {"sha": "4105fa5ec96006ac611439266af31ba70809084d", "filename": "src/bootstrap/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCHANGELOG.md?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -15,6 +15,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n - Several unsupported `./configure` options have been removed: `optimize`, `parallel-compiler`. These can still be enabled with `--set`, although it isn't recommended.\n - `remote-test-server`'s `verbose` argument has been removed in favor of the `--verbose` flag\n - `remote-test-server`'s `remote` argument has been removed in favor of the `--bind` flag. Use `--bind 0.0.0.0:12345` to replicate the behavior of the `remote` argument.\n+- `x.py fmt` now formats only files modified between the merge-base of HEAD and the last commit in the master branch of the rust-lang repository and the current working directory. To restore old behaviour, use `x.py fmt .`. The check mode is not affected by this change. [#105702](https://github.com/rust-lang/rust/pull/105702)\n \n ### Non-breaking changes\n "}, {"sha": "79c2eb31cdae07b3fca56104c8d9b806bfc87276", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -80,18 +80,12 @@ The script accepts commands, flags, and arguments to determine what to do:\n \n ## Configuring rustbuild\n \n-There are currently two methods for configuring the rustbuild build system.\n-\n-First, rustbuild offers a TOML-based configuration system with a `config.toml`\n+rustbuild offers a TOML-based configuration system with a `config.toml`\n file. An example of this configuration can be found at `config.toml.example`,\n and the configuration file can also be passed as `--config path/to/config.toml`\n if the build system is being invoked manually (via the python script).\n \n-Next, the `./configure` options serialized in `config.mk` will be\n-parsed and read. That is, if any `./configure` options are passed, they'll be\n-handled naturally. `./configure` should almost never be used for local\n-installations, and is primarily useful for CI. Prefer to customize behavior\n-using `config.toml`.\n+You can generate a config.toml using `./configure` options if you want to automate creating the file without having to edit it.\n \n Finally, rustbuild makes use of the [cc-rs crate] which has [its own\n method][env-vars] of configuring C compilers and C flags via environment"}, {"sha": "9cf43fc7a2193f1b67c5cd51e2927e98dff7b941", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -753,6 +753,9 @@ def build_bootstrap(self, color):\n             target_features += [\"-crt-static\"]\n         if target_features:\n             env[\"RUSTFLAGS\"] += \" -C target-feature=\" + (\",\".join(target_features))\n+        target_linker = self.get_toml(\"linker\", build_section)\n+        if target_linker is not None:\n+            env[\"RUSTFLAGS\"] += \" -C linker=\" + target_linker\n         env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes\"\n         env[\"RUSTFLAGS\"] += \" -Wsemicolon_in_expressions_from_macros\"\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":"}, {"sha": "b54bf43262198e558353410c81d9ae201aeb020f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 92, "deletions": 48, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -13,7 +13,6 @@ use std::time::{Duration, Instant};\n \n use crate::cache::{Cache, Interned, INTERNER};\n use crate::config::{SplitDebuginfo, TargetSelection};\n-use crate::dist;\n use crate::doc;\n use crate::flags::{Color, Subcommand};\n use crate::install;\n@@ -25,6 +24,7 @@ use crate::tool::{self, SourceType};\n use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir, output, t};\n use crate::EXTRA_CHECK_CFGS;\n use crate::{check, compile, Crate};\n+use crate::{clean, dist};\n use crate::{Build, CLang, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n@@ -96,6 +96,35 @@ impl RunConfig<'_> {\n     pub fn build_triple(&self) -> TargetSelection {\n         self.builder.build.build\n     }\n+\n+    /// Return a list of crate names selected by `run.paths`.\n+    pub fn cargo_crates_in_set(&self) -> Interned<Vec<String>> {\n+        let mut crates = Vec::new();\n+        for krate in &self.paths {\n+            let path = krate.assert_single_path();\n+            let crate_name = self.builder.crate_paths[&path.path];\n+            crates.push(crate_name.to_string());\n+        }\n+        INTERNER.intern_list(crates)\n+    }\n+}\n+\n+/// A description of the crates in this set, suitable for passing to `builder.info`.\n+///\n+/// `crates` should be generated by [`RunConfig::cargo_crates_in_set`].\n+pub fn crate_description(crates: &[impl AsRef<str>]) -> String {\n+    if crates.is_empty() {\n+        return \"\".into();\n+    }\n+\n+    let mut descr = String::from(\" {\");\n+    descr.push_str(crates[0].as_ref());\n+    for krate in &crates[1..] {\n+        descr.push_str(\", \");\n+        descr.push_str(krate.as_ref());\n+    }\n+    descr.push('}');\n+    descr\n }\n \n struct StepDescription {\n@@ -633,6 +662,7 @@ impl<'a> Builder<'a> {\n                 crate::toolstate::ToolStateCheck,\n                 test::ExpandYamlAnchors,\n                 test::Tidy,\n+                test::TidySelfTest,\n                 test::Ui,\n                 test::RunPassValgrind,\n                 test::MirOpt,\n@@ -764,8 +794,9 @@ impl<'a> Builder<'a> {\n                 run::GenerateCopyright,\n             ),\n             Kind::Setup => describe!(setup::Profile),\n-            // These commands either don't use paths, or they're special-cased in Build::build()\n-            Kind::Clean | Kind::Format => vec![],\n+            Kind::Clean => describe!(clean::CleanAll, clean::Rustc, clean::Std),\n+            // special-cased in Build::build()\n+            Kind::Format => vec![],\n         }\n     }\n \n@@ -827,14 +858,12 @@ impl<'a> Builder<'a> {\n             Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n             Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n             Subcommand::Run { ref paths, .. } => (Kind::Run, &paths[..]),\n+            Subcommand::Clean { ref paths, .. } => (Kind::Clean, &paths[..]),\n             Subcommand::Format { .. } => (Kind::Format, &[][..]),\n             Subcommand::Setup { profile: ref path } => (\n                 Kind::Setup,\n                 path.as_ref().map_or([].as_slice(), |path| std::slice::from_ref(path)),\n             ),\n-            Subcommand::Clean { .. } => {\n-                panic!()\n-            }\n         };\n \n         Self::new_internal(build, kind, paths.to_owned())\n@@ -1077,6 +1106,62 @@ impl<'a> Builder<'a> {\n         None\n     }\n \n+    /// Like `cargo`, but only passes flags that are valid for all commands.\n+    pub fn bare_cargo(\n+        &self,\n+        compiler: Compiler,\n+        mode: Mode,\n+        target: TargetSelection,\n+        cmd: &str,\n+    ) -> Command {\n+        let mut cargo = Command::new(&self.initial_cargo);\n+        // Run cargo from the source root so it can find .cargo/config.\n+        // This matters when using vendoring and the working directory is outside the repository.\n+        cargo.current_dir(&self.src);\n+\n+        let out_dir = self.stage_out(compiler, mode);\n+        cargo.env(\"CARGO_TARGET_DIR\", &out_dir).arg(cmd);\n+\n+        // Found with `rg \"init_env_logger\\(\"`. If anyone uses `init_env_logger`\n+        // from out of tree it shouldn't matter, since x.py is only used for\n+        // building in-tree.\n+        let color_logs = [\"RUSTDOC_LOG_COLOR\", \"RUSTC_LOG_COLOR\", \"RUST_LOG_COLOR\"];\n+        match self.build.config.color {\n+            Color::Always => {\n+                cargo.arg(\"--color=always\");\n+                for log in &color_logs {\n+                    cargo.env(log, \"always\");\n+                }\n+            }\n+            Color::Never => {\n+                cargo.arg(\"--color=never\");\n+                for log in &color_logs {\n+                    cargo.env(log, \"never\");\n+                }\n+            }\n+            Color::Auto => {} // nothing to do\n+        }\n+\n+        if cmd != \"install\" {\n+            cargo.arg(\"--target\").arg(target.rustc_target_arg());\n+        } else {\n+            assert_eq!(target, compiler.host);\n+        }\n+\n+        if self.config.rust_optimize {\n+            // FIXME: cargo bench/install do not accept `--release`\n+            if cmd != \"bench\" && cmd != \"install\" {\n+                cargo.arg(\"--release\");\n+            }\n+        }\n+\n+        // Remove make-related flags to ensure Cargo can correctly set things up\n+        cargo.env_remove(\"MAKEFLAGS\");\n+        cargo.env_remove(\"MFLAGS\");\n+\n+        cargo\n+    }\n+\n     /// Prepares an invocation of `cargo` to be run.\n     ///\n     /// This will create a `Command` that represents a pending execution of\n@@ -1092,11 +1177,8 @@ impl<'a> Builder<'a> {\n         target: TargetSelection,\n         cmd: &str,\n     ) -> Cargo {\n-        let mut cargo = Command::new(&self.initial_cargo);\n+        let mut cargo = self.bare_cargo(compiler, mode, target, cmd);\n         let out_dir = self.stage_out(compiler, mode);\n-        // Run cargo from the source root so it can find .cargo/config.\n-        // This matters when using vendoring and the working directory is outside the repository.\n-        cargo.current_dir(&self.src);\n \n         // Codegen backends are not yet tracked by -Zbinary-dep-depinfo,\n         // so we need to explicitly clear out if they've been updated.\n@@ -1121,8 +1203,6 @@ impl<'a> Builder<'a> {\n             self.clear_if_dirty(&my_out, &rustdoc);\n         }\n \n-        cargo.env(\"CARGO_TARGET_DIR\", &out_dir).arg(cmd);\n-\n         let profile_var = |name: &str| {\n             let profile = if self.config.rust_optimize { \"RELEASE\" } else { \"DEV\" };\n             format!(\"CARGO_PROFILE_{}_{}\", profile, name)\n@@ -1135,32 +1215,6 @@ impl<'a> Builder<'a> {\n             cargo.env(\"REAL_LIBRARY_PATH\", e);\n         }\n \n-        // Found with `rg \"init_env_logger\\(\"`. If anyone uses `init_env_logger`\n-        // from out of tree it shouldn't matter, since x.py is only used for\n-        // building in-tree.\n-        let color_logs = [\"RUSTDOC_LOG_COLOR\", \"RUSTC_LOG_COLOR\", \"RUST_LOG_COLOR\"];\n-        match self.build.config.color {\n-            Color::Always => {\n-                cargo.arg(\"--color=always\");\n-                for log in &color_logs {\n-                    cargo.env(log, \"always\");\n-                }\n-            }\n-            Color::Never => {\n-                cargo.arg(\"--color=never\");\n-                for log in &color_logs {\n-                    cargo.env(log, \"never\");\n-                }\n-            }\n-            Color::Auto => {} // nothing to do\n-        }\n-\n-        if cmd != \"install\" {\n-            cargo.arg(\"--target\").arg(target.rustc_target_arg());\n-        } else {\n-            assert_eq!(target, compiler.host);\n-        }\n-\n         // Set a flag for `check`/`clippy`/`fix`, so that certain build\n         // scripts can do less work (i.e. not building/requiring LLVM).\n         if cmd == \"check\" || cmd == \"clippy\" || cmd == \"fix\" {\n@@ -1341,9 +1395,6 @@ impl<'a> Builder<'a> {\n         }\n \n         cargo.arg(\"-j\").arg(self.jobs().to_string());\n-        // Remove make-related flags to ensure Cargo can correctly set things up\n-        cargo.env_remove(\"MAKEFLAGS\");\n-        cargo.env_remove(\"MFLAGS\");\n \n         // FIXME: Temporary fix for https://github.com/rust-lang/cargo/issues/3005\n         // Force cargo to output binaries with disambiguating hashes in the name\n@@ -1827,13 +1878,6 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        if self.config.rust_optimize {\n-            // FIXME: cargo bench/install do not accept `--release`\n-            if cmd != \"bench\" && cmd != \"install\" {\n-                cargo.arg(\"--release\");\n-            }\n-        }\n-\n         if self.config.locked_deps {\n             cargo.arg(\"--locked\");\n         }"}, {"sha": "b203ecd3844b039d11358abc156f6d7b427a8be6", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -99,19 +99,13 @@ impl Step for Std {\n             cargo_subcommand(builder.kind),\n         );\n         std_cargo(builder, target, compiler.stage, &mut cargo);\n+        cargo.args(args(builder));\n \n         builder.info(&format!(\n-            \"Checking stage{} std artifacts ({} -> {})\",\n+            \"Checking stage{} library artifacts ({} -> {})\",\n             builder.top_stage, &compiler.host, target\n         ));\n-        run_cargo(\n-            builder,\n-            cargo,\n-            args(builder),\n-            &libstd_stamp(builder, compiler, target),\n-            vec![],\n-            true,\n-        );\n+        run_cargo(builder, cargo, &libstd_stamp(builder, compiler, target), vec![], true, false);\n \n         // We skip populating the sysroot in non-zero stage because that'll lead\n         // to rlib/rmeta conflicts if std gets built during this session.\n@@ -155,18 +149,19 @@ impl Step for Std {\n         for krate in builder.in_tree_crates(\"test\", Some(target)) {\n             cargo.arg(\"-p\").arg(krate.name);\n         }\n+        cargo.args(args(builder));\n \n         builder.info(&format!(\n-            \"Checking stage{} std test/bench/example targets ({} -> {})\",\n+            \"Checking stage{} library test/bench/example targets ({} -> {})\",\n             builder.top_stage, &compiler.host, target\n         ));\n         run_cargo(\n             builder,\n             cargo,\n-            args(builder),\n             &libstd_test_stamp(builder, compiler, target),\n             vec![],\n             true,\n+            false,\n         );\n     }\n }\n@@ -231,19 +226,13 @@ impl Step for Rustc {\n         for krate in builder.in_tree_crates(\"rustc-main\", Some(target)) {\n             cargo.arg(\"-p\").arg(krate.name);\n         }\n+        cargo.args(args(builder));\n \n         builder.info(&format!(\n             \"Checking stage{} compiler artifacts ({} -> {})\",\n             builder.top_stage, &compiler.host, target\n         ));\n-        run_cargo(\n-            builder,\n-            cargo,\n-            args(builder),\n-            &librustc_stamp(builder, compiler, target),\n-            vec![],\n-            true,\n-        );\n+        run_cargo(builder, cargo, &librustc_stamp(builder, compiler, target), vec![], true, false);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n@@ -290,6 +279,7 @@ impl Step for CodegenBackend {\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(format!(\"compiler/rustc_codegen_{}/Cargo.toml\", backend)));\n         rustc_cargo_env(builder, &mut cargo, target);\n+        cargo.args(args(builder));\n \n         builder.info(&format!(\n             \"Checking stage{} {} artifacts ({} -> {})\",\n@@ -299,10 +289,10 @@ impl Step for CodegenBackend {\n         run_cargo(\n             builder,\n             cargo,\n-            args(builder),\n             &codegen_backend_stamp(builder, compiler, target, backend),\n             vec![],\n             true,\n+            false,\n         );\n     }\n }\n@@ -355,11 +345,13 @@ impl Step for RustAnalyzer {\n             cargo.arg(\"--benches\");\n         }\n \n+        cargo.args(args(builder));\n+\n         builder.info(&format!(\n             \"Checking stage{} {} artifacts ({} -> {})\",\n             compiler.stage, \"rust-analyzer\", &compiler.host.triple, target.triple\n         ));\n-        run_cargo(builder, cargo, args(builder), &stamp(builder, compiler, target), vec![], true);\n+        run_cargo(builder, cargo, &stamp(builder, compiler, target), vec![], true, false);\n \n         /// Cargo's output path in a given stage, compiled by a particular\n         /// compiler for the specified target.\n@@ -413,6 +405,8 @@ macro_rules! tool_check_step {\n                     cargo.arg(\"--all-targets\");\n                 }\n \n+                cargo.args(args(builder));\n+\n                 // Enable internal lints for clippy and rustdoc\n                 // NOTE: this doesn't enable lints for any other tools unless they explicitly add `#![warn(rustc::internal)]`\n                 // See https://github.com/rust-lang/rust/pull/80573#issuecomment-754010776\n@@ -428,10 +422,10 @@ macro_rules! tool_check_step {\n                 run_cargo(\n                     builder,\n                     cargo,\n-                    args(builder),\n                     &stamp(builder, compiler, target),\n                     vec![],\n                     true,\n+                    false,\n                 );\n \n                 /// Cargo's output path in a given stage, compiled by a particular"}, {"sha": "468efc1114c43f3ff8e6735b4e87313a8f5739bb", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 74, "deletions": 2, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -9,10 +9,81 @@ use std::fs;\n use std::io::{self, ErrorKind};\n use std::path::Path;\n \n+use crate::builder::{crate_description, Builder, RunConfig, ShouldRun, Step};\n+use crate::cache::Interned;\n use crate::util::t;\n-use crate::Build;\n+use crate::{Build, Compiler, Mode, Subcommand};\n \n-pub fn clean(build: &Build, all: bool) {\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct CleanAll {}\n+\n+impl Step for CleanAll {\n+    const DEFAULT: bool = true;\n+    type Output = ();\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(CleanAll {})\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let Subcommand::Clean { all, .. } = builder.config.cmd else { unreachable!(\"wrong subcommand?\") };\n+        clean_default(builder.build, all)\n+    }\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.never() // handled by DEFAULT\n+    }\n+}\n+\n+macro_rules! clean_crate_tree {\n+    ( $( $name:ident, $mode:path, $root_crate:literal);+ $(;)? ) => { $(\n+        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+        pub struct $name {\n+            compiler: Compiler,\n+            crates: Interned<Vec<String>>,\n+        }\n+\n+        impl Step for $name {\n+            type Output = ();\n+\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+                let crates = run.builder.in_tree_crates($root_crate, None);\n+                run.crates(crates)\n+            }\n+\n+            fn make_run(run: RunConfig<'_>) {\n+                let builder = run.builder;\n+                let compiler = builder.compiler(builder.top_stage, run.target);\n+                builder.ensure(Self { crates: run.cargo_crates_in_set(), compiler });\n+            }\n+\n+            fn run(self, builder: &Builder<'_>) -> Self::Output {\n+                let compiler = self.compiler;\n+                let target = compiler.host;\n+                let mut cargo = builder.bare_cargo(compiler, $mode, target, \"clean\");\n+                for krate in &*self.crates {\n+                    cargo.arg(krate);\n+                }\n+\n+                builder.info(&format!(\n+                    \"Cleaning{} stage{} {} artifacts ({} -> {})\",\n+                    crate_description(&self.crates), compiler.stage, stringify!($name).to_lowercase(), &compiler.host, target,\n+                ));\n+\n+                // NOTE: doesn't use `run_cargo` because we don't want to save a stamp file,\n+                // and doesn't use `stream_cargo` to avoid passing `--message-format` which `clean` doesn't accept.\n+                builder.run(&mut cargo);\n+            }\n+        }\n+    )+ }\n+}\n+\n+clean_crate_tree! {\n+    Rustc, Mode::Rustc, \"rustc-main\";\n+    Std, Mode::Std, \"test\";\n+}\n+\n+fn clean_default(build: &Build, all: bool) {\n     rm_rf(\"tmp\".as_ref());\n \n     if all {\n@@ -21,6 +92,7 @@ pub fn clean(build: &Build, all: bool) {\n         rm_rf(&build.out.join(\"tmp\"));\n         rm_rf(&build.out.join(\"dist\"));\n         rm_rf(&build.out.join(\"bootstrap\"));\n+        rm_rf(&build.out.join(\"rustfmt.stamp\"));\n \n         for host in &build.hosts {\n             let entries = match build.out.join(host.triple).read_dir() {"}, {"sha": "147ded3a9eed7c13ee41b09b2117bf6100e7b56f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -18,6 +18,7 @@ use std::str;\n \n use serde::Deserialize;\n \n+use crate::builder::crate_description;\n use crate::builder::Cargo;\n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n@@ -46,17 +47,6 @@ impl Std {\n     }\n }\n \n-/// Return a `-p=x -p=y` string suitable for passing to a cargo invocation.\n-fn build_crates_in_set(run: &RunConfig<'_>) -> Interned<Vec<String>> {\n-    let mut crates = Vec::new();\n-    for krate in &run.paths {\n-        let path = krate.assert_single_path();\n-        let crate_name = run.builder.crate_paths[&path.path];\n-        crates.push(format!(\"-p={crate_name}\"));\n-    }\n-    INTERNER.intern_list(crates)\n-}\n-\n impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n@@ -76,7 +66,7 @@ impl Step for Std {\n         // Build all crates anyway, as if they hadn't passed the other args.\n         let has_library =\n             run.paths.iter().any(|set| set.assert_single_path().path.ends_with(\"library\"));\n-        let crates = if has_library { Default::default() } else { build_crates_in_set(&run) };\n+        let crates = if has_library { Default::default() } else { run.cargo_crates_in_set() };\n         run.builder.ensure(Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.build_triple()),\n             target: run.target,\n@@ -121,7 +111,10 @@ impl Step for Std {\n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n             builder.ensure(Std::new(compiler_to_use, target));\n-            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", compiler_to_use.host, target));\n+            builder.info(&format!(\n+                \"Uplifting stage1 library ({} -> {})\",\n+                compiler_to_use.host, target\n+            ));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n@@ -137,18 +130,24 @@ impl Step for Std {\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, SourceType::InTree, target, \"build\");\n         std_cargo(builder, target, compiler.stage, &mut cargo);\n+        for krate in &*self.crates {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n \n         builder.info(&format!(\n-            \"Building stage{} std artifacts ({} -> {})\",\n-            compiler.stage, &compiler.host, target\n+            \"Building{} stage{} library artifacts ({} -> {})\",\n+            crate_description(&self.crates),\n+            compiler.stage,\n+            &compiler.host,\n+            target,\n         ));\n         run_cargo(\n             builder,\n             cargo,\n-            self.crates.to_vec(),\n             &libstd_stamp(builder, compiler, target),\n             target_deps,\n             false,\n+            false,\n         );\n \n         builder.ensure(StdLink::from_std(\n@@ -436,7 +435,7 @@ impl Step for StdLink {\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n         builder.info(&format!(\n-            \"Copying stage{} std from stage{} ({} -> {} / {})\",\n+            \"Copying stage{} library from stage{} ({} -> {} / {})\",\n             target_compiler.stage, compiler.stage, &compiler.host, target_compiler.host, target\n         ));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n@@ -603,7 +602,7 @@ impl Step for Rustc {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        let crates = build_crates_in_set(&run);\n+        let crates = run.cargo_crates_in_set();\n         run.builder.ensure(Rustc {\n             compiler: run.builder.compiler(run.builder.top_stage, run.build_triple()),\n             target: run.target,\n@@ -702,7 +701,8 @@ impl Step for Rustc {\n             ));\n         }\n \n-        // cfg(bootstrap): remove if condition once the bootstrap compiler supports dylib LTO\n+        // We currently don't support cross-crate LTO in stage0. This also isn't hugely necessary\n+        // and may just be a time sink.\n         if compiler.stage != 0 {\n             match builder.config.rust_lto {\n                 RustcLto::Thin | RustcLto::Fat => {\n@@ -724,17 +724,24 @@ impl Step for Rustc {\n             }\n         }\n \n+        for krate in &*self.crates {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n+\n         builder.info(&format!(\n-            \"Building stage{} compiler artifacts ({} -> {})\",\n-            compiler.stage, &compiler.host, target\n+            \"Building{} stage{} compiler artifacts ({} -> {})\",\n+            crate_description(&self.crates),\n+            compiler.stage,\n+            &compiler.host,\n+            target,\n         ));\n         run_cargo(\n             builder,\n             cargo,\n-            self.crates.to_vec(),\n             &librustc_stamp(builder, compiler, target),\n             vec![],\n             false,\n+            true, // Only ship rustc_driver.so and .rmeta files, not all intermediate .rlib files.\n         );\n \n         builder.ensure(RustcLink::from_rustc(\n@@ -991,7 +998,7 @@ impl Step for CodegenBackend {\n             \"Building stage{} codegen backend {} ({} -> {})\",\n             compiler.stage, backend, &compiler.host, target\n         ));\n-        let files = run_cargo(builder, cargo, vec![], &tmp_stamp, vec![], false);\n+        let files = run_cargo(builder, cargo, &tmp_stamp, vec![], false, false);\n         if builder.config.dry_run() {\n             return;\n         }\n@@ -1415,10 +1422,10 @@ pub fn add_to_sysroot(\n pub fn run_cargo(\n     builder: &Builder<'_>,\n     cargo: Cargo,\n-    tail_args: Vec<String>,\n     stamp: &Path,\n     additional_target_deps: Vec<(PathBuf, DependencyType)>,\n     is_check: bool,\n+    rlib_only_metadata: bool,\n ) -> Vec<PathBuf> {\n     if builder.config.dry_run() {\n         return Vec::new();\n@@ -1441,7 +1448,7 @@ pub fn run_cargo(\n     // files we need to probe for later.\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n-    let ok = stream_cargo(builder, cargo, tail_args, &mut |msg| {\n+    let ok = stream_cargo(builder, cargo, &mut |msg| {\n         let (filenames, crate_types) = match msg {\n             CargoMessage::CompilerArtifact {\n                 filenames,\n@@ -1452,13 +1459,35 @@ pub fn run_cargo(\n         };\n         for filename in filenames {\n             // Skip files like executables\n-            if !(filename.ends_with(\".rlib\")\n-                || filename.ends_with(\".lib\")\n+            let mut keep = false;\n+            if filename.ends_with(\".lib\")\n                 || filename.ends_with(\".a\")\n                 || is_debug_info(&filename)\n                 || is_dylib(&filename)\n-                || (is_check && filename.ends_with(\".rmeta\")))\n             {\n+                // Always keep native libraries, rust dylibs and debuginfo\n+                keep = true;\n+            }\n+            if is_check && filename.ends_with(\".rmeta\") {\n+                // During check builds we need to keep crate metadata\n+                keep = true;\n+            } else if rlib_only_metadata {\n+                if filename.contains(\"jemalloc_sys\") || filename.contains(\"rustc_smir\") {\n+                    // jemalloc_sys and rustc_smir are not linked into librustc_driver.so,\n+                    // so we need to distribute them as rlib to be able to use them.\n+                    keep |= filename.ends_with(\".rlib\");\n+                } else {\n+                    // Distribute the rest of the rustc crates as rmeta files only to reduce\n+                    // the tarball sizes by about 50%. The object files are linked into\n+                    // librustc_driver.so, so it is still possible to link against them.\n+                    keep |= filename.ends_with(\".rmeta\");\n+                }\n+            } else {\n+                // In all other cases keep all rlibs\n+                keep |= filename.ends_with(\".rlib\");\n+            }\n+\n+            if !keep {\n                 continue;\n             }\n \n@@ -1556,7 +1585,6 @@ pub fn run_cargo(\n pub fn stream_cargo(\n     builder: &Builder<'_>,\n     cargo: Cargo,\n-    tail_args: Vec<String>,\n     cb: &mut dyn FnMut(CargoMessage<'_>),\n ) -> bool {\n     let mut cargo = Command::from(cargo);\n@@ -1576,10 +1604,6 @@ pub fn stream_cargo(\n     }\n     cargo.arg(\"--message-format\").arg(message_format).stdout(Stdio::piped());\n \n-    for arg in tail_args {\n-        cargo.arg(arg);\n-    }\n-\n     builder.verbose(&format!(\"running: {:?}\", cargo));\n     let mut child = match cargo.spawn() {\n         Ok(child) => child,"}, {"sha": "b41d60d51a8b5972f75ea63e518d68e461f7df0e", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -49,10 +49,7 @@ pub enum DryRun {\n \n /// Global configuration for the entire build and/or bootstrap.\n ///\n-/// This structure is derived from a combination of both `config.toml` and\n-/// `config.mk`. As of the time of this writing it's unlikely that `config.toml`\n-/// is used all that much, so this is primarily filled out by `config.mk` which\n-/// is generated from `./configure`.\n+/// This structure is parsed from `config.toml`, and some of the fields are inferred from `git` or build-time parameters.\n ///\n /// Note that this structure is not decoded directly into, but rather it is\n /// filled out from the decoded forms of the structs below. For documentation"}, {"sha": "31cc4aa57bbea45170f4ff339e424528c1edee5c", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -405,7 +405,9 @@ def set(key, value):\n         configured_targets.append(target)\n for target in configured_targets:\n     targets[target] = sections['target'][:]\n-    targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", \"'{}'\".format(target))\n+    # For `.` to be valid TOML, it needs to be quoted. But `bootstrap.py` doesn't use a proper TOML parser and fails to parse the target.\n+    # Avoid using quotes unless it's necessary.\n+    targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", \"'{}'\".format(target) if \".\" in target else target)\n \n \n def is_number(value):"}, {"sha": "9bad9046ecc2c4fed4a122d5d2a60ccf2adda4c1", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -12,6 +12,7 @@ use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n \n+use crate::builder::crate_description;\n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n@@ -506,7 +507,11 @@ impl Step for Std {\n         // Look for library/std, library/core etc in the `x.py doc` arguments and\n         // open the corresponding rendered docs.\n         for requested_crate in requested_crates {\n-            if STD_PUBLIC_CRATES.iter().any(|k| *k == requested_crate.as_str()) {\n+            if requested_crate == \"library\" {\n+                // For `x.py doc library --open`, open `std` by default.\n+                let index = out.join(\"std\").join(\"index.html\");\n+                builder.open_in_browser(index);\n+            } else if STD_PUBLIC_CRATES.iter().any(|&k| k == requested_crate) {\n                 let index = out.join(requested_crate).join(\"index.html\");\n                 builder.open_in_browser(index);\n             }\n@@ -554,7 +559,8 @@ fn doc_std(\n     requested_crates: &[String],\n ) {\n     builder.info(&format!(\n-        \"Documenting stage{} std ({}) in {} format\",\n+        \"Documenting{} stage{} library ({}) in {} format\",\n+        crate_description(requested_crates),\n         stage,\n         target,\n         format.as_str()"}, {"sha": "2c6d201d18fbeacc697c03f990d8770d04bfa8ff", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -130,6 +130,7 @@ pub enum Subcommand {\n         test_args: Vec<String>,\n     },\n     Clean {\n+        paths: Vec<PathBuf>,\n         all: bool,\n     },\n     Dist {\n@@ -351,22 +352,32 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n \n         // fn usage()\n         let usage = |exit_code: i32, opts: &Options, verbose: bool, subcommand_help: &str| -> ! {\n-            let config = Config::parse(&[\"setup\".to_string()]);\n-            let build = Build::new(config);\n-            let paths = Builder::get_help(&build, subcommand);\n-\n             println!(\"{}\", opts.usage(subcommand_help));\n-            if let Some(s) = paths {\n-                if verbose {\n+            if verbose {\n+                // We have an unfortunate situation here: some Steps use `builder.in_tree_crates` to determine their paths.\n+                // To determine those crates, we need to run `cargo metadata`, which means we need all submodules to be checked out.\n+                // That takes a while to run, so only do it when paths were explicitly requested, not on all CLI errors.\n+                // `Build::new` won't load submodules for the `setup` command.\n+                let cmd = if verbose {\n+                    println!(\"note: updating submodules before printing available paths\");\n+                    \"build\"\n+                } else {\n+                    \"setup\"\n+                };\n+                let config = Config::parse(&[cmd.to_string()]);\n+                let build = Build::new(config);\n+                let paths = Builder::get_help(&build, subcommand);\n+\n+                if let Some(s) = paths {\n                     println!(\"{}\", s);\n                 } else {\n-                    println!(\n-                        \"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                        subcommand.as_str()\n-                    );\n+                    panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n                 }\n-            } else if verbose {\n-                panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n+            } else {\n+                println!(\n+                    \"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                    subcommand.as_str()\n+                );\n             }\n             crate::detail_exit(exit_code);\n         };\n@@ -601,14 +612,7 @@ Arguments:\n                 open: matches.opt_present(\"open\"),\n                 json: matches.opt_present(\"json\"),\n             },\n-            Kind::Clean => {\n-                if !paths.is_empty() {\n-                    println!(\"\\nclean does not take a path argument\\n\");\n-                    usage(1, &opts, verbose, &subcommand_help);\n-                }\n-\n-                Subcommand::Clean { all: matches.opt_present(\"all\") }\n-            }\n+            Kind::Clean => Subcommand::Clean { all: matches.opt_present(\"all\"), paths },\n             Kind::Format => Subcommand::Format { check: matches.opt_present(\"check\"), paths },\n             Kind::Dist => Subcommand::Dist { paths },\n             Kind::Install => Subcommand::Install { paths },"}, {"sha": "84e4611895965ce22dfa63b7d75516813c113821", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,7 +1,7 @@\n //! Runs rustfmt on the repository.\n \n use crate::builder::Builder;\n-use crate::util::{output, t};\n+use crate::util::{output, program_out_of_date, t};\n use ignore::WalkBuilder;\n use std::collections::VecDeque;\n use std::path::{Path, PathBuf};\n@@ -44,6 +44,86 @@ fn rustfmt(src: &Path, rustfmt: &Path, paths: &[PathBuf], check: bool) -> impl F\n     }\n }\n \n+fn get_rustfmt_version(build: &Builder<'_>) -> Option<(String, PathBuf)> {\n+    let stamp_file = build.out.join(\"rustfmt.stamp\");\n+\n+    let mut cmd = Command::new(match build.initial_rustfmt() {\n+        Some(p) => p,\n+        None => return None,\n+    });\n+    cmd.arg(\"--version\");\n+    let output = match cmd.output() {\n+        Ok(status) => status,\n+        Err(_) => return None,\n+    };\n+    if !output.status.success() {\n+        return None;\n+    }\n+    Some((String::from_utf8(output.stdout).unwrap(), stamp_file))\n+}\n+\n+/// Return whether the format cache can be reused.\n+fn verify_rustfmt_version(build: &Builder<'_>) -> bool {\n+    let Some((version, stamp_file)) = get_rustfmt_version(build) else {return false;};\n+    !program_out_of_date(&stamp_file, &version)\n+}\n+\n+/// Updates the last rustfmt version used\n+fn update_rustfmt_version(build: &Builder<'_>) {\n+    let Some((version, stamp_file)) = get_rustfmt_version(build) else {return;};\n+    t!(std::fs::write(stamp_file, version))\n+}\n+\n+/// Returns the Rust files modified between the `merge-base` of HEAD and\n+/// rust-lang/master and what is now on the disk.\n+///\n+/// Returns `None` if all files should be formatted.\n+fn get_modified_rs_files(build: &Builder<'_>) -> Option<Vec<String>> {\n+    let Ok(remote) = get_rust_lang_rust_remote() else { return None; };\n+    if !verify_rustfmt_version(build) {\n+        return None;\n+    }\n+\n+    let merge_base =\n+        output(build.config.git().arg(\"merge-base\").arg(&format!(\"{remote}/master\")).arg(\"HEAD\"));\n+    Some(\n+        output(build.config.git().arg(\"diff-index\").arg(\"--name-only\").arg(merge_base.trim()))\n+            .lines()\n+            .map(|s| s.trim().to_owned())\n+            .filter(|f| Path::new(f).extension().map_or(false, |ext| ext == \"rs\"))\n+            .collect(),\n+    )\n+}\n+\n+/// Finds the remote for rust-lang/rust.\n+/// For example for these remotes it will return `upstream`.\n+/// ```text\n+/// origin  https://github.com/Nilstrieb/rust.git (fetch)\n+/// origin  https://github.com/Nilstrieb/rust.git (push)\n+/// upstream        https://github.com/rust-lang/rust (fetch)\n+/// upstream        https://github.com/rust-lang/rust (push)\n+/// ```\n+fn get_rust_lang_rust_remote() -> Result<String, String> {\n+    let mut git = Command::new(\"git\");\n+    git.args([\"config\", \"--local\", \"--get-regex\", \"remote\\\\..*\\\\.url\"]);\n+\n+    let output = git.output().map_err(|err| format!(\"{err:?}\"))?;\n+    if !output.status.success() {\n+        return Err(\"failed to execute git config command\".to_owned());\n+    }\n+\n+    let stdout = String::from_utf8(output.stdout).map_err(|err| format!(\"{err:?}\"))?;\n+\n+    let rust_lang_remote = stdout\n+        .lines()\n+        .find(|remote| remote.contains(\"rust-lang\"))\n+        .ok_or_else(|| \"rust-lang/rust remote not found\".to_owned())?;\n+\n+    let remote_name =\n+        rust_lang_remote.split('.').nth(1).ok_or_else(|| \"remote name not found\".to_owned())?;\n+    Ok(remote_name.into())\n+}\n+\n #[derive(serde::Deserialize)]\n struct RustfmtConfig {\n     ignore: Vec<String>,\n@@ -110,6 +190,14 @@ pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n                 // preventing the latter from being formatted.\n                 ignore_fmt.add(&format!(\"!/{}\", untracked_path)).expect(&untracked_path);\n             }\n+            if !check && paths.is_empty() {\n+                if let Some(files) = get_modified_rs_files(build) {\n+                    for file in files {\n+                        println!(\"formatting modified file {file}\");\n+                        ignore_fmt.add(&format!(\"/{file}\")).expect(&file);\n+                    }\n+                }\n+            }\n         } else {\n             println!(\"Not in git tree. Skipping git-aware format checks\");\n         }\n@@ -187,4 +275,7 @@ pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n     drop(tx);\n \n     thread.join().unwrap();\n+    if !check {\n+        update_rustfmt_version(build);\n+    }\n }"}, {"sha": "5ea41d10bc8170686f78e87f79d905e32b7c7993", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -727,10 +727,6 @@ impl Build {\n             return format::format(&builder::Builder::new(&self), *check, &paths);\n         }\n \n-        if let Subcommand::Clean { all } = self.config.cmd {\n-            return clean::clean(self, all);\n-        }\n-\n         // Download rustfmt early so that it can be used in rust-analyzer configs.\n         let _ = &builder::Builder::new(&self).initial_rustfmt();\n \n@@ -1400,7 +1396,10 @@ impl Build {\n         let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n-            let krate = &self.crates[&krate];\n+            let krate = self\n+                .crates\n+                .get(&krate)\n+                .unwrap_or_else(|| panic!(\"metadata missing for {krate}: {:?}\", self.crates));\n             ret.push(krate);\n             for dep in &krate.deps {\n                 if !self.crates.contains_key(dep) {"}, {"sha": "ea906be7e3ac255f58fc0d1ddb780bc82b8edc60", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -11,6 +11,7 @@ use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n \n+use crate::builder::crate_description;\n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n use crate::compile;\n@@ -1048,7 +1049,7 @@ impl Step for RustdocGUI {\n                 if entry.file_name() == \"link_to_definition\" {\n                     cargo.env(\"RUSTDOCFLAGS\", \"-Zunstable-options --generate-link-to-definition\");\n                 } else if entry.file_name() == \"scrape_examples\" {\n-                    cargo.arg(\"-Zrustdoc-scrape-examples=examples\");\n+                    cargo.arg(\"-Zrustdoc-scrape-examples\");\n                 }\n                 builder.run(&mut cargo);\n             }\n@@ -1142,6 +1143,40 @@ help: to skip test's attempt to check tidiness, pass `--exclude src/tools/tidy`\n     }\n }\n \n+/// Runs tidy's own tests.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct TidySelfTest;\n+\n+impl Step for TidySelfTest {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.alias(\"tidyselftest\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(TidySelfTest);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        let bootstrap_host = builder.config.build;\n+        let compiler = builder.compiler(0, bootstrap_host);\n+        let cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolBootstrap,\n+            bootstrap_host,\n+            \"test\",\n+            \"src/tools/tidy\",\n+            SourceType::InTree,\n+            &[],\n+        );\n+        try_run(builder, &mut cargo.into());\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct ExpandYamlAnchors;\n \n@@ -2154,8 +2189,12 @@ impl Step for Crate {\n         }\n \n         builder.info(&format!(\n-            \"{} {:?} stage{} ({} -> {})\",\n-            test_kind, self.crates, compiler.stage, &compiler.host, target\n+            \"{}{} stage{} ({} -> {})\",\n+            test_kind,\n+            crate_description(&self.crates),\n+            compiler.stage,\n+            &compiler.host,\n+            target\n         ));\n         let _time = util::timeit(&builder);\n         try_run(builder, &mut cargo.into());"}, {"sha": "63026bd44d475277d388b9a3b8d37d237a0e8842", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -72,7 +72,7 @@ impl Step for ToolBuild {\n \n         builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n         let mut duplicates = Vec::new();\n-        let is_expected = compile::stream_cargo(builder, cargo, vec![], &mut |msg| {\n+        let is_expected = compile::stream_cargo(builder, cargo, &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n             match tool {\n                 \"rls\" | \"cargo\" | \"clippy-driver\" | \"miri\" | \"rustfmt\" => {}"}, {"sha": "dc0e591cad6f6f9aec51a1ab2eec129f01e9988b", "filename": "src/ci/docker/host-x86_64/mingw-check-tidy/Dockerfile", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -32,5 +32,4 @@ RUN pip3 install --no-deps --no-cache-dir --require-hashes -r /tmp/reuse-require\n COPY host-x86_64/mingw-check/validate-toolstate.sh /scripts/\n COPY host-x86_64/mingw-check/validate-error-codes.sh /scripts/\n \n-ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n-ENV SCRIPT python3 ../x.py test --stage 0 src/tools/tidy\n+ENV SCRIPT python3 ../x.py test --stage 0 src/tools/tidy tidyselftest"}, {"sha": "0db9c993eecb407f2fd72cb4a3a0a76ef3535cb4", "filename": "src/ci/run.sh", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -45,14 +45,6 @@ fi\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n-if command -v python > /dev/null; then\n-    PYTHON=\"python\"\n-elif command -v python3 > /dev/null; then\n-    PYTHON=\"python3\"\n-else\n-    PYTHON=\"python2\"\n-fi\n-\n if ! isCI || isCiBranch auto || isCiBranch beta || isCiBranch try || isCiBranch try-perf; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.metrics\"\n@@ -192,16 +184,16 @@ if [ \"$RUN_CHECK_WITH_PARALLEL_QUERIES\" != \"\" ]; then\n   $SRC/configure --set rust.parallel-compiler\n \n   # Save the build metrics before we wipe the directory\n-  if [ $HAS_METRICS = 1 ]; then\n+  if [ \"$HAS_METRICS\" = 1 ]; then\n     mv build/metrics.json .\n   fi\n   rm -rf build\n-  if [ $HAS_METRICS = 1 ]; then\n+  if [ \"$HAS_METRICS\" = 1 ]; then\n     mkdir build\n     mv metrics.json build\n   fi\n \n-  CARGO_INCREMENTAL=0 $PYTHON ../x.py check\n+  CARGO_INCREMENTAL=0 ../x check\n fi\n \n sccache --show-stats || true"}, {"sha": "2bd5d42c9956369132228da6409f0e68da56c51a", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1 +1 @@\n-Subproject commit a60f4316ec923a5ac2ed6a2eba6960edb832d855\n+Subproject commit 2bd5d42c9956369132228da6409f0e68da56c51a"}, {"sha": "8ca261268068d80c0969260fff15199bad87b587", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1 +1 @@\n-Subproject commit dd37e21ccee43918ed18a71581bb2af537ffe4fc\n+Subproject commit 8ca261268068d80c0969260fff15199bad87b587"}, {"sha": "8888f9428fe9a48f31de6bd2cef9b9bf80791edc", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1 +1 @@\n-Subproject commit 995df09b65c582eb6290ab7ea5d9485983eb4c37\n+Subproject commit 8888f9428fe9a48f31de6bd2cef9b9bf80791edc"}, {"sha": "b3e2a6e6c8a3aae5b5d950c63046f23bae07096d", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1 +1 @@\n-Subproject commit 8b42eb5f57d3d8ed2257a22d0e850d9db52afed3\n+Subproject commit b3e2a6e6c8a3aae5b5d950c63046f23bae07096d"}, {"sha": "f291cde2e5a0dbb45195804334ea76c2d8a26bea", "filename": "src/doc/rustc/src/targets/index.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1,7 +1,10 @@\n # Targets\n \n `rustc` is a cross-compiler by default. This means that you can use any compiler to build for any\n-architecture. The list of *targets* are the possible architectures that you can build for.\n+architecture. The list of *targets* are the possible architectures that you can build for. See\n+the [Platform Support](../platform-support.md) page for a detailed list of targets, or\n+[Built-in Targets](built-in.md) for instructions on how to view what is available for your version\n+of `rustc`.\n \n To see all the options that you can set with a target, see the docs\n [here](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/struct.Target.html)."}, {"sha": "8ecf05f0e121f7316fc9301b59f5227239f0436a", "filename": "src/doc/rustdoc/src/write-documentation/the-doc-attribute.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fthe-doc-attribute.md?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -9,11 +9,11 @@ are the same:\n \n ```rust,no_run\n /// This is a doc comment.\n-#[doc = \" This is a doc comment.\"]\n+#[doc = r\" This is a doc comment.\"]\n # fn f() {}\n ```\n \n-(Note the leading space in the attribute version.)\n+(Note the leading space and the raw string literal in the attribute version.)\n \n In most cases, `///` is easier to use than `#[doc]`. One case where the latter is easier is\n when generating documentation in macros; the `collapse-docs` pass will combine multiple"}, {"sha": "07a9c48365f446852ed5490e79902dfba0970f94", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1612,7 +1612,7 @@ pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> T\n     match ty.kind {\n         TyKind::Never => Primitive(PrimitiveType::Never),\n         TyKind::Ptr(ref m) => RawPointer(m.mutbl, Box::new(clean_ty(m.ty, cx))),\n-        TyKind::Rptr(ref l, ref m) => {\n+        TyKind::Ref(ref l, ref m) => {\n             let lifetime = if l.is_anonymous() { None } else { Some(clean_lifetime(*l, cx)) };\n             BorrowedRef { lifetime, mutability: m.mutbl, type_: Box::new(clean_ty(m.ty, cx)) }\n         }\n@@ -1853,7 +1853,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n         ty::Placeholder(..) => panic!(\"Placeholder\"),\n         ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n         ty::Infer(..) => panic!(\"Infer\"),\n-        ty::Error(_) => panic!(\"Error\"),\n+        ty::Error(_) => rustc_errors::FatalError.raise(),\n     }\n }\n \n@@ -1949,40 +1949,52 @@ pub(crate) fn clean_field_with_def_id(\n }\n \n pub(crate) fn clean_variant_def<'tcx>(variant: &ty::VariantDef, cx: &mut DocContext<'tcx>) -> Item {\n+    let discriminant = match variant.discr {\n+        ty::VariantDiscr::Explicit(def_id) => Some(Discriminant { expr: None, value: def_id }),\n+        ty::VariantDiscr::Relative(_) => None,\n+    };\n+\n     let kind = match variant.ctor_kind() {\n-        Some(CtorKind::Const) => Variant::CLike(match variant.discr {\n-            ty::VariantDiscr::Explicit(def_id) => Some(Discriminant { expr: None, value: def_id }),\n-            ty::VariantDiscr::Relative(_) => None,\n-        }),\n-        Some(CtorKind::Fn) => Variant::Tuple(\n+        Some(CtorKind::Const) => VariantKind::CLike,\n+        Some(CtorKind::Fn) => VariantKind::Tuple(\n             variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n         ),\n-        None => Variant::Struct(VariantStruct {\n+        None => VariantKind::Struct(VariantStruct {\n             ctor_kind: None,\n             fields: variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n         }),\n     };\n-    Item::from_def_id_and_parts(variant.def_id, Some(variant.name), VariantItem(kind), cx)\n+\n+    Item::from_def_id_and_parts(\n+        variant.def_id,\n+        Some(variant.name),\n+        VariantItem(Variant { kind, discriminant }),\n+        cx,\n+    )\n }\n \n fn clean_variant_data<'tcx>(\n     variant: &hir::VariantData<'tcx>,\n     disr_expr: &Option<hir::AnonConst>,\n     cx: &mut DocContext<'tcx>,\n ) -> Variant {\n-    match variant {\n-        hir::VariantData::Struct(..) => Variant::Struct(VariantStruct {\n+    let discriminant = disr_expr.map(|disr| Discriminant {\n+        expr: Some(disr.body),\n+        value: cx.tcx.hir().local_def_id(disr.hir_id).to_def_id(),\n+    });\n+\n+    let kind = match variant {\n+        hir::VariantData::Struct(..) => VariantKind::Struct(VariantStruct {\n             ctor_kind: None,\n             fields: variant.fields().iter().map(|x| clean_field(x, cx)).collect(),\n         }),\n         hir::VariantData::Tuple(..) => {\n-            Variant::Tuple(variant.fields().iter().map(|x| clean_field(x, cx)).collect())\n+            VariantKind::Tuple(variant.fields().iter().map(|x| clean_field(x, cx)).collect())\n         }\n-        hir::VariantData::Unit(..) => Variant::CLike(disr_expr.map(|disr| Discriminant {\n-            expr: Some(disr.body),\n-            value: cx.tcx.hir().local_def_id(disr.hir_id).to_def_id(),\n-        })),\n-    }\n+        hir::VariantData::Unit(..) => VariantKind::CLike,\n+    };\n+\n+    Variant { discriminant, kind }\n }\n \n fn clean_path<'tcx>(path: &hir::Path<'tcx>, cx: &mut DocContext<'tcx>) -> Path {"}, {"sha": "77ec024262123ebb9dc6aa08ab721162c2a6431e", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -807,8 +807,11 @@ impl ItemKind {\n         match self {\n             StructItem(s) => s.fields.iter(),\n             UnionItem(u) => u.fields.iter(),\n-            VariantItem(Variant::Struct(v)) => v.fields.iter(),\n-            VariantItem(Variant::Tuple(v)) => v.iter(),\n+            VariantItem(v) => match &v.kind {\n+                VariantKind::CLike => [].iter(),\n+                VariantKind::Tuple(t) => t.iter(),\n+                VariantKind::Struct(s) => s.fields.iter(),\n+            },\n             EnumItem(e) => e.variants.iter(),\n             TraitItem(t) => t.items.iter(),\n             ImplItem(i) => i.items.iter(),\n@@ -824,7 +827,6 @@ impl ItemKind {\n             | TyMethodItem(_)\n             | MethodItem(_, _)\n             | StructFieldItem(_)\n-            | VariantItem(_)\n             | ForeignFunctionItem(_)\n             | ForeignStaticItem(_)\n             | ForeignTypeItem\n@@ -1740,7 +1742,7 @@ impl Type {\n     fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n         let t: PrimitiveType = match *self {\n             Type::Path { ref path } => return Some(path.def_id()),\n-            DynTrait(ref bounds, _) => return Some(bounds[0].trait_.def_id()),\n+            DynTrait(ref bounds, _) => return bounds.get(0).map(|b| b.trait_.def_id()),\n             Primitive(p) => return cache.and_then(|c| c.primitive_locations.get(&p).cloned()),\n             BorrowedRef { type_: box Generic(..), .. } => PrimitiveType::Reference,\n             BorrowedRef { ref type_, .. } => return type_.inner_def_id(cache),\n@@ -2136,17 +2138,23 @@ impl Enum {\n }\n \n #[derive(Clone, Debug)]\n-pub(crate) enum Variant {\n-    CLike(Option<Discriminant>),\n+pub(crate) struct Variant {\n+    pub kind: VariantKind,\n+    pub discriminant: Option<Discriminant>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub(crate) enum VariantKind {\n+    CLike,\n     Tuple(Vec<Item>),\n     Struct(VariantStruct),\n }\n \n impl Variant {\n     pub(crate) fn has_stripped_entries(&self) -> Option<bool> {\n-        match *self {\n-            Self::Struct(ref struct_) => Some(struct_.has_stripped_entries()),\n-            Self::CLike(..) | Self::Tuple(_) => None,\n+        match &self.kind {\n+            VariantKind::Struct(struct_) => Some(struct_.has_stripped_entries()),\n+            VariantKind::CLike | VariantKind::Tuple(_) => None,\n         }\n     }\n }"}, {"sha": "656aeefb01a4a807ea8aa8b418957544a28c356c", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -37,17 +37,21 @@ pub(crate) trait DocFolder: Sized {\n                 i.items = i.items.into_iter().filter_map(|x| self.fold_item(x)).collect();\n                 ImplItem(i)\n             }\n-            VariantItem(i) => match i {\n-                Variant::Struct(mut j) => {\n-                    j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                    VariantItem(Variant::Struct(j))\n-                }\n-                Variant::Tuple(fields) => {\n-                    let fields = fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                    VariantItem(Variant::Tuple(fields))\n-                }\n-                Variant::CLike(disr) => VariantItem(Variant::CLike(disr)),\n-            },\n+            VariantItem(Variant { kind, discriminant }) => {\n+                let kind = match kind {\n+                    VariantKind::Struct(mut j) => {\n+                        j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n+                        VariantKind::Struct(j)\n+                    }\n+                    VariantKind::Tuple(fields) => {\n+                        let fields = fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n+                        VariantKind::Tuple(fields)\n+                    }\n+                    VariantKind::CLike => VariantKind::CLike,\n+                };\n+\n+                VariantItem(Variant { kind, discriminant })\n+            }\n             ExternCrateItem { src: _ }\n             | ImportItem(_)\n             | FunctionItem(_)"}, {"sha": "40dfb06975067c7e149777f78bada90384203553", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1968dd6120935055e138ab10c6e0a3f3f2288b9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=e1968dd6120935055e138ab10c6e0a3f3f2288b9", "patch": "@@ -1220,15 +1220,15 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                     w.write_str(\"    \");\n                     let name = v.name.unwrap();\n                     match *v.kind {\n-                        clean::VariantItem(ref var) => match var {\n-                            // FIXME(#101337): Show discriminant\n-                            clean::Variant::CLike(..) => write!(w, \"{}\", name),\n-                            clean::Variant::Tuple(ref s) => {\n+                        // FIXME(#101337): Show discriminant\n+                        clean::VariantItem(ref var) => match var.kind {\n+                            clean::VariantKind::CLike => write!(w, \"{}\", name),\n+                            clean::VariantKind::Tuple(ref s) => {\n                                 write!(w, \"{}(\", name);\n                                 print_tuple_struct_fields(w, cx, s);\n                                 w.write_str(\")\");\n                             }\n-                            clean::Variant::Struct(ref s) => {\n+                            clean::VariantKind::Struct(ref s) => {\n                                 render_struct(\n                                     w,\n                                     v,\n@@ -1286,25 +1286,28 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                 \" rightside\",\n             );\n             write!(w, \"<h3 class=\\\"code-header\\\">{name}\", name = variant.name.unwrap());\n-            if let clean::VariantItem(clean::Variant::Tuple(ref s)) = *variant.kind {\n+\n+            let clean::VariantItem(variant_data) = &*variant.kind else { unreachable!() };\n+\n+            if let clean::VariantKind::Tuple(ref s) = variant_data.kind {\n                 w.write_str(\"(\");\n                 print_tuple_struct_fields(w, cx, s);\n                 w.write_str(\")\");\n             }\n             w.write_str(\"</h3></section>\");\n \n-            use crate::clean::Variant;\n-\n-            let heading_and_fields = match &*variant.kind {\n-                clean::VariantItem(Variant::Struct(s)) => Some((\"Fields\", &s.fields)),\n-                // Documentation on tuple variant fields is rare, so to reduce noise we only emit\n-                // the section if at least one field is documented.\n-                clean::VariantItem(Variant::Tuple(fields))\n-                    if fields.iter().any(|f| f.doc_value().is_some()) =>\n-                {\n-                    Some((\"Tuple Fields\", fields))\n+            let heading_and_fields = match &variant_data.kind {\n+                clean::VariantKind::Struct(s) => Some((\"Fields\", &s.fields)),\n+                clean::VariantKind::Tuple(fields) => {\n+                    // Documentation on tuple variant fields is rare, so to reduce noise we only emit\n+                    // the section if at least one field is documented.\n+                    if fields.iter().any(|f| f.doc_value().is_some()) {\n+                        Some((\"Tuple Fields\", fields))\n+                    } else {\n+                        None\n+                    }\n                 }\n-                _ => None,\n+                clean::VariantKind::CLike => None,\n             };\n \n             if let Some((heading, fields)) = heading_and_fields {"}]}