{"sha": "2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYjQyNTliMzUzMWUwY2ZhMWY2ZGYyZmY5NWUzMGE0Yzg3MWExMDU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-30T17:37:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-01T02:53:02Z"}, "message": "Stop inferring bot/static when types/regions are unconstrained.\n\nAlso, some other changes that came up along the way:\n- add a 'blk' region for the current block.\n- detect unused type/region variables.", "tree": {"sha": "192b8d969e34bd1390bd769e17d68b2e9c57e77e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/192b8d969e34bd1390bd769e17d68b2e9c57e77e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "html_url": "https://github.com/rust-lang/rust/commit/2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "079c3b02a86aa73d0d070876612ed889dc187354", "url": "https://api.github.com/repos/rust-lang/rust/commits/079c3b02a86aa73d0d070876612ed889dc187354", "html_url": "https://github.com/rust-lang/rust/commit/079c3b02a86aa73d0d070876612ed889dc187354"}], "stats": {"total": 388, "additions": 234, "deletions": 154}, "files": [{"sha": "4aa8b57568f9113da5a1db61f21478411bebbd0d", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -14,15 +14,15 @@ native mod rustrt {\n     fn rust_task_unweaken(ch: rust_port_id);\n }\n \n-type global_ptr<T: send> = *libc::uintptr_t;\n+type global_ptr = *libc::uintptr_t;\n \n #[doc = \"\n Atomically gets a channel from a pointer to a pointer-sized memory location\n or, if no channel exists creates and installs a new channel and sets up a new\n task to receive from it.\n \"]\n unsafe fn chan_from_global_ptr<T: send>(\n-    global: global_ptr<T>,\n+    global: global_ptr,\n     builder: fn() -> task::builder,\n     f: fn~(comm::port<T>)\n ) -> comm::chan<T> {"}, {"sha": "3215f3b9f289cb5034f174f1976fc41c21844e33", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -1168,7 +1168,9 @@ mod unsafe {\n     #[inline(always)]\n     unsafe fn form_slice<T,U>(p: *T, len: uint, f: fn([T]/&) -> U) -> U {\n         let pair = (p, len * sys::size_of::<T>());\n-        let v : *([T]/&) = ::unsafe::reinterpret_cast(ptr::addr_of(pair));\n+        // FIXME: should use &blk not &static here, but a snapshot is req'd\n+        let v : *([T]/&static) =\n+            ::unsafe::reinterpret_cast(ptr::addr_of(pair));\n         f(*v)\n     }\n }"}, {"sha": "4a4b5ea4d38f96346e9f0b2c5f3e587b43b61669", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -452,11 +452,7 @@ enum prim_ty {\n type region = {id: node_id, node: region_};\n \n #[auto_serialize]\n-enum region_ {\n-    re_anon,\n-    re_named(ident),\n-    re_static\n-}\n+enum region_ { re_anon, re_named(ident) }\n \n #[auto_serialize]\n enum ty_ {"}, {"sha": "0c681900dd560a5d069d6c1e41221ecf9210bbfa", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -250,16 +250,7 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n \n fn region_from_name(p: parser, s: option<str>) -> @ast::region {\n     let r = alt s {\n-      some (string) {\n-        // FIXME: To be consistent with our type resolution, the\n-        // static region should probably be resolved during type\n-        // checking, not in the parser. (Issue #2256)\n-        if string == \"static\" {\n-            ast::re_static\n-        } else {\n-            ast::re_named(string)\n-        }\n-      }\n+      some (string) { ast::re_named(string) }\n       none { ast::re_anon }\n     };\n "}, {"sha": "d67a2c822d01d9db53fac7b4d2b903dc2c88bb57", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -329,7 +329,6 @@ fn print_native_mod(s: ps, nmod: ast::native_mod, attrs: [ast::attribute]) {\n fn print_region(s: ps, region: @ast::region) {\n     alt region.node {\n       ast::re_anon { word_space(s, \"&\"); }\n-      ast::re_static { word_space(s, \"&static\"); }\n       ast::re_named(name) {\n         word(s.s, \"&\");\n         word_space(s, name);"}, {"sha": "bae50d13d17d405916b288032d42a80512ce3246", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -251,23 +251,23 @@ fn find_library_crate_aux(sess: session::session,\n         if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n             #debug(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n                    suffix);\n-            option::none\n+            option::none::<()>\n         } else {\n             #debug(\"%s is a candidate\", path);\n             alt get_metadata_section(sess, path) {\n               option::some(cvec) {\n                 if !crate_matches(cvec, metas, hash) {\n                     #debug(\"skipping %s, metadata doesn't match\", path);\n-                    option::none\n+                    option::none::<()>\n                 } else {\n                     #debug(\"found %s with matching metadata\", path);\n                     matches += [{ident: path, data: cvec}];\n-                    option::none\n+                    option::none::<()>\n                 }\n               }\n               _ {\n                 #debug(\"could not load metadata for %s\", path);\n-                option::none\n+                option::none::<()>\n               }\n             }\n         }"}, {"sha": "0477f6469cca5061d6e991e99292fce7b2047fc5", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -579,11 +579,8 @@ impl unify_methods for infer_ctxt {\n // [B].  Deep resolution, on the other hand, would yield [int].\n //\n // But there is one more knob: the force_vars variable controls the\n-// behavior in the face of unconstrained variables.  If we have A, B\n-// and only the constraint that A <: B, then the result is [_|_] if\n-// force_vars is true and [B] otherwise.  We use force_vars == true\n-// when resolving types after typeck, but false otherwise (for\n-// example, when pretty-printing them for errors).\n+// behavior in the face of unconstrained variables.  If it is true,\n+// then unconstrained variables result in an error.\n \n type resolve_state = @{\n     infcx: infer_ctxt,\n@@ -673,8 +670,12 @@ impl methods for resolve_state {\n             let r1 = alt bounds {\n               { ub:_, lb:some(t) } { self.resolve_region(t) }\n               { ub:some(t), lb:_ } { self.resolve_region(t) }\n-              { ub:none, lb:none } if self.force_vars { ty::re_static }\n-              { ub:none, lb:none } { ty::re_var(rid) }\n+              { ub:none, lb:none } {\n+                if self.force_vars {\n+                    self.err = some(unresolved_region(rid));\n+                }\n+                ty::re_var(rid)\n+              }\n             };\n             vec::pop(self.r_seen);\n             ret r1;\n@@ -700,8 +701,12 @@ impl methods for resolve_state {\n               { ub:_, lb:some(t) } if !type_is_bot(t) { self.resolve1(t) }\n               { ub:some(t), lb:_ } { self.resolve1(t) }\n               { ub:_, lb:some(t) } { self.resolve1(t) }\n-              { ub:none, lb:none } if self.force_vars { ty::mk_bot(tcx) }\n-              { ub:none, lb:none } { ty::mk_var(tcx, vid) }\n+              { ub:none, lb:none } {\n+                if self.force_vars {\n+                    self.err = some(unresolved_ty(vid));\n+                }\n+                ty::mk_var(tcx, vid)\n+              }\n             };\n             vec::pop(self.v_seen);\n             ret t1;"}, {"sha": "dee278e7ed031d32cae4bd25ed1fe4a517552ed4", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -4,6 +4,7 @@ import syntax::codemap::span;\n import ty::{kind, kind_copyable, kind_sendable, kind_noncopyable};\n import driver::session::session;\n import std::map::hashmap;\n+import syntax::print::pprust::expr_to_str;\n \n // Kind analysis pass. There are three kinds:\n //\n@@ -138,6 +139,7 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n }\n \n fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n+    #debug[\"kind::check_expr(%s)\", expr_to_str(e)];\n     alt e.node {\n       expr_assign(_, ex) | expr_assign_op(_, _, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |"}, {"sha": "cf8f223afd9d280ba8878d9d977b6b721e624423", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -37,7 +37,7 @@ export expr_ty_params_and_ty;\n export expr_is_lval;\n export field_ty;\n export fold_ty, fold_sty_to_ty, fold_region, fold_regions, fold_ty_var;\n-export fold_regions_and_ty;\n+export fold_regions_and_ty, walk_regions_and_ty;\n export field;\n export field_idx;\n export get_field;\n@@ -97,7 +97,7 @@ export ty_tup, mk_tup;\n export ty_type, mk_type;\n export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n-export ty_var, mk_var;\n+export ty_var, mk_var, type_is_var;\n export ty_self, mk_self;\n export region, bound_region;\n export get, type_has_params, type_has_vars, type_has_regions;\n@@ -818,6 +818,21 @@ fn fold_ty_var(cx: ctxt, t0: t, fldop: fn(ty_vid) -> t) -> t {\n     }\n }\n \n+fn walk_regions_and_ty(\n+    cx: ctxt,\n+    ty: t,\n+    walkr: fn(r: region),\n+    walkt: fn(t: t) -> bool) {\n+\n+    if (walkt(ty)) {\n+        fold_regions_and_ty(\n+            cx, ty,\n+            { |r| walkr(r); r },\n+            { |t| walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t },\n+            { |t| walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t });\n+    }\n+}\n+\n fn fold_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n@@ -1000,6 +1015,13 @@ fn type_is_nil(ty: t) -> bool { get(ty).struct == ty_nil }\n \n fn type_is_bot(ty: t) -> bool { get(ty).struct == ty_bot }\n \n+fn type_is_var(ty: t) -> bool {\n+    alt get(ty).struct {\n+      ty_var(_) { true }\n+      _ { false }\n+    }\n+}\n+\n fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n \n fn type_is_structural(ty: t) -> bool {"}, {"sha": "931d3d9e7903bd77a17b38da3f5335cbcb2227ea", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 106, "deletions": 33, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -105,6 +105,7 @@ type fn_ctxt =\n      ty_var_counter: @mut uint,\n      region_var_counter: @mut uint,\n \n+     mut blocks: [ast::node_id], // stack of blocks in scope, may be empty\n      in_scope_regions: isr_alist,\n \n      // While type checking a function, the intermediate types for the\n@@ -276,10 +277,8 @@ fn instantiate_path(fcx: @fn_ctxt,\n \n // Type tests\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n-    alt infer::resolve_shallow(fcx.infcx, tp, true) {\n-      // note: the bot type doesn't count as resolved; it's what we use when\n-      // there is no information about a variable.\n-      result::ok(t_s) if !ty::type_is_bot(t_s) { ret t_s; }\n+    alt infer::resolve_shallow(fcx.infcx, tp, false) {\n+      result::ok(t_s) if !ty::type_is_var(t_s) { ret t_s; }\n       _ {\n         fcx.ccx.tcx.sess.span_fatal\n             (sp, \"the type of this value must be known in this context\");\n@@ -322,7 +321,16 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n       ast::vstore_uniq { ty::vstore_uniq }\n       ast::vstore_box { ty::vstore_box }\n       ast::vstore_slice(r) {\n-        ty::vstore_slice(ast_region_to_region(fcx, fcx, e.span, r))\n+        alt fcx.block_region() {\n+          result::ok(b_r) {\n+            let rscope = in_anon_rscope(fcx, b_r);\n+            ty::vstore_slice(ast_region_to_region(fcx, rscope, e.span, r))\n+          }\n+          result::err(msg) {\n+            fcx.ccx.tcx.sess.span_err(e.span, msg);\n+            ty::vstore_slice(ty::re_static)\n+          }\n+        }\n       }\n     }\n }\n@@ -386,30 +394,30 @@ impl of region_scope for empty_rscope {\n     fn anon_region() -> result<ty::region, str> {\n         result::err(\"region types are not allowed here\")\n     }\n-    fn named_region(_id: str) -> result<ty::region, str> {\n-        result::err(\"region types are not allowed here\")\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        if id == \"static\" { result::ok(ty::re_static) }\n+        else { result::err(\"only the static region is allowed here\") }\n     }\n }\n \n enum type_rscope = ast::region_param;\n impl of region_scope for type_rscope {\n     fn anon_region() -> result<ty::region, str> {\n         alt *self {\n-          ast::rp_self {\n-            result::ok(ty::re_bound(ty::br_self))\n-          }\n+          ast::rp_self { result::ok(ty::re_bound(ty::br_self)) }\n           ast::rp_none {\n             result::err(\"to use region types here, the containing type \\\n                          must be declared with a region bound\")\n           }\n         }\n     }\n     fn named_region(id: str) -> result<ty::region, str> {\n-        if id == \"self\" {\n-            self.anon_region()\n-        } else {\n-            result::err(\"named regions other than `self` are not \\\n-                         allowed as part of a type declaration\")\n+        empty_rscope.named_region(id).chain_err { |_e|\n+            if id == \"self\" { self.anon_region() }\n+            else {\n+                result::err(\"named regions other than `self` are not \\\n+                             allowed as part of a type declaration\")\n+            }\n         }\n     }\n }\n@@ -419,11 +427,14 @@ impl of region_scope for @fn_ctxt {\n         result::ok(self.next_region_var())\n     }\n     fn named_region(id: str) -> result<ty::region, str> {\n-        alt self.in_scope_regions.find(ty::br_named(id)) {\n-          some(r) { result::ok(r) }\n-          none {\n-            result::err(#fmt[\"named region `%s` not in scope here\", id])\n-          }\n+        empty_rscope.named_region(id).chain_err { |_e|\n+            alt self.in_scope_regions.find(ty::br_named(id)) {\n+              some(r) { result::ok(r) }\n+              none if id == \"blk\" { self.block_region() }\n+              none {\n+                result::err(#fmt[\"named region `%s` not in scope here\", id])\n+              }\n+            }\n         }\n     }\n }\n@@ -477,7 +488,6 @@ fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n     let res = alt a_r.node {\n       ast::re_anon { rscope.anon_region() }\n       ast::re_named(id) { rscope.named_region(id) }\n-      ast::re_static { result::ok(ty::re_static) }\n     };\n \n     get_region_reporting_err(self.tcx(), span, res)\n@@ -772,6 +782,49 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n     ret typ;\n }\n \n+fn check_bounds_are_used(ccx: @crate_ctxt,\n+                         span: span,\n+                         tps: [ast::ty_param],\n+                         rp: ast::region_param,\n+                         ty: ty::t) {\n+    let mut r_used = alt rp {\n+      ast::rp_self { false }\n+      ast::rp_none { true }\n+    };\n+\n+    if tps.len() == 0u && r_used { ret; }\n+    let tps_used = vec::to_mut(vec::from_elem(tps.len(), false));\n+\n+    ty::walk_regions_and_ty(\n+        ccx.tcx, ty,\n+        { |r|\n+            alt r {\n+              ty::re_bound(_) { r_used = true; }\n+              _ { }\n+            }\n+        },\n+        { |t|\n+            alt ty::get(t).struct {\n+              ty::ty_param(idx, _) { tps_used[idx] = true; }\n+              _ { }\n+            }\n+            true\n+        });\n+\n+    if !r_used {\n+        ccx.tcx.sess.span_err(\n+            span, \"lifetime `self` unused inside \\\n+                   reference-parameterized type.\");\n+    }\n+\n+    for tps_used.eachi { |i, b|\n+        if !b {\n+            ccx.tcx.sess.span_err(\n+                span, #fmt[\"Type parameter %s is unused.\", tps[i].ident]);\n+        }\n+    }\n+}\n+\n fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n     -> ty::ty_param_bounds_and_ty {\n \n@@ -816,6 +869,9 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n             };\n             {bounds: ty_param_bounds(ccx, tps), rp: rp, ty: ty}\n         };\n+\n+        check_bounds_are_used(ccx, t.span, tps, rp, tpt.ty);\n+\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -1125,6 +1181,12 @@ impl methods for @fn_ctxt {\n     fn ty_to_str(t: ty::t) -> str {\n         ty_to_str(self.ccx.tcx, resolve_type_vars_if_possible(self, t))\n     }\n+    fn block_region() -> result<ty::region, str> {\n+        alt vec::last_opt(self.blocks) {\n+          some(bid) { result::ok(ty::re_scope(bid)) }\n+          none { result::err(\"no block is in scope here\") }\n+        }\n+    }\n     fn write_ty(node_id: ast::node_id, ty: ty::t) {\n         #debug[\"write_ty(%d, %s) in fcx %s\",\n                node_id, ty_to_str(self.tcx(), ty), self.tag()];\n@@ -3144,7 +3206,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         -> option<O> {\n         alt expected {\n           some(t) {\n-            alt infer::resolve_shallow(fcx.infcx, t, true) {\n+            alt infer::resolve_shallow(fcx.infcx, t, false) {\n               result::ok(t) { unpack(ty::get(t).struct) }\n               _ { none }\n             }\n@@ -3913,6 +3975,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n       ast::unsafe_blk { @{purity: ast::unsafe_fn with *fcx0} }\n       ast::default_blk { fcx0 }\n     };\n+    vec::push(fcx.blocks, blk.node.id);\n     let mut bot = false;\n     let mut warned = false;\n     for blk.node.stmts.each {|s|\n@@ -3943,6 +4006,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n     if bot {\n         fcx.write_bot(blk.node.id);\n     }\n+    vec::pop(fcx.blocks);\n     ret bot;\n }\n \n@@ -3960,6 +4024,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n           locals: int_hash(),\n           ty_var_counter: @mut 0u,\n           region_var_counter: @mut 0u,\n+          mut blocks: [],\n           in_scope_regions: @nil,\n           node_types: smallintmap::mk(),\n           node_type_substs: map::int_hash(),\n@@ -4000,6 +4065,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n           locals: int_hash(),\n           ty_var_counter: @mut 0u,\n           region_var_counter: @mut 0u,\n+          mut blocks: [],\n           in_scope_regions: @nil,\n           node_types: smallintmap::mk(),\n           node_type_substs: map::int_hash(),\n@@ -4262,6 +4328,7 @@ fn check_fn(ccx: @crate_ctxt,\n           locals: locals,\n           ty_var_counter: tvc,\n           region_var_counter: rvc,\n+          mut blocks: [],\n           in_scope_regions: isr,\n           node_types: node_types,\n           node_type_substs: node_type_substs,\n@@ -4350,21 +4417,27 @@ fn check_fn(ccx: @crate_ctxt,\n             visit::visit_pat(p, e, v);\n         };\n \n+        let visit_block = fn@(b: ast::blk, &&e: (), v: visit::vt<()>) {\n+            vec::push(fcx.blocks, b.node.id);\n+            visit::visit_block(b, e, v);\n+            vec::pop(fcx.blocks);\n+        };\n+\n         // Don't descend into fns and items\n-        fn visit_fn<T>(_fk: visit::fn_kind, _decl: ast::fn_decl,\n-                       _body: ast::blk, _sp: span,\n-                       _id: ast::node_id, _t: T, _v: visit::vt<T>) {\n+        fn visit_fn(_fk: visit::fn_kind, _decl: ast::fn_decl,\n+                    _body: ast::blk, _sp: span,\n+                    _id: ast::node_id, &&_t: (), _v: visit::vt<()>) {\n         }\n-        fn visit_item<E>(_i: @ast::item, _e: E, _v: visit::vt<E>) { }\n+        fn visit_item(_i: @ast::item, &&_e: (), _v: visit::vt<()>) { }\n \n-        let visit =\n-            @{visit_local: visit_local,\n-              visit_pat: visit_pat,\n-              visit_fn: bind visit_fn(_, _, _, _, _, _, _),\n-              visit_item: bind visit_item(_, _, _)\n-              with *visit::default_visitor()};\n+        let visit = visit::mk_vt(@{visit_local: visit_local,\n+                                   visit_pat: visit_pat,\n+                                   visit_fn: visit_fn,\n+                                   visit_item: visit_item,\n+                                   visit_block: visit_block\n+                                   with *visit::default_visitor()});\n \n-        visit::visit_block(body, (), visit::mk_vt(visit));\n+        visit.visit_block(body, (), visit);\n     }\n }\n "}, {"sha": "678e3cc57ea9ec12212d3e71bde05b20236529eb", "filename": "src/test/compile-fail/issue-1763.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -0,0 +1,7 @@\n+// Issue #1763 - infer types correctly\n+\n+type actor<T> = { //! ERROR Type parameter T is unused.\n+    unused: bool\n+};\n+\n+fn main() {}"}, {"sha": "15b3d6d96c7ed7f157a09cef7afb2c2ed6caa6d0", "filename": "src/test/compile-fail/issue-2163.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fissue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fissue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2163.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -1,5 +1,5 @@\n fn main(s: [str]) {\n-    let a = [];\n+    let a: [int] = [];\n     vec::each(a) { |x| //! ERROR in function `anon`, not all control paths\n     }                  //! ERROR see function return type of `bool`\n }"}, {"sha": "617315853af01cd86a93aee0c5857fa5c855de7b", "filename": "src/test/compile-fail/region-unused.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregion-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregion-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-unused.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -0,0 +1,3 @@\n+type foo/& = {f: int}; //! ERROR lifetime `self` unused\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "0d0cdb6d93f76c337e25acdf507fb9404283dccb", "filename": "src/test/compile-fail/regions-blk.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-blk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-blk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-blk.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -0,0 +1,15 @@\n+fn foo(cond: bool) {\n+    let x = 5;\n+    let mut y: &blk.int = &x;\n+\n+    let mut z: &blk.int;\n+    if cond {\n+        z = &x;\n+    } else {\n+        let w: &blk.int = &x;\n+        z = w; //! ERROR mismatched types\n+    }\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "c48fec0f8acf674a89b07ddfc090d4493c490b9a", "filename": "src/test/compile-fail/regions-in-consts.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -0,0 +1,7 @@\n+// xfail-test\n+\n+const c_x: &blk.int = 22; //! ERROR only the static region is allowed here\n+const c_y: &static.int = &22; //! ERROR only the static region is allowed here\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "c4619001e7cd00af80bb6137933bdfa4f8d109da", "filename": "src/test/compile-fail/regions-in-type-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -18,7 +18,7 @@ type item_ty_yes1/& = {\n     x: &self.uint\n };\n \n-type item_ty_yes2/& = {\n+type item_ty_yes2/& = { //! ERROR lifetime `self` unused inside reference-parameterized type\n     x: &foo.uint //! ERROR named regions other than `self` are not allowed as part of a type declaration\n };\n "}, {"sha": "5f5aadaa10763c225942a464745ca11dde901bb8", "filename": "src/test/compile-fail/regions-out-of-scope-slice.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-out-of-scope-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-out-of-scope-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-out-of-scope-slice.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -0,0 +1,13 @@\n+// xfail-test\n+\n+fn foo(cond: bool) {\n+    // Here we will infer a type that uses the\n+    // region of the if stmt then block, but in the scope:\n+    let mut x; //! ERROR foo\n+\n+    if cond {\n+        x = [1,2,3]/&blk;\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "b8aecb05e897a93824804b6109bba3eb7495c0e4", "filename": "src/test/compile-fail/regions-var-type-out-of-scope.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -0,0 +1,13 @@\n+// xfail-test\n+\n+fn foo(cond: bool) {\n+    // Here we will infer a type that uses the\n+    // region of the if stmt then block:\n+    let mut x; //! ERROR foo\n+\n+    if cond {\n+        x = &3;\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "4fe164878a840f389771efa0809061152456440e", "filename": "src/test/compile-fail/use-after-send.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -4,7 +4,8 @@ fn send<T: send>(ch: _chan<T>, -data: T) {\n     log(debug, data);\n     fail;\n }\n-type _chan<T> = int;\n+\n+enum _chan<T> = int;\n \n // Tests that \"log(debug, message);\" is flagged as using\n // message after the send deinitializes it"}, {"sha": "8d4478d949f5a00e80a18b620746968702edd535", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _foo = []; //! ERROR unconstrained type\n+}"}, {"sha": "a7d360ff8fc392185419a292f4521f970598f76b", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -4,7 +4,7 @@ fn test00_start(ch: chan_t<int>, message: int) { send(ch, copy message); }\n type task_id = int;\n type port_id = int;\n \n-type chan_t<T: send> = {task: task_id, port: port_id};\n+enum chan_t<T: send> = {task: task_id, port: port_id};\n \n fn send<T: send>(ch: chan_t<T>, -data: T) { fail; }\n "}, {"sha": "36ea0d961b7e869eb6dcadd5a16f42a710f642bf", "filename": "src/test/run-fail/issue-1763.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/079c3b02a86aa73d0d070876612ed889dc187354/src%2Ftest%2Frun-fail%2Fissue-1763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/079c3b02a86aa73d0d070876612ed889dc187354/src%2Ftest%2Frun-fail%2Fissue-1763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-1763.rs?ref=079c3b02a86aa73d0d070876612ed889dc187354", "patch": "@@ -1,14 +0,0 @@\n-// Issue #1763 - infer types correctly\n-// error-pattern:explicit failure\n-\n-type actor<T> = {\n-    unused: bool\n-};\n-\n-fn act2<T>() -> actor<T> {\n-    fail;\n-}\n-\n-fn main() {\n-    let a: actor<int> = act2();\n-}"}, {"sha": "6f614258bcbefb8b71b73804d7fa89f8cc8ea705", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:get called on error result: \"kitty\"\n fn main() {\n-  log(error, result::get(result::err(\"kitty\")));\n+  log(error, result::get(result::err::<int,str>(\"kitty\")));\n }\n\\ No newline at end of file"}, {"sha": "d46f501f0fafdbda4fa9cc63ecd25e42959f2b16", "filename": "src/test/run-pass/class-poly-methods-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n // xfail-fast\n // aux-build:cci_class_6.rs\n use cci_class_6;"}, {"sha": "3b2f1b2ced5b6558d95b5f1e7282a2f9135dd882", "filename": "src/test/run-pass/iter-to-vec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -1,7 +1,8 @@\n fn main() {\n     assert [1u, 3u].to_vec() == [1u, 3u];\n-    assert [].to_vec() == [];\n-    assert none.to_vec() == [];\n+    let e: [uint] = [];\n+    assert e.to_vec() == [];\n+    assert none::<uint>.to_vec() == [];\n     assert some(1u).to_vec() == [1u];\n     assert some(2u).to_vec() == [2u];\n }\n\\ No newline at end of file"}, {"sha": "822ed735f772e817877787b89c809af337e3a592", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -16,7 +16,7 @@ type ccx = {\n };\n \n fn alloc(_bcx : &a.arena) -> &a.bcx unsafe {\n-    ret unsafe::reinterpret_cast(libc::malloc(sys::size_of::<bcx>()));\n+    ret unsafe::reinterpret_cast(libc::malloc(sys::size_of::<bcx/&blk>()));\n }\n \n fn h(bcx : &a.bcx) -> &a.bcx {"}, {"sha": "38b97b47e4bd6c558eb56609954284518effab55", "filename": "src/test/run-pass/unreachable-code-1.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Funreachable-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Funreachable-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funreachable-code-1.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -8,7 +8,6 @@ fn call_id() {\n }\n \n fn call_id_3() { id(ret) && id(ret); }\n-    //!^ ERROR the type of this value must be known\n \n fn main() {\n }", "previous_filename": "src/test/compile-fail/unreachable-code-1.rs"}, {"sha": "c97224144e25f885e503a50fd7448f21b3d91737", "filename": "src/test/run-pass/unreachable-code.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/079c3b02a86aa73d0d070876612ed889dc187354/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/079c3b02a86aa73d0d070876612ed889dc187354/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funreachable-code.rs?ref=079c3b02a86aa73d0d070876612ed889dc187354", "patch": "@@ -1,57 +0,0 @@\n-// xfail-pretty\n-\n-fn id(x: bool) -> bool { x }\n-\n-fn call_id() {\n-    let c <- fail;\n-    id(c);\n-}\n-\n-fn call_id_2() { id(true) && id(ret); }\n-\n-fn call_id_4() { while id(ret) { } }\n-\n-fn bind_id_1() { bind id(fail); }\n-\n-fn bind_id_2() { bind id(ret); }\n-\n-fn fail_fail() { fail fail; }\n-\n-fn log_fail() { log(error, fail); }\n-\n-fn log_ret() { log(error, ret); }\n-\n-fn log_break() { loop { log(error, break); } }\n-\n-fn log_cont() { do { log(error, cont); } while false }\n-\n-fn ret_ret() -> int { ret 3 + (ret 2); }\n-\n-fn ret_guard() {\n-    alt check 2 {\n-      x if (ret) { x; }\n-    }\n-}\n-\n-fn rec_ret() { let _r: {c: int} = {c: ret}; }\n-\n-fn vec_ret() { let _v: [int] = [1, 2, ret, 4]; }\n-\n-fn fail_then_concat() {\n-    let mut x = [], y = [3];\n-    fail;\n-    x += y;\n-    \"good\" + \"bye\";\n-}\n-\n-fn main() {\n-  // Call the functions that don't fail.\n-  rec_ret();\n-  vec_ret();\n-  ret_ret();\n-  log_ret();\n-  call_id_2();\n-  call_id_4();\n-  bind_id_2();\n-  ret_guard();\n-}"}, {"sha": "dec8ca27db608a3aa155fbdcd667be43f0b552fd", "filename": "src/test/run-pass/vector-no-ann.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/079c3b02a86aa73d0d070876612ed889dc187354/src%2Ftest%2Frun-pass%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/079c3b02a86aa73d0d070876612ed889dc187354/src%2Ftest%2Frun-pass%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-no-ann.rs?ref=079c3b02a86aa73d0d070876612ed889dc187354", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    // We will infer this to have the type vec[bot]\n-    let _foo = [];\n-}"}, {"sha": "bf3bd4c8ae6e5feb5766b49bbc3a7c478a0c9b62", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db4259b3531e0cfa1f6df2ff95e30a4c871a105/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=2db4259b3531e0cfa1f6df2ff95e30a4c871a105", "patch": "@@ -1,6 +1,6 @@\n // Just a grab bag of stuff that you wouldn't want to actually write.\n \n-fn strange() -> bool { let _x = ret true; }\n+fn strange() -> bool { let _x: bool = ret true; }\n \n fn funny() {\n     fn f(_x: ()) { }\n@@ -20,13 +20,14 @@ fn zombiejesus() {\n         while (ret) {\n             if (ret) {\n                 alt (ret) {\n-                    _ {\n+                    1 {\n                         if (ret) {\n                             ret\n                         } else {\n                             ret\n                         }\n                     }\n+                    _ { ret }\n                 };\n             } else if (ret) {\n                 ret;\n@@ -51,7 +52,7 @@ fn canttouchthis() -> uint {\n     pure fn p() -> bool { true }\n     let _a = (assert (true)) == (check (p()));\n     let _c = (check (p())) == ();\n-    let _b = (log(debug, 0) == (ret 0u));\n+    let _b: bool = (log(debug, 0) == (ret 0u));\n }\n \n fn angrydome() {"}]}