{"sha": "9f6917d4264c423283ba610b4185ace61e77428b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNjkxN2Q0MjY0YzQyMzI4M2JhNjEwYjQxODVhY2U2MWU3NzQyOGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-14T01:26:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-14T01:26:54Z"}, "message": "Auto merge of #30466 - alexcrichton:move-wrapping-and-fill-out, r=aturon\n\nThis commit migrates all of the methods on `num::wrapping::OverflowingOps` onto\ninherent methods of the integer types. This also fills out some missing gaps in\nthe saturating and checked departments such as:\n\n* `saturating_mul`\n* `checked_{neg,rem,shl,shr}`\n\nThis is done in preparation for stabilization,\n\ncc #27755", "tree": {"sha": "90d7092d3024bf318c811c653fa6a3cd40fff40b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90d7092d3024bf318c811c653fa6a3cd40fff40b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f6917d4264c423283ba610b4185ace61e77428b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f6917d4264c423283ba610b4185ace61e77428b", "html_url": "https://github.com/rust-lang/rust/commit/9f6917d4264c423283ba610b4185ace61e77428b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f6917d4264c423283ba610b4185ace61e77428b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1447ce78fbd65a629f228ec8731a5cddc076a15c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1447ce78fbd65a629f228ec8731a5cddc076a15c", "html_url": "https://github.com/rust-lang/rust/commit/1447ce78fbd65a629f228ec8731a5cddc076a15c"}, {"sha": "7eb76995933ee0ced03c23cdaeeeac86d7713450", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eb76995933ee0ced03c23cdaeeeac86d7713450", "html_url": "https://github.com/rust-lang/rust/commit/7eb76995933ee0ced03c23cdaeeeac86d7713450"}], "stats": {"total": 672, "additions": 658, "deletions": 14}, "files": [{"sha": "76214366dc6d4d3cc7a9fe78b51e437ba30acdfc", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 658, "deletions": 14, "changes": 672, "blob_url": "https://github.com/rust-lang/rust/blob/9f6917d4264c423283ba610b4185ace61e77428b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f6917d4264c423283ba610b4185ace61e77428b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9f6917d4264c423283ba610b4185ace61e77428b", "patch": "@@ -124,7 +124,7 @@ macro_rules! checked_op {\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($ActualT:ty, $UnsignedT:ty, $BITS:expr,\n+    ($ActualT:ident, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n@@ -393,7 +393,8 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn checked_add(self, other: Self) -> Option<Self> {\n-            checked_op!($ActualT, $add_with_overflow, self, other)\n+            let (a, b) = self.overflowing_add(other);\n+            if b {None} else {Some(a)}\n         }\n \n         /// Checked integer subtraction. Computes `self - other`, returning\n@@ -410,7 +411,8 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn checked_sub(self, other: Self) -> Option<Self> {\n-            checked_op!($ActualT, $sub_with_overflow, self, other)\n+            let (a, b) = self.overflowing_sub(other);\n+            if b {None} else {Some(a)}\n         }\n \n         /// Checked integer multiplication. Computes `self * other`, returning\n@@ -427,7 +429,8 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn checked_mul(self, other: Self) -> Option<Self> {\n-            checked_op!($ActualT, $mul_with_overflow, self, other)\n+            let (a, b) = self.overflowing_mul(other);\n+            if b {None} else {Some(a)}\n         }\n \n         /// Checked integer division. Computes `self / other`, returning `None`\n@@ -445,14 +448,103 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn checked_div(self, other: Self) -> Option<Self> {\n-            match other {\n-                0    => None,\n-               -1 if self == Self::min_value()\n-                     => None,\n-               other => Some(self / other),\n+            if other == 0 {\n+                None\n+            } else {\n+                let (a, b) = self.overflowing_div(other);\n+                if b {None} else {Some(a)}\n             }\n         }\n \n+        /// Checked integer remainder. Computes `self % other`, returning `None`\n+        /// if `other == 0` or the operation results in underflow or overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!(5i32.checked_rem(2), Some(1));\n+        /// assert_eq!(5i32.checked_rem(0), None);\n+        /// assert_eq!(i32::MIN.checked_rem(-1), None);\n+        /// ```\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[inline]\n+        pub fn checked_rem(self, other: Self) -> Option<Self> {\n+            if other == 0 {\n+                None\n+            } else {\n+                let (a, b) = self.overflowing_rem(other);\n+                if b {None} else {Some(a)}\n+            }\n+        }\n+\n+        /// Checked negation. Computes `!self`, returning `None` if `self ==\n+        /// MIN`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!(5i32.checked_neg(), Some(-5));\n+        /// assert_eq!(i32::MIN.checked_neg(), None);\n+        /// ```\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[inline]\n+        pub fn checked_neg(self) -> Option<Self> {\n+            let (a, b) = self.overflowing_neg();\n+            if b {None} else {Some(a)}\n+        }\n+\n+        /// Checked shift left. Computes `self << rhs`, returning `None`\n+        /// if `rhs` is larger than or equal to the number of bits in `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(0x10i32.checked_shl(4), Some(0x100));\n+        /// assert_eq!(0x10i32.checked_shl(33), None);\n+        /// ```\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[inline]\n+        pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n+            let (a, b) = self.overflowing_shl(rhs);\n+            if b {None} else {Some(a)}\n+        }\n+\n+        /// Checked shift right. Computes `self >> rhs`, returning `None`\n+        /// if `rhs` is larger than or equal to the number of bits in `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(0x10i32.checked_shr(4), Some(0x1));\n+        /// assert_eq!(0x10i32.checked_shr(33), None);\n+        /// ```\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[inline]\n+        pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n+            let (a, b) = self.overflowing_shr(rhs);\n+            if b {None} else {Some(a)}\n+        }\n+\n         /// Saturating integer addition. Computes `self + other`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n@@ -468,7 +560,7 @@ macro_rules! int_impl {\n         #[inline]\n         pub fn saturating_add(self, other: Self) -> Self {\n             match self.checked_add(other) {\n-                Some(x)                       => x,\n+                Some(x) => x,\n                 None if other >= Self::zero() => Self::max_value(),\n                 None => Self::min_value(),\n             }\n@@ -489,12 +581,40 @@ macro_rules! int_impl {\n         #[inline]\n         pub fn saturating_sub(self, other: Self) -> Self {\n             match self.checked_sub(other) {\n-                Some(x)                      => x,\n+                Some(x) => x,\n                 None if other >= Self::zero() => Self::min_value(),\n                 None => Self::max_value(),\n             }\n         }\n \n+        /// Saturating integer multiplication. Computes `self * other`,\n+        /// saturating at the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!(100i32.saturating_mul(127), 12700);\n+        /// assert_eq!((1i32 << 23).saturating_mul(1 << 23), i32::MAX);\n+        /// assert_eq!((-1i32 << 23).saturating_mul(1 << 23), i32::MIN);\n+        /// ```\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[inline]\n+        pub fn saturating_mul(self, other: Self) -> Self {\n+            self.checked_mul(other).unwrap_or_else(|| {\n+                if (self < 0 && other < 0) || (self > 0 && other > 0) {\n+                    Self::max_value()\n+                } else {\n+                    Self::min_value()\n+                }\n+            })\n+        }\n+\n         /// Wrapping (modular) addition. Computes `self + other`,\n         /// wrapping around at the boundary of the type.\n         ///\n@@ -562,6 +682,10 @@ macro_rules! int_impl {\n         /// in the type. In such a case, this function returns `MIN`\n         /// itself.\n         ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0.\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -584,6 +708,10 @@ macro_rules! int_impl {\n         /// -1` on a signed type (where `MIN` is the negative\n         /// minimal value). In such a case, this function returns `0`.\n         ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0.\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -657,6 +785,230 @@ macro_rules! int_impl {\n             self.overflowing_shr(rhs).0\n         }\n \n+        /// Calculates `self` + `rhs`\n+        ///\n+        /// Returns a tuple of the addition along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!(5i32.overflowing_add(2), (7, false));\n+        /// assert_eq!(i32::MAX.overflowing_add(1), (i32::MIN, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+            unsafe {\n+                let (a, b) = $add_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        /// Calculates `self` - `rhs`\n+        ///\n+        /// Returns a tuple of the subtraction along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!(5i32.overflowing_sub(2), (3, false));\n+        /// assert_eq!(i32::MIN.overflowing_sub(1), (i32::MAX, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+            unsafe {\n+                let (a, b) = $sub_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        /// Calculates the multiplication of `self` and `rhs`.\n+        ///\n+        /// Returns a tuple of the multiplication along with a boolean\n+        /// indicating whether an arithmetic overflow would occur. If an\n+        /// overflow would have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(5i32.overflowing_mul(2), (10, false));\n+        /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+            unsafe {\n+                let (a, b) = $mul_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        /// Calculates the divisor when `self` is divided by `rhs`.\n+        ///\n+        /// Returns a tuple of the divisor along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// occur then self is returned.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!(5i32.overflowing_div(2), (2, false));\n+        /// assert_eq!(i32::MIN.overflowing_div(-1), (i32::MIN, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+            if self == Self::min_value() && rhs == -1 {\n+                (self, true)\n+            } else {\n+                (self / rhs, false)\n+            }\n+        }\n+\n+        /// Calculates the remainder when `self` is divided by `rhs`.\n+        ///\n+        /// Returns a tuple of the remainder after dividing along with a boolean\n+        /// indicating whether an arithmetic overflow would occur. If an\n+        /// overflow would occur then 0 is returned.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!(5i32.overflowing_rem(2), (1, false));\n+        /// assert_eq!(i32::MIN.overflowing_rem(-1), (0, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+            if self == Self::min_value() && rhs == -1 {\n+                (0, true)\n+            } else {\n+                (self % rhs, false)\n+            }\n+        }\n+\n+        /// Negates self, overflowing if this is equal to the minimum value.\n+        ///\n+        /// Returns a tuple of the negated version of self along with a boolean\n+        /// indicating whether an overflow happened. If `self` is the minimum\n+        /// value (e.g. `i32::MIN` for values of type `i32`), then the minimum\n+        /// value will be returned again and `true` will be returned for an\n+        /// overflow happening.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!(2i32.overflowing_neg(), (-2, false));\n+        /// assert_eq!(i32::MIN.overflowing_neg(), (i32::MIN, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_neg(self) -> (Self, bool) {\n+            if self == Self::min_value() {\n+                (Self::min_value(), true)\n+            } else {\n+                (-self, false)\n+            }\n+        }\n+\n+        /// Shifts self left by `rhs` bits.\n+        ///\n+        /// Returns a tuple of the shifted version of self along with a boolean\n+        /// indicating whether the shift value was larger than or equal to the\n+        /// number of bits. If the shift value is too large, then value is\n+        /// masked (N-1) where N is the number of bits, and this value is then\n+        /// used to perform the shift.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(0x10i32.overflowing_shl(4), (0x100, false));\n+        /// assert_eq!(0x10i32.overflowing_shl(36), (0x100, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Shifts self right by `rhs` bits.\n+        ///\n+        /// Returns a tuple of the shifted version of self along with a boolean\n+        /// indicating whether the shift value was larger than or equal to the\n+        /// number of bits. If the shift value is too large, then value is\n+        /// masked (N-1) where N is the number of bits, and this value is then\n+        /// used to perform the shift.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(0x10i32.overflowing_shr(4), (0x1, false));\n+        /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n+        }\n+\n         /// Raises self to the power of `exp`, using exponentiation by squaring.\n         ///\n         /// # Examples\n@@ -1121,7 +1473,8 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn checked_add(self, other: Self) -> Option<Self> {\n-            checked_op!($ActualT, $add_with_overflow, self, other)\n+            let (a, b) = self.overflowing_add(other);\n+            if b {None} else {Some(a)}\n         }\n \n         /// Checked integer subtraction. Computes `self - other`, returning\n@@ -1138,7 +1491,8 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn checked_sub(self, other: Self) -> Option<Self> {\n-            checked_op!($ActualT, $sub_with_overflow, self, other)\n+            let (a, b) = self.overflowing_sub(other);\n+            if b {None} else {Some(a)}\n         }\n \n         /// Checked integer multiplication. Computes `self * other`, returning\n@@ -1155,7 +1509,8 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn checked_mul(self, other: Self) -> Option<Self> {\n-            checked_op!($ActualT, $mul_with_overflow, self, other)\n+            let (a, b) = self.overflowing_mul(other);\n+            if b {None} else {Some(a)}\n         }\n \n         /// Checked integer division. Computes `self / other`, returning `None`\n@@ -1179,6 +1534,69 @@ macro_rules! uint_impl {\n             }\n         }\n \n+        /// Checked integer remainder. Computes `self % other`, returning `None`\n+        /// if `other == 0` or the operation results in underflow or overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(5u32.checked_rem(2), Some(1));\n+        /// assert_eq!(5u32.checked_rem(0), None);\n+        /// ```\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[inline]\n+        pub fn checked_rem(self, other: Self) -> Option<Self> {\n+            if other == 0 {\n+                None\n+            } else {\n+                Some(self % other)\n+            }\n+        }\n+\n+        /// Checked shift left. Computes `self << rhs`, returning `None`\n+        /// if `rhs` is larger than or equal to the number of bits in `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(0x10u32.checked_shl(4), Some(0x100));\n+        /// assert_eq!(0x10u32.checked_shl(33), None);\n+        /// ```\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[inline]\n+        pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n+            let (a, b) = self.overflowing_shl(rhs);\n+            if b {None} else {Some(a)}\n+        }\n+\n+        /// Checked shift right. Computes `self >> rhs`, returning `None`\n+        /// if `rhs` is larger than or equal to the number of bits in `self`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(0x10u32.checked_shr(4), Some(0x1));\n+        /// assert_eq!(0x10u32.checked_shr(33), None);\n+        /// ```\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[inline]\n+        pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n+            let (a, b) = self.overflowing_shr(rhs);\n+            if b {None} else {Some(a)}\n+        }\n+\n         /// Saturating integer addition. Computes `self + other`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n@@ -1221,6 +1639,27 @@ macro_rules! uint_impl {\n             }\n         }\n \n+        /// Saturating integer multiplication. Computes `self * other`,\n+        /// saturating at the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::u32;\n+        ///\n+        /// assert_eq!(100u32.saturating_mul(127), 12700);\n+        /// assert_eq!((1u32 << 23).saturating_mul(1 << 23), u32::MAX);\n+        /// ```\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[inline]\n+        pub fn saturating_mul(self, other: Self) -> Self {\n+            self.checked_mul(other).unwrap_or(Self::max_value())\n+        }\n+\n         /// Wrapping (modular) addition. Computes `self + other`,\n         /// wrapping around at the boundary of the type.\n         ///\n@@ -1383,6 +1822,211 @@ macro_rules! uint_impl {\n             self.overflowing_shr(rhs).0\n         }\n \n+        /// Calculates `self` + `rhs`\n+        ///\n+        /// Returns a tuple of the addition along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::u32;\n+        ///\n+        /// assert_eq!(5u32.overflowing_add(2), (7, false));\n+        /// assert_eq!(u32::MAX.overflowing_add(1), (0, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+            unsafe {\n+                let (a, b) = $add_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        /// Calculates `self` - `rhs`\n+        ///\n+        /// Returns a tuple of the subtraction along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// use std::u32;\n+        ///\n+        /// assert_eq!(5u32.overflowing_sub(2), (3, false));\n+        /// assert_eq!(0u32.overflowing_sub(1), (u32::MAX, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+            unsafe {\n+                let (a, b) = $sub_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        /// Calculates the multiplication of `self` and `rhs`.\n+        ///\n+        /// Returns a tuple of the multiplication along with a boolean\n+        /// indicating whether an arithmetic overflow would occur. If an\n+        /// overflow would have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n+        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+            unsafe {\n+                let (a, b) = $mul_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        /// Calculates the divisor when `self` is divided by `rhs`.\n+        ///\n+        /// Returns a tuple of the divisor along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. Note that for unsigned\n+        /// integers overflow never occurs, so the second value is always\n+        /// `false`.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(5u32.overflowing_div(2), (2, false));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+            (self / rhs, false)\n+        }\n+\n+        /// Calculates the remainder when `self` is divided by `rhs`.\n+        ///\n+        /// Returns a tuple of the remainder after dividing along with a boolean\n+        /// indicating whether an arithmetic overflow would occur. Note that for\n+        /// unsigned integers overflow never occurs, so the second value is\n+        /// always `false`.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(5u32.overflowing_rem(2), (1, false));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+            (self % rhs, false)\n+        }\n+\n+        /// Negates self in an overflowing fashion.\n+        ///\n+        /// Returns `!self + 1` using wrapping operations to return the value\n+        /// that represents the negation of this unsigned value. Note that for\n+        /// positive unsigned values overflow always occurs, but negating 0 does\n+        /// not overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(0u32.overflowing_neg(), (0, false));\n+        /// assert_eq!(2u32.overflowing_neg(), (-2i32 as u32, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_neg(self) -> (Self, bool) {\n+            ((!self).wrapping_add(1), self != 0)\n+        }\n+\n+        /// Shifts self left by `rhs` bits.\n+        ///\n+        /// Returns a tuple of the shifted version of self along with a boolean\n+        /// indicating whether the shift value was larger than or equal to the\n+        /// number of bits. If the shift value is too large, then value is\n+        /// masked (N-1) where N is the number of bits, and this value is then\n+        /// used to perform the shift.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(0x10u32.overflowing_shl(4), (0x100, false));\n+        /// assert_eq!(0x10u32.overflowing_shl(36), (0x100, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Shifts self right by `rhs` bits.\n+        ///\n+        /// Returns a tuple of the shifted version of self along with a boolean\n+        /// indicating whether the shift value was larger than or equal to the\n+        /// number of bits. If the shift value is too large, then value is\n+        /// masked (N-1) where N is the number of bits, and this value is then\n+        /// used to perform the shift.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(wrapping)]\n+        ///\n+        /// assert_eq!(0x10u32.overflowing_shr(4), (0x1, false));\n+        /// assert_eq!(0x10u32.overflowing_shr(36), (0x1, true));\n+        /// ```\n+        #[inline]\n+        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n+        }\n+\n         /// Raises self to the power of `exp`, using exponentiation by squaring.\n         ///\n         /// # Examples"}]}