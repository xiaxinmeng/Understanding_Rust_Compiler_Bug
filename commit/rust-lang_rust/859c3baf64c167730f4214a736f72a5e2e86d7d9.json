{"sha": "859c3baf64c167730f4214a736f72a5e2e86d7d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OWMzYmFmNjRjMTY3NzMwZjQyMTRhNzM2ZjcyYTVlMmU4NmQ3ZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-28T11:51:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-28T11:51:32Z"}, "message": "auto merge of #10519 : nikomatsakis/rust/issue-8624-borrowck-overly-permissive, r=pnkfelix\n\nSee #8624 for details.\r\n\r\nr? @pnkfelix", "tree": {"sha": "0eb984505c08f758bd8623bbb93cd91977eff03f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0eb984505c08f758bd8623bbb93cd91977eff03f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/859c3baf64c167730f4214a736f72a5e2e86d7d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/859c3baf64c167730f4214a736f72a5e2e86d7d9", "html_url": "https://github.com/rust-lang/rust/commit/859c3baf64c167730f4214a736f72a5e2e86d7d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/859c3baf64c167730f4214a736f72a5e2e86d7d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42ea44ba27cf16a9e534dbcbe663e0e16c5f03ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/42ea44ba27cf16a9e534dbcbe663e0e16c5f03ce", "html_url": "https://github.com/rust-lang/rust/commit/42ea44ba27cf16a9e534dbcbe663e0e16c5f03ce"}, {"sha": "09e12fa553efc933cb69d112f8f5c461c2b91492", "url": "https://api.github.com/repos/rust-lang/rust/commits/09e12fa553efc933cb69d112f8f5c461c2b91492", "html_url": "https://github.com/rust-lang/rust/commit/09e12fa553efc933cb69d112f8f5c461c2b91492"}], "stats": {"total": 737, "additions": 583, "deletions": 154}, "files": [{"sha": "3507201b839a905e62b17d03fb555bec883b325d", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -225,8 +225,9 @@ impl<T> Deque<T> for DList<T> {\n     /// Provide a mutable reference to the back element, or None if the list is empty\n     #[inline]\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        let mut tmp = self.list_tail.resolve(); // FIXME: #3511: shouldn't need variable\n-        tmp.as_mut().map(|tail| &mut tail.value)\n+        let tmp: Option<&'a mut Node<T>> =\n+            self.list_tail.resolve(); // FIXME: #3511: shouldn't need variable\n+        tmp.map(|tail| &mut tail.value)\n     }\n \n     /// Add an element first in the list"}, {"sha": "5580ca32bf90398d8c67d93a05011ac76fd8eb8c", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 108, "deletions": 47, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -198,7 +198,28 @@ impl<T> RingBuf<T> {\n \n     /// Front-to-back iterator which returns mutable values.\n     pub fn mut_iter<'a>(&'a mut self) -> RingBufMutIterator<'a, T> {\n-        RingBufMutIterator{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts}\n+        let start_index = raw_index(self.lo, self.elts.len(), 0);\n+        let end_index = raw_index(self.lo, self.elts.len(), self.nelts);\n+\n+        // Divide up the array\n+        if end_index <= start_index {\n+            // Items to iterate goes from:\n+            //    start_index to self.elts.len()\n+            // and then\n+            //    0 to end_index\n+            let (temp, remaining1) = self.elts.mut_split(start_index);\n+            let (remaining2, _) = temp.mut_split(end_index);\n+            RingBufMutIterator { remaining1: remaining1,\n+                                 remaining2: remaining2,\n+                                 nelts: self.nelts }\n+        } else {\n+            // Items to iterate goes from start_index to end_index:\n+            let (empty, elts) = self.elts.mut_split(0);\n+            let remaining1 = elts.mut_slice(start_index, end_index);\n+            RingBufMutIterator { remaining1: remaining1,\n+                                 remaining2: empty,\n+                                 nelts: self.nelts }\n+        }\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n@@ -207,54 +228,43 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-macro_rules! iterator {\n-    (impl $name:ident -> $elem:ty, $getter:ident) => {\n-        impl<'self, T> Iterator<$elem> for $name<'self, T> {\n-            #[inline]\n-            fn next(&mut self) -> Option<$elem> {\n-                if self.index == self.rindex {\n-                    return None;\n-                }\n-                let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n-                self.index += 1;\n-                Some(self.elts[raw_index] . $getter ())\n-            }\n+/// RingBuf iterator\n+pub struct RingBufIterator<'self, T> {\n+    priv lo: uint,\n+    priv index: uint,\n+    priv rindex: uint,\n+    priv elts: &'self [Option<T>],\n+}\n \n-            #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                let len = self.rindex - self.index;\n-                (len, Some(len))\n-            }\n+impl<'self, T> Iterator<&'self T> for RingBufIterator<'self, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self T> {\n+        if self.index == self.rindex {\n+            return None;\n         }\n+        let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n+        self.index += 1;\n+        Some(self.elts[raw_index].get_ref())\n     }\n-}\n \n-macro_rules! iterator_rev {\n-    (impl $name:ident -> $elem:ty, $getter:ident) => {\n-        impl<'self, T> DoubleEndedIterator<$elem> for $name<'self, T> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$elem> {\n-                if self.index == self.rindex {\n-                    return None;\n-                }\n-                self.rindex -= 1;\n-                let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n-                Some(self.elts[raw_index] . $getter ())\n-            }\n-        }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let len = self.rindex - self.index;\n+        (len, Some(len))\n     }\n }\n \n-\n-/// RingBuf iterator\n-pub struct RingBufIterator<'self, T> {\n-    priv lo: uint,\n-    priv index: uint,\n-    priv rindex: uint,\n-    priv elts: &'self [Option<T>],\n+impl<'self, T> DoubleEndedIterator<&'self T> for RingBufIterator<'self, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'self T> {\n+        if self.index == self.rindex {\n+            return None;\n+        }\n+        self.rindex -= 1;\n+        let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n+        Some(self.elts[raw_index].get_ref())\n+    }\n }\n-iterator!{impl RingBufIterator -> &'self T, get_ref}\n-iterator_rev!{impl RingBufIterator -> &'self T, get_ref}\n \n impl<'self, T> ExactSize<&'self T> for RingBufIterator<'self, T> {}\n \n@@ -275,13 +285,49 @@ impl<'self, T> RandomAccessIterator<&'self T> for RingBufIterator<'self, T> {\n \n /// RingBuf mutable iterator\n pub struct RingBufMutIterator<'self, T> {\n-    priv lo: uint,\n-    priv index: uint,\n-    priv rindex: uint,\n-    priv elts: &'self mut [Option<T>],\n+    priv remaining1: &'self mut [Option<T>],\n+    priv remaining2: &'self mut [Option<T>],\n+    priv nelts: uint,\n+}\n+\n+impl<'self, T> Iterator<&'self mut T> for RingBufMutIterator<'self, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self mut T> {\n+        if self.nelts == 0 {\n+            return None;\n+        }\n+        let r = if self.remaining1.len() > 0 {\n+            &mut self.remaining1\n+        } else {\n+            assert!(self.remaining2.len() > 0);\n+            &mut self.remaining2\n+        };\n+        self.nelts -= 1;\n+        Some(r.mut_shift_ref().get_mut_ref())\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.nelts, Some(self.nelts))\n+    }\n+}\n+\n+impl<'self, T> DoubleEndedIterator<&'self mut T> for RingBufMutIterator<'self, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'self mut T> {\n+        if self.nelts == 0 {\n+            return None;\n+        }\n+        let r = if self.remaining2.len() > 0 {\n+            &mut self.remaining2\n+        } else {\n+            assert!(self.remaining1.len() > 0);\n+            &mut self.remaining1\n+        };\n+        self.nelts -= 1;\n+        Some(r.mut_pop_ref().get_mut_ref())\n+    }\n }\n-iterator!{impl RingBufMutIterator -> &'self mut T, get_mut_ref}\n-iterator_rev!{impl RingBufMutIterator -> &'self mut T, get_mut_ref}\n \n impl<'self, T> ExactSize<&'self mut T> for RingBufMutIterator<'self, T> {}\n \n@@ -667,6 +713,21 @@ mod tests {\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n     }\n \n+    #[test]\n+    fn test_mut_rev_iter_wrap() {\n+        let mut d = RingBuf::with_capacity(3);\n+        assert!(d.mut_rev_iter().next().is_none());\n+\n+        d.push_back(1);\n+        d.push_back(2);\n+        d.push_back(3);\n+        assert_eq!(d.pop_front(), Some(1));\n+        d.push_back(4);\n+\n+        assert_eq!(d.mut_rev_iter().map(|x| *x).collect::<~[int]>(),\n+                   ~[4, 3, 2]);\n+    }\n+\n     #[test]\n     fn test_mut_iter() {\n         let mut d = RingBuf::new();"}, {"sha": "7cc1395a9e5d6906edbfaacf72bed647e24656ff", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 142, "deletions": 76, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -233,7 +233,7 @@ the lifetime of the value being borrowed. This pass is also\n responsible for inserting root annotations to keep managed values\n alive and for dynamically freezing `@mut` boxes.\n \n-3. `RESTRICTIONS(LV, ACTIONS) = RS`: This pass checks and computes the\n+3. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n restrictions to maintain memory safety. These are the restrictions\n that will go into the final loan. We'll discuss in more detail below.\n \n@@ -451,17 +451,17 @@ the scope `LT`.\n \n The final rules govern the computation of *restrictions*, meaning that\n we compute the set of actions that will be illegal for the life of the\n-loan. The predicate is written `RESTRICTIONS(LV, ACTIONS) =\n+loan. The predicate is written `RESTRICTIONS(LV, LT, ACTIONS) =\n RESTRICTION*`, which can be read \"in order to prevent `ACTIONS` from\n occuring on `LV`, the restrictions `RESTRICTION*` must be respected\n for the lifetime of the loan\".\n \n Note that there is an initial set of restrictions: these restrictions\n are computed based on the kind of borrow:\n \n-    &mut LV =>   RESTRICTIONS(LV, MUTATE|CLAIM|FREEZE)\n-    &LV =>       RESTRICTIONS(LV, MUTATE|CLAIM)\n-    &const LV => RESTRICTIONS(LV, [])\n+    &mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n+    &LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n+    &const LV => RESTRICTIONS(LV, LT, [])\n \n The reasoning here is that a mutable borrow must be the only writer,\n therefore it prevents other writes (`MUTATE`), mutable borrows\n@@ -474,7 +474,7 @@ moved out from under it, so no actions are forbidden.\n \n The simplest case is a borrow of a local variable `X`:\n \n-    RESTRICTIONS(X, ACTIONS) = (X, ACTIONS)            // R-Variable\n+    RESTRICTIONS(X, LT, ACTIONS) = (X, ACTIONS)            // R-Variable\n \n In such cases we just record the actions that are not permitted.\n \n@@ -483,8 +483,8 @@ In such cases we just record the actions that are not permitted.\n Restricting a field is the same as restricting the owner of that\n field:\n \n-    RESTRICTIONS(LV.f, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n-      RESTRICTIONS(LV, ACTIONS) = RS\n+    RESTRICTIONS(LV.f, LT, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n+      RESTRICTIONS(LV, LT, ACTIONS) = RS\n \n The reasoning here is as follows. If the field must not be mutated,\n then you must not mutate the owner of the field either, since that\n@@ -504,9 +504,9 @@ must prevent the owned pointer `LV` from being mutated, which means\n that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n on `LV`:\n \n-    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n+    RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n       TYPE(LV) = ~Ty\n-      RESTRICTIONS(LV, ACTIONS|MUTATE|CLAIM) = RS\n+      RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n \n ### Restrictions for loans of immutable managed/borrowed pointees\n \n@@ -519,7 +519,7 @@ restricting that path. Therefore, the rule for `&Ty` and `@Ty`\n pointers always returns an empty set of restrictions, and it only\n permits restricting `MUTATE` and `CLAIM` actions:\n \n-    RESTRICTIONS(*LV, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n+    RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n       TYPE(LV) = &Ty or @Ty\n       ACTIONS subset of [MUTATE, CLAIM]\n \n@@ -546,7 +546,7 @@ Because moves from a `&const` or `@const` lvalue are never legal, it\n is not necessary to add any restrictions at all to the final\n result.\n \n-    RESTRICTIONS(*LV, []) = []                         // R-Deref-Freeze-Borrowed\n+    RESTRICTIONS(*LV, LT, []) = []                         // R-Deref-Freeze-Borrowed\n       TYPE(LV) = &const Ty or @const Ty\n \n ### Restrictions for loans of mutable borrowed pointees\n@@ -581,91 +581,157 @@ an `&mut` pointee from being mutated, claimed, or frozen, as occurs\n whenever the `&mut` pointee `*LV` is reborrowed as mutable or\n immutable:\n \n-    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed-1\n-      TYPE(LV) = &mut Ty\n-      RESTRICTIONS(LV, MUTATE|CLAIM|ALIAS) = RS\n-\n-The main interesting part of the rule is the final line, which\n-requires that the `&mut` *pointer* `LV` be restricted from being\n-mutated, claimed, or aliased. The goal of these restrictions is to\n-ensure that, not considering the pointer that will result from this\n-borrow, `LV` remains the *sole pointer with mutable access* to `*LV`.\n-\n-Restrictions against mutations and claims are necessary because if the\n-pointer in `LV` were to be somehow copied or moved to a different\n-location, then the restriction issued for `*LV` would not apply to the\n-new location. Note that because `&mut` values are non-copyable, a\n-simple attempt to move the base pointer will fail due to the\n-(implicit) restriction against moves:\n-\n-    // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n-    fn foo(t0: &mut int) {\n-        let p: &int = &*t0; // Freezes `*t0`\n-        let t1 = t0;        //~ ERROR cannot move out of `t0`\n-        *t1 = 22;\n-    }\n-\n-However, the additional restrictions against mutation mean that even a\n-clever attempt to use a swap to circumvent the type system will\n-encounter an error:\n-\n-    // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n-    fn foo<'a>(mut t0: &'a mut int,\n-               mut t1: &'a mut int) {\n-        let p: &int = &*t0;     // Freezes `*t0`\n-        swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n-        *t1 = 22;\n-    }\n-\n-The restriction against *aliasing* (and, in turn, freezing) is\n-necessary because, if an alias were of `LV` were to be produced, then\n-`LV` would no longer be the sole path to access the `&mut`\n-pointee. Since we are only issuing restrictions against `*LV`, these\n-other aliases would be unrestricted, and the result would be\n-unsound. For example:\n+    RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed-1\n+      TYPE(LV) = &LT' mut Ty\n+      LT <= LT'                                            // (1)\n+      RESTRICTIONS(LV, LT, MUTATE|CLAIM|ALIAS) = RS        // (2)\n+\n+There are two interesting parts to this rule:\n+\n+1. The lifetime of the loan (`LT`) cannot exceed the lifetime of the\n+   `&mut` pointer (`LT'`). The reason for this is that the `&mut`\n+   pointer is guaranteed to be the only legal way to mutate its\n+   pointee -- but only for the lifetime `LT'`.  After that lifetime,\n+   the loan on the pointee expires and hence the data may be modified\n+   by its owner again. This implies that we are only able to guarantee that\n+   the pointee will not be modified or aliased for a maximum of `LT'`.\n+\n+   Here is a concrete example of a bug this rule prevents:\n+\n+       // Test region-reborrow-from-shorter-mut-ref.rs:\n+       fn copy_pointer<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n+           &mut **p // ERROR due to clause (1)\n+       }\n+       fn main() {\n+           let mut x = 1;\n+           let mut y = &mut x; // <-'b-----------------------------+\n+           //      +-'a--------------------+                       |\n+           //      v                       v                       |\n+           let z = copy_borrowed_ptr(&mut y); // y is lent         |\n+           *y += 1; // Here y==z, so both should not be usable...  |\n+           *z += 1; // ...and yet they would be, but for clause 1. |\n+       } <---------------------------------------------------------+\n+\n+2. The final line recursively requires that the `&mut` *pointer* `LV`\n+   be restricted from being mutated, claimed, or aliased (not just the\n+   pointee). The goal of these restrictions is to ensure that, not\n+   considering the pointer that will result from this borrow, `LV`\n+   remains the *sole pointer with mutable access* to `*LV`.\n+\n+   Restrictions against claims are necessary because if the pointer in\n+   `LV` were to be somehow copied or moved to a different location,\n+   then the restriction issued for `*LV` would not apply to the new\n+   location. Note that because `&mut` values are non-copyable, a\n+   simple attempt to move the base pointer will fail due to the\n+   (implicit) restriction against moves:\n+\n+       // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n+       fn foo(t0: &mut int) {\n+           let p: &int = &*t0; // Freezes `*t0`\n+           let t1 = t0;        //~ ERROR cannot move out of `t0`\n+           *t1 = 22;\n+       }\n+\n+   However, the additional restrictions against claims mean that even\n+   a clever attempt to use a swap to circumvent the type system will\n+   encounter an error:\n+\n+       // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n+       fn foo<'a>(mut t0: &'a mut int,\n+                  mut t1: &'a mut int) {\n+           let p: &int = &*t0;     // Freezes `*t0`\n+           swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n+           *t1 = 22;\n+       }\n+\n+   The restriction against *aliasing* (and, in turn, freezing) is\n+   necessary because, if an alias were of `LV` were to be produced,\n+   then `LV` would no longer be the sole path to access the `&mut`\n+   pointee. Since we are only issuing restrictions against `*LV`,\n+   these other aliases would be unrestricted, and the result would be\n+   unsound. For example:\n \n     // src/test/compile-fail/borrowck-alias-mut-base-ptr.rs\n     fn foo(t0: &mut int) {\n         let p: &int = &*t0; // Freezes `*t0`\n         let q: &const &mut int = &const t0; //~ ERROR cannot borrow `t0`\n-        **q = 22; // (*)\n-    }\n-\n-Note that the current rules also report an error at the assignment in\n-`(*)`, because we only permit `&mut` poiners to be assigned if they\n-are located in a non-aliasable location. However, I do not believe\n-this restriction is strictly necessary. It was added, I believe, to\n-discourage `&mut` from being placed in aliasable locations in the\n-first place. One (desirable) side-effect of restricting aliasing on\n-`LV` is that borrowing an `&mut` pointee found inside an aliasable\n-pointee yields an error:\n-\n-    // src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc:\n-    fn foo(t0: & &mut int) {\n-        let t1 = t0;\n-        let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&` pointer\n-        **t1 = 22; // (*)\n+        **q = 22;\n     }\n \n-Here at the line `(*)` you will also see the error I referred to\n-above, which I do not believe is strictly necessary.\n+The current rules could use some correction:\n+\n+1. Issue #10520. Now that the swap operator has been removed, I do not\n+   believe the restriction against mutating `LV` is needed, and in\n+   fact it prevents some useful patterns. For example, the following\n+   function will fail to compile:\n+\n+       fn mut_shift_ref<'a,T>(x: &mut &'a mut [T]) -> &'a mut T {\n+           // `mut_split` will restrict mutation against *x:\n+           let (head, tail) = (*x).mut_split(1);\n+\n+           // Hence mutating `*x` yields an error here:\n+           *x = tail;\n+           &mut head[0]\n+       }\n+\n+   Note that this function -- which adjusts the slice `*x` in place so\n+   that it no longer contains the head element and then returns a\n+   pointer to that element separately -- is perfectly valid. It is\n+   currently implemented using unsafe code. I believe that now that\n+   the swap operator is removed from the language, we could liberalize\n+   the rules and make this function be accepted normally. The idea\n+   would be to have the assignment to `*x` kill the loans of `*x` and\n+   its subpaths -- after all, those subpaths are no longer accessible\n+   through `*x`, since it has been overwritten with a new value. Thus\n+   those subpaths are only accessible through prior existing borrows\n+   of `*x`, if any. The danger of the *swap* operator was that it\n+   allowed `*x` to be mutated without making the subpaths of `*x`\n+   inaccessible: worse, they became accessible through a new path (I\n+   suppose that we could support swap, too, if needed, by moving the\n+   loans over to the new path).\n+\n+   Note: the `swap()` function doesn't pose the same danger as the\n+   swap operator because it requires taking `&mut` refs to invoke it.\n+\n+2. Issue #9629. The current rules correctly prohibit `&mut` pointees\n+   from being assigned unless they are in a unique location. However,\n+   we *also* prohibit `&mut` pointees from being frozen. This prevents\n+   compositional patterns, like this one:\n+\n+       struct BorrowedMap<'a> {\n+           map: &'a mut HashMap\n+       }\n+\n+   If we have a pointer `x:&BorrowedMap`, we can't freeze `x.map`,\n+   and hence can't call `find` etc on it. But that's silly, since\n+   fact that the `&mut` exists in frozen data implies that it\n+   will not be mutable by anyone. For example, this program nets an\n+   error:\n+\n+       fn main() {\n+           let a = &mut 2;\n+           let b = &a;\n+           *a += 1; // ERROR: cannot assign to `*a` because it is borrowed\n+       }\n+\n+   (Naturally `&mut` reborrows from an `&&mut` pointee should be illegal.)\n \n The second rule for `&mut` handles the case where we are not adding\n any restrictions (beyond the default of \"no move\"):\n \n-    RESTRICTIONS(*LV, []) = []                    // R-Deref-Mut-Borrowed-2\n+    RESTRICTIONS(*LV, LT, []) = []                    // R-Deref-Mut-Borrowed-2\n       TYPE(LV) = &mut Ty\n \n Moving from an `&mut` pointee is never legal, so no special\n-restrictions are needed.\n+restrictions are needed. This rule is used for `&const` borrows.\n \n ### Restrictions for loans of mutable managed pointees\n \n With `@mut` pointees, we don't make any static guarantees.  But as a\n convenience, we still register a restriction against `*LV`, because\n that way if we *can* find a simple static error, we will:\n \n-    RESTRICTIONS(*LV, ACTIONS) = [*LV, ACTIONS]   // R-Deref-Managed-Borrowed\n+    RESTRICTIONS(*LV, LT, ACTIONS) = [*LV, ACTIONS]   // R-Deref-Managed-Borrowed\n       TYPE(LV) = @mut Ty\n \n # Moves and initialization"}, {"sha": "8cfb47bd04dc98dd2c4a252448b9a92627282322", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This module implements the check that the lifetime of a borrow\n-//! does not exceed the lifetime of the value being borrowed.\n-\n+/*!\n+ * This module implements the check that the lifetime of a borrow\n+ * does not exceed the lifetime of the value being borrowed.\n+ */\n \n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n@@ -20,13 +21,15 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::{note_and_explain_region};\n \n+type R = Result<(),()>;\n+\n pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                           item_scope_id: ast::NodeId,\n                           root_scope_id: ast::NodeId,\n                           span: Span,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n-                          loan_mutbl: LoanMutability) {\n+                          loan_mutbl: LoanMutability) -> R {\n     debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n@@ -36,7 +39,7 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                                          loan_mutbl: loan_mutbl,\n                                          cmt_original: cmt,\n                                          root_scope_id: root_scope_id};\n-    ctxt.check(cmt, None);\n+    ctxt.check(cmt, None)\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -63,7 +66,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         self.bccx.tcx\n     }\n \n-    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::NodeId>) {\n+    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n \n         match cmt.cat {\n@@ -83,6 +86,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n             }\n \n             mc::cat_static_item => {\n+                Ok(())\n             }\n \n             mc::cat_deref(base, derefs, mc::gc_ptr(ptr_mutbl)) => {\n@@ -99,10 +103,11 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                 if !omit_root {\n                     // L-Deref-Managed-Imm-Compiler-Root\n                     // L-Deref-Managed-Mut-Compiler-Root\n-                    self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope);\n+                    self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope)\n                 } else {\n                     debug!(\"omitting root, base={}, base_scope={:?}\",\n                            base.repr(self.tcx()), base_scope);\n+                    Ok(())\n                 }\n             }\n \n@@ -120,7 +125,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                 // for one arm.  Therefore, we insert a cat_discr(),\n                 // basically a special kind of category that says \"if this\n                 // value must be dynamically rooted, root it for the scope\n-                // `match_id`.\n+                // `match_id`\".\n                 //\n                 // As an example, consider this scenario:\n                 //\n@@ -188,7 +193,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                   cmt_base: mc::cmt,\n                   derefs: uint,\n                   ptr_mutbl: ast::Mutability,\n-                  discr_scope: Option<ast::NodeId>) {\n+                  discr_scope: Option<ast::NodeId>) -> R {\n         debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, ptr_mutbl={:?}, \\\n                 discr_scope={:?})\",\n                cmt_deref.repr(self.tcx()),\n@@ -201,9 +206,8 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         // that we can root the value, dynamically.\n         let root_region = ty::ReScope(self.root_scope_id);\n         if !self.bccx.is_subregion_of(self.loan_region, root_region) {\n-            self.report_error(\n-                err_out_of_root_scope(root_region, self.loan_region));\n-            return;\n+            return Err(self.report_error(\n+                err_out_of_root_scope(root_region, self.loan_region)));\n         }\n \n         // Extract the scope id that indicates how long the rooting is required\n@@ -278,13 +282,16 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         self.bccx.root_map.insert(rm_key, root_info);\n \n         debug!(\"root_key: {:?} root_info: {:?}\", rm_key, root_info);\n+        Ok(())\n     }\n \n-    fn check_scope(&self, max_scope: ty::Region) {\n+    fn check_scope(&self, max_scope: ty::Region) -> R {\n         //! Reports an error if `loan_region` is larger than `valid_scope`\n \n         if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n-            self.report_error(err_out_of_scope(max_scope, self.loan_region));\n+            Err(self.report_error(err_out_of_scope(max_scope, self.loan_region)))\n+        } else {\n+            Ok(())\n         }\n     }\n "}, {"sha": "44a5f6fe49dff32b972d97cac2dac5c55c02085e", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -447,17 +447,22 @@ impl<'self> GatherLoanCtxt<'self> {\n \n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n-        lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n-                                     borrow_span, cmt, loan_region, req_mutbl);\n+        if lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n+                                        borrow_span, cmt, loan_region,\n+                                        req_mutbl).is_err() {\n+            return; // reported an error, no sense in reporting more.\n+        }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n-        check_mutability(self.bccx, borrow_span, cmt, req_mutbl);\n+        if check_mutability(self.bccx, borrow_span, cmt, req_mutbl).is_err() {\n+            return; // reported an error, no sense in reporting more.\n+        }\n \n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n             self.bccx, borrow_span,\n-            cmt, self.restriction_set(req_mutbl));\n+            cmt, loan_region, self.restriction_set(req_mutbl));\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -554,25 +559,29 @@ impl<'self> GatherLoanCtxt<'self> {\n         fn check_mutability(bccx: &BorrowckCtxt,\n                             borrow_span: Span,\n                             cmt: mc::cmt,\n-                            req_mutbl: LoanMutability) {\n+                            req_mutbl: LoanMutability) -> Result<(),()> {\n             //! Implements the M-* rules in doc.rs.\n \n             match req_mutbl {\n                 ConstMutability => {\n                     // Data of any mutability can be lent as const.\n+                    Ok(())\n                 }\n \n                 ImmutableMutability => {\n                     // both imm and mut data can be lent as imm;\n                     // for mutable data, this is a freeze\n+                    Ok(())\n                 }\n \n                 MutableMutability => {\n                     // Only mutable data can be lent as mutable.\n                     if !cmt.mutbl.is_mutable() {\n-                        bccx.report(BckError {span: borrow_span,\n-                                              cmt: cmt,\n-                                              code: err_mutbl(req_mutbl)});\n+                        Err(bccx.report(BckError {span: borrow_span,\n+                                                  cmt: cmt,\n+                                                  code: err_mutbl(req_mutbl)}))\n+                    } else {\n+                        Ok(())\n                     }\n                 }\n             }"}, {"sha": "d4fe23e57b47dfa831384efb6d638b136e6dfafa", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Computes the restrictions that result from a borrow.\n-\n+/*!\n+ * Computes the restrictions that result from a borrow.\n+ */\n \n use std::vec;\n use middle::borrowck::*;\n@@ -26,11 +27,13 @@ pub enum RestrictionResult {\n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n                             span: Span,\n                             cmt: mc::cmt,\n+                            loan_region: ty::Region,\n                             restr: RestrictionSet) -> RestrictionResult {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n         span: span,\n-        cmt_original: cmt\n+        cmt_original: cmt,\n+        loan_region: loan_region,\n     };\n \n     ctxt.restrict(cmt, restr)\n@@ -42,7 +45,8 @@ pub fn compute_restrictions(bccx: &BorrowckCtxt,\n struct RestrictionsContext<'self> {\n     bccx: &'self BorrowckCtxt,\n     span: Span,\n-    cmt_original: mc::cmt\n+    cmt_original: mc::cmt,\n+    loan_region: ty::Region,\n }\n \n impl<'self> RestrictionsContext<'self> {\n@@ -169,12 +173,22 @@ impl<'self> RestrictionsContext<'self> {\n                 }\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, _)) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, lt)) => {\n                 // Because an `&mut` pointer does not inherit its\n                 // mutability, we can only prevent mutation or prevent\n                 // freezing if it is not aliased. Therefore, in such\n                 // cases we restrict aliasing on `cmt_base`.\n                 if restrictions != RESTR_EMPTY {\n+                    if !self.bccx.is_subregion_of(self.loan_region, lt) {\n+                        self.bccx.report(\n+                            BckError {\n+                                span: self.span,\n+                                cmt: cmt_base,\n+                                code: err_mut_pointer_too_short(\n+                                    self.loan_region, lt, restrictions)});\n+                        return Safe;\n+                    }\n+\n                     // R-Deref-Mut-Borrowed-1\n                     let result = self.restrict(\n                         cmt_base,"}, {"sha": "51002889b2f65c26cb182d3a74f9443d9f169c1f", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -443,7 +443,8 @@ pub enum bckerr_code {\n     err_mutbl(LoanMutability),\n     err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n-    err_freeze_aliasable_const\n+    err_freeze_aliasable_const,\n+    err_mut_pointer_too_short(ty::Region, ty::Region, RestrictionSet), // loan, ptr\n }\n \n // Combination of an error code and the categorization of the expression\n@@ -669,6 +670,22 @@ impl BorrowckCtxt {\n                 // supposed to be going away.\n                 format!(\"unsafe borrow of aliasable, const value\")\n             }\n+            err_mut_pointer_too_short(_, _, r) => {\n+                let descr = match opt_loan_path(err.cmt) {\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                    None => ~\"`&mut` pointer\"\n+                };\n+\n+                let tag = if r.intersects(RESTR_ALIAS) {\n+                    \"its contents are unique\"\n+                } else {\n+                    \"its contents are not otherwise mutable\"\n+                };\n+\n+                format!(\"lifetime of {} is too short to guarantee {} \\\n+                        so they can be safely reborrowed\",\n+                        descr, tag)\n+            }\n         }\n     }\n \n@@ -742,7 +759,24 @@ impl BorrowckCtxt {\n                     \"...but borrowed value is only valid for \",\n                     super_scope,\n                     \"\");\n-          }\n+            }\n+\n+            err_mut_pointer_too_short(loan_scope, ptr_scope, _) => {\n+                let descr = match opt_loan_path(err.cmt) {\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                    None => ~\"`&mut` pointer\"\n+                };\n+                note_and_explain_region(\n+                    self.tcx,\n+                    format!(\"{} would have to be valid for \", descr),\n+                    loan_scope,\n+                    \"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    format!(\"...but {} is only valid for \", descr),\n+                    ptr_scope,\n+                    \"\");\n+            }\n         }\n     }\n "}, {"sha": "e76251e8a1e72b79211087535e10c2d7ad6c376c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -975,6 +975,40 @@ pub trait ImmutableVector<'self, T> {\n      * foreign interop.\n      */\n     fn as_imm_buf<U>(&self, f: |*T, uint| -> U) -> U;\n+\n+    /**\n+     * Returns a mutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```\n+     *     let head = &self[0];\n+     *     *self = self.slice_from(1);\n+     *     head\n+     * ```\n+     *\n+     * Fails if slice is empty.\n+     */\n+    fn shift_ref(&mut self) -> &'self T;\n+\n+    /**\n+     * Returns a mutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```\n+     *     let tail = &self[self.len() - 1];\n+     *     *self = self.slice_to(self.len() - 1);\n+     *     tail\n+     * ```\n+     *\n+     * Fails if slice is empty.\n+     */\n+    fn pop_ref(&mut self) -> &'self T;\n }\n \n impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n@@ -1146,6 +1180,20 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         let s = self.repr();\n         f(s.data, s.len)\n     }\n+\n+    fn shift_ref(&mut self) -> &'self T {\n+        unsafe {\n+            let s: &mut Slice<T> = cast::transmute(self);\n+            &*raw::shift_ptr(s)\n+        }\n+    }\n+\n+    fn pop_ref(&mut self) -> &'self T {\n+        unsafe {\n+            let s: &mut Slice<T> = cast::transmute(self);\n+            &*raw::pop_ptr(s)\n+        }\n+    }\n }\n \n /// Extension methods for vectors contain `Eq` elements.\n@@ -1864,23 +1912,61 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n pub trait MutableVector<'self, T> {\n     /// Return a slice that points into another slice.\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T];\n+\n     /**\n      * Returns a slice of self from `start` to the end of the vec.\n      *\n      * Fails when `start` points outside the bounds of self.\n      */\n     fn mut_slice_from(self, start: uint) -> &'self mut [T];\n+\n     /**\n      * Returns a slice of self from the start of the vec to `end`.\n      *\n      * Fails when `end` points outside the bounds of self.\n      */\n     fn mut_slice_to(self, end: uint) -> &'self mut [T];\n+\n     /// Returns an iterator that allows modifying each value\n     fn mut_iter(self) -> VecMutIterator<'self, T>;\n+\n     /// Returns a reversed iterator that allows modifying each value\n     fn mut_rev_iter(self) -> MutRevIterator<'self, T>;\n \n+    /**\n+     * Returns a mutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```\n+     *     let head = &mut self[0];\n+     *     *self = self.mut_slice_from(1);\n+     *     head\n+     * ```\n+     *\n+     * Fails if slice is empty.\n+     */\n+    fn mut_shift_ref(&mut self) -> &'self mut T;\n+\n+    /**\n+     * Returns a mutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```\n+     *     let tail = &mut self[self.len() - 1];\n+     *     *self = self.mut_slice_to(self.len() - 1);\n+     *     tail\n+     * ```\n+     *\n+     * Fails if slice is empty.\n+     */\n+    fn mut_pop_ref(&mut self) -> &'self mut T;\n+\n     /**\n      * Swaps two elements in a vector\n      *\n@@ -1983,6 +2069,20 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         self.mut_iter().invert()\n     }\n \n+    fn mut_shift_ref(&mut self) -> &'self mut T {\n+        unsafe {\n+            let s: &mut Slice<T> = cast::transmute(self);\n+            cast::transmute_mut(&*raw::shift_ptr(s))\n+        }\n+    }\n+\n+    fn mut_pop_ref(&mut self) -> &'self mut T {\n+        unsafe {\n+            let s: &mut Slice<T> = cast::transmute(self);\n+            cast::transmute_mut(&*raw::pop_ptr(s))\n+        }\n+    }\n+\n     fn swap(self, a: uint, b: uint) {\n         unsafe {\n             // Can't take two mutable loans from one vector, so instead just cast\n@@ -2194,6 +2294,31 @@ pub mod raw {\n             })\n         })\n     }\n+\n+    /**\n+     * Returns a pointer to first element in slice and adjusts\n+     * slice so it no longer contains that element. Fails if\n+     * slice is empty. O(1).\n+     */\n+    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {\n+        if slice.len == 0 { fail!(\"shift on empty slice\"); }\n+        let head: *T = slice.data;\n+        slice.data = ptr::offset(slice.data, 1);\n+        slice.len -= 1;\n+        head\n+    }\n+\n+    /**\n+     * Returns a pointer to last element in slice and adjusts\n+     * slice so it no longer contains that element. Fails if\n+     * slice is empty. O(1).\n+     */\n+    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {\n+        if slice.len == 0 { fail!(\"pop on empty slice\"); }\n+        let tail: *T = ptr::offset(slice.data, (slice.len - 1) as int);\n+        slice.len -= 1;\n+        tail\n+    }\n }\n \n /// Operations on `[u8]`\n@@ -3827,6 +3952,75 @@ mod tests {\n         assert!(!empty.ends_with(bytes!(\"foo\")));\n         assert!(bytes!(\"foobar\").ends_with(empty));\n     }\n+\n+    #[test]\n+    fn test_shift_ref() {\n+        let mut x: &[int] = [1, 2, 3, 4, 5];\n+        let h = x.shift_ref();\n+        assert_eq!(*h, 1);\n+        assert_eq!(x.len(), 4);\n+        assert_eq!(x[0], 2);\n+        assert_eq!(x[3], 5);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_shift_ref_empty() {\n+        let mut x: &[int] = [];\n+        x.shift_ref();\n+    }\n+\n+    #[test]\n+    fn test_pop_ref() {\n+        let mut x: &[int] = [1, 2, 3, 4, 5];\n+        let h = x.pop_ref();\n+        assert_eq!(*h, 5);\n+        assert_eq!(x.len(), 4);\n+        assert_eq!(x[0], 1);\n+        assert_eq!(x[3], 4);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_pop_ref_empty() {\n+        let mut x: &[int] = [];\n+        x.pop_ref();\n+    }\n+\n+\n+    #[test]\n+    fn test_mut_shift_ref() {\n+        let mut x: &mut [int] = [1, 2, 3, 4, 5];\n+        let h = x.mut_shift_ref();\n+        assert_eq!(*h, 1);\n+        assert_eq!(x.len(), 4);\n+        assert_eq!(x[0], 2);\n+        assert_eq!(x[3], 5);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_mut_shift_ref_empty() {\n+        let mut x: &mut [int] = [];\n+        x.mut_shift_ref();\n+    }\n+\n+    #[test]\n+    fn test_mut_pop_ref() {\n+        let mut x: &mut [int] = [1, 2, 3, 4, 5];\n+        let h = x.mut_pop_ref();\n+        assert_eq!(*h, 5);\n+        assert_eq!(x.len(), 4);\n+        assert_eq!(x[0], 1);\n+        assert_eq!(x[3], 4);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_mut_pop_ref_empty() {\n+        let mut x: &mut [int] = [];\n+        x.mut_pop_ref();\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "d3e0740a0fefe6bc4eecd5058256403a9f7e2ed1", "filename": "src/test/compile-fail/regions-reborrow-from-shorter-mut-ref-mut-ref.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #8624. Test for reborrowing with 3 levels, not just two.\n+\n+fn copy_borrowed_ptr<'a, 'b, 'c>(p: &'a mut &'b mut &'c mut int) -> &'b mut int {\n+    &mut ***p //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn main() {\n+}"}, {"sha": "385bc11d1a983d233c5303b70d904fe04ce8e6d0", "filename": "src/test/compile-fail/regions-reborrow-from-shorter-mut-ref.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859c3baf64c167730f4214a736f72a5e2e86d7d9/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs?ref=859c3baf64c167730f4214a736f72a5e2e86d7d9", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #8624. Tests that reborrowing the contents of an `&'b mut`\n+// pointer which is backed by another `&'a mut` can only be done\n+// for `'a` (which must be a sublifetime of `'b`).\n+\n+fn copy_borrowed_ptr<'a, 'b>(p: &'a mut &'b mut int) -> &'b mut int {\n+    &mut **p //~ ERROR lifetime of `p` is too short\n+}\n+\n+fn main() {\n+    let mut x = 1;\n+    let mut y = &mut x;\n+    let z = copy_borrowed_ptr(&mut y);\n+    *y += 1;\n+    *z += 1;\n+}"}]}