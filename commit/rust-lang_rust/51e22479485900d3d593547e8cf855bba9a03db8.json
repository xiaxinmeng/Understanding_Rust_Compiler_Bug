{"sha": "51e22479485900d3d593547e8cf855bba9a03db8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZTIyNDc5NDg1OTAwZDNkNTkzNTQ3ZThjZjg1NWJiYTlhMDNkYjg=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-11-05T14:45:41Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-11-05T19:53:41Z"}, "message": "Abbreviate some stdout/stderr output in compiletest.\n\nThis is intended to prevent the spurious OOM error from\nrun-pass/rustc-rust-log.rs, by skipping the output in the middle when the\nsize is over 416 KB, so that the log output will not be overwhelmed.", "tree": {"sha": "447db1c87839f258a0ddc6cd69fe0117877b0957", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/447db1c87839f258a0ddc6cd69fe0117877b0957"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51e22479485900d3d593547e8cf855bba9a03db8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAln/bEUACgkQ/vbIBR0O\nATyDnQ/9Ex0ZpB2KhJDqZsYMWy31U7VqzrffJuQvDrZHjGUx+eOebuA94RjrRmuP\nMxCt/hZxl7Ymiedd1Bwpk9wpHbKtb11m839U6K0nveuO8OuAS1kvrcqdi6cyqyxI\nTf4bF07wPb9sxSqQn2vSheqlZA0SckpGaEKUBGKqMv8xqakl4EdLnbQGy5qzVFtv\nT4bnn/n0tiXJRbwJswrgMDtaIlrfIu7Xjcld+tdFMtj9xADVdgqFF38VAFCSwWX1\nJKrhWZ3Gvaj4zX/FFVIqnAT4G4SzhC4XPds7iLuYWXNKSd04uAWzhv1DGvEofkNw\n2DOBbg8CI3AVQf22Fm3F+dIvlS0hSVJgXfWNk3l5LyF4u/XhjxBUvC/7Yk6QorrE\nEttt385hXatYzTXMwpUl/eo3F8bgyh16G/j4sTwMUkyi7/Rou51X610+CsRHMUgh\n+MiqKSjJY6zddMCSwm8Hj2BgCi75AOzNyhfNAMd10umC8kK11UOnqd7TV85Q7q7l\ntQomVa5ezBjPx+baQp6CrLemTm5Q4aOC3lRaZ1PZUevw4X4Wg3/q8uf2nIhosbrY\neT/IycpH7ZBlm9z002TuIPNwyVU8SRkm4EoDIlEKk6IEB48q1TS8QLbELygH8B/x\nZnli5rxy17WrxFRlNM+eawu3C64hbvcdUx+pcPZXO/fyxLu02Bo=\n=qxbN\n-----END PGP SIGNATURE-----", "payload": "tree 447db1c87839f258a0ddc6cd69fe0117877b0957\nparent d517668a088715e932c373fb18dfffdc58831829\nauthor kennytm <kennytm@gmail.com> 1509893141 +0800\ncommitter kennytm <kennytm@gmail.com> 1509911621 +0800\n\nAbbreviate some stdout/stderr output in compiletest.\n\nThis is intended to prevent the spurious OOM error from\nrun-pass/rustc-rust-log.rs, by skipping the output in the middle when the\nsize is over 416 KB, so that the log output will not be overwhelmed.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51e22479485900d3d593547e8cf855bba9a03db8", "html_url": "https://github.com/rust-lang/rust/commit/51e22479485900d3d593547e8cf855bba9a03db8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51e22479485900d3d593547e8cf855bba9a03db8/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d517668a088715e932c373fb18dfffdc58831829", "url": "https://api.github.com/repos/rust-lang/rust/commits/d517668a088715e932c373fb18dfffdc58831829", "html_url": "https://github.com/rust-lang/rust/commit/d517668a088715e932c373fb18dfffdc58831829"}], "stats": {"total": 309, "additions": 302, "deletions": 7}, "files": [{"sha": "edd0ee8bd5ace2dffa2f261e9249dada5b05ddbb", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51e22479485900d3d593547e8cf855bba9a03db8/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/51e22479485900d3d593547e8cf855bba9a03db8/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=51e22479485900d3d593547e8cf855bba9a03db8", "patch": "@@ -347,7 +347,9 @@ dependencies = [\n  \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "d4d567e63c017748b2c606d02d50b0e2829e830a", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51e22479485900d3d593547e8cf855bba9a03db8/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/51e22479485900d3d593547e8cf855bba9a03db8/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=51e22479485900d3d593547e8cf855bba9a03db8", "patch": "@@ -11,3 +11,7 @@ getopts = \"0.2\"\n log = \"0.3\"\n rustc-serialize = \"0.3\"\n libc = \"0.2\"\n+\n+[target.'cfg(windows)'.dependencies]\n+miow = \"0.2\"\n+winapi = \"0.2\""}, {"sha": "9fb6a3f5e07539256d110bc58aced4641fa0578a", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51e22479485900d3d593547e8cf855bba9a03db8/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e22479485900d3d593547e8cf855bba9a03db8/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=51e22479485900d3d593547e8cf855bba9a03db8", "patch": "@@ -11,10 +11,11 @@\n #![crate_name = \"compiletest\"]\n \n #![feature(test)]\n+#![feature(slice_rotate)]\n \n #![deny(warnings)]\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+#[cfg(unix)]\n extern crate libc;\n extern crate test;\n extern crate getopts;\n@@ -47,6 +48,7 @@ pub mod runtest;\n pub mod common;\n pub mod errors;\n mod raise_fd_limit;\n+mod read2;\n \n fn main() {\n     env_logger::init().unwrap();"}, {"sha": "1d8816c7db132d95d78b728e0fdccdf536aaa14c", "filename": "src/tools/compiletest/src/read2.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/51e22479485900d3d593547e8cf855bba9a03db8/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e22479485900d3d593547e8cf855bba9a03db8/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=51e22479485900d3d593547e8cf855bba9a03db8", "patch": "@@ -0,0 +1,208 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: This is a complete copy of `cargo/src/cargo/util/read2.rs`\n+// Consider unify the read2() in libstd, cargo and this to prevent further code duplication.\n+\n+pub use self::imp::read2;\n+\n+#[cfg(not(any(unix, windows)))]\n+mod imp {\n+    use std::io::{self, Read};\n+    use std::process::{ChildStdout, ChildStderr};\n+\n+    pub fn read2(out_pipe: ChildStdout,\n+                 err_pipe: ChildStderr,\n+                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+        let mut buffer = Vec::new();\n+        out_pipe.read_to_end(&mut buffer)?;\n+        data(true, &mut buffer, true);\n+        buffer.clear();\n+        err_pipe.read_to_end(&mut buffer)?;\n+        data(false, &mut buffer, true);\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use std::io::prelude::*;\n+    use std::io;\n+    use std::mem;\n+    use std::os::unix::prelude::*;\n+    use std::process::{ChildStdout, ChildStderr};\n+    use libc;\n+\n+    pub fn read2(mut out_pipe: ChildStdout,\n+                 mut err_pipe: ChildStderr,\n+                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+        unsafe {\n+            libc::fcntl(out_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n+            libc::fcntl(err_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n+        }\n+\n+        let mut out_done = false;\n+        let mut err_done = false;\n+        let mut out = Vec::new();\n+        let mut err = Vec::new();\n+\n+        let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n+        fds[0].fd = out_pipe.as_raw_fd();\n+        fds[0].events = libc::POLLIN;\n+        fds[1].fd = err_pipe.as_raw_fd();\n+        fds[1].events = libc::POLLIN;\n+        loop {\n+            // wait for either pipe to become readable using `select`\n+            let r = unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) };\n+            if r == -1 {\n+                let err = io::Error::last_os_error();\n+                if err.kind() == io::ErrorKind::Interrupted {\n+                    continue\n+                }\n+                return Err(err)\n+            }\n+\n+            // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n+            // EAGAIN. If we hit EOF, then this will happen because the underlying\n+            // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n+            // this case we flip the other fd back into blocking mode and read\n+            // whatever's leftover on that file descriptor.\n+            let handle = |res: io::Result<_>| {\n+                match res {\n+                    Ok(_) => Ok(true),\n+                    Err(e) => {\n+                        if e.kind() == io::ErrorKind::WouldBlock {\n+                            Ok(false)\n+                        } else {\n+                            Err(e)\n+                        }\n+                    }\n+                }\n+            };\n+            if !out_done && fds[0].revents != 0 && handle(out_pipe.read_to_end(&mut out))? {\n+                out_done = true;\n+            }\n+            data(true, &mut out, out_done);\n+            if !err_done && fds[1].revents != 0 && handle(err_pipe.read_to_end(&mut err))? {\n+                err_done = true;\n+            }\n+            data(false, &mut err, err_done);\n+\n+            if out_done && err_done {\n+                return Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    extern crate miow;\n+    extern crate winapi;\n+\n+    use std::io;\n+    use std::os::windows::prelude::*;\n+    use std::process::{ChildStdout, ChildStderr};\n+    use std::slice;\n+\n+    use self::miow::iocp::{CompletionPort, CompletionStatus};\n+    use self::miow::pipe::NamedPipe;\n+    use self::miow::Overlapped;\n+    use self::winapi::ERROR_BROKEN_PIPE;\n+\n+    struct Pipe<'a> {\n+        dst: &'a mut Vec<u8>,\n+        overlapped: Overlapped,\n+        pipe: NamedPipe,\n+        done: bool,\n+    }\n+\n+    pub fn read2(out_pipe: ChildStdout,\n+                 err_pipe: ChildStderr,\n+                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+        let mut out = Vec::new();\n+        let mut err = Vec::new();\n+\n+        let port = CompletionPort::new(1)?;\n+        port.add_handle(0, &out_pipe)?;\n+        port.add_handle(1, &err_pipe)?;\n+\n+        unsafe {\n+            let mut out_pipe = Pipe::new(out_pipe, &mut out);\n+            let mut err_pipe = Pipe::new(err_pipe, &mut err);\n+\n+            out_pipe.read()?;\n+            err_pipe.read()?;\n+\n+            let mut status = [CompletionStatus::zero(), CompletionStatus::zero()];\n+\n+            while !out_pipe.done || !err_pipe.done {\n+                for status in port.get_many(&mut status, None)? {\n+                    if status.token() == 0 {\n+                        out_pipe.complete(status);\n+                        data(true, out_pipe.dst, out_pipe.done);\n+                        out_pipe.read()?;\n+                    } else {\n+                        err_pipe.complete(status);\n+                        data(false, err_pipe.dst, err_pipe.done);\n+                        err_pipe.read()?;\n+                    }\n+                }\n+            }\n+\n+            Ok(())\n+        }\n+    }\n+\n+    impl<'a> Pipe<'a> {\n+        unsafe fn new<P: IntoRawHandle>(p: P, dst: &'a mut Vec<u8>) -> Pipe<'a> {\n+            Pipe {\n+                dst: dst,\n+                pipe: NamedPipe::from_raw_handle(p.into_raw_handle()),\n+                overlapped: Overlapped::zero(),\n+                done: false,\n+            }\n+        }\n+\n+        unsafe fn read(&mut self) -> io::Result<()> {\n+            let dst = slice_to_end(self.dst);\n+            match self.pipe.read_overlapped(dst, self.overlapped.raw()) {\n+                Ok(_) => Ok(()),\n+                Err(e) => {\n+                    if e.raw_os_error() == Some(ERROR_BROKEN_PIPE as i32) {\n+                        self.done = true;\n+                        Ok(())\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            }\n+        }\n+\n+        unsafe fn complete(&mut self, status: &CompletionStatus) {\n+            let prev = self.dst.len();\n+            self.dst.set_len(prev + status.bytes_transferred() as usize);\n+            if status.bytes_transferred() == 0 {\n+                self.done = true;\n+            }\n+        }\n+    }\n+\n+    unsafe fn slice_to_end(v: &mut Vec<u8>) -> &mut [u8] {\n+        if v.capacity() == 0 {\n+            v.reserve(16);\n+        }\n+        if v.capacity() == v.len() {\n+            v.reserve(1);\n+        }\n+        slice::from_raw_parts_mut(v.as_mut_ptr().offset(v.len() as isize),\n+                                  v.capacity() - v.len())\n+    }\n+}"}, {"sha": "0983ce9d09a049630b8637a0a03fcf1b7f9f5e76", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 85, "deletions": 6, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/51e22479485900d3d593547e8cf855bba9a03db8/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e22479485900d3d593547e8cf855bba9a03db8/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=51e22479485900d3d593547e8cf855bba9a03db8", "patch": "@@ -29,7 +29,7 @@ use std::fmt;\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Output, ExitStatus, Stdio};\n+use std::process::{Command, Output, ExitStatus, Stdio, Child};\n use std::str;\n \n use extract_gdb_version;\n@@ -1344,12 +1344,14 @@ actual:\\n\\\n         if let Some(input) = input {\n             child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n         }\n-        let Output { status, stdout, stderr } = child.wait_with_output().unwrap();\n+\n+        let Output { status, stdout, stderr } = read2_abbreviated(child)\n+            .expect(\"failed to read output\");\n \n         let result = ProcRes {\n             status,\n-            stdout: String::from_utf8(stdout).unwrap(),\n-            stderr: String::from_utf8(stderr).unwrap(),\n+            stdout: String::from_utf8_lossy(&stdout).into_owned(),\n+            stderr: String::from_utf8_lossy(&stderr).into_owned(),\n             cmdline,\n         };\n \n@@ -1634,7 +1636,9 @@ actual:\\n\\\n         cmd.arg(\"-a\").arg(\"-u\");\n         cmd.arg(filename);\n         cmd.arg(\"-nobanner\");\n-        let output = match cmd.output() {\n+        cmd.stdout(Stdio::piped());\n+        cmd.stderr(Stdio::piped());\n+        let output = match cmd.spawn().and_then(read2_abbreviated) {\n             Ok(output) => output,\n             Err(_) => return,\n         };\n@@ -2094,6 +2098,8 @@ actual:\\n\\\n \n         let mut cmd = Command::new(make);\n         cmd.current_dir(&self.testpaths.file)\n+           .stdout(Stdio::piped())\n+           .stderr(Stdio::piped())\n            .env(\"TARGET\", &self.config.target)\n            .env(\"PYTHON\", &self.config.docck_python)\n            .env(\"S\", src_root)\n@@ -2142,7 +2148,7 @@ actual:\\n\\\n             }\n         }\n \n-        let output = cmd.output().expect(\"failed to spawn `make`\");\n+        let output = cmd.spawn().and_then(read2_abbreviated).expect(\"failed to spawn `make`\");\n         if !output.status.success() {\n             let res = ProcRes {\n                 status: output.status,\n@@ -2534,3 +2540,76 @@ fn nocomment_mir_line(line: &str) -> &str {\n         line\n     }\n }\n+\n+fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n+    use std::mem::replace;\n+    use read2::read2;\n+\n+    const HEAD_LEN: usize = 160 * 1024;\n+    const TAIL_LEN: usize = 256 * 1024;\n+\n+    enum ProcOutput {\n+        Full(Vec<u8>),\n+        Abbreviated {\n+            head: Vec<u8>,\n+            skipped: usize,\n+            tail: Box<[u8]>,\n+        }\n+    }\n+\n+    impl ProcOutput {\n+        fn extend(&mut self, data: &[u8]) {\n+            let new_self = match *self {\n+                ProcOutput::Full(ref mut bytes) => {\n+                    bytes.extend_from_slice(data);\n+                    let new_len = bytes.len();\n+                    if new_len <= HEAD_LEN + TAIL_LEN {\n+                        return;\n+                    }\n+                    let tail = bytes.split_off(new_len - TAIL_LEN).into_boxed_slice();\n+                    let head = replace(bytes, Vec::new());\n+                    let skipped = new_len - HEAD_LEN - TAIL_LEN;\n+                    ProcOutput::Abbreviated { head, skipped, tail }\n+                }\n+                ProcOutput::Abbreviated { ref mut skipped, ref mut tail, .. } => {\n+                    *skipped += data.len();\n+                    if data.len() <= TAIL_LEN {\n+                        tail[..data.len()].copy_from_slice(data);\n+                        tail.rotate(data.len());\n+                    } else {\n+                        tail.copy_from_slice(&data[(data.len() - TAIL_LEN)..]);\n+                    }\n+                    return;\n+                }\n+            };\n+            *self = new_self;\n+        }\n+\n+        fn into_bytes(self) -> Vec<u8> {\n+            match self {\n+                ProcOutput::Full(bytes) => bytes,\n+                ProcOutput::Abbreviated { mut head, skipped, tail } => {\n+                    write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n+                    head.extend_from_slice(&tail);\n+                    head\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut stdout = ProcOutput::Full(Vec::new());\n+    let mut stderr = ProcOutput::Full(Vec::new());\n+\n+    drop(child.stdin.take());\n+    read2(child.stdout.take().unwrap(), child.stderr.take().unwrap(), &mut |is_stdout, data, _| {\n+        if is_stdout { &mut stdout } else { &mut stderr }.extend(data);\n+        data.clear();\n+    })?;\n+    let status = child.wait()?;\n+\n+    Ok(Output {\n+        status,\n+        stdout: stdout.into_bytes(),\n+        stderr: stderr.into_bytes(),\n+    })\n+}\n\\ No newline at end of file"}]}