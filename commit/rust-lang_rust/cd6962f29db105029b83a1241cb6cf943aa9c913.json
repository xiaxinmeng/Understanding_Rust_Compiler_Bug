{"sha": "cd6962f29db105029b83a1241cb6cf943aa9c913", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNjk2MmYyOWRiMTA1MDI5YjgzYTEyNDFjYjZjZjk0M2FhOWM5MTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-07T18:42:40Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-07T18:42:40Z"}, "message": "rustc: Link to external tag discriminants. Un-XFAIL test/run-pass/lib-option.rs.", "tree": {"sha": "a1705a9b409ed7104ef8fab1813a48376738a128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1705a9b409ed7104ef8fab1813a48376738a128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd6962f29db105029b83a1241cb6cf943aa9c913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6962f29db105029b83a1241cb6cf943aa9c913", "html_url": "https://github.com/rust-lang/rust/commit/cd6962f29db105029b83a1241cb6cf943aa9c913", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd6962f29db105029b83a1241cb6cf943aa9c913/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a894cabc237f32484dd9fb4265790c60eefd661", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a894cabc237f32484dd9fb4265790c60eefd661", "html_url": "https://github.com/rust-lang/rust/commit/2a894cabc237f32484dd9fb4265790c60eefd661"}], "stats": {"total": 99, "additions": 53, "deletions": 46}, "files": [{"sha": "ce9d98b9943b728cecbcb6a7758c6359cfce6d11", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cd6962f29db105029b83a1241cb6cf943aa9c913/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6962f29db105029b83a1241cb6cf943aa9c913/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cd6962f29db105029b83a1241cb6cf943aa9c913", "patch": "@@ -3679,6 +3679,24 @@ fn lval_generic_fn(@block_ctxt cx,\n     ret lv;\n }\n \n+fn lookup_discriminant(@crate_ctxt ccx, ast.def_id tid, ast.def_id vid)\n+        -> ValueRef {\n+    alt (ccx.discrims.find(vid)) {\n+        case (none[ValueRef]) {\n+            // It's an external discriminant that we haven't seen yet.\n+            check (ccx.sess.get_targ_crate_num() != vid._0);\n+            auto sym = creader.get_symbol(ccx.sess, vid);\n+            auto gvar = llvm.LLVMAddGlobal(ccx.llmod, T_int(), _str.buf(sym));\n+            llvm.LLVMSetLinkage(gvar,\n+                                lib.llvm.LLVMExternalLinkage as llvm.Linkage);\n+            llvm.LLVMSetGlobalConstant(gvar, True);\n+            ccx.discrims.insert(vid, gvar);\n+            ret gvar;\n+        }\n+        case (some[ValueRef](?llval)) { ret llval; }\n+    }\n+}\n+\n fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n               &ast.ann ann) -> lval_result {\n     alt (dopt) {\n@@ -3725,46 +3743,39 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n-                    // TODO: externals\n-                    if (cx.fcx.ccx.fn_pairs.contains_key(vid)) {\n-                        check (cx.fcx.ccx.items.contains_key(tid));\n-                        auto tag_item = cx.fcx.ccx.items.get(tid);\n-                        auto params = ty.item_ty(tag_item)._0;\n-                        auto fty = plain_ty(ty.ty_nil);\n-                        alt (tag_item.node) {\n-                            case (ast.item_tag(_, ?variants, _, _, _)) {\n-                                for (ast.variant v in variants) {\n-                                    if (v.node.id == vid) {\n-                                        fty = node_ann_type(cx.fcx.ccx,\n-                                                            v.node.ann);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        ret lval_generic_fn(cx, tup(params, fty), vid, ann);\n-                    } else {\n-                        // Nullary variant.\n-                        auto tag_ty = node_ann_type(cx.fcx.ccx, ann);\n-                        auto lldiscrim_gv = cx.fcx.ccx.discrims.get(vid);\n-                        auto lldiscrim = cx.build.Load(lldiscrim_gv);\n-\n-                        auto alloc_result = alloc_ty(cx, tag_ty);\n-                        auto lltagblob = alloc_result.val;\n-\n-                        auto lltagty;\n-                        if (ty.type_has_dynamic_size(tag_ty)) {\n-                            lltagty = T_opaque_tag(cx.fcx.ccx.tn);\n-                        } else {\n-                            lltagty = type_of(cx.fcx.ccx, tag_ty);\n+                    auto v_tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n+                        cx.fcx.ccx.type_cache, vid);\n+                    alt (v_tyt._1.struct) {\n+                        case (ty.ty_fn(_, _, _)) {\n+                            // N-ary variant.\n+                            ret lval_generic_fn(cx, v_tyt, vid, ann);\n                         }\n-                        auto lltagptr = alloc_result.bcx.build.PointerCast(\n-                            lltagblob, T_ptr(lltagty));\n+                        case (_) {\n+                            // Nullary variant.\n+                            auto tag_ty = node_ann_type(cx.fcx.ccx, ann);\n+                            auto lldiscrim_gv =\n+                                lookup_discriminant(cx.fcx.ccx, tid, vid);\n+                            auto lldiscrim = cx.build.Load(lldiscrim_gv);\n+\n+                            auto alloc_result = alloc_ty(cx, tag_ty);\n+                            auto lltagblob = alloc_result.val;\n+\n+                            auto lltagty;\n+                            if (ty.type_has_dynamic_size(tag_ty)) {\n+                                lltagty = T_opaque_tag(cx.fcx.ccx.tn);\n+                            } else {\n+                                lltagty = type_of(cx.fcx.ccx, tag_ty);\n+                            }\n+                            auto lltagptr = alloc_result.bcx.build.PointerCast(\n+                                lltagblob, T_ptr(lltagty));\n \n-                        auto lldiscrimptr = alloc_result.bcx.build.GEP(\n-                            lltagptr, vec(C_int(0), C_int(0)));\n-                        alloc_result.bcx.build.Store(lldiscrim, lldiscrimptr);\n+                            auto lldiscrimptr = alloc_result.bcx.build.GEP(\n+                                lltagptr, vec(C_int(0), C_int(0)));\n+                            alloc_result.bcx.build.Store(lldiscrim,\n+                                                         lldiscrimptr);\n \n-                        ret lval_val(alloc_result.bcx, lltagptr);\n+                            ret lval_val(alloc_result.bcx, lltagptr);\n+                        }\n                     }\n                 }\n                 case (ast.def_const(?did)) {\n@@ -6378,25 +6389,22 @@ fn collect_tag_ctors(@crate_ctxt cx, @ast.crate crate) {\n \n fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n     alt (it.node) {\n-        case (ast.item_tag(_, ?variants, _, ?tag_id, _)) {\n+        case (ast.item_tag(?ident, ?variants, _, ?tag_id, _)) {\n             auto i = 0u;\n             auto n_variants = _vec.len[ast.variant](variants);\n             while (i < n_variants) {\n                 auto variant = variants.(i);\n \n                 auto discrim_val = C_int(i as int);\n \n-                // FIXME: better name.\n-                auto s = cx.names.next(\"_rust_tag_discrim\");\n+                auto s = mangle_name_by_seq(cx,\n+                                            #fmt(\"_rust_tag_discrim_%s_%u\",\n+                                                 ident, i));\n                 auto discrim_gvar = llvm.LLVMAddGlobal(cx.llmod, T_int(),\n                                                        _str.buf(s));\n \n-                // FIXME: Eventually we do want to export these, but we need\n-                // to figure out what name they get first!\n                 llvm.LLVMSetInitializer(discrim_gvar, discrim_val);\n                 llvm.LLVMSetGlobalConstant(discrim_gvar, True);\n-                llvm.LLVMSetLinkage(discrim_gvar, lib.llvm.LLVMInternalLinkage\n-                                    as llvm.Linkage);\n \n                 cx.discrims.insert(variant.node.id, discrim_gvar);\n                 cx.discrim_symbols.insert(variant.node.id, s);"}, {"sha": "922072e5759a867aaf23e53962ea415a5c926fee", "filename": "src/test/run-pass/lib-option.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd6962f29db105029b83a1241cb6cf943aa9c913/src%2Ftest%2Frun-pass%2Flib-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6962f29db105029b83a1241cb6cf943aa9c913/src%2Ftest%2Frun-pass%2Flib-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-option.rs?ref=cd6962f29db105029b83a1241cb6cf943aa9c913", "patch": "@@ -1,6 +1,5 @@\n-// xfail-stage0\n use std;\n \n fn main() {\n   auto x = std.option.some[int](10);\n-}\n\\ No newline at end of file\n+}"}]}