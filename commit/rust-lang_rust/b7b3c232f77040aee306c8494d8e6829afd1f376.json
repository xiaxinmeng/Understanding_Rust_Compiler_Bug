{"sha": "b7b3c232f77040aee306c8494d8e6829afd1f376", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3YjNjMjMyZjc3MDQwYWVlMzA2Yzg0OTRkOGU2ODI5YWZkMWYzNzY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-27T16:25:13Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-30T12:49:04Z"}, "message": "refactor the handling of lvalue ops\n\nFixes #41604.", "tree": {"sha": "80f7a3030e9b80c3a8371e76de06c67dc9ae4d66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80f7a3030e9b80c3a8371e76de06c67dc9ae4d66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7b3c232f77040aee306c8494d8e6829afd1f376", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b3c232f77040aee306c8494d8e6829afd1f376", "html_url": "https://github.com/rust-lang/rust/commit/b7b3c232f77040aee306c8494d8e6829afd1f376", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7b3c232f77040aee306c8494d8e6829afd1f376/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78f63181360269981085795b7feb0f4b6591f52f", "url": "https://api.github.com/repos/rust-lang/rust/commits/78f63181360269981085795b7feb0f4b6591f52f", "html_url": "https://github.com/rust-lang/rust/commit/78f63181360269981085795b7feb0f4b6591f52f"}], "stats": {"total": 434, "additions": 204, "deletions": 230}, "files": [{"sha": "c9584f1d9e1e0968a057f4c6875058788a6ebb75", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 7, "deletions": 34, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=b7b3c232f77040aee306c8494d8e6829afd1f376", "patch": "@@ -10,15 +10,15 @@\n \n use astconv::AstConv;\n \n-use super::FnCtxt;\n+use super::{FnCtxt, LvalueOp};\n \n use check::coercion::AsCoercionSite;\n use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::{MethodCall, MethodCallee};\n-use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n+use rustc::ty::{LvaluePreference, NoPreference};\n use rustc::hir;\n \n use syntax_pos::Span;\n@@ -213,39 +213,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 span: Span,\n                                 base_expr: Option<&hir::Expr>,\n                                 base_ty: Ty<'tcx>,\n-                                lvalue_pref: LvaluePreference)\n+                                pref: LvaluePreference)\n                                 -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        debug!(\"try_overloaded_deref({:?},{:?},{:?},{:?})\",\n-               span,\n-               base_expr,\n-               base_ty,\n-               lvalue_pref);\n-        // Try DerefMut first, if preferred.\n-        let method = match (lvalue_pref, self.tcx.lang_items.deref_mut_trait()) {\n-            (PreferMutLvalue, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span,\n-                                            base_expr,\n-                                            Symbol::intern(\"deref_mut\"),\n-                                            trait_did,\n-                                            base_ty,\n-                                            None)\n-            }\n-            _ => None,\n-        };\n-\n-        // Otherwise, fall back to Deref.\n-        let method = match (method, self.tcx.lang_items.deref_trait()) {\n-            (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span,\n-                                            base_expr,\n-                                            Symbol::intern(\"deref\"),\n-                                            trait_did,\n-                                            base_ty,\n-                                            None)\n-            }\n-            (method, _) => method,\n-        };\n+        let rcvr = base_expr.map(|base_expr| super::AdjustedRcvr {\n+            rcvr_expr: base_expr, autoderefs: 0, unsize: false\n+        });\n \n-        method\n+        self.try_overloaded_lvalue_op(span, rcvr, base_ty, &[], pref, LvalueOp::Deref)\n     }\n }"}, {"sha": "7a49309e005a11de55a0dbaadb085a1ccf4d309f", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=b7b3c232f77040aee306c8494d8e6829afd1f376", "patch": "@@ -165,11 +165,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             match self.lookup_method_in_trait_adjusted(call_expr.span,\n-                                                       Some(&callee_expr),\n+                                                       Some(super::AdjustedRcvr {\n+                                                           rcvr_expr: callee_expr,\n+                                                           autoderefs,\n+                                                           unsize: false\n+                                                       }),\n                                                        method_name,\n                                                        trait_def_id,\n-                                                       autoderefs,\n-                                                       false,\n                                                        adjusted_ty,\n                                                        None) {\n                 None => continue,"}, {"sha": "aad14bc975de5af618d7f9a5e9f36c35d554f450", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 61, "deletions": 117, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b7b3c232f77040aee306c8494d8e6829afd1f376", "patch": "@@ -10,7 +10,7 @@\n \n use super::probe;\n \n-use check::{FnCtxt, callee};\n+use check::{FnCtxt, LvalueOp, callee};\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -433,137 +433,81 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n             debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n-            // Count autoderefs. We don't need to fix up the autoref - the parent\n-            // expression will fix them up for us.\n-            let adjustment = self.tables.borrow().adjustments.get(&expr.id).cloned();\n-            match adjustment {\n-                Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) => {\n-                    if autoderefs > 0 {\n-                        let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n-                        autoderef.nth(autoderefs).unwrap_or_else(|| {\n-                            span_bug!(expr.span,\n-                                      \"expr was deref-able {} times but now isn't?\",\n-                                      autoderefs);\n-                        });\n-                        autoderef.finalize(PreferMutLvalue, expr);\n+            // Fix up the adjustment.\n+            let autoderefs = match self.tables.borrow_mut().adjustments.get_mut(&expr.id) {\n+                Some(&mut Adjustment {\n+                    kind: Adjust::DerefRef { autoderefs, ref mut autoref, .. }, ref mut target\n+                }) => {\n+                    if let &mut Some(AutoBorrow::Ref(_, ref mut mutbl)) = autoref {\n+                        *mutbl = hir::Mutability::MutMutable;\n+                        *target = match target.sty {\n+                            ty::TyRef(r, ty::TypeAndMut { ty, .. }) =>\n+                                self.tcx.mk_ref(r, ty::TypeAndMut { ty, mutbl: *mutbl }),\n+                            _ => span_bug!(expr.span, \"AutoBorrow::Ref resulted in non-ref {:?}\",\n+                                           target)\n+                        };\n                     }\n+                    autoderefs\n                 }\n-                Some(_) | None => {}\n+                Some(_) | None => 0\n+            };\n+\n+            if autoderefs > 0 {\n+                let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n+                autoderef.nth(autoderefs).unwrap_or_else(|| {\n+                    span_bug!(expr.span,\n+                              \"expr was deref-able {} times but now isn't?\",\n+                              autoderefs);\n+                });\n+                autoderef.finalize(PreferMutLvalue, expr);\n             }\n \n-            // Don't retry the first one or we might infinite loop!\n-            if i == 0 {\n-                continue;\n-            }\n             match expr.node {\n                 hir::ExprIndex(ref base_expr, ref index_expr) => {\n-                    // If this is an overloaded index, the\n-                    // adjustment will include an extra layer of\n-                    // autoref because the method is an &self/&mut\n-                    // self method. We have to peel it off to get\n-                    // the raw adjustment that `try_index_step`\n-                    // expects. This is annoying and horrible. We\n-                    // ought to recode this routine so it doesn't\n-                    // (ab)use the normal type checking paths.\n-                    let adj = self.tables.borrow_mut().adjustments.remove(&base_expr.id);\n-                    let (autoderefs, unsize, adjusted_base_ty) = match adj {\n-                        Some(Adjustment {\n-                            kind: Adjust::DerefRef { autoderefs, autoref, unsize },\n-                            target\n-                        }) => {\n-                            match autoref {\n-                                None => {\n-                                    assert!(!unsize);\n-                                }\n-                                Some(AutoBorrow::Ref(..)) => {}\n-                                Some(_) => {\n-                                    span_bug!(base_expr.span,\n-                                              \"unexpected adjustment autoref {:?}\",\n-                                              adj);\n-                                }\n-                            }\n-\n-                            (autoderefs, unsize, if unsize {\n-                                target.builtin_deref(false, NoPreference)\n-                                      .expect(\"fixup: AutoBorrow::Ref is not &T\")\n-                                      .ty\n-                            } else {\n-                                let ty = self.node_ty(base_expr.id);\n-                                let mut ty = self.shallow_resolve(ty);\n-                                let mut method_type = |method_call: ty::MethodCall| {\n-                                    self.tables.borrow().method_map.get(&method_call).map(|m| {\n-                                        self.resolve_type_vars_if_possible(&m.ty)\n-                                    })\n-                                };\n-\n-                                if !ty.references_error() {\n-                                    for i in 0..autoderefs {\n-                                        ty = ty.adjust_for_autoderef(self.tcx,\n-                                                                     base_expr.id,\n-                                                                     base_expr.span,\n-                                                                     i as u32,\n-                                                                     &mut method_type);\n-                                    }\n-                                }\n-\n-                                ty\n-                            })\n-                        }\n-                        None => (0, false, self.node_ty(base_expr.id)),\n-                        Some(_) => {\n-                            span_bug!(base_expr.span, \"unexpected adjustment type\");\n-                        }\n-                    };\n-\n                     let index_expr_ty = self.node_ty(index_expr.id);\n-                    let adjusted_base_ty = self.resolve_type_vars_if_possible(&adjusted_base_ty);\n-                    let index_expr_ty = self.resolve_type_vars_if_possible(&index_expr_ty);\n-\n-                    let result = self.try_index_step(ty::MethodCall::expr(expr.id),\n-                                                     expr,\n-                                                     &base_expr,\n-                                                     adjusted_base_ty,\n-                                                     autoderefs,\n-                                                     unsize,\n-                                                     PreferMutLvalue,\n-                                                     index_expr_ty);\n-\n-                    if let Some((input_ty, return_ty)) = result {\n-                        self.demand_suptype(index_expr.span, input_ty, index_expr_ty);\n-\n-                        let expr_ty = self.node_ty(expr.id);\n-                        self.demand_suptype(expr.span, expr_ty, return_ty);\n-                    } else {\n-                        // We could not perform a mutable index. Re-apply the\n-                        // immutable index adjustments - borrowck will detect\n-                        // this as an error.\n-                        if let Some(adjustment) = adjustment {\n-                            self.apply_adjustment(expr.id, adjustment);\n-                        }\n-                        self.tcx.sess.delay_span_bug(\n-                            expr.span, \"convert_lvalue_derefs_to_mutable failed\");\n-                    }\n+                    self.convert_lvalue_op_to_mutable(\n+                        LvalueOp::Index, expr, base_expr, &[index_expr_ty]);\n                 }\n                 hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n-                    // if this is an overloaded deref, then re-evaluate with\n-                    // a preference for mut\n-                    let method_call = ty::MethodCall::expr(expr.id);\n-                    if self.tables.borrow().method_map.contains_key(&method_call) {\n-                        self.tables.borrow_mut().adjustments.remove(&base_expr.id);\n-                        let method = self.try_overloaded_deref(expr.span,\n-                                                               Some(&base_expr),\n-                                                               self.node_ty(base_expr.id),\n-                                                               PreferMutLvalue);\n-                        let ok = method.expect(\"re-trying deref failed\");\n-                        let method = self.register_infer_ok_obligations(ok);\n-                        self.tables.borrow_mut().method_map.insert(method_call, method);\n-                    }\n+                    self.convert_lvalue_op_to_mutable(\n+                        LvalueOp::Deref, expr, base_expr, &[]);\n                 }\n                 _ => {}\n             }\n         }\n     }\n \n+    fn convert_lvalue_op_to_mutable(&self,\n+                                    op: LvalueOp,\n+                                    expr: &hir::Expr,\n+                                    base_expr: &hir::Expr,\n+                                    arg_tys: &[Ty<'tcx>])\n+    {\n+        debug!(\"convert_lvalue_op_to_mutable({:?}, {:?}, {:?}, {:?})\",\n+               op, expr, base_expr, arg_tys);\n+        let method_call = ty::MethodCall::expr(expr.id);\n+        if !self.tables.borrow().method_map.contains_key(&method_call) {\n+            debug!(\"convert_lvalue_op_to_mutable - builtin, nothing to do\");\n+            return\n+        }\n+\n+        let base_ty = self.tables.borrow().adjustments.get(&base_expr.id)\n+            .map_or_else(|| self.node_ty(expr.id), |adj| adj.target);\n+        let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n+\n+        // Need to deref because overloaded lvalue ops take self by-reference.\n+        let base_ty = base_ty.builtin_deref(false, NoPreference)\n+            .expect(\"lvalue op takes something that is not a ref\")\n+            .ty;\n+\n+        let method = self.try_overloaded_lvalue_op(\n+            expr.span, None, base_ty, arg_tys, PreferMutLvalue, op);\n+        let ok = method.expect(\"re-trying op failed\");\n+        let method = self.register_infer_ok_obligations(ok);\n+        debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n+        self.tables.borrow_mut().method_map.insert(method_call, method);\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n "}, {"sha": "4d5f67004a7cc0c35bc9bea72fab65e59fa827e2", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b7b3c232f77040aee306c8494d8e6829afd1f376", "patch": "@@ -10,7 +10,7 @@\n \n //! Method lookup: the secret sauce of Rust. See `README.md`.\n \n-use check::FnCtxt;\n+use check::{FnCtxt, AdjustedRcvr};\n use hir::def::Def;\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n@@ -153,24 +153,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                supplied_method_types))\n     }\n \n-    pub fn lookup_method_in_trait(&self,\n-                                  span: Span,\n-                                  self_expr: Option<&hir::Expr>,\n-                                  m_name: ast::Name,\n-                                  trait_def_id: DefId,\n-                                  self_ty: ty::Ty<'tcx>,\n-                                  opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                  -> Option<InferOk<'tcx, ty::MethodCallee<'tcx>>> {\n-        self.lookup_method_in_trait_adjusted(span,\n-                                             self_expr,\n-                                             m_name,\n-                                             trait_def_id,\n-                                             0,\n-                                             false,\n-                                             self_ty,\n-                                             opt_input_types)\n-    }\n-\n     /// `lookup_in_trait_adjusted` is used for overloaded operators.\n     /// It does a very narrow slice of what the normal probe/confirm path does.\n     /// In particular, it doesn't really do any probing: it simply constructs\n@@ -184,18 +166,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// this method is basically the same as confirmation.\n     pub fn lookup_method_in_trait_adjusted(&self,\n                                            span: Span,\n-                                           self_expr: Option<&hir::Expr>,\n+                                           self_info: Option<AdjustedRcvr>,\n                                            m_name: ast::Name,\n                                            trait_def_id: DefId,\n-                                           autoderefs: usize,\n-                                           unsize: bool,\n                                            self_ty: ty::Ty<'tcx>,\n                                            opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n                                            -> Option<InferOk<'tcx, ty::MethodCallee<'tcx>>> {\n-        debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_expr={:?}, \\\n+        debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_info={:?}, \\\n                 m_name={}, trait_def_id={:?})\",\n                self_ty,\n-               self_expr,\n+               self_info,\n                m_name,\n                trait_def_id);\n \n@@ -288,10 +268,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         obligations.push(traits::Obligation::new(cause, ty::Predicate::WellFormed(method_ty)));\n \n         // Insert any adjustments needed (always an autoref of some mutability).\n-        if let Some(self_expr) = self_expr {\n+        if let Some(AdjustedRcvr { rcvr_expr, autoderefs, unsize }) = self_info {\n             debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n                     (self-id={}, autoderefs={}, unsize={}, fty={:?})\",\n-                    self_expr.id, autoderefs, unsize, original_method_ty);\n+                    rcvr_expr.id, autoderefs, unsize, original_method_ty);\n \n             let original_sig = original_method_ty.fn_sig();\n             let autoref = match (&original_sig.input(0).skip_binder().sty,\n@@ -308,7 +288,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            self.apply_adjustment(self_expr.id, Adjustment {\n+            self.apply_adjustment(rcvr_expr.id, Adjustment {\n                 kind: Adjust::DerefRef {\n                     autoderefs: autoderefs,\n                     autoref: autoref,"}, {"sha": "8752f82f7abf2eef7f2b9eb66f20e1fefdce8926", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 95, "deletions": 43, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b7b3c232f77040aee306c8494d8e6829afd1f376", "patch": "@@ -361,6 +361,19 @@ impl UnsafetyState {\n     }\n }\n \n+#[derive(Debug, Copy, Clone)]\n+pub enum LvalueOp {\n+    Deref,\n+    Index\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct AdjustedRcvr<'a> {\n+    pub rcvr_expr: &'a hir::Expr,\n+    pub autoderefs: usize,\n+    pub unsize: bool\n+}\n+\n /// Tracks whether executing a node may exit normally (versus\n /// return/break/panic, which \"diverge\", leaving dead code in their\n /// wake). Tracked semi-automatically (through type variables marked\n@@ -2156,20 +2169,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         while let Some((adj_ty, autoderefs)) = autoderef.next() {\n             if let Some(final_mt) = self.try_index_step(\n-                MethodCall::expr(expr.id),\n-                expr, base_expr, adj_ty, autoderefs,\n-                false, lvalue_pref, idx_ty)\n+                MethodCall::expr(expr.id), expr, Some(AdjustedRcvr {\n+                    rcvr_expr: base_expr,\n+                    autoderefs,\n+                    unsize: false\n+                }), base_expr.span, adj_ty, lvalue_pref, idx_ty)\n             {\n                 autoderef.finalize(lvalue_pref, base_expr);\n                 return Some(final_mt);\n             }\n \n             if let ty::TyArray(element_ty, _) = adj_ty.sty {\n                 autoderef.finalize(lvalue_pref, base_expr);\n-                let adjusted_ty = self.tcx.mk_slice(element_ty);\n+                let adj_ty = self.tcx.mk_slice(element_ty);\n                 return self.try_index_step(\n-                    MethodCall::expr(expr.id), expr, base_expr,\n-                    adjusted_ty, autoderefs, true, lvalue_pref, idx_ty);\n+                    MethodCall::expr(expr.id), expr, Some(AdjustedRcvr {\n+                        rcvr_expr: base_expr,\n+                        autoderefs,\n+                        unsize: true\n+                    }), base_expr.span, adj_ty, lvalue_pref, idx_ty)\n             }\n         }\n         autoderef.unambiguous_final_ty();\n@@ -2184,77 +2202,111 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn try_index_step(&self,\n                       method_call: MethodCall,\n                       expr: &hir::Expr,\n-                      base_expr: &'gcx hir::Expr,\n+                      base_expr: Option<AdjustedRcvr>,\n+                      base_span: Span,\n                       adjusted_ty: Ty<'tcx>,\n-                      autoderefs: usize,\n-                      unsize: bool,\n                       lvalue_pref: LvaluePreference,\n                       index_ty: Ty<'tcx>)\n                       -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n         let tcx = self.tcx;\n-        debug!(\"try_index_step(expr={:?}, base_expr.id={:?}, adjusted_ty={:?}, \\\n-                               autoderefs={}, unsize={}, index_ty={:?})\",\n+        debug!(\"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n+                               index_ty={:?})\",\n                expr,\n                base_expr,\n                adjusted_ty,\n-               autoderefs,\n-               unsize,\n                index_ty);\n \n-        let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n+        let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_span));\n \n         // First, try built-in indexing.\n         match (adjusted_ty.builtin_index(), &index_ty.sty) {\n             (Some(ty), &ty::TyUint(ast::UintTy::Us)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n                 debug!(\"try_index_step: success, using built-in indexing\");\n                 // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n-                assert!(!unsize);\n-                self.apply_autoderef_adjustment(base_expr.id, autoderefs, adjusted_ty);\n+                if let Some(base_expr) = base_expr {\n+                    assert!(!base_expr.unsize);\n+                    self.apply_autoderef_adjustment(\n+                        base_expr.rcvr_expr.id, base_expr.autoderefs, adjusted_ty);\n+                }\n                 return Some((tcx.types.usize, ty));\n             }\n             _ => {}\n         }\n \n-        // Try `IndexMut` first, if preferred.\n-        let method = match (lvalue_pref, tcx.lang_items.index_mut_trait()) {\n+        // If some lookup succeeds, write callee into table and extract index/element\n+        // type from the method signature.\n+        // If some lookup succeeded, install method in table\n+        let method = self.try_overloaded_lvalue_op(\n+            expr.span, base_expr, adjusted_ty, &[input_ty], lvalue_pref, LvalueOp::Index);\n+\n+        method.map(|ok| {\n+            debug!(\"try_index_step: success, using overloaded indexing\");\n+            let method = self.register_infer_ok_obligations(ok);\n+            self.tables.borrow_mut().method_map.insert(method_call, method);\n+            (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n+        })\n+    }\n+\n+    fn resolve_lvalue_op(&self, op: LvalueOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n+        let (tr, name) = match (op, is_mut) {\n+            (LvalueOp::Deref, false) =>\n+                (self.tcx.lang_items.deref_trait(), \"deref\"),\n+            (LvalueOp::Deref, true) =>\n+                (self.tcx.lang_items.deref_mut_trait(), \"deref_mut\"),\n+            (LvalueOp::Index, false) =>\n+                (self.tcx.lang_items.index_trait(), \"index\"),\n+            (LvalueOp::Index, true) =>\n+                (self.tcx.lang_items.index_mut_trait(), \"index_mut\"),\n+        };\n+        (tr, Symbol::intern(name))\n+    }\n+\n+    fn try_overloaded_lvalue_op(&self,\n+                                span: Span,\n+                                base_expr: Option<AdjustedRcvr>,\n+                                base_ty: Ty<'tcx>,\n+                                arg_tys: &[Ty<'tcx>],\n+                                lvalue_pref: LvaluePreference,\n+                                op: LvalueOp)\n+                                -> Option<InferOk<'tcx, MethodCallee<'tcx>>>\n+    {\n+        debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?},{:?})\",\n+               span,\n+               base_expr,\n+               base_ty,\n+               lvalue_pref,\n+               op);\n+\n+        // Try Mut first, if preferred.\n+        let (mut_tr, mut_op) = self.resolve_lvalue_op(op, true);\n+        let method = match (lvalue_pref, mut_tr) {\n             (PreferMutLvalue, Some(trait_did)) => {\n-                self.lookup_method_in_trait_adjusted(expr.span,\n-                                                     Some(&base_expr),\n-                                                     Symbol::intern(\"index_mut\"),\n+                self.lookup_method_in_trait_adjusted(span,\n+                                                     base_expr,\n+                                                     mut_op,\n                                                      trait_did,\n-                                                     autoderefs,\n-                                                     unsize,\n-                                                     adjusted_ty,\n-                                                     Some(vec![input_ty]))\n+                                                     base_ty,\n+                                                     Some(arg_tys.to_owned()))\n             }\n             _ => None,\n         };\n \n-        // Otherwise, fall back to `Index`.\n-        let method = match (method, tcx.lang_items.index_trait()) {\n+        // Otherwise, fall back to the immutable version.\n+        let (imm_tr, imm_op) = self.resolve_lvalue_op(op, false);\n+        let method = match (method, imm_tr) {\n             (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait_adjusted(expr.span,\n-                                                     Some(&base_expr),\n-                                                     Symbol::intern(\"index\"),\n+                self.lookup_method_in_trait_adjusted(span,\n+                                                     base_expr,\n+                                                     imm_op,\n                                                      trait_did,\n-                                                     autoderefs,\n-                                                     unsize,\n-                                                     adjusted_ty,\n-                                                     Some(vec![input_ty]))\n+                                                     base_ty,\n+                                                     Some(arg_tys.to_owned()))\n             }\n             (method, _) => method,\n         };\n \n-        // If some lookup succeeds, write callee into table and extract index/element\n-        // type from the method signature.\n-        // If some lookup succeeded, install method in table\n-        method.map(|ok| {\n-            debug!(\"try_index_step: success, using overloaded indexing\");\n-            let method = self.register_infer_ok_obligations(ok);\n-            self.tables.borrow_mut().method_map.insert(method_call, method);\n-            (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n-        })\n+        method\n     }\n \n     fn check_method_argument_types(&self,"}, {"sha": "4fd0e984c9f4d0bef2856de8e23519aebdf77780", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b7b3c232f77040aee306c8494d8e6829afd1f376", "patch": "@@ -398,12 +398,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let method = match trait_did {\n             Some(trait_did) => {\n-                self.lookup_method_in_trait(expr.span,\n-                                            Some(lhs_expr),\n-                                            opname,\n-                                            trait_did,\n-                                            lhs_ty,\n-                                            Some(other_tys))\n+                let lhs_expr = Some(super::AdjustedRcvr {\n+                    rcvr_expr: lhs_expr, autoderefs: 0, unsize: false\n+                });\n+                self.lookup_method_in_trait_adjusted(expr.span,\n+                                                     lhs_expr,\n+                                                     opname,\n+                                                     trait_did,\n+                                                     lhs_ty,\n+                                                     Some(other_tys))\n             }\n             None => None\n         };"}, {"sha": "20fb8c7e7d6b013fad1b215c21c3232fcec23f42", "filename": "src/test/run-pass/issue-41604.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Ftest%2Frun-pass%2Fissue-41604.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3c232f77040aee306c8494d8e6829afd1f376/src%2Ftest%2Frun-pass%2Fissue-41604.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41604.rs?ref=b7b3c232f77040aee306c8494d8e6829afd1f376", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct B;\n+\n+impl B {\n+    fn init(&mut self) {}\n+}\n+\n+fn main() {\n+    let mut b = [B];\n+    b[1-1].init();\n+}"}]}