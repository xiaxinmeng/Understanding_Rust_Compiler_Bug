{"sha": "1a33c25d6f60868525eb0e936a8fe33ddcc98ad7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMzNjMjVkNmY2MDg2ODUyNWViMGU5MzZhOGZlMzNkZGNjOThhZDc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-10T21:57:23Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-10T22:15:10Z"}, "message": "Make moves explicit in pipes and pipe compiler", "tree": {"sha": "2e45e7aa44903097e9908556a54cc09628121b07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e45e7aa44903097e9908556a54cc09628121b07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7", "html_url": "https://github.com/rust-lang/rust/commit/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c7cc9a1b813f658e34dbb7d596e2b4ab9221e9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c7cc9a1b813f658e34dbb7d596e2b4ab9221e9e", "html_url": "https://github.com/rust-lang/rust/commit/3c7cc9a1b813f658e34dbb7d596e2b4ab9221e9e"}], "stats": {"total": 124, "additions": 62, "deletions": 62}, "files": [{"sha": "a903a828326a1c7d05668e78aa2db3d167060810", "filename": "src/libcore/future.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=1a33c25d6f60868525eb0e936a8fe33ddcc98ad7", "patch": "@@ -75,7 +75,7 @@ fn from_value<A>(+val: A) -> Future<A> {\n      * not block.\n      */\n \n-    Future {state: Forced(~val)}\n+    Future {state: Forced(~(move val))}\n }\n \n fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n@@ -86,13 +86,13 @@ fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n      * waiting for the result to be received on the port.\n      */\n \n-    let port = ~mut Some(port);\n+    let port = ~mut Some(move port);\n     do from_fn |move port| {\n         let mut port_ = None;\n         port_ <-> *port;\n         let port = option::unwrap(port_);\n-        match recv(port) {\n-            future_pipe::completed(move data) => data\n+        match recv(move port) {\n+            future_pipe::completed(move data) => move data\n         }\n     }\n }\n@@ -106,7 +106,7 @@ fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n      * function. It is not spawned into another task.\n      */\n \n-    Future {state: Pending(f)}\n+    Future {state: Pending(move f)}\n }\n \n fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n@@ -117,8 +117,8 @@ fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n      * value of the future.\n      */\n \n-    from_port(pipes::spawn_service_recv(future_pipe::init, |ch| {\n-        future_pipe::server::completed(ch, blk());\n+    from_port(pipes::spawn_service_recv(future_pipe::init, |move blk, ch| {\n+        future_pipe::server::completed(move ch, blk());\n     }))\n }\n "}, {"sha": "75716e642df4b779bc4177ecbd761141b53e682f", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=1a33c25d6f60868525eb0e936a8fe33ddcc98ad7", "patch": "@@ -113,7 +113,7 @@ export send_packet, recv_packet, buffer_header;\n const SPIN_COUNT: uint = 0;\n \n macro_rules! move_it (\n-    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); move y } }\n )\n \n #[doc(hidden)]\n@@ -262,8 +262,7 @@ fn unibuffer<T: Send>() -> ~Buffer<Packet<T>> {\n     unsafe {\n         b.data.header.buffer = reinterpret_cast(&b);\n     }\n-\n-    b\n+    move b\n }\n \n #[doc(hidden)]\n@@ -411,7 +410,7 @@ fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n     let p = unsafe { &*p_ };\n     assert ptr::addr_of(p.header) == header;\n     assert p.payload.is_none();\n-    p.payload <- Some(payload);\n+    p.payload <- Some(move payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n     match old_state {\n         Empty => {\n@@ -449,7 +448,7 @@ Fails if the sender closes the connection.\n \n */\n fn recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>) -> T {\n-    option::unwrap_expect(try_recv(p), \"connection closed\")\n+    option::unwrap_expect(try_recv(move p), \"connection closed\")\n }\n \n /** Attempts to receive a message from a pipe.\n@@ -713,8 +712,8 @@ fn select2<A: Send, Ab: Send, B: Send, Bb: Send>(\n     let i = wait_many([a.header(), b.header()]/_);\n \n     match i {\n-      0 => Left((try_recv(a), b)),\n-      1 => Right((a, try_recv(b))),\n+      0 => Left((try_recv(move a), move b)),\n+      1 => Right((move a, try_recv(move b))),\n       _ => fail ~\"select2 return an invalid packet\"\n     }\n }\n@@ -750,10 +749,10 @@ fn select<T: Send, Tb: Send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n     -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n-    let mut remaining = endpoints;\n+    let mut remaining <- endpoints;\n     let port = vec::swap_remove(remaining, ready);\n-    let result = try_recv(port);\n-    (ready, result, remaining)\n+    let result = try_recv(move port);\n+    (ready, move result, move remaining)\n }\n \n /** The sending end of a pipe. It can be used to send exactly one\n@@ -943,14 +942,14 @@ fn spawn_service<T: Send, Tb: Send>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(server);\n-    do task::spawn |move service| {\n+    let server = ~mut Some(move server);\n+    do task::spawn |move service, move server| {\n         let mut server_ = None;\n         server_ <-> *server;\n         service(option::unwrap(server_))\n     }\n \n-    client\n+    move client\n }\n \n /** Like `spawn_service_recv`, but for protocols that start in the\n@@ -967,14 +966,14 @@ fn spawn_service_recv<T: Send, Tb: Send>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(server);\n-    do task::spawn |move service| {\n+    let server = ~mut Some(move server);\n+    do task::spawn |move service, move server| {\n         let mut server_ = None;\n         server_ <-> *server;\n         service(option::unwrap(server_))\n     }\n \n-    client\n+    move client\n }\n \n // Streams - Make pipes a little easier in general.\n@@ -1039,23 +1038,23 @@ These allow sending or receiving an unlimited number of messages.\n fn stream<T:Send>() -> (Chan<T>, Port<T>) {\n     let (c, s) = streamp::init();\n \n-    (Chan_({ mut endp: Some(c) }), Port_({ mut endp: Some(s) }))\n+    (Chan_({ mut endp: Some(move c) }), Port_({ mut endp: Some(move s) }))\n }\n \n impl<T: Send> Chan<T>: Channel<T> {\n     fn send(+x: T) {\n         let mut endp = None;\n         endp <-> self.endp;\n         self.endp = Some(\n-            streamp::client::data(unwrap(endp), x))\n+            streamp::client::data(unwrap(endp), move x))\n     }\n \n     fn try_send(+x: T) -> bool {\n         let mut endp = None;\n         endp <-> self.endp;\n-        match move streamp::client::try_data(unwrap(endp), x) {\n+        match move streamp::client::try_data(unwrap(endp), move x) {\n             Some(move next) => {\n-                self.endp = Some(next);\n+                self.endp = Some(move next);\n                 true\n             }\n             None => false\n@@ -1068,17 +1067,17 @@ impl<T: Send> Port<T>: Recv<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n         let streamp::data(x, endp) = pipes::recv(unwrap(endp));\n-        self.endp = Some(endp);\n-        x\n+        self.endp = Some(move endp);\n+        move x\n     }\n \n     fn try_recv() -> Option<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n         match move pipes::try_recv(unwrap(endp)) {\n           Some(streamp::data(move x, move endp)) => {\n-            self.endp = Some(endp);\n-            Some(x)\n+            self.endp = Some(move endp);\n+            Some(move x)\n           }\n           None => None\n         }\n@@ -1101,13 +1100,13 @@ struct PortSet<T: Send> : Recv<T> {\n     mut ports: ~[pipes::Port<T>],\n \n     fn add(+port: pipes::Port<T>) {\n-        vec::push(self.ports, port)\n+        vec::push(self.ports, move port)\n     }\n \n     fn chan() -> Chan<T> {\n         let (ch, po) = stream();\n-        self.add(po);\n-        ch\n+        self.add(move po);\n+        move ch\n     }\n \n     fn try_recv() -> Option<T> {\n@@ -1120,7 +1119,7 @@ struct PortSet<T: Send> : Recv<T> {\n             let i = wait_many(ports);\n             match move ports[i].try_recv() {\n                 Some(move m) => {\n-                  result = Some(m);\n+                  result = Some(move m);\n                 }\n                 None => {\n                     // Remove this port.\n@@ -1129,7 +1128,7 @@ struct PortSet<T: Send> : Recv<T> {\n             }\n         }\n         ports <-> self.ports;\n-        result\n+        move result\n     }\n \n     fn recv() -> T {\n@@ -1166,7 +1165,7 @@ type SharedChan<T: Send> = unsafe::Exclusive<Chan<T>>;\n \n impl<T: Send> SharedChan<T>: Channel<T> {\n     fn send(+x: T) {\n-        let mut xx = Some(x);\n+        let mut xx = Some(move x);\n         do self.with |chan| {\n             let mut x = None;\n             x <-> xx;\n@@ -1175,7 +1174,7 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n     }\n \n     fn try_send(+x: T) -> bool {\n-        let mut xx = Some(x);\n+        let mut xx = Some(move x);\n         do self.with |chan| {\n             let mut x = None;\n             x <-> xx;\n@@ -1186,7 +1185,7 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n \n /// Converts a `chan` into a `shared_chan`.\n fn SharedChan<T:Send>(+c: Chan<T>) -> SharedChan<T> {\n-    unsafe::exclusive(c)\n+    unsafe::exclusive(move c)\n }\n \n /// Receive a message from one of two endpoints.\n@@ -1240,24 +1239,24 @@ fn oneshot<T: Send>() -> (ChanOne<T>, PortOne<T>) {\n  * closed.\n  */\n fn recv_one<T: Send>(+port: PortOne<T>) -> T {\n-    let oneshot::send(message) = recv(port);\n-    message\n+    let oneshot::send(message) = recv(move port);\n+    move message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n-    let message = try_recv(port);\n+    let message = try_recv(move port);\n \n     if message.is_none() { None }\n     else {\n         let oneshot::send(message) = option::unwrap(message);\n-        Some(message)\n+        Some(move message)\n     }\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n fn send_one<T: Send>(+chan: ChanOne<T>, +data: T) {\n-    oneshot::client::send(chan, data);\n+    oneshot::client::send(move chan, move data);\n }\n \n /**\n@@ -1266,13 +1265,13 @@ fn send_one<T: Send>(+chan: ChanOne<T>, +data: T) {\n  */\n fn try_send_one<T: Send>(+chan: ChanOne<T>, +data: T)\n         -> bool {\n-    oneshot::client::try_send(chan, data).is_some()\n+    oneshot::client::try_send(move chan, move data).is_some()\n }\n \n mod rt {\n     // These are used to hide the option constructors from the\n     // compiler because their names are changing\n-    fn make_some<T>(+val: T) -> Option<T> { Some(val) }\n+    fn make_some<T>(+val: T) -> Option<T> { Some(move val) }\n     fn make_none<T>() -> Option<T> { None }\n }\n "}, {"sha": "123628a28a2481002349058a8e7df9a46dcd3650", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a33c25d6f60868525eb0e936a8fe33ddcc98ad7/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=1a33c25d6f60868525eb0e936a8fe33ddcc98ad7", "patch": "@@ -64,10 +64,10 @@ impl message: gen_send {\n \n             if this.proto.is_bounded() {\n                 let (sp, rp) = match (this.dir, next.dir) {\n-                  (send, send) => (~\"c\", ~\"s\"),\n+                  (send, send) => (~\"move c\", ~\"move s\"),\n                   (send, recv) => (~\"s\", ~\"c\"),\n                   (recv, send) => (~\"s\", ~\"c\"),\n-                  (recv, recv) => (~\"c\", ~\"s\")\n+                  (recv, recv) => (~\"move c\", ~\"move s\")\n                 };\n \n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n@@ -80,10 +80,10 @@ impl message: gen_send {\n             }\n             else {\n                 let pat = match (this.dir, next.dir) {\n-                  (send, send) => \"(c, s)\",\n+                  (send, send) => \"(move c, move s)\",\n                   (send, recv) => \"(s, c)\",\n                   (recv, send) => \"(s, c)\",\n-                  (recv, recv) => \"(c, s)\"\n+                  (recv, recv) => \"(move c, move s)\"\n                 };\n \n                 body += fmt!(\"let %s = pipes::entangle();\\n\", pat);\n@@ -92,17 +92,17 @@ impl message: gen_send {\n                          this.proto.name,\n                          self.name(),\n                          str::connect(vec::append_one(\n-                             arg_names.map(|x| cx.str_of(x)), ~\"s\"),\n-                                      ~\", \"));\n+                           arg_names.map(|x| ~\"move \" + cx.str_of(x)),\n+                             ~\"move s\"), ~\", \"));\n \n             if !try {\n-                body += fmt!(\"pipes::send(pipe, message);\\n\");\n+                body += fmt!(\"pipes::send(move pipe, move message);\\n\");\n                 // return the new channel\n-                body += ~\"c }\";\n+                body += ~\"move c }\";\n             }\n             else {\n-                body += fmt!(\"if pipes::send(pipe, message) {\\n \\\n-                                  pipes::rt::make_some(c) \\\n+                body += fmt!(\"if pipes::send(move pipe, move message) {\\n \\\n+                                  pipes::rt::make_some(move c) \\\n                               } else { pipes::rt::make_none() } }\");\n             }\n \n@@ -145,7 +145,8 @@ impl message: gen_send {\n                     ~\"\"\n                 }\n                 else {\n-                    ~\"(\" + str::connect(arg_names, ~\", \") + ~\")\"\n+                    ~\"(\" + str::connect(arg_names.map(|x| ~\"move \" + x),\n+                                        ~\", \") + ~\")\"\n                 };\n \n                 let mut body = ~\"{ \";\n@@ -155,10 +156,10 @@ impl message: gen_send {\n                              message_args);\n \n                 if !try {\n-                    body += fmt!(\"pipes::send(pipe, message);\\n\");\n+                    body += fmt!(\"pipes::send(move pipe, move message);\\n\");\n                     body += ~\" }\";\n                 } else {\n-                    body += fmt!(\"if pipes::send(pipe, message) { \\\n+                    body += fmt!(\"if pipes::send(move pipe, move message) { \\\n                                       pipes::rt::make_some(()) \\\n                                   } else { pipes::rt::make_none() } }\");\n                 }\n@@ -301,7 +302,7 @@ impl protocol: gen_init {\n               recv => {\n                 #ast {{\n                     let (s, c) = pipes::entangle();\n-                    (c, s)\n+                    (move c, move s)\n                 }}\n               }\n             }\n@@ -313,7 +314,7 @@ impl protocol: gen_init {\n               recv => {\n                 #ast {{\n                     let (s, c) = $(body);\n-                    (c, s)\n+                    (move c, move s)\n                 }}\n               }\n             }\n@@ -356,7 +357,7 @@ impl protocol: gen_init {\n \n         #ast {{\n             let buffer = $(buffer);\n-            do pipes::entangle_buffer(buffer) |buffer, data| {\n+            do pipes::entangle_buffer(move buffer) |buffer, data| {\n                 $(entangle_body)\n             }\n         }}"}]}