{"sha": "e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "node_id": "C_kwDOAAsO6NoAKGU1MjQ1ZWYxZWIyYmFjYjA3ZjdlMjQ3M2I4NDVkODZjM2JkZDFiMDE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-10T00:47:06Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-10T00:47:06Z"}, "message": "interpret: unify offset_from check with offset check", "tree": {"sha": "b83bf7c9fa03c113a2beb1a71c66ec495ecf89d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b83bf7c9fa03c113a2beb1a71c66ec495ecf89d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "html_url": "https://github.com/rust-lang/rust/commit/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be16c6166f08f9b26d854783bbd4ce8d006c8f6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/be16c6166f08f9b26d854783bbd4ce8d006c8f6f", "html_url": "https://github.com/rust-lang/rust/commit/be16c6166f08f9b26d854783bbd4ce8d006c8f6f"}], "stats": {"total": 171, "additions": 87, "deletions": 84}, "files": [{"sha": "e51c51cf45e5ec25cd6fea7db0b632ed55ee3db6", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 70, "deletions": 67, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "patch": "@@ -313,78 +313,82 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let a = self.read_pointer(&args[0])?;\n                 let b = self.read_pointer(&args[1])?;\n \n-                // Special case: if both scalars are *equal integers*\n-                // and not null, we pretend there is an allocation of size 0 right there,\n-                // and their offset is 0. (There's never a valid object at null, making it an\n-                // exception from the exception.)\n-                // This is the dual to the special exception for offset-by-0\n-                // in the inbounds pointer offset operation (see `ptr_offset_inbounds` below).\n-                match (self.ptr_try_get_alloc_id(a), self.ptr_try_get_alloc_id(b)) {\n-                    (Err(a), Err(b)) if a == b && a != 0 => {\n-                        // Both are the same non-null integer.\n-                        self.write_scalar(Scalar::from_machine_isize(0, self), dest)?;\n-                    }\n-                    (Err(offset), _) | (_, Err(offset)) => {\n-                        throw_ub!(DanglingIntPointer(offset, CheckInAllocMsg::OffsetFromTest));\n-                    }\n-                    (Ok((a_alloc_id, a_offset, _)), Ok((b_alloc_id, b_offset, _))) => {\n-                        // Both are pointers. They must be into the same allocation.\n-                        if a_alloc_id != b_alloc_id {\n-                            throw_ub_format!(\n-                                \"{} cannot compute offset of pointers into different allocations.\",\n-                                intrinsic_name,\n-                            );\n+                let usize_layout = self.layout_of(self.tcx.types.usize)?;\n+                let isize_layout = self.layout_of(self.tcx.types.isize)?;\n+\n+                // Get offsets for both that are at least relative to the same base.\n+                let (a_offset, b_offset) =\n+                    match (self.ptr_try_get_alloc_id(a), self.ptr_try_get_alloc_id(b)) {\n+                        (Err(a), Err(b)) => {\n+                            // Neither poiner points to an allocation.\n+                            // If these are inequal or null, this *will* fail the deref check below.\n+                            (a, b)\n                         }\n-                        // And they must both be valid for zero-sized accesses (\"in-bounds or one past the end\").\n-                        self.check_ptr_access_align(\n-                            a,\n-                            Size::ZERO,\n-                            Align::ONE,\n-                            CheckInAllocMsg::OffsetFromTest,\n-                        )?;\n-                        self.check_ptr_access_align(\n-                            b,\n-                            Size::ZERO,\n-                            Align::ONE,\n-                            CheckInAllocMsg::OffsetFromTest,\n-                        )?;\n-\n-                        if intrinsic_name == sym::ptr_offset_from_unsigned && a_offset < b_offset {\n+                        (Err(_), _) | (_, Err(_)) => {\n+                            // We managed to find a valid allocation for one pointer, but not the other.\n+                            // That means they are definitely not pointing to the same allocation.\n                             throw_ub_format!(\n-                                \"{} cannot compute a negative offset, but {} < {}\",\n-                                intrinsic_name,\n-                                a_offset.bytes(),\n-                                b_offset.bytes(),\n+                                \"{} called on pointers into different allocations\",\n+                                intrinsic_name\n                             );\n                         }\n-\n-                        // Compute offset.\n-                        let usize_layout = self.layout_of(self.tcx.types.usize)?;\n-                        let isize_layout = self.layout_of(self.tcx.types.isize)?;\n-                        let ret_layout = if intrinsic_name == sym::ptr_offset_from {\n-                            isize_layout\n-                        } else {\n-                            usize_layout\n-                        };\n-\n-                        // The subtraction is always done in `isize` to enforce\n-                        // the \"no more than `isize::MAX` apart\" requirement.\n-                        let a_offset = ImmTy::from_uint(a_offset.bytes(), isize_layout);\n-                        let b_offset = ImmTy::from_uint(b_offset.bytes(), isize_layout);\n-                        let (val, overflowed, _ty) =\n-                            self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n-                        if overflowed {\n-                            throw_ub_format!(\"Pointers were too far apart for {}\", intrinsic_name);\n+                        (Ok((a_alloc_id, a_offset, _)), Ok((b_alloc_id, b_offset, _))) => {\n+                            // Found allocation for both. They must be into the same allocation.\n+                            if a_alloc_id != b_alloc_id {\n+                                throw_ub_format!(\n+                                    \"{} called on pointers into different allocations\",\n+                                    intrinsic_name\n+                                );\n+                            }\n+                            // Use these offsets for distance calculation.\n+                            (a_offset.bytes(), b_offset.bytes())\n                         }\n-\n-                        let pointee_layout = self.layout_of(substs.type_at(0))?;\n-                        // This re-interprets an isize at ret_layout, but we already checked\n-                        // that if ret_layout is usize, then the result must be non-negative.\n-                        let val = ImmTy::from_scalar(val, ret_layout);\n-                        let size = ImmTy::from_int(pointee_layout.size.bytes(), ret_layout);\n-                        self.exact_div(&val, &size, dest)?;\n+                    };\n+\n+                // Compute distance.\n+                let distance = {\n+                    // The subtraction is always done in `isize` to enforce\n+                    // the \"no more than `isize::MAX` apart\" requirement.\n+                    let a_offset = ImmTy::from_uint(a_offset, isize_layout);\n+                    let b_offset = ImmTy::from_uint(b_offset, isize_layout);\n+                    let (val, overflowed, _ty) =\n+                        self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n+                    if overflowed {\n+                        throw_ub_format!(\"pointers were too far apart for {}\", intrinsic_name);\n                     }\n+                    val.to_machine_isize(self)?\n+                };\n+\n+                // Check that the range between them is dereferenceable (\"in-bounds or one past the\n+                // end of the same allocation\"). This is like the check in ptr_offset_inbounds.\n+                let min_ptr = if distance >= 0 { b } else { a };\n+                self.check_ptr_access_align(\n+                    min_ptr,\n+                    Size::from_bytes(distance.unsigned_abs()),\n+                    Align::ONE,\n+                    CheckInAllocMsg::OffsetFromTest,\n+                )?;\n+\n+                if intrinsic_name == sym::ptr_offset_from_unsigned && distance < 0 {\n+                    throw_ub_format!(\n+                        \"{} called when first pointer has smaller offset than second: {} < {}\",\n+                        intrinsic_name,\n+                        a_offset,\n+                        b_offset,\n+                    );\n                 }\n+\n+                // Perform division by size to compute return value.\n+                let ret_layout = if intrinsic_name == sym::ptr_offset_from_unsigned {\n+                    usize_layout\n+                } else {\n+                    isize_layout\n+                };\n+                let pointee_layout = self.layout_of(substs.type_at(0))?;\n+                // If ret_layout is unsigned, we checked that so is the distance, so we are good.\n+                let val = ImmTy::from_int(distance, ret_layout);\n+                let size = ImmTy::from_int(pointee_layout.size.bytes(), ret_layout);\n+                self.exact_div(&val, &size, dest)?;\n             }\n \n             sym::transmute => {\n@@ -575,11 +579,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // memory between these pointers must be accessible. Note that we do not require the\n         // pointers to be properly aligned (unlike a read/write operation).\n         let min_ptr = if offset_bytes >= 0 { ptr } else { offset_ptr };\n-        let size = offset_bytes.unsigned_abs();\n         // This call handles checking for integer/null pointers.\n         self.check_ptr_access_align(\n             min_ptr,\n-            Size::from_bytes(size),\n+            Size::from_bytes(offset_bytes.unsigned_abs()),\n             Align::ONE,\n             CheckInAllocMsg::PointerArithmeticTest,\n         )?;"}, {"sha": "023d5ea34d871ef4bcee985752798d9e14af152f", "filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr?ref=e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "patch": "@@ -243,7 +243,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  ptr_offset_from_unsigned called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -262,7 +262,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  ptr_offset_from_unsigned called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL"}, {"sha": "ed89c253d532c6edb184275f30464aa993d0b667", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "patch": "@@ -243,7 +243,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  ptr_offset_from_unsigned called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -262,7 +262,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  ptr_offset_from_unsigned called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL"}, {"sha": "10e368ba13396ce486a875ac9ebeb6e11e07f5ee", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "patch": "@@ -15,7 +15,7 @@ pub const DIFFERENT_ALLOC: usize = {\n     let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n     let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n     let offset = unsafe { ptr_offset_from(field_ptr, base_ptr) }; //~ERROR evaluation of constant value failed\n-    //~| ptr_offset_from cannot compute offset of pointers into different allocations.\n+    //~| pointers into different allocations\n     offset as usize\n };\n \n@@ -41,7 +41,7 @@ pub const DIFFERENT_INT: isize = { // offset_from with two different integers: l\n     let ptr1 = 8 as *const u8;\n     let ptr2 = 16 as *const u8;\n     unsafe { ptr_offset_from(ptr2, ptr1) } //~ERROR evaluation of constant value failed\n-    //~| 0x10 is not a valid pointer\n+    //~| 0x8 is not a valid pointer\n };\n \n const OUT_OF_BOUNDS_1: isize = {\n@@ -50,7 +50,7 @@ const OUT_OF_BOUNDS_1: isize = {\n     let end_ptr = (start_ptr).wrapping_add(length);\n     // First ptr is out of bounds\n     unsafe { ptr_offset_from(end_ptr, start_ptr) } //~ERROR evaluation of constant value failed\n-    //~| pointer at offset 10 is out-of-bounds\n+    //~| pointer to 10 bytes starting at offset 0 is out-of-bounds\n };\n \n const OUT_OF_BOUNDS_2: isize = {\n@@ -59,7 +59,7 @@ const OUT_OF_BOUNDS_2: isize = {\n     let end_ptr = (start_ptr).wrapping_add(length);\n     // Second ptr is out of bounds\n     unsafe { ptr_offset_from(start_ptr, end_ptr) } //~ERROR evaluation of constant value failed\n-    //~| pointer at offset 10 is out-of-bounds\n+    //~| pointer to 10 bytes starting at offset 0 is out-of-bounds\n };\n \n const OUT_OF_BOUNDS_SAME: isize = {\n@@ -76,15 +76,15 @@ pub const DIFFERENT_ALLOC_UNSIGNED: usize = {\n     let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n     let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n     let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) }; //~ERROR evaluation of constant value failed\n-    //~| ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+    //~| pointers into different allocations\n     offset as usize\n };\n \n const WRONG_ORDER_UNSIGNED: usize = {\n     let a = ['a', 'b', 'c'];\n     let p = a.as_ptr();\n     unsafe { ptr_offset_from_unsigned(p, p.add(2) ) } //~ERROR evaluation of constant value failed\n-    //~| cannot compute a negative offset, but 0 < 8\n+    //~| first pointer has smaller offset than second: 0 < 8\n };\n \n fn main() {}"}, {"sha": "eb7f1d7a6b25283cf4e036912fe7c0ad9b11681e", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "patch": "@@ -2,15 +2,15 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:17:27\n    |\n LL |     let offset = unsafe { ptr_offset_from(field_ptr, base_ptr) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from cannot compute offset of pointers into different allocations.\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from called on pointers into different allocations\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  out-of-bounds offset_from: 0x2a is not a valid pointer\n+   |                  ptr_offset_from called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $DIR/offset_from_ub.rs:23:14\n@@ -34,19 +34,19 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:43:14\n    |\n LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: 0x10 is not a valid pointer\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: 0x8 is not a valid pointer\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:52:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:61:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:69:14\n@@ -58,13 +58,13 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:78:27\n    |\n LL |     let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned called on pointers into different allocations\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:86:14\n    |\n LL |     unsafe { ptr_offset_from_unsigned(p, p.add(2) ) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned cannot compute a negative offset, but 0 < 8\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned called when first pointer has smaller offset than second: 0 < 8\n \n error: aborting due to 10 previous errors\n "}]}