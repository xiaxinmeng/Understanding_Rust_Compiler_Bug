{"sha": "68c2706780031e3aac6cccea0f7b867ad5eff13a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YzI3MDY3ODAwMzFlM2FhYzZjY2NlYTBmN2I4NjdhZDVlZmYxM2E=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-26T21:34:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-28T18:21:48Z"}, "message": "native: Ignore SIGPIPE by default\n\nSome unix platforms will send a SIGPIPE signal instead of returning EPIPE from a\nsyscall by default. The native runtime doesn't install a SIGPIPE handler,\ncausing the program to die immediately in this case. This brings the behavior in\nline with libgreen by ignoring SIGPIPE and propagating EPIPE upwards to the\napplication in the form of an IoError.\n\nCloses #13123", "tree": {"sha": "a125fe5ae4eaa62a69a237ce464dbdbc022dae91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a125fe5ae4eaa62a69a237ce464dbdbc022dae91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68c2706780031e3aac6cccea0f7b867ad5eff13a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68c2706780031e3aac6cccea0f7b867ad5eff13a", "html_url": "https://github.com/rust-lang/rust/commit/68c2706780031e3aac6cccea0f7b867ad5eff13a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68c2706780031e3aac6cccea0f7b867ad5eff13a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8601a3d8b91ad3b653d143307611f2f5c75617e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8601a3d8b91ad3b653d143307611f2f5c75617e", "html_url": "https://github.com/rust-lang/rust/commit/b8601a3d8b91ad3b653d143307611f2f5c75617e"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "59b3437ad9a33968548e8d554284c2a0f1b244d0", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/68c2706780031e3aac6cccea0f7b867ad5eff13a/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c2706780031e3aac6cccea0f7b867ad5eff13a/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=68c2706780031e3aac6cccea0f7b867ad5eff13a", "patch": "@@ -97,6 +97,24 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n     // frames above our current position.\n     let my_stack_bottom = my_stack_top + 20000 - OS_DEFAULT_STACK_ESTIMATE;\n \n+    // When using libgreen, one of the first things that we do is to turn off\n+    // the SIGPIPE signal (set it to ignore). By default, some platforms will\n+    // send a *signal* when a EPIPE error would otherwise be delivered. This\n+    // runtime doesn't install a SIGPIPE handler, causing it to kill the\n+    // program, which isn't exactly what we want!\n+    //\n+    // Hence, we set SIGPIPE to ignore when the program starts up in order to\n+    // prevent this problem.\n+    #[cfg(windows)] fn ignore_sigpipe() {}\n+    #[cfg(unix)] fn ignore_sigpipe() {\n+        use std::libc;\n+        use std::libc::funcs::posix01::signal::signal;\n+        unsafe {\n+            assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != -1);\n+        }\n+    }\n+    ignore_sigpipe();\n+\n     rt::init(argc, argv);\n     let mut exit_code = None;\n     let mut main = Some(main);"}, {"sha": "7496428f672628b469219257c6ba94d25de5ba3b", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/68c2706780031e3aac6cccea0f7b867ad5eff13a/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c2706780031e3aac6cccea0f7b867ad5eff13a/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=68c2706780031e3aac6cccea0f7b867ad5eff13a", "patch": "@@ -266,6 +266,8 @@ pub mod types {\n                 }\n \n                 pub enum timezone {}\n+\n+                pub type sighandler_t = size_t;\n             }\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint};\n@@ -637,6 +639,8 @@ pub mod types {\n                 }\n \n                 pub enum timezone {}\n+\n+                pub type sighandler_t = size_t;\n             }\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint};\n@@ -1206,6 +1210,8 @@ pub mod types {\n                 }\n \n                 pub enum timezone {}\n+\n+                pub type sighandler_t = size_t;\n             }\n \n             pub mod bsd44 {\n@@ -2292,6 +2298,8 @@ pub mod consts {\n             use libc::types::os::arch::c95::{c_int, size_t};\n \n             pub static SIGTRAP : c_int = 5;\n+            pub static SIGPIPE: c_int = 13;\n+            pub static SIG_IGN: size_t = 1;\n \n             pub static GLOB_ERR      : c_int = 1 << 0;\n             pub static GLOB_MARK     : c_int = 1 << 1;\n@@ -2741,6 +2749,8 @@ pub mod consts {\n             use libc::types::os::arch::c95::{c_int, size_t};\n \n             pub static SIGTRAP : c_int = 5;\n+            pub static SIGPIPE: c_int = 13;\n+            pub static SIG_IGN: size_t = 1;\n \n             pub static GLOB_APPEND   : c_int = 0x0001;\n             pub static GLOB_DOOFFS   : c_int = 0x0002;\n@@ -3136,6 +3146,8 @@ pub mod consts {\n             use libc::types::os::arch::c95::{c_int, size_t};\n \n             pub static SIGTRAP : c_int = 5;\n+            pub static SIGPIPE: c_int = 13;\n+            pub static SIG_IGN: size_t = 1;\n \n             pub static GLOB_APPEND   : c_int = 0x0001;\n             pub static GLOB_DOOFFS   : c_int = 0x0002;\n@@ -3838,6 +3850,24 @@ pub mod funcs {\n             }\n         }\n \n+        pub mod signal {\n+            use libc::types::os::arch::c95::c_int;\n+            use libc::types::os::common::posix01::sighandler_t;\n+\n+            #[cfg(not(target_os = \"android\"))]\n+            extern {\n+                pub fn signal(signum: c_int,\n+                              handler: sighandler_t) -> sighandler_t;\n+            }\n+\n+            #[cfg(target_os = \"android\")]\n+            extern {\n+                #[link_name = \"bsd_signal\"]\n+                pub fn signal(signum: c_int,\n+                              handler: sighandler_t) -> sighandler_t;\n+            }\n+        }\n+\n         pub mod wait {\n             use libc::types::os::arch::c95::{c_int};\n             use libc::types::os::arch::posix88::{pid_t};"}, {"sha": "5c62ea2ad21e8a883ef91d65bd1d691607dd953f", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/68c2706780031e3aac6cccea0f7b867ad5eff13a/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c2706780031e3aac6cccea0f7b867ad5eff13a/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=68c2706780031e3aac6cccea0f7b867ad5eff13a", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+\n+// Be sure that when a SIGPIPE would have been received that the entire process\n+// doesn't die in a ball of fire, but rather it's gracefully handled.\n+\n+use std::os;\n+use std::io::{PipeStream, Process};\n+\n+fn test() {\n+    let os::Pipe { input, out } = os::pipe();\n+    let input = PipeStream::open(input);\n+    let mut out = PipeStream::open(out);\n+    drop(input);\n+\n+    let _ = out.write([1]);\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    if args.len() > 1 && args[1].as_slice() == \"test\" {\n+        return test();\n+    }\n+\n+    let mut p = Process::new(args[0], [~\"test\"]).unwrap();\n+    assert!(p.wait().success());\n+}"}]}