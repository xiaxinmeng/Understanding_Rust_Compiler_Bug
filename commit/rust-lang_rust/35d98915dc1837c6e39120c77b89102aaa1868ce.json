{"sha": "35d98915dc1837c6e39120c77b89102aaa1868ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZDk4OTE1ZGMxODM3YzZlMzkxMjBjNzdiODkxMDJhYWExODY4Y2U=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-04-02T14:29:02Z"}, "committer": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-04-02T14:29:02Z"}, "message": "Merge pull request #802 (through #828)\n\nBad Comparison of Upcasted Ints", "tree": {"sha": "682ed77b53403431e1d52d843e7bae8053eaf1d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/682ed77b53403431e1d52d843e7bae8053eaf1d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35d98915dc1837c6e39120c77b89102aaa1868ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35d98915dc1837c6e39120c77b89102aaa1868ce", "html_url": "https://github.com/rust-lang/rust/commit/35d98915dc1837c6e39120c77b89102aaa1868ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35d98915dc1837c6e39120c77b89102aaa1868ce/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c150ae782414da13ee6202b153c38aee50eb4ea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c150ae782414da13ee6202b153c38aee50eb4ea4", "html_url": "https://github.com/rust-lang/rust/commit/c150ae782414da13ee6202b153c38aee50eb4ea4"}, {"sha": "eada860aa74f9b325342ac533c55593beabcc24c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eada860aa74f9b325342ac533c55593beabcc24c", "html_url": "https://github.com/rust-lang/rust/commit/eada860aa74f9b325342ac533c55593beabcc24c"}], "stats": {"total": 260, "additions": 248, "deletions": 12}, "files": [{"sha": "fee6d066e7c26669bbf824f88f58f62a1e13a1e3", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35d98915dc1837c6e39120c77b89102aaa1868ce/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/35d98915dc1837c6e39120c77b89102aaa1868ce/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=35d98915dc1837c6e39120c77b89102aaa1868ce", "patch": "@@ -14,7 +14,7 @@ Table of contents:\n * [License](#license)\n \n ##Lints\n-There are 139 lints included in this crate:\n+There are 140 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -68,6 +68,7 @@ name\n [ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)                         | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n [inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                       | warn    | `#[inline(always)]` is a bad idea in most cases\n [invalid_regex](https://github.com/Manishearth/rust-clippy/wiki#invalid_regex)                                       | deny    | finds invalid regular expressions in `Regex::new(_)` invocations\n+[invalid_upcast_comparisons](https://github.com/Manishearth/rust-clippy/wiki#invalid_upcast_comparisons)             | warn    | a comparison involving an upcast which is always true or false\n [items_after_statements](https://github.com/Manishearth/rust-clippy/wiki#items_after_statements)                     | warn    | finds blocks where an item comes after a statement\n [iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                                     | warn    | for-looping over `_.next()` which is probably not intended\n [len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)                         | warn    | traits and impls that have `.len()` but not `.is_empty()`"}, {"sha": "f3fc453cf69b10826f042ed3afb1ca938b548151", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35d98915dc1837c6e39120c77b89102aaa1868ce/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d98915dc1837c6e39120c77b89102aaa1868ce/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=35d98915dc1837c6e39120c77b89102aaa1868ce", "patch": "@@ -221,6 +221,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     });\n     reg.register_late_lint_pass(box drop_ref::DropRefPass);\n     reg.register_late_lint_pass(box types::AbsurdExtremeComparisons);\n+    reg.register_late_lint_pass(box types::InvalidUpcastComparisons);\n     reg.register_late_lint_pass(box regex::RegexPass::default());\n     reg.register_late_lint_pass(box copies::CopyAndPaste);\n     reg.register_late_lint_pass(box format::FormatMacLint);\n@@ -369,6 +370,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         types::ABSURD_EXTREME_COMPARISONS,\n         types::BOX_VEC,\n         types::CHAR_LIT_AS_U8,\n+        types::INVALID_UPCAST_COMPARISONS,\n         types::LET_UNIT_VALUE,\n         types::LINKEDLIST,\n         types::TYPE_COMPLEXITY,"}, {"sha": "cc618453132f2ab88ad6a51e79d215e9ed764fc3", "filename": "src/types.rs", "status": "modified", "additions": 185, "deletions": 11, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/35d98915dc1837c6e39120c77b89102aaa1868ce/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d98915dc1837c6e39120c77b89102aaa1868ce/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=35d98915dc1837c6e39120c77b89102aaa1868ce", "patch": "@@ -5,6 +5,7 @@ use rustc::ty;\n use rustc_front::hir::*;\n use rustc_front::intravisit::{FnKind, Visitor, walk_ty};\n use rustc_front::util::{is_comparison_binop, binop_to_string};\n+use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n use utils::*;\n@@ -640,23 +641,20 @@ enum AbsurdComparisonResult {\n     InequalityImpossible,\n }\n \n+\n+\n fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n                                 -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n     use types::ExtremeType::*;\n     use types::AbsurdComparisonResult::*;\n+    use utils::comparisons::*;\n     type Extr<'a> = ExtremeExpr<'a>;\n \n-    // Put the expression in the form lhs < rhs or lhs <= rhs.\n-    enum Rel {\n-        Lt,\n-        Le,\n-    };\n-    let (rel, normalized_lhs, normalized_rhs) = match op {\n-        BiLt => (Rel::Lt, lhs, rhs),\n-        BiLe => (Rel::Le, lhs, rhs),\n-        BiGt => (Rel::Lt, rhs, lhs),\n-        BiGe => (Rel::Le, rhs, lhs),\n-        _ => return None,\n+    let normalized = normalize_comparison(op, lhs, rhs);\n+    let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n+        val\n+    } else {\n+        return None;\n     };\n \n     let lx = detect_extreme_expr(cx, normalized_lhs);\n@@ -679,6 +677,7 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n                 _ => return None,\n             }\n         }\n+        Rel::Ne | Rel::Eq => return None,\n     })\n }\n \n@@ -778,3 +777,178 @@ impl LateLintPass for AbsurdExtremeComparisons {\n         }\n     }\n }\n+\n+/// **What it does:** This lint checks for comparisons where the relation is always either true or false, but where one side has been upcast so that the comparison is necessary. Only integer types are checked.\n+///\n+/// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300` will mistakenly imply that it is possible for `x` to be outside the range of `u8`.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `let x : u8 = ...; (x as u32) > 300`\n+declare_lint! {\n+    pub INVALID_UPCAST_COMPARISONS, Warn,\n+    \"a comparison involving an upcast which is always true or false\"\n+}\n+\n+pub struct InvalidUpcastComparisons;\n+\n+impl LintPass for InvalidUpcastComparisons {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(INVALID_UPCAST_COMPARISONS)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq)]\n+enum FullInt {\n+    S(i64),\n+    U(u64),\n+}\n+\n+impl FullInt {\n+    #[allow(cast_sign_loss)]\n+    fn cmp_s_u(s: i64, u: u64) -> Ordering {\n+        if s < 0 {\n+            Ordering::Less\n+        } else if u > (i64::max_value() as u64) {\n+            Ordering::Greater\n+        } else {\n+            (s as u64).cmp(&u)\n+        }\n+    }\n+}\n+\n+impl PartialEq for FullInt {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other).expect(\"partial_cmp only returns Some(_)\") == Ordering::Equal\n+    }\n+}\n+\n+impl PartialOrd for FullInt {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(match (self, other) {\n+            (&FullInt::S(s), &FullInt::S(o)) => s.cmp(&o),\n+            (&FullInt::U(s), &FullInt::U(o)) => s.cmp(&o),\n+            (&FullInt::S(s), &FullInt::U(o)) => Self::cmp_s_u(s, o),\n+            (&FullInt::U(s), &FullInt::S(o)) => Self::cmp_s_u(o, s).reverse(),\n+        })\n+    }\n+}\n+impl Ord for FullInt {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other).expect(\"partial_cmp for FullInt can never return None\")\n+    }\n+}\n+\n+\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n+    use rustc::ty::TypeVariants::{TyInt, TyUint};\n+    use syntax::ast::{IntTy, UintTy};\n+    use std::*;\n+\n+    if let ExprCast(ref cast_exp,_) = expr.node {\n+        match cx.tcx.expr_ty(cast_exp).sty {\n+            TyInt(int_ty) => Some(match int_ty {\n+                IntTy::I8 => (FullInt::S(i8::min_value() as i64), FullInt::S(i8::max_value() as i64)),\n+                IntTy::I16 => (FullInt::S(i16::min_value() as i64), FullInt::S(i16::max_value() as i64)),\n+                IntTy::I32 => (FullInt::S(i32::min_value() as i64), FullInt::S(i32::max_value() as i64)),\n+                IntTy::I64 => (FullInt::S(i64::min_value() as i64), FullInt::S(i64::max_value() as i64)),\n+                IntTy::Is => (FullInt::S(isize::min_value() as i64), FullInt::S(isize::max_value() as i64)),\n+            }),\n+            TyUint(uint_ty) => Some(match uint_ty {\n+                UintTy::U8 => (FullInt::U(u8::min_value() as u64), FullInt::U(u8::max_value() as u64)),\n+                UintTy::U16 => (FullInt::U(u16::min_value() as u64), FullInt::U(u16::max_value() as u64)),\n+                UintTy::U32 => (FullInt::U(u32::min_value() as u64), FullInt::U(u32::max_value() as u64)),\n+                UintTy::U64 => (FullInt::U(u64::min_value() as u64), FullInt::U(u64::max_value() as u64)),\n+                UintTy::Us => (FullInt::U(usize::min_value() as u64), FullInt::U(usize::max_value() as u64)),\n+            }),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n+    use rustc::middle::const_val::ConstVal::*;\n+    use rustc_const_eval::EvalHint::ExprTypeChecked;\n+    use rustc_const_eval::eval_const_expr_partial;\n+    use rustc_const_math::ConstInt;\n+\n+    match eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None) {\n+        Ok(val) => {\n+            if let Integral(const_int) = val {\n+                Some(match const_int.erase_type() {\n+                    ConstInt::InferSigned(x) => FullInt::S(x as i64),\n+                    ConstInt::Infer(x) => FullInt::U(x as u64),\n+                    _ => unreachable!(),\n+                })\n+            } else {\n+                None\n+            }\n+        },\n+        Err(_) => None,\n+    }\n+}\n+\n+fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: bool) {\n+    if let ExprCast(ref cast_val, _) = expr.node {\n+        span_lint(\n+            cx,\n+            INVALID_UPCAST_COMPARISONS,\n+            *span,\n+            &format!(\n+                \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n+                snippet(cx, cast_val.span, \"the expression\"),\n+                if always { \"true\" } else { \"false\" },\n+            )\n+        );\n+    }\n+}\n+\n+fn upcast_comparison_bounds_err(\n+        cx: &LateContext, span: &Span, rel: comparisons::Rel,\n+        lhs_bounds: Option<(FullInt, FullInt)>, lhs: &Expr, rhs: &Expr, invert: bool) {\n+    use utils::comparisons::*;\n+\n+    if let Some((lb, ub)) = lhs_bounds {\n+        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n+            if rel == Rel::Eq || rel == Rel::Ne {\n+                if norm_rhs_val < lb || norm_rhs_val > ub {\n+                    err_upcast_comparison(cx, &span, lhs, rel == Rel::Ne);\n+                }\n+            } else if match rel {\n+                Rel::Lt => if invert { norm_rhs_val < lb } else { ub < norm_rhs_val },\n+                Rel::Le => if invert { norm_rhs_val <= lb  } else { ub <= norm_rhs_val },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n+                err_upcast_comparison(cx, &span, lhs, true)\n+            } else if match rel {\n+                Rel::Lt => if invert { norm_rhs_val >= ub } else { lb >= norm_rhs_val },\n+                Rel::Le => if invert { norm_rhs_val > ub } else { lb > norm_rhs_val },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n+                err_upcast_comparison(cx, &span, lhs, false)\n+            }\n+        }\n+    }\n+}\n+\n+impl LateLintPass for InvalidUpcastComparisons {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n+\n+            let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n+            let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n+                val\n+            } else {\n+                return;\n+            };\n+\n+            let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n+            let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n+\n+            upcast_comparison_bounds_err(cx, &expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n+            upcast_comparison_bounds_err(cx, &expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n+        }\n+    }\n+}"}, {"sha": "a9181b35b3851e624a9ab344cafa68e83524c5b5", "filename": "src/utils/comparisons.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35d98915dc1837c6e39120c77b89102aaa1868ce/src%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d98915dc1837c6e39120c77b89102aaa1868ce/src%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fcomparisons.rs?ref=35d98915dc1837c6e39120c77b89102aaa1868ce", "patch": "@@ -0,0 +1,23 @@\n+use rustc_front::hir::{BinOp_, Expr};\n+\n+#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n+pub enum Rel {\n+    Lt,\n+    Le,\n+    Eq,\n+    Ne,\n+}\n+\n+/// Put the expression in the form  `lhs < rhs` or `lhs <= rhs`.\n+pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n+                                -> Option<(Rel, &'a Expr, &'a Expr)> {\n+    match op {\n+        BinOp_::BiLt => Some((Rel::Lt, lhs, rhs)),\n+        BinOp_::BiLe => Some((Rel::Le, lhs, rhs)),\n+        BinOp_::BiGt => Some((Rel::Lt, rhs, lhs)),\n+        BinOp_::BiGe => Some((Rel::Le, rhs, lhs)),\n+        BinOp_::BiEq => Some((Rel::Eq, rhs, lhs)),\n+        BinOp_::BiNe => Some((Rel::Ne, rhs, lhs)),\n+        _ => None,\n+    }\n+}"}, {"sha": "7607ef31486b18ccd28e679a2b27ed66e733d938", "filename": "src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35d98915dc1837c6e39120c77b89102aaa1868ce/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d98915dc1837c6e39120c77b89102aaa1868ce/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=35d98915dc1837c6e39120c77b89102aaa1868ce", "patch": "@@ -19,6 +19,7 @@ use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n+pub mod comparisons;\n pub mod conf;\n mod hir;\n pub use self::hir::{SpanlessEq, SpanlessHash};"}, {"sha": "443dd89aab9e3d0bb6403ae497963ef372ed9089", "filename": "tests/compile-fail/invalid_upcast_comparisons.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35d98915dc1837c6e39120c77b89102aaa1868ce/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d98915dc1837c6e39120c77b89102aaa1868ce/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs?ref=35d98915dc1837c6e39120c77b89102aaa1868ce", "patch": "@@ -0,0 +1,35 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(invalid_upcast_comparisons)]\n+#![allow(unused, eq_op, no_effect)]\n+fn main() {\n+    let zero: u32 = 0;\n+    let u8_max: u8 = 255;\n+\n+    (u8_max as u32) > 300; //~ERROR because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n+    (u8_max as u32) > 20;\n+\n+    (zero as i32) < -5; //~ERROR because of the numeric bounds on `zero` prior to casting, this expression is always false\n+    (zero as i32) < 10;\n+\n+    -5 < (zero as i32); //~ERROR because of the numeric bounds on `zero` prior to casting, this expression is always true\n+    0 <= (zero as i32); //~ERROR because of the numeric bounds on `zero` prior to casting, this expression is always true\n+    0 < (zero as i32);\n+\n+    -5 > (zero as i32); //~ERROR because of the numeric bounds on `zero` prior to casting, this expression is always false\n+    -5 >= (u8_max as i32); //~ERROR because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n+    1337 == (u8_max as i32); //~ERROR because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n+\n+    -5 == (zero as i32); //~ERROR because of the numeric bounds on `zero` prior to casting, this expression is always false\n+    -5 != (u8_max as i32); //~ERROR because of the numeric bounds on `u8_max` prior to casting, this expression is always true\n+\n+    // Those are Ok:\n+    42 == (u8_max as i32);\n+    42 != (u8_max as i32);\n+    42 > (u8_max as i32);\n+    (u8_max as i32) == 42;\n+    (u8_max as i32) != 42;\n+    (u8_max as i32) > 42;\n+    (u8_max as i32) < 42;\n+}"}]}