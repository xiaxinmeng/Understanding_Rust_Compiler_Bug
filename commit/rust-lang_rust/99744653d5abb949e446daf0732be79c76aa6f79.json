{"sha": "99744653d5abb949e446daf0732be79c76aa6f79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NzQ0NjUzZDVhYmI5NDllNDQ2ZGFmMDczMmJlNzljNzZhYTZmNzk=", "commit": {"author": {"name": "Alan Andrade", "email": "alan.andradec@gmail.com", "date": "2014-05-24T20:15:48Z"}, "committer": {"name": "Alan Andrade", "email": "alan.andradec@gmail.com", "date": "2014-05-24T20:15:48Z"}, "message": "get over bold text madness, changes per PR, brought the \"returning pointers\" section back to pointers guide", "tree": {"sha": "5327f65e65e33161e658ca63e4c4f02bac079175", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5327f65e65e33161e658ca63e4c4f02bac079175"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99744653d5abb949e446daf0732be79c76aa6f79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99744653d5abb949e446daf0732be79c76aa6f79", "html_url": "https://github.com/rust-lang/rust/commit/99744653d5abb949e446daf0732be79c76aa6f79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99744653d5abb949e446daf0732be79c76aa6f79/comments", "author": {"login": "alan-andrade", "id": 97609, "node_id": "MDQ6VXNlcjk3NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/97609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alan-andrade", "html_url": "https://github.com/alan-andrade", "followers_url": "https://api.github.com/users/alan-andrade/followers", "following_url": "https://api.github.com/users/alan-andrade/following{/other_user}", "gists_url": "https://api.github.com/users/alan-andrade/gists{/gist_id}", "starred_url": "https://api.github.com/users/alan-andrade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alan-andrade/subscriptions", "organizations_url": "https://api.github.com/users/alan-andrade/orgs", "repos_url": "https://api.github.com/users/alan-andrade/repos", "events_url": "https://api.github.com/users/alan-andrade/events{/privacy}", "received_events_url": "https://api.github.com/users/alan-andrade/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alan-andrade", "id": 97609, "node_id": "MDQ6VXNlcjk3NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/97609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alan-andrade", "html_url": "https://github.com/alan-andrade", "followers_url": "https://api.github.com/users/alan-andrade/followers", "following_url": "https://api.github.com/users/alan-andrade/following{/other_user}", "gists_url": "https://api.github.com/users/alan-andrade/gists{/gist_id}", "starred_url": "https://api.github.com/users/alan-andrade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alan-andrade/subscriptions", "organizations_url": "https://api.github.com/users/alan-andrade/orgs", "repos_url": "https://api.github.com/users/alan-andrade/repos", "events_url": "https://api.github.com/users/alan-andrade/events{/privacy}", "received_events_url": "https://api.github.com/users/alan-andrade/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64dad2cb0333e12d0e5b4bb4e9b013af68f14156", "url": "https://api.github.com/repos/rust-lang/rust/commits/64dad2cb0333e12d0e5b4bb4e9b013af68f14156", "html_url": "https://github.com/rust-lang/rust/commit/64dad2cb0333e12d0e5b4bb4e9b013af68f14156"}], "stats": {"total": 93, "additions": 67, "deletions": 26}, "files": [{"sha": "3c0d8c4797c2e18b5b0bdce7b4a37d7cea9aed76", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/99744653d5abb949e446daf0732be79c76aa6f79/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/99744653d5abb949e446daf0732be79c76aa6f79/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=99744653d5abb949e446daf0732be79c76aa6f79", "patch": "@@ -45,12 +45,11 @@ let on_the_heap  : Box<Point> = box Point {x: 7.0, y: 9.0};\n \n Suppose we wanted to write a procedure that computed the distance between any\n two points, no matter where they were stored. One option is to define a function\n-that takes two arguments of type `Point`\u2014that is, it takes the points __by value__.\n-But if we define it this way, calling the function will cause the points __to be\n-copied__. For points, this is probably not so bad, but often copies are\n-expensive. Worse, if the data type contains mutable fields, copying can change\n-the semantics of your program in unexpected ways. So we'd like to define\n-a function that takes the points just as a __reference__/__borrowed pointer__.\n+that takes two arguments of type `Point`\u2014that is, it takes the points by value.\n+But if we define it this way, calling the function will cause the points to be\n+copied. For points, this is probably not so bad, but often copies are\n+expensive. So we'd like to define a function that takes the points just as\n+a reference.\n \n ~~~\n # struct Point {x: f64, y: f64}\n@@ -62,27 +61,26 @@ fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n }\n ~~~\n \n-Now we can call `compute_distance()`\n+Now we can call `compute_distance()`:\n \n ~~~\n # struct Point {x: f64, y: f64}\n # let on_the_stack :     Point  =     Point{x: 3.0, y: 4.0};\n # let on_the_heap  : Box<Point> = box Point{x: 7.0, y: 9.0};\n # fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&on_the_stack, on_the_heap);\n+compute_distance(&on_the_stack, &*on_the_heap);\n ~~~\n \n Here, the `&` operator takes the address of the variable\n `on_the_stack`; this is because `on_the_stack` has the type `Point`\n (that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n-`on_the_stack`, because we have created __an alias__: that is, another\n+`on_the_stack`, because we have created an alias: that is, another\n name for the same data.\n \n-In contrast, we can pass `on_the_heap` to `compute_distance` directly.\n-The compiler automatically converts a box like `Box<Point>` to a reference like\n-`&Point`. This is another form of borrowing: in this case, the caller lends\n-the contents of the box to the callee.\n+For the second argument, we need to grab the contents of `on_the_heap`\n+by using the `*` operator, and then get a reference to that data. In\n+order to convert `Box<T>` into a `&T`, we need to use `&*`.\n \n Whenever a caller lends data to a callee, there are some limitations on what\n the caller can do with the original. For example, if the contents of a\n@@ -166,12 +164,12 @@ as well as from the owned box, and then compute the distance between them.\n \n # Lifetimes\n \n-We\u2019ve seen a few examples of borrowing data. Up till this point, we\u2019ve glossed\n+We\u2019ve seen a few examples of borrowing data. To this point, we\u2019ve glossed\n over issues of safety. As stated in the introduction, at runtime a reference\n is simply a pointer, nothing more. Therefore, avoiding C's problems with\n dangling pointers requires a compile-time safety check.\n \n-The basis for the check is the notion of __lifetimes__. A lifetime is a\n+The basis for the check is the notion of _lifetimes_. A lifetime is a\n static approximation of the span of execution during which the pointer\n is valid: it always corresponds to some expression or block within the\n program.\n@@ -324,7 +322,7 @@ circle constant][tau] and not that dreadfully outdated notion of pi).\n \n The second match is more interesting. Here we match against a\n rectangle and extract its size: but rather than copy the `size`\n-struct, we use a __by-reference binding__ to create a pointer to it. In\n+struct, we use a by-reference binding to create a pointer to it. In\n other words, a pattern binding like `ref size` binds the name `size`\n to a pointer of type `&size` into the _interior of the enum_.\n "}, {"sha": "248142851b70915c043150cfe9f24efa7a1f2967", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 53, "deletions": 10, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/99744653d5abb949e446daf0732be79c76aa6f79/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/99744653d5abb949e446daf0732be79c76aa6f79/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=99744653d5abb949e446daf0732be79c76aa6f79", "patch": "@@ -37,7 +37,7 @@ error: mismatched types: expected `&int` but found `<generic integer #0>` (expec\n \n What gives? It needs a pointer! Therefore I have to use pointers!\"\n \n-Turns out, you don't. __All you need is a reference__. Try this on for size:\n+Turns out, you don't. All you need is a reference. Try this on for size:\n \n ~~~rust\n # fn succ(x: &int) -> int { *x + 1 }\n@@ -74,8 +74,7 @@ Here are the use-cases for pointers. I've prefixed them with the name of the\n pointer that satisfies that use-case:\n \n 1. Owned: `Box<Trait>` must be a pointer, because you don't know the size of the\n-object, so indirection is mandatory. Notation might change once Rust\n-support DST fully so we recommend you stay tuned.\n+object, so indirection is mandatory.\n \n 2. Owned: You need a recursive data structure. These can be infinite sized, so\n indirection is mandatory.\n@@ -89,7 +88,10 @@ common, such as C++, please read \"A note...\" below.\n care about its ownership. If you make the argument a reference, callers\n can send in whatever kind they want.\n \n-Four exceptions. That's it. Otherwise, you shouldn't need them. Be sceptical\n+5. Shared: You need to share data among tasks. You can achieve that via the\n+`Rc` and `Arc` types.\n+\n+Five exceptions. That's it. Otherwise, you shouldn't need them. Be sceptical\n of pointers in Rust: use them for a deliberate purpose, not just to make the\n compiler happy.\n \n@@ -205,10 +207,6 @@ The inner lists _must_ be an owned pointer, because we can't know how many\n elements are in the list. Without knowing the length, we don't know the size,\n and therefore require the indirection that pointers offer.\n \n-> Note: Nil is just part of the List enum and even though is being used\n-> to represent the concept of \"nothing\", you shouldn't think of it as\n-> NULL. Rust doesn't have NULL.\n-\n ## Efficiency\n \n This should almost never be a concern, but because creating an owned pointer\n@@ -284,8 +282,8 @@ fn main() {\n ~~~\n \n This prints `5.83095189`. You can see that the `compute_distance` function\n-takes in two references, but we give it a stack allocated reference and an\n-owned box reference.\n+takes in two references, a reference to a value on the stack, and a reference\n+to a value in a box.\n Of course, if this were a real program, we wouldn't have any of these pointers,\n they're just there to demonstrate the concepts.\n \n@@ -361,6 +359,51 @@ hard for a computer, too! There is an entire [guide devoted to references\n and lifetimes](guide-lifetimes.html) that goes into lifetimes in\n great detail, so if you want the full details, check that out.\n \n+# Returning Pointers\n+\n+We've talked a lot about functions that accept various kinds of pointers, but\n+what about returning them? In general, it is better to let the caller decide\n+how to use a function's output, instead of assuming a certain type of pointer\n+is best.\n+\n+What does that mean? Don't do this:\n+\n+~~~rust\n+fn foo(x: Box<int>) -> Box<int> {\n+    return box *x;\n+}\n+\n+fn main() {\n+    let x = box 5;\n+    let y = foo(x);\n+}\n+~~~\n+\n+Do this:\n+\n+~~~rust\n+fn foo(x: Box<int>) -> int {\n+    return *x;\n+}\n+\n+fn main() {\n+    let x = box 5;\n+    let y = box foo(x);\n+}\n+~~~\n+\n+This gives you flexibility, without sacrificing performance.\n+\n+You may think that this gives us terrible performance: return a value and then\n+immediately box it up ?! Isn't that the worst of both worlds? Rust is smarter\n+than that. There is no copy in this code. `main` allocates enough room for the\n+`box int`, passes a pointer to that memory into `foo` as `x`, and then `foo` writes\n+the value straight into that pointer. This writes the return value directly into\n+the allocated box.\n+\n+This is important enough that it bears repeating: pointers are not for optimizing\n+returning values from your code. Allow the caller to choose how they want to\n+use your output.\n \n # Related Resources\n "}]}