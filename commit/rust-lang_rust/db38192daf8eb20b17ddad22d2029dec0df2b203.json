{"sha": "db38192daf8eb20b17ddad22d2029dec0df2b203", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMzgxOTJkYWY4ZWIyMGIxN2RkYWQyMmQyMDI5ZGVjMGRmMmIyMDM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-07T19:41:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:24Z"}, "message": "mem_categorization -- parameterize over TYPER interface, treat upvar refs as\nderef'd borrowed pointers", "tree": {"sha": "2a5cc7a4d069fba88340fa0890e8649807ef54d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a5cc7a4d069fba88340fa0890e8649807ef54d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db38192daf8eb20b17ddad22d2029dec0df2b203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db38192daf8eb20b17ddad22d2029dec0df2b203", "html_url": "https://github.com/rust-lang/rust/commit/db38192daf8eb20b17ddad22d2029dec0df2b203", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db38192daf8eb20b17ddad22d2029dec0df2b203/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc", "html_url": "https://github.com/rust-lang/rust/commit/d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc"}], "stats": {"total": 623, "additions": 380, "deletions": 243}, "files": [{"sha": "b0e31a8e443947ae360f2bdd7d9c7c1afc5c461d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 380, "deletions": 243, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/db38192daf8eb20b17ddad22d2029dec0df2b203/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db38192daf8eb20b17ddad22d2029dec0df2b203/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=db38192daf8eb20b17ddad22d2029dec0df2b203", "patch": "@@ -22,7 +22,7 @@\n  * forms):\n  *\n  *     E = rvalue    // some computed rvalue\n- *       | x         // address of a local variable, arg, or upvar\n+ *       | x         // address of a local variable or argument\n  *       | *E        // deref of a ptr\n  *       | E.comp    // access to an interior component\n  *\n@@ -44,13 +44,25 @@\n  * themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n  * decomposed into two operations: a derefence to reach the array data and\n  * then an index to jump forward to the relevant item.\n+ *\n+ * ## By-reference upvars\n+ *\n+ * One part of the translation which may be non-obvious is that we translate\n+ * closure upvars into the dereference of a borrow pointer; this more closely\n+ * resembles the runtime translation. So, for example, if we had:\n+ *\n+ *     let mut x = 3;\n+ *     let y = 5;\n+ *     let inc = || x += y;\n+ *\n+ * Then when we categorize `x` (*within* the closure) we would yield a\n+ * result of `*x'`, effectively, where `x'` is a `cat_upvar` reference\n+ * tied to `x`. The type of `x'` will be a borrowed pointer.\n  */\n \n \n use middle::ty;\n-use middle::typeck;\n use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n-use util::common::indenter;\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n@@ -63,15 +75,15 @@ pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n-    cat_stack_upvar(cmt),              // by ref upvar from ||\n+    cat_upvar(ty::UpvarId, ty::UpvarBorrow), // by ref upvar from stack closure\n     cat_local(ast::NodeId),            // local variable\n     cat_arg(ast::NodeId),              // formal argument\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n-    cat_downcast(cmt),                 // selects a particular enum variant (..)\n+    cat_downcast(cmt),                 // selects a particular enum variant (*1)\n     cat_discr(cmt, ast::NodeId),       // match discriminant (see preserve())\n \n-    // (..) downcast is only required if the enum has more than one variant\n+    // (*1) downcast is only required if the enum has more than one variant\n }\n \n #[deriving(Eq)]\n@@ -83,10 +95,10 @@ pub struct CopiedUpvar {\n // different kinds of pointers:\n #[deriving(Eq, IterBytes)]\n pub enum PointerKind {\n-    uniq_ptr,\n-    gc_ptr,\n-    region_ptr(ast::Mutability, ty::Region),\n-    unsafe_ptr(ast::Mutability)\n+    OwnedPtr,\n+    GcPtr,\n+    BorrowedPtr(ty::BorrowKind, ty::Region),\n+    UnsafePtr(ast::Mutability),\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -114,7 +126,7 @@ pub enum ElementKind {\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable.\n-    McInherited  // Inherited from the fact that owner is mutable.\n+    McInherited, // Inherited from the fact that owner is mutable.\n }\n \n // `cmt`: \"Category, Mutability, and Type\".\n@@ -159,30 +171,32 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         ty::ty_vec(_, ty::vstore_uniq) |\n         ty::ty_str(ty::vstore_uniq) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n-            Some(deref_ptr(uniq_ptr))\n+            Some(deref_ptr(OwnedPtr))\n         }\n \n         ty::ty_rptr(r, mt) |\n         ty::ty_vec(mt, ty::vstore_slice(r)) => {\n-            Some(deref_ptr(region_ptr(mt.mutbl, r)))\n+            let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n+            Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n         ty::ty_trait(_, _, ty::RegionTraitStore(r), m, _) => {\n-            Some(deref_ptr(region_ptr(m, r)))\n+            let kind = ty::BorrowKind::from_mutbl(m);\n+            Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n         ty::ty_str(ty::vstore_slice(r)) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n                                       region: r, ..}) => {\n-            Some(deref_ptr(region_ptr(ast::MutImmutable, r)))\n+            Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n         }\n \n-        ty::ty_box(_) => {\n-            Some(deref_ptr(gc_ptr))\n+        ty::ty_box(..) => {\n+            Some(deref_ptr(GcPtr))\n         }\n \n         ty::ty_ptr(ref mt) => {\n-            Some(deref_ptr(unsafe_ptr(mt.mutbl)))\n+            Some(deref_ptr(UnsafePtr(mt.mutbl)))\n         }\n \n         ty::ty_enum(..) |\n@@ -210,53 +224,7 @@ pub fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n     }\n }\n \n-pub fn cat_expr(tcx: ty::ctxt,\n-                method_map: typeck::method_map,\n-                expr: &ast::Expr)\n-             -> cmt {\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_expr(expr);\n-}\n-\n-pub fn cat_expr_unadjusted(tcx: ty::ctxt,\n-                           method_map: typeck::method_map,\n-                           expr: &ast::Expr)\n-                        -> cmt {\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_expr_unadjusted(expr);\n-}\n-\n-pub fn cat_expr_autoderefd(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    expr: &ast::Expr,\n-    autoderefs: uint) -> cmt\n-{\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_expr_autoderefd(expr, autoderefs);\n-}\n-\n-pub fn cat_def(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    expr_id: ast::NodeId,\n-    expr_span: Span,\n-    expr_ty: ty::t,\n-    def: ast::Def) -> cmt {\n-\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_def(expr_id, expr_span, expr_ty, def);\n-}\n-\n-pub trait ast_node {\n+trait ast_node {\n     fn id(&self) -> ast::NodeId;\n     fn span(&self) -> Span;\n }\n@@ -271,9 +239,37 @@ impl ast_node for ast::Pat {\n     fn span(&self) -> Span { self.span }\n }\n \n-pub struct mem_categorization_ctxt {\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n+pub struct MemCategorizationContext<TYPER> {\n+    typer: TYPER\n+}\n+\n+pub type McResult<T> = Result<T, ()>;\n+\n+/**\n+ * The `Typer` trait provides the interface fro the mem-categorization\n+ * module to the results of the type check. It can be used to query\n+ * the type assigned to an expression node, to inquire after adjustments,\n+ * and so on.\n+ *\n+ * This interface is needed because mem-categorization is used from\n+ * two places: `regionck` and `borrowck`. `regionck` executes before\n+ * type inference is complete, and hence derives types and so on from\n+ * intermediate tables.  This also implies that type errors can occur,\n+ * and hence `node_ty()` and friends return a `Result` type -- any\n+ * error will propagate back up through the mem-categorization\n+ * routines.\n+ *\n+ * In the borrow checker, in contrast, type checking is complete and we\n+ * know that no errors have occurred, so we simply consult the tcx and we\n+ * can be sure that only `Ok` results will occur.\n+ */\n+pub trait Typer {\n+    fn tcx(&self) -> ty::ctxt;\n+    fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t>;\n+    fn adjustment(&mut self, node_id: ast::NodeId) -> Option<@ty::AutoAdjustment>;\n+    fn is_method_call(&mut self, id: ast::NodeId) -> bool;\n+    fn temporary_scope(&mut self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n+    fn upvar_borrow(&mut self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n }\n \n impl ToStr for MutabilityCategory {\n@@ -290,18 +286,45 @@ impl MutabilityCategory {\n         }\n     }\n \n+    pub fn from_borrow_kind(borrow_kind: ty::BorrowKind) -> MutabilityCategory {\n+        match borrow_kind {\n+            ty::ImmBorrow => McImmutable,\n+            ty::UniqueImmBorrow => McImmutable,\n+            ty::MutBorrow => McDeclared,\n+        }\n+    }\n+\n+    pub fn from_pointer_kind(base_mutbl: MutabilityCategory,\n+                             ptr: PointerKind) -> MutabilityCategory {\n+        match ptr {\n+            OwnedPtr => {\n+                base_mutbl.inherit()\n+            }\n+            BorrowedPtr(borrow_kind, _) => {\n+                MutabilityCategory::from_borrow_kind(borrow_kind)\n+            }\n+            GcPtr => {\n+                McImmutable\n+            }\n+            UnsafePtr(m) => {\n+                MutabilityCategory::from_mutbl(m)\n+            }\n+        }\n+    }\n+\n     pub fn inherit(&self) -> MutabilityCategory {\n         match *self {\n             McImmutable => McImmutable,\n             McDeclared => McInherited,\n-            McInherited => McInherited\n+            McInherited => McInherited,\n         }\n     }\n \n     pub fn is_mutable(&self) -> bool {\n         match *self {\n             McImmutable => false,\n-            McDeclared | McInherited => true\n+            McInherited => true,\n+            McDeclared => true,\n         }\n     }\n \n@@ -320,55 +343,78 @@ impl MutabilityCategory {\n     }\n }\n \n-impl mem_categorization_ctxt {\n-    pub fn expr_ty(&self, expr: &ast::Expr) -> ty::t {\n-        ty::expr_ty(self.tcx, expr)\n+macro_rules! if_ok(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => { v }\n+            Err(e) => { return Err(e); }\n+        }\n+    )\n+)\n+\n+impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.typer.tcx()\n+    }\n+\n+    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n+        self.typer.adjustment(id)\n+    }\n+\n+    fn expr_ty(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n+        self.typer.node_ty(expr.id)\n     }\n \n-    pub fn pat_ty(&self, pat: &ast::Pat) -> ty::t {\n-        ty::node_id_to_type(self.tcx, pat.id)\n+    fn expr_ty_adjusted(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n+        let unadjusted_ty = if_ok!(self.expr_ty(expr));\n+        let adjustment = self.adjustment(expr.id);\n+        Ok(ty::adjust_ty(self.tcx(), expr.span, unadjusted_ty, adjustment))\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> cmt {\n-        let adjustments = self.tcx.adjustments.borrow();\n-        match adjustments.get().find(&expr.id) {\n+    fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t> {\n+        self.typer.node_ty(id)\n+    }\n+\n+    fn pat_ty(&mut self, pat: @ast::Pat) -> McResult<ty::t> {\n+        self.typer.node_ty(pat.id)\n+    }\n+\n+    pub fn cat_expr(&mut self, expr: &ast::Expr) -> McResult<cmt> {\n+        match self.adjustment(expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n             }\n \n             Some(adjustment) => {\n-                match **adjustment {\n+                match *adjustment {\n                     ty::AutoObject(..) => {\n                         // Implicity casts a concrete object to trait object\n                         // so just patch up the type\n-                        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                        @cmt_ {\n-                            ty: expr_ty,\n-                            ..*self.cat_expr_unadjusted(expr)\n-                        }\n+                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n+                        let expr_cmt = if_ok!(self.cat_expr_unadjusted(expr));\n+                        Ok(@cmt_ {ty: expr_ty, ..*expr_cmt})\n                     }\n \n                     ty::AutoAddEnv(..) => {\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n-                        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n+                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n-                    ty::AutoDerefRef(ty::AutoDerefRef {\n-                        autoref: Some(_),\n-                    ..}) => {\n+                    ty::AutoDerefRef(\n+                        ty::AutoDerefRef {\n+                            autoref: Some(_), ..}) => {\n                         // Equivalent to &*expr or something similar.\n                         // Result is an rvalue.\n-                        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n+                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n-                    ty::AutoDerefRef(ty::AutoDerefRef {\n-                            autoref: None,\n-                            autoderefs: autoderefs\n-                    }) => {\n+                    ty::AutoDerefRef(\n+                        ty::AutoDerefRef {\n+                            autoref: None, autoderefs: autoderefs}) => {\n                         // Equivalent to *expr or something similar.\n                         self.cat_expr_autoderefd(expr, autoderefs)\n                     }\n@@ -377,53 +423,51 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_expr_autoderefd(&self, expr: &ast::Expr, autoderefs: uint)\n-                               -> cmt {\n-        let mut cmt = self.cat_expr_unadjusted(expr);\n+    pub fn cat_expr_autoderefd(&mut self, expr: &ast::Expr, autoderefs: uint)\n+                               -> McResult<cmt> {\n+        let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n         for deref in range(1u, autoderefs + 1) {\n             cmt = self.cat_deref(expr, cmt, deref);\n         }\n-        return cmt;\n+        return Ok(cmt);\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> cmt {\n+    pub fn cat_expr_unadjusted(&mut self, expr: &ast::Expr) -> McResult<cmt> {\n         debug!(\"cat_expr: id={} expr={}\",\n-               expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n+               expr.id,\n+               expr.repr(self.tcx()));\n \n-        let expr_ty = self.expr_ty(expr);\n+        let expr_ty = if_ok!(self.expr_ty(expr));\n         match expr.node {\n           ast::ExprUnary(_, ast::UnDeref, e_base) => {\n-            let method_map = self.method_map.borrow();\n-            if method_map.get().contains_key(&expr.id) {\n-                return self.cat_rvalue_node(expr.id(), expr.span(), expr_ty);\n+            if self.typer.is_method_call(expr.id) {\n+                return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n             }\n \n-            let base_cmt = self.cat_expr(e_base);\n-            self.cat_deref(expr, base_cmt, 0)\n+            let base_cmt = if_ok!(self.cat_expr(e_base));\n+            Ok(self.cat_deref(expr, base_cmt, 0))\n           }\n \n           ast::ExprField(base, f_name, _) => {\n             // Method calls are now a special syntactic form,\n             // so `a.b` should always be a field.\n-            let method_map = self.method_map.borrow();\n-            assert!(!method_map.get().contains_key(&expr.id));\n+            assert!(!self.typer.is_method_call(expr.id));\n \n-            let base_cmt = self.cat_expr(base);\n-            self.cat_field(expr, base_cmt, f_name, self.expr_ty(expr))\n+            let base_cmt = if_ok!(self.cat_expr(base));\n+            Ok(self.cat_field(expr, base_cmt, f_name, expr_ty))\n           }\n \n           ast::ExprIndex(_, base, _) => {\n-            let method_map = self.method_map.borrow();\n-            if method_map.get().contains_key(&expr.id) {\n-                return self.cat_rvalue_node(expr.id(), expr.span(), expr_ty);\n+            if self.typer.is_method_call(expr.id) {\n+                return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n             }\n \n-            let base_cmt = self.cat_expr(base);\n-            self.cat_index(expr, base_cmt, 0)\n+            let base_cmt = if_ok!(self.cat_expr(base));\n+            Ok(self.cat_index(expr, base_cmt, 0))\n           }\n \n           ast::ExprPath(_) => {\n-            let def_map = self.tcx.def_map.borrow();\n+            let def_map = self.tcx().def_map.borrow();\n             let def = def_map.get().get_copy(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n@@ -441,49 +485,48 @@ impl mem_categorization_ctxt {\n           ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n           ast::ExprInlineAsm(..) | ast::ExprBox(..) => {\n-            return self.cat_rvalue_node(expr.id(), expr.span(), expr_ty);\n+            Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n \n           ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")\n         }\n     }\n \n-    pub fn cat_def(&self,\n+    pub fn cat_def(&mut self,\n                    id: ast::NodeId,\n                    span: Span,\n                    expr_ty: ty::t,\n                    def: ast::Def)\n-                   -> cmt {\n+                   -> McResult<cmt> {\n         debug!(\"cat_def: id={} expr={}\",\n-               id, ty_to_str(self.tcx, expr_ty));\n-\n+               id, expr_ty.repr(self.tcx()));\n \n         match def {\n           ast::DefStruct(..) | ast::DefVariant(..) => {\n-                self.cat_rvalue_node(id, span, expr_ty)\n+                Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           ast::DefFn(..) | ast::DefStaticMethod(..) | ast::DefMod(_) |\n           ast::DefForeignMod(_) | ast::DefStatic(_, false) |\n           ast::DefUse(_) | ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n           ast::DefTyParam(..) | ast::DefTyParamBinder(..) | ast::DefRegion(_) |\n           ast::DefLabel(_) | ast::DefSelfTy(..) | ast::DefMethod(..) => {\n-              @cmt_ {\n+              Ok(@cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McImmutable,\n                   ty:expr_ty\n-              }\n+              })\n           }\n \n           ast::DefStatic(_, true) => {\n-              @cmt_ {\n+              Ok(@cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McDeclared,\n                   ty:expr_ty\n-              }\n+              })\n           }\n \n           ast::DefArg(vid, binding_mode) => {\n@@ -495,17 +538,17 @@ impl mem_categorization_ctxt {\n                 ast::BindByValue(ast::MutMutable) => McDeclared,\n                 _ => McImmutable\n             };\n-            @cmt_ {\n+            Ok(@cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_arg(vid),\n                 mutbl: m,\n                 ty:expr_ty\n-            }\n+            })\n           }\n \n-          ast::DefUpvar(upvar_id, inner, fn_node_id, _) => {\n-              let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n+          ast::DefUpvar(var_id, _, fn_node_id, _) => {\n+              let ty = if_ok!(self.node_ty(fn_node_id));\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n                       // Decide whether to use implicit reference or by copy/move\n@@ -523,33 +566,25 @@ impl mem_categorization_ctxt {\n \n                       };\n                       if var_is_refd {\n-                          let upvar_cmt =\n-                              self.cat_def(id, span, expr_ty, *inner);\n-                          @cmt_ {\n-                              id:id,\n-                              span:span,\n-                              cat:cat_stack_upvar(upvar_cmt),\n-                              mutbl:upvar_cmt.mutbl.inherit(),\n-                              ty:upvar_cmt.ty\n-                          }\n+                          self.cat_upvar(id, span, var_id, fn_node_id)\n                       } else {\n                           // FIXME #2152 allow mutation of moved upvars\n-                          @cmt_ {\n+                          Ok(@cmt_ {\n                               id:id,\n                               span:span,\n                               cat:cat_copied_upvar(CopiedUpvar {\n-                                  upvar_id: upvar_id,\n+                                  upvar_id: var_id,\n                                   onceness: closure_ty.onceness}),\n                               mutbl:McImmutable,\n                               ty:expr_ty\n-                          }\n+                          })\n                       }\n                   }\n                   _ => {\n-                      self.tcx.sess.span_bug(\n+                      self.tcx().sess.span_bug(\n                           span,\n-                          format!(\"upvar of non-closure {:?} - {}\",\n-                               fn_node_id, ty.repr(self.tcx)));\n+                          format!(\"Upvar of non-closure {} - {}\",\n+                                  fn_node_id, ty.repr(self.tcx())));\n                   }\n               }\n           }\n@@ -562,19 +597,73 @@ impl mem_categorization_ctxt {\n                 _ => McImmutable\n             };\n \n-            @cmt_ {\n+            Ok(@cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n                 mutbl: m,\n                 ty: expr_ty\n-            }\n+            })\n           }\n         }\n     }\n \n-    pub fn cat_rvalue_node(&self, id: ast::NodeId, span: Span, expr_ty: ty::t) -> cmt {\n-        match self.tcx.region_maps.temporary_scope(id) {\n+    fn cat_upvar(&mut self,\n+                 id: ast::NodeId,\n+                 span: Span,\n+                 var_id: ast::NodeId,\n+                 fn_node_id: ast::NodeId)\n+                 -> McResult<cmt> {\n+        /*!\n+         * Upvars through a closure are in fact indirect\n+         * references. That is, when a closure refers to a\n+         * variable from a parent stack frame like `x = 10`,\n+         * that is equivalent to `*x_ = 10` where `x_` is a\n+         * borrowed pointer (`&mut x`) created when the closure\n+         * was created and store in the environment. This\n+         * equivalence is expose in the mem-categorization.\n+         */\n+\n+        let upvar_id = ty::UpvarId { var_id: var_id,\n+                                     closure_expr_id: fn_node_id };\n+\n+        let upvar_borrow = self.typer.upvar_borrow(upvar_id);\n+\n+        let var_ty = if_ok!(self.node_ty(var_id));\n+\n+        // We can't actually represent the types of all upvars\n+        // as user-describable types, since upvars support const\n+        // and unique-imm borrows! Therefore, we cheat, and just\n+        // give err type. Nobody should be inspecting this type anyhow.\n+        let upvar_ty = ty::mk_err();\n+\n+        let base_cmt = @cmt_ {\n+            id:id,\n+            span:span,\n+            cat:cat_upvar(upvar_id, upvar_borrow),\n+            mutbl:McImmutable,\n+            ty:upvar_ty,\n+        };\n+\n+        let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n+\n+        let deref_cmt = @cmt_ {\n+            id:id,\n+            span:span,\n+            cat:cat_deref(base_cmt, 0, ptr),\n+            mutbl:MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n+            ty:var_ty,\n+        };\n+\n+        Ok(deref_cmt)\n+    }\n+\n+    pub fn cat_rvalue_node(&mut self,\n+                           id: ast::NodeId,\n+                           span: Span,\n+                           expr_ty: ty::t)\n+                           -> cmt {\n+        match self.typer.temporary_scope(id) {\n             Some(scope) => {\n                 self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n             }\n@@ -584,7 +673,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_rvalue(&self,\n+    pub fn cat_rvalue(&mut self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n@@ -602,7 +691,7 @@ impl mem_categorization_ctxt {\n     /// component is inherited from the base it is a part of. For\n     /// example, a record field is mutable if it is declared mutable\n     /// or if the container is mutable.\n-    pub fn inherited_mutability(&self,\n+    pub fn inherited_mutability(&mut self,\n                                 base_m: MutabilityCategory,\n                                 interior_m: ast::Mutability)\n                                 -> MutabilityCategory {\n@@ -612,7 +701,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_field<N:ast_node>(&self,\n+    pub fn cat_field<N:ast_node>(&mut self,\n                                  node: &N,\n                                  base_cmt: cmt,\n                                  f_name: ast::Ident,\n@@ -627,7 +716,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_deref_fn_or_obj<N:ast_node>(&self,\n+    pub fn cat_deref_fn_or_obj<N:ast_node>(&mut self,\n                                            node: &N,\n                                            base_cmt: cmt,\n                                            deref_cnt: uint)\n@@ -638,49 +727,40 @@ impl mem_categorization_ctxt {\n         // know what type lies at the other end, so we just call it\n         // `()` (the empty tuple).\n \n-        let opaque_ty = ty::mk_tup(self.tcx, ~[]);\n+        let opaque_ty = ty::mk_tup(self.tcx(), ~[]);\n         return self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty);\n     }\n \n-    pub fn cat_deref<N:ast_node>(&self,\n+    pub fn cat_deref<N:ast_node>(&mut self,\n                                  node: &N,\n                                  base_cmt: cmt,\n                                  deref_cnt: uint)\n                                  -> cmt {\n         let mt = match ty::deref(base_cmt.ty, true) {\n             Some(mt) => mt,\n             None => {\n-                self.tcx.sess.span_bug(\n+                self.tcx().sess.span_bug(\n                     node.span(),\n-                    format!(\"explicit deref of non-derefable type: {}\",\n-                         ty_to_str(self.tcx, base_cmt.ty)));\n+                    format!(\"Explicit deref of non-derefable type: {}\",\n+                            base_cmt.ty.repr(self.tcx())));\n             }\n         };\n \n         return self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty);\n     }\n \n-    pub fn cat_deref_common<N:ast_node>(&self,\n+    pub fn cat_deref_common<N:ast_node>(&mut self,\n                                         node: &N,\n                                         base_cmt: cmt,\n                                         deref_cnt: uint,\n                                         deref_ty: ty::t)\n                                         -> cmt {\n-        match deref_kind(self.tcx, base_cmt.ty) {\n+        match deref_kind(self.tcx(), base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n-                let m = match ptr {\n-                    uniq_ptr => {\n-                        base_cmt.mutbl.inherit()\n-                    }\n-                    gc_ptr => {\n-                        McImmutable\n-                    }\n-                    region_ptr(m, _) | unsafe_ptr(m) => {\n-                        MutabilityCategory::from_mutbl(m)\n-                    }\n-                };\n+                let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl,\n+                                                              ptr);\n \n                 @cmt_ {\n                     id:node.id(),\n@@ -704,7 +784,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_index<N:ast_node>(&self,\n+    pub fn cat_index<N:ast_node>(&mut self,\n                                  elt: &N,\n                                  base_cmt: cmt,\n                                  derefs: uint)\n@@ -743,28 +823,18 @@ impl mem_categorization_ctxt {\n         let element_ty = match ty::index(base_cmt.ty) {\n           Some(ref mt) => mt.ty,\n           None => {\n-            self.tcx.sess.span_bug(\n+            self.tcx().sess.span_bug(\n                 elt.span(),\n-                format!(\"explicit index of non-index type `{}`\",\n-                     ty_to_str(self.tcx, base_cmt.ty)));\n+                format!(\"Explicit index of non-index type `{}`\",\n+                     base_cmt.ty.repr(self.tcx())));\n           }\n         };\n \n-        return match deref_kind(self.tcx, base_cmt.ty) {\n+        return match deref_kind(self.tcx(), base_cmt.ty) {\n           deref_ptr(ptr) => {\n             // for unique ptrs, we inherit mutability from the\n             // owning reference.\n-            let m = match ptr {\n-                uniq_ptr => {\n-                    base_cmt.mutbl.inherit()\n-                }\n-                gc_ptr => {\n-                    McImmutable\n-                }\n-                region_ptr(m, _) | unsafe_ptr(m) => {\n-                    MutabilityCategory::from_mutbl(m)\n-                }\n-            };\n+            let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n \n             // the deref is explicit in the resulting cmt\n             let deref_cmt = @cmt_ {\n@@ -775,7 +845,7 @@ impl mem_categorization_ctxt {\n                 ty:element_ty\n             };\n \n-            interior(elt, deref_cmt, base_cmt.ty, m, element_ty)\n+            interior(elt, deref_cmt, base_cmt.ty, m.inherit(), element_ty)\n           }\n \n           deref_interior(_) => {\n@@ -801,7 +871,57 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_imm_interior<N:ast_node>(&self,\n+    pub fn cat_slice_pattern(&mut self,\n+                             vec_cmt: cmt,\n+                             slice_pat: @ast::Pat)\n+                             -> McResult<(cmt, ast::Mutability, ty::Region)> {\n+        /*!\n+         * Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is\n+         * the cmt for `P`, `slice_pat` is the pattern `Q`, returns:\n+         * - a cmt for `Q`\n+         * - the mutability and region of the slice `Q`\n+         *\n+         * These last two bits of info happen to be things that\n+         * borrowck needs.\n+         */\n+\n+        let slice_ty = if_ok!(self.node_ty(slice_pat.id));\n+        let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n+                                                    slice_pat,\n+                                                    slice_ty);\n+        let cmt_slice = self.cat_index(slice_pat, vec_cmt, 0);\n+        return Ok((cmt_slice, slice_mutbl, slice_r));\n+\n+        fn vec_slice_info(tcx: ty::ctxt,\n+                          pat: @ast::Pat,\n+                          slice_ty: ty::t)\n+                          -> (ast::Mutability, ty::Region) {\n+            /*!\n+             * In a pattern like [a, b, ..c], normally `c` has slice type,\n+             * but if you have [a, b, ..ref c], then the type of `ref c`\n+             * will be `&&[]`, so to extract the slice details we have\n+             * to recurse through rptrs.\n+             */\n+\n+            match ty::get(slice_ty).sty {\n+                ty::ty_vec(slice_mt, ty::vstore_slice(slice_r)) => {\n+                    (slice_mt.mutbl, slice_r)\n+                }\n+\n+                ty::ty_rptr(_, ref mt) => {\n+                    vec_slice_info(tcx, pat, mt.ty)\n+                }\n+\n+                _ => {\n+                    tcx.sess.span_bug(\n+                        pat.span,\n+                        format!(\"Type of slice pattern is not a slice\"));\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn cat_imm_interior<N:ast_node>(&mut self,\n                                         node: &N,\n                                         base_cmt: cmt,\n                                         interior_ty: ty::t,\n@@ -816,7 +936,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_downcast<N:ast_node>(&self,\n+    pub fn cat_downcast<N:ast_node>(&mut self,\n                                     node: &N,\n                                     base_cmt: cmt,\n                                     downcast_ty: ty::t)\n@@ -830,10 +950,13 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_pattern(&self,\n+    pub fn cat_pattern(&mut self,\n                        cmt: cmt,\n-                       pat: &ast::Pat,\n-                       op: |cmt, &ast::Pat|) {\n+                       pat: @ast::Pat,\n+                       op: |&mut MemCategorizationContext<TYPER>,\n+                            cmt,\n+                            @ast::Pat|)\n+                       -> McResult<()> {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //\n@@ -846,7 +969,7 @@ impl mem_categorization_ctxt {\n         // we can be sure that the binding will remain valid for the\n         // duration of the arm.\n         //\n-        // (..) There is subtlety concerning the correspondence between\n+        // (*2) There is subtlety concerning the correspondence between\n         // pattern ids and types as compared to *expression* ids and\n         // types. This is explained briefly. on the definition of the\n         // type `cmt`, so go off and read what it says there, then\n@@ -856,7 +979,8 @@ impl mem_categorization_ctxt {\n         // In general, the id of the cmt should be the node that\n         // \"produces\" the value---patterns aren't executable code\n         // exactly, but I consider them to \"execute\" when they match a\n-        // value. So if you have something like:\n+        // value, and I consider them to produce the value that was\n+        // matched. So if you have something like:\n         //\n         //     let x = @@3;\n         //     match x {\n@@ -878,13 +1002,12 @@ impl mem_categorization_ctxt {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        let tcx = self.tcx;\n+        let tcx = self.tcx();\n         debug!(\"cat_pattern: id={} pat={} cmt={}\",\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n                cmt.repr(tcx));\n-        let _i = indenter();\n \n-        op(cmt, pat);\n+        op(self, cmt, pat);\n \n         match pat.node {\n           ast::PatWild | ast::PatWildMulti => {\n@@ -895,56 +1018,56 @@ impl mem_categorization_ctxt {\n             // variant(..)\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n-            let def_map = self.tcx.def_map.borrow();\n+            let def_map = self.tcx().def_map.borrow();\n             match def_map.get().find(&pat.id) {\n                 Some(&ast::DefVariant(enum_did, _, _)) => {\n                     // variant(x, y, z)\n \n                     let downcast_cmt = {\n-                        if ty::enum_is_univariant(tcx, enum_did) {\n+                        if ty::enum_is_univariant(self.tcx(), enum_did) {\n                             cmt // univariant, no downcast needed\n                         } else {\n                             self.cat_downcast(pat, cmt, cmt.ty)\n                         }\n                     };\n \n                     for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(subpat); // see (..)\n+                        let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, downcast_cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n+                        if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&ast::DefFn(..)) |\n                 Some(&ast::DefStruct(..)) => {\n                     for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(subpat); // see (..)\n+                        let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        self.cat_pattern(cmt_field, subpat, |x,y| op(x,y));\n+                        if_ok!(self.cat_pattern(cmt_field, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&ast::DefStatic(..)) => {\n                     for &subpat in subpats.iter() {\n-                        self.cat_pattern(cmt, subpat, |x,y| op(x,y));\n+                        if_ok!(self.cat_pattern(cmt, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 _ => {\n-                    self.tcx.sess.span_bug(\n+                    self.tcx().sess.span_bug(\n                         pat.span,\n                         \"enum pattern didn't resolve to enum or struct\");\n                 }\n             }\n           }\n \n           ast::PatIdent(_, _, Some(subpat)) => {\n-              self.cat_pattern(cmt, subpat, op);\n+              if_ok!(self.cat_pattern(cmt, subpat, op));\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -954,52 +1077,54 @@ impl mem_categorization_ctxt {\n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n-                let field_ty = self.pat_ty(fp.pat); // see (..)\n+                let field_ty = if_ok!(self.pat_ty(fp.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n-                self.cat_pattern(cmt_field, fp.pat, |x,y| op(x,y));\n+                if_ok!(self.cat_pattern(cmt_field, fp.pat, |x,y,z| op(x,y,z)));\n             }\n           }\n \n           ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, &subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = self.pat_ty(subpat); // see (..)\n+                let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt, subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n+                if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n             }\n           }\n \n           ast::PatUniq(subpat) | ast::PatRegion(subpat) => {\n             // @p1, ~p1\n             let subcmt = self.cat_deref(pat, cmt, 0);\n-            self.cat_pattern(subcmt, subpat, op);\n+            if_ok!(self.cat_pattern(subcmt, subpat, op));\n           }\n \n           ast::PatVec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n               for &before_pat in before.iter() {\n-                  self.cat_pattern(elt_cmt, before_pat, |x,y| op(x,y));\n+                  if_ok!(self.cat_pattern(elt_cmt, before_pat, |x,y,z| op(x,y,z)));\n               }\n               for &slice_pat in slice.iter() {\n-                  let slice_ty = self.pat_ty(slice_pat);\n+                  let slice_ty = if_ok!(self.pat_ty(slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n+                  if_ok!(self.cat_pattern(slice_cmt, slice_pat, |x,y,z| op(x,y,z)));\n               }\n               for &after_pat in after.iter() {\n-                  self.cat_pattern(elt_cmt, after_pat, |x,y| op(x,y));\n+                  if_ok!(self.cat_pattern(elt_cmt, after_pat, |x,y,z| op(x,y,z)));\n               }\n           }\n \n           ast::PatLit(_) | ast::PatRange(_, _) => {\n               /*always ok*/\n           }\n         }\n+\n+        Ok(())\n     }\n \n-    pub fn mut_to_str(&self, mutbl: ast::Mutability) -> ~str {\n+    pub fn mut_to_str(&mut self, mutbl: ast::Mutability) -> ~str {\n         match mutbl {\n           MutMutable => ~\"mutable\",\n           MutImmutable => ~\"immutable\"\n@@ -1023,8 +1148,15 @@ impl mem_categorization_ctxt {\n           cat_arg(..) => {\n               ~\"argument\"\n           }\n-          cat_deref(_, _, pk) => {\n-              format!(\"dereference of {} pointer\", ptr_sigil(pk))\n+          cat_deref(base, _, pk) => {\n+              match base.cat {\n+                  cat_upvar(..) => {\n+                      format!(\"captured outer variable\")\n+                  }\n+                  _ => {\n+                      format!(\"dereference of {} pointer\", ptr_sigil(pk))\n+                  }\n+              }\n           }\n           cat_interior(_, InteriorField(NamedField(_))) => {\n               ~\"field\"\n@@ -1041,7 +1173,7 @@ impl mem_categorization_ctxt {\n           cat_interior(_, InteriorElement(OtherElement)) => {\n               ~\"indexed content\"\n           }\n-          cat_stack_upvar(_) => {\n+          cat_upvar(..) => {\n               ~\"captured outer variable\"\n           }\n           cat_discr(cmt, _) => {\n@@ -1054,7 +1186,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn region_to_str(&self, r: ty::Region) -> ~str {\n-        region_ptr_to_str(self.tcx, r)\n+        region_ptr_to_str(self.tcx(), r)\n     }\n }\n \n@@ -1099,7 +1231,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n \n pub enum AliasableReason {\n     AliasableManaged,\n-    AliasableBorrowed(ast::Mutability),\n+    AliasableBorrowed,\n     AliasableOther,\n     AliasableStatic,\n     AliasableStaticMut,\n@@ -1117,16 +1249,16 @@ impl cmt_ {\n             cat_copied_upvar(..) |\n             cat_local(..) |\n             cat_arg(..) |\n-            cat_deref(_, _, unsafe_ptr(..)) |\n-            cat_deref(_, _, gc_ptr) |\n-            cat_deref(_, _, region_ptr(..)) => {\n+            cat_deref(_, _, UnsafePtr(..)) |\n+            cat_deref(_, _, GcPtr(..)) |\n+            cat_deref(_, _, BorrowedPtr(..)) |\n+            cat_upvar(..) => {\n                 @self\n             }\n             cat_downcast(b) |\n-            cat_stack_upvar(b) |\n             cat_discr(b, _) |\n             cat_interior(b, _) |\n-            cat_deref(b, _, uniq_ptr) => {\n+            cat_deref(b, _, OwnedPtr) => {\n                 b.guarantor()\n             }\n         }\n@@ -1143,10 +1275,10 @@ impl cmt_ {\n         // aliased and eventually recused.\n \n         match self.cat {\n-            cat_deref(b, _, region_ptr(MutMutable, _)) |\n+            cat_deref(b, _, BorrowedPtr(ty::MutBorrow, _)) |\n+            cat_deref(b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n             cat_downcast(b) |\n-            cat_stack_upvar(b) |\n-            cat_deref(b, _, uniq_ptr) |\n+            cat_deref(b, _, OwnedPtr) |\n             cat_interior(b, _) |\n             cat_discr(b, _) => {\n                 // Aliasability depends on base cmt\n@@ -1156,8 +1288,9 @@ impl cmt_ {\n             cat_copied_upvar(CopiedUpvar {onceness: ast::Once, ..}) |\n             cat_rvalue(..) |\n             cat_local(..) |\n+            cat_upvar(..) |\n             cat_arg(_) |\n-            cat_deref(_, _, unsafe_ptr(..)) => { // yes, it's aliasable, but...\n+            cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n                 None\n             }\n \n@@ -1173,12 +1306,12 @@ impl cmt_ {\n                 }\n             }\n \n-            cat_deref(_, _, gc_ptr) => {\n+            cat_deref(_, _, GcPtr) => {\n                 Some(AliasableManaged)\n             }\n \n-            cat_deref(_, _, region_ptr(m @ MutImmutable, _)) => {\n-                Some(AliasableBorrowed(m))\n+            cat_deref(_, _, BorrowedPtr(ty::ImmBorrow, _)) => {\n+                Some(AliasableBorrowed)\n             }\n         }\n     }\n@@ -1201,12 +1334,15 @@ impl Repr for categorization {\n             cat_rvalue(..) |\n             cat_copied_upvar(..) |\n             cat_local(..) |\n+            cat_upvar(..) |\n             cat_arg(..) => {\n                 format!(\"{:?}\", *self)\n             }\n             cat_deref(cmt, derefs, ptr) => {\n-                format!(\"{}->({}, {})\", cmt.cat.repr(tcx),\n-                     ptr_sigil(ptr), derefs)\n+                format!(\"{}-{}{}->\",\n+                        cmt.cat.repr(tcx),\n+                        ptr_sigil(ptr),\n+                        derefs)\n             }\n             cat_interior(cmt, interior) => {\n                 format!(\"{}.{}\",\n@@ -1216,20 +1352,21 @@ impl Repr for categorization {\n             cat_downcast(cmt) => {\n                 format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n             }\n-            cat_stack_upvar(cmt) |\n             cat_discr(cmt, _) => {\n                 cmt.cat.repr(tcx)\n             }\n         }\n     }\n }\n \n-pub fn ptr_sigil(ptr: PointerKind) -> ~str {\n+pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     match ptr {\n-        uniq_ptr => ~\"~\",\n-        gc_ptr => ~\"@\",\n-        region_ptr(_, _) => ~\"&\",\n-        unsafe_ptr(_) => ~\"*\"\n+        OwnedPtr => \"~\",\n+        GcPtr => \"@\",\n+        BorrowedPtr(ty::ImmBorrow, _) => \"&\",\n+        BorrowedPtr(ty::MutBorrow, _) => \"&mut\",\n+        BorrowedPtr(ty::UniqueImmBorrow, _) => \"&unique\",\n+        UnsafePtr(_) => \"*\"\n     }\n }\n "}]}