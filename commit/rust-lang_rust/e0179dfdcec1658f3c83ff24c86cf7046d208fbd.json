{"sha": "e0179dfdcec1658f3c83ff24c86cf7046d208fbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMTc5ZGZkY2VjMTY1OGYzYzgzZmYyNGM4NmNmNzA0NmQyMDhmYmQ=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-06-28T22:07:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-28T22:07:13Z"}, "message": "Rollup merge of #51822 - estebank:suggest-more, r=nikomatsakis\n\nProvide existing ref suggestions for more E0308 errors", "tree": {"sha": "e9208c0d7f01fd10ad1bbc42f3a8789604f4b2d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9208c0d7f01fd10ad1bbc42f3a8789604f4b2d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0179dfdcec1658f3c83ff24c86cf7046d208fbd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbNVwRCRBK7hj4Ov3rIwAAdHIIAElzwBH+0RZ43FFOv6y1DTPP\nT4CMQh4DhN1wctLIQVBKUAzD4Hbvsr9K9QaMCc0T2ZjVlyQOi0vie0cLs/P9PN2R\nyqkmWVqY2bcCQIlfQT6Mmj+WFQuEomd746umVTgb7FHZxT8Ug7H4MqUtCFP6do2Z\n+2uBr4aEjtQDZxL2jt7f4XkxGpRIv/QJJqlOvbdyma4uemH1tEoBcQbwjeiLgjNR\n9rMWRSauy8PLRn8hLmQd2j9AEs3t/o4O3uoRGI/TampoOk0jajOqe721fyirMLoW\nzZLeEdkhZsw1TEdQOCwZ5vjimuCHpROofvpHXiV29SrUHKlFbb05x2yXI0RYMXY=\n=SQwx\n-----END PGP SIGNATURE-----\n", "payload": "tree e9208c0d7f01fd10ad1bbc42f3a8789604f4b2d7\nparent 85804f66be86509d5c2e8ff047e2edd47332986b\nparent 54a04b3b036e318dd08d4947e33669c79152ace4\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1530223633 -0600\ncommitter GitHub <noreply@github.com> 1530223633 -0600\n\nRollup merge of #51822 - estebank:suggest-more, r=nikomatsakis\n\nProvide existing ref suggestions for more E0308 errors\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0179dfdcec1658f3c83ff24c86cf7046d208fbd", "html_url": "https://github.com/rust-lang/rust/commit/e0179dfdcec1658f3c83ff24c86cf7046d208fbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0179dfdcec1658f3c83ff24c86cf7046d208fbd/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85804f66be86509d5c2e8ff047e2edd47332986b", "url": "https://api.github.com/repos/rust-lang/rust/commits/85804f66be86509d5c2e8ff047e2edd47332986b", "html_url": "https://github.com/rust-lang/rust/commit/85804f66be86509d5c2e8ff047e2edd47332986b"}, {"sha": "54a04b3b036e318dd08d4947e33669c79152ace4", "url": "https://api.github.com/repos/rust-lang/rust/commits/54a04b3b036e318dd08d4947e33669c79152ace4", "html_url": "https://github.com/rust-lang/rust/commit/54a04b3b036e318dd08d4947e33669c79152ace4"}], "stats": {"total": 97, "additions": 59, "deletions": 38}, "files": [{"sha": "e276dcff0601dca195a53556bd141d68365b28bc", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0179dfdcec1658f3c83ff24c86cf7046d208fbd/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0179dfdcec1658f3c83ff24c86cf7046d208fbd/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e0179dfdcec1658f3c83ff24c86cf7046d208fbd", "patch": "@@ -1203,9 +1203,14 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                                       \"supposed to be part of a block tail expression, but the \\\n                                        expression is empty\");\n                         });\n-                        fcx.suggest_mismatched_types_on_tail(&mut db, expr,\n-                                                             expected, found,\n-                                                             cause.span, blk_id);\n+                        fcx.suggest_mismatched_types_on_tail(\n+                            &mut db,\n+                            expr,\n+                            expected,\n+                            found,\n+                            cause.span,\n+                            blk_id,\n+                        );\n                     }\n                     _ => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);"}, {"sha": "08d8dd2e498b68ff67c437929978b883bd124abe", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e0179dfdcec1658f3c83ff24c86cf7046d208fbd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0179dfdcec1658f3c83ff24c86cf7046d208fbd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e0179dfdcec1658f3c83ff24c86cf7046d208fbd", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::iter;\n-\n use check::FnCtxt;\n use rustc::infer::InferOk;\n use rustc::traits::ObligationCause;\n@@ -140,25 +138,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        if let Some((sp, msg, suggestion)) = self.check_ref(expr, checked_ty, expected) {\n-            err.span_suggestion(sp, msg, suggestion);\n-        } else if !self.check_for_cast(&mut err, expr, expr_ty, expected) {\n-            let methods = self.get_conversion_methods(expr.span, expected, checked_ty);\n-            if let Ok(expr_text) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n-                let suggestions = iter::repeat(expr_text).zip(methods.iter())\n-                    .map(|(receiver, method)| format!(\"{}.{}()\", receiver, method.ident))\n-                    .collect::<Vec<_>>();\n-                if !suggestions.is_empty() {\n-                    err.span_suggestions(expr.span,\n-                                         \"try using a conversion method\",\n-                                         suggestions);\n-                }\n-            }\n-        }\n+        self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n+\n         (expected, Some(err))\n     }\n \n-    fn get_conversion_methods(&self, span: Span, expected: Ty<'tcx>, checked_ty: Ty<'tcx>)\n+    pub fn get_conversion_methods(&self, span: Span, expected: Ty<'tcx>, checked_ty: Ty<'tcx>)\n                               -> Vec<AssociatedItem> {\n         let mut methods = self.probe_for_return_type(span,\n                                                      probe::Mode::MethodCall,\n@@ -261,19 +246,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// In addition of this check, it also checks between references mutability state. If the\n     /// expected is mutable but the provided isn't, maybe we could just say \"Hey, try with\n     /// `&mut`!\".\n-    fn check_ref(&self,\n+    pub fn check_ref(&self,\n                  expr: &hir::Expr,\n                  checked_ty: Ty<'tcx>,\n                  expected: Ty<'tcx>)\n                  -> Option<(Span, &'static str, String)> {\n-        let sp = expr.span;\n+        let cm = self.sess().codemap();\n+        // Use the callsite's span if this is a macro call. #41858\n+        let sp = cm.call_span_if_macro(expr.span);\n+        if !cm.span_to_filename(sp).is_real() {\n+            return None;\n+        }\n+\n         match (&expected.sty, &checked_ty.sty) {\n             (&ty::TyRef(_, exp, _), &ty::TyRef(_, check, _)) => match (&exp.sty, &check.sty) {\n                 (&ty::TyStr, &ty::TyArray(arr, _)) |\n                 (&ty::TyStr, &ty::TySlice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprLit(_) = expr.node {\n-                        let sp = self.sess().codemap().call_span_if_macro(expr.span);\n-                        if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(sp) {\n+                        if let Ok(src) = cm.span_to_snippet(sp) {\n                             return Some((sp,\n                                          \"consider removing the leading `b`\",\n                                          src[1..].to_string()));\n@@ -283,8 +273,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (&ty::TyArray(arr, _), &ty::TyStr) |\n                 (&ty::TySlice(arr), &ty::TyStr) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprLit(_) = expr.node {\n-                        let sp = self.sess().codemap().call_span_if_macro(expr.span);\n-                        if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(sp) {\n+                        if let Ok(src) = cm.span_to_snippet(sp) {\n                             return Some((sp,\n                                          \"consider adding a leading `b`\",\n                                          format!(\"b{}\", src)));\n@@ -311,9 +300,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                        checked_ty),\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n-                    // Use the callsite's span if this is a macro call. #41858\n-                    let sp = self.sess().codemap().call_span_if_macro(expr.span);\n-                    if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(sp) {\n+                    if let Ok(src) = cm.span_to_snippet(sp) {\n                         let sugg_expr = match expr.node { // parenthesize if needed (Issue #46756)\n                             hir::ExprCast(_, _) | hir::ExprBinary(_, _, _) => format!(\"({})\", src),\n                             _ => src,\n@@ -342,11 +329,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // a macro; if so, it's hard to extract the text and make a good\n                 // suggestion, so don't bother.)\n                 if self.infcx.can_sub(self.param_env, checked, &expected).is_ok() &&\n-                   expr.span.ctxt().outer().expn_info().is_none() {\n+                   sp.ctxt().outer().expn_info().is_none() {\n                     match expr.node {\n                         // Maybe remove `&`?\n                         hir::ExprAddrOf(_, ref expr) => {\n-                            if let Ok(code) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                            if !cm.span_to_filename(expr.span).is_real() {\n+                                return None;\n+                            }\n+                            if let Ok(code) = cm.span_to_snippet(expr.span) {\n                                 return Some((sp, \"consider removing the borrow\", code));\n                             }\n                         }\n@@ -355,9 +345,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         _ => {\n                             if !self.infcx.type_moves_by_default(self.param_env,\n                                                                 checked,\n-                                                                expr.span) {\n-                                let sp = self.sess().codemap().call_span_if_macro(expr.span);\n-                                if let Ok(code) = self.tcx.sess.codemap().span_to_snippet(sp) {\n+                                                                sp) {\n+                                let sp = cm.call_span_if_macro(sp);\n+                                if let Ok(code) = cm.span_to_snippet(sp) {\n                                     return Some((sp,\n                                                  \"consider dereferencing the borrow\",\n                                                  format!(\"*{}\", code)));\n@@ -372,7 +362,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    fn check_for_cast(&self,\n+    pub fn check_for_cast(&self,\n                       err: &mut DiagnosticBuilder<'tcx>,\n                       expr: &hir::Expr,\n                       checked_ty: Ty<'tcx>,"}, {"sha": "0185d00518699b0b53cc09681b665ce8dba83034", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0179dfdcec1658f3c83ff24c86cf7046d208fbd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0179dfdcec1658f3c83ff24c86cf7046d208fbd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e0179dfdcec1658f3c83ff24c86cf7046d208fbd", "patch": "@@ -116,6 +116,7 @@ use rustc_data_structures::sync::Lrc;\n use std::collections::hash_map::Entry;\n use std::cmp;\n use std::fmt::Display;\n+use std::iter;\n use std::mem::replace;\n use std::ops::{self, Deref};\n use rustc_target::spec::abi::Abi;\n@@ -4539,10 +4540,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             cause_span: Span,\n                                             blk_id: ast::NodeId) {\n         self.suggest_missing_semicolon(err, expression, expected, cause_span);\n-\n         if let Some((fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n             self.suggest_missing_return_type(err, &fn_decl, expected, found, can_suggest);\n         }\n+        self.suggest_ref_or_into(err, expression, expected, found);\n+    }\n+\n+    pub fn suggest_ref_or_into(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        if let Some((sp, msg, suggestion)) = self.check_ref(expr, found, expected) {\n+            err.span_suggestion(sp, msg, suggestion);\n+        } else if !self.check_for_cast(err, expr, found, expected) {\n+            let methods = self.get_conversion_methods(expr.span, expected, found);\n+            if let Ok(expr_text) = self.sess().codemap().span_to_snippet(expr.span) {\n+                let suggestions = iter::repeat(expr_text).zip(methods.iter())\n+                    .map(|(receiver, method)| format!(\"{}.{}()\", receiver, method.ident))\n+                    .collect::<Vec<_>>();\n+                if !suggestions.is_empty() {\n+                    err.span_suggestions(expr.span, \"try using a conversion method\", suggestions);\n+                }\n+            }\n+        }\n     }\n \n     /// A common error is to forget to add a semicolon at the end of a block:"}, {"sha": "041bae4a421080644c088473bf386227040f847c", "filename": "src/test/ui/suggestions/str-array-assignment.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0179dfdcec1658f3c83ff24c86cf7046d208fbd/src%2Ftest%2Fui%2Fsuggestions%2Fstr-array-assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0179dfdcec1658f3c83ff24c86cf7046d208fbd/src%2Ftest%2Fui%2Fsuggestions%2Fstr-array-assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fstr-array-assignment.stderr?ref=e0179dfdcec1658f3c83ff24c86cf7046d208fbd", "patch": "@@ -14,7 +14,10 @@ LL | fn main() {\n    |           - expected `()` because of default return type\n ...\n LL |   let u: &str = if true { s[..2] } else { s };\n-   |                           ^^^^^^ expected &str, found str\n+   |                           ^^^^^^\n+   |                           |\n+   |                           expected &str, found str\n+   |                           help: consider borrowing here: `&s[..2]`\n    |\n    = note: expected type `&str`\n               found type `str`"}]}