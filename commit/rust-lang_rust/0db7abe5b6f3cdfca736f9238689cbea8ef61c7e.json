{"sha": "0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYjdhYmU1YjZmM2NkZmNhNzM2ZjkyMzg2ODljYmVhOGVmNjFjN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-30T23:36:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-30T23:36:10Z"}, "message": "Auto merge of #54004 - tromey:enum-debuginfo, r=tromey\n\nFix DWARF generation for enums\n\nThe DWARF generated for Rust enums was always somewhat unusual.\nRather than using DWARF constructs directly, it would emit magic field\nnames like \"RUST$ENCODED$ENUM$0$Name\" and \"RUST$ENUM$DISR\".  Since\nPR #45225, though, even this has not worked -- the ad hoc scheme was\nnot updated to handle the wider variety of niche-filling layout\noptimizations now available.\n\nThis patch changes the generated DWARF to use the standard tags meant\nfor this purpose; namely, DW_TAG_variant and DW_TAG_variant_part.\n\nThe patch to implement this went in to LLVM 7.  In order to work with\nolder versions of LLVM, and because LLVM doesn't do anything here for\nPDB, the existing code is kept as a fallback mode.\n\nSupport for this DWARF is in the Rust lldb and in gdb 8.2.\n\nCloses #32920\nCloses #32924\nCloses #52762\nCloses #53153", "tree": {"sha": "af51f2a467017cf73d69494c03b524e61ba6d0ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af51f2a467017cf73d69494c03b524e61ba6d0ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "html_url": "https://github.com/rust-lang/rust/commit/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cf82fd9c0e8eb9ff29d4165f9824c483bd72f7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf82fd9c0e8eb9ff29d4165f9824c483bd72f7d", "html_url": "https://github.com/rust-lang/rust/commit/1cf82fd9c0e8eb9ff29d4165f9824c483bd72f7d"}, {"sha": "98b26888e552cf498518a6d34538302dc41ac6ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/98b26888e552cf498518a6d34538302dc41ac6ae", "html_url": "https://github.com/rust-lang/rust/commit/98b26888e552cf498518a6d34538302dc41ac6ae"}], "stats": {"total": 1952, "additions": 1691, "deletions": 261}, "files": [{"sha": "dd94f2652b4c9a86a9145cec5114dacdaec428d9", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:16.04\n+FROM ubuntu:18.10\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\"}, {"sha": "ba1e3f5960c8596b0d4c484aff8f703fd986d8ef", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 382, "deletions": 144, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -31,9 +31,10 @@ use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ich::NodeIdHashingMode;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n-use common::CodegenCx;\n+use common::{CodegenCx, C_u64};\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, LayoutOf, PrimitiveExt, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, HasDataLayout, Integer, IntegerExt, LayoutOf,\n+                        PrimitiveExt, Size, TyLayout};\n use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n use rustc_fs_util::path2cstr;\n@@ -205,6 +206,7 @@ enum RecursiveTypeDescription<'ll, 'tcx> {\n         unfinished_type: Ty<'tcx>,\n         unique_type_id: UniqueTypeId,\n         metadata_stub: &'ll DICompositeType,\n+        member_holding_stub: &'ll DICompositeType,\n         member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n     },\n     FinalMetadata(&'ll DICompositeType)\n@@ -215,6 +217,7 @@ fn create_and_register_recursive_type_forward_declaration(\n     unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n     metadata_stub: &'ll DICompositeType,\n+    member_holding_stub: &'ll DICompositeType,\n     member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n \n@@ -227,6 +230,7 @@ fn create_and_register_recursive_type_forward_declaration(\n         unfinished_type,\n         unique_type_id,\n         metadata_stub,\n+        member_holding_stub,\n         member_description_factory,\n     }\n }\n@@ -242,6 +246,7 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n                 unfinished_type,\n                 unique_type_id,\n                 metadata_stub,\n+                member_holding_stub,\n                 ref member_description_factory,\n             } => {\n                 // Make sure that we have a forward declaration of the type in\n@@ -266,7 +271,7 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n \n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n-                                              metadata_stub,\n+                                              member_holding_stub,\n                                               member_descriptions);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n@@ -350,6 +355,7 @@ fn vec_slice_metadata(\n             size: pointer_size,\n             align: pointer_align,\n             flags: DIFlags::FlagZero,\n+            discriminant: None,\n         },\n         MemberDescription {\n             name: \"length\".to_owned(),\n@@ -358,6 +364,7 @@ fn vec_slice_metadata(\n             size: usize_size,\n             align: usize_align,\n             flags: DIFlags::FlagZero,\n+            discriminant: None,\n         },\n     ];\n \n@@ -458,6 +465,7 @@ fn trait_pointer_metadata(\n             size: data_ptr_field.size,\n             align: data_ptr_field.align,\n             flags: DIFlags::FlagArtificial,\n+            discriminant: None,\n         },\n         MemberDescription {\n             name: \"vtable\".to_owned(),\n@@ -466,6 +474,7 @@ fn trait_pointer_metadata(\n             size: vtable_field.size,\n             align: vtable_field.align,\n             flags: DIFlags::FlagArtificial,\n+            discriminant: None,\n         },\n     ];\n \n@@ -914,6 +923,7 @@ struct MemberDescription<'ll> {\n     size: Size,\n     align: Align,\n     flags: DIFlags,\n+    discriminant: Option<u64>,\n }\n \n // A factory for MemberDescriptions. It produces a list of member descriptions\n@@ -981,6 +991,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,\n+                discriminant: None,\n             }\n         }).collect()\n     }\n@@ -1013,6 +1024,7 @@ fn prepare_struct_metadata(\n         struct_type,\n         unique_type_id,\n         struct_metadata_stub,\n+        struct_metadata_stub,\n         StructMDF(StructMemberDescriptionFactory {\n             ty: struct_type,\n             variant,\n@@ -1045,6 +1057,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,\n+                discriminant: None,\n             }\n         }).collect()\n     }\n@@ -1059,15 +1072,18 @@ fn prepare_tuple_metadata(\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n \n+    let struct_stub = create_struct_stub(cx,\n+                                         tuple_type,\n+                                         &tuple_name[..],\n+                                         unique_type_id,\n+                                         NO_SCOPE_METADATA);\n+\n     create_and_register_recursive_type_forward_declaration(\n         cx,\n         tuple_type,\n         unique_type_id,\n-        create_struct_stub(cx,\n-                           tuple_type,\n-                           &tuple_name[..],\n-                           unique_type_id,\n-                           NO_SCOPE_METADATA),\n+        struct_stub,\n+        struct_stub,\n         TupleMDF(TupleMemberDescriptionFactory {\n             ty: tuple_type,\n             component_types: component_types.to_vec(),\n@@ -1099,6 +1115,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,\n+                discriminant: None,\n             }\n         }).collect()\n     }\n@@ -1130,6 +1147,7 @@ fn prepare_union_metadata(\n         union_type,\n         unique_type_id,\n         union_metadata_stub,\n+        union_metadata_stub,\n         UnionMDF(UnionMemberDescriptionFactory {\n             layout: cx.layout_of(union_type),\n             variant,\n@@ -1142,6 +1160,20 @@ fn prepare_union_metadata(\n // Enums\n //=-----------------------------------------------------------------------------\n \n+// DWARF variant support is only available starting in LLVM 7.\n+// Although the earlier enum debug info output did not work properly\n+// in all situations, it is better for the time being to continue to\n+// sometimes emit the old style rather than emit something completely\n+// useless when rust is compiled against LLVM 6 or older.  This\n+// function decides which representation will be emitted.\n+fn use_enum_fallback(cx: &CodegenCx) -> bool {\n+    // On MSVC we have to use the fallback mode, because LLVM doesn't\n+    // lower variant parts to PDB.\n+    return cx.sess().target.target.options.is_like_msvc || unsafe {\n+        llvm::LLVMRustVersionMajor() < 7\n+    };\n+}\n+\n // Describes the members of an enum value: An enum is described as a union of\n // structs in DWARF. This MemberDescriptionFactory provides the description for\n // the members of this union; so for every variant of the given enum, this\n@@ -1159,6 +1191,15 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n                                   -> Vec<MemberDescription<'ll>> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n+\n+        // This will always find the metadata in the type map.\n+        let fallback = use_enum_fallback(cx);\n+        let self_metadata = if fallback {\n+            self.containing_scope\n+        } else {\n+            type_metadata(cx, self.enum_type, self.span)\n+        };\n+\n         match self.layout.variants {\n             layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n             layout::Variants::Single { index } => {\n@@ -1167,7 +1208,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                           self.layout,\n                                           &adt.variants[index],\n                                           NoDiscriminant,\n-                                          self.containing_scope,\n+                                          self_metadata,\n                                           self.span);\n \n                 let member_descriptions =\n@@ -1178,26 +1219,36 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                               member_descriptions);\n                 vec![\n                     MemberDescription {\n-                        name: String::new(),\n+                        name: if fallback {\n+                            String::new()\n+                        } else {\n+                            adt.variants[index].name.as_str().to_string()\n+                        },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n                         size: self.layout.size,\n                         align: self.layout.align,\n-                        flags: DIFlags::FlagZero\n+                        flags: DIFlags::FlagZero,\n+                        discriminant: None,\n                     }\n                 ]\n             }\n             layout::Variants::Tagged { ref variants, .. } => {\n-                let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n-                    .expect(\"\"));\n+                let discriminant_info = if fallback {\n+                    RegularDiscriminant(self.discriminant_type_metadata\n+                                        .expect(\"\"))\n+                } else {\n+                    // This doesn't matter in this case.\n+                    NoDiscriminant\n+                };\n                 (0..variants.len()).map(|i| {\n                     let variant = self.layout.for_variant(cx, i);\n                     let (variant_type_metadata, member_desc_factory) =\n                         describe_enum_variant(cx,\n                                               variant,\n                                               &adt.variants[i],\n                                               discriminant_info,\n-                                              self.containing_scope,\n+                                              self_metadata,\n                                               self.span);\n \n                     let member_descriptions = member_desc_factory\n@@ -1207,75 +1258,127 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                                   variant_type_metadata,\n                                                   member_descriptions);\n                     MemberDescription {\n-                        name: String::new(),\n+                        name: if fallback {\n+                            String::new()\n+                        } else {\n+                            adt.variants[i].name.as_str().to_string()\n+                        },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n-                        size: variant.size,\n-                        align: variant.align,\n-                        flags: DIFlags::FlagZero\n+                        size: self.layout.size,\n+                        align: self.layout.align,\n+                        flags: DIFlags::FlagZero,\n+                        discriminant: Some(self.layout.ty.ty_adt_def().unwrap()\n+                                           .discriminant_for_variant(cx.tcx, i)\n+                                           .val as u64),\n                     }\n                 }).collect()\n             }\n-            layout::Variants::NicheFilling { dataful_variant, ref niche_variants, .. } => {\n-                let variant = self.layout.for_variant(cx, dataful_variant);\n-                // Create a description of the non-null variant\n-                let (variant_type_metadata, member_description_factory) =\n-                    describe_enum_variant(cx,\n-                                          variant,\n-                                          &adt.variants[dataful_variant],\n-                                          OptimizedDiscriminant,\n-                                          self.containing_scope,\n-                                          self.span);\n+            layout::Variants::NicheFilling {\n+                ref niche_variants,\n+                niche_start,\n+                ref variants,\n+                dataful_variant,\n+                ..\n+            } => {\n+                if fallback {\n+                    let variant = self.layout.for_variant(cx, dataful_variant);\n+                    // Create a description of the non-null variant\n+                    let (variant_type_metadata, member_description_factory) =\n+                        describe_enum_variant(cx,\n+                                              variant,\n+                                              &adt.variants[dataful_variant],\n+                                              OptimizedDiscriminant,\n+                                              self.containing_scope,\n+                                              self.span);\n \n-                let variant_member_descriptions =\n-                    member_description_factory.create_member_descriptions(cx);\n+                    let variant_member_descriptions =\n+                        member_description_factory.create_member_descriptions(cx);\n \n-                set_members_of_composite_type(cx,\n-                                              variant_type_metadata,\n-                                              variant_member_descriptions);\n-\n-                // Encode the information about the null variant in the union\n-                // member's name.\n-                let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n-                // HACK(eddyb) the debuggers should just handle offset+size\n-                // of discriminant instead of us having to recover its path.\n-                // Right now it's not even going to work for `niche_start > 0`,\n-                // and for multiple niche variants it only supports the first.\n-                fn compute_field_path<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                                name: &mut String,\n-                                                layout: TyLayout<'tcx>,\n-                                                offset: Size,\n-                                                size: Size) {\n-                    for i in 0..layout.fields.count() {\n-                        let field_offset = layout.fields.offset(i);\n-                        if field_offset > offset {\n-                            continue;\n-                        }\n-                        let inner_offset = offset - field_offset;\n-                        let field = layout.field(cx, i);\n-                        if inner_offset + size <= field.size {\n-                            write!(name, \"{}$\", i).unwrap();\n-                            compute_field_path(cx, name, field, inner_offset, size);\n+                    set_members_of_composite_type(cx,\n+                                                  variant_type_metadata,\n+                                                  variant_member_descriptions);\n+\n+                    // Encode the information about the null variant in the union\n+                    // member's name.\n+                    let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n+                    // Right now it's not even going to work for `niche_start > 0`,\n+                    // and for multiple niche variants it only supports the first.\n+                    fn compute_field_path<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n+                                                    name: &mut String,\n+                                                    layout: TyLayout<'tcx>,\n+                                                    offset: Size,\n+                                                    size: Size) {\n+                        for i in 0..layout.fields.count() {\n+                            let field_offset = layout.fields.offset(i);\n+                            if field_offset > offset {\n+                                continue;\n+                            }\n+                            let inner_offset = offset - field_offset;\n+                            let field = layout.field(cx, i);\n+                            if inner_offset + size <= field.size {\n+                                write!(name, \"{}$\", i).unwrap();\n+                                compute_field_path(cx, name, field, inner_offset, size);\n+                            }\n                         }\n                     }\n+                    compute_field_path(cx, &mut name,\n+                                       self.layout,\n+                                       self.layout.fields.offset(0),\n+                                       self.layout.field(cx, 0).size);\n+                    name.push_str(&adt.variants[*niche_variants.start()].name.as_str());\n+\n+                    // Create the (singleton) list of descriptions of union members.\n+                    vec![\n+                        MemberDescription {\n+                            name,\n+                            type_metadata: variant_type_metadata,\n+                            offset: Size::ZERO,\n+                            size: variant.size,\n+                            align: variant.align,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: None,\n+                        }\n+                    ]\n+                } else {\n+                    (0..variants.len()).map(|i| {\n+                        let variant = self.layout.for_variant(cx, i);\n+                        let (variant_type_metadata, member_desc_factory) =\n+                            describe_enum_variant(cx,\n+                                                  variant,\n+                                                  &adt.variants[i],\n+                                                  OptimizedDiscriminant,\n+                                                  self_metadata,\n+                                                  self.span);\n+\n+                        let member_descriptions = member_desc_factory\n+                            .create_member_descriptions(cx);\n+\n+                        set_members_of_composite_type(cx,\n+                                                      variant_type_metadata,\n+                                                      member_descriptions);\n+\n+                        let niche_value = if i == dataful_variant {\n+                            None\n+                        } else {\n+                            let niche = (i as u128)\n+                                .wrapping_sub(*niche_variants.start() as u128)\n+                                .wrapping_add(niche_start);\n+                            assert_eq!(niche as u64 as u128, niche);\n+                            Some(niche as u64)\n+                        };\n+\n+                        MemberDescription {\n+                            name: adt.variants[i].name.as_str().to_string(),\n+                            type_metadata: variant_type_metadata,\n+                            offset: Size::ZERO,\n+                            size: self.layout.size,\n+                            align: self.layout.align,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: niche_value,\n+                        }\n+                    }).collect()\n                 }\n-                compute_field_path(cx, &mut name,\n-                                   self.layout,\n-                                   self.layout.fields.offset(0),\n-                                   self.layout.field(cx, 0).size);\n-                name.push_str(&adt.variants[*niche_variants.start()].name.as_str());\n-\n-                // Create the (singleton) list of descriptions of union members.\n-                vec![\n-                    MemberDescription {\n-                        name,\n-                        type_metadata: variant_type_metadata,\n-                        offset: Size::ZERO,\n-                        size: variant.size,\n-                        align: variant.align,\n-                        flags: DIFlags::FlagZero\n-                    }\n-                ]\n             }\n         }\n     }\n@@ -1297,14 +1400,19 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n             let (size, align) = cx.size_and_align_of(ty);\n             MemberDescription {\n                 name: name.to_string(),\n-                type_metadata: match self.discriminant_type_metadata {\n-                    Some(metadata) if i == 0 => metadata,\n-                    _ => type_metadata(cx, ty, self.span)\n+                type_metadata: if use_enum_fallback(cx) {\n+                    match self.discriminant_type_metadata {\n+                        Some(metadata) if i == 0 => metadata,\n+                        _ => type_metadata(cx, ty, self.span)\n+                    }\n+                } else {\n+                    type_metadata(cx, ty, self.span)\n                 },\n                 offset: self.offsets[i],\n                 size,\n                 align,\n-                flags: DIFlags::FlagZero\n+                flags: DIFlags::FlagZero,\n+                discriminant: None,\n             }\n         }).collect()\n     }\n@@ -1317,10 +1425,10 @@ enum EnumDiscriminantInfo<'ll> {\n     NoDiscriminant\n }\n \n-// Returns a tuple of (1) type_metadata_stub of the variant, (2) the llvm_type\n-// of the variant, and (3) a MemberDescriptionFactory for producing the\n-// descriptions of the fields of the variant. This is a rudimentary version of a\n-// full RecursiveTypeDescription.\n+// Returns a tuple of (1) type_metadata_stub of the variant, (2) a\n+// MemberDescriptionFactory for producing the descriptions of the\n+// fields of the variant. This is a rudimentary version of a full\n+// RecursiveTypeDescription.\n fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyLayout<'tcx>,\n@@ -1343,29 +1451,46 @@ fn describe_enum_variant(\n                                            unique_type_id,\n                                            Some(containing_scope));\n \n-    // If this is not a univariant enum, there is also the discriminant field.\n-    let (discr_offset, discr_arg) = match discriminant_info {\n-        RegularDiscriminant(_) => {\n-            // We have the layout of an enum variant, we need the layout of the outer enum\n-            let enum_layout = cx.layout_of(layout.ty);\n-            (Some(enum_layout.fields.offset(0)),\n-             Some((\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, 0).ty)))\n-        }\n-        _ => (None, None),\n-    };\n-    let offsets = discr_offset.into_iter().chain((0..layout.fields.count()).map(|i| {\n-        layout.fields.offset(i)\n-    })).collect();\n-\n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args = discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n-        let name = if variant.ctor_kind == CtorKind::Fn {\n-            format!(\"__{}\", i)\n-        } else {\n-            variant.fields[i].ident.to_string()\n+    let (offsets, args) = if use_enum_fallback(cx) {\n+        // If this is not a univariant enum, there is also the discriminant field.\n+        let (discr_offset, discr_arg) = match discriminant_info {\n+            RegularDiscriminant(_) => {\n+                // We have the layout of an enum variant, we need the layout of the outer enum\n+                let enum_layout = cx.layout_of(layout.ty);\n+                (Some(enum_layout.fields.offset(0)),\n+                 Some((\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, 0).ty)))\n+            }\n+            _ => (None, None),\n         };\n-        (name, layout.field(cx, i).ty)\n-    })).collect();\n+        (\n+            discr_offset.into_iter().chain((0..layout.fields.count()).map(|i| {\n+                layout.fields.offset(i)\n+            })).collect(),\n+            discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n+                let name = if variant.ctor_kind == CtorKind::Fn {\n+                    format!(\"__{}\", i)\n+                } else {\n+                    variant.fields[i].ident.to_string()\n+                };\n+                (name, layout.field(cx, i).ty)\n+            })).collect()\n+        )\n+    } else {\n+        (\n+            (0..layout.fields.count()).map(|i| {\n+                layout.fields.offset(i)\n+            }).collect(),\n+            (0..layout.fields.count()).map(|i| {\n+                let name = if variant.ctor_kind == CtorKind::Fn {\n+                    format!(\"__{}\", i)\n+                } else {\n+                    variant.fields[i].ident.to_string()\n+                };\n+                (name, layout.field(cx, i).ty)\n+            }).collect()\n+        )\n+    };\n \n     let member_description_factory =\n         VariantMDF(VariantMemberDescriptionFactory {\n@@ -1401,22 +1526,22 @@ fn prepare_enum_metadata(\n     // <unknown>\n     let file_metadata = unknown_file_metadata(cx);\n \n-    let def = enum_type.ty_adt_def().unwrap();\n-    let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n-        .zip(&def.variants)\n-        .map(|(discr, v)| {\n-            let name = SmallCStr::new(&v.name.as_str());\n-            unsafe {\n-                Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n-                    DIB(cx),\n-                    name.as_ptr(),\n-                    // FIXME: what if enumeration has i128 discriminant?\n-                    discr.val as u64))\n-            }\n-        })\n-        .collect();\n-\n     let discriminant_type_metadata = |discr: layout::Primitive| {\n+        let def = enum_type.ty_adt_def().unwrap();\n+        let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n+            .zip(&def.variants)\n+            .map(|(discr, v)| {\n+                let name = SmallCStr::new(&v.name.as_str());\n+                unsafe {\n+                    Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                        DIB(cx),\n+                        name.as_ptr(),\n+                        // FIXME: what if enumeration has i128 discriminant?\n+                        discr.val as u64))\n+                }\n+            })\n+            .collect();\n+\n         let disr_type_key = (enum_def_id, discr);\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n@@ -1441,7 +1566,7 @@ fn prepare_enum_metadata(\n                         discriminant_size.bits(),\n                         discriminant_align.abi_bits() as u32,\n                         create_DIArray(DIB(cx), &enumerators_metadata),\n-                        discriminant_base_type_metadata)\n+                        discriminant_base_type_metadata, true)\n                 };\n \n                 debug_context(cx).created_enum_disr_types\n@@ -1455,16 +1580,10 @@ fn prepare_enum_metadata(\n \n     let layout = cx.layout_of(enum_type);\n \n-    let discriminant_type_metadata = match layout.variants {\n-        layout::Variants::Single { .. } |\n-        layout::Variants::NicheFilling { .. } => None,\n-        layout::Variants::Tagged { ref tag, .. } => {\n-            Some(discriminant_type_metadata(tag.value))\n-        }\n-    };\n-\n-    if let (&layout::Abi::Scalar(_), Some(discr)) = (&layout.abi, discriminant_type_metadata) {\n-        return FinalMetadata(discr);\n+    match (&layout.abi, &layout.variants) {\n+        (&layout::Abi::Scalar(_), &layout::Variants::Tagged {ref tag, .. }) =>\n+            return FinalMetadata(discriminant_type_metadata(tag.value)),\n+        _ => {}\n     }\n \n     let (enum_type_size, enum_type_align) = layout.size_and_align();\n@@ -1473,30 +1592,145 @@ fn prepare_enum_metadata(\n     let unique_type_id_str = SmallCStr::new(\n         debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n     );\n-    let enum_metadata = unsafe {\n-        llvm::LLVMRustDIBuilderCreateUnionType(\n-        DIB(cx),\n-        containing_scope,\n-        enum_name.as_ptr(),\n-        file_metadata,\n-        UNKNOWN_LINE_NUMBER,\n-        enum_type_size.bits(),\n-        enum_type_align.abi_bits() as u32,\n-        DIFlags::FlagZero,\n-        None,\n-        0, // RuntimeLang\n-        unique_type_id_str.as_ptr())\n+\n+    if use_enum_fallback(cx) {\n+        let discriminant_type_metadata = match layout.variants {\n+            layout::Variants::Single { .. } |\n+            layout::Variants::NicheFilling { .. } => None,\n+            layout::Variants::Tagged { ref tag, .. } => {\n+                Some(discriminant_type_metadata(tag.value))\n+            }\n+        };\n+\n+        let enum_metadata = unsafe {\n+            llvm::LLVMRustDIBuilderCreateUnionType(\n+                DIB(cx),\n+                containing_scope,\n+                enum_name.as_ptr(),\n+                file_metadata,\n+                UNKNOWN_LINE_NUMBER,\n+                enum_type_size.bits(),\n+                enum_type_align.abi_bits() as u32,\n+                DIFlags::FlagZero,\n+                None,\n+                0, // RuntimeLang\n+                unique_type_id_str.as_ptr())\n+        };\n+\n+        return create_and_register_recursive_type_forward_declaration(\n+            cx,\n+            enum_type,\n+            unique_type_id,\n+            enum_metadata,\n+            enum_metadata,\n+            EnumMDF(EnumMemberDescriptionFactory {\n+                enum_type,\n+                layout,\n+                discriminant_type_metadata,\n+                containing_scope,\n+                span,\n+            }),\n+        );\n+    }\n+\n+    let discriminator_metadata = match &layout.variants {\n+        // A single-variant enum has no discriminant.\n+        &layout::Variants::Single { .. } => None,\n+\n+        &layout::Variants::NicheFilling { ref niche, .. } => {\n+            // Find the integer type of the correct size.\n+            let size = niche.value.size(cx);\n+            let align = niche.value.align(cx);\n+\n+            let discr_type = match niche.value {\n+                layout::Int(t, _) => t,\n+                layout::Float(layout::FloatTy::F32) => Integer::I32,\n+                layout::Float(layout::FloatTy::F64) => Integer::I64,\n+                layout::Pointer => cx.data_layout().ptr_sized_integer(),\n+            }.to_ty(cx.tcx, false);\n+\n+            let discr_metadata = basic_type_metadata(cx, discr_type);\n+            unsafe {\n+                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    ptr::null_mut(),\n+                    file_metadata,\n+                    UNKNOWN_LINE_NUMBER,\n+                    size.bits(),\n+                    align.abi_bits() as u32,\n+                    layout.fields.offset(0).bits(),\n+                    DIFlags::FlagArtificial,\n+                    discr_metadata))\n+            }\n+        },\n+\n+        &layout::Variants::Tagged { ref tag, .. } => {\n+            let discr_type = tag.value.to_ty(cx.tcx);\n+            let (size, align) = cx.size_and_align_of(discr_type);\n+\n+            let discr_metadata = basic_type_metadata(cx, discr_type);\n+            unsafe {\n+                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    ptr::null_mut(),\n+                    file_metadata,\n+                    UNKNOWN_LINE_NUMBER,\n+                    size.bits(),\n+                    align.abi_bits() as u32,\n+                    layout.fields.offset(0).bits(),\n+                    DIFlags::FlagArtificial,\n+                    discr_metadata))\n+            }\n+        },\n+    };\n+\n+    let empty_array = create_DIArray(DIB(cx), &[]);\n+    let variant_part = unsafe {\n+        llvm::LLVMRustDIBuilderCreateVariantPart(\n+            DIB(cx),\n+            containing_scope,\n+            ptr::null_mut(),\n+            file_metadata,\n+            UNKNOWN_LINE_NUMBER,\n+            enum_type_size.bits(),\n+            enum_type_align.abi_bits() as u32,\n+            DIFlags::FlagZero,\n+            discriminator_metadata,\n+            empty_array,\n+            unique_type_id_str.as_ptr())\n+    };\n+\n+    // The variant part must be wrapped in a struct according to DWARF.\n+    let type_array = create_DIArray(DIB(cx), &[Some(variant_part)]);\n+    let struct_wrapper = unsafe {\n+        llvm::LLVMRustDIBuilderCreateStructType(\n+            DIB(cx),\n+            Some(containing_scope),\n+            enum_name.as_ptr(),\n+            file_metadata,\n+            UNKNOWN_LINE_NUMBER,\n+            enum_type_size.bits(),\n+            enum_type_align.abi_bits() as u32,\n+            DIFlags::FlagZero,\n+            None,\n+            type_array,\n+            0,\n+            None,\n+            unique_type_id_str.as_ptr())\n     };\n \n     return create_and_register_recursive_type_forward_declaration(\n         cx,\n         enum_type,\n         unique_type_id,\n-        enum_metadata,\n+        struct_wrapper,\n+        variant_part,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type,\n             layout,\n-            discriminant_type_metadata,\n+            discriminant_type_metadata: None,\n             containing_scope,\n             span,\n         }),\n@@ -1565,7 +1799,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n         .map(|member_description| {\n             let member_name = CString::new(member_description.name).unwrap();\n             unsafe {\n-                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n+                Some(llvm::LLVMRustDIBuilderCreateVariantMemberType(\n                     DIB(cx),\n                     composite_type_metadata,\n                     member_name.as_ptr(),\n@@ -1574,6 +1808,10 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n                     member_description.size.bits(),\n                     member_description.align.abi_bits() as u32,\n                     member_description.offset.bits(),\n+                    match member_description.discriminant {\n+                        None => None,\n+                        Some(value) => Some(C_u64(cx, value)),\n+                    },\n                     member_description.flags,\n                     member_description.type_metadata))\n             }"}, {"sha": "f046ea030272afe045dfa05b59295aee2f019806", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -1307,6 +1307,19 @@ extern \"C\" {\n                                              Ty: &'a DIType)\n                                              -> &'a DIDerivedType;\n \n+    pub fn LLVMRustDIBuilderCreateVariantMemberType(Builder: &DIBuilder<'a>,\n+                                                    Scope: &'a DIScope,\n+                                                    Name: *const c_char,\n+                                                    File: &'a DIFile,\n+                                                    LineNumber: c_uint,\n+                                                    SizeInBits: u64,\n+                                                    AlignInBits: u32,\n+                                                    OffsetInBits: u64,\n+                                                    Discriminant: Option<&'a Value>,\n+                                                    Flags: DIFlags,\n+                                                    Ty: &'a DIType)\n+                                                    -> &'a DIType;\n+\n     pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: &DIBuilder<'a>,\n                                                Scope: &'a DIScope,\n                                                File: &'a DIFile,\n@@ -1384,7 +1397,8 @@ extern \"C\" {\n                                                   SizeInBits: u64,\n                                                   AlignInBits: u32,\n                                                   Elements: &'a DIArray,\n-                                                  ClassType: &'a DIType)\n+                                                  ClassType: &'a DIType,\n+                                                  IsFixed: bool)\n                                                   -> &'a DIType;\n \n     pub fn LLVMRustDIBuilderCreateUnionType(Builder: &DIBuilder<'a>,\n@@ -1400,6 +1414,19 @@ extern \"C\" {\n                                             UniqueId: *const c_char)\n                                             -> &'a DIType;\n \n+    pub fn LLVMRustDIBuilderCreateVariantPart(Builder: &DIBuilder<'a>,\n+                                              Scope: &'a DIScope,\n+                                              Name: *const c_char,\n+                                              File: &'a DIFile,\n+                                              LineNo: c_uint,\n+                                              SizeInBits: u64,\n+                                              AlignInBits: u32,\n+                                              Flags: DIFlags,\n+                                              Discriminator: Option<&'a DIDerivedType>,\n+                                              Elements: &'a DIArray,\n+                                              UniqueId: *const c_char)\n+                                              -> &'a DIDerivedType;\n+\n     pub fn LLVMSetUnnamedAddr(GlobalVar: &Value, UnnamedAddr: Bool);\n \n     pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: &DIBuilder<'a>,"}, {"sha": "7051ead40a5f825878b59bf08d4e768be9e99a4a", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -1 +1 @@\n-Subproject commit caddcd9b9dc9479a20908d93c3e47c49b021379e\n+Subproject commit 7051ead40a5f825878b59bf08d4e768be9e99a4a"}, {"sha": "affec73e3ac62d608c8db0fbf46090698b2e74cc", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -713,6 +713,21 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStructType(\n       unwrapDI<DIType>(VTableHolder), UniqueId));\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantPart(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n+    uint32_t AlignInBits, LLVMRustDIFlags Flags, LLVMMetadataRef Discriminator,\n+    LLVMMetadataRef Elements, const char *UniqueId) {\n+#if LLVM_VERSION_GE(7, 0)\n+  return wrap(Builder->createVariantPart(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, fromRust(Flags), unwrapDI<DIDerivedType>(Discriminator),\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), UniqueId));\n+#else\n+  abort();\n+#endif\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMemberType(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n     LLVMMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n@@ -724,6 +739,28 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMemberType(\n                                         fromRust(Flags), unwrapDI<DIType>(Ty)));\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantMemberType(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, LLVMMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n+    uint32_t AlignInBits, uint64_t OffsetInBits, LLVMValueRef Discriminant,\n+    LLVMRustDIFlags Flags, LLVMMetadataRef Ty) {\n+#if LLVM_VERSION_GE(7, 0)\n+  llvm::ConstantInt* D = nullptr;\n+  if (Discriminant) {\n+    D = unwrap<llvm::ConstantInt>(Discriminant);\n+  }\n+  return wrap(Builder->createVariantMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n+                                               unwrapDI<DIFile>(File), LineNo,\n+                                               SizeInBits, AlignInBits, OffsetInBits, D,\n+                                               fromRust(Flags), unwrapDI<DIType>(Ty)));\n+#else\n+  return wrap(Builder->createMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n+                                        unwrapDI<DIFile>(File), LineNo,\n+                                        SizeInBits, AlignInBits, OffsetInBits,\n+                                        fromRust(Flags), unwrapDI<DIType>(Ty)));\n+#endif\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n     LLVMMetadataRef File, unsigned Line, unsigned Col) {\n@@ -826,11 +863,19 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMMetadataRef Elements,\n-    LLVMMetadataRef ClassTy) {\n+    LLVMMetadataRef ClassTy, bool IsFixed) {\n+#if LLVM_VERSION_GE(7, 0)\n   return wrap(Builder->createEnumerationType(\n       unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n       SizeInBits, AlignInBits, DINodeArray(unwrapDI<MDTuple>(Elements)),\n-      unwrapDI<DIType>(ClassTy)));\n+      unwrapDI<DIType>(ClassTy), \"\", IsFixed));\n+#else\n+  // Ignore IsFixed on older LLVM.\n+  return wrap(Builder->createEnumerationType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, DINodeArray(unwrapDI<MDTuple>(Elements)),\n+      unwrapDI<DIType>(ClassTy), \"\"));\n+#endif\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateUnionType("}, {"sha": "528e84b298c43244f9135b729bfddebe6d844833", "filename": "src/test/codegen/enum-debug-clike.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fcodegen%2Fenum-debug-clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fcodegen%2Fenum-debug-clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-debug-clike.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test depends on a patch that was committed to upstream LLVM\n+// before 7.0, then backported to the Rust LLVM fork.  It tests that\n+// debug info for \"c-like\" enums is properly emitted.\n+\n+// ignore-tidy-linelength\n+// ignore-windows\n+// min-system-llvm-version 7.0\n+\n+// compile-flags: -g -C no-prepopulate-passes\n+\n+// CHECK-LABEL: @main\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_enumeration_type,{{.*}}name: \"E\",{{.*}}flags: DIFlagFixedEnum,{{.*}}\n+// CHECK: {{.*}}DIEnumerator{{.*}}name: \"A\",{{.*}}value: {{[0-9].*}}\n+// CHECK: {{.*}}DIEnumerator{{.*}}name: \"B\",{{.*}}value: {{[0-9].*}}\n+// CHECK: {{.*}}DIEnumerator{{.*}}name: \"C\",{{.*}}value: {{[0-9].*}}\n+\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+\n+enum E { A, B, C }\n+\n+pub fn main() {\n+    let e = E::C;\n+}"}, {"sha": "6326ba93266c2c6a52c8d1f9d640e67845ca1e2c", "filename": "src/test/codegen/enum-debug-niche.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fcodegen%2Fenum-debug-niche.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fcodegen%2Fenum-debug-niche.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-debug-niche.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test depends on a patch that was committed to upstream LLVM\n+// before 7.0, then backported to the Rust LLVM fork.  It tests that\n+// optimized enum debug info accurately reflects the enum layout.\n+\n+// ignore-tidy-linelength\n+// ignore-windows\n+// min-system-llvm-version 7.0\n+\n+// compile-flags: -g -C no-prepopulate-passes\n+\n+// CHECK-LABEL: @main\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_variant_part,{{.*}}discriminator:{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"A\",{{.*}}extraData:{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"A\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"B\",{{.*}}extraData:{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"B\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"C\",{{.*}}extraData:{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"C\",{{.*}}\n+// CHECK-NOT: {{.*}}DIDerivedType{{.*}}name: \"D\",{{.*}}extraData:{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"D\",{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"D\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}flags: DIFlagArtificial{{.*}}\n+\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+\n+enum E { A, B, C, D(bool) }\n+\n+pub fn main() {\n+    let e = E::D(true);\n+}"}, {"sha": "e862d29c940f08b4f0a8b620ddb68da147f629cf", "filename": "src/test/codegen/enum-debug-tagged.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fcodegen%2Fenum-debug-tagged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fcodegen%2Fenum-debug-tagged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-debug-tagged.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test depends on a patch that was committed to upstream LLVM\n+// before 7.0, then backported to the Rust LLVM fork.  It tests that\n+// debug info for tagged (ordinary) enums is properly emitted.\n+\n+// ignore-tidy-linelength\n+// ignore-windows\n+// min-system-llvm-version 7.0\n+\n+// compile-flags: -g -C no-prepopulate-passes\n+\n+// CHECK-LABEL: @main\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"E\",{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_variant_part,{{.*}}discriminator:{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"A\",{{.*}}extraData:{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"A\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"__0\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"B\",{{.*}}extraData:{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"B\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"__0\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}flags: DIFlagArtificial{{.*}}\n+\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+\n+enum E { A(u32), B(u32) }\n+\n+pub fn main() {\n+    let e = E::A(23);\n+}"}, {"sha": "dcd4588af76c7710b063a0dd63d1da6ec12b5b9b", "filename": "src/test/debuginfo/basic-types.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -16,6 +16,10 @@\n \n // min-lldb-version: 310\n \n+// This fails on lldb 6.0.1 on x86-64 Fedora 28; so mark it macOS-only\n+// for now.\n+// only-macos\n+\n // compile-flags:-g\n \n // === GDB TESTS ==================================================================================="}, {"sha": "a04f7d6dd8aec2a99768ec1b346b8ec105d38b3b", "filename": "src/test/debuginfo/borrowed-enum-legacy.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fborrowed-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fborrowed-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum-legacy.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+\n+// gdb-command:print *the_a_ref\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n+// gdbr-check:$1 = borrowed_enum_legacy::ABC::TheA{x: 0, y: 8970181431921507452}\n+\n+// gdb-command:print *the_b_ref\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbr-check:$2 = borrowed_enum_legacy::ABC::TheB(0, 286331153, 286331153)\n+\n+// gdb-command:print *univariant_ref\n+// gdbg-check:$3 = {{__0 = 4820353753753434}}\n+// gdbr-check:$3 = borrowed_enum_legacy::Univariant::TheOnlyCase(4820353753753434)\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print *the_a_ref\n+// lldbg-check:[...]$0 = TheA { x: 0, y: 8970181431921507452 }\n+// lldbr-check:(borrowed_enum_legacy::ABC::TheA) *the_a_ref = TheA { borrowed_enum_legacy::ABC::TheA: 0, borrowed_enum_legacy::ABC::TheB: 8970181431921507452 }\n+// lldb-command:print *the_b_ref\n+// lldbg-check:[...]$1 = TheB(0, 286331153, 286331153)\n+// lldbr-check:(borrowed_enum_legacy::ABC::TheB) *the_b_ref = { = 0 = 286331153 = 286331153 }\n+// lldb-command:print *univariant_ref\n+// lldbg-check:[...]$2 = TheOnlyCase(4820353753753434)\n+// lldbr-check:(borrowed_enum_legacy::Univariant) *univariant_ref = { borrowed_enum_legacy::TheOnlyCase = { = 4820353753753434 } }\n+\n+#![allow(unused_variables)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum ABC {\n+    TheA { x: i64, y: i64 },\n+    TheB (i64, i32, i32),\n+}\n+\n+// This is a special case since it does not have the implicit discriminant field.\n+enum Univariant {\n+    TheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let the_a = ABC::TheA { x: 0, y: 8970181431921507452 };\n+    let the_a_ref: &ABC = &the_a;\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let the_b = ABC::TheB (0, 286331153, 286331153);\n+    let the_b_ref: &ABC = &the_b;\n+\n+    let univariant = Univariant::TheOnlyCase(4820353753753434);\n+    let univariant_ref: &Univariant = &univariant;\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "8362934166cf56a7abeab87cc76e00929e2906fa", "filename": "src/test/debuginfo/borrowed-enum.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -9,8 +9,11 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb or lldb that can read it.\n+// min-system-llvm-version: 7.0\n+// min-gdb-version: 8.2\n+// rust-lldb\n \n // compile-flags:-g\n \n@@ -19,15 +22,12 @@\n // gdb-command:run\n \n // gdb-command:print *the_a_ref\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n // gdbr-check:$1 = borrowed_enum::ABC::TheA{x: 0, y: 8970181431921507452}\n \n // gdb-command:print *the_b_ref\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n // gdbr-check:$2 = borrowed_enum::ABC::TheB(0, 286331153, 286331153)\n \n // gdb-command:print *univariant_ref\n-// gdbg-check:$3 = {{__0 = 4820353753753434}}\n // gdbr-check:$3 = borrowed_enum::Univariant::TheOnlyCase(4820353753753434)\n \n \n@@ -36,14 +36,11 @@\n // lldb-command:run\n \n // lldb-command:print *the_a_ref\n-// lldbg-check:[...]$0 = TheA { x: 0, y: 8970181431921507452 }\n-// lldbr-check:(borrowed_enum::ABC::TheA) *the_a_ref = TheA { borrowed_enum::ABC::TheA: 0, borrowed_enum::ABC::TheB: 8970181431921507452 }\n+// lldbr-check:(borrowed_enum::ABC::TheA) *the_a_ref = TheA { TheA: 0, TheB: 8970181431921507452 }\n // lldb-command:print *the_b_ref\n-// lldbg-check:[...]$1 = TheB(0, 286331153, 286331153)\n // lldbr-check:(borrowed_enum::ABC::TheB) *the_b_ref = { = 0 = 286331153 = 286331153 }\n // lldb-command:print *univariant_ref\n-// lldbg-check:[...]$2 = TheOnlyCase(4820353753753434)\n-// lldbr-check:(borrowed_enum::Univariant) *univariant_ref = { borrowed_enum::TheOnlyCase = { = 4820353753753434 } }\n+// lldbr-check:(borrowed_enum::Univariant) *univariant_ref = { TheOnlyCase = { = 4820353753753434 } }\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]"}, {"sha": "715024a2ef9130ba800a9d5a35a167bfe37ce8fd", "filename": "src/test/debuginfo/cross-crate-spans.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -13,6 +13,10 @@\n \n // min-lldb-version: 310\n \n+// This fails on lldb 6.0.1 on x86-64 Fedora 28; so mark it macOS-only\n+// for now.\n+// only-macos\n+\n // aux-build:cross_crate_spans.rs\n extern crate cross_crate_spans;\n "}, {"sha": "77583ab10377919c75f57508134b781248a0d5fb", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -12,6 +12,10 @@\n \n // min-lldb-version: 310\n \n+// This fails on lldb 6.0.1 on x86-64 Fedora 28; so mark it macOS-only\n+// for now.\n+// only-macos\n+\n // compile-flags:-g\n \n // === GDB TESTS ==================================================================================="}, {"sha": "092b31b7c30547f0f716815c01ebaa69d4fcd100", "filename": "src/test/debuginfo/generic-enum-with-different-disr-sizes-legacy.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes-legacy.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// ignore-lldb: FIXME(#27089)\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+// gdb-command:run\n+\n+// gdb-command:print eight_bytes1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Variant1, __0 = 100}, {RUST$ENUM$DISR = Variant1, __0 = 100}}\n+// gdbr-check:$1 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(100)\n+\n+// gdb-command:print four_bytes1\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Variant1, __0 = 101}, {RUST$ENUM$DISR = Variant1, __0 = 101}}\n+// gdbr-check:$2 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(101)\n+\n+// gdb-command:print two_bytes1\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Variant1, __0 = 102}, {RUST$ENUM$DISR = Variant1, __0 = 102}}\n+// gdbr-check:$3 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(102)\n+\n+// gdb-command:print one_byte1\n+// gdbg-check:$4 = {{RUST$ENUM$DISR = Variant1, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant1, __0 = 65 'A'}}\n+// gdbr-check:$4 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(65)\n+\n+\n+// gdb-command:print eight_bytes2\n+// gdbg-check:$5 = {{RUST$ENUM$DISR = Variant2, __0 = 100}, {RUST$ENUM$DISR = Variant2, __0 = 100}}\n+// gdbr-check:$5 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(100)\n+\n+// gdb-command:print four_bytes2\n+// gdbg-check:$6 = {{RUST$ENUM$DISR = Variant2, __0 = 101}, {RUST$ENUM$DISR = Variant2, __0 = 101}}\n+// gdbr-check:$6 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(101)\n+\n+// gdb-command:print two_bytes2\n+// gdbg-check:$7 = {{RUST$ENUM$DISR = Variant2, __0 = 102}, {RUST$ENUM$DISR = Variant2, __0 = 102}}\n+// gdbr-check:$7 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(102)\n+\n+// gdb-command:print one_byte2\n+// gdbg-check:$8 = {{RUST$ENUM$DISR = Variant2, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant2, __0 = 65 'A'}}\n+// gdbr-check:$8 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(65)\n+\n+// gdb-command:continue\n+\n+// === LLDB TESTS ==================================================================================\n+// lldb-command:run\n+\n+// lldb-command:print eight_bytes1\n+// lldb-check:[...]$0 = Variant1(100)\n+// lldb-command:print four_bytes1\n+// lldb-check:[...]$1 = Variant1(101)\n+// lldb-command:print two_bytes1\n+// lldb-check:[...]$2 = Variant1(102)\n+// lldb-command:print one_byte1\n+// lldb-check:[...]$3 = Variant1('A')\n+\n+// lldb-command:print eight_bytes2\n+// lldb-check:[...]$4 = Variant2(100)\n+// lldb-command:print four_bytes2\n+// lldb-check:[...]$5 = Variant2(101)\n+// lldb-command:print two_bytes2\n+// lldb-check:[...]$6 = Variant2(102)\n+// lldb-command:print one_byte2\n+// lldb-check:[...]$7 = Variant2('A')\n+\n+// lldb-command:continue\n+\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+// This test case makes sure that we get correct type descriptions for the enum\n+// discriminant of different instantiations of the same generic enum type where,\n+// dependending on the generic type parameter(s), the discriminant has a\n+// different size in memory.\n+\n+enum Enum<T> {\n+    Variant1(T),\n+    Variant2(T)\n+}\n+\n+fn main() {\n+    // These are ordered for descending size on purpose\n+    let eight_bytes1 = Enum::Variant1(100.0f64);\n+    let four_bytes1 = Enum::Variant1(101i32);\n+    let two_bytes1 = Enum::Variant1(102i16);\n+    let one_byte1 = Enum::Variant1(65u8);\n+\n+    let eight_bytes2 = Enum::Variant2(100.0f64);\n+    let four_bytes2 = Enum::Variant2(101i32);\n+    let two_bytes2 = Enum::Variant2(102i16);\n+    let one_byte2 = Enum::Variant2(65u8);\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() { () }"}, {"sha": "988ec4a65f1e2a8e041d82f3727bd92daafd1885", "filename": "src/test/debuginfo/generic-enum-with-different-disr-sizes.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -12,43 +12,39 @@\n // ignore-lldb: FIXME(#27089)\n // min-lldb-version: 310\n \n+// Require LLVM with DW_TAG_variant_part and a gdb that can read it.\n+// min-system-llvm-version: 7.0\n+// min-gdb-version: 8.2\n+\n // compile-flags:-g\n \n // === GDB TESTS ===================================================================================\n // gdb-command:run\n \n // gdb-command:print eight_bytes1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Variant1, __0 = 100}, {RUST$ENUM$DISR = Variant1, __0 = 100}}\n-// gdbr-check:$1 = generic_enum_with_different_disr_sizes::Enum::Variant1(100)\n+// gdbr-check:$1 = generic_enum_with_different_disr_sizes::Enum<f64>::Variant1(100)\n \n // gdb-command:print four_bytes1\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Variant1, __0 = 101}, {RUST$ENUM$DISR = Variant1, __0 = 101}}\n-// gdbr-check:$2 = generic_enum_with_different_disr_sizes::Enum::Variant1(101)\n+// gdbr-check:$2 = generic_enum_with_different_disr_sizes::Enum<i32>::Variant1(101)\n \n // gdb-command:print two_bytes1\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Variant1, __0 = 102}, {RUST$ENUM$DISR = Variant1, __0 = 102}}\n-// gdbr-check:$3 = generic_enum_with_different_disr_sizes::Enum::Variant1(102)\n+// gdbr-check:$3 = generic_enum_with_different_disr_sizes::Enum<i16>::Variant1(102)\n \n // gdb-command:print one_byte1\n-// gdbg-check:$4 = {{RUST$ENUM$DISR = Variant1, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant1, __0 = 65 'A'}}\n-// gdbr-check:$4 = generic_enum_with_different_disr_sizes::Enum::Variant1(65)\n+// gdbr-check:$4 = generic_enum_with_different_disr_sizes::Enum<u8>::Variant1(65)\n \n \n // gdb-command:print eight_bytes2\n-// gdbg-check:$5 = {{RUST$ENUM$DISR = Variant2, __0 = 100}, {RUST$ENUM$DISR = Variant2, __0 = 100}}\n-// gdbr-check:$5 = generic_enum_with_different_disr_sizes::Enum::Variant2(100)\n+// gdbr-check:$5 = generic_enum_with_different_disr_sizes::Enum<f64>::Variant2(100)\n \n // gdb-command:print four_bytes2\n-// gdbg-check:$6 = {{RUST$ENUM$DISR = Variant2, __0 = 101}, {RUST$ENUM$DISR = Variant2, __0 = 101}}\n-// gdbr-check:$6 = generic_enum_with_different_disr_sizes::Enum::Variant2(101)\n+// gdbr-check:$6 = generic_enum_with_different_disr_sizes::Enum<i32>::Variant2(101)\n \n // gdb-command:print two_bytes2\n-// gdbg-check:$7 = {{RUST$ENUM$DISR = Variant2, __0 = 102}, {RUST$ENUM$DISR = Variant2, __0 = 102}}\n-// gdbr-check:$7 = generic_enum_with_different_disr_sizes::Enum::Variant2(102)\n+// gdbr-check:$7 = generic_enum_with_different_disr_sizes::Enum<i16>::Variant2(102)\n \n // gdb-command:print one_byte2\n-// gdbg-check:$8 = {{RUST$ENUM$DISR = Variant2, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant2, __0 = 65 'A'}}\n-// gdbr-check:$8 = generic_enum_with_different_disr_sizes::Enum::Variant2(65)\n+// gdbr-check:$8 = generic_enum_with_different_disr_sizes::Enum<u8>::Variant2(65)\n \n // gdb-command:continue\n "}, {"sha": "47c4ea77e4426a1bead13e02a06fc78d28805a25", "filename": "src/test/debuginfo/generic-struct-style-enum-legacy.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum-legacy.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// gdb-command:set print union on\n+// gdb-command:run\n+\n+// gdb-command:print case1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n+// gdbr-check:$1 = generic_struct_style_enum_legacy::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n+\n+// gdb-command:print case2\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n+// gdbr-check:$2 = generic_struct_style_enum_legacy::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n+\n+// gdb-command:print case3\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbr-check:$3 = generic_struct_style_enum_legacy::Regular::Case3{a: 0, b: 6438275382588823897}\n+\n+// gdb-command:print univariant\n+// gdbg-check:$4 = {{a = -1}}\n+// gdbr-check:$4 = generic_struct_style_enum_legacy::Univariant<i32>::TheOnlyCase{a: -1}\n+\n+\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Regular::{Case1, Case2, Case3};\n+use self::Univariant::TheOnlyCase;\n+\n+// NOTE: This is a copy of the non-generic test case. The `Txx` type parameters have to be\n+// substituted with something of size `xx` bits and the same alignment as an integer type of the\n+// same size.\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular<T16, T32, T64> {\n+    Case1 { a: T64, b: T16, c: T16, d: T16, e: T16},\n+    Case2 { a: T64, b: T32, c: T32},\n+    Case3 { a: T64, b: T64 }\n+}\n+\n+enum Univariant<T> {\n+    TheOnlyCase { a: T }\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1: Regular<u16, u32, i64> = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2: Regular<i16, u32, i64>  = Case2 { a: 0, b: 286331153, c: 286331153 };\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3: Regular<u16, i32, u64>  = Case3 { a: 0, b: 6438275382588823897 };\n+\n+    let univariant = TheOnlyCase { a: -1 };\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "e08cde03c477b92aa3a91e6dcfeef993d79fc0a5", "filename": "src/test/debuginfo/generic-struct-style-enum.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -10,27 +10,26 @@\n \n // ignore-tidy-linelength\n // min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb that can read it.\n+// min-system-llvm-version: 7.0\n+// min-gdb-version: 8.2\n \n // compile-flags:-g\n \n // gdb-command:set print union on\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n-// gdbr-check:$1 = generic_struct_style_enum::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n+// gdbr-check:$1 = generic_struct_style_enum::Regular<u16, u32, i64>::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n-// gdbr-check:$2 = generic_struct_style_enum::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n+// gdbr-check:$2 = generic_struct_style_enum::Regular<i16, u32, i64>::Case2{a: 0, b: 286331153, c: 286331153}\n \n // gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n-// gdbr-check:$3 = generic_struct_style_enum::Regular::Case3{a: 0, b: 6438275382588823897}\n+// gdbr-check:$3 = generic_struct_style_enum::Regular<u16, i32, u64>::Case3{a: 0, b: 6438275382588823897}\n \n // gdb-command:print univariant\n-// gdbg-check:$4 = {{a = -1}}\n // gdbr-check:$4 = generic_struct_style_enum::Univariant<i32>::TheOnlyCase{a: -1}\n \n "}, {"sha": "ee28968619d8efe36ab2ad9573ed927c85551058", "filename": "src/test/debuginfo/generic-tuple-style-enum-legacy.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum-legacy.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:set print union on\n+// gdb-command:run\n+\n+// gdb-command:print case1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n+// gdbr-check:$1 = generic_tuple_style_enum_legacy::Regular::Case1(0, 31868, 31868, 31868, 31868)\n+\n+// gdb-command:print case2\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n+// gdbr-check:$2 = generic_tuple_style_enum_legacy::Regular::Case2(0, 286331153, 286331153)\n+\n+// gdb-command:print case3\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbr-check:$3 = generic_tuple_style_enum_legacy::Regular::Case3(0, 6438275382588823897)\n+\n+// gdb-command:print univariant\n+// gdbg-check:$4 = {{__0 = -1}}\n+// gdbr-check:$4 = generic_tuple_style_enum_legacy::Univariant<i64>::TheOnlyCase(-1)\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print case1\n+// lldbg-check:[...]$0 = Case1(0, 31868, 31868, 31868, 31868)\n+// lldbr-check:(generic_tuple_style_enum_legacy::Regular<u16, u32, u64>::Case1) case1 = { = 0 = 31868 = 31868 = 31868 = 31868 }\n+\n+// lldb-command:print case2\n+// lldbg-check:[...]$1 = Case2(0, 286331153, 286331153)\n+// lldbr-check:(generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case2) case2 = Regular<i16, i32, i64>::Case2 { generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case1: 0, generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case2: 286331153, generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case3: 286331153 }\n+\n+// lldb-command:print case3\n+// lldbg-check:[...]$2 = Case3(0, 6438275382588823897)\n+// lldbr-check:(generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case3) case3 = Regular<i16, i32, i64>::Case3 { generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case1: 0, generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case2: 6438275382588823897 }\n+\n+// lldb-command:print univariant\n+// lldbg-check:[...]$3 = TheOnlyCase(-1)\n+// lldbr-check:(generic_tuple_style_enum_legacy::Univariant<i64>) univariant = { generic_tuple_style_enum_legacy::TheOnlyCase = { = -1 } }\n+\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Regular::{Case1, Case2, Case3};\n+use self::Univariant::TheOnlyCase;\n+\n+// NOTE: This is a copy of the non-generic test case. The `Txx` type parameters have to be\n+// substituted with something of size `xx` bits and the same alignment as an integer type of the\n+// same size.\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular<T16, T32, T64> {\n+    Case1(T64, T16, T16, T16, T16),\n+    Case2(T64, T32, T32),\n+    Case3(T64, T64)\n+}\n+\n+enum Univariant<T64> {\n+    TheOnlyCase(T64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1: Regular<u16, u32, u64> = Case1(0_u64, 31868_u16, 31868_u16, 31868_u16, 31868_u16);\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2: Regular<i16, i32, i64> = Case2(0_i64, 286331153_i32, 286331153_i32);\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3: Regular<i16, i32, i64> = Case3(0_i64, 6438275382588823897_i64);\n+\n+    let univariant = TheOnlyCase(-1_i64);\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() { () }"}, {"sha": "ebd43daf46479f7ecf363d3ef2a0bc245bd99b77", "filename": "src/test/debuginfo/generic-tuple-style-enum.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -9,8 +9,12 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb and lldb that can\n+// read it.\n+// min-system-llvm-version: 7.0\n+// min-gdb-version: 8.2\n+// rust-lldb\n \n // compile-flags:-g\n \n@@ -20,19 +24,15 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n-// gdbr-check:$1 = generic_tuple_style_enum::Regular::Case1(0, 31868, 31868, 31868, 31868)\n+// gdbr-check:$1 = generic_tuple_style_enum::Regular<u16, u32, u64>::Case1(0, 31868, 31868, 31868, 31868)\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n-// gdbr-check:$2 = generic_tuple_style_enum::Regular::Case2(0, 286331153, 286331153)\n+// gdbr-check:$2 = generic_tuple_style_enum::Regular<i16, i32, i64>::Case2(0, 286331153, 286331153)\n \n // gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n-// gdbr-check:$3 = generic_tuple_style_enum::Regular::Case3(0, 6438275382588823897)\n+// gdbr-check:$3 = generic_tuple_style_enum::Regular<i16, i32, i64>::Case3(0, 6438275382588823897)\n \n // gdb-command:print univariant\n-// gdbg-check:$4 = {{__0 = -1}}\n // gdbr-check:$4 = generic_tuple_style_enum::Univariant<i64>::TheOnlyCase(-1)\n \n \n@@ -41,20 +41,16 @@\n // lldb-command:run\n \n // lldb-command:print case1\n-// lldbg-check:[...]$0 = Case1(0, 31868, 31868, 31868, 31868)\n // lldbr-check:(generic_tuple_style_enum::Regular<u16, u32, u64>::Case1) case1 = { = 0 = 31868 = 31868 = 31868 = 31868 }\n \n // lldb-command:print case2\n-// lldbg-check:[...]$1 = Case2(0, 286331153, 286331153)\n-// lldbr-check:(generic_tuple_style_enum::Regular<i16, i32, i64>::Case2) case2 = Regular<i16, i32, i64>::Case2 { generic_tuple_style_enum::Regular<i16, i32, i64>::Case1: 0, generic_tuple_style_enum::Regular<i16, i32, i64>::Case2: 286331153, generic_tuple_style_enum::Regular<i16, i32, i64>::Case3: 286331153 }\n+// lldbr-check:(generic_tuple_style_enum::Regular<i16, i32, i64>::Case2) case2 = Regular<i16, i32, i64>::Case2 { Case1: 0, Case2: 286331153, Case3: 286331153 }\n \n // lldb-command:print case3\n-// lldbg-check:[...]$2 = Case3(0, 6438275382588823897)\n-// lldbr-check:(generic_tuple_style_enum::Regular<i16, i32, i64>::Case3) case3 = Regular<i16, i32, i64>::Case3 { generic_tuple_style_enum::Regular<i16, i32, i64>::Case1: 0, generic_tuple_style_enum::Regular<i16, i32, i64>::Case2: 6438275382588823897 }\n+// lldbr-check:(generic_tuple_style_enum::Regular<i16, i32, i64>::Case3) case3 = Regular<i16, i32, i64>::Case3 { Case1: 0, Case2: 6438275382588823897 }\n \n // lldb-command:print univariant\n-// lldbg-check:[...]$3 = TheOnlyCase(-1)\n-// lldbr-check:(generic_tuple_style_enum::Univariant<i64>) univariant = { generic_tuple_style_enum::TheOnlyCase = { = -1 } }\n+// lldbr-check:(generic_tuple_style_enum::Univariant<i64>) univariant = { TheOnlyCase = { = -1 } }\n \n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]"}, {"sha": "ffd402ec9361043f476b206a9e7208f883a1c4e0", "filename": "src/test/debuginfo/method-on-tuple-struct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -74,7 +74,7 @@\n // STACK BY REF\n // lldb-command:print *self\n // lldbg-check:[...]$0 = TupleStruct(100, -100.5)\n-// lldbr-check:(method_on_tuple_struct::TupleStruct) *self = { = 100 = -100.5 }\n+// lldbr-check:(method_on_tuple_struct::TupleStruct) *self = TupleStruct(100, -100.5)\n // lldb-command:print arg1\n // lldbg-check:[...]$1 = -1\n // lldbr-check:(isize) arg1 = -1\n@@ -86,7 +86,7 @@\n // STACK BY VAL\n // lldb-command:print self\n // lldbg-check:[...]$3 = TupleStruct(100, -100.5)\n-// lldbr-check:(method_on_tuple_struct::TupleStruct) self = { = 100 = -100.5 }\n+// lldbr-check:(method_on_tuple_struct::TupleStruct) self = TupleStruct(100, -100.5)\n // lldb-command:print arg1\n // lldbg-check:[...]$4 = -3\n // lldbr-check:(isize) arg1 = -3\n@@ -98,7 +98,7 @@\n // OWNED BY REF\n // lldb-command:print *self\n // lldbg-check:[...]$6 = TupleStruct(200, -200.5)\n-// lldbr-check:(method_on_tuple_struct::TupleStruct) *self = { = 200 = -200.5 }\n+// lldbr-check:(method_on_tuple_struct::TupleStruct) *self = TupleStruct(200, -200.5)\n // lldb-command:print arg1\n // lldbg-check:[...]$7 = -5\n // lldbr-check:(isize) arg1 = -5\n@@ -110,7 +110,7 @@\n // OWNED BY VAL\n // lldb-command:print self\n // lldbg-check:[...]$9 = TupleStruct(200, -200.5)\n-// lldbr-check:(method_on_tuple_struct::TupleStruct) self = { = 200 = -200.5 }\n+// lldbr-check:(method_on_tuple_struct::TupleStruct) self = TupleStruct(200, -200.5)\n // lldb-command:print arg1\n // lldbg-check:[...]$10 = -7\n // lldbr-check:(isize) arg1 = -7\n@@ -122,7 +122,7 @@\n // OWNED MOVED\n // lldb-command:print *self\n // lldbg-check:[...]$12 = TupleStruct(200, -200.5)\n-// lldbr-check:(method_on_tuple_struct::TupleStruct) *self = { = 200 = -200.5 }\n+// lldbr-check:(method_on_tuple_struct::TupleStruct) *self = TupleStruct(200, -200.5)\n // lldb-command:print arg1\n // lldbg-check:[...]$13 = -9\n // lldbr-check:(isize) arg1 = -9"}, {"sha": "ab42b2eff99f858bffac19b006b2e23c015fa4ee", "filename": "src/test/debuginfo/nil-enum.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -14,16 +14,21 @@\n // ignore-lldb\n \n \n+// Require LLVM with DW_TAG_variant_part and a gdb that can read it.\n+// gdb 8.2.0 crashes on this test case, see\n+// https://sourceware.org/bugzilla/show_bug.cgi?id=23626\n+// This will be fixed in the next release, which will be >= 8.2.1.\n+// min-system-llvm-version: 7.0\n+// min-gdb-version: 8.2.1\n+\n // compile-flags:-g\n // gdb-command:run\n \n // gdb-command:print first\n-// gdbg-check:$1 = {<No data fields>}\n-// gdbr-check:$1 = <error reading variable>\n+// gdbr-check:$1 = nil_enum::ANilEnum {<No data fields>}\n \n // gdb-command:print second\n-// gdbg-check:$2 = {<No data fields>}\n-// gdbr-check:$2 = <error reading variable>\n+// gdbr-check:$2 = nil_enum::AnotherNilEnum {<No data fields>}\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]"}, {"sha": "ac407ced52747d9624c5d525ad646e5c9a6082ed", "filename": "src/test/debuginfo/recursive-struct-legacy.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Frecursive-struct-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Frecursive-struct-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct-legacy.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,245 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// ignore-lldb\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// gdb-command:run\n+\n+// gdb-command:print stack_unique.value\n+// gdb-check:$1 = 0\n+// gdbg-command:print stack_unique.next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print stack_unique.next.val.value\n+// gdb-check:$2 = 1\n+\n+// gdbg-command:print unique_unique->value\n+// gdbr-command:print unique_unique.value\n+// gdb-check:$3 = 2\n+// gdbg-command:print unique_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print unique_unique.next.val.value\n+// gdb-check:$4 = 3\n+\n+// gdb-command:print vec_unique[0].value\n+// gdb-check:$5 = 6.5\n+// gdbg-command:print vec_unique[0].next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print vec_unique[0].next.val.value\n+// gdb-check:$6 = 7.5\n+\n+// gdbg-command:print borrowed_unique->value\n+// gdbr-command:print borrowed_unique.value\n+// gdb-check:$7 = 8.5\n+// gdbg-command:print borrowed_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print borrowed_unique.next.val.value\n+// gdb-check:$8 = 9.5\n+\n+// LONG CYCLE\n+// gdb-command:print long_cycle1.value\n+// gdb-check:$9 = 20\n+// gdbg-command:print long_cycle1.next->value\n+// gdbr-command:print long_cycle1.next.value\n+// gdb-check:$10 = 21\n+// gdbg-command:print long_cycle1.next->next->value\n+// gdbr-command:print long_cycle1.next.next.value\n+// gdb-check:$11 = 22\n+// gdbg-command:print long_cycle1.next->next->next->value\n+// gdbr-command:print long_cycle1.next.next.next.value\n+// gdb-check:$12 = 23\n+\n+// gdb-command:print long_cycle2.value\n+// gdb-check:$13 = 24\n+// gdbg-command:print long_cycle2.next->value\n+// gdbr-command:print long_cycle2.next.value\n+// gdb-check:$14 = 25\n+// gdbg-command:print long_cycle2.next->next->value\n+// gdbr-command:print long_cycle2.next.next.value\n+// gdb-check:$15 = 26\n+\n+// gdb-command:print long_cycle3.value\n+// gdb-check:$16 = 27\n+// gdbg-command:print long_cycle3.next->value\n+// gdbr-command:print long_cycle3.next.value\n+// gdb-check:$17 = 28\n+\n+// gdb-command:print long_cycle4.value\n+// gdb-check:$18 = 29.5\n+\n+// gdbg-command:print (*****long_cycle_w_anonymous_types).value\n+// gdbr-command:print long_cycle_w_anonymous_types.value\n+// gdb-check:$19 = 30\n+\n+// gdbg-command:print (*****((*****long_cycle_w_anonymous_types).next.RUST$ENCODED$ENUM$0$Empty.val)).value\n+// gdbr-command:print long_cycle_w_anonymous_types.next.val.value\n+// gdb-check:$20 = 31\n+\n+// gdb-command:continue\n+\n+#![allow(unused_variables)]\n+#![feature(box_syntax)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Opt::{Empty, Val};\n+\n+enum Opt<T> {\n+    Empty,\n+    Val { val: T }\n+}\n+\n+struct UniqueNode<T> {\n+    next: Opt<Box<UniqueNode<T>>>,\n+    value: T\n+}\n+\n+struct LongCycle1<T> {\n+    next: Box<LongCycle2<T>>,\n+    value: T,\n+}\n+\n+struct LongCycle2<T> {\n+    next: Box<LongCycle3<T>>,\n+    value: T,\n+}\n+\n+struct LongCycle3<T> {\n+    next: Box<LongCycle4<T>>,\n+    value: T,\n+}\n+\n+struct LongCycle4<T> {\n+    next: Option<Box<LongCycle1<T>>>,\n+    value: T,\n+}\n+\n+struct LongCycleWithAnonymousTypes {\n+    next: Opt<Box<Box<Box<Box<Box<LongCycleWithAnonymousTypes>>>>>>,\n+    value: usize,\n+}\n+\n+// This test case makes sure that recursive structs are properly described. The Node structs are\n+// generic so that we can have a new type (that newly needs to be described) for the different\n+// cases. The potential problem with recursive types is that the DI generation algorithm gets\n+// trapped in an endless loop. To make sure, we actually test this in the different cases, we have\n+// to operate on a new type each time, otherwise we would just hit the DI cache for all but the\n+// first case.\n+\n+// The different cases below (stack_*, unique_*, box_*, etc) are set up so that the type description\n+// algorithm will enter the type reference cycle that is created by a recursive definition from a\n+// different context each time.\n+\n+// The \"long cycle\" cases are constructed to span a longer, indirect recursion cycle between types.\n+// The different locals will cause the DI algorithm to enter the type reference cycle at different\n+// points.\n+\n+fn main() {\n+    let stack_unique: UniqueNode<u16> = UniqueNode {\n+        next: Val {\n+            val: box UniqueNode {\n+                next: Empty,\n+                value: 1,\n+            }\n+        },\n+        value: 0,\n+    };\n+\n+    let unique_unique: Box<UniqueNode<u32>> = box UniqueNode {\n+        next: Val {\n+            val: box UniqueNode {\n+                next: Empty,\n+                value: 3,\n+            }\n+        },\n+        value: 2,\n+    };\n+\n+    let vec_unique: [UniqueNode<f32>; 1] = [UniqueNode {\n+        next: Val {\n+            val: box UniqueNode {\n+                next: Empty,\n+                value: 7.5,\n+            }\n+        },\n+        value: 6.5,\n+    }];\n+\n+    let borrowed_unique: &UniqueNode<f64> = &UniqueNode {\n+        next: Val {\n+            val: box UniqueNode {\n+                next: Empty,\n+                value: 9.5,\n+            }\n+        },\n+        value: 8.5,\n+    };\n+\n+    // LONG CYCLE\n+    let long_cycle1: LongCycle1<u16> = LongCycle1 {\n+        next: box LongCycle2 {\n+            next: box LongCycle3 {\n+                next: box LongCycle4 {\n+                    next: None,\n+                    value: 23,\n+                },\n+                value: 22,\n+            },\n+            value: 21\n+        },\n+        value: 20\n+    };\n+\n+    let long_cycle2: LongCycle2<u32> = LongCycle2 {\n+        next: box LongCycle3 {\n+            next: box LongCycle4 {\n+                next: None,\n+                value: 26,\n+            },\n+            value: 25,\n+        },\n+        value: 24\n+    };\n+\n+    let long_cycle3: LongCycle3<u64> = LongCycle3 {\n+        next: box LongCycle4 {\n+            next: None,\n+            value: 28,\n+        },\n+        value: 27,\n+    };\n+\n+    let long_cycle4: LongCycle4<f32> = LongCycle4 {\n+        next: None,\n+        value: 29.5,\n+    };\n+\n+    // It's important that LongCycleWithAnonymousTypes is encountered only at the end of the\n+    // `box` chain.\n+    let long_cycle_w_anonymous_types = box box box box box LongCycleWithAnonymousTypes {\n+        next: Val {\n+            val: box box box box box LongCycleWithAnonymousTypes {\n+                next: Empty,\n+                value: 31,\n+            }\n+        },\n+        value: 30\n+    };\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "647f95197894e52546814dc5c961e383feccea70", "filename": "src/test/debuginfo/recursive-struct.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -10,74 +10,63 @@\n \n // ignore-tidy-linelength\n // ignore-lldb\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb that can read it.\n+// min-system-llvm-version: 7.0\n+// min-gdb-version: 8.2\n \n // compile-flags:-g\n \n // gdb-command:run\n \n // gdb-command:print stack_unique.value\n // gdb-check:$1 = 0\n-// gdbg-command:print stack_unique.next.RUST$ENCODED$ENUM$0$Empty.val->value\n // gdbr-command:print stack_unique.next.val.value\n // gdb-check:$2 = 1\n \n-// gdbg-command:print unique_unique->value\n // gdbr-command:print unique_unique.value\n // gdb-check:$3 = 2\n-// gdbg-command:print unique_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n // gdbr-command:print unique_unique.next.val.value\n // gdb-check:$4 = 3\n \n // gdb-command:print vec_unique[0].value\n // gdb-check:$5 = 6.5\n-// gdbg-command:print vec_unique[0].next.RUST$ENCODED$ENUM$0$Empty.val->value\n // gdbr-command:print vec_unique[0].next.val.value\n // gdb-check:$6 = 7.5\n \n-// gdbg-command:print borrowed_unique->value\n // gdbr-command:print borrowed_unique.value\n // gdb-check:$7 = 8.5\n-// gdbg-command:print borrowed_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n // gdbr-command:print borrowed_unique.next.val.value\n // gdb-check:$8 = 9.5\n \n // LONG CYCLE\n // gdb-command:print long_cycle1.value\n // gdb-check:$9 = 20\n-// gdbg-command:print long_cycle1.next->value\n // gdbr-command:print long_cycle1.next.value\n // gdb-check:$10 = 21\n-// gdbg-command:print long_cycle1.next->next->value\n // gdbr-command:print long_cycle1.next.next.value\n // gdb-check:$11 = 22\n-// gdbg-command:print long_cycle1.next->next->next->value\n // gdbr-command:print long_cycle1.next.next.next.value\n // gdb-check:$12 = 23\n \n // gdb-command:print long_cycle2.value\n // gdb-check:$13 = 24\n-// gdbg-command:print long_cycle2.next->value\n // gdbr-command:print long_cycle2.next.value\n // gdb-check:$14 = 25\n-// gdbg-command:print long_cycle2.next->next->value\n // gdbr-command:print long_cycle2.next.next.value\n // gdb-check:$15 = 26\n \n // gdb-command:print long_cycle3.value\n // gdb-check:$16 = 27\n-// gdbg-command:print long_cycle3.next->value\n // gdbr-command:print long_cycle3.next.value\n // gdb-check:$17 = 28\n \n // gdb-command:print long_cycle4.value\n // gdb-check:$18 = 29.5\n \n-// gdbg-command:print (*****long_cycle_w_anonymous_types).value\n // gdbr-command:print long_cycle_w_anonymous_types.value\n // gdb-check:$19 = 30\n \n-// gdbg-command:print (*****((*****long_cycle_w_anonymous_types).next.RUST$ENCODED$ENUM$0$Empty.val)).value\n // gdbr-command:print long_cycle_w_anonymous_types.next.val.value\n // gdb-check:$20 = 31\n "}, {"sha": "fd2c6fa8171296fd20cb0cc0794b8419649f3d21", "filename": "src/test/debuginfo/struct-style-enum-legacy.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum-legacy.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:set print union on\n+// gdb-command:run\n+\n+// gdb-command:print case1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n+// gdbr-check:$1 = struct_style_enum_legacy::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n+\n+// gdb-command:print case2\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n+// gdbr-check:$2 = struct_style_enum_legacy::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n+\n+// gdb-command:print case3\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbr-check:$3 = struct_style_enum_legacy::Regular::Case3{a: 0, b: 6438275382588823897}\n+\n+// gdb-command:print univariant\n+// gdbg-check:$4 = {{a = -1}}\n+// gdbr-check:$4 = struct_style_enum_legacy::Univariant::TheOnlyCase{a: -1}\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print case1\n+// lldbg-check:[...]$0 = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 }\n+// lldbr-check:(struct_style_enum_legacy::Regular::Case1) case1 = { a = 0 b = 31868 c = 31868 d = 31868 e = 31868 }\n+\n+// lldb-command:print case2\n+// lldbg-check:[...]$1 = Case2 { a: 0, b: 286331153, c: 286331153 }\n+// lldbr-check:(struct_style_enum_legacy::Regular::Case2) case2 = Case2 { struct_style_enum_legacy::Regular::Case1: 0, struct_style_enum_legacy::Regular::Case2: 286331153, struct_style_enum_legacy::Regular::Case3: 286331153 }\n+\n+// lldb-command:print case3\n+// lldbg-check:[...]$2 = Case3 { a: 0, b: 6438275382588823897 }\n+// lldbr-check:(struct_style_enum_legacy::Regular::Case3) case3 = Case3 { struct_style_enum_legacy::Regular::Case1: 0, struct_style_enum_legacy::Regular::Case2: 6438275382588823897 }\n+\n+// lldb-command:print univariant\n+// lldbg-check:[...]$3 = TheOnlyCase { a: -1 }\n+// lldbr-check:(struct_style_enum_legacy::Univariant) univariant = Univariant { struct_style_enum_legacy::TheOnlyCase: TheOnlyCase { a: -1 } }\n+\n+#![allow(unused_variables)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Regular::{Case1, Case2, Case3};\n+use self::Univariant::TheOnlyCase;\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular {\n+    Case1 { a: u64, b: u16, c: u16, d: u16, e: u16},\n+    Case2 { a: u64, b: u32, c: u32},\n+    Case3 { a: u64, b: u64 }\n+}\n+\n+enum Univariant {\n+    TheOnlyCase { a: i64 }\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1 = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2 = Case2 { a: 0, b: 286331153, c: 286331153 };\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3 = Case3 { a: 0, b: 6438275382588823897 };\n+\n+    let univariant = TheOnlyCase { a: -1 };\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "722ca00e0488908a64c70e6bdeb8c0f2b6d18f6f", "filename": "src/test/debuginfo/struct-style-enum.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -9,8 +9,12 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb and lldb that can\n+// read it.\n+// min-system-llvm-version: 7.0\n+// min-gdb-version: 8.2\n+// rust-lldb\n \n // compile-flags:-g\n \n@@ -20,19 +24,15 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n // gdbr-check:$1 = struct_style_enum::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n // gdbr-check:$2 = struct_style_enum::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n \n // gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n // gdbr-check:$3 = struct_style_enum::Regular::Case3{a: 0, b: 6438275382588823897}\n \n // gdb-command:print univariant\n-// gdbg-check:$4 = {{a = -1}}\n // gdbr-check:$4 = struct_style_enum::Univariant::TheOnlyCase{a: -1}\n \n \n@@ -41,20 +41,16 @@\n // lldb-command:run\n \n // lldb-command:print case1\n-// lldbg-check:[...]$0 = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 }\n // lldbr-check:(struct_style_enum::Regular::Case1) case1 = { a = 0 b = 31868 c = 31868 d = 31868 e = 31868 }\n \n // lldb-command:print case2\n-// lldbg-check:[...]$1 = Case2 { a: 0, b: 286331153, c: 286331153 }\n-// lldbr-check:(struct_style_enum::Regular::Case2) case2 = Case2 { struct_style_enum::Regular::Case1: 0, struct_style_enum::Regular::Case2: 286331153, struct_style_enum::Regular::Case3: 286331153 }\n+// lldbr-check:(struct_style_enum::Regular::Case2) case2 = Case2 { Case1: 0, Case2: 286331153, Case3: 286331153 }\n \n // lldb-command:print case3\n-// lldbg-check:[...]$2 = Case3 { a: 0, b: 6438275382588823897 }\n-// lldbr-check:(struct_style_enum::Regular::Case3) case3 = Case3 { struct_style_enum::Regular::Case1: 0, struct_style_enum::Regular::Case2: 6438275382588823897 }\n+// lldbr-check:(struct_style_enum::Regular::Case3) case3 = Case3 { Case1: 0, Case2: 6438275382588823897 }\n \n // lldb-command:print univariant\n-// lldbg-check:[...]$3 = TheOnlyCase { a: -1 }\n-// lldbr-check:(struct_style_enum::Univariant) univariant = Univariant { struct_style_enum::TheOnlyCase: TheOnlyCase { a: -1 } }\n+// lldbr-check:(struct_style_enum::Univariant) univariant = Univariant { TheOnlyCase: TheOnlyCase { a: -1 } }\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]"}, {"sha": "e33f6db534f80b6b74653d55357349a5de53023c", "filename": "src/test/debuginfo/tuple-style-enum-legacy.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum-legacy.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:set print union on\n+// gdb-command:run\n+\n+// gdb-command:print case1\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n+// gdbr-check:$1 = tuple_style_enum_legacy::Regular::Case1(0, 31868, 31868, 31868, 31868)\n+\n+// gdb-command:print case2\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n+// gdbr-check:$2 = tuple_style_enum_legacy::Regular::Case2(0, 286331153, 286331153)\n+\n+// gdb-command:print case3\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbr-check:$3 = tuple_style_enum_legacy::Regular::Case3(0, 6438275382588823897)\n+\n+// gdb-command:print univariant\n+// gdbg-check:$4 = {{__0 = -1}}\n+// gdbr-check:$4 = tuple_style_enum_legacy::Univariant::TheOnlyCase(-1)\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print case1\n+// lldbg-check:[...]$0 = Case1(0, 31868, 31868, 31868, 31868)\n+// lldbr-check:(tuple_style_enum_legacy::Regular::Case1) case1 = { = 0 = 31868 = 31868 = 31868 = 31868 }\n+\n+// lldb-command:print case2\n+// lldbg-check:[...]$1 = Case2(0, 286331153, 286331153)\n+// lldbr-check:(tuple_style_enum_legacy::Regular::Case2) case2 = Case2 { tuple_style_enum_legacy::Regular::Case1: 0, tuple_style_enum_legacy::Regular::Case2: 286331153, tuple_style_enum_legacy::Regular::Case3: 286331153 }\n+\n+// lldb-command:print case3\n+// lldbg-check:[...]$2 = Case3(0, 6438275382588823897)\n+// lldbr-check:(tuple_style_enum_legacy::Regular::Case3) case3 = Case3 { tuple_style_enum_legacy::Regular::Case1: 0, tuple_style_enum_legacy::Regular::Case2: 6438275382588823897 }\n+\n+// lldb-command:print univariant\n+// lldbg-check:[...]$3 = TheOnlyCase(-1)\n+// lldbr-check:(tuple_style_enum_legacy::Univariant) univariant = { tuple_style_enum_legacy::TheOnlyCase = { = -1 } }\n+\n+#![allow(unused_variables)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use self::Regular::{Case1, Case2, Case3};\n+use self::Univariant::TheOnlyCase;\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular {\n+    Case1(u64, u16, u16, u16, u16),\n+    Case2(u64, u32, u32),\n+    Case3(u64, u64)\n+}\n+\n+enum Univariant {\n+    TheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1 = Case1(0, 31868, 31868, 31868, 31868);\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2 = Case2(0, 286331153, 286331153);\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3 = Case3(0, 6438275382588823897);\n+\n+    let univariant = TheOnlyCase(-1);\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "d976839f08c1135ae740d977c34f18a1787d5ea6", "filename": "src/test/debuginfo/tuple-style-enum.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -9,8 +9,12 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb and lldb that can\n+// read it.\n+// min-system-llvm-version: 7.0\n+// min-gdb-version: 8.2\n+// rust-lldb\n \n // compile-flags:-g\n \n@@ -20,19 +24,15 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n // gdbr-check:$1 = tuple_style_enum::Regular::Case1(0, 31868, 31868, 31868, 31868)\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n // gdbr-check:$2 = tuple_style_enum::Regular::Case2(0, 286331153, 286331153)\n \n // gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n // gdbr-check:$3 = tuple_style_enum::Regular::Case3(0, 6438275382588823897)\n \n // gdb-command:print univariant\n-// gdbg-check:$4 = {{__0 = -1}}\n // gdbr-check:$4 = tuple_style_enum::Univariant::TheOnlyCase(-1)\n \n \n@@ -41,20 +41,16 @@\n // lldb-command:run\n \n // lldb-command:print case1\n-// lldbg-check:[...]$0 = Case1(0, 31868, 31868, 31868, 31868)\n // lldbr-check:(tuple_style_enum::Regular::Case1) case1 = { = 0 = 31868 = 31868 = 31868 = 31868 }\n \n // lldb-command:print case2\n-// lldbg-check:[...]$1 = Case2(0, 286331153, 286331153)\n-// lldbr-check:(tuple_style_enum::Regular::Case2) case2 = Case2 { tuple_style_enum::Regular::Case1: 0, tuple_style_enum::Regular::Case2: 286331153, tuple_style_enum::Regular::Case3: 286331153 }\n+// lldbr-check:(tuple_style_enum::Regular::Case2) case2 = Case2 { Case1: 0, Case2: 286331153, Case3: 286331153 }\n \n // lldb-command:print case3\n-// lldbg-check:[...]$2 = Case3(0, 6438275382588823897)\n-// lldbr-check:(tuple_style_enum::Regular::Case3) case3 = Case3 { tuple_style_enum::Regular::Case1: 0, tuple_style_enum::Regular::Case2: 6438275382588823897 }\n+// lldbr-check:(tuple_style_enum::Regular::Case3) case3 = Case3 { Case1: 0, Case2: 6438275382588823897 }\n \n // lldb-command:print univariant\n-// lldbg-check:[...]$3 = TheOnlyCase(-1)\n-// lldbr-check:(tuple_style_enum::Univariant) univariant = { tuple_style_enum::TheOnlyCase = { = -1 } }\n+// lldbr-check:(tuple_style_enum::Univariant) univariant = { TheOnlyCase = { = -1 } }\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]"}, {"sha": "91fece334b2ab7314db569cb694c98de3f807387", "filename": "src/test/debuginfo/unique-enum-legacy.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Funique-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Funique-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum-legacy.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// min-lldb-version: 310\n+\n+// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n+// enum debuginfo fallback mode.  Once those are desupported, this\n+// test can be removed, as there is another (non-\"legacy\") test that\n+// tests the new mode.\n+// ignore-llvm-version: 7.0 - 9.9.9\n+// ignore-gdb-version: 7.11.90 - 7.12.9\n+// ignore-gdb-version: 8.2 - 9.9\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+\n+// gdb-command:print *the_a\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n+// gdbr-check:$1 = unique_enum_legacy::ABC::TheA{x: 0, y: 8970181431921507452}\n+\n+// gdb-command:print *the_b\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbr-check:$2 = unique_enum_legacy::ABC::TheB(0, 286331153, 286331153)\n+\n+// gdb-command:print *univariant\n+// gdbg-check:$3 = {{__0 = 123234}}\n+// gdbr-check:$3 = unique_enum_legacy::Univariant::TheOnlyCase(123234)\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print *the_a\n+// lldbg-check:[...]$0 = TheA { x: 0, y: 8970181431921507452 }\n+// lldbr-check:(unique_enum_legacy::ABC::TheA) *the_a = TheA { unique_enum_legacy::ABC::TheA: 0, unique_enum_legacy::ABC::TheB: 8970181431921507452 }\n+\n+// lldb-command:print *the_b\n+// lldbg-check:[...]$1 = TheB(0, 286331153, 286331153)\n+// lldbr-check:(unique_enum_legacy::ABC::TheB) *the_b = { = 0 = 286331153 = 286331153 }\n+\n+// lldb-command:print *univariant\n+// lldbg-check:[...]$2 = TheOnlyCase(123234)\n+// lldbr-check:(unique_enum_legacy::Univariant) *univariant = { unique_enum_legacy::TheOnlyCase = { = 123234 } }\n+\n+#![allow(unused_variables)]\n+#![feature(box_syntax)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum ABC {\n+    TheA { x: i64, y: i64 },\n+    TheB (i64, i32, i32),\n+}\n+\n+// This is a special case since it does not have the implicit discriminant field.\n+enum Univariant {\n+    TheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianness trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let the_a: Box<_> = box ABC::TheA { x: 0, y: 8970181431921507452 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let the_b: Box<_> = box ABC::TheB (0, 286331153, 286331153);\n+\n+    let univariant: Box<_> = box Univariant::TheOnlyCase(123234);\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "aab8edc55f74c108c2c07db5f4745165e5df27d2", "filename": "src/test/debuginfo/unique-enum.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -9,8 +9,12 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb and lldb that can\n+// read it.\n+// min-system-llvm-version: 7.0\n+// min-gdb-version: 8.2\n+// rust-lldb\n \n // compile-flags:-g\n \n@@ -19,15 +23,12 @@\n // gdb-command:run\n \n // gdb-command:print *the_a\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n // gdbr-check:$1 = unique_enum::ABC::TheA{x: 0, y: 8970181431921507452}\n \n // gdb-command:print *the_b\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n // gdbr-check:$2 = unique_enum::ABC::TheB(0, 286331153, 286331153)\n \n // gdb-command:print *univariant\n-// gdbg-check:$3 = {{__0 = 123234}}\n // gdbr-check:$3 = unique_enum::Univariant::TheOnlyCase(123234)\n \n \n@@ -36,16 +37,13 @@\n // lldb-command:run\n \n // lldb-command:print *the_a\n-// lldbg-check:[...]$0 = TheA { x: 0, y: 8970181431921507452 }\n-// lldbr-check:(unique_enum::ABC::TheA) *the_a = TheA { unique_enum::ABC::TheA: 0, unique_enum::ABC::TheB: 8970181431921507452 }\n+// lldbr-check:(unique_enum::ABC::TheA) *the_a = TheA { TheA: 0, TheB: 8970181431921507452 }\n \n // lldb-command:print *the_b\n-// lldbg-check:[...]$1 = TheB(0, 286331153, 286331153)\n // lldbr-check:(unique_enum::ABC::TheB) *the_b = { = 0 = 286331153 = 286331153 }\n \n // lldb-command:print *univariant\n-// lldbg-check:[...]$2 = TheOnlyCase(123234)\n-// lldbr-check:(unique_enum::Univariant) *univariant = { unique_enum::TheOnlyCase = { = 123234 } }\n+// lldbr-check:(unique_enum::Univariant) *univariant = { TheOnlyCase = { = 123234 } }\n \n #![allow(unused_variables)]\n #![feature(box_syntax)]"}, {"sha": "39267edaac04566b535657a5ec1920928b7a881f", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -99,7 +99,7 @@\n \n // lldb-command:print padded_tuple\n // lldbg-check:[...]$4 = &[(6, 7), (8, 9)]\n-// lldbr-check:(&[(i32, i16)]) padded_tuple = { data_ptr = *0x555555554ff0 length = 2 }\n+// lldbr-check:(&[(i32, i16)]) padded_tuple = { data_ptr = *0x555555555030 length = 2 }\n \n // lldb-command:print padded_struct\n // lldbg-check:[...]$5 = &[AStruct { x: 10, y: 11, z: 12 }, AStruct { x: 13, y: 14, z: 15 }]"}, {"sha": "f12dd31c402d9e85d11b1cc542ac477136290b5d", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db7abe5b6f3cdfca736f9238689cbea8ef61c7e/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -243,6 +243,29 @@ impl EarlyProps {\n                     // Ignore if using system LLVM and actual version\n                     // is smaller the minimum required version\n                     config.system_llvm && &actual_version[..] < min_version\n+                } else if line.starts_with(\"ignore-llvm-version\") {\n+                    // Syntax is: \"ignore-llvm-version <version1> [- <version2>]\"\n+                    let range_components = line.split(' ')\n+                        .skip(1) // Skip the directive.\n+                        .map(|s| s.trim())\n+                        .filter(|word| !word.is_empty() && word != &\"-\")\n+                        .take(3) // 3 or more = invalid, so take at most 3.\n+                        .collect::<Vec<&str>>();\n+                    match range_components.len() {\n+                        1 => {\n+                            &actual_version[..] == range_components[0]\n+                        }\n+                        2 => {\n+                            let v_min = range_components[0];\n+                            let v_max = range_components[1];\n+                            if v_max < v_min {\n+                                panic!(\"Malformed LLVM version range: max < min\")\n+                            }\n+                            // Ignore if version lies inside of range.\n+                            &actual_version[..] >= v_min && &actual_version[..] <= v_max\n+                        }\n+                        _ => panic!(\"Malformed LLVM version directive\"),\n+                    }\n                 } else {\n                     false\n                 }"}, {"sha": "29bf48582812212450f4caf7da1af3f18c52bfef", "filename": "src/tools/lldb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flldb?ref=0db7abe5b6f3cdfca736f9238689cbea8ef61c7e", "patch": "@@ -1 +1 @@\n-Subproject commit 7728fa22bebea288abfea3b70cf795c60b93df3a\n+Subproject commit 29bf48582812212450f4caf7da1af3f18c52bfef"}]}