{"sha": "7f5d2722afea902e89e44062765733c4800b7d21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNWQyNzIyYWZlYTkwMmU4OWU0NDA2Mjc2NTczM2M0ODAwYjdkMjE=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-10-06T23:01:12Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-13T21:38:23Z"}, "message": "move copy specialization into sys::unix module", "tree": {"sha": "32423e29495ae7c9a3866603f86986a981e42dd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32423e29495ae7c9a3866603f86986a981e42dd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f5d2722afea902e89e44062765733c4800b7d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5d2722afea902e89e44062765733c4800b7d21", "html_url": "https://github.com/rust-lang/rust/commit/7f5d2722afea902e89e44062765733c4800b7d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f5d2722afea902e89e44062765733c4800b7d21/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad9b07c7e5c1a24ec3b75a5bc70708dbed2e40f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9b07c7e5c1a24ec3b75a5bc70708dbed2e40f9", "html_url": "https://github.com/rust-lang/rust/commit/ad9b07c7e5c1a24ec3b75a5bc70708dbed2e40f9"}], "stats": {"total": 827, "additions": 435, "deletions": 392}, "files": [{"sha": "b88bca2f2b4ff04a6140f439f818a6e1f6da2fca", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 8, "deletions": 377, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d2722afea902e89e44062765733c4800b7d21/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d2722afea902e89e44062765733c4800b7d21/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=7f5d2722afea902e89e44062765733c4800b7d21", "patch": "@@ -45,15 +45,17 @@ where\n     R: Read,\n     W: Write,\n {\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    {\n-        kernel_copy::copy_spec(reader, writer)\n+    cfg_if::cfg_if! {\n+        if #[cfg(any(target_os = \"linux\", target_os = \"android\"))] {\n+            crate::sys::kernel_copy::copy_spec(reader, writer)\n+        } else {\n+            generic_copy(reader, writer)\n+        }\n     }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    generic_copy(reader, writer)\n }\n \n+/// The general read-write-loop implementation of\n+/// `io::copy` that is used when specializations are not available or not applicable.\n pub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n where\n     R: Read,\n@@ -84,374 +86,3 @@ where\n         written += len as u64;\n     }\n }\n-\n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-mod kernel_copy {\n-\n-    use crate::cmp::min;\n-    use crate::convert::TryInto;\n-    use crate::fs::{File, Metadata};\n-    use crate::io::{\n-        BufRead, BufReader, BufWriter, Read, Result, StderrLock, StdinLock, StdoutLock, Take, Write,\n-    };\n-    use crate::mem::ManuallyDrop;\n-    use crate::net::TcpStream;\n-    use crate::os::unix::fs::FileTypeExt;\n-    use crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\n-    use crate::process::{ChildStderr, ChildStdin, ChildStdout};\n-    use crate::sys::fs::{copy_regular_files, sendfile_splice, CopyResult, SpliceMode};\n-\n-    pub(super) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n-        read: &mut R,\n-        write: &mut W,\n-    ) -> Result<u64> {\n-        let copier = Copier { read, write };\n-        SpecCopy::copy(copier)\n-    }\n-\n-    /// This type represents either the inferred `FileType` of a `RawFd` based on the source\n-    /// type from which it was extracted or the actual metadata\n-    ///\n-    /// The methods on this type only provide hints, due to `AsRawFd` and `FromRawFd` the inferred\n-    /// type may be wrong.\n-    enum FdMeta {\n-        /// We obtained the FD from a type that can contain any type of `FileType` and queried the metadata\n-        /// because it is cheaper than probing all possible syscalls (reader side)\n-        Metadata(Metadata),\n-        Socket,\n-        Pipe,\n-        /// We don't have any metadata, e.g. because the original type was `File` which can represent\n-        /// any `FileType` and we did not query the metadata either since it did not seem beneficial\n-        /// (writer side)\n-        NoneObtained,\n-    }\n-\n-    impl FdMeta {\n-        fn maybe_fifo(&self) -> bool {\n-            match self {\n-                FdMeta::Metadata(meta) => meta.file_type().is_fifo(),\n-                FdMeta::Socket => false,\n-                FdMeta::Pipe => true,\n-                FdMeta::NoneObtained => true,\n-            }\n-        }\n-\n-        fn potential_sendfile_source(&self) -> bool {\n-            match self {\n-                // procfs erronously shows 0 length on non-empty readable files.\n-                // and if a file is truly empty then a `read` syscall will determine that and skip the write syscall\n-                // thus there would be benefit from attempting sendfile\n-                FdMeta::Metadata(meta)\n-                    if meta.file_type().is_file() && meta.len() > 0\n-                        || meta.file_type().is_block_device() =>\n-                {\n-                    true\n-                }\n-                _ => false,\n-            }\n-        }\n-\n-        fn copy_file_range_candidate(&self) -> bool {\n-            match self {\n-                // copy_file_range will fail on empty procfs files. `read` can determine whether EOF has been reached\n-                // without extra cost and skip the write, thus there is no benefit in attempting copy_file_range\n-                FdMeta::Metadata(meta) if meta.is_file() && meta.len() > 0 => true,\n-                FdMeta::NoneObtained => true,\n-                _ => false,\n-            }\n-        }\n-    }\n-\n-    struct CopyParams(FdMeta, Option<RawFd>);\n-\n-    struct Copier<'a, 'b, R: Read + ?Sized, W: Write + ?Sized> {\n-        pub read: &'a mut R,\n-        pub write: &'b mut W,\n-    }\n-\n-    trait SpecCopy {\n-        fn copy(self) -> Result<u64>;\n-    }\n-\n-    impl<R: Read + ?Sized, W: Write + ?Sized> SpecCopy for Copier<'_, '_, R, W> {\n-        default fn copy(self) -> Result<u64> {\n-            super::generic_copy(self.read, self.write)\n-        }\n-    }\n-\n-    impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n-        fn copy(self) -> Result<u64> {\n-            let (reader, writer) = (self.read, self.write);\n-            let r_cfg = reader.properties();\n-            let w_cfg = writer.properties();\n-\n-            // before direct operations on file descriptors ensure that all source and sink buffers are emtpy\n-            let mut flush = || -> crate::io::Result<u64> {\n-                let bytes = reader.drain_to(writer, u64::MAX)?;\n-                // BufWriter buffered bytes have already been accounted for in earlier write() calls\n-                writer.flush()?;\n-                Ok(bytes)\n-            };\n-\n-            let mut written = 0u64;\n-\n-            if let (CopyParams(input_meta, Some(readfd)), CopyParams(output_meta, Some(writefd))) =\n-                (r_cfg, w_cfg)\n-            {\n-                written += flush()?;\n-                let max_write = reader.min_limit();\n-\n-                if input_meta.copy_file_range_candidate() && output_meta.copy_file_range_candidate()\n-                {\n-                    let result = copy_regular_files(readfd, writefd, max_write);\n-\n-                    match result {\n-                        CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n-                        CopyResult::Ended(err) => return err,\n-                        CopyResult::Fallback(bytes) => written += bytes,\n-                    }\n-                }\n-\n-                // on modern kernels sendfile can copy from any mmapable type (some but not all regular files and block devices)\n-                // to any writable file descriptor. On older kernels the writer side can only be a socket.\n-                // So we just try and fallback if needed.\n-                // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n-                // fall back to the generic copy loop.\n-                if input_meta.potential_sendfile_source() {\n-                    let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n-\n-                    match result {\n-                        CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n-                        CopyResult::Ended(err) => return err,\n-                        CopyResult::Fallback(bytes) => written += bytes,\n-                    }\n-                }\n-\n-                if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n-                    let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n-\n-                    match result {\n-                        CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n-                        CopyResult::Ended(err) => return err,\n-                        CopyResult::Fallback(0) => { /* use fallback */ }\n-                        CopyResult::Fallback(_) => {\n-                            unreachable!(\"splice should not return > 0 bytes on the fallback path\")\n-                        }\n-                    }\n-                }\n-            }\n-\n-            match super::generic_copy(reader, writer) {\n-                Ok(bytes) => Ok(bytes + written),\n-                err => err,\n-            }\n-        }\n-    }\n-\n-    #[rustc_specialization_trait]\n-    trait CopyRead: Read {\n-        fn drain_to<W: Write>(&mut self, _writer: &mut W, _limit: u64) -> Result<u64> {\n-            Ok(0)\n-        }\n-\n-        /// The minimum of the limit of all `Take<_>` wrappers, `u64::MAX` otherwise.\n-        /// This method does not account for data `BufReader` buffers and would underreport\n-        /// the limit of a `Take<BufReader<Take<_>>>` type. Thus its result is only valid\n-        /// after draining the buffers.\n-        fn min_limit(&self) -> u64 {\n-            u64::MAX\n-        }\n-\n-        fn properties(&self) -> CopyParams;\n-    }\n-\n-    #[rustc_specialization_trait]\n-    trait CopyWrite: Write {\n-        fn properties(&self) -> CopyParams;\n-    }\n-\n-    impl<T> CopyRead for &mut T\n-    where\n-        T: CopyRead,\n-    {\n-        fn drain_to<W: Write>(&mut self, writer: &mut W, limit: u64) -> Result<u64> {\n-            (**self).drain_to(writer, limit)\n-        }\n-\n-        fn min_limit(&self) -> u64 {\n-            (**self).min_limit()\n-        }\n-\n-        fn properties(&self) -> CopyParams {\n-            (**self).properties()\n-        }\n-    }\n-\n-    impl<T> CopyWrite for &mut T\n-    where\n-        T: CopyWrite,\n-    {\n-        fn properties(&self) -> CopyParams {\n-            (**self).properties()\n-        }\n-    }\n-\n-    impl CopyRead for File {\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyRead for &File {\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyWrite for File {\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyWrite for &File {\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyRead for TcpStream {\n-        fn properties(&self) -> CopyParams {\n-            // avoid the stat syscall since we can be fairly sure it's a socket\n-            CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyRead for &TcpStream {\n-        fn properties(&self) -> CopyParams {\n-            // avoid the stat syscall since we can be fairly sure it's a socket\n-            CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyWrite for TcpStream {\n-        fn properties(&self) -> CopyParams {\n-            // avoid the stat syscall since we can be fairly sure it's a socket\n-            CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyWrite for &TcpStream {\n-        fn properties(&self) -> CopyParams {\n-            // avoid the stat syscall since we can be fairly sure it's a socket\n-            CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyWrite for ChildStdin {\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyRead for ChildStdout {\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyRead for ChildStderr {\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyRead for StdinLock<'_> {\n-        fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n-            let buf_reader = self.as_mut_buf();\n-            let buf = buf_reader.buffer();\n-            let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n-            let bytes_drained = buf.len();\n-            writer.write_all(buf)?;\n-            buf_reader.consume(bytes_drained);\n-\n-            Ok(bytes_drained as u64)\n-        }\n-\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyWrite for StdoutLock<'_> {\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl CopyWrite for StderrLock<'_> {\n-        fn properties(&self) -> CopyParams {\n-            CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n-        }\n-    }\n-\n-    impl<T: CopyRead> CopyRead for Take<T> {\n-        fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n-            let local_limit = self.limit();\n-            let combined_limit = min(outer_limit, local_limit);\n-            let bytes_drained = self.get_mut().drain_to(writer, combined_limit)?;\n-            // update limit since read() was bypassed\n-            self.set_limit(local_limit - bytes_drained);\n-\n-            Ok(bytes_drained)\n-        }\n-\n-        fn min_limit(&self) -> u64 {\n-            min(Take::limit(self), self.get_ref().min_limit())\n-        }\n-\n-        fn properties(&self) -> CopyParams {\n-            self.get_ref().properties()\n-        }\n-    }\n-\n-    impl<T: CopyRead> CopyRead for BufReader<T> {\n-        fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n-            let buf = self.buffer();\n-            let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n-            let bytes = buf.len();\n-            writer.write_all(buf)?;\n-            self.consume(bytes);\n-\n-            let remaining = outer_limit - bytes as u64;\n-\n-            // in case of nested bufreaders we also need to drain the ones closer to the source\n-            let inner_bytes = self.get_mut().drain_to(writer, remaining)?;\n-\n-            Ok(bytes as u64 + inner_bytes)\n-        }\n-\n-        fn min_limit(&self) -> u64 {\n-            self.get_ref().min_limit()\n-        }\n-\n-        fn properties(&self) -> CopyParams {\n-            self.get_ref().properties()\n-        }\n-    }\n-\n-    impl<T: CopyWrite> CopyWrite for BufWriter<T> {\n-        fn properties(&self) -> CopyParams {\n-            self.get_ref().properties()\n-        }\n-    }\n-\n-    fn fd_to_meta<T: AsRawFd>(fd: &T) -> FdMeta {\n-        let fd = fd.as_raw_fd();\n-        let file: ManuallyDrop<File> = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });\n-        match file.metadata() {\n-            Ok(meta) => FdMeta::Metadata(meta),\n-            Err(_) => FdMeta::NoneObtained,\n-        }\n-    }\n-}"}, {"sha": "81cc0a59eb61ffc4c0a7922e2fbc747b791605c5", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d2722afea902e89e44062765733c4800b7d21/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d2722afea902e89e44062765733c4800b7d21/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=7f5d2722afea902e89e44062765733c4800b7d21", "patch": "@@ -1195,15 +1195,15 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     let max_len = u64::MAX;\n     let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n \n-    return match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {\n+    match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {\n         CopyResult::Ended(result) => result,\n         CopyResult::Fallback(written) => {\n             // fallback is only > 0 on EOVERFLOW, which shouldn't happen\n             // because the copy loop starts at a file offset 0 and countns down from `len`\n             assert_eq!(0, written);\n             io::copy::generic_copy(&mut reader, &mut writer)\n         }\n-    };\n+    }\n }\n \n /// linux-specific implementation that will attempt to use copy_file_range for copy offloading\n@@ -1330,19 +1330,7 @@ pub(crate) fn sendfile_splice(\n                 cvt(unsafe { libc::sendfile(writer, reader, ptr::null_mut(), chunk_size) })\n             }\n             SpliceMode::Splice => cvt(unsafe {\n-                libc::splice(\n-                    reader,\n-                    ptr::null_mut(),\n-                    writer,\n-                    ptr::null_mut(),\n-                    // default pipe size is 64KiB. try to only fill/drain half of that capacity\n-                    // so that the next loop iteration won't be put to sleep.\n-                    // If reader and writer operate at the same pace they will experience fewer blocking waits.\n-                    // This is only needed for splice since sendfile stays in kernel space when it has to block.\n-                    //crate::cmp::min(32*1024, chunk_size),\n-                    chunk_size,\n-                    0,\n-                )\n+                libc::splice(reader, ptr::null_mut(), writer, ptr::null_mut(), chunk_size, 0)\n             }),\n         };\n "}, {"sha": "4b7a5f508d9e1afe46474403c9ac3ecdd0065d25", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d2722afea902e89e44062765733c4800b7d21/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d2722afea902e89e44062765733c4800b7d21/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=7f5d2722afea902e89e44062765733c4800b7d21", "patch": "@@ -0,0 +1,422 @@\n+//! This module contains specializations that can offload `io::copy()` operations on file descriptor\n+//! containing types (`File`, `TcpStream`, etc.) to more efficient syscalls than `read(2)` and `write(2)`.\n+//!\n+//! Specialization is only applied to wholly std-owned types so that user code can't observe\n+//! that the `Read` and `Write` traits are not used.\n+//!\n+//! Since a copy operation involves a reader and writer side where each can consist of different types\n+//! and also involve generic wrappers (e.g. `Take`, `BufReader`) it is not practical to specialize\n+//! a single method on all possible combinations.\n+//!\n+//! Instead readers and writers are handled separately by the `CopyRead` and `CopyWrite` specialization\n+//! traits and then specialized on by the `Copier::copy` method.\n+//!\n+//! `Copier` uses the specialization traits to unpack the underlying file descriptors and\n+//! additional prerequisites and constraints imposed by the wrapper types.\n+//!\n+//! Once it has obtained all necessary pieces and brought any wrapper types into a state where they\n+//! can be safely bypassed it will attempt to use the `copy_file_range(2)`,\n+//! `sendfile(2)` or `splice(2)` syscalls to move data directly between file descriptors.\n+//! Since those syscalls have requirements that cannot be fully checked in advance and\n+//! gathering additional information about file descriptors would require additional syscalls\n+//! anyway it simply attempts to use them one after another (guided by inaccurate hints) to\n+//! figure out which one works and and falls back to the generic read-write copy loop if none of them\n+//! does.\n+//! Once a working syscall is found for a pair of file descriptors it will be called in a loop\n+//! until the copy operation is completed.\n+//!\n+//! Advantages of using these syscalls:\n+//!\n+//! * fewer context switches since reads and writes are coalesced into a single syscall\n+//!   and more bytes are transferred per syscall. This translates to higher throughput\n+//!   and fewer CPU cycles, at least for sufficiently large transfers to amortize the initial probing.\n+//! * `copy_file_range` creates reflink copies on CoW filesystems, thus moving less data and\n+//!   consuming less disk space\n+//! * `sendfile` and `splice` can perform zero-copy IO under some circumstances while\n+//!   a naive copy loop would move every byte through the CPU.\n+//!\n+//! Drawbacks:\n+//!\n+//! * copy operations smaller than the default buffer size can under some circumstances, especially\n+//!   on older kernels, incur more syscalls than the naive approach would. As mentioned above\n+//!   the syscall selection is guided by hints to minimize this possibility but they are not perfect.\n+//! * optimizations only apply to std types. If a user adds a custom wrapper type, e.g. to report\n+//!   progress, they can hit a performance cliff.\n+//! * complexity\n+\n+use crate::cmp::min;\n+use crate::convert::TryInto;\n+use crate::fs::{File, Metadata};\n+use crate::io::copy::generic_copy;\n+use crate::io::{\n+    BufRead, BufReader, BufWriter, Read, Result, StderrLock, StdinLock, StdoutLock, Take, Write,\n+};\n+use crate::mem::ManuallyDrop;\n+use crate::net::TcpStream;\n+use crate::os::unix::fs::FileTypeExt;\n+use crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\n+use crate::process::{ChildStderr, ChildStdin, ChildStdout};\n+use crate::sys::fs::{copy_regular_files, sendfile_splice, CopyResult, SpliceMode};\n+\n+pub(crate) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n+    read: &mut R,\n+    write: &mut W,\n+) -> Result<u64> {\n+    let copier = Copier { read, write };\n+    SpecCopy::copy(copier)\n+}\n+\n+/// This type represents either the inferred `FileType` of a `RawFd` based on the source\n+/// type from which it was extracted or the actual metadata\n+///\n+/// The methods on this type only provide hints, due to `AsRawFd` and `FromRawFd` the inferred\n+/// type may be wrong.\n+enum FdMeta {\n+    /// We obtained the FD from a type that can contain any type of `FileType` and queried the metadata\n+    /// because it is cheaper than probing all possible syscalls (reader side)\n+    Metadata(Metadata),\n+    Socket,\n+    Pipe,\n+    /// We don't have any metadata, e.g. because the original type was `File` which can represent\n+    /// any `FileType` and we did not query the metadata either since it did not seem beneficial\n+    /// (writer side)\n+    NoneObtained,\n+}\n+\n+impl FdMeta {\n+    fn maybe_fifo(&self) -> bool {\n+        match self {\n+            FdMeta::Metadata(meta) => meta.file_type().is_fifo(),\n+            FdMeta::Socket => false,\n+            FdMeta::Pipe => true,\n+            FdMeta::NoneObtained => true,\n+        }\n+    }\n+\n+    fn potential_sendfile_source(&self) -> bool {\n+        match self {\n+            // procfs erronously shows 0 length on non-empty readable files.\n+            // and if a file is truly empty then a `read` syscall will determine that and skip the write syscall\n+            // thus there would be benefit from attempting sendfile\n+            FdMeta::Metadata(meta)\n+                if meta.file_type().is_file() && meta.len() > 0\n+                    || meta.file_type().is_block_device() =>\n+            {\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn copy_file_range_candidate(&self) -> bool {\n+        match self {\n+            // copy_file_range will fail on empty procfs files. `read` can determine whether EOF has been reached\n+            // without extra cost and skip the write, thus there is no benefit in attempting copy_file_range\n+            FdMeta::Metadata(meta) if meta.is_file() && meta.len() > 0 => true,\n+            FdMeta::NoneObtained => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+struct CopyParams(FdMeta, Option<RawFd>);\n+\n+struct Copier<'a, 'b, R: Read + ?Sized, W: Write + ?Sized> {\n+    read: &'a mut R,\n+    write: &'b mut W,\n+}\n+\n+trait SpecCopy {\n+    fn copy(self) -> Result<u64>;\n+}\n+\n+impl<R: Read + ?Sized, W: Write + ?Sized> SpecCopy for Copier<'_, '_, R, W> {\n+    default fn copy(self) -> Result<u64> {\n+        generic_copy(self.read, self.write)\n+    }\n+}\n+\n+impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n+    fn copy(self) -> Result<u64> {\n+        let (reader, writer) = (self.read, self.write);\n+        let r_cfg = reader.properties();\n+        let w_cfg = writer.properties();\n+\n+        // before direct operations on file descriptors ensure that all source and sink buffers are empty\n+        let mut flush = || -> crate::io::Result<u64> {\n+            let bytes = reader.drain_to(writer, u64::MAX)?;\n+            // BufWriter buffered bytes have already been accounted for in earlier write() calls\n+            writer.flush()?;\n+            Ok(bytes)\n+        };\n+\n+        let mut written = 0u64;\n+\n+        if let (CopyParams(input_meta, Some(readfd)), CopyParams(output_meta, Some(writefd))) =\n+            (r_cfg, w_cfg)\n+        {\n+            written += flush()?;\n+            let max_write = reader.min_limit();\n+\n+            if input_meta.copy_file_range_candidate() && output_meta.copy_file_range_candidate() {\n+                let result = copy_regular_files(readfd, writefd, max_write);\n+\n+                match result {\n+                    CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n+                    CopyResult::Ended(err) => return err,\n+                    CopyResult::Fallback(bytes) => written += bytes,\n+                }\n+            }\n+\n+            // on modern kernels sendfile can copy from any mmapable type (some but not all regular files and block devices)\n+            // to any writable file descriptor. On older kernels the writer side can only be a socket.\n+            // So we just try and fallback if needed.\n+            // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n+            // fall back to the generic copy loop.\n+            if input_meta.potential_sendfile_source() {\n+                let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n+\n+                match result {\n+                    CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n+                    CopyResult::Ended(err) => return err,\n+                    CopyResult::Fallback(bytes) => written += bytes,\n+                }\n+            }\n+\n+            if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n+                let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n+\n+                match result {\n+                    CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n+                    CopyResult::Ended(err) => return err,\n+                    CopyResult::Fallback(0) => { /* use the fallback below */ }\n+                    CopyResult::Fallback(_) => {\n+                        unreachable!(\"splice should not return > 0 bytes on the fallback path\")\n+                    }\n+                }\n+            }\n+        }\n+\n+        // fallback if none of the more specialized syscalls wants to work with these file descriptors\n+        match generic_copy(reader, writer) {\n+            Ok(bytes) => Ok(bytes + written),\n+            err => err,\n+        }\n+    }\n+}\n+\n+#[rustc_specialization_trait]\n+trait CopyRead: Read {\n+    /// Implementations that contain buffers (i.e. `BufReader`) must transfer data from their internal\n+    /// buffers into `writer` until either the buffers are emptied or `limit` bytes have been\n+    /// transferred, whichever occurs sooner.\n+    /// If nested buffers are present the outer buffers must be drained first.\n+    ///\n+    /// This is necessary to directly bypass the wrapper types while preserving the data order\n+    /// when operating directly on the underlying file descriptors.\n+    fn drain_to<W: Write>(&mut self, _writer: &mut W, _limit: u64) -> Result<u64> {\n+        Ok(0)\n+    }\n+\n+    /// The minimum of the limit of all `Take<_>` wrappers, `u64::MAX` otherwise.\n+    /// This method does not account for data `BufReader` buffers and would underreport\n+    /// the limit of a `Take<BufReader<Take<_>>>` type. Thus its result is only valid\n+    /// after draining the buffers via `drain_to`.\n+    fn min_limit(&self) -> u64 {\n+        u64::MAX\n+    }\n+\n+    /// Extracts the file descriptor and hints/metadata, delegating through wrappers if necessary.\n+    fn properties(&self) -> CopyParams;\n+}\n+\n+#[rustc_specialization_trait]\n+trait CopyWrite: Write {\n+    /// Extracts the file descriptor and hints/metadata, delegating through wrappers if necessary.\n+    fn properties(&self) -> CopyParams;\n+}\n+\n+impl<T> CopyRead for &mut T\n+where\n+    T: CopyRead,\n+{\n+    fn drain_to<W: Write>(&mut self, writer: &mut W, limit: u64) -> Result<u64> {\n+        (**self).drain_to(writer, limit)\n+    }\n+\n+    fn min_limit(&self) -> u64 {\n+        (**self).min_limit()\n+    }\n+\n+    fn properties(&self) -> CopyParams {\n+        (**self).properties()\n+    }\n+}\n+\n+impl<T> CopyWrite for &mut T\n+where\n+    T: CopyWrite,\n+{\n+    fn properties(&self) -> CopyParams {\n+        (**self).properties()\n+    }\n+}\n+\n+impl CopyRead for File {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for &File {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for File {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for &File {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for TcpStream {\n+    fn properties(&self) -> CopyParams {\n+        // avoid the stat syscall since we can be fairly sure it's a socket\n+        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for &TcpStream {\n+    fn properties(&self) -> CopyParams {\n+        // avoid the stat syscall since we can be fairly sure it's a socket\n+        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for TcpStream {\n+    fn properties(&self) -> CopyParams {\n+        // avoid the stat syscall since we can be fairly sure it's a socket\n+        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for &TcpStream {\n+    fn properties(&self) -> CopyParams {\n+        // avoid the stat syscall since we can be fairly sure it's a socket\n+        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for ChildStdin {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for ChildStdout {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for ChildStderr {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for StdinLock<'_> {\n+    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n+        let buf_reader = self.as_mut_buf();\n+        let buf = buf_reader.buffer();\n+        let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n+        let bytes_drained = buf.len();\n+        writer.write_all(buf)?;\n+        buf_reader.consume(bytes_drained);\n+\n+        Ok(bytes_drained as u64)\n+    }\n+\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for StdoutLock<'_> {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for StderrLock<'_> {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl<T: CopyRead> CopyRead for Take<T> {\n+    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n+        let local_limit = self.limit();\n+        let combined_limit = min(outer_limit, local_limit);\n+        let bytes_drained = self.get_mut().drain_to(writer, combined_limit)?;\n+        // update limit since read() was bypassed\n+        self.set_limit(local_limit - bytes_drained);\n+\n+        Ok(bytes_drained)\n+    }\n+\n+    fn min_limit(&self) -> u64 {\n+        min(Take::limit(self), self.get_ref().min_limit())\n+    }\n+\n+    fn properties(&self) -> CopyParams {\n+        self.get_ref().properties()\n+    }\n+}\n+\n+impl<T: CopyRead> CopyRead for BufReader<T> {\n+    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n+        let buf = self.buffer();\n+        let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n+        let bytes = buf.len();\n+        writer.write_all(buf)?;\n+        self.consume(bytes);\n+\n+        let remaining = outer_limit - bytes as u64;\n+\n+        // in case of nested bufreaders we also need to drain the ones closer to the source\n+        let inner_bytes = self.get_mut().drain_to(writer, remaining)?;\n+\n+        Ok(bytes as u64 + inner_bytes)\n+    }\n+\n+    fn min_limit(&self) -> u64 {\n+        self.get_ref().min_limit()\n+    }\n+\n+    fn properties(&self) -> CopyParams {\n+        self.get_ref().properties()\n+    }\n+}\n+\n+impl<T: CopyWrite> CopyWrite for BufWriter<T> {\n+    fn properties(&self) -> CopyParams {\n+        self.get_ref().properties()\n+    }\n+}\n+\n+fn fd_to_meta<T: AsRawFd>(fd: &T) -> FdMeta {\n+    let fd = fd.as_raw_fd();\n+    let file: ManuallyDrop<File> = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });\n+    match file.metadata() {\n+        Ok(meta) => FdMeta::Metadata(meta),\n+        Err(_) => FdMeta::NoneObtained,\n+    }\n+}"}, {"sha": "7609afbdd76aca9a13a10f53ab0e24cce0e15a7d", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5d2722afea902e89e44062765733c4800b7d21/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5d2722afea902e89e44062765733c4800b7d21/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=7f5d2722afea902e89e44062765733c4800b7d21", "patch": "@@ -51,6 +51,8 @@ pub mod fd;\n pub mod fs;\n pub mod futex;\n pub mod io;\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub mod kernel_copy;\n #[cfg(target_os = \"l4re\")]\n mod l4re;\n pub mod memchr;"}]}