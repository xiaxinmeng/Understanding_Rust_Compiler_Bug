{"sha": "ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkN2M4NDkwNTcyYzhlYWFjZmUyYWNmNDU5NjYwYmQ5MDAzZTFiYTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-05-07T11:20:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-05-09T09:56:44Z"}, "message": "Currently trans uses Vec<ty::t> to represent substitutions instead of a proper\nty::substs struct. This is a holdover from the olden days of yore. This patch\nremoves the last vestiges of that practice. This is part of the work\nI was doing on #5527.", "tree": {"sha": "e08f5b7070aad04bf7f161dd58d74dc7501a4b2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e08f5b7070aad04bf7f161dd58d74dc7501a4b2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "html_url": "https://github.com/rust-lang/rust/commit/ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6c9dbd3e40e9de4a907ce5cb1e5d8ee0b5d6220", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6c9dbd3e40e9de4a907ce5cb1e5d8ee0b5d6220", "html_url": "https://github.com/rust-lang/rust/commit/b6c9dbd3e40e9de4a907ce5cb1e5d8ee0b5d6220"}], "stats": {"total": 743, "additions": 391, "deletions": 352}, "files": [{"sha": "26f5ead37bec83713fbf4d6c9f51f454c7187bae", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -128,7 +128,7 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_val = 0x45,\n     tag_table_def = 0x46,\n     tag_table_node_type = 0x47,\n-    tag_table_node_type_subst = 0x48,\n+    tag_table_item_subst = 0x48,\n     tag_table_freevars = 0x49,\n     tag_table_tcache = 0x4a,\n     tag_table_param_defs = 0x4b,"}, {"sha": "523e0042cce50b58e0ac9b402c61cd22b9176df1", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -657,13 +657,13 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                         vtable_origin: &typeck::vtable_origin) {\n     ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n         match *vtable_origin {\n-          typeck::vtable_static(def_id, ref tys, ref vtable_res) => {\n+          typeck::vtable_static(def_id, ref substs, ref vtable_res) => {\n             ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |ebml_w| {\n                 ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n                     Ok(ebml_w.emit_def_id(def_id))\n                 });\n                 ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    Ok(ebml_w.emit_tys(ecx, tys.as_slice()))\n+                    Ok(ebml_w.emit_substs(ecx, substs))\n                 });\n                 ebml_w.emit_enum_variant_arg(2u, |ebml_w| {\n                     Ok(encode_vtable_res(ecx, ebml_w, vtable_res))\n@@ -744,7 +744,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                             Ok(this.read_def_id_noxcx(cdata))\n                         }).unwrap(),\n                         this.read_enum_variant_arg(1u, |this| {\n-                            Ok(this.read_tys_noxcx(tcx, cdata))\n+                            Ok(this.read_substs_noxcx(tcx, cdata))\n                         }).unwrap(),\n                         this.read_enum_variant_arg(2u, |this| {\n                             Ok(this.read_vtable_res(tcx, cdata))\n@@ -962,11 +962,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for tys in tcx.node_type_substs.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_node_type_subst, |ebml_w| {\n+    for &item_substs in tcx.item_substs.borrow().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_item_subst, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_tys(ecx, tys.as_slice())\n+                ebml_w.emit_substs(ecx, &item_substs.substs);\n             })\n         })\n     }\n@@ -1091,6 +1091,9 @@ trait ebml_decoder_decoder_helpers {\n     fn read_tys_noxcx(&mut self,\n                       tcx: &ty::ctxt,\n                       cdata: &cstore::crate_metadata) -> Vec<ty::t>;\n+    fn read_substs_noxcx(&mut self, tcx: &ty::ctxt,\n+                         cdata: &cstore::crate_metadata)\n+                         -> ty::substs;\n }\n \n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n@@ -1115,6 +1118,21 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n             .collect()\n     }\n \n+    fn read_substs_noxcx(&mut self,\n+                         tcx: &ty::ctxt,\n+                         cdata: &cstore::crate_metadata)\n+                         -> ty::substs\n+    {\n+        self.read_opaque(|_, doc| {\n+            Ok(tydecode::parse_substs_data(\n+                doc.data,\n+                cdata.cnum,\n+                doc.start,\n+                tcx,\n+                |_, id| decoder::translate_def_id(cdata, id)))\n+        }).unwrap()\n+    }\n+\n     fn read_ty(&mut self, xcx: &ExtendedDecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n@@ -1312,9 +1330,12 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                                id, ty_to_str(dcx.tcx, ty));\n                         dcx.tcx.node_types.borrow_mut().insert(id as uint, ty);\n                     }\n-                    c::tag_table_node_type_subst => {\n-                        let tys = val_dsr.read_tys(xcx);\n-                        dcx.tcx.node_type_substs.borrow_mut().insert(id, tys);\n+                    c::tag_table_item_subst => {\n+                        let item_substs = ty::ItemSubsts {\n+                            substs: val_dsr.read_substs(xcx)\n+                        };\n+                        dcx.tcx.item_substs.borrow_mut().insert(\n+                            id, item_substs);\n                     }\n                     c::tag_table_freevars => {\n                         let fv_info = val_dsr.read_to_vec(|val_dsr| {"}, {"sha": "b88083c0df9abeb08537cdb856cbf653bf091b00", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -245,10 +245,10 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     {\n         let method_map = cx.tcx.method_map.borrow();\n         let method = method_map.find(&typeck::MethodCall::expr(e.id));\n-        let node_type_substs = cx.tcx.node_type_substs.borrow();\n+        let item_substs = cx.tcx.item_substs.borrow();\n         let r = match method {\n             Some(method) => Some(&method.substs.tps),\n-            None => node_type_substs.find(&e.id)\n+            None => item_substs.find(&e.id).map(|s| &s.substs.tps)\n         };\n         for ts in r.iter() {\n             let def_map = cx.tcx.def_map.borrow();\n@@ -341,15 +341,19 @@ fn check_trait_cast(cx: &mut Context, source_ty: ty::t, target_ty: ty::t, span:\n fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n         TyPath(_, _, id) => {\n-            let node_type_substs = cx.tcx.node_type_substs.borrow();\n-            let r = node_type_substs.find(&id);\n-            for ts in r.iter() {\n-                let def_map = cx.tcx.def_map.borrow();\n-                let did = ast_util::def_id_of_def(def_map.get_copy(&id));\n-                let generics = ty::lookup_item_type(cx.tcx, did).generics;\n-                let type_param_defs = generics.type_param_defs();\n-                for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n-                    check_typaram_bounds(cx, aty.span, ty, type_param_def)\n+            match cx.tcx.item_substs.borrow().find(&id) {\n+                None => { }\n+                Some(ref item_substs) => {\n+                    let def_map = cx.tcx.def_map.borrow();\n+                    let did = ast_util::def_id_of_def(def_map.get_copy(&id));\n+                    let generics = ty::lookup_item_type(cx.tcx, did).generics;\n+                    let type_param_defs = generics.type_param_defs();\n+                    for (&ty, type_param_def) in\n+                        item_substs.substs.tps.iter().zip(\n+                            type_param_defs.iter())\n+                    {\n+                        check_typaram_bounds(cx, aty.span, ty, type_param_def)\n+                    }\n                 }\n             }\n         }"}, {"sha": "59ff1f804036da62b3a3600c77d2c9516faf36fe", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -195,6 +195,17 @@ impl Subst for ty::substs {\n     }\n }\n \n+impl Subst for ty::ItemSubsts {\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>)\n+                     -> ty::ItemSubsts {\n+        ty::ItemSubsts {\n+            substs: self.substs.subst_spanned(tcx, substs, span)\n+        }\n+    }\n+}\n+\n impl Subst for ty::RegionSubsts {\n     fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,"}, {"sha": "6c4566c09aa7aabfc40a4bf92b6df01d8d90f992", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 47, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -478,35 +478,29 @@ pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: ~str) {\n pub fn get_res_dtor(ccx: &CrateContext,\n                     did: ast::DefId,\n                     parent_id: ast::DefId,\n-                    substs: &[ty::t])\n+                    substs: &ty::substs)\n                  -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n     let did = if did.krate != ast::LOCAL_CRATE {\n         inline::maybe_instantiate_inline(ccx, did)\n     } else {\n         did\n     };\n-    if !substs.is_empty() {\n+\n+    if !substs.tps.is_empty() || !substs.self_ty.is_none() {\n         assert_eq!(did.krate, ast::LOCAL_CRATE);\n-        let tsubsts = ty::substs {\n-            regions: ty::ErasedRegions,\n-            self_ty: None,\n-            tps: Vec::from_slice(substs),\n-        };\n \n-        let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx(), did.node, &tsubsts);\n-        let (val, _) = monomorphize::monomorphic_fn(ccx, did, &tsubsts, vtables, None, None);\n+        let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx(), did.node, substs);\n+        let (val, _) = monomorphize::monomorphic_fn(ccx, did, substs, vtables, None, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {\n         get_item_val(ccx, did.node)\n     } else {\n         let tcx = ccx.tcx();\n         let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-        let class_ty = ty::subst_tps(tcx,\n-                                     substs,\n-                                     None,\n-                                     ty::lookup_item_type(tcx, parent_id).ty);\n+        let class_ty = ty::subst(tcx, substs,\n+                                 ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n \n         get_extern_fn(&mut *ccx.externs.borrow_mut(), ccx.llmod, name,\n@@ -670,7 +664,7 @@ pub fn iter_structural_ty<'r,\n                     repr: &adt::Repr,\n                     av: ValueRef,\n                     variant: &ty::VariantInfo,\n-                    tps: &[ty::t],\n+                    substs: &ty::substs,\n                     f: val_and_ty_fn<'r,'b>)\n                     -> &'b Block<'b> {\n         let _icx = push_ctxt(\"iter_variant\");\n@@ -680,7 +674,7 @@ pub fn iter_structural_ty<'r,\n         for (i, &arg) in variant.args.iter().enumerate() {\n             cx = f(cx,\n                    adt::trans_field_ptr(cx, repr, av, variant.disr_val, i),\n-                   ty::subst_tps(tcx, tps, None, arg));\n+                   ty::subst(tcx, substs, arg));\n         }\n         return cx;\n     }\n@@ -722,7 +716,7 @@ pub fn iter_structural_ty<'r,\n           match adt::trans_switch(cx, &*repr, av) {\n               (_match::single, None) => {\n                   cx = iter_variant(cx, &*repr, av, &**variants.get(0),\n-                                    substs.tps.as_slice(), f);\n+                                    substs, f);\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n                   cx = f(cx, lldiscrim_a, ty::mk_int());\n@@ -748,7 +742,7 @@ pub fn iter_structural_ty<'r,\n                                        &*repr,\n                                        av,\n                                        &**variant,\n-                                       substs.tps.as_slice(),\n+                                       substs,\n                                        |x,y,z| f(x,y,z));\n                       Br(variant_cx, next_cx.llbb);\n                   }\n@@ -1153,15 +1147,7 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n            },\n            id, param_substs.map(|s| s.repr(ccx.tcx())));\n \n-    let substd_output_type = match param_substs {\n-        None => output_type,\n-        Some(substs) => {\n-            ty::subst_tps(ccx.tcx(),\n-                          substs.tys.as_slice(),\n-                          substs.self_ty,\n-                          output_type)\n-        }\n-    };\n+    let substd_output_type = output_type.substp(ccx.tcx(), param_substs);\n     let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n \n@@ -1213,15 +1199,7 @@ pub fn init_function<'a>(fcx: &'a FunctionContext<'a>,\n \n     // This shouldn't need to recompute the return type,\n     // as new_fn_ctxt did it already.\n-    let substd_output_type = match fcx.param_substs {\n-        None => output_type,\n-        Some(substs) => {\n-            ty::subst_tps(fcx.ccx.tcx(),\n-                          substs.tys.as_slice(),\n-                          substs.self_ty,\n-                          output_type)\n-        }\n-    };\n+    let substd_output_type = output_type.substp(fcx.ccx.tcx(), fcx.param_substs);\n \n     if !return_type_is_void(fcx.ccx, substd_output_type) {\n         // If the function returns nil/bot, there is no real return\n@@ -1508,18 +1486,8 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n                                            disr: ty::Disr,\n                                            param_substs: Option<&param_substs>,\n                                            llfndecl: ValueRef) {\n-    let ctor_ty = {\n-        let no_substs: &[ty::t] = [];\n-        let ty_param_substs: &[ty::t] = match param_substs {\n-            Some(substs) => substs.tys.as_slice(),\n-            None => no_substs\n-        };\n-\n-        ty::subst_tps(ccx.tcx(),\n-                      ty_param_substs,\n-                      None,\n-                      ty::node_id_to_type(ccx.tcx(), ctor_id))\n-    };\n+    let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n+    let ctor_ty = ctor_ty.substp(ccx.tcx(), param_substs);\n \n     let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,"}, {"sha": "f32aa62d861d36796595a63de65709b54146a6cd", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -159,36 +159,36 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n \n pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) -> ValueRef {\n     /*!\n-     *\n      * Translates a reference (with id `ref_id`) to the fn/method\n      * with id `def_id` into a function pointer.  This may require\n-     * monomorphization or inlining. */\n+     * monomorphization or inlining.\n+     */\n \n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n-    let type_params = node_id_type_params(bcx, node);\n+    let substs = node_id_substs(bcx, node);\n     let vtable_key = match node {\n         ExprId(id) => MethodCall::expr(id),\n         MethodCall(method_call) => method_call\n     };\n     let vtables = node_vtables(bcx, vtable_key);\n-    debug!(\"trans_fn_ref(def_id={}, node={:?}, type_params={}, vtables={})\",\n-           def_id.repr(bcx.tcx()), node, type_params.repr(bcx.tcx()),\n+    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={}, vtables={})\",\n+           def_id.repr(bcx.tcx()),\n+           node,\n+           substs.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n-    trans_fn_ref_with_vtables(bcx, def_id, node,\n-                              type_params,\n-                              vtables)\n+    trans_fn_ref_with_vtables(bcx, def_id, node, substs, vtables)\n }\n \n fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n                                            def_id: ast::DefId,\n                                            ref_id: ast::NodeId,\n-                                           type_params: Vec<ty::t>,\n+                                           substs: ty::substs,\n                                            vtables: Option<typeck::vtable_res>)\n                                            -> Callee<'a> {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ExprId(ref_id),\n-                                               type_params, vtables))}\n+                                               substs, vtables))}\n }\n \n fn resolve_default_method_vtables(bcx: &Block,\n@@ -204,8 +204,7 @@ fn resolve_default_method_vtables(bcx: &Block,\n     // Build up a param_substs that we are going to resolve the\n     // trait_vtables under.\n     let param_substs = param_substs {\n-        tys: substs.tps.clone(),\n-        self_ty: substs.self_ty,\n+        substs: (*substs).clone(),\n         vtables: impl_vtables.clone(),\n         self_vtables: None\n     };\n@@ -241,7 +240,7 @@ pub fn trans_fn_ref_with_vtables(\n         bcx: &Block,       //\n         def_id: ast::DefId,   // def id of fn\n         node: ExprOrMethodCall,  // node id of use of fn; may be zero if N/A\n-        type_params: Vec<ty::t>, // values for fn's ty params\n+        substs: ty::substs, // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n      -> ValueRef {\n     /*!\n@@ -255,7 +254,7 @@ pub fn trans_fn_ref_with_vtables(\n      * - `node`: node id of the reference to the fn/method, if applicable.\n      *   This parameter may be zero; but, if so, the resulting value may not\n      *   have the right type, so it must be cast before being used.\n-     * - `type_params`: values for each of the fn/method's type parameters\n+     * - `substs`: values for each of the fn/method's parameters\n      * - `vtables`: values for each bound on each of the type parameters\n      */\n \n@@ -264,24 +263,18 @@ pub fn trans_fn_ref_with_vtables(\n     let tcx = bcx.tcx();\n \n     debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, node={:?}, \\\n-            type_params={}, vtables={})\",\n+            substs={}, vtables={})\",\n            bcx.to_str(),\n            def_id.repr(tcx),\n            node,\n-           type_params.repr(tcx),\n+           substs.repr(tcx),\n            vtables.repr(tcx));\n \n-    assert!(type_params.iter().all(|t| !ty::type_needs_infer(*t)));\n+    assert!(substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n \n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n \n-    let substs = ty::substs {\n-        regions: ty::ErasedRegions,\n-        self_ty: None,\n-        tps: type_params\n-    };\n-\n     // Load the info for the appropriate trait if necessary.\n     match ty::trait_of_method(tcx, def_id) {\n         None => {}\n@@ -510,7 +503,7 @@ pub fn trans_lang_call<'a>(\n                                 trans_fn_ref_with_vtables_to_callee(bcx,\n                                                                     did,\n                                                                     0,\n-                                                                    vec!(),\n+                                                                    ty::substs::empty(),\n                                                                     None)\n                              },\n                              ArgVals(args),"}, {"sha": "e438477a4a3f816e617445314f832566ba5d1eb4", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -25,6 +25,7 @@ use middle::trans::datum::{Datum, Lvalue};\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n use middle::ty;\n+use middle::subst::Subst;\n use middle::typeck;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n@@ -177,23 +178,24 @@ pub type ExternMap = HashMap<~str, ValueRef>;\n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n pub struct param_substs {\n-    pub tys: Vec<ty::t> ,\n-    pub self_ty: Option<ty::t>,\n+    pub substs: ty::substs,\n     pub vtables: Option<typeck::vtable_res>,\n     pub self_vtables: Option<typeck::vtable_param_res>\n }\n \n impl param_substs {\n     pub fn validate(&self) {\n-        for t in self.tys.iter() { assert!(!ty::type_needs_infer(*t)); }\n-        for t in self.self_ty.iter() { assert!(!ty::type_needs_infer(*t)); }\n+        for t in self.substs.tps.iter() {\n+            assert!(!ty::type_needs_infer(*t));\n+        }\n+        for t in self.substs.self_ty.iter() {\n+            assert!(!ty::type_needs_infer(*t));\n+        }\n     }\n }\n \n fn param_substs_to_str(this: &param_substs, tcx: &ty::ctxt) -> ~str {\n-    format!(\"param_substs \\\\{tys:{}, vtables:{}\\\\}\",\n-         this.tys.repr(tcx),\n-         this.vtables.repr(tcx))\n+    format!(\"param_substs({})\", this.substs.repr(tcx))\n }\n \n impl Repr for param_substs {\n@@ -202,6 +204,25 @@ impl Repr for param_substs {\n     }\n }\n \n+pub trait SubstP {\n+    fn substp(&self, tcx: &ty::ctxt, param_substs: Option<&param_substs>)\n+              -> Self;\n+}\n+\n+impl<T:Subst+Clone> SubstP for T {\n+    fn substp(&self, tcx: &ty::ctxt, param_substs: Option<&param_substs>)\n+              -> T {\n+        match param_substs {\n+            Some(substs) => {\n+                self.subst(tcx, &substs.substs)\n+            }\n+            None => {\n+                (*self).clone()\n+            }\n+        }\n+    }\n+}\n+\n // work around bizarre resolve errors\n pub type RvalueDatum = datum::Datum<datum::Rvalue>;\n pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n@@ -676,7 +697,7 @@ pub fn is_null(val: ValueRef) -> bool {\n pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(ref substs) => {\n-            ty::subst_tps(bcx.tcx(), substs.tys.as_slice(), substs.self_ty, t)\n+            ty::subst(bcx.tcx(), &substs.substs, t)\n         }\n         _ => {\n             assert!(!ty::type_has_params(t));\n@@ -710,32 +731,28 @@ pub enum ExprOrMethodCall {\n     MethodCall(typeck::MethodCall)\n }\n \n-pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n+pub fn node_id_substs(bcx: &Block,\n+                      node: ExprOrMethodCall)\n+                      -> ty::substs {\n     let tcx = bcx.tcx();\n-    let params = match node {\n-        ExprId(id) => ty::node_id_to_type_params(tcx, id),\n+\n+    let substs = match node {\n+        ExprId(id) => {\n+            ty::node_id_item_substs(tcx, id).substs\n+        }\n         MethodCall(method_call) => {\n-            tcx.method_map.borrow().get(&method_call).substs.tps.clone()\n+            tcx.method_map.borrow().get(&method_call).substs.clone()\n         }\n     };\n \n-    if !params.iter().all(|t| !ty::type_needs_infer(*t)) {\n+    if !substs.tps.iter().all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n             format!(\"type parameters for node {:?} include inference types: {}\",\n-                 node, params.iter()\n-                             .map(|t| bcx.ty_to_str(*t))\n-                             .collect::<Vec<~str>>()\n-                             .connect(\",\")));\n+                    node,\n+                    substs.repr(bcx.tcx())));\n     }\n \n-    match bcx.fcx.param_substs {\n-        Some(ref substs) => {\n-            params.iter().map(|t| {\n-                ty::subst_tps(tcx, substs.tys.as_slice(), substs.self_ty, *t)\n-            }).collect()\n-        }\n-        _ => params\n-    }\n+    substs.substp(tcx, bcx.fcx.param_substs)\n }\n \n pub fn node_vtables(bcx: &Block, id: typeck::MethodCall)\n@@ -785,20 +802,10 @@ pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n                                          vt: &typeck::vtable_origin)\n                                          -> typeck::vtable_origin {\n     match *vt {\n-        typeck::vtable_static(trait_id, ref tys, ref sub) => {\n-            let tys = match param_substs {\n-                Some(substs) => {\n-                    tys.iter().map(|t| {\n-                        ty::subst_tps(tcx,\n-                                      substs.tys.as_slice(),\n-                                      substs.self_ty,\n-                                      *t)\n-                    }).collect()\n-                }\n-                _ => Vec::from_slice(tys.as_slice())\n-            };\n+        typeck::vtable_static(trait_id, ref vtable_substs, ref sub) => {\n+            let vtable_substs = vtable_substs.substp(tcx, param_substs);\n             typeck::vtable_static(\n-                trait_id, tys,\n+                trait_id, vtable_substs,\n                 resolve_vtables_under_param_substs(tcx, param_substs, sub.as_slice()))\n         }\n         typeck::vtable_param(n_param, n_bound) => {"}, {"sha": "304aa9b4025b532a1ca55764eccb00fc815b1d51", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -793,16 +793,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 assert_type_for_node_id(cx, fn_ast_id, error_span);\n \n                 let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n-                let return_type = match param_substs {\n-                    None => return_type,\n-                    Some(substs) => {\n-                        ty::subst_tps(cx.tcx(),\n-                                      substs.tys.as_slice(),\n-                                      substs.self_ty,\n-                                      return_type)\n-                    }\n-                };\n-\n+                let return_type = return_type.substp(cx.tcx(), param_substs);\n                 signature.push(type_metadata(cx, return_type, codemap::DUMMY_SP));\n             }\n         }\n@@ -811,16 +802,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         for arg in fn_decl.inputs.iter() {\n             assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n             let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n-            let arg_type = match param_substs {\n-                None => arg_type,\n-                Some(substs) => {\n-                    ty::subst_tps(cx.tcx(),\n-                                  substs.tys.as_slice(),\n-                                  substs.self_ty,\n-                                  arg_type)\n-                }\n-            };\n-\n+            let arg_type = arg_type.substp(cx.tcx(), param_substs);\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n@@ -834,7 +816,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                name_to_append_suffix_to: &mut StrBuf)\n                                -> DIArray {\n         let self_type = match param_substs {\n-            Some(param_substs) => param_substs.self_ty,\n+            Some(param_substs) => param_substs.substs.self_ty,\n             _ => None\n         };\n \n@@ -890,7 +872,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n         // Handle other generic parameters\n         let actual_types = match param_substs {\n-            Some(param_substs) => &param_substs.tys,\n+            Some(param_substs) => &param_substs.substs.tps,\n             None => {\n                 return create_DIArray(DIB(cx), template_params.as_slice());\n             }"}, {"sha": "4f03ec0567cfb43a6beaabf2a28e710b95744422", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -236,7 +236,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n \n     // Find and call the actual destructor\n     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n-                                 class_did, substs.tps.as_slice());\n+                                 class_did, substs);\n \n     // The second argument is the \"self\" argument for drop\n     let params = unsafe {"}, {"sha": "cd28d314772127d158b06e7cca1e6043c71b3866", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -295,7 +295,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             RetVoid(bcx);\n         }\n         \"size_of\" => {\n-            let tp_ty = *substs.tys.get(0);\n+            let tp_ty = *substs.substs.tps.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty) as uint));\n         }\n@@ -305,7 +305,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             // if the value is non-immediate. Note that, with\n             // intrinsics, there are no argument cleanups to\n             // concern ourselves with, so we can use an rvalue datum.\n-            let tp_ty = *substs.tys.get(0);\n+            let tp_ty = *substs.substs.tps.get(0);\n             let mode = appropriate_rvalue_mode(ccx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty,\n@@ -314,17 +314,17 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             RetVoid(bcx);\n         }\n         \"min_align_of\" => {\n-            let tp_ty = *substs.tys.get(0);\n+            let tp_ty = *substs.substs.tps.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty) as uint));\n         }\n         \"pref_align_of\"=> {\n-            let tp_ty = *substs.tys.get(0);\n+            let tp_ty = *substs.substs.tps.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty) as uint));\n         }\n         \"get_tydesc\" => {\n-            let tp_ty = *substs.tys.get(0);\n+            let tp_ty = *substs.substs.tps.get(0);\n             let static_ti = get_tydesc(ccx, tp_ty);\n             glue::lazily_emit_visit_glue(ccx, &*static_ti);\n \n@@ -339,7 +339,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         \"type_id\" => {\n             let hash = ty::hash_crate_independent(\n                 ccx.tcx(),\n-                *substs.tys.get(0),\n+                *substs.substs.tps.get(0),\n                 &ccx.link_meta.crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n@@ -354,7 +354,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             }\n         }\n         \"init\" => {\n-            let tp_ty = *substs.tys.get(0);\n+            let tp_ty = *substs.substs.tps.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             match bcx.fcx.llretptr.get() {\n                 Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n@@ -364,7 +364,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         }\n         \"uninit\" => {\n             // Do nothing, this is effectively a no-op\n-            let retty = *substs.tys.get(0);\n+            let retty = *substs.substs.tps.get(0);\n             if type_is_immediate(ccx, retty) && !return_type_is_void(ccx, retty) {\n                 unsafe {\n                     Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n@@ -377,7 +377,8 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             RetVoid(bcx);\n         }\n         \"transmute\" => {\n-            let (in_type, out_type) = (*substs.tys.get(0), *substs.tys.get(1));\n+            let (in_type, out_type) = (*substs.substs.tps.get(0),\n+                                       *substs.substs.tps.get(1));\n             let llintype = type_of::type_of(ccx, in_type);\n             let llouttype = type_of::type_of(ccx, out_type);\n \n@@ -444,11 +445,11 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             }\n         }\n         \"needs_drop\" => {\n-            let tp_ty = *substs.tys.get(0);\n+            let tp_ty = *substs.substs.tps.get(0);\n             Ret(bcx, C_bool(ccx, ty::type_needs_drop(ccx.tcx(), tp_ty)));\n         }\n         \"owns_managed\" => {\n-            let tp_ty = *substs.tys.get(0);\n+            let tp_ty = *substs.substs.tps.get(0);\n             Ret(bcx, C_bool(ccx, ty::type_contents(ccx.tcx(), tp_ty).owns_managed()));\n         }\n         \"visit_tydesc\" => {\n@@ -464,14 +465,20 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             let lladdr = InBoundsGEP(bcx, ptr, [offset]);\n             Ret(bcx, lladdr);\n         }\n-        \"copy_nonoverlapping_memory\" => copy_intrinsic(bcx, false, false, *substs.tys.get(0)),\n-        \"copy_memory\" => copy_intrinsic(bcx, true, false, *substs.tys.get(0)),\n-        \"set_memory\" => memset_intrinsic(bcx, false, *substs.tys.get(0)),\n+        \"copy_nonoverlapping_memory\" => {\n+            copy_intrinsic(bcx, false, false, *substs.substs.tps.get(0))\n+        }\n+        \"copy_memory\" => {\n+            copy_intrinsic(bcx, true, false, *substs.substs.tps.get(0))\n+        }\n+        \"set_memory\" => {\n+            memset_intrinsic(bcx, false, *substs.substs.tps.get(0))\n+        }\n \n         \"volatile_copy_nonoverlapping_memory\" =>\n-            copy_intrinsic(bcx, false, true, *substs.tys.get(0)),\n-        \"volatile_copy_memory\" => copy_intrinsic(bcx, true, true, *substs.tys.get(0)),\n-        \"volatile_set_memory\" => memset_intrinsic(bcx, true, *substs.tys.get(0)),\n+            copy_intrinsic(bcx, false, true, *substs.substs.tps.get(0)),\n+        \"volatile_copy_memory\" => copy_intrinsic(bcx, true, true, *substs.substs.tps.get(0)),\n+        \"volatile_set_memory\" => memset_intrinsic(bcx, true, *substs.substs.tps.get(0)),\n \n         \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n         \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),"}, {"sha": "e735fd21034f728bb18338da3e871ea173f85522", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -198,7 +198,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n \n     match vtbls.move_iter().nth(bound_index).unwrap().move_iter().nth(0).unwrap() {\n         typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n-            assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n+            assert!(rcvr_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n@@ -277,39 +277,41 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n fn combine_impl_and_methods_tps(bcx: &Block,\n                                 mth_did: ast::DefId,\n                                 node: ExprOrMethodCall,\n-                                rcvr_substs: Vec<ty::t>,\n+                                rcvr_substs: ty::substs,\n                                 rcvr_origins: typeck::vtable_res)\n-                                -> (Vec<ty::t>, typeck::vtable_res) {\n+                                -> (ty::substs, typeck::vtable_res)\n+{\n     /*!\n-    *\n-    * Creates a concatenated set of substitutions which includes\n-    * those from the impl and those from the method.  This are\n-    * some subtle complications here.  Statically, we have a list\n-    * of type parameters like `[T0, T1, T2, M1, M2, M3]` where\n-    * `Tn` are type parameters that appear on the receiver.  For\n-    * example, if the receiver is a method parameter `A` with a\n-    * bound like `trait<B,C,D>` then `Tn` would be `[B,C,D]`.\n-    *\n-    * The weird part is that the type `A` might now be bound to\n-    * any other type, such as `foo<X>`.  In that case, the vector\n-    * we want is: `[X, M1, M2, M3]`.  Therefore, what we do now is\n-    * to slice off the method type parameters and append them to\n-    * the type parameters from the type that the receiver is\n-    * mapped to. */\n+     * Creates a concatenated set of substitutions which includes\n+     * those from the impl and those from the method.  This are\n+     * some subtle complications here.  Statically, we have a list\n+     * of type parameters like `[T0, T1, T2, M1, M2, M3]` where\n+     * `Tn` are type parameters that appear on the receiver.  For\n+     * example, if the receiver is a method parameter `A` with a\n+     * bound like `trait<B,C,D>` then `Tn` would be `[B,C,D]`.\n+     *\n+     * The weird part is that the type `A` might now be bound to\n+     * any other type, such as `foo<X>`.  In that case, the vector\n+     * we want is: `[X, M1, M2, M3]`.  Therefore, what we do now is\n+     * to slice off the method type parameters and append them to\n+     * the type parameters from the type that the receiver is\n+     * mapped to.\n+     */\n \n     let ccx = bcx.ccx();\n     let method = ty::method(ccx.tcx(), mth_did);\n     let n_m_tps = method.generics.type_param_defs().len();\n-    let node_substs = node_id_type_params(bcx, node);\n+    let node_substs = node_id_substs(bcx, node);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx()));\n     debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx()));\n-    let mut ty_substs = rcvr_substs;\n+    let rcvr_self_ty = rcvr_substs.self_ty;\n+    let mut tps = rcvr_substs.tps;\n     {\n-        let start = node_substs.len() - n_m_tps;\n-        ty_substs.extend(node_substs.move_iter().skip(start));\n+        let start = node_substs.tps.len() - n_m_tps;\n+        tps.extend(node_substs.tps.move_iter().skip(start));\n     }\n     debug!(\"n_m_tps={:?}\", n_m_tps);\n-    debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx()));\n+    debug!(\"tps={}\", tps.repr(ccx.tcx()));\n \n \n     // Now, do the same work for the vtables.  The vtables might not\n@@ -333,6 +335,12 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n         }\n     }\n \n+    let ty_substs = ty::substs {\n+        tps: tps,\n+        regions: ty::ErasedRegions,\n+        self_ty: rcvr_self_ty\n+    };\n+\n     (ty_substs, vtables)\n }\n \n@@ -485,7 +493,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n \n fn emit_vtable_methods(bcx: &Block,\n                        impl_id: ast::DefId,\n-                       substs: Vec<ty::t>,\n+                       substs: ty::substs,\n                        vtables: typeck::vtable_res)\n                        -> Vec<ValueRef> {\n     let ccx = bcx.ccx();"}, {"sha": "69f1dcbc67cd4172bc1980119d74c7e1632a4b74", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -85,9 +85,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     }\n \n     let psubsts = param_substs {\n-        tys: real_substs.tps.clone(),\n+        substs: (*real_substs).clone(),\n         vtables: vtables,\n-        self_ty: real_substs.self_ty.clone(),\n         self_vtables: self_vtables\n     };\n \n@@ -139,8 +138,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n     let mono_ty = match is_static_provided {\n-        None => ty::subst_tps(ccx.tcx(), real_substs.tps.as_slice(),\n-                              real_substs.self_ty, llitem_ty),\n+        None => ty::subst(ccx.tcx(), real_substs, llitem_ty),\n         Some(num_method_ty_params) => {\n             // Static default methods are a little unfortunate, in\n             // that the \"internal\" and \"external\" type of them differ.\n@@ -157,13 +155,19 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             // This is a bit unfortunate.\n \n             let idx = real_substs.tps.len() - num_method_ty_params;\n-            let substs = Vec::from_slice(real_substs.tps.slice(0, idx))\n-                         .append([real_substs.self_ty.unwrap()])\n-                         .append(real_substs.tps.tailn(idx));\n+            let mut tps = Vec::new();\n+            tps.push_all(real_substs.tps.slice(0, idx));\n+            tps.push(real_substs.self_ty.unwrap());\n+            tps.push_all(real_substs.tps.tailn(idx));\n+\n+            let substs = ty::substs { regions: ty::ErasedRegions,\n+                                      self_ty: None,\n+                                      tps: tps };\n+\n             debug!(\"static default: changed substitution to {}\",\n                    substs.repr(ccx.tcx()));\n \n-            ty::subst_tps(ccx.tcx(), substs.as_slice(), None, llitem_ty)\n+            ty::subst(ccx.tcx(), &substs, llitem_ty)\n         }\n     };\n \n@@ -334,7 +338,10 @@ pub fn make_vtable_id(ccx: &CrateContext,\n         &typeck::vtable_static(impl_id, ref substs, ref sub_vtables) => {\n             MonoId {\n                 def: impl_id,\n-                params: sub_vtables.iter().zip(substs.iter()).map(|(vtable, subst)| {\n+                // FIXME(NDM) -- this is pretty bogus. It ignores self-type,\n+                // and vtables are not necessary, AND they are not guaranteed\n+                // to be same length as the number of TPS ANYHOW!\n+                params: sub_vtables.iter().zip(substs.tps.iter()).map(|(vtable, subst)| {\n                     MonoParamId {\n                         subst: *subst,\n                         // Do we really need the vtables to be hashed? Isn't the type enough?"}, {"sha": "e61961f999c8e241d9620c9af3adae34ff5d0a3a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 62, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -255,9 +255,9 @@ pub struct ctxt {\n \n     // Stores the type parameters which were substituted to obtain the type\n     // of this node.  This only applies to nodes that refer to entities\n-    // parameterized by type parameters, such as generic fns, types, or\n+    // param<eterized by type parameters, such as generic fns, types, or\n     // other items.\n-    pub node_type_substs: RefCell<NodeMap<Vec<t>>>,\n+    pub item_substs: RefCell<NodeMap<ItemSubsts>>,\n \n     // Maps from a method to the method \"descriptor\"\n     pub methods: RefCell<DefIdMap<Rc<Method>>>,\n@@ -1060,6 +1060,13 @@ pub struct TraitDef {\n     pub trait_ref: Rc<ty::TraitRef>,\n }\n \n+/// Records the substitutions used to translate the polytype for an\n+/// item into the monotype of an item reference.\n+#[deriving(Clone)]\n+pub struct ItemSubsts {\n+    pub substs: ty::substs,\n+}\n+\n pub struct ty_param_substs_and_ty {\n     pub substs: ty::substs,\n     pub ty: ty::t\n@@ -1086,7 +1093,7 @@ pub fn mk_ctxt(s: Session,\n         def_map: dm,\n         region_maps: region_maps,\n         node_types: RefCell::new(HashMap::new()),\n-        node_type_substs: RefCell::new(NodeMap::new()),\n+        item_substs: RefCell::new(NodeMap::new()),\n         trait_refs: RefCell::new(NodeMap::new()),\n         trait_defs: RefCell::new(DefIdMap::new()),\n         map: map,\n@@ -1510,47 +1517,13 @@ pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n                                    |t| { fldt(t); t }).fold_ty(ty)\n }\n \n-// Substitute *only* type parameters.  Used in trans where regions are erased.\n-pub fn subst_tps(tcx: &ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n-    let mut subst = TpsSubst { tcx: tcx, self_ty_opt: self_ty_opt, tps: tps };\n-    return subst.fold_ty(typ);\n-\n-    struct TpsSubst<'a> {\n-        tcx: &'a ctxt,\n-        self_ty_opt: Option<t>,\n-        tps: &'a [t],\n+impl ItemSubsts {\n+    pub fn empty() -> ItemSubsts {\n+        ItemSubsts { substs: substs::empty() }\n     }\n \n-    impl<'a> TypeFolder for TpsSubst<'a> {\n-        fn tcx<'a>(&'a self) -> &'a ctxt { self.tcx }\n-\n-        fn fold_ty(&mut self, t: ty::t) -> ty::t {\n-            if self.tps.len() == 0u && self.self_ty_opt.is_none() {\n-                return t;\n-            }\n-\n-            let tb = ty::get(t);\n-            if self.self_ty_opt.is_none() && !tbox_has_flag(tb, has_params) {\n-                return t;\n-            }\n-\n-            match ty::get(t).sty {\n-                ty_param(p) => {\n-                    self.tps[p.idx]\n-                }\n-\n-                ty_self(_) => {\n-                    match self.self_ty_opt {\n-                        None => self.tcx.sess.bug(\"ty_self unexpected here\"),\n-                        Some(self_ty) => self_ty\n-                    }\n-                }\n-\n-                _ => {\n-                    ty_fold::super_fold_ty(self, t)\n-                }\n-            }\n-        }\n+    pub fn is_noop(&self) -> bool {\n+        ty::substs_is_noop(&self.substs)\n     }\n }\n \n@@ -2669,11 +2642,10 @@ pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n     }\n }\n \n-// FIXME(pcwalton): Makes a copy, bleh. Probably better to not do that.\n-pub fn node_id_to_type_params(cx: &ctxt, id: ast::NodeId) -> Vec<t> {\n-    match cx.node_type_substs.borrow().find(&id) {\n-      None => return Vec::new(),\n-      Some(ts) => return (*ts).clone(),\n+pub fn node_id_item_substs(cx: &ctxt, id: ast::NodeId) -> ItemSubsts {\n+    match cx.item_substs.borrow().find(&id) {\n+      None => ItemSubsts::empty(),\n+      Some(ts) => ts.clone(),\n     }\n }\n \n@@ -2991,21 +2963,6 @@ impl AutoRef {\n     }\n }\n \n-pub struct ParamsTy {\n-    pub params: Vec<t>,\n-    pub ty: t\n-}\n-\n-#[allow(dead_code)] // this may be useful?\n-pub fn expr_ty_params_and_ty(cx: &ctxt,\n-                             expr: &ast::Expr)\n-                          -> ParamsTy {\n-    ParamsTy {\n-        params: node_id_to_type_params(cx, expr.id),\n-        ty: node_id_to_type(cx, expr.id)\n-    }\n-}\n-\n pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n                                    -> Rc<Vec<TypeParameterDef>> {\n     match origin {"}, {"sha": "472386209e399291ce9f0bbd3deef550f5f2966e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -52,7 +52,7 @@ can be broken down into several distinct phases:\n \n While type checking a function, the intermediate types for the\n expressions, blocks, and so forth contained within the function are\n-stored in `fcx.node_types` and `fcx.node_type_substs`.  These types\n+stored in `fcx.node_types` and `fcx.item_substs`.  These types\n may contain unresolved type variables.  After type checking is\n complete, the functions in the writeback module are used to take the\n types from this table, resolve them, and then write them into their\n@@ -161,7 +161,7 @@ pub struct Inherited<'a> {\n \n     // Temporary tables:\n     node_types: RefCell<NodeMap<ty::t>>,\n-    node_type_substs: RefCell<NodeMap<ty::substs>>,\n+    item_substs: RefCell<NodeMap<ty::ItemSubsts>>,\n     adjustments: RefCell<NodeMap<ty::AutoAdjustment>>,\n     method_map: MethodMap,\n     vtable_map: vtable_map,\n@@ -268,7 +268,7 @@ impl<'a> Inherited<'a> {\n             locals: RefCell::new(NodeMap::new()),\n             param_env: param_env,\n             node_types: RefCell::new(NodeMap::new()),\n-            node_type_substs: RefCell::new(NodeMap::new()),\n+            item_substs: RefCell::new(NodeMap::new()),\n             adjustments: RefCell::new(NodeMap::new()),\n             method_map: RefCell::new(FnvHashMap::new()),\n             vtable_map: RefCell::new(FnvHashMap::new()),\n@@ -1111,22 +1111,22 @@ impl<'a> FnCtxt<'a> {\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n-    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::substs) {\n-        if !ty::substs_is_noop(&substs) {\n+    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts) {\n+        if !ty::substs_is_noop(&substs.substs) {\n             debug!(\"write_substs({}, {}) in fcx {}\",\n                    node_id,\n-                   ty::substs_to_str(self.tcx(), &substs),\n+                   substs.repr(self.tcx()),\n                    self.tag());\n \n-            self.inh.node_type_substs.borrow_mut().insert(node_id, substs);\n+            self.inh.item_substs.borrow_mut().insert(node_id, substs);\n         }\n     }\n \n     pub fn write_ty_substs(&self,\n                            node_id: ast::NodeId,\n                            ty: ty::t,\n-                           substs: ty::substs) {\n-        let ty = ty::subst(self.tcx(), &substs, ty);\n+                           substs: ty::ItemSubsts) {\n+        let ty = ty::subst(self.tcx(), &substs.substs, ty);\n         self.write_ty(node_id, ty);\n         self.write_substs(node_id, substs);\n     }\n@@ -1204,8 +1204,8 @@ impl<'a> FnCtxt<'a> {\n \n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n-                              f: |&ty::substs|) {\n-        match self.inh.node_type_substs.borrow().find(&id) {\n+                              f: |&ty::ItemSubsts|) {\n+        match self.inh.item_substs.borrow().find(&id) {\n             Some(s) => { f(s) }\n             None => { }\n         }\n@@ -3963,10 +3963,10 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         (tps, regions)\n     };\n \n-    fcx.write_ty_substs(node_id, tpt.ty, substs {\n-        regions: regions,\n-        self_ty: None,\n-        tps: tps\n+    fcx.write_ty_substs(node_id, tpt.ty, ty::ItemSubsts {\n+        substs: substs { regions: regions,\n+                         self_ty: None,\n+                         tps: tps }\n     });\n \n     debug!(\"<<<\");"}, {"sha": "04facc1426dba4e34e25a8f7593e8656a42721a1", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -15,6 +15,7 @@ use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n+use middle::typeck::check::writeback;\n use middle::typeck::infer::fixup_err_to_str;\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n@@ -444,7 +445,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         // Finally, we register that we found a matching impl, and\n         // record the def ID of the impl as well as the resolved list\n         // of type substitutions for the target trait.\n-        found.push(vtable_static(impl_did, substs_f.tps.clone(), subres));\n+        found.push(vtable_static(impl_did, substs_f, subres));\n     }\n \n     match found.len() {\n@@ -625,7 +626,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     };\n     match ex.node {\n       ast::ExprPath(..) => {\n-        fcx.opt_node_ty_substs(ex.id, |substs| {\n+        fcx.opt_node_ty_substs(ex.id, |item_substs| {\n             debug!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n             let def = cx.tcx.def_map.borrow().get_copy(&ex.id);\n@@ -639,7 +640,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                 let vcx = fcx.vtable_context();\n                 let vtbls = lookup_vtables(&vcx, ex.span,\n                                            item_ty.generics.type_param_defs(),\n-                                           substs, is_early);\n+                                           &item_substs.substs, is_early);\n                 if !is_early {\n                     insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n                 }\n@@ -733,8 +734,10 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n pub fn resolve_impl(tcx: &ty::ctxt,\n                     impl_item: &ast::Item,\n                     impl_generics: &ty::Generics,\n-                    impl_trait_ref: &ty::TraitRef)\n-{\n+                    impl_trait_ref: &ty::TraitRef) {\n+    debug!(\"resolve_impl(impl_item.id={})\",\n+           impl_item.id);\n+\n     let param_env = ty::construct_parameter_environment(\n         tcx,\n         None,\n@@ -745,6 +748,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n         impl_item.id);\n \n     let impl_trait_ref = impl_trait_ref.subst(tcx, &param_env.free_substs);\n+    debug!(\"impl_trait_ref={}\", impl_trait_ref.repr(tcx));\n \n     let infcx = &infer::new_infer_ctxt(tcx);\n     let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n@@ -781,8 +785,13 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n         trait_vtables: vtbls,\n         self_vtables: self_vtable_res\n     };\n+    let res = writeback::resolve_impl_res(infcx, impl_item.span, &res);\n     let impl_def_id = ast_util::local_def(impl_item.id);\n \n+    debug!(\"impl_vtables for {} are {}\",\n+           impl_def_id.repr(tcx),\n+           res.repr(tcx));\n+\n     tcx.impl_vtables.borrow_mut().insert(impl_def_id, res);\n }\n "}, {"sha": "8c7a3fed21b4ec212fb79d5822dc599ff3a02cd6", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 116, "deletions": 60, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -21,12 +21,15 @@ use middle::typeck::check::FnCtxt;\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n+use middle::typeck::impl_res;\n use middle::typeck::{MethodCall, MethodCallee};\n use middle::typeck::{vtable_origin, vtable_static, vtable_param};\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n use util::ppaux::Repr;\n \n+use std::cell::Cell;\n+\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::print::pprust::pat_to_str;\n@@ -61,6 +64,17 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     wbcx.visit_upvar_borrow_map();\n }\n \n+pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n+                        span: Span,\n+                        impl_res: &impl_res)\n+                        -> impl_res {\n+    let errors = Cell::new(false); // nobody cares\n+    let mut resolver = Resolver::from_infcx(infcx,\n+                                            &errors,\n+                                            ResolvingImplRes(span));\n+    impl_res.resolve_in(&mut resolver)\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // The Writerback context. This visitor walks the AST, checking the\n // fn-specific tables to find references to types or regions. It\n@@ -159,7 +173,7 @@ impl<'cx> Visitor<()> for WritebackCx<'cx> {\n         }\n \n         let var_ty = self.fcx.local_ty(l.span, l.id);\n-        let var_ty = var_ty.resolve(self.fcx, ResolvingLocal(l.span));\n+        let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n         write_ty_to_tcx(self.tcx(), l.id, var_ty);\n         visit::walk_local(self, l, ());\n     }\n@@ -177,7 +191,7 @@ impl<'cx> WritebackCx<'cx> {\n \n         for (upvar_id, upvar_borrow) in self.fcx.inh.upvar_borrow_map.borrow().iter() {\n             let r = upvar_borrow.region;\n-            let r = r.resolve(self.fcx, ResolvingUpvar(*upvar_id));\n+            let r = self.resolve(&r, ResolvingUpvar(*upvar_id));\n             let new_upvar_borrow = ty::UpvarBorrow { kind: upvar_borrow.kind,\n                                                      region: r };\n             debug!(\"Upvar borrow for {} resolved to {}\",\n@@ -194,17 +208,14 @@ impl<'cx> WritebackCx<'cx> {\n \n         // Resolve the type of the node with id `id`\n         let n_ty = self.fcx.node_ty(id);\n-        let n_ty = n_ty.resolve(self.fcx, reason);\n+        let n_ty = self.resolve(&n_ty, reason);\n         write_ty_to_tcx(self.tcx(), id, n_ty);\n         debug!(\"Node {} has type {}\", id, n_ty.repr(self.tcx()));\n \n         // Resolve any substitutions\n-        self.fcx.opt_node_ty_substs(id, |node_substs| {\n-            let mut new_tps = Vec::new();\n-            for subst in node_substs.tps.iter() {\n-                new_tps.push(subst.resolve(self.fcx, reason));\n-            }\n-            write_substs_to_tcx(self.tcx(), id, new_tps);\n+        self.fcx.opt_node_ty_substs(id, |item_substs| {\n+            write_substs_to_tcx(self.tcx(), id,\n+                                self.resolve(item_substs, reason));\n         });\n     }\n \n@@ -228,12 +239,12 @@ impl<'cx> WritebackCx<'cx> {\n                             }\n                             _ => {\n                                 self.tcx().sess.span_err(\n-                                    reason.span(self.fcx),\n+                                    reason.span(self.tcx()),\n                                     \"cannot coerce non-statically resolved bare fn\")\n                             }\n                         }\n \n-                        ty::AutoAddEnv(store.resolve(self.fcx, reason))\n+                        ty::AutoAddEnv(self.resolve(&store, reason))\n                     }\n \n                     ty::AutoDerefRef(adj) => {\n@@ -245,7 +256,7 @@ impl<'cx> WritebackCx<'cx> {\n \n                         ty::AutoDerefRef(ty::AutoDerefRef {\n                             autoderefs: adj.autoderefs,\n-                            autoref: adj.autoref.resolve(self.fcx, reason),\n+                            autoref: self.resolve(&adj.autoref, reason),\n                         })\n                     }\n \n@@ -269,8 +280,8 @@ impl<'cx> WritebackCx<'cx> {\n                        method.repr(self.tcx()));\n                 let mut new_method = MethodCallee {\n                     origin: method.origin,\n-                    ty: method.ty.resolve(self.fcx, reason),\n-                    substs: method.substs.resolve(self.fcx, reason),\n+                    ty: self.resolve(&method.ty, reason),\n+                    substs: self.resolve(&method.substs, reason),\n                 };\n \n                 // Wack. For some reason I don't quite know, we always\n@@ -297,7 +308,7 @@ impl<'cx> WritebackCx<'cx> {\n         // Resolve any vtable map entry\n         match self.fcx.inh.vtable_map.borrow_mut().pop(&vtable_key) {\n             Some(origins) => {\n-                let r_origins = origins.resolve(self.fcx, reason);\n+                let r_origins = self.resolve(&origins, reason);\n                 debug!(\"writeback::resolve_vtable_map_entry(\\\n                         vtable_key={}, vtables={:?})\",\n                        vtable_key, r_origins.repr(self.tcx()));\n@@ -306,6 +317,10 @@ impl<'cx> WritebackCx<'cx> {\n             None => {}\n         }\n     }\n+\n+    fn resolve<T:ResolveIn>(&self, t: &T, reason: ResolveReason) -> T {\n+        t.resolve_in(&mut Resolver::new(self.fcx, reason))\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -315,78 +330,88 @@ enum ResolveReason {\n     ResolvingExpr(Span),\n     ResolvingLocal(Span),\n     ResolvingPattern(Span),\n-    ResolvingUpvar(ty::UpvarId)\n+    ResolvingUpvar(ty::UpvarId),\n+    ResolvingImplRes(Span),\n }\n \n impl ResolveReason {\n-    fn span(&self, fcx: &FnCtxt) -> Span {\n+    fn span(&self, tcx: &ty::ctxt) -> Span {\n         match *self {\n             ResolvingExpr(s) => s,\n             ResolvingLocal(s) => s,\n             ResolvingPattern(s) => s,\n             ResolvingUpvar(upvar_id) => {\n-                ty::expr_span(fcx.tcx(), upvar_id.closure_expr_id)\n+                ty::expr_span(tcx, upvar_id.closure_expr_id)\n             }\n+            ResolvingImplRes(s) => s,\n         }\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Convenience methods for resolving different kinds of things.\n \n-trait Resolve {\n-    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> Self;\n+trait ResolveIn {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> Self;\n }\n \n-impl<T:Resolve> Resolve for Option<T> {\n-    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> Option<T> {\n-        self.as_ref().map(|t| t.resolve(fcx, reason))\n+impl<T:ResolveIn> ResolveIn for Option<T> {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> Option<T> {\n+        self.as_ref().map(|t| t.resolve_in(resolver))\n     }\n }\n \n-impl<T:Resolve> Resolve for Vec<T> {\n-    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> Vec<T> {\n-        self.iter().map(|t| t.resolve(fcx, reason)).collect()\n+impl<T:ResolveIn> ResolveIn for Vec<T> {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> Vec<T> {\n+        self.iter().map(|t| t.resolve_in(resolver)).collect()\n     }\n }\n \n-impl Resolve for ty::TraitStore {\n-    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::TraitStore {\n-        Resolver::new(fcx, reason).fold_trait_store(*self)\n+impl ResolveIn for ty::TraitStore {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> ty::TraitStore {\n+        resolver.fold_trait_store(*self)\n     }\n }\n \n-impl Resolve for ty::t {\n-    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::t {\n-        Resolver::new(fcx, reason).fold_ty(*self)\n+impl ResolveIn for ty::t {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> ty::t {\n+        resolver.fold_ty(*self)\n     }\n }\n \n-impl Resolve for ty::Region {\n-    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::Region {\n-        Resolver::new(fcx, reason).fold_region(*self)\n+impl ResolveIn for ty::Region {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> ty::Region {\n+        resolver.fold_region(*self)\n     }\n }\n \n-impl Resolve for ty::substs {\n-    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::substs {\n-        Resolver::new(fcx, reason).fold_substs(self)\n+impl ResolveIn for ty::substs {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> ty::substs {\n+        resolver.fold_substs(self)\n     }\n }\n \n-impl Resolve for ty::AutoRef {\n-    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> ty::AutoRef {\n-        Resolver::new(fcx, reason).fold_autoref(self)\n+impl ResolveIn for ty::ItemSubsts {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> ty::ItemSubsts {\n+        ty::ItemSubsts {\n+            substs: self.substs.resolve_in(resolver)\n+        }\n     }\n }\n \n-impl Resolve for vtable_origin {\n-    fn resolve(&self, fcx: &FnCtxt, reason: ResolveReason) -> vtable_origin {\n+impl ResolveIn for ty::AutoRef {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> ty::AutoRef {\n+        resolver.fold_autoref(self)\n+    }\n+}\n+\n+impl ResolveIn for vtable_origin {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> vtable_origin {\n         match *self {\n-            vtable_static(def_id, ref tys, ref origins) => {\n-                let r_tys = tys.resolve(fcx, reason);\n-                let r_origins = origins.resolve(fcx, reason);\n-                vtable_static(def_id, r_tys, r_origins)\n+            vtable_static(def_id, ref substs, ref origins) => {\n+                let r_substs = substs.resolve_in(resolver);\n+                let r_origins = origins.resolve_in(resolver);\n+                vtable_static(def_id, r_substs, r_origins)\n             }\n             vtable_param(n, b) => {\n                 vtable_param(n, b)\n@@ -395,12 +420,23 @@ impl Resolve for vtable_origin {\n     }\n }\n \n+impl ResolveIn for impl_res {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> impl_res {\n+        impl_res {\n+            trait_vtables: self.trait_vtables.resolve_in(resolver),\n+            self_vtables: self.self_vtables.resolve_in(resolver),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth.\n \n struct Resolver<'cx> {\n-    fcx: &'cx FnCtxt<'cx>,\n+    tcx: &'cx ty::ctxt,\n+    infcx: &'cx infer::InferCtxt<'cx>,\n+    writeback_errors: &'cx Cell<bool>,\n     reason: ResolveReason,\n }\n \n@@ -409,64 +445,84 @@ impl<'cx> Resolver<'cx> {\n            reason: ResolveReason)\n            -> Resolver<'cx>\n     {\n-        Resolver { fcx: fcx, reason: reason }\n+        Resolver { infcx: fcx.infcx(),\n+                   tcx: fcx.tcx(),\n+                   writeback_errors: &fcx.writeback_errors,\n+                   reason: reason }\n+    }\n+\n+    fn from_infcx(infcx: &'cx infer::InferCtxt<'cx>,\n+                  writeback_errors: &'cx Cell<bool>,\n+                  reason: ResolveReason)\n+                  -> Resolver<'cx>\n+    {\n+        Resolver { infcx: infcx,\n+                   tcx: infcx.tcx,\n+                   writeback_errors: writeback_errors,\n+                   reason: reason }\n     }\n \n     fn report_error(&self, e: infer::fixup_err) {\n-        self.fcx.writeback_errors.set(true);\n-        if !self.tcx().sess.has_errors() {\n+        self.writeback_errors.set(true);\n+        if !self.tcx.sess.has_errors() {\n             match self.reason {\n                 ResolvingExpr(span) => {\n-                    self.tcx().sess.span_err(\n+                    self.tcx.sess.span_err(\n                         span,\n                         format!(\"cannot determine a type for \\\n                                  this expression: {}\",\n                                 infer::fixup_err_to_str(e)))\n                 }\n \n                 ResolvingLocal(span) => {\n-                    self.tcx().sess.span_err(\n+                    self.tcx.sess.span_err(\n                         span,\n                         format!(\"cannot determine a type for \\\n                                  this local variable: {}\",\n                                 infer::fixup_err_to_str(e)))\n                 }\n \n                 ResolvingPattern(span) => {\n-                    self.tcx().sess.span_err(\n+                    self.tcx.sess.span_err(\n                         span,\n                         format!(\"cannot determine a type for \\\n                                  this pattern binding: {}\",\n                                 infer::fixup_err_to_str(e)))\n                 }\n \n                 ResolvingUpvar(upvar_id) => {\n-                    let span = self.reason.span(self.fcx);\n-                    self.tcx().sess.span_err(\n+                    let span = self.reason.span(self.tcx);\n+                    self.tcx.sess.span_err(\n                         span,\n                         format!(\"cannot resolve lifetime for \\\n                                  captured variable `{}`: {}\",\n                                 ty::local_var_name_str(\n-                                    self.tcx(),\n+                                    self.tcx,\n                                     upvar_id.var_id).get().to_str(),\n                                 infer::fixup_err_to_str(e)));\n                 }\n+\n+                ResolvingImplRes(span) => {\n+                    self.tcx.sess.span_err(\n+                        span,\n+                        format!(\"cannot determine a type for impl supertrait\"));\n+                }\n             }\n         }\n     }\n }\n \n impl<'cx> TypeFolder for Resolver<'cx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n-        self.fcx.tcx()\n+        self.tcx\n     }\n \n     fn fold_ty(&mut self, t: ty::t) -> ty::t {\n         if !ty::type_needs_infer(t) {\n             return t;\n         }\n \n-        match resolve_type(self.fcx.infcx(), t, resolve_all | force_all) {\n+        match resolve_type(self.infcx, t, resolve_all | force_all) {\n             Ok(t) => t,\n             Err(e) => {\n                 self.report_error(e);\n@@ -476,7 +532,7 @@ impl<'cx> TypeFolder for Resolver<'cx> {\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match resolve_region(self.fcx.infcx(), r, resolve_all | force_all) {\n+        match resolve_region(self.infcx, r, resolve_all | force_all) {\n             Ok(r) => r,\n             Err(e) => {\n                 self.report_error(e);"}, {"sha": "49297e919ec60b9ddfdacbc9fb1924fe3c392f4d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -184,7 +184,7 @@ pub enum vtable_origin {\n       from whence comes the vtable, and tys are the type substs.\n       vtable_res is the vtable itself\n      */\n-    vtable_static(ast::DefId, Vec<ty::t>, vtable_res),\n+    vtable_static(ast::DefId, ty::substs, vtable_res),\n \n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n@@ -253,13 +253,16 @@ pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n }\n pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n                            node_id: ast::NodeId,\n-                           substs: Vec<ty::t> ) {\n-    if substs.len() > 0u {\n-        debug!(\"write_substs_to_tcx({}, {:?})\", node_id,\n-               substs.iter().map(|t| ppaux::ty_to_str(tcx, *t)).collect::<Vec<~str>>());\n-        assert!(substs.iter().all(|t| !ty::type_needs_infer(*t)));\n+                           item_substs: ty::ItemSubsts) {\n+    if !item_substs.is_noop() {\n+        debug!(\"write_substs_to_tcx({}, {})\",\n+               node_id,\n+               item_substs.repr(tcx));\n \n-        tcx.node_type_substs.borrow_mut().insert(node_id, substs);\n+        assert!(item_substs.substs.tps.iter().\n+                all(|t| !ty::type_needs_infer(*t)));\n+\n+        tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n     }\n }\n pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {"}, {"sha": "94815d0144db35221bc726d0141632084ba79b1e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c8490572c8eaacfe2acf459660bd9003e1ba4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ed7c8490572c8eaacfe2acf459660bd9003e1ba4", "patch": "@@ -561,6 +561,12 @@ impl Repr for ty::substs {\n     }\n }\n \n+impl Repr for ty::ItemSubsts {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n+        format!(\"ItemSubsts({})\", self.substs.repr(tcx))\n+    }\n+}\n+\n impl Repr for ty::RegionSubsts {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {"}]}