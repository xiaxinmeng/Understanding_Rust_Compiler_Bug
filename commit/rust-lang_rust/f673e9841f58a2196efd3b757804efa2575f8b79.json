{"sha": "f673e9841f58a2196efd3b757804efa2575f8b79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NzNlOTg0MWY1OGEyMTk2ZWZkM2I3NTc4MDRlZmEyNTc1ZjhiNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-25T14:21:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-25T14:21:47Z"}, "message": "auto merge of #20167 : michaelwoerister/rust/for-loop-var, r=alexcrichton\n\n... really this time `:)`\r\n\r\nI went for the simpler fix after all since it turned out to become a bit too complicated to extract the current iteration value from its containing `Option` with the different memory layouts it can have. It's also what we already do for match bindings.\r\n\r\nI also extended the new test case to include the \"simple identifier\" case.\r\n\r\nFixes #20127, fixes #19732", "tree": {"sha": "ddc92fbfca99d63685e99b9a53c350aa3121f373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddc92fbfca99d63685e99b9a53c350aa3121f373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f673e9841f58a2196efd3b757804efa2575f8b79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f673e9841f58a2196efd3b757804efa2575f8b79", "html_url": "https://github.com/rust-lang/rust/commit/f673e9841f58a2196efd3b757804efa2575f8b79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f673e9841f58a2196efd3b757804efa2575f8b79/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ead198c5133fd649d1e385cfc46f344a2baaef8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ead198c5133fd649d1e385cfc46f344a2baaef8b", "html_url": "https://github.com/rust-lang/rust/commit/ead198c5133fd649d1e385cfc46f344a2baaef8b"}, {"sha": "875a30c492b0eaa745f88db4d4c14887a6dd6ae0", "url": "https://api.github.com/repos/rust-lang/rust/commits/875a30c492b0eaa745f88db4d4c14887a6dd6ae0", "html_url": "https://github.com/rust-lang/rust/commit/875a30c492b0eaa745f88db4d4c14887a6dd6ae0"}], "stats": {"total": 417, "additions": 345, "deletions": 72}, "files": [{"sha": "fb8006905f9f214336a2ecd1a4f3948b3419366d", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=f673e9841f58a2196efd3b757804efa2575f8b79", "patch": "@@ -1554,7 +1554,8 @@ pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::store_for_loop_binding\");\n \n-    if simple_identifier(&*pat).is_some() {\n+    if simple_identifier(&*pat).is_some() &&\n+       bcx.sess().opts.debuginfo != FullDebugInfo {\n         // Generate nicer LLVM for the common case of a `for` loop pattern\n         // like `for x in blahblah { ... }`.\n         let binding_type = node_id_type(bcx, pat.id);"}, {"sha": "3b24ded6717cc9612ea4ab97aecae1d04acfc9c7", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=f673e9841f58a2196efd3b757804efa2575f8b79", "patch": "@@ -286,6 +286,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"iterator type is {}, datum type is {}\",\n            ppaux::ty_to_string(bcx.tcx(), iterator_type),\n            ppaux::ty_to_string(bcx.tcx(), iterator_datum.ty));\n+\n     let lliterator = load_ty(bcx, iterator_datum.val, iterator_datum.ty);\n \n     // Create our basic blocks and set up our loop cleanups.\n@@ -365,6 +366,8 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        llpayload,\n                                        binding_cleanup_scope_id);\n \n+    debuginfo::create_for_loop_var_metadata(body_bcx_in, pat);\n+\n     // Codegen the body.\n     body_bcx_out = trans_block(body_bcx_out, body, expr::Ignore);\n     body_bcx_out ="}, {"sha": "f829a8ec248faf20a268093a775914bb62a14100", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 121, "deletions": 70, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=f673e9841f58a2196efd3b757804efa2575f8b79", "patch": "@@ -182,7 +182,6 @@\n //! comparatively expensive to construct, though, `ty::type_id()` is still used\n //! additionally as an optimization for cases where the exact same type has been\n //! seen before (which is most of the time).\n-use self::FunctionDebugContextRepr::*;\n use self::VariableAccess::*;\n use self::VariableKind::*;\n use self::MemberOffset::*;\n@@ -679,12 +678,8 @@ impl<'tcx> CrateDebugContext<'tcx> {\n     }\n }\n \n-pub struct FunctionDebugContext {\n-    repr: FunctionDebugContextRepr,\n-}\n-\n-enum FunctionDebugContextRepr {\n-    DebugInfo(Box<FunctionDebugContextData>),\n+pub enum FunctionDebugContext {\n+    RegularContext(Box<FunctionDebugContextData>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n@@ -694,13 +689,13 @@ impl FunctionDebugContext {\n                    cx: &CrateContext,\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n-        match self.repr {\n-            DebugInfo(box ref data) => data,\n-            DebugInfoDisabled => {\n+        match *self {\n+            FunctionDebugContext::RegularContext(box ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::debuginfo_disabled_message());\n             }\n-            FunctionWithoutDebugInfo => {\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::should_be_ignored_message());\n             }\n@@ -844,6 +839,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n /// Creates debug information for the given local variable.\n ///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// local in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -852,11 +849,10 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n \n     let cx = bcx.ccx();\n     let def_map = &cx.tcx().def_map;\n+    let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n-        let var_ident = path1.node;\n-\n-        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -865,10 +861,15 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             }\n         };\n \n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n+                                      Referenced variable location is not an alloca!\");\n+        }\n+\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      var_ident,\n+                      var_ident.node,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -981,7 +982,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n     // actually have `T**`. So to get the actual variable we need to dereference once\n     // more. For ByCopy we just use the stack slot we created for the binding.\n-    let var_type = match binding.trmode {\n+    let var_access = match binding.trmode {\n         TrByCopy(llbinding) => DirectVariable {\n             alloca: llbinding\n         },\n@@ -998,27 +999,31 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   variable_ident,\n                   binding.ty,\n                   scope_metadata,\n-                  var_type,\n+                  var_access,\n                   LocalVariable,\n                   binding.span);\n }\n \n /// Creates debug information for the given function argument.\n ///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// argument in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let fcx = bcx.fcx;\n-    let cx = fcx.ccx;\n+    let def_map = &bcx.tcx().def_map;\n+    let scope_metadata = bcx\n+                         .fcx\n+                         .debug_context\n+                         .get_ref(bcx.ccx(), arg.pat.span)\n+                         .fn_metadata;\n+    let locals = bcx.fcx.lllocals.borrow();\n \n-    let def_map = &cx.tcx().def_map;\n-    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n-\n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n-        let llarg = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1027,28 +1032,72 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null_mut() {\n-            cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n-                                    Referenced variable location is not an alloca!\");\n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+                                       Referenced variable location is not an alloca!\");\n         }\n \n         let argument_index = {\n-            let counter = &fcx.debug_context.get_ref(cx, span).argument_counter;\n+            let counter = &bcx\n+                          .fcx\n+                          .debug_context\n+                          .get_ref(bcx.ccx(), span)\n+                          .argument_counter;\n             let argument_index = counter.get();\n             counter.set(argument_index + 1);\n             argument_index\n         };\n \n         declare_local(bcx,\n-                      path1.node,\n-                      llarg.ty,\n+                      var_ident.node,\n+                      datum.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: llarg.val },\n+                      DirectVariable { alloca: datum.val },\n                       ArgumentVariable(argument_index),\n                       span);\n     })\n }\n \n+/// Creates debug information for the given for-loop variable.\n+///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// loop variable in `bcx.fcx.lllocals`.\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n+\n+    let def_map = &bcx.tcx().def_map;\n+    let locals = bcx.fcx.lllocals.borrow();\n+\n+    pat_util::pat_bindings(def_map, pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n+            Some(datum) => datum,\n+            None => {\n+                bcx.sess().span_bug(span,\n+                    format!(\"no entry in lllocals table for {}\",\n+                            node_id).as_slice());\n+            }\n+        };\n+\n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            bcx.sess().span_bug(span, \"debuginfo::create_for_loop_var_metadata() - \\\n+                                       Referenced variable location is not an alloca!\");\n+        }\n+\n+        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+\n+        declare_local(bcx,\n+                      var_ident.node,\n+                      datum.ty,\n+                      scope_metadata,\n+                      DirectVariable { alloca: datum.val },\n+                      LocalVariable,\n+                      span);\n+    })\n+}\n+\n pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,\n@@ -1117,13 +1166,13 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n-    match fcx.debug_context.repr {\n-        DebugInfoDisabled => return,\n-        FunctionWithoutDebugInfo => {\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => return,\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n             set_debug_location(fcx.ccx, UnknownLocation);\n             return;\n         }\n-        DebugInfo(box ref function_debug_context) => {\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n             debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n@@ -1160,8 +1209,8 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context.repr {\n-        DebugInfo(box ref data) => {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -1179,7 +1228,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                param_substs: &Substs<'tcx>,\n                                                llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n-        return FunctionDebugContext { repr: DebugInfoDisabled };\n+        return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n     // Clear the debug location so we don't assign them in the function prelude.\n@@ -1189,7 +1238,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     if fn_ast_id == ast::DUMMY_NODE_ID {\n         // This is a function not linked to any source location, so don't\n         // generate debuginfo for it.\n-        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n     let empty_generics = ast_util::empty_generics();\n@@ -1199,7 +1248,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n             if contains_nodebug_attribute(item.attrs.as_slice()) {\n-                return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+                return FunctionDebugContext::FunctionWithoutDebugInfo;\n             }\n \n             match item.node {\n@@ -1216,9 +1265,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **item {\n                 ast::MethodImplItem(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext {\n-                            repr: FunctionWithoutDebugInfo\n-                        };\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (method.pe_ident(),\n@@ -1257,9 +1304,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **trait_method {\n                 ast::ProvidedMethod(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext {\n-                            repr: FunctionWithoutDebugInfo\n-                        };\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (method.pe_ident(),\n@@ -1280,7 +1325,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeForeignItem(..) |\n         ast_map::NodeVariant(..) |\n         ast_map::NodeStructCtor(..) => {\n-            return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n@@ -1289,7 +1334,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // This can be the case for functions inlined from another crate\n     if span == codemap::DUMMY_SP {\n-        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n     let loc = span_start(cx, span);\n@@ -1356,22 +1401,23 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n     });\n \n+    let scope_map = create_scope_map(cx,\n+                                     fn_decl.inputs.as_slice(),\n+                                     &*top_level_block,\n+                                     fn_metadata,\n+                                     fn_ast_id);\n+\n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(NodeMap::new()),\n+        scope_map: RefCell::new(scope_map),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n     };\n \n-    populate_scope_map(cx,\n-                       fn_decl.inputs.as_slice(),\n-                       &*top_level_block,\n-                       fn_metadata,\n-                       fn_ast_id,\n-                       &mut *fn_debug_context.scope_map.borrow_mut());\n \n-    return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n+\n+    return FunctionDebugContext::RegularContext(fn_debug_context);\n \n     fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                         fn_ast_id: ast::NodeId,\n@@ -3134,8 +3180,8 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n-    match fcx.debug_context.repr {\n-        DebugInfo(_) => false,\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(_) => false,\n         _ => true\n     }\n }\n@@ -3169,12 +3215,14 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // what belongs to which scope, creating DIScope DIEs along the way, and\n // introducing *artificial* lexical scope descriptors where necessary. These\n // artificial scopes allow GDB to correctly handle name shadowing.\n-fn populate_scope_map(cx: &CrateContext,\n-                      args: &[ast::Arg],\n-                      fn_entry_block: &ast::Block,\n-                      fn_metadata: DISubprogram,\n-                      fn_ast_id: ast::NodeId,\n-                      scope_map: &mut NodeMap<DIScope>) {\n+fn create_scope_map(cx: &CrateContext,\n+                    args: &[ast::Arg],\n+                    fn_entry_block: &ast::Block,\n+                    fn_metadata: DISubprogram,\n+                    fn_ast_id: ast::NodeId)\n+                 -> NodeMap<DIScope> {\n+    let mut scope_map = NodeMap::new();\n+\n     let def_map = &cx.tcx().def_map;\n \n     struct ScopeStackEntry {\n@@ -3200,11 +3248,14 @@ fn populate_scope_map(cx: &CrateContext,\n     with_new_scope(cx,\n                    fn_entry_block.span,\n                    &mut scope_stack,\n-                   scope_map,\n+                   &mut scope_map,\n                    |cx, scope_stack, scope_map| {\n         walk_block(cx, fn_entry_block, scope_stack, scope_map);\n     });\n \n+    return scope_map;\n+\n+\n     // local helper functions for walking the AST.\n     fn with_new_scope<F>(cx: &CrateContext,\n                          scope_span: Span,\n@@ -3440,7 +3491,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::PatMac(_) => {\n-                cx.sess().span_bug(pat.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n         }\n@@ -3531,7 +3582,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprIfLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded if-let.\");\n             }\n \n@@ -3548,7 +3599,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprWhileLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded while-let.\");\n             }\n \n@@ -3573,7 +3624,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprMac(_) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n "}, {"sha": "9935bb60364862da137b08ffd5618a2d42d71f62", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=f673e9841f58a2196efd3b757804efa2575f8b79", "patch": "@@ -0,0 +1,219 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android: FIXME(#10381)\n+// min-lldb-version: 310\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+\n+// DESTRUCTURED STRUCT\n+// gdb-command:print x\n+// gdb-check:$1 = 400\n+// gdb-command:print y\n+// gdb-check:$2 = 401.5\n+// gdb-command:print z\n+// gdb-check:$3 = true\n+// gdb-command:continue\n+\n+// DESTRUCTURED TUPLE\n+// gdb-command:print/x _i8\n+// gdb-check:$4 = 0x6f\n+// gdb-command:print/x _u8\n+// gdb-check:$5 = 0x70\n+// gdb-command:print _i16\n+// gdb-check:$6 = -113\n+// gdb-command:print _u16\n+// gdb-check:$7 = 114\n+// gdb-command:print _i32\n+// gdb-check:$8 = -115\n+// gdb-command:print _u32\n+// gdb-check:$9 = 116\n+// gdb-command:print _i64\n+// gdb-check:$10 = -117\n+// gdb-command:print _u64\n+// gdb-check:$11 = 118\n+// gdb-command:print _f32\n+// gdb-check:$12 = 119.5\n+// gdb-command:print _f64\n+// gdb-check:$13 = 120.5\n+// gdb-command:continue\n+\n+// MORE COMPLEX CASE\n+// gdb-command:print v1\n+// gdb-check:$14 = 80000\n+// gdb-command:print x1\n+// gdb-check:$15 = 8000\n+// gdb-command:print *y1\n+// gdb-check:$16 = 80001.5\n+// gdb-command:print z1\n+// gdb-check:$17 = false\n+// gdb-command:print *x2\n+// gdb-check:$18 = -30000\n+// gdb-command:print y2\n+// gdb-check:$19 = -300001.5\n+// gdb-command:print *z2\n+// gdb-check:$20 = true\n+// gdb-command:print v2\n+// gdb-check:$21 = 854237.5\n+// gdb-command:continue\n+\n+// SIMPLE IDENTIFIER\n+// gdb-command:print i\n+// gdb-check:$22 = 1234\n+// gdb-command:continue\n+\n+// gdb-command:print simple_struct_ident\n+// gdb-check:$23 = {x = 3537, y = 35437.5, z = true}\n+// gdb-command:continue\n+\n+// gdb-command:print simple_tuple_ident\n+// gdb-check:$24 = {34903493, 232323}\n+// gdb-command:continue\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:type format add --format hex char\n+// lldb-command:type format add --format hex 'unsigned char'\n+\n+// lldb-command:run\n+\n+// DESTRUCTURED STRUCT\n+// lldb-command:print x\n+// lldb-check:[...]$0 = 400\n+// lldb-command:print y\n+// lldb-check:[...]$1 = 401.5\n+// lldb-command:print z\n+// lldb-check:[...]$2 = true\n+// lldb-command:continue\n+\n+// DESTRUCTURED TUPLE\n+// lldb-command:print _i8\n+// lldb-check:[...]$3 = 0x6f\n+// lldb-command:print _u8\n+// lldb-check:[...]$4 = 0x70\n+// lldb-command:print _i16\n+// lldb-check:[...]$5 = -113\n+// lldb-command:print _u16\n+// lldb-check:[...]$6 = 114\n+// lldb-command:print _i32\n+// lldb-check:[...]$7 = -115\n+// lldb-command:print _u32\n+// lldb-check:[...]$8 = 116\n+// lldb-command:print _i64\n+// lldb-check:[...]$9 = -117\n+// lldb-command:print _u64\n+// lldb-check:[...]$10 = 118\n+// lldb-command:print _f32\n+// lldb-check:[...]$11 = 119.5\n+// lldb-command:print _f64\n+// lldb-check:[...]$12 = 120.5\n+// lldb-command:continue\n+\n+// MORE COMPLEX CASE\n+// lldb-command:print v1\n+// lldb-check:[...]$13 = 80000\n+// lldb-command:print x1\n+// lldb-check:[...]$14 = 8000\n+// lldb-command:print *y1\n+// lldb-check:[...]$15 = 80001.5\n+// lldb-command:print z1\n+// lldb-check:[...]$16 = false\n+// lldb-command:print *x2\n+// lldb-check:[...]$17 = -30000\n+// lldb-command:print y2\n+// lldb-check:[...]$18 = -300001.5\n+// lldb-command:print *z2\n+// lldb-check:[...]$19 = true\n+// lldb-command:print v2\n+// lldb-check:[...]$20 = 854237.5\n+// lldb-command:continue\n+\n+// SIMPLE IDENTIFIER\n+// lldb-command:print i\n+// lldb-check:[...]$21 = 1234\n+// lldb-command:continue\n+\n+// lldb-command:print simple_struct_ident\n+// lldb-check:[...]$22 = Struct { x: 3537, y: 35437.5, z: true }\n+// lldb-command:continue\n+\n+// lldb-command:print simple_tuple_ident\n+// lldb-check:[...]$23 = (34903493, 232323)\n+// lldb-command:continue\n+\n+struct Struct {\n+    x: i16,\n+    y: f32,\n+    z: bool\n+}\n+\n+fn main() {\n+\n+    let s = Struct {\n+        x: 400,\n+        y: 401.5,\n+        z: true\n+    };\n+\n+    for &Struct { x, y, z } in [s].iter() {\n+        zzz(); // #break\n+    }\n+\n+    let tuple: (i8, u8, i16, u16, i32, u32, i64, u64, f32, f64) =\n+        (0x6f, 0x70, -113, 114, -115, 116, -117, 118, 119.5, 120.5);\n+\n+    for &(_i8, _u8, _i16, _u16, _i32, _u32, _i64, _u64, _f32, _f64) in [tuple].iter() {\n+        zzz(); // #break\n+    }\n+\n+    let more_complex: (i32, &Struct, Struct, Box<f64>) =\n+        (80000,\n+         &Struct {\n+            x: 8000,\n+            y: 80001.5,\n+            z: false\n+         },\n+         Struct {\n+            x: -30000,\n+            y: -300001.5,\n+            z: true\n+         },\n+         box 854237.5);\n+\n+    for &(v1,\n+          &Struct { x: x1, y: ref y1, z: z1 },\n+          Struct { x: ref x2, y: y2, z: ref z2 },\n+          box v2) in [more_complex].iter() {\n+        zzz(); // #break\n+    }\n+\n+    for i in range(1234, 1235i) {\n+        zzz(); // #break\n+    }\n+\n+    for simple_struct_ident in\n+      vec![Struct {\n+            x: 3537,\n+            y: 35437.5,\n+            z: true\n+           }].into_iter() {\n+      zzz(); // #break\n+    }\n+\n+    for simple_tuple_ident in vec![(34903493u32, 232323i64)].into_iter() {\n+      zzz(); // #break\n+    }\n+}\n+\n+fn zzz() {()}"}, {"sha": "7636ffdb07dcd6a02a54e656d3db53d5a5a9bd75", "filename": "src/test/debuginfo/lexical-scope-in-for-loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f673e9841f58a2196efd3b757804efa2575f8b79/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs?ref=f673e9841f58a2196efd3b757804efa2575f8b79", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // ignore-android: FIXME(#10381)\n-// ignore-test: Not sure what is going on here --pcwalton\n // min-lldb-version: 310\n \n // compile-flags:-g"}]}