{"sha": "fad64db5783d8d575ffdb262f032a276c335b384", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZDY0ZGI1NzgzZDhkNTc1ZmZkYjI2MmYwMzJhMjc2YzMzNWIzODQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-27T17:01:30Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-27T17:02:10Z"}, "message": "share some common code for compile-time miri instances", "tree": {"sha": "eb5378fb63fe586bd476e7ba35fe45cf004136eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb5378fb63fe586bd476e7ba35fe45cf004136eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fad64db5783d8d575ffdb262f032a276c335b384", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fad64db5783d8d575ffdb262f032a276c335b384", "html_url": "https://github.com/rust-lang/rust/commit/fad64db5783d8d575ffdb262f032a276c335b384", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fad64db5783d8d575ffdb262f032a276c335b384/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "html_url": "https://github.com/rust-lang/rust/commit/46ec74e60f238f694b46c976d6217e7cf8d4cf1a"}], "stats": {"total": 187, "additions": 74, "deletions": 113}, "files": [{"sha": "84031ec0f17649aea4b0046ad45ca5c91b0cde93", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=fad64db5783d8d575ffdb262f032a276c335b384", "patch": "@@ -1,7 +1,7 @@\n use rustc_middle::mir;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, Ty};\n-use std::borrow::{Borrow, Cow};\n+use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n \n@@ -13,8 +13,8 @@ use rustc_middle::mir::AssertMessage;\n use rustc_span::symbol::Symbol;\n \n use crate::interpret::{\n-    self, AllocId, Allocation, Frame, GlobalId, ImmTy, InterpCx, InterpResult, Memory, MemoryKind,\n-    OpTy, PlaceTy, Pointer, Scalar,\n+    self, compile_time_machine, AllocId, Allocation, Frame, GlobalId, ImmTy, InterpCx,\n+    InterpResult, Memory, OpTy, PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n@@ -171,29 +171,9 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n-    type MemoryKind = !;\n-    type PointerTag = ();\n-    type ExtraFnVal = !;\n+    compile_time_machine!(<'mir, 'tcx>);\n \n-    type FrameExtra = ();\n     type MemoryExtra = MemoryExtra;\n-    type AllocExtra = ();\n-\n-    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n-\n-    const GLOBAL_KIND: Option<!> = None; // no copying of globals from `tcx` to machine memory\n-\n-    #[inline(always)]\n-    fn enforce_alignment(_memory_extra: &Self::MemoryExtra) -> bool {\n-        // We do not check for alignment to avoid having to carry an `Align`\n-        // in `ConstValue::ByRef`.\n-        false\n-    }\n-\n-    #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        false // for now, we don't enforce validity\n-    }\n \n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -241,16 +221,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }))\n     }\n \n-    fn call_extra_fn(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        fn_val: !,\n-        _args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        match fn_val {}\n-    }\n-\n     fn call_intrinsic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n@@ -310,20 +280,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n     }\n \n-    #[inline(always)]\n-    fn init_allocation_extra<'b>(\n-        _memory_extra: &MemoryExtra,\n-        _id: AllocId,\n-        alloc: Cow<'b, Allocation>,\n-        _kind: Option<MemoryKind<!>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n-        // We do not use a tag so we can just cheaply forward the allocation\n-        (alloc, ())\n-    }\n-\n-    #[inline(always)]\n-    fn tag_global_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {}\n-\n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n@@ -345,14 +301,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Ok(())\n     }\n \n-    #[inline(always)]\n-    fn init_frame_extra(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        frame: Frame<'mir, 'tcx>,\n-    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n-        Ok(frame)\n-    }\n-\n     #[inline(always)]\n     fn stack(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,"}, {"sha": "03a617993e916e08ba0b0cbf6ff37ebe2576d0ac", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=fad64db5783d8d575ffdb262f032a276c335b384", "patch": "@@ -357,3 +357,67 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64>;\n }\n+\n+// A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n+// (CTFE and ConstProp) use the same instance.  Here, we share that code.\n+pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n+    type PointerTag = ();\n+    type ExtraFnVal = !;\n+\n+    type MemoryKind = !;\n+    type MemoryMap = rustc_data_structures::fx::FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n+    const GLOBAL_KIND: Option<!> = None; // no copying of globals from `tcx` to machine memory\n+\n+    type AllocExtra = ();\n+    type FrameExtra = ();\n+\n+    #[inline(always)]\n+    fn enforce_alignment(_memory_extra: &Self::MemoryExtra) -> bool {\n+        // We do not check for alignment to avoid having to carry an `Align`\n+        // in `ConstValue::ByRef`.\n+        false\n+    }\n+\n+    #[inline(always)]\n+    fn enforce_validity(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n+        false // for now, we don't enforce validity\n+    }\n+\n+    #[inline(always)]\n+    fn call_extra_fn(\n+        _ecx: &mut InterpCx<$mir, $tcx, Self>,\n+        fn_val: !,\n+        _args: &[OpTy<$tcx>],\n+        _ret: Option<(PlaceTy<$tcx>, mir::BasicBlock)>,\n+        _unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<$tcx> {\n+        match fn_val {}\n+    }\n+\n+    #[inline(always)]\n+    fn init_allocation_extra<'b>(\n+        _memory_extra: &Self::MemoryExtra,\n+        _id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        _kind: Option<MemoryKind<!>>,\n+    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n+        // We do not use a tag so we can just cheaply forward the allocation\n+        (alloc, ())\n+    }\n+\n+    #[inline(always)]\n+    fn tag_global_base_pointer(\n+        _memory_extra: &Self::MemoryExtra,\n+        _id: AllocId,\n+    ) -> Self::PointerTag {\n+        ()\n+    }\n+\n+    #[inline(always)]\n+    fn init_frame_extra(\n+        _ecx: &mut InterpCx<$mir, $tcx, Self>,\n+        frame: Frame<$mir, $tcx>,\n+    ) -> InterpResult<$tcx, Frame<$mir, $tcx>> {\n+        Ok(frame)\n+    }\n+}"}, {"sha": "d46010d98a5aa82349559a0fb1e13bb3a0183bd1", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=fad64db5783d8d575ffdb262f032a276c335b384", "patch": "@@ -19,7 +19,7 @@ pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in\n \n pub use self::eval_context::{Frame, InterpCx, LocalState, LocalValue, StackPopCleanup};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n-pub use self::machine::{AllocMap, Machine, MayLeak, StackPopJump};\n+pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};"}, {"sha": "ae7bbe9f36a3a2bc8b8dda5a552485100fbea0c7", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=fad64db5783d8d575ffdb262f032a276c335b384", "patch": "@@ -13,6 +13,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n+#![feature(decl_macro)]\n #![feature(drain_filter)]\n #![feature(exhaustive_patterns)]\n #![feature(iter_order_by)]"}, {"sha": "a38cf3bba85bfb243571dc3c36302020e740768b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad64db5783d8d575ffdb262f032a276c335b384/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fad64db5783d8d575ffdb262f032a276c335b384", "patch": "@@ -1,11 +1,9 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use std::borrow::Cow;\n use std::cell::Cell;\n \n use rustc_ast::ast::Mutability;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n@@ -29,9 +27,9 @@ use rustc_trait_selection::traits;\n \n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n-    self, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy, Immediate, InternKind,\n-    InterpCx, LocalState, LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n-    Pointer, ScalarMaybeUndef, StackPopCleanup,\n+    self, compile_time_machine, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy,\n+    Immediate, InternKind, InterpCx, LocalState, LocalValue, Memory, MemoryKind, OpTy,\n+    Operand as InterpOperand, PlaceTy, Pointer, ScalarMaybeUndef, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -162,27 +160,9 @@ impl<'mir, 'tcx> ConstPropMachine<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx> {\n-    type MemoryKind = !;\n-    type PointerTag = ();\n-    type ExtraFnVal = !;\n+    compile_time_machine!(<'mir, 'tcx>);\n \n-    type FrameExtra = ();\n     type MemoryExtra = ();\n-    type AllocExtra = ();\n-\n-    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n-\n-    const GLOBAL_KIND: Option<!> = None; // no copying of globals from `tcx` to machine memory\n-\n-    #[inline(always)]\n-    fn enforce_alignment(_memory_extra: &Self::MemoryExtra) -> bool {\n-        false\n-    }\n-\n-    #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        false\n-    }\n \n     fn find_mir_or_eval_fn(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -194,16 +174,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         Ok(None)\n     }\n \n-    fn call_extra_fn(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        fn_val: !,\n-        _args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n-        _unwind: Option<BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        match fn_val {}\n-    }\n-\n     fn call_intrinsic(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n@@ -236,20 +206,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n-    #[inline(always)]\n-    fn init_allocation_extra<'b>(\n-        _memory_extra: &(),\n-        _id: AllocId,\n-        alloc: Cow<'b, Allocation>,\n-        _kind: Option<MemoryKind<!>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n-        // We do not use a tag so we can just cheaply forward the allocation\n-        (alloc, ())\n-    }\n-\n-    #[inline(always)]\n-    fn tag_global_base_pointer(_memory_extra: &(), _id: AllocId) -> Self::PointerTag {}\n-\n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n@@ -290,14 +246,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         Ok(())\n     }\n \n-    #[inline(always)]\n-    fn init_frame_extra(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        frame: Frame<'mir, 'tcx>,\n-    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n-        Ok(frame)\n-    }\n-\n     #[inline(always)]\n     fn stack(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,"}]}