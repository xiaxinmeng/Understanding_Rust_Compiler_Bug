{"sha": "8ab82b87af4f20b6c0a481e050517103d50263e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYjgyYjg3YWY0ZjIwYjZjMGE0ODFlMDUwNTE3MTAzZDUwMjYzZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-29T09:50:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-29T09:50:52Z"}, "message": "Auto merge of #70525 - Centril:rollup-vj3esv3, r=Centril\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #68692 (impl From<[T; N]> for Vec<T>)\n - #70101 (Add copy bound to atomic & numeric intrinsics)\n - #70506 (BTreeMap testing: introduce symbolic constants and use height consistently)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "5ffd5002cb637fdb542bd9efbfc7135a1cdb4354", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ffd5002cb637fdb542bd9efbfc7135a1cdb4354"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ab82b87af4f20b6c0a481e050517103d50263e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab82b87af4f20b6c0a481e050517103d50263e9", "html_url": "https://github.com/rust-lang/rust/commit/8ab82b87af4f20b6c0a481e050517103d50263e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ab82b87af4f20b6c0a481e050517103d50263e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "html_url": "https://github.com/rust-lang/rust/commit/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2"}, {"sha": "f31e56309a769dcef456ce419a81500801b247ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/f31e56309a769dcef456ce419a81500801b247ef", "html_url": "https://github.com/rust-lang/rust/commit/f31e56309a769dcef456ce419a81500801b247ef"}], "stats": {"total": 362, "additions": 202, "deletions": 160}, "files": [{"sha": "535b6a9c31451c9fd69f22ff4ec82e5f0bac4ed6", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=8ab82b87af4f20b6c0a481e050517103d50263e9", "patch": "@@ -7,17 +7,31 @@ use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::catch_unwind;\n use std::rc::Rc;\n-use std::sync::atomic::{AtomicU32, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n use super::DeterministicRng;\n \n+// Value of node::CAPACITY, thus capacity of a tree with a single level,\n+// i.e. a tree who's root is a leaf node at height 0.\n+const NODE_CAPACITY: usize = 11;\n+\n+// Minimum number of elements to insert in order to guarantee a tree with 2 levels,\n+// i.e. a tree who's root is an internal node at height 1, with edges to leaf nodes.\n+// It's not the minimum size: removing an element from such a tree does not always reduce height.\n+const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n+\n+// Minimum number of elements to insert in order to guarantee a tree with 3 levels,\n+// i.e. a tree who's root is an internal node at height 2, with edges to more internal nodes.\n+// It's not the minimum size: removing an element from such a tree does not always reduce height.\n+const MIN_INSERTS_HEIGHT_2: usize = NODE_CAPACITY + (NODE_CAPACITY + 1) * NODE_CAPACITY + 1;\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n     #[cfg(miri)]\n-    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n+    let size = MIN_INSERTS_HEIGHT_2;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -237,30 +251,26 @@ impl TryFrom<usize> for Align32 {\n \n #[test]\n fn test_iter_mut_mutation() {\n-    // Check many alignments because various fields precede array in NodeHeader.\n-    // Check with size 0 which should not iterate at all.\n-    // Check with size 1 for a tree with one kind of node (root = leaf).\n-    // Check with size 12 for a tree with two kinds of nodes (root and leaves).\n-    // Check with size 144 for a tree with all kinds of nodes (root, internals and leaves).\n+    // Check many alignments and trees with roots at various heights.\n     do_test_iter_mut_mutation::<u8>(0);\n     do_test_iter_mut_mutation::<u8>(1);\n-    do_test_iter_mut_mutation::<u8>(12);\n-    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test 144\n+    do_test_iter_mut_mutation::<u8>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test MIN_INSERTS_HEIGHT_2\n     do_test_iter_mut_mutation::<u16>(1);\n-    do_test_iter_mut_mutation::<u16>(12);\n-    do_test_iter_mut_mutation::<u16>(144);\n+    do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u32>(1);\n-    do_test_iter_mut_mutation::<u32>(12);\n-    do_test_iter_mut_mutation::<u32>(144);\n+    do_test_iter_mut_mutation::<u32>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u32>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u64>(1);\n-    do_test_iter_mut_mutation::<u64>(12);\n-    do_test_iter_mut_mutation::<u64>(144);\n+    do_test_iter_mut_mutation::<u64>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u64>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u128>(1);\n-    do_test_iter_mut_mutation::<u128>(12);\n-    do_test_iter_mut_mutation::<u128>(144);\n+    do_test_iter_mut_mutation::<u128>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u128>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<Align32>(1);\n-    do_test_iter_mut_mutation::<Align32>(12);\n-    do_test_iter_mut_mutation::<Align32>(144);\n+    do_test_iter_mut_mutation::<Align32>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<Align32>(MIN_INSERTS_HEIGHT_2);\n }\n \n #[test]\n@@ -376,12 +386,11 @@ fn test_range_small() {\n }\n \n #[test]\n-fn test_range_height_2() {\n-    // Assuming that node.CAPACITY is 11, having 12 pairs implies a height 2 tree\n-    // with 2 leaves. Depending on details we don't want or need to rely upon,\n-    // the single key at the root will be 6 or 7.\n+fn test_range_height_1() {\n+    // Tests tree with a root and 2 leaves. Depending on details we don't want or need\n+    // to rely upon, the single key at the root will be 6 or 7.\n \n-    let map: BTreeMap<_, _> = (1..=12).map(|i| (i, i)).collect();\n+    let map: BTreeMap<_, _> = (1..=MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n     for &root in &[6, 7] {\n         assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n         assert_eq!(range_keys(&map, (Excluded(root), Included(root + 1))), vec![root + 1]);\n@@ -519,7 +528,7 @@ fn test_range_1000() {\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 1000;\n     #[cfg(miri)]\n-    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n+    let size = MIN_INSERTS_HEIGHT_2;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -755,7 +764,7 @@ fn test_bad_zst() {\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n-    let size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n+    let size = MIN_INSERTS_HEIGHT_1;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -783,20 +792,19 @@ fn test_clone() {\n         assert_eq!(map, map.clone());\n     }\n \n-    // Full 2-level and minimal 3-level tree (sizes 143, 144 -- the only ones we clone for).\n-    for i in 1..=144 {\n-        assert_eq!(map.insert(i, i), None);\n-        assert_eq!(map.len(), i);\n-        if i >= 143 {\n-            assert_eq!(map, map.clone());\n-        }\n-    }\n+    // Test a tree with 2 chock-full levels and a tree with 3 levels.\n+    map = (1..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(map, map.clone());\n+    map.insert(0, 0);\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2);\n+    assert_eq!(map, map.clone());\n }\n \n #[test]\n fn test_clone_from() {\n     let mut map1 = BTreeMap::new();\n-    let max_size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n+    let max_size = MIN_INSERTS_HEIGHT_1;\n \n     // Range to max_size inclusive, because i is the size of map1 being tested.\n     for i in 0..=max_size {\n@@ -1014,8 +1022,8 @@ fn test_split_off_large_random_sorted() {\n }\n \n #[test]\n-fn test_into_iter_drop_leak_1() {\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n+fn test_into_iter_drop_leak_height_0() {\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n \n     struct D;\n \n@@ -1040,10 +1048,10 @@ fn test_into_iter_drop_leak_1() {\n }\n \n #[test]\n-fn test_into_iter_drop_leak_2() {\n-    let size = 12; // to obtain tree with 2 levels (having edges to leaf nodes)\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-    static PANIC_POINT: AtomicU32 = AtomicU32::new(0);\n+fn test_into_iter_drop_leak_height_1() {\n+    let size = MIN_INSERTS_HEIGHT_1;\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n+    static PANIC_POINT: AtomicUsize = AtomicUsize::new(0);\n \n     struct D;\n     impl Drop for D {"}, {"sha": "e171edef736098d493980e47b8ce710fa722735d", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=8ab82b87af4f20b6c0a481e050517103d50263e9", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! A contiguous growable array type with heap-allocated contents, written\n //! `Vec<T>`.\n //!\n@@ -2398,6 +2399,21 @@ impl<T: Clone> From<&mut [T]> for Vec<T> {\n     }\n }\n \n+#[stable(feature = \"vec_from_array\", since = \"1.44.0\")]\n+impl<T, const N: usize> From<[T; N]> for Vec<T>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[cfg(not(test))]\n+    fn from(s: [T; N]) -> Vec<T> {\n+        <[T]>::into_vec(box s)\n+    }\n+    #[cfg(test)]\n+    fn from(s: [T; N]) -> Vec<T> {\n+        crate::slice::into_vec(box s)\n+    }\n+}\n+\n #[stable(feature = \"vec_from_cow_slice\", since = \"1.14.0\")]\n impl<'a, T> From<Cow<'a, [T]>> for Vec<T>\n where"}, {"sha": "0c956104221ebfce973188cc9845a22cfd72bbb0", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8ab82b87af4f20b6c0a481e050517103d50263e9", "patch": "@@ -76,7 +76,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -86,7 +86,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -98,7 +98,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -110,7 +110,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -120,7 +120,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -132,7 +132,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -144,7 +144,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -156,7 +156,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -168,7 +168,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange`][compare_exchange].\n     ///\n     /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n-    pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n@@ -179,7 +179,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -189,7 +189,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -201,7 +201,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -213,7 +213,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -223,7 +223,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -235,7 +235,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -247,7 +247,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -259,7 +259,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -271,7 +271,7 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::compare_exchange_weak`][cew].\n     ///\n     /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n-    pub fn atomic_cxchgweak_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n@@ -280,24 +280,24 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n-    pub fn atomic_load<T>(src: *const T) -> T;\n+    pub fn atomic_load<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `load` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n-    pub fn atomic_load_acq<T>(src: *const T) -> T;\n+    pub fn atomic_load_acq<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `load` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n-    pub fn atomic_load_relaxed<T>(src: *const T) -> T;\n-    pub fn atomic_load_unordered<T>(src: *const T) -> T;\n+    pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n \n     /// Stores the value at the specified memory location.\n     ///\n@@ -306,24 +306,24 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n-    pub fn atomic_store<T>(dst: *mut T, val: T);\n+    pub fn atomic_store<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `store` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n-    pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n+    pub fn atomic_store_rel<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `store` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n-    pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);\n-    pub fn atomic_store_unordered<T>(dst: *mut T, val: T);\n+    pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n \n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n@@ -332,39 +332,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `swap` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n-    pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Adds to the current value, returning the previous value.\n     ///\n@@ -373,39 +373,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n-    pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Subtract from the current value, returning the previous value.\n     ///\n@@ -414,39 +414,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_sub` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n-    pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise and with the current value, returning the previous value.\n     ///\n@@ -455,39 +455,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_and` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n-    pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n@@ -496,39 +496,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n-    pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise or with the current value, returning the previous value.\n     ///\n@@ -537,39 +537,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_or` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n-    pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n@@ -578,39 +578,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_xor` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n-    pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using a signed comparison.\n     ///\n@@ -619,39 +619,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n-    pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using a signed comparison.\n     ///\n@@ -660,39 +660,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n     /// as the `order`. For example,\n     /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n-    pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using an unsigned comparison.\n     ///\n@@ -701,39 +701,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n-    pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using an unsigned comparison.\n     ///\n@@ -742,39 +742,39 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n     /// as the `order`. For example,\n     /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n-    pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -1561,36 +1561,36 @@ extern \"rust-intrinsic\" {\n \n     /// Float addition that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn fadd_fast<T>(a: T, b: T) -> T;\n+    pub fn fadd_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float subtraction that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn fsub_fast<T>(a: T, b: T) -> T;\n+    pub fn fsub_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float multiplication that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn fmul_fast<T>(a: T, b: T) -> T;\n+    pub fn fmul_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float division that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn fdiv_fast<T>(a: T, b: T) -> T;\n+    pub fn fdiv_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float remainder that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n-    pub fn frem_fast<T>(a: T, b: T) -> T;\n+    pub fn frem_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     /// This is under stabilization at <https://github.com/rust-lang/rust/issues/67058>\n-    pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n+    pub fn float_to_int_approx_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `count_ones` method. For example,\n     /// [`std::u32::count_ones`](../../std/primitive.u32.html#method.count_ones)\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n-    pub fn ctpop<T>(x: T) -> T;\n+    pub fn ctpop<T: Copy>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n     ///\n@@ -1622,7 +1622,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_leading, 16);\n     /// ```\n     #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n-    pub fn ctlz<T>(x: T) -> T;\n+    pub fn ctlz<T: Copy>(x: T) -> T;\n \n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n     /// given an `x` with value `0`.\n@@ -1639,7 +1639,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_leading, 3);\n     /// ```\n     #[rustc_const_unstable(feature = \"constctlz\", issue = \"none\")]\n-    pub fn ctlz_nonzero<T>(x: T) -> T;\n+    pub fn ctlz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n     ///\n@@ -1671,7 +1671,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_trailing, 16);\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n-    pub fn cttz<T>(x: T) -> T;\n+    pub fn cttz<T: Copy>(x: T) -> T;\n \n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n     /// given an `x` with value `0`.\n@@ -1688,51 +1688,51 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_trailing, 3);\n     /// ```\n     #[rustc_const_unstable(feature = \"const_cttz\", issue = \"none\")]\n-    pub fn cttz_nonzero<T>(x: T) -> T;\n+    pub fn cttz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `swap_bytes` method. For example,\n     /// [`std::u32::swap_bytes`](../../std/primitive.u32.html#method.swap_bytes)\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n-    pub fn bswap<T>(x: T) -> T;\n+    pub fn bswap<T: Copy>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `reverse_bits` method. For example,\n     /// [`std::u32::reverse_bits`](../../std/primitive.u32.html#method.reverse_bits)\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n-    pub fn bitreverse<T>(x: T) -> T;\n+    pub fn bitreverse<T: Copy>(x: T) -> T;\n \n     /// Performs checked integer addition.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,\n     /// [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n-    pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n+    pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_sub` method. For example,\n     /// [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n-    pub fn sub_with_overflow<T>(x: T, y: T) -> (T, bool);\n+    pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_mul` method. For example,\n     /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n-    pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n+    pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n     /// `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n-    pub fn exact_div<T>(x: T, y: T) -> T;\n+    pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::min_value()` and y = -1\n@@ -1741,15 +1741,15 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_div` method. For example,\n     /// [`std::u32::checked_div`](../../std/primitive.u32.html#method.checked_div)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_div<T>(x: T, y: T) -> T;\n+    pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n     /// [`std::u32::checked_rem`](../../std/primitive.u32.html#method.checked_rem)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_rem<T>(x: T, y: T) -> T;\n+    pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n@@ -1758,83 +1758,83 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shl` method. For example,\n     /// [`std::u32::checked_shl`](../../std/primitive.u32.html#method.checked_shl)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n-    pub fn unchecked_shl<T>(x: T, y: T) -> T;\n+    pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_shr` method. For example,\n     /// [`std::u32::checked_shr`](../../std/primitive.u32.html#method.checked_shr)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n-    pub fn unchecked_shr<T>(x: T, y: T) -> T;\n+    pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_add<T>(x: T, y: T) -> T;\n+    pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_sub<T>(x: T, y: T) -> T;\n+    pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::max_value()` or `x * y < T::min_value()`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n-    pub fn unchecked_mul<T>(x: T, y: T) -> T;\n+    pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate left.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_left` method. For example,\n     /// [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n-    pub fn rotate_left<T>(x: T, y: T) -> T;\n+    pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_right` method. For example,\n     /// [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n-    pub fn rotate_right<T>(x: T, y: T) -> T;\n+    pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_add` method. For example,\n     /// [`std::u32::checked_add`](../../std/primitive.u32.html#method.checked_add)\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n-    pub fn wrapping_add<T>(a: T, b: T) -> T;\n+    pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_sub` method. For example,\n     /// [`std::u32::checked_sub`](../../std/primitive.u32.html#method.checked_sub)\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n-    pub fn wrapping_sub<T>(a: T, b: T) -> T;\n+    pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_mul` method. For example,\n     /// [`std::u32::checked_mul`](../../std/primitive.u32.html#method.checked_mul)\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n-    pub fn wrapping_mul<T>(a: T, b: T) -> T;\n+    pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, while saturating at numeric bounds.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,\n     /// [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n-    pub fn saturating_add<T>(a: T, b: T) -> T;\n+    pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, while saturating at numeric bounds.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_sub` method. For example,\n     /// [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n-    pub fn saturating_sub<T>(a: T, b: T) -> T;\n+    pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v',\n     /// cast to a `u64`; if `T` has no discriminant, returns 0."}, {"sha": "0d0765e971d50a053c6c5d7c173ee345fe3a4d80", "filename": "src/test/ui/const-generics/array-impls/alloc-traits-impls-length-32.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-impls-length-32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-impls-length-32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-impls-length-32.rs?ref=8ab82b87af4f20b6c0a481e050517103d50263e9", "patch": "@@ -14,6 +14,10 @@ where\n     Vec::<A>::new()\n }\n \n+pub fn yes_array_into_vec<T>() -> Vec<T> {\n+    [].into()\n+}\n+\n use std::collections::VecDeque;\n \n pub fn yes_vecdeque_partial_eq_array<A, B>() -> impl PartialEq<[B; 32]>"}, {"sha": "4b195f3a06edc730bcd14217e0af83b6e164e64f", "filename": "src/test/ui/const-generics/array-impls/alloc-types-no-impls-length-33.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.rs?ref=8ab82b87af4f20b6c0a481e050517103d50263e9", "patch": "@@ -2,6 +2,11 @@\n \n use std::{convert::TryFrom, rc::Rc, sync::Arc};\n \n+pub fn no_vec() {\n+    let v: Vec<_> = [0; 33].into();\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n pub fn no_box() {\n     let boxed_slice = Box::new([0; 33]) as Box<[i32]>;\n     let boxed_array = <Box<[i32; 33]>>::try_from(boxed_slice);"}, {"sha": "d795840551c50175184f374be842eaedaf5e2957", "filename": "src/test/ui/const-generics/array-impls/alloc-types-no-impls-length-33.stderr", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ab82b87af4f20b6c0a481e050517103d50263e9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.stderr?ref=8ab82b87af4f20b6c0a481e050517103d50263e9", "patch": "@@ -1,5 +1,14 @@\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/alloc-types-no-impls-length-33.rs:6:29\n+   |\n+LL |     let v: Vec<_> = [0; 33].into();\n+   |                             ^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[{integer}; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::convert::From<[{integer}; 33]>` for `std::vec::Vec<{integer}>`\n+   = note: required because of the requirements on the impl of `std::convert::Into<std::vec::Vec<{integer}>>` for `[{integer}; 33]`\n+\n error[E0277]: the trait bound `std::boxed::Box<[i32; 33]>: std::convert::From<std::boxed::Box<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:7:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:12:23\n    |\n LL |     let boxed_array = <Box<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::From<std::boxed::Box<[i32]>>` is not implemented for `std::boxed::Box<[i32; 33]>`\n@@ -14,7 +23,7 @@ LL |     let boxed_array = <Box<[i32; 33]>>::try_from(boxed_slice);\n    = note: required because of the requirements on the impl of `std::convert::TryFrom<std::boxed::Box<[i32]>>` for `std::boxed::Box<[i32; 33]>`\n \n error[E0277]: the trait bound `std::boxed::Box<[i32; 33]>: std::convert::TryFrom<std::boxed::Box<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:7:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:12:23\n    |\n LL |     let boxed_array = <Box<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::TryFrom<std::boxed::Box<[i32]>>` is not implemented for `std::boxed::Box<[i32; 33]>`\n@@ -23,7 +32,7 @@ LL |     let boxed_array = <Box<[i32; 33]>>::try_from(boxed_slice);\n              <std::boxed::Box<[T; _]> as std::convert::TryFrom<std::boxed::Box<[T]>>>\n \n error[E0277]: the trait bound `std::rc::Rc<[i32; 33]>: std::convert::From<std::rc::Rc<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:14:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:19:23\n    |\n LL |     let boxed_array = <Rc<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::From<std::rc::Rc<[i32]>>` is not implemented for `std::rc::Rc<[i32; 33]>`\n@@ -38,7 +47,7 @@ LL |     let boxed_array = <Rc<[i32; 33]>>::try_from(boxed_slice);\n    = note: required because of the requirements on the impl of `std::convert::TryFrom<std::rc::Rc<[i32]>>` for `std::rc::Rc<[i32; 33]>`\n \n error[E0277]: the trait bound `std::rc::Rc<[i32; 33]>: std::convert::TryFrom<std::rc::Rc<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:14:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:19:23\n    |\n LL |     let boxed_array = <Rc<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::TryFrom<std::rc::Rc<[i32]>>` is not implemented for `std::rc::Rc<[i32; 33]>`\n@@ -47,7 +56,7 @@ LL |     let boxed_array = <Rc<[i32; 33]>>::try_from(boxed_slice);\n              <std::rc::Rc<[T; _]> as std::convert::TryFrom<std::rc::Rc<[T]>>>\n \n error[E0277]: the trait bound `std::sync::Arc<[i32; 33]>: std::convert::From<std::sync::Arc<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:21:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:26:23\n    |\n LL |     let boxed_array = <Arc<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::From<std::sync::Arc<[i32]>>` is not implemented for `std::sync::Arc<[i32; 33]>`\n@@ -62,14 +71,14 @@ LL |     let boxed_array = <Arc<[i32; 33]>>::try_from(boxed_slice);\n    = note: required because of the requirements on the impl of `std::convert::TryFrom<std::sync::Arc<[i32]>>` for `std::sync::Arc<[i32; 33]>`\n \n error[E0277]: the trait bound `std::sync::Arc<[i32; 33]>: std::convert::TryFrom<std::sync::Arc<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:21:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:26:23\n    |\n LL |     let boxed_array = <Arc<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::TryFrom<std::sync::Arc<[i32]>>` is not implemented for `std::sync::Arc<[i32; 33]>`\n    |\n    = help: the following implementations were found:\n              <std::sync::Arc<[T; _]> as std::convert::TryFrom<std::sync::Arc<[T]>>>\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}]}