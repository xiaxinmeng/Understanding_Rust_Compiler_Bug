{"sha": "7858cb432d3f2efc0374424cb2b51518f697c172", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NThjYjQzMmQzZjJlZmMwMzc0NDI0Y2IyYjUxNTE4ZjY5N2MxNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-03T03:44:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-03T03:44:05Z"}, "message": "Auto merge of #21872 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "bccd460a861e61f758d2d459cb9da02b1ad8792b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bccd460a861e61f758d2d459cb9da02b1ad8792b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7858cb432d3f2efc0374424cb2b51518f697c172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7858cb432d3f2efc0374424cb2b51518f697c172", "html_url": "https://github.com/rust-lang/rust/commit/7858cb432d3f2efc0374424cb2b51518f697c172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7858cb432d3f2efc0374424cb2b51518f697c172/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaf4c5c784637f3df8bdebc6ec21dbd4bc69420a", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf4c5c784637f3df8bdebc6ec21dbd4bc69420a", "html_url": "https://github.com/rust-lang/rust/commit/eaf4c5c784637f3df8bdebc6ec21dbd4bc69420a"}, {"sha": "9ece22ee00033cdf0b6b418c451112c92c8ad922", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ece22ee00033cdf0b6b418c451112c92c8ad922", "html_url": "https://github.com/rust-lang/rust/commit/9ece22ee00033cdf0b6b418c451112c92c8ad922"}], "stats": {"total": 8942, "additions": 5748, "deletions": 3194}, "files": [{"sha": "d4ad98e6e87993d7dfb1557377affb77ba9089b6", "filename": "COPYRIGHT", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -23,12 +23,12 @@ The following third party packages are included, and carry\n their own copyright notices and license terms:\n \n * Two header files that are part of the Valgrind\n-  package. These files are found at src/rt/vg/valgrind.h and\n-  src/rt/vg/memcheck.h, within this distribution. These files\n+  package. These files are found at src/rt/valgrind/valgrind.h and\n+  src/rt/valgrind/memcheck.h, within this distribution. These files\n   are redistributed under the following terms, as noted in\n   them:\n \n-  for src/rt/vg/valgrind.h:\n+  for src/rt/valgrind/valgrind.h:\n \n     This file is part of Valgrind, a dynamic binary\n     instrumentation framework.\n@@ -74,7 +74,7 @@ their own copyright notices and license terms:\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n \n-  for src/rt/vg/memcheck.h:\n+  for src/rt/valgrind/memcheck.h:\n \n     This file is part of MemCheck, a heavyweight Valgrind\n     tool for detecting memory errors.\n@@ -120,18 +120,6 @@ their own copyright notices and license terms:\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n \n-* The auxiliary file src/etc/pkg/modpath.iss contains a\n-  library routine compiled, by Inno Setup, into the Windows\n-  installer binary. This file is licensed under the LGPL,\n-  version 3, but, in our legal interpretation, this does not\n-  affect the aggregate \"collected work\" license of the Rust\n-  distribution (MIT/ASL2) nor any other components of it. We\n-  believe that the terms governing distribution of the\n-  binary Windows installer built from modpath.iss are\n-  therefore LGPL, but not the terms governing distribution\n-  of any of the files installed by such an installer (such\n-  as the Rust compiler or runtime libraries themselves).\n-\n * The src/rt/miniz.c file, carrying an implementation of\n   RFC1950/RFC1951 DEFLATE, by Rich Geldreich\n   <richgel99@gmail.com>. All uses of this file are"}, {"sha": "2127f2c656d03bf8797bee7547d12850efac865a", "filename": "configure", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/configure", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -374,6 +374,10 @@ case $CFG_OSTYPE in\n         CFG_OSTYPE=unknown-dragonfly\n         ;;\n \n+    OpenBSD)\n+\tCFG_OSTYPE=unknown-openbsd\n+       ;;\n+\n     Darwin)\n         CFG_OSTYPE=apple-darwin\n         ;;"}, {"sha": "582d75c3eaf09dba7313d4f91336b11490746c37", "filename": "mk/cfg/x86_64-unknown-openbsd.mk", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/mk%2Fcfg%2Fx86_64-unknown-openbsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/mk%2Fcfg%2Fx86_64-unknown-openbsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-openbsd.mk?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -0,0 +1,26 @@\n+# x86_64-pc-openbsd-elf configuration\n+CC_x86_64-unknown-openbsd=$(CC)\n+CXX_x86_64-unknown-openbsd=$(CXX)\n+CPP_x86_64-unknown-openbsd=$(CPP)\n+AR_x86_64-unknown-openbsd=$(AR)\n+CFG_LIB_NAME_x86_64-unknown-openbsd=lib$(1).so\n+CFG_STATIC_LIB_NAME_x86_64-unknown-openbsd=lib$(1).a\n+CFG_LIB_GLOB_x86_64-unknown-openbsd=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_x86_64-unknown-openbsd=$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_x86_64-unknown-openbsd := -m64 -I/usr/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-unknown-openbsd := -Wall -Werror -g -fPIC -m64 -I/usr/include $(CFLAGS)\n+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-openbsd := -shared -fPIC -g -pthread -m64\n+CFG_GCCISH_DEF_FLAG_x86_64-unknown-openbsd := -Wl,--export-dynamic,--dynamic-list=\n+CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-openbsd := -Wl,-whole-archive\n+CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-openbsd := -Wl,-no-whole-archive\n+CFG_DEF_SUFFIX_x86_64-unknown-openbsd := .bsd.def\n+CFG_LLC_FLAGS_x86_64-unknown-openbsd :=\n+CFG_INSTALL_NAME_x86_64-unknown-openbsd =\n+CFG_EXE_SUFFIX_x86_64-unknown-openbsd :=\n+CFG_WINDOWSY_x86_64-unknown-openbsd :=\n+CFG_UNIXY_x86_64-unknown-openbsd := 1\n+CFG_PATH_MUNGE_x86_64-unknown-openbsd :=\n+CFG_LDPATH_x86_64-unknown-openbsd :=\n+CFG_RUN_x86_64-unknown-openbsd=$(2)\n+CFG_RUN_TARG_x86_64-unknown-openbsd=$(call CFG_RUN_x86_64-unknown-openbsd,,$(2))\n+CFG_GNU_TRIPLE_x86_64-unknown-openbsd := x86_64-unknown-openbsd"}, {"sha": "07e92c704d86f9fb854660d24378c27026fac86f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -22,6 +22,7 @@\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(unicode)]\n+#![feature(env)]\n \n #![deny(warnings)]\n \n@@ -31,7 +32,7 @@ extern crate getopts;\n #[macro_use]\n extern crate log;\n \n-use std::os;\n+use std::env;\n use std::old_io;\n use std::old_io::fs;\n use std::thunk::Thunk;\n@@ -48,7 +49,7 @@ pub mod common;\n pub mod errors;\n \n pub fn main() {\n-    let args = os::args();\n+    let args = env::args().map(|s| s.into_string().unwrap()).collect();;\n     let config = parse_config(args);\n \n     if config.valgrind_path.is_none() && config.force_valgrind {\n@@ -224,15 +225,15 @@ pub fn run_tests(config: &Config) {\n         //arm-linux-androideabi debug-info test uses remote debugger\n         //so, we test 1 task at once.\n         // also trying to isolate problems with adb_run_wrapper.sh ilooping\n-        os::setenv(\"RUST_TEST_TASKS\",\"1\");\n+        env::set_var(\"RUST_TEST_TASKS\",\"1\");\n     }\n \n     match config.mode {\n         DebugInfoLldb => {\n             // Some older versions of LLDB seem to have problems with multiple\n             // instances running in parallel, so only run one test task at a\n             // time.\n-            os::setenv(\"RUST_TEST_TASKS\", \"1\");\n+            env::set_var(\"RUST_TEST_TASKS\", \"1\");\n         }\n         _ => { /* proceed */ }\n     }\n@@ -245,7 +246,7 @@ pub fn run_tests(config: &Config) {\n     old_io::test::raise_fd_limit();\n     // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n     // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n-    os::setenv(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n+    env::set_var(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n     let res = test::run_tests_console(&opts, tests.into_iter().collect());\n     match res {\n         Ok(true) => {}\n@@ -276,7 +277,7 @@ pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n            config.src_base.display());\n     let mut tests = Vec::new();\n     let dirs = fs::readdir(&config.src_base).unwrap();\n-    for file in dirs.iter() {\n+    for file in &dirs {\n         let file = file.clone();\n         debug!(\"inspecting file {:?}\", file.display());\n         if is_test(config, &file) {\n@@ -304,13 +305,13 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n \n     let mut valid = false;\n \n-    for ext in valid_extensions.iter() {\n+    for ext in &valid_extensions {\n         if name.ends_with(ext.as_slice()) {\n             valid = true;\n         }\n     }\n \n-    for pre in invalid_prefixes.iter() {\n+    for pre in &invalid_prefixes {\n         if name.starts_with(pre.as_slice()) {\n             valid = false;\n         }"}, {"sha": "4b0eea33d69b7a2176cd0c0c86d1480f43409c48", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -40,13 +40,13 @@ pub fn run(lib_path: &str,\n     let mut cmd = Command::new(prog);\n     cmd.args(args);\n     add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env.into_iter() {\n+    for (key, val) in env {\n         cmd.env(key, val);\n     }\n \n     match cmd.spawn() {\n         Ok(mut process) => {\n-            for input in input.iter() {\n+            if let Some(input) = input {\n                 process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n             let ProcessOutput { status, output, error } =\n@@ -72,13 +72,13 @@ pub fn run_background(lib_path: &str,\n     let mut cmd = Command::new(prog);\n     cmd.args(args);\n     add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env.into_iter() {\n+    for (key, val) in env {\n         cmd.env(key, val);\n     }\n \n     match cmd.spawn() {\n         Ok(mut process) => {\n-            for input in input.iter() {\n+            if let Some(input) = input {\n                 process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n "}, {"sha": "5bb0a4031ead5cac3844a717e8db5fd9e3793a0e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -31,7 +31,7 @@ use std::old_io::process::ProcessExit;\n use std::old_io::process;\n use std::old_io::timer;\n use std::old_io;\n-use std::os;\n+use std::env;\n use std::iter::repeat;\n use std::str;\n use std::string::String;\n@@ -547,7 +547,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                          exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))[]);\n \n             // Add line breakpoints\n-            for line in breakpoint_lines.iter() {\n+            for line in &breakpoint_lines {\n                 script_str.push_str(&format!(\"break '{}':{}\\n\",\n                                              testfile.filename_display(),\n                                              *line)[]);\n@@ -683,13 +683,13 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     script_str.push_str(\"type category enable Rust\\n\");\n \n     // Set breakpoints on every line that contains the string \"#break\"\n-    for line in breakpoint_lines.iter() {\n+    for line in &breakpoint_lines {\n         script_str.push_str(format!(\"breakpoint set --line {}\\n\",\n                                     line).as_slice());\n     }\n \n     // Append the other commands\n-    for line in commands.iter() {\n+    for line in &commands {\n         script_str.push_str(line.as_slice());\n         script_str.push_str(\"\\n\");\n     }\n@@ -847,7 +847,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             let mut rest = line.trim();\n             let mut first = true;\n             let mut failed = false;\n-            for frag in check_fragments[i].iter() {\n+            for frag in &check_fragments[i] {\n                 let found = if first {\n                     if rest.starts_with(frag.as_slice()) {\n                         Some(0)\n@@ -915,7 +915,7 @@ fn check_error_patterns(props: &TestProps,\n                               missing_patterns[0]).as_slice(),\n                       proc_res);\n     } else {\n-        for pattern in missing_patterns.iter() {\n+        for pattern in missing_patterns {\n             error(format!(\"error pattern '{}' not found!\",\n                           *pattern).as_slice());\n         }\n@@ -935,7 +935,7 @@ fn check_no_compiler_crash(proc_res: &ProcRes) {\n fn check_forbid_output(props: &TestProps,\n                        output_to_check: &str,\n                        proc_res: &ProcRes) {\n-    for pat in props.forbid_output.iter() {\n+    for pat in &props.forbid_output {\n         if output_to_check.contains(pat.as_slice()) {\n             fatal_proc_rec(\"forbidden pattern found in compiler output\", proc_res);\n         }\n@@ -1173,7 +1173,7 @@ fn compose_and_run_compiler(\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let extra_link_args = vec!(\"-L\".to_string(), aux_dir.as_str().unwrap().to_string());\n \n-    for rel_ab in props.aux_builds.iter() {\n+    for rel_ab in &props.aux_builds {\n         let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_props = header::load_props(&abs_ab);\n         let mut crate_type = if aux_props.no_prefer_dynamic {\n@@ -1298,9 +1298,9 @@ fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> Path {\n \n fn make_exe_name(config: &Config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    if !os::consts::EXE_SUFFIX.is_empty() {\n+    if !env::consts::EXE_SUFFIX.is_empty() {\n         let mut fname = f.filename().unwrap().to_vec();\n-        fname.extend(os::consts::EXE_SUFFIX.bytes());\n+        fname.extend(env::consts::EXE_SUFFIX.bytes());\n         f.set_filename(fname);\n     }\n     f\n@@ -1503,14 +1503,14 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     // run test via adb_run_wrapper\n     runargs.push(\"shell\".to_string());\n-    for (key, val) in env.into_iter() {\n+    for (key, val) in env {\n         runargs.push(format!(\"{}={}\", key, val));\n     }\n     runargs.push(format!(\"{}/adb_run_wrapper.sh\", config.adb_test_dir));\n     runargs.push(format!(\"{}\", config.adb_test_dir));\n     runargs.push(format!(\"{}\", prog_short));\n \n-    for tv in args.args.iter() {\n+    for tv in &args.args {\n         runargs.push(tv.to_string());\n     }\n     procsrv::run(\"\",\n@@ -1591,7 +1591,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n     let tdir = aux_output_dir_name(config, testfile);\n \n     let dirs = fs::readdir(&tdir).unwrap();\n-    for file in dirs.iter() {\n+    for file in &dirs {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let copy_result = procsrv::run(\"\","}, {"sha": "078eb7bba20a45924d5841f1a7d07c84c7640892", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,7 +11,7 @@\n use common::Config;\n \n #[cfg(target_os = \"windows\")]\n-use std::os::getenv;\n+use std::env;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n static OS_TABLE: &'static [(&'static str, &'static str)] = &[\n@@ -23,10 +23,11 @@ static OS_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"linux\", \"linux\"),\n     (\"freebsd\", \"freebsd\"),\n     (\"dragonfly\", \"dragonfly\"),\n+    (\"openbsd\", \"openbsd\"),\n ];\n \n pub fn get_os(triple: &str) -> &'static str {\n-    for &(triple_os, os) in OS_TABLE.iter() {\n+    for &(triple_os, os) in OS_TABLE {\n         if triple.contains(triple_os) {\n             return os\n         }\n@@ -39,11 +40,11 @@ pub fn make_new_path(path: &str) -> String {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n-    match getenv(lib_path_env_var()) {\n-      Some(curr) => {\n+    match env::var_string(lib_path_env_var()) {\n+      Ok(curr) => {\n         format!(\"{}{}{}\", path, path_div(), curr)\n       }\n-      None => path.to_string()\n+      Err(..) => path.to_string()\n     }\n }\n "}, {"sha": "59a1c8f828b297bdd2cb324bf41ff187b98a20ad", "filename": "src/doc/grammar.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -196,8 +196,7 @@ raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n common_escape : '\\x5c'\n               | 'n' | 'r' | 't' | '0'\n               | 'x' hex_digit 2\n-unicode_escape : 'u' hex_digit 4\n-               | 'U' hex_digit 8 ;\n+unicode_escape : 'u' '{' hex_digit+ 6 '}';\n \n hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n           | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'"}, {"sha": "64ddb3ffdd39ffa5fbe1e706f26e99d5ccd8db0c", "filename": "src/doc/reference.md", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -250,8 +250,7 @@ cases mentioned in [Number literals](#number-literals) below.\n ##### Unicode escapes\n |   | Name |\n |---|------|\n-| `\\u7FFF` | 16-bit character code (exactly 4 digits) |\n-| `\\U7EEEFFFF` | 32-bit character code (exactly 8 digits) |\n+| `\\u{7FFF}` | 24-bit Unicode character code (up to 6 digits) |\n \n ##### Numbers\n \n@@ -286,8 +285,8 @@ raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n common_escape : '\\x5c'\n               | 'n' | 'r' | 't' | '0'\n               | 'x' hex_digit 2\n-unicode_escape : 'u' hex_digit 4\n-               | 'U' hex_digit 8 ;\n+\n+unicode_escape : 'u' '{' hex_digit+ 6 '}';\n \n hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n           | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n@@ -320,12 +319,9 @@ following forms:\n * An _8-bit codepoint escape_ escape starts with `U+0078` (`x`) and is\n   followed by exactly two _hex digits_. It denotes the Unicode codepoint\n   equal to the provided hex value.\n-* A _16-bit codepoint escape_ starts with `U+0075` (`u`) and is followed\n-  by exactly four _hex digits_. It denotes the Unicode codepoint equal to\n-  the provided hex value.\n-* A _32-bit codepoint escape_ starts with `U+0055` (`U`) and is followed\n-  by exactly eight _hex digits_. It denotes the Unicode codepoint equal to\n-  the provided hex value.\n+* A _24-bit codepoint escape_ starts with `U+0075` (`u`) and is followed\n+  by up to six _hex digits_ surrounded by braces `U+007B` (`{`) and `U+007D`\n+  (`}`). It denotes the Unicode codepoint equal to the provided hex value.\n * A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`\n   (`r`), or `U+0074` (`t`), denoting the unicode values `U+000A` (LF),\n   `U+000D` (CR) or `U+0009` (HT) respectively.\n@@ -1063,7 +1059,7 @@ mod foo {\n     extern crate core;\n \n     use foo::core::iter; // good: foo is at crate root\n-//  use core::iter;      // bad:  native is not at the crate root\n+//  use core::iter;      // bad:  core is not at the crate root\n     use self::baz::foobaz;  // good: self refers to module 'foo'\n     use foo::bar::foobar;   // good: foo is at crate root\n \n@@ -2197,7 +2193,8 @@ The following configurations must be defined by the implementation:\n   `\"unix\"` or `\"windows\"`. The value of this configuration option is defined\n   as a configuration itself, like `unix` or `windows`.\n * `target_os = \"...\"`. Operating system of the target, examples include\n-  `\"win32\"`, `\"macos\"`, `\"linux\"`, `\"android\"`, `\"freebsd\"` or `\"dragonfly\"`.\n+  `\"win32\"`, `\"macos\"`, `\"linux\"`, `\"android\"`, `\"freebsd\"`, `\"dragonfly\"` or\n+  `\"openbsd\"`.\n * `target_word_size = \"...\"`. Target word size in bits. This is set to `\"32\"`\n   for targets with 32-bit pointers, and likewise set to `\"64\"` for 64-bit\n   pointers."}, {"sha": "66670c7c631cd972639aab3a174038b8a0871dcb", "filename": "src/doc/trpl/comments.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Ftrpl%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Ftrpl%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcomments.md?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -43,5 +43,5 @@ When writing doc comments, adding sections for any arguments, return values,\n and providing some examples of usage is very, very helpful. Don't worry about\n the `&str`, we'll get to it soon.\n \n-You can use the [`rustdoc`](../rustdoc.html) tool to generate HTML documentation\n+You can use the [`rustdoc`](documentation.html) tool to generate HTML documentation\n from these doc comments."}, {"sha": "8ebebc98baf6b6d6bd4bb1f549e1400d33734d58", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -36,7 +36,7 @@ s.push_str(\", world.\");\n println!(\"{}\", s);\n ```\n \n-`String`s will coerece into `&str` with an `&`:\n+`String`s will coerce into `&str` with an `&`:\n \n ```\n fn takes_slice(slice: &str) {"}, {"sha": "9c46c8724d4978f2bc5e960f0f0d1e1981c29599", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -552,9 +552,7 @@ extern crate test;\n # struct X;\n # impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n b.iter(|| {\n-    let mut n = 1000_u32;\n-\n-    test::black_box(&mut n); // pretend to modify `n`\n+    let n = test::black_box(1000);\n \n     range(0, n).fold(0, |a, b| a ^ b)\n })\n@@ -569,7 +567,7 @@ Performing either of the above changes gives the following benchmarking results\n \n ```text\n running 1 test\n-test bench_xor_1000_ints ... bench:       1 ns/iter (+/- 0)\n+test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n ```"}, {"sha": "b506aff94e7209372ba7197874cef1109fec0a21", "filename": "src/etc/local_stage0.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fetc%2Flocal_stage0.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fetc%2Flocal_stage0.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flocal_stage0.sh?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,5 +1,5 @@\n #!/bin/sh\n-# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n #\n@@ -18,7 +18,7 @@ LIB_PREFIX=lib\n \n OS=`uname -s`\n case $OS in\n-    (\"Linux\"|\"FreeBSD\"|\"DragonFly\")\n+    (\"Linux\"|\"FreeBSD\"|\"DragonFly\"|\"OpenBSD\")\n     BIN_SUF=\n     LIB_SUF=.so\n     ;;"}, {"sha": "defda27acc9ec663adc816983504002be17c7f55", "filename": "src/etc/make-win-dist.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fetc%2Fmake-win-dist.py", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fetc%2Fmake-win-dist.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmake-win-dist.py?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -87,6 +87,7 @@ def make_win_dist(rust_root, gcc_root, target_triple):\n                     \"libsetupapi.a\",\n                     \"libshell32.a\",\n                     \"libuser32.a\",\n+                    \"libuserenv.a\",\n                     \"libuuid.a\",\n                     \"libwinhttp.a\",\n                     \"libwinmm.a\","}, {"sha": "264af5f9854cc81c5ec73306167840aab1187807", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-# Copyright 2011-2014 The Rust Project Developers. See the COPYRIGHT\n+# Copyright 2011-2015 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n #\n@@ -46,6 +46,7 @@ def scrub(b):\n         \"winnt\": [\"bin/rustc.exe\"],\n         \"freebsd\": [\"bin/rustc\"],\n         \"dragonfly\": [\"bin/rustc\"],\n+        \"openbsd\": [\"bin/rustc\"],\n         }\n \n winnt_runtime_deps_32 = [\"libgcc_s_dw2-1.dll\", \"libstdc++-6.dll\"]\n@@ -100,6 +101,8 @@ def get_kernel(triple):\n         return \"freebsd\"\n     if os_name == \"dragonfly\":\n         return \"dragonfly\"\n+    if os_name == \"openbsd\":\n+        return \"openbsd\"\n     return \"linux\"\n \n "}, {"sha": "0ff6cf7b79a359be37a4964de1252707efe462e3", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -127,7 +127,7 @@ impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&*self.head.borrow());\n-            for chunk in self.chunks.borrow().iter() {\n+            for chunk in &*self.chunks.borrow() {\n                 if !chunk.is_copy.get() {\n                     destroy_chunk(chunk);\n                 }"}, {"sha": "14a9fd4f452793a1a5ffb1607fc8f00fc3a9aa40", "filename": "src/libbacktrace/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -9332,7 +9332,7 @@ if test -z \"$aix_libpath\"; then aix_libpath=\"/usr/lib:/lib\"; fi\n       ;;\n \n     # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n-    freebsd* | dragonfly*)\n+    freebsd* | dragonfly* | openbsd*)\n       archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'\n       hardcode_libdir_flag_spec='-R$libdir'\n       hardcode_direct=yes"}, {"sha": "9301bf5e4ab47c701a57ef29f3a91fbbc868c10e", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -73,7 +73,7 @@ pub fn find_rand_n<M, T, I, F>(n: uint,\n     let mut keys = (0..n).map(|_| rng.gen::<uint>() % n)\n                               .collect::<Vec<_>>();\n \n-    for k in keys.iter() {\n+    for k in &keys {\n         insert(map, *k);\n     }\n "}, {"sha": "b51ec13335e0eb721ef52d8a73f5d90e0ab5cb0b", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -673,7 +673,7 @@ impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n-    fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n+    fn extend<Iter: Iterator<Item=T>>(&mut self, iter: Iter) {\n         let (lower, _) = iter.size_hint();\n \n         self.reserve(lower);\n@@ -696,7 +696,7 @@ mod tests {\n         let iterout = [9, 5, 3];\n         let heap = BinaryHeap::from_vec(data);\n         let mut i = 0;\n-        for el in heap.iter() {\n+        for el in &heap {\n             assert_eq!(*el, iterout[i]);\n             i += 1;\n         }\n@@ -884,7 +884,7 @@ mod tests {\n \n         let mut q: BinaryHeap<uint> = xs.iter().rev().map(|&x| x).collect();\n \n-        for &x in xs.iter() {\n+        for &x in &xs {\n             assert_eq!(q.pop().unwrap(), x);\n         }\n     }"}, {"sha": "3e603f6ebaf86862703e047e0d2ccca269cdfb40", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -431,7 +431,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n-        for w in self.storage.iter_mut() { *w = !0u32; }\n+        for w in &mut self.storage { *w = !0u32; }\n         self.fix_last_block();\n     }\n \n@@ -451,7 +451,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n-        for w in self.storage.iter_mut() { *w = !*w; }\n+        for w in &mut self.storage { *w = !*w; }\n         self.fix_last_block();\n     }\n \n@@ -912,7 +912,7 @@ impl Bitv {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        for w in self.storage.iter_mut() { *w = 0u32; }\n+        for w in &mut self.storage { *w = 0u32; }\n     }\n }\n \n@@ -934,7 +934,7 @@ impl FromIterator<bool> for Bitv {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<bool> for Bitv {\n     #[inline]\n-    fn extend<I: Iterator<Item=bool>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=bool>>(&mut self, iterator: I) {\n         let (min, _) = iterator.size_hint();\n         self.reserve(min);\n         for element in iterator {\n@@ -976,7 +976,7 @@ impl Ord for Bitv {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        for bit in self.iter() {\n+        for bit in self {\n             try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n         }\n         Ok(())\n@@ -1141,7 +1141,7 @@ impl FromIterator<uint> for BitvSet {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<uint> for BitvSet {\n     #[inline]\n-    fn extend<I: Iterator<Item=uint>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=uint>>(&mut self, iterator: I) {\n         for i in iterator {\n             self.insert(i);\n         }\n@@ -1353,7 +1353,7 @@ impl BitvSet {\n         }\n \n         // virtually pad other with 0's for equal lengths\n-        let mut other_words = {\n+        let other_words = {\n             let (_, result) = match_words(self_bitv, other_bitv);\n             result\n         };\n@@ -1743,7 +1743,7 @@ impl fmt::Debug for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"BitvSet {{\"));\n         let mut first = true;\n-        for n in self.iter() {\n+        for n in self {\n             if !first {\n                 try!(write!(fmt, \", \"));\n             }\n@@ -1756,7 +1756,7 @@ impl fmt::Debug for BitvSet {\n \n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n     fn hash(&self, state: &mut S) {\n-        for pos in self.iter() {\n+        for pos in self {\n             pos.hash(state);\n         }\n     }\n@@ -2600,7 +2600,7 @@ mod bitv_bench {\n         b.iter(|| {\n             let mut sum = 0u;\n             for _ in 0u..10 {\n-                for pres in bitv.iter() {\n+                for pres in &bitv {\n                     sum += pres as uint;\n                 }\n             }\n@@ -2613,7 +2613,7 @@ mod bitv_bench {\n         let bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             let mut sum = 0u;\n-            for pres in bitv.iter() {\n+            for pres in &bitv {\n                 sum += pres as uint;\n             }\n             sum\n@@ -2674,8 +2674,8 @@ mod bitv_set_test {\n     fn test_bitv_set_frombitv_init() {\n         let bools = [true, false];\n         let lengths = [10, 64, 100];\n-        for &b in bools.iter() {\n-            for &l in lengths.iter() {\n+        for &b in &bools {\n+            for &l in &lengths {\n                 let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n                 assert_eq!(bitset.contains(&1u), b);\n                 assert_eq!(bitset.contains(&(l-1u)), b);\n@@ -3062,7 +3062,7 @@ mod bitv_set_bench {\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n             let mut sum = 0u;\n-            for idx in bitv.iter() {\n+            for idx in &bitv {\n                 sum += idx as uint;\n             }\n             sum"}, {"sha": "99ee5957913dc5659e21c07f7bfb9c703d4c8886", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -116,13 +116,13 @@ pub struct IntoIter<K, V> {\n /// An iterator over a BTreeMap's keys.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n /// An iterator over a sub-range of BTreeMap's entries.\n@@ -197,7 +197,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n-        for _ in mem::replace(self, BTreeMap::with_b(b)).into_iter() {};\n+        for _ in mem::replace(self, BTreeMap::with_b(b)) {};\n     }\n \n     // Searching in a B-Tree is pretty straightforward.\n@@ -846,7 +846,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n-    fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n+    fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -856,7 +856,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n         }\n     }\n@@ -1946,7 +1946,7 @@ mod bench {\n         }\n \n         b.iter(|| {\n-            for entry in map.iter() {\n+            for entry in &map {\n                 black_box(entry);\n             }\n         });"}, {"sha": "8fdfe9ed56a4882014fdcce5f8e1dea865bbbaa1", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -435,13 +435,13 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n             let mut vals = RawItems::from_parts(ret.vals().as_ptr(), 0);\n             let mut edges = RawItems::from_parts(ret.edges().as_ptr(), 0);\n \n-            for key in self.keys().iter() {\n+            for key in self.keys() {\n                 keys.push(key.clone())\n             }\n-            for val in self.vals().iter() {\n+            for val in self.vals() {\n                 vals.push(val.clone())\n             }\n-            for edge in self.edges().iter() {\n+            for edge in self.edges() {\n                 edges.push(edge.clone())\n             }\n "}, {"sha": "1997fe189be44d21baed70551e5bfb7f9ba14764", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -45,40 +45,40 @@ pub struct Iter<'a, T: 'a> {\n /// An owning iterator over a BTreeSet's items.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n+    iter: Map<::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n \n /// An iterator over a sub-range of BTreeSet's items.\n pub struct Range<'a, T: 'a> {\n-    iter: Map<(&'a T, &'a ()), &'a T, ::btree_map::Range<'a, T, ()>, fn((&'a T, &'a ())) -> &'a T>\n+    iter: Map<::btree_map::Range<'a, T, ()>, fn((&'a T, &'a ())) -> &'a T>\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T:'a> {\n-    a: Peekable<&'a T, Iter<'a, T>>,\n-    b: Peekable<&'a T, Iter<'a, T>>,\n+    a: Peekable<Iter<'a, T>>,\n+    b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T:'a> {\n-    a: Peekable<&'a T, Iter<'a, T>>,\n-    b: Peekable<&'a T, Iter<'a, T>>,\n+    a: Peekable<Iter<'a, T>>,\n+    b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T:'a> {\n-    a: Peekable<&'a T, Iter<'a, T>>,\n-    b: Peekable<&'a T, Iter<'a, T>>,\n+    a: Peekable<Iter<'a, T>>,\n+    b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T:'a> {\n-    a: Peekable<&'a T, Iter<'a, T>>,\n-    b: Peekable<&'a T, Iter<'a, T>>,\n+    a: Peekable<Iter<'a, T>>,\n+    b: Peekable<Iter<'a, T>>,\n }\n \n impl<T: Ord> BTreeSet<T> {\n@@ -499,7 +499,7 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n-    fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n+    fn extend<Iter: Iterator<Item=T>>(&mut self, iter: Iter) {\n         for elem in iter {\n             self.insert(elem);\n         }\n@@ -791,8 +791,8 @@ mod test {\n         let mut set_a = BTreeSet::new();\n         let mut set_b = BTreeSet::new();\n \n-        for x in a.iter() { assert!(set_a.insert(*x)) }\n-        for y in b.iter() { assert!(set_b.insert(*y)) }\n+        for x in a { assert!(set_a.insert(*x)) }\n+        for y in b { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n         f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n@@ -894,7 +894,7 @@ mod test {\n \n         let set: BTreeSet<int> = xs.iter().map(|&x| x).collect();\n \n-        for x in xs.iter() {\n+        for x in &xs {\n             assert!(set.contains(x));\n         }\n     }"}, {"sha": "d85e9ee32265e134fcfc9f2858b2eca5baecf26c", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -856,7 +856,7 @@ impl<'a, T> IntoIterator for &'a mut DList<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for DList<A> {\n-    fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n+    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n         for elt in iterator { self.push_back(elt); }\n     }\n }\n@@ -917,7 +917,7 @@ impl<A: fmt::Debug> fmt::Debug for DList<A> {\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n         }\n     }\n@@ -1061,7 +1061,7 @@ mod tests {\n         let mut sum = v;\n         sum.push_all(u.as_slice());\n         assert_eq!(sum.len(), m.len());\n-        for elt in sum.into_iter() {\n+        for elt in sum {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n         assert_eq!(n.len(), 0);"}, {"sha": "8cbf50d29f23b02ebe9347b89c83dd619499e653", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -36,7 +36,7 @@ impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"EnumSet {{\"));\n         let mut first = true;\n-        for e in self.iter() {\n+        for e in self {\n             if !first {\n                 try!(write!(fmt, \", \"));\n             }\n@@ -266,7 +266,7 @@ impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n }\n \n impl<E:CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: Iterator<Item=E>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=E>>(&mut self, iterator: I) {\n         for element in iterator {\n             self.insert(element);\n         }"}, {"sha": "102dfb3df9d0319b4e221ca4863bb07c49cfc618", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -22,8 +22,6 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n-\n #![feature(alloc)]\n #![feature(box_syntax)]\n #![feature(core)]"}, {"sha": "18021dea9f29ed5f118208d9b948a5a1431b4cac", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1573,7 +1573,7 @@ impl<A: Ord> Ord for RingBuf<A> {\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n         }\n     }\n@@ -1635,7 +1635,7 @@ impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for RingBuf<A> {\n-    fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n+    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n         for elt in iterator {\n             self.push_back(elt);\n         }\n@@ -1856,7 +1856,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut sum = 0;\n-            for &i in ring.iter() {\n+            for &i in &ring {\n                 sum += i;\n             }\n             test::black_box(sum);\n@@ -1869,7 +1869,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut sum = 0;\n-            for i in ring.iter_mut() {\n+            for i in &mut ring {\n                 sum += *i;\n             }\n             test::black_box(sum);"}, {"sha": "4b4ea3e4c3ca539729dc22c657aabc7be7221a67", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -98,9 +98,6 @@ use core::iter::{range_step, MultiplicativeIterator};\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n-#[cfg(stage0)]\n-use core::ops::{FnMut, FullRange};\n-#[cfg(not(stage0))]\n use core::ops::FnMut;\n use core::option::Option::{self, Some, None};\n use core::ptr::PtrExt;\n@@ -1121,7 +1118,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n     fn concat(&self) -> Vec<T> {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size);\n-        for v in self.iter() {\n+        for v in self {\n             result.push_all(v.as_slice())\n         }\n         result\n@@ -1131,7 +1128,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n-        for v in self.iter() {\n+        for v in self {\n             if first { first = false } else { result.push(sep.clone()) }\n             result.push_all(v.as_slice())\n         }\n@@ -1231,7 +1228,7 @@ impl Iterator for ElementSwaps {\n                 self.sdir.swap(i, j);\n \n                 // Swap the direction of each larger SizeDirection\n-                for x in self.sdir.iter_mut() {\n+                for x in &mut self.sdir {\n                     if x.size > sd.size {\n                         x.dir = match x.dir { Pos => Neg, Neg => Pos };\n                     }\n@@ -1512,9 +1509,6 @@ mod tests {\n     use core::prelude::{Some, None, range, Clone};\n     use core::prelude::{Iterator, IteratorExt};\n     use core::prelude::{AsSlice};\n-    #[cfg(stage0)]\n-    use core::prelude::{Ord, FullRange};\n-    #[cfg(not(stage0))]\n     use core::prelude::Ord;\n     use core::default::Default;\n     use core::mem;\n@@ -2362,7 +2356,7 @@ mod tests {\n     #[test]\n     fn test_mut_iterator() {\n         let mut xs = [1, 2, 3, 4, 5];\n-        for x in xs.iter_mut() {\n+        for x in &mut xs {\n             *x += 1;\n         }\n         assert!(xs == [2, 3, 4, 5, 6])\n@@ -2662,15 +2656,15 @@ mod tests {\n                 let left: &[_] = left;\n                 assert!(left[..left.len()] == [1, 2][]);\n             }\n-            for p in left.iter_mut() {\n+            for p in left {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n                 assert!(right[..right.len()] == [3, 4, 5][]);\n             }\n-            for p in right.iter_mut() {\n+            for p in right {\n                 *p += 2;\n             }\n         }\n@@ -2687,33 +2681,33 @@ mod tests {\n         assert_eq!(v.len(), 3);\n         let mut cnt = 0u;\n \n-        for f in v.iter() {\n+        for f in &v {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v[1..3].iter() {\n+        for f in &v[1..3] {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 5);\n \n-        for f in v.iter_mut() {\n+        for f in &mut v {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 8);\n \n-        for f in v.into_iter() {\n+        for f in v {\n             assert!(f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 11);\n \n         let xs: [Foo; 3] = [Foo, Foo, Foo];\n         cnt = 0;\n-        for f in xs.iter() {\n+        for f in &xs {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n@@ -2802,7 +2796,7 @@ mod tests {\n         let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n         assert_eq!(v.chunks_mut(2).len(), 4);\n         for (i, chunk) in v.chunks_mut(3).enumerate() {\n-            for x in chunk.iter_mut() {\n+            for x in chunk {\n                 *x = i as u8;\n             }\n         }\n@@ -2814,7 +2808,7 @@ mod tests {\n     fn test_mut_chunks_rev() {\n         let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n         for (i, chunk) in v.chunks_mut(3).rev().enumerate() {\n-            for x in chunk.iter_mut() {\n+            for x in chunk {\n                 *x = i as u8;\n             }\n         }\n@@ -2864,7 +2858,7 @@ mod bench {\n \n         b.iter(|| {\n             let mut sum = 0;\n-            for x in v.iter() {\n+            for x in &v {\n                 sum += *x;\n             }\n             // sum == 11806, to stop dead code elimination.\n@@ -2878,7 +2872,7 @@ mod bench {\n \n         b.iter(|| {\n             let mut i = 0;\n-            for x in v.iter_mut() {\n+            for x in &mut v {\n                 *x = i;\n                 i += 1;\n             }\n@@ -3012,7 +3006,7 @@ mod bench {\n             unsafe {\n                 v.set_len(1024);\n             }\n-            for x in v.iter_mut() {\n+            for x in &mut v {\n                 *x = 0;\n             }\n             v"}, {"sha": "75f7b812974d703daba644a855e53b9721e4b206", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -61,11 +61,6 @@ use core::clone::Clone;\n use core::iter::AdditiveIterator;\n use core::iter::{Iterator, IteratorExt};\n use core::ops::Index;\n-#[cfg(stage0)]\n-use core::ops::FullRange as RangeFull;\n-#[cfg(stage0)]\n-use core::ops::FullRange;\n-#[cfg(not(stage0))]\n use core::ops::RangeFull;\n use core::option::Option::{self, Some, None};\n use core::result::Result;\n@@ -104,7 +99,7 @@ impl<S: Str> SliceConcatExt<str, String> for [S] {\n         let len = s.iter().map(|s| s.as_slice().len()).sum();\n         let mut result = String::with_capacity(len);\n \n-        for s in s.iter() {\n+        for s in s {\n             result.push_str(s.as_slice())\n         }\n \n@@ -130,7 +125,7 @@ impl<S: Str> SliceConcatExt<str, String> for [S] {\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n-        for s in s.iter() {\n+        for s in s {\n             if first {\n                 first = false;\n             } else {\n@@ -2010,7 +2005,7 @@ mod tests {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n-        for ch in v.iter() {\n+        for ch in &v {\n             assert!(s.char_at(pos) == *ch);\n             pos += ch.to_string().len();\n         }\n@@ -2708,7 +2703,7 @@ mod tests {\n             &[\"\\u{378}\\u{308}\\u{903}\"], &[\"\\u{378}\\u{308}\", \"\\u{903}\"]),\n         ];\n \n-        for &(s, g) in test_same.iter() {\n+        for &(s, g) in &test_same[] {\n             // test forward iterator\n             assert!(order::equals(s.graphemes(true), g.iter().map(|&x| x)));\n             assert!(order::equals(s.graphemes(false), g.iter().map(|&x| x)));\n@@ -2718,7 +2713,7 @@ mod tests {\n             assert!(order::equals(s.graphemes(false).rev(), g.iter().rev().map(|&x| x)));\n         }\n \n-        for &(s, gt, gf) in test_diff.iter() {\n+        for &(s, gt, gf) in &test_diff {\n             // test forward iterator\n             assert!(order::equals(s.graphemes(true), gt.iter().map(|&x| x)));\n             assert!(order::equals(s.graphemes(false), gf.iter().map(|&x| x)));"}, {"sha": "554eee765f3eb5efc4a792ed6162b7c06cea5403", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -729,7 +729,7 @@ impl<'a> FromIterator<&'a str> for String {\n #[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl Extend<char> for String {\n-    fn extend<I:Iterator<Item=char>>(&mut self, mut iterator: I) {\n+    fn extend<I:Iterator<Item=char>>(&mut self, iterator: I) {\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n         for ch in iterator {\n@@ -741,7 +741,7 @@ impl Extend<char> for String {\n #[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl<'a> Extend<&'a str> for String {\n-    fn extend<I: Iterator<Item=&'a str>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=&'a str>>(&mut self, iterator: I) {\n         // A guess that at least one byte per iterator element will be needed.\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n@@ -877,16 +877,6 @@ impl ops::Index<ops::RangeFrom<uint>> for String {\n         &self[][*index]\n     }\n }\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::FullRange> for String {\n-    type Output = str;\n-    #[inline]\n-    fn index(&self, _index: &ops::FullRange) -> &str {\n-        unsafe { mem::transmute(self.vec.as_slice()) }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for String {\n     type Output = str;\n@@ -1011,8 +1001,6 @@ mod tests {\n     use str::Utf8Error;\n     use core::iter::repeat;\n     use super::{as_string, CowString};\n-    #[cfg(stage0)]\n-    use core::ops::FullRange;\n \n     #[test]\n     fn test_as_string() {\n@@ -1130,7 +1118,7 @@ mod tests {\n              (String::from_str(\"\\u{20000}\"),\n               vec![0xD840, 0xDC00])];\n \n-        for p in pairs.iter() {\n+        for p in &pairs {\n             let (s, u) = (*p).clone();\n             let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n             let u_as_string = String::from_utf16(u.as_slice()).unwrap();"}, {"sha": "e9ddfd4872f7e3671c77dd1bc1aabbb879ae4412", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1318,16 +1318,6 @@ impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n         self.as_slice().index(index)\n     }\n }\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::FullRange> for Vec<T> {\n-    type Output = [T];\n-    #[inline]\n-    fn index(&self, _index: &ops::FullRange) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n@@ -1361,16 +1351,6 @@ impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n-    type Output = [T];\n-    #[inline]\n-    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n-        self.as_mut_slice()\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n@@ -1395,7 +1375,7 @@ impl<T> ops::DerefMut for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n-    fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n+    fn from_iter<I:Iterator<Item=T>>(iterator: I) -> Vec<T> {\n         let (lower, _) = iterator.size_hint();\n         let mut vector = Vec::with_capacity(lower);\n         for element in iterator {\n@@ -1432,7 +1412,7 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n #[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n-    fn extend<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=T>>(&mut self, iterator: I) {\n         let (lower, _) = iterator.size_hint();\n         self.reserve(lower);\n         for element in iterator {\n@@ -1567,7 +1547,7 @@ impl<T> Drop for Vec<T> {\n         // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n         if self.cap != 0 {\n             unsafe {\n-                for x in self.iter() {\n+                for x in &*self {\n                     ptr::read(x);\n                 }\n                 dealloc(*self.ptr, self.cap)\n@@ -1934,8 +1914,6 @@ mod tests {\n     use prelude::*;\n     use core::mem::size_of;\n     use core::iter::repeat;\n-    #[cfg(stage0)]\n-    use core::ops::FullRange;\n     use test::Bencher;\n     use super::as_vec;\n \n@@ -2044,7 +2022,7 @@ mod tests {\n         {\n             let slice = &mut values[2 ..];\n             assert!(slice == [3, 4, 5]);\n-            for p in slice.iter_mut() {\n+            for p in slice {\n                 *p += 2;\n             }\n         }\n@@ -2058,7 +2036,7 @@ mod tests {\n         {\n             let slice = &mut values[.. 2];\n             assert!(slice == [1, 2]);\n-            for p in slice.iter_mut() {\n+            for p in slice {\n                 *p += 1;\n             }\n         }\n@@ -2075,15 +2053,15 @@ mod tests {\n                 let left: &[_] = left;\n                 assert!(&left[..left.len()] == &[1, 2][]);\n             }\n-            for p in left.iter_mut() {\n+            for p in left {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n                 assert!(&right[..right.len()] == &[3, 4, 5][]);\n             }\n-            for p in right.iter_mut() {\n+            for p in right {\n                 *p += 2;\n             }\n         }\n@@ -2151,15 +2129,15 @@ mod tests {\n         v.push(());\n         assert_eq!(v.iter().count(), 2);\n \n-        for &() in v.iter() {}\n+        for &() in &v {}\n \n         assert_eq!(v.iter_mut().count(), 2);\n         v.push(());\n         assert_eq!(v.iter_mut().count(), 3);\n         v.push(());\n         assert_eq!(v.iter_mut().count(), 4);\n \n-        for &mut () in v.iter_mut() {}\n+        for &mut () in &mut v {}\n         unsafe { v.set_len(0); }\n         assert_eq!(v.iter_mut().count(), 0);\n     }\n@@ -2355,7 +2333,7 @@ mod tests {\n     fn test_move_items() {\n         let vec = vec![1, 2, 3];\n         let mut vec2 : Vec<i32> = vec![];\n-        for i in vec.into_iter() {\n+        for i in vec {\n             vec2.push(i);\n         }\n         assert!(vec2 == vec![1, 2, 3]);\n@@ -2375,7 +2353,7 @@ mod tests {\n     fn test_move_items_zero_sized() {\n         let vec = vec![(), (), ()];\n         let mut vec2 : Vec<()> = vec![];\n-        for i in vec.into_iter() {\n+        for i in vec {\n             vec2.push(i);\n         }\n         assert!(vec2 == vec![(), (), ()]);"}, {"sha": "c74c870eef5d5cfa707c8b8fa40488a5c40b4617", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -90,7 +90,7 @@ impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n         // In order to not traverse the `VecMap` twice, count the elements\n         // during iteration.\n         let mut count: uint = 0;\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n             count += 1;\n         }\n@@ -562,7 +562,7 @@ impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n-    fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) {\n+    fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, iter: Iter) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -687,7 +687,7 @@ double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n /// An iterator over the keys of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n+    iter: Map<Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -702,7 +702,7 @@ impl<'a, V> Clone for Keys<'a, V> {\n /// An iterator over the values of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n+    iter: Map<Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -718,17 +718,13 @@ impl<'a, V> Clone for Values<'a, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<V> {\n     iter: FilterMap<\n-    (uint, Option<V>),\n-    (uint, V),\n     Enumerate<vec::IntoIter<Option<V>>>,\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n #[unstable(feature = \"collections\")]\n pub struct Drain<'a, V> {\n     iter: FilterMap<\n-    (uint, Option<V>),\n-    (uint, V),\n     Enumerate<vec::Drain<'a, Option<V>>>,\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n@@ -924,7 +920,7 @@ mod test_map {\n         assert!(m.insert(6, 10).is_none());\n         assert!(m.insert(10, 11).is_none());\n \n-        for (k, v) in m.iter_mut() {\n+        for (k, v) in &mut m {\n             *v += k as int;\n         }\n \n@@ -984,7 +980,7 @@ mod test_map {\n         let mut m = VecMap::new();\n         m.insert(1, box 2);\n         let mut called = false;\n-        for (k, v) in m.into_iter() {\n+        for (k, v) in m {\n             assert!(!called);\n             called = true;\n             assert_eq!(k, 1);\n@@ -1112,7 +1108,7 @@ mod test_map {\n \n         let map: VecMap<char> = xs.iter().map(|&x| x).collect();\n \n-        for &(k, v) in xs.iter() {\n+        for &(k, v) in &xs {\n             assert_eq!(map.get(&k), Some(&v));\n         }\n     }"}, {"sha": "5c4567e567b0daa9f880559994473760a69bbc2b", "filename": "src/libcore/array.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -20,9 +20,6 @@ use fmt;\n use hash::{Hash, Hasher, self};\n use iter::IntoIterator;\n use marker::Copy;\n-#[cfg(stage0)]\n-use ops::{Deref, FullRange};\n-#[cfg(not(stage0))]\n use ops::Deref;\n use option::Option;\n use slice::{Iter, IterMut, SliceExt};"}, {"sha": "0f3823eb7a5b0df76d8e4d1933f4ac4da1a084a1", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -415,6 +415,7 @@ impl AtomicIsize {\n     /// let atomic_forty_two  = AtomicIsize::new(42);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(v: isize) -> AtomicIsize {\n         AtomicIsize {v: UnsafeCell::new(v)}\n     }\n@@ -437,6 +438,7 @@ impl AtomicIsize {\n     /// let value = some_isize.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> isize {\n         unsafe { atomic_load(self.v.get(), order) }\n     }\n@@ -459,6 +461,7 @@ impl AtomicIsize {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: isize, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n@@ -477,6 +480,7 @@ impl AtomicIsize {\n     /// let value = some_isize.swap(10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -498,6 +502,7 @@ impl AtomicIsize {\n     /// let value = some_isize.compare_and_swap(5, 10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -514,6 +519,7 @@ impl AtomicIsize {\n     /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_add(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -530,6 +536,7 @@ impl AtomicIsize {\n     /// assert_eq!(-10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -545,6 +552,7 @@ impl AtomicIsize {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_and(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -560,6 +568,7 @@ impl AtomicIsize {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_or(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -575,6 +584,7 @@ impl AtomicIsize {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n@@ -592,6 +602,7 @@ impl AtomicUsize {\n     /// let atomic_forty_two = AtomicUsize::new(42);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(v: usize) -> AtomicUsize {\n         AtomicUsize { v: UnsafeCell::new(v) }\n     }\n@@ -614,6 +625,7 @@ impl AtomicUsize {\n     /// let value = some_usize.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> usize {\n         unsafe { atomic_load(self.v.get(), order) }\n     }\n@@ -636,6 +648,7 @@ impl AtomicUsize {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: usize, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n@@ -654,6 +667,7 @@ impl AtomicUsize {\n     /// let value = some_usize.swap(10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -675,6 +689,7 @@ impl AtomicUsize {\n     /// let value = some_usize.compare_and_swap(5, 10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -691,6 +706,7 @@ impl AtomicUsize {\n     /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_add(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -707,6 +723,7 @@ impl AtomicUsize {\n     /// assert_eq!(0, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -722,6 +739,7 @@ impl AtomicUsize {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_and(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -737,6 +755,7 @@ impl AtomicUsize {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_or(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -752,6 +771,7 @@ impl AtomicUsize {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }"}, {"sha": "c82d8c531d243e9624fd60b85f9f95a726fbf67b", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -266,6 +266,18 @@ pub struct RefCell<T> {\n     borrow: Cell<BorrowFlag>,\n }\n \n+/// An enumeration of values returned from the `state` method on a `RefCell<T>`.\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[unstable(feature = \"std_misc\")]\n+pub enum BorrowState {\n+    /// The cell is currently being read, there is at least one active `borrow`.\n+    Reading,\n+    /// The cell is currently being written to, there is an active `borrow_mut`.\n+    Writing,\n+    /// There are no outstanding borrows on this cell.\n+    Unused,\n+}\n+\n // Values [1, MAX-1] represent the number of `Ref` active\n // (will not outgrow its range since `uint` is the size of the address space)\n type BorrowFlag = uint;\n@@ -310,13 +322,28 @@ impl<T> RefCell<T> {\n         unsafe { self.value.into_inner() }\n     }\n \n+    /// Query the current state of this `RefCell`\n+    ///\n+    /// The returned value can be dispatched on to determine if a call to\n+    /// `borrow` or `borrow_mut` would succeed.\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn borrow_state(&self) -> BorrowState {\n+        match self.borrow.get() {\n+            WRITING => BorrowState::Writing,\n+            UNUSED => BorrowState::Unused,\n+            _ => BorrowState::Reading,\n+        }\n+    }\n+\n     /// Attempts to immutably borrow the wrapped value.\n     ///\n     /// The borrow lasts until the returned `Ref` exits scope. Multiple\n     /// immutable borrows can be taken out at the same time.\n     ///\n     /// Returns `None` if the value is currently mutably borrowed.\n     #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"dispatch on `cell.borrow_state()` instead\")]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n@@ -326,8 +353,8 @@ impl<T> RefCell<T> {\n \n     /// Immutably borrows the wrapped value.\n     ///\n-    /// The borrow lasts until the returned `Ref` exits scope. Multiple immutable borrows can be\n-    /// taken out at the same time.\n+    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n+    /// immutable borrows can be taken out at the same time.\n     ///\n     /// # Panics\n     ///\n@@ -361,9 +388,12 @@ impl<T> RefCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n-        match self.try_borrow() {\n-            Some(ptr) => ptr,\n-            None => panic!(\"RefCell<T> already mutably borrowed\")\n+        match BorrowRef::new(&self.borrow) {\n+            Some(b) => Ref {\n+                _value: unsafe { &*self.value.get() },\n+                _borrow: b,\n+            },\n+            None => panic!(\"RefCell<T> already mutably borrowed\"),\n         }\n     }\n \n@@ -374,6 +404,8 @@ impl<T> RefCell<T> {\n     ///\n     /// Returns `None` if the value is currently borrowed.\n     #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"dispatch on `cell.borrow_state()` instead\")]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n@@ -383,8 +415,8 @@ impl<T> RefCell<T> {\n \n     /// Mutably borrows the wrapped value.\n     ///\n-    /// The borrow lasts until the returned `RefMut` exits scope. The value cannot be borrowed\n-    /// while this borrow is active.\n+    /// The borrow lasts until the returned `RefMut` exits scope. The value\n+    /// cannot be borrowed while this borrow is active.\n     ///\n     /// # Panics\n     ///\n@@ -417,9 +449,12 @@ impl<T> RefCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n-        match self.try_borrow_mut() {\n-            Some(ptr) => ptr,\n-            None => panic!(\"RefCell<T> already borrowed\")\n+        match BorrowRefMut::new(&self.borrow) {\n+            Some(b) => RefMut {\n+                _value: unsafe { &mut *self.value.get() },\n+                _borrow: b,\n+            },\n+            None => panic!(\"RefCell<T> already borrowed\"),\n         }\n     }\n "}, {"sha": "28e0247f00a2557ef1a6e28435b70d246db031aa", "filename": "src/libcore/char.rs", "status": "modified", "additions": 174, "deletions": 20, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -67,7 +67,25 @@ static MAX_THREE_B: u32 =  0x10000u32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: char = '\\u{10ffff}';\n \n-/// Converts from `u32` to a `char`\n+/// Converts a `u32` to an `Option<char>`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_u32(10084); // produces `Some(\u2764)`\n+/// assert_eq!(c, Some('\u2764'));\n+/// ```\n+///\n+/// An invalid character:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let none = char::from_u32(1114112);\n+/// assert_eq!(none, None);\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_u32(i: u32) -> Option<char> {\n@@ -79,8 +97,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n     }\n }\n \n-///\n-/// Converts a number to the character representing it\n+/// Converts a number to the character representing it.\n ///\n /// # Return value\n ///\n@@ -91,6 +108,15 @@ pub fn from_u32(i: u32) -> Option<char> {\n ///\n /// Panics if given an `radix` > 36.\n ///\n+/// # Examples\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_digit(4, 10);\n+///\n+/// assert_eq!(c, Some('4'));\n+/// ```\n #[inline]\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n@@ -126,6 +152,16 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert!(c.is_digit(10));\n+    ///\n+    /// assert!('f'.is_digit(16));\n+    /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool;\n@@ -141,16 +177,53 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert_eq!(c.to_digit(10), Some(1));\n+    ///\n+    /// assert_eq!('f'.to_digit(16), Some(15));\n+    /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint>;\n \n-    /// Returns an iterator that yields the hexadecimal Unicode escape\n-    /// of a character, as `char`s.\n+    /// Returns an iterator that yields the hexadecimal Unicode escape of a character, as `char`s.\n+    ///\n+    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}` where `NNNN` is the\n+    /// shortest hexadecimal representation of the code point.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\u2764'.escape_unicode() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n     ///\n-    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n-    /// where `NNNN` is the shortest hexadecimal representation of the code\n-    /// point.\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// u\n+    /// {\n+    /// 2\n+    /// 7\n+    /// 6\n+    /// 4\n+    /// }\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let heart: String = '\u2764'.escape_unicode().collect();\n+    ///\n+    /// assert_eq!(heart, r\"\\u{2764}\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode;\n \n@@ -166,32 +239,113 @@ pub trait CharExt {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\"'.escape_default() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// \"\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let quote: String = '\"'.escape_default().collect();\n+    ///\n+    /// assert_eq!(quote, \"\\\\\\\"\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault;\n \n-    /// Returns the amount of bytes this character would need if encoded in\n-    /// UTF-8.\n+    /// Returns the number of bytes this character would need if encoded in UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf8();\n+    ///\n+    /// assert_eq!(n, 2);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint;\n \n-    /// Returns the amount of bytes this character would need if encoded in\n-    /// UTF-16.\n+    /// Returns the number of bytes this character would need if encoded in UTF-16.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf16();\n+    ///\n+    /// assert_eq!(n, 1);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint;\n \n-    /// Encodes this character as UTF-8 into the provided byte buffer,\n-    /// and then returns the number of bytes written.\n+    /// Encodes this character as UTF-8 into the provided byte buffer, and then returns the number\n+    /// of bytes written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a `None` will be\n+    /// returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes two bytes to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 2];\n     ///\n-    /// If the buffer is not large enough, nothing will be written into it\n-    /// and a `None` will be returned.\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(2));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n \n-    /// Encodes this character as UTF-16 into the provided `u16` buffer,\n-    /// and then returns the number of `u16`s written.\n+    /// Encodes this character as UTF-16 into the provided `u16` buffer, and then returns the\n+    /// number of `u16`s written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a `None` will be\n+    /// returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes one byte to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf16(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(1));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 0];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n     ///\n-    /// If the buffer is not large enough, nothing will be written into it\n-    /// and a `None` will be returned.\n+    /// assert_eq!(result, None);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n }"}, {"sha": "551277bae5c6bd061bc29ba482ba27ee5af79379", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 59, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -13,7 +13,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use any;\n-use cell::{Cell, RefCell, Ref, RefMut};\n+use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n use char::CharExt;\n use iter::{Iterator, IteratorExt};\n use marker::{Copy, Sized};\n@@ -38,7 +38,6 @@ mod float;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(hidden)]\n pub mod rt {\n-    #[cfg(stage0)] pub use self::v1::*;\n     pub mod v1;\n }\n \n@@ -191,46 +190,13 @@ impl<'a> Arguments<'a> {\n         }\n     }\n \n-    /// When using the format_args!() macro, this function is used to generate the\n-    /// Arguments structure.\n-    #[doc(hidden)] #[inline]\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(pieces: &'a [&'a str],\n-               args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n-        Arguments {\n-            pieces: pieces,\n-            fmt: None,\n-            args: args\n-        }\n-    }\n-\n-    /// This function is used to specify nonstandard formatting parameters.\n-    /// The `pieces` array must be at least as long as `fmt` to construct\n-    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n-    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n-    /// created with `argumentuint`. However, failing to do so doesn't cause\n-    /// unsafety, but will ignore invalid .\n-    #[doc(hidden)] #[inline]\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_placeholders(pieces: &'a [&'a str],\n-                             fmt: &'a [rt::v1::Argument],\n-                             args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n-        Arguments {\n-            pieces: pieces,\n-            fmt: Some(fmt),\n-            args: args\n-        }\n-    }\n     /// This function is used to specify nonstandard formatting parameters.\n     /// The `pieces` array must be at least as long as `fmt` to construct\n     /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n     /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[cfg(not(stage0))]\n     pub fn new_v1_formatted(pieces: &'a [&'a str],\n                             args: &'a [ArgumentV1<'a>],\n                             fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n@@ -516,7 +482,7 @@ impl<'a> Formatter<'a> {\n \n         // Writes the sign if it exists, and then the prefix if it was requested\n         let write_prefix = |&: f: &mut Formatter| {\n-            for c in sign.into_iter() {\n+            if let Some(c) = sign {\n                 let mut b = [0; 4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);\n                 let b = unsafe { str::from_utf8_unchecked(&b[..n]) };\n@@ -684,25 +650,6 @@ impl Display for Error {\n     }\n }\n \n-/// This is a function which calls are emitted to by the compiler itself to\n-/// create the Argument structures that are passed into the `format` function.\n-#[doc(hidden)] #[inline]\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n-                       t: &'a T) -> ArgumentV1<'a> {\n-    ArgumentV1::new(t, f)\n-}\n-\n-/// When the compiler determines that the type of an argument *must* be a uint\n-/// (such as for width and precision), then it invokes this method.\n-#[doc(hidden)] #[inline]\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn argumentuint<'a>(s: &'a uint) -> ArgumentV1<'a> {\n-    ArgumentV1::from_uint(s)\n-}\n-\n // Implementations of the core formatting traits\n \n macro_rules! fmt_refs {\n@@ -941,7 +888,7 @@ impl<T: Debug> Debug for [T] {\n             try!(write!(f, \"[\"));\n         }\n         let mut is_first = true;\n-        for x in self.iter() {\n+        for x in self {\n             if is_first {\n                 is_first = false;\n             } else {\n@@ -973,9 +920,11 @@ impl<T: Copy + Debug> Debug for Cell<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        match self.try_borrow() {\n-            Some(val) => write!(f, \"RefCell {{ value: {:?} }}\", val),\n-            None => write!(f, \"RefCell {{ <borrowed> }}\")\n+        match self.borrow_state() {\n+            BorrowState::Unused | BorrowState::Reading => {\n+                write!(f, \"RefCell {{ value: {:?} }}\", self.borrow())\n+            }\n+            BorrowState::Writing => write!(f, \"RefCell {{ <borrowed> }}\"),\n         }\n     }\n }"}, {"sha": "0c9bb6316e0d805ecbcc08a05c1c6bb2fa67bc5e", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -16,19 +16,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[cfg(stage0)] pub use self::Position::*;\n-\n-#[cfg(stage0)] pub use self::Alignment::Left as AlignLeft;\n-#[cfg(stage0)] pub use self::Alignment::Right as AlignRight;\n-#[cfg(stage0)] pub use self::Alignment::Center as AlignCenter;\n-#[cfg(stage0)] pub use self::Alignment::Unknown as AlignUnknown;\n-#[cfg(stage0)] pub use self::Count::Is as CountIs;\n-#[cfg(stage0)] pub use self::Count::Implied as CountImplied;\n-#[cfg(stage0)] pub use self::Count::Param as CountIsParam;\n-#[cfg(stage0)] pub use self::Count::NextParam as CountIsNextParam;\n-#[cfg(stage0)] pub use self::Position::Next as ArgumentNext;\n-#[cfg(stage0)] pub use self::Position::At as ArgumentIs;\n-\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Argument {"}, {"sha": "d73e6ed589ff3bed1455121de3cc80a76ee8062e", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -205,7 +205,7 @@ impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n         }\n     }"}, {"sha": "d0734f9c0395faec4b2713420651137cf4a3e4ec", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 115, "deletions": 249, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -174,7 +174,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn last(mut self) -> Option<Self::Item> {\n+    fn last(self) -> Option<Self::Item> {\n         let mut last = None;\n         for x in self { last = Some(x); }\n         last\n@@ -239,9 +239,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn zip<B, U>(self, other: U) -> Zip<Self, U> where\n-        U: Iterator<Item=B>,\n-    {\n+    fn zip<U: Iterator>(self, other: U) -> Zip<Self, U> {\n         Zip{a: self, b: other}\n     }\n \n@@ -259,7 +257,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn map<B, F>(self, f: F) -> Map<Self::Item, B, Self, F> where\n+    fn map<B, F>(self, f: F) -> Map<Self, F> where\n         F: FnMut(Self::Item) -> B,\n     {\n         Map{iter: self, f: f}\n@@ -279,7 +277,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn filter<P>(self, predicate: P) -> Filter<Self::Item, Self, P> where\n+    fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n         Filter{iter: self, predicate: predicate}\n@@ -299,7 +297,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn filter_map<B, F>(self, f: F) -> FilterMap<Self::Item, B, Self, F> where\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n         FilterMap { iter: self, f: f }\n@@ -342,7 +340,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn peekable(self) -> Peekable<Self::Item, Self> {\n+    fn peekable(self) -> Peekable<Self> {\n         Peekable{iter: self, peeked: None}\n     }\n \n@@ -362,7 +360,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self::Item, Self, P> where\n+    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n@@ -383,7 +381,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn take_while<P>(self, predicate: P) -> TakeWhile<Self::Item, Self, P> where\n+    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n@@ -448,12 +446,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn scan<St, B, F>(\n-        self,\n-        initial_state: St,\n-        f: F,\n-    ) -> Scan<Self::Item, B, Self, St, F> where\n-        F: FnMut(&mut St, Self::Item) -> Option<B>,\n+    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n+        where F: FnMut(&mut St, Self::Item) -> Option<B>,\n     {\n         Scan{iter: self, f: f, state: initial_state}\n     }\n@@ -474,9 +468,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn flat_map<B, U, F>(self, f: F) -> FlatMap<Self::Item, B, Self, U, F> where\n-        U: Iterator<Item=B>,\n-        F: FnMut(Self::Item) -> U,\n+    fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n+        where U: Iterator, F: FnMut(Self::Item) -> U,\n     {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n@@ -534,7 +527,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn inspect<F>(self, f: F) -> Inspect<Self::Item, Self, F> where\n+    fn inspect<F>(self, f: F) -> Inspect<Self, F> where\n         F: FnMut(&Self::Item),\n     {\n         Inspect{iter: self, f: f}\n@@ -588,7 +581,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"recently added as part of collections reform\")]\n-    fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n+    fn partition<B, F>(self, mut f: F) -> (B, B) where\n         B: Default + Extend<Self::Item>,\n         F: FnMut(&Self::Item) -> bool\n     {\n@@ -617,7 +610,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n+    fn fold<B, F>(self, init: B, mut f: F) -> B where\n         F: FnMut(B, Self::Item) -> B,\n     {\n         let mut accum = init;\n@@ -638,7 +631,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n+    fn all<F>(self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n     }\n@@ -946,7 +939,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!([2, 4], right);\n     /// ```\n     #[unstable(feature = \"core\", reason = \"recent addition\")]\n-    fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n+    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n         Self: Iterator<Item=(A, B)>,\n@@ -1077,16 +1070,14 @@ pub trait ExactSizeIterator: Iterator {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n-    I: ExactSizeIterator<Item=A>,\n-    F: FnMut(&A),\n+impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F> where\n+    F: FnMut(&I::Item),\n {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n-    I: ExactSizeIterator<Item=A>,\n-    F: FnMut(A) -> B,\n+impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n@@ -1561,28 +1552,15 @@ impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n /// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Map<A, B, I: Iterator<Item=A>, F: FnMut(A) -> B> {\n+#[derive(Clone)]\n+pub struct Map<I, F> {\n     iter: I,\n     f: F,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> Clone for Map<A, B, I, F> where\n-    I: Clone + Iterator<Item=A>,\n-    F: Clone + FnMut(A) -> B,\n-{\n-    fn clone(&self) -> Map<A, B, I, F> {\n-        Map {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-        }\n-    }\n-}\n-\n-impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n+impl<I: Iterator, F, B> Map<I, F> where F: FnMut(I::Item) -> B {\n     #[inline]\n-    fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n+    fn do_map(&mut self, elt: Option<I::Item>) -> Option<B> {\n         match elt {\n             Some(a) => Some((self.f)(a)),\n             _ => None\n@@ -1591,7 +1569,7 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n+impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n     type Item = B;\n \n     #[inline]\n@@ -1607,9 +1585,8 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n-    I: DoubleEndedIterator<Item=A>,\n-    F: FnMut(A) -> B,\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n@@ -1619,9 +1596,8 @@ impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n-    I: RandomAccessIterator<Item=A>,\n-    F: FnMut(A) -> B,\n+impl<B, I: RandomAccessIterator, F> RandomAccessIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1638,31 +1614,18 @@ impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n /// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+#[derive(Clone)]\n+pub struct Filter<I, P> {\n     iter: I,\n     predicate: P,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Clone for Filter<A, I, P> where\n-    I: Clone + Iterator<Item=A>,\n-    P: Clone + FnMut(&A) -> bool,\n-{\n-    fn clone(&self) -> Filter<A, I, P> {\n-        Filter {\n-            iter: self.iter.clone(),\n-            predicate: self.predicate.clone(),\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n-    type Item = A;\n+impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<I::Item> {\n         for x in self.iter.by_ref() {\n             if (self.predicate)(&x) {\n                 return Some(x);\n@@ -1681,12 +1644,11 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n-    I: DoubleEndedIterator<Item=A>,\n-    P: FnMut(&A) -> bool,\n+impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n+    where P: FnMut(&I::Item) -> bool,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option<I::Item> {\n         for x in self.iter.by_ref().rev() {\n             if (self.predicate)(&x) {\n                 return Some(x);\n@@ -1699,29 +1661,15 @@ impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n /// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct FilterMap<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> Option<B> {\n+#[derive(Clone)]\n+pub struct FilterMap<I, F> {\n     iter: I,\n     f: F,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n-    I: Clone + Iterator<Item=A>,\n-    F: Clone + FnMut(A) -> Option<B>,\n-{\n-    fn clone(&self) -> FilterMap<A, B, I, F> {\n-        FilterMap {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n-    I: Iterator<Item=A>,\n-    F: FnMut(A) -> Option<B>,\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n {\n     type Item = B;\n \n@@ -1744,9 +1692,8 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n-    I: DoubleEndedIterator<Item=A>,\n-    F: FnMut(A) -> Option<B>,\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n@@ -1824,20 +1771,28 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n }\n \n /// An iterator with a `peek()` that returns an optional reference to the next element.\n-#[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Peekable<T, I> where I: Iterator<Item=T> {\n+pub struct Peekable<I: Iterator> {\n     iter: I,\n-    peeked: Option<T>,\n+    peeked: Option<I::Item>,\n+}\n+\n+impl<I: Iterator + Clone> Clone for Peekable<I> where I::Item: Clone {\n+    fn clone(&self) -> Peekable<I> {\n+        Peekable {\n+            iter: self.iter.clone(),\n+            peeked: self.peeked.clone(),\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n-    type Item = T;\n+impl<I: Iterator> Iterator for Peekable<I> {\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<T> {\n+    fn next(&mut self) -> Option<I::Item> {\n         if self.peeked.is_some() { self.peeked.take() }\n         else { self.iter.next() }\n     }\n@@ -1859,14 +1814,14 @@ impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, I> ExactSizeIterator for Peekable<T, I> where I: ExactSizeIterator<Item = T> {}\n+impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n-    /// Return a reference to the next element of the iterator with out advancing it,\n-    /// or None if the iterator is exhausted.\n+impl<I: Iterator> Peekable<I> {\n+    /// Return a reference to the next element of the iterator with out\n+    /// advancing it, or None if the iterator is exhausted.\n     #[inline]\n-    pub fn peek(&mut self) -> Option<&T> {\n+    pub fn peek(&mut self) -> Option<&I::Item> {\n         if self.peeked.is_none() {\n             self.peeked = self.iter.next();\n         }\n@@ -1886,33 +1841,21 @@ impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n /// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+#[derive(Clone)]\n+pub struct SkipWhile<I, P> {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Clone for SkipWhile<A, I, P> where\n-    I: Clone + Iterator<Item=A>,\n-    P: Clone + FnMut(&A) -> bool,\n+impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n {\n-    fn clone(&self) -> SkipWhile<A, I, P> {\n-        SkipWhile {\n-            iter: self.iter.clone(),\n-            flag: self.flag,\n-            predicate: self.predicate.clone(),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n-    type Item = A;\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<I::Item> {\n         for x in self.iter.by_ref() {\n             if self.flag || !(self.predicate)(&x) {\n                 self.flag = true;\n@@ -1932,33 +1875,21 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n /// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+#[derive(Clone)]\n+pub struct TakeWhile<I, P> {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Clone for TakeWhile<A, I, P> where\n-    I: Clone + Iterator<Item=A>,\n-    P: Clone + FnMut(&A) -> bool,\n+impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n {\n-    fn clone(&self) -> TakeWhile<A, I, P> {\n-        TakeWhile {\n-            iter: self.iter.clone(),\n-            flag: self.flag,\n-            predicate: self.predicate.clone(),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n-    type Item = A;\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<I::Item> {\n         if self.flag {\n             None\n         } else {\n@@ -2118,34 +2049,18 @@ impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n+#[derive(Clone)]\n+pub struct Scan<I, St, F> {\n     iter: I,\n     f: F,\n \n     /// The current internal state to be passed to the closure next.\n     pub state: St,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n-    I: Clone + Iterator<Item=A>,\n-    St: Clone,\n-    F: Clone + FnMut(&mut St, A) -> Option<B>,\n-{\n-    fn clone(&self) -> Scan<A, B, I, St, F> {\n-        Scan {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-            state: self.state.clone(),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n-    I: Iterator<Item=A>,\n-    F: FnMut(&mut St, A) -> Option<B>,\n+impl<B, I: Iterator, St, F> Iterator for Scan<I, St, F> where\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n {\n     type Item = B;\n \n@@ -2166,46 +2081,24 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct FlatMap<A, B, I, U, F> where\n-    I: Iterator<Item=A>,\n-    U: Iterator<Item=B>,\n-    F: FnMut(A) -> U,\n-{\n+#[derive(Clone)]\n+pub struct FlatMap<I, U, F> {\n     iter: I,\n     f: F,\n     frontiter: Option<U>,\n     backiter: Option<U>,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n-    I: Clone + Iterator<Item=A>,\n-    U: Clone + Iterator<Item=B>,\n-    F: Clone + FnMut(A) -> U,\n-{\n-    fn clone(&self) -> FlatMap<A, B, I, U, F> {\n-        FlatMap {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-            frontiter: self.frontiter.clone(),\n-            backiter: self.backiter.clone(),\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n-    I: Iterator<Item=A>,\n-    U: Iterator<Item=B>,\n-    F: FnMut(A) -> U,\n+impl<I: Iterator, U: Iterator, F> Iterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n {\n-    type Item = B;\n+    type Item = U::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<B> {\n+    fn next(&mut self) -> Option<U::Item> {\n         loop {\n-            for inner in self.frontiter.iter_mut() {\n+            if let Some(ref mut inner) = self.frontiter {\n                 for x in inner.by_ref() {\n                     return Some(x)\n                 }\n@@ -2230,15 +2123,14 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n-    I: DoubleEndedIterator<Item=A>,\n-    U: DoubleEndedIterator<Item=B>,\n-    F: FnMut(A) -> U,\n+impl<I: DoubleEndedIterator, U: DoubleEndedIterator, F> DoubleEndedIterator\n+    for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n+    fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n-            for inner in self.backiter.iter_mut() {\n+            if let Some(ref mut inner) = self.backiter {\n                 match inner.next_back() {\n                     None => (),\n                     y => return y\n@@ -2340,28 +2232,15 @@ impl<I> Fuse<I> {\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n+#[derive(Clone)]\n+pub struct Inspect<I, F> {\n     iter: I,\n     f: F,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, F> Clone for Inspect<A, I, F> where\n-    I: Clone + Iterator<Item=A>,\n-    F: Clone + FnMut(&A),\n-{\n-    fn clone(&self) -> Inspect<A, I, F> {\n-        Inspect {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-        }\n-    }\n-}\n-\n-impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n+impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n     #[inline]\n-    fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n+    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n         match elt {\n             Some(ref a) => (self.f)(a),\n             None => ()\n@@ -2372,11 +2251,11 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n-    type Item = A;\n+impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<I::Item> {\n         let next = self.iter.next();\n         self.do_inspect(next)\n     }\n@@ -2388,29 +2267,27 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n-    I: DoubleEndedIterator<Item=A>,\n-    F: FnMut(&A),\n+impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item),\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option<I::Item> {\n         let next = self.iter.next_back();\n         self.do_inspect(next)\n     }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n-    I: RandomAccessIterator<Item=A>,\n-    F: FnMut(&A),\n+impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item),\n {\n     #[inline]\n     fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: usize) -> Option<A> {\n+    fn idx(&mut self, index: usize) -> Option<I::Item> {\n         let element = self.iter.idx(index);\n         self.do_inspect(element)\n     }\n@@ -2426,9 +2303,11 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n /// use std::iter::Unfold;\n /// use std::num::Int; // For `.checked_add()`\n ///\n-/// // This iterator will yield up to the last Fibonacci number before the max value of `u32`.\n-/// // You can simply change `u32` to `u64` in this line if you want higher values than that.\n-/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)), |&mut (ref mut x2, ref mut x1)| {\n+/// // This iterator will yield up to the last Fibonacci number before the max\n+/// // value of `u32`. You can simply change `u32` to `u64` in this line if\n+/// // you want higher values than that.\n+/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)),\n+///                                 |&mut (ref mut x2, ref mut x1)| {\n ///     // Attempt to get the next Fibonacci number\n ///     // `x1` will be `None` if previously overflowed.\n ///     let next = match (*x2, *x1) {\n@@ -2449,32 +2328,19 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n /// }\n /// ```\n #[unstable(feature = \"core\")]\n-pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+#[derive(Clone)]\n+pub struct Unfold<St, F> {\n     f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n     pub state: St,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, St, F> Clone for Unfold<A, St, F> where\n-    F: Clone + FnMut(&mut St) -> Option<A>,\n-    St: Clone,\n-{\n-    fn clone(&self) -> Unfold<A, St, F> {\n-        Unfold {\n-            f: self.f.clone(),\n-            state: self.state.clone(),\n-        }\n-    }\n-}\n-\n #[unstable(feature = \"core\")]\n-impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+impl<A, St, F> Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n     #[inline]\n-    pub fn new(initial_state: St, f: F) -> Unfold<A, St, F> {\n+    pub fn new(initial_state: St, f: F) -> Unfold<St, F> {\n         Unfold {\n             f: f,\n             state: initial_state\n@@ -2483,7 +2349,7 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+impl<A, St, F> Iterator for Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n     type Item = A;\n \n     #[inline]\n@@ -2899,7 +2765,7 @@ type IterateState<T, F> = (F, Option<T>, bool);\n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n #[unstable(feature = \"core\")]\n-pub type Iterate<T, F> = Unfold<T, IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n+pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`."}, {"sha": "5e9793f270dedea1d37d6b2b565dab1b8b645dae", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -59,7 +59,6 @@\n #![no_std]\n #![allow(raw_pointer_derive)]\n #![deny(missing_docs)]\n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n \n #![feature(int_uint)]\n #![feature(intrinsics, lang_items)]"}, {"sha": "7af94c73f324d80324fdacec9a44edd95df61698", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -947,28 +947,11 @@ pub trait IndexMut<Index: ?Sized> {\n }\n \n /// An unbounded range.\n-#[cfg(stage0)]\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-#[lang=\"full_range\"]\n-#[unstable(feature = \"core\", reason  = \"may be renamed to RangeFull\")]\n-pub struct FullRange;\n-\n-/// An unbounded range.\n-#[cfg(not(stage0))]\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_full\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for FullRange {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(\"..\", fmt)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for RangeFull {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "f4b1a0633de5ceecf1d122fdce30ffd0bec80707", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -26,9 +26,6 @@\n \n // Reexported core operators\n pub use marker::{Copy, Send, Sized, Sync};\n-#[cfg(stage0)]\n-pub use ops::{Drop, Fn, FnMut, FnOnce, FullRange};\n-#[cfg(not(stage0))]\n pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // Reexported functions"}, {"sha": "d610962f8620cb491b41cd52882dd99e34857d66", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -956,7 +956,7 @@ pub fn fold<T,\n             E,\n             F: FnMut(V, T) -> V,\n             Iter: Iterator<Item=Result<T, E>>>(\n-            mut iterator: Iter,\n+            iterator: Iter,\n             mut init: V,\n             mut f: F)\n             -> Result<V, E> {"}, {"sha": "a750e81bf596b7fd9aeebbec55822b0146c0956d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -43,9 +43,6 @@ use default::Default;\n use iter::*;\n use num::Int;\n use ops::{FnMut, self, Index};\n-#[cfg(stage0)]\n-use ops::FullRange as RangeFull;\n-#[cfg(not(stage0))]\n use ops::RangeFull;\n use option::Option;\n use option::Option::{None, Some};\n@@ -769,16 +766,6 @@ impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> {\n-    type Output = [T];\n-    #[inline]\n-    fn index(&self, _index: &ops::FullRange) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-#[cfg(not(stage0))]\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<RangeFull> for Iter<'a, T> {\n     type Output = [T];"}, {"sha": "8c0c16bafc4c586b860d57ebb81339ebe2c3719c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -478,7 +478,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n /// Created with `StrExt::bytes`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n-pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n+pub struct Bytes<'a>(Map<slice::Iter<'a, u8>, BytesDeref>);\n delegate_iter!{exact u8 : Bytes<'a>}\n \n /// A temporary fn new type that ensures that the `Bytes` iterator\n@@ -526,7 +526,7 @@ pub struct Lines<'a> {\n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinesAny<'a> {\n-    inner: Map<&'a str, &'a str, Lines<'a>, fn(&str) -> &str>,\n+    inner: Map<Lines<'a>, fn(&str) -> &str>,\n }\n \n impl<'a, Sep> CharSplits<'a, Sep> {\n@@ -1266,16 +1266,6 @@ mod traits {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::FullRange> for str {\n-        type Output = str;\n-        #[inline]\n-        fn index(&self, _index: &ops::FullRange) -> &str {\n-            self\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;"}, {"sha": "8939bd61fe4ae0cc6e7ca10822d3c613972f70f7", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -60,20 +60,24 @@ fn no_mut_then_imm_borrow() {\n     let x = RefCell::new(0);\n     let _b1 = x.borrow_mut();\n     assert!(x.try_borrow().is_none());\n+    assert_eq!(x.borrow_state(), BorrowState::Writing);\n }\n \n #[test]\n fn no_imm_then_borrow_mut() {\n     let x = RefCell::new(0);\n     let _b1 = x.borrow();\n     assert!(x.try_borrow_mut().is_none());\n+    assert_eq!(x.borrow_state(), BorrowState::Reading);\n }\n \n #[test]\n fn no_double_borrow_mut() {\n     let x = RefCell::new(0);\n+    assert_eq!(x.borrow_state(), BorrowState::Unused);\n     let _b1 = x.borrow_mut();\n     assert!(x.try_borrow_mut().is_none());\n+    assert_eq!(x.borrow_state(), BorrowState::Writing);\n }\n \n #[test]"}, {"sha": "2e5c6fe5a2ff7bec0f1f4a3694a85a22957ee061", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -66,11 +66,11 @@ fn test_partial_min() {\n         (1.0f64, NAN, None)\n     ];\n \n-    for &(a, b, result) in data_integer.iter() {\n+    for &(a, b, result) in &data_integer {\n         assert!(partial_min(a, b) == result);\n     }\n \n-    for &(a, b, result) in data_float.iter() {\n+    for &(a, b, result) in &data_float {\n         assert!(partial_min(a, b) == result);\n     }\n }\n@@ -99,11 +99,11 @@ fn test_partial_max() {\n         (1.0f64, NAN, None)\n     ];\n \n-    for &(a, b, result) in data_integer.iter() {\n+    for &(a, b, result) in &data_integer {\n         assert!(partial_max(a, b) == result);\n     }\n \n-    for &(a, b, result) in data_float.iter() {\n+    for &(a, b, result) in &data_float {\n         assert!(partial_max(a, b) == result);\n     }\n }"}, {"sha": "2da3f370b40ac467435f5da7379213ea30aacbbe", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -25,7 +25,7 @@ impl Default for MyHasher {\n impl Writer for MyHasher {\n     // Most things we'll just add up the bytes.\n     fn write(&mut self, buf: &[u8]) {\n-        for byte in buf.iter() {\n+        for byte in buf {\n             self.hash += *byte as u64;\n         }\n     }"}, {"sha": "a493f71925e0a2a15a53158be8a9bf837fcea39c", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -109,7 +109,7 @@ fn test_siphash() {\n \n     fn to_hex_str(r: &[u8; 8]) -> String {\n         let mut s = String::new();\n-        for b in r.iter() {\n+        for b in r {\n             s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n         }\n         s\n@@ -130,7 +130,7 @@ fn test_siphash() {\n     fn result_str(h: u64) -> String {\n         let r = result_bytes(h);\n         let mut s = String::new();\n-        for b in r.iter() {\n+        for b in &r {\n             s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n         }\n         s"}, {"sha": "fc8d18df81523a6889f4216ccbc935fe9dbe4959", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -24,7 +24,6 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![cfg_attr(stage0, feature(core))]\n #![feature(int_uint)]\n #![feature(slicing_syntax)]\n #![feature(staged_api)]"}, {"sha": "b4eb8e9902ae22c4eaabb0b1e721edb2886b69e8", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -315,7 +315,7 @@ impl Matches {\n \n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[String]) -> bool {\n-        for nm in names.iter() {\n+        for nm in names {\n             match find_opt(self.opts.as_slice(), Name::from_str(&nm[])) {\n                 Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n@@ -326,7 +326,7 @@ impl Matches {\n \n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n-        for nm in names.iter() {\n+        for nm in names {\n             match self.opt_val(&nm[]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n@@ -342,7 +342,7 @@ impl Matches {\n     pub fn opt_strs(&self, nm: &str) -> Vec<String> {\n         let mut acc: Vec<String> = Vec::new();\n         let r = self.opt_vals(nm);\n-        for v in r.iter() {\n+        for v in &r {\n             match *v {\n                 Val(ref s) => acc.push((*s).clone()),\n                 _ => ()\n@@ -395,7 +395,7 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n     }\n \n     // Search in aliases.\n-    for candidate in opts.iter() {\n+    for candidate in opts {\n         if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n             return opts.iter().position(|opt| opt.name == candidate.name);\n         }\n@@ -648,7 +648,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 }\n             }\n             let mut name_pos = 0;\n-            for nm in names.iter() {\n+            for nm in &names {\n                 name_pos += 1;\n                 let optid = match find_opt(opts.as_slice(), (*nm).clone()) {\n                   Some(id) => id,"}, {"sha": "e9c7f837014b83b102ac7807163d50ffbbf3323d", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -548,7 +548,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n               options: &[RenderOption]) -> old_io::IoResult<()>\n {\n     fn writeln<W:Writer>(w: &mut W, arg: &[&str]) -> old_io::IoResult<()> {\n-        for &s in arg.iter() { try!(w.write_str(s)); }\n+        for &s in arg { try!(w.write_str(s)); }\n         w.write_char('\\n')\n     }\n \n@@ -557,7 +557,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n     }\n \n     try!(writeln(w, &[\"digraph \", g.graph_id().as_slice(), \" {\"]));\n-    for n in g.nodes().iter() {\n+    for n in &*g.nodes() {\n         try!(indent(w));\n         let id = g.node_id(n);\n         if options.contains(&RenderOption::NoNodeLabels) {\n@@ -569,7 +569,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n         }\n     }\n \n-    for e in g.edges().iter() {\n+    for e in &*g.edges() {\n         let escaped_label = g.edge_label(e).escape();\n         try!(indent(w));\n         let source = g.source(e);"}, {"sha": "75867eb38be652236a86bc3a103d28f5c2e34aef", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 673, "deletions": 40, "changes": 713, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -280,7 +280,8 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(any(target_os = \"linux\",\n           target_os = \"android\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n pub use consts::os::posix01::{CLOCK_REALTIME, CLOCK_MONOTONIC};\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n@@ -290,7 +291,7 @@ pub use types::os::arch::extra::{sockaddr_ll};\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub use consts::os::extra::{AF_PACKET};\n \n-#[cfg(all(unix, not(target_os = \"freebsd\")))]\n+#[cfg(all(unix, not(any(target_os = \"freebsd\", target_os = \"openbsd\"))))]\n pub use consts::os::extra::{MAP_STACK};\n \n #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n@@ -1326,6 +1327,233 @@ pub mod types {\n         }\n     }\n \n+    #[cfg(target_os = \"openbsd\")]\n+    pub mod os {\n+        pub mod common {\n+            pub mod posix01 {\n+                use types::common::c95::{c_void};\n+                use types::os::arch::c95::{c_char, c_int, size_t,\n+                                                 time_t, suseconds_t, c_long};\n+                use types::os::arch::c99::{uintptr_t};\n+\n+                pub type pthread_t = uintptr_t;\n+\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct glob_t {\n+                    pub gl_pathc:  c_int,\n+                    pub __unused1: c_int,\n+                    pub gl_offs:   c_int,\n+                    pub __unused2: c_int,\n+                    pub gl_pathv:  *mut *mut c_char,\n+\n+                    pub __unused3: *mut c_void,\n+\n+                    pub __unused4: *mut c_void,\n+                    pub __unused5: *mut c_void,\n+                    pub __unused6: *mut c_void,\n+                    pub __unused7: *mut c_void,\n+                    pub __unused8: *mut c_void,\n+                    pub __unused9: *mut c_void,\n+                }\n+\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct timeval {\n+                    pub tv_sec: time_t,\n+                    pub tv_usec: suseconds_t,\n+                }\n+\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct timespec {\n+                    pub tv_sec: time_t,\n+                    pub tv_nsec: c_long,\n+                }\n+\n+                #[derive(Copy)] pub enum timezone {}\n+\n+                pub type sighandler_t = size_t;\n+            }\n+            pub mod bsd44 {\n+                use types::common::c95::{c_void};\n+                use types::os::arch::c95::{c_char, c_int, c_uint};\n+\n+                pub type socklen_t = u32;\n+                pub type sa_family_t = u8;\n+                pub type in_port_t = u16;\n+                pub type in_addr_t = u32;\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct sockaddr {\n+                    pub sa_len: u8,\n+                    pub sa_family: sa_family_t,\n+                    pub sa_data: [u8; 14],\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct sockaddr_storage {\n+                    pub ss_len: u8,\n+                    pub ss_family: sa_family_t,\n+                    pub __ss_pad1: [u8; 6],\n+                    pub __ss_pad2: i64,\n+                    pub __ss_pad3: [u8; 240],\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct sockaddr_in {\n+                    pub sin_len: u8,\n+                    pub sin_family: sa_family_t,\n+                    pub sin_port: in_port_t,\n+                    pub sin_addr: in_addr,\n+                    pub sin_zero: [u8; 8],\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct in_addr {\n+                    pub s_addr: in_addr_t,\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct sockaddr_in6 {\n+                    pub sin6_len: u8,\n+                    pub sin6_family: sa_family_t,\n+                    pub sin6_port: in_port_t,\n+                    pub sin6_flowinfo: u32,\n+                    pub sin6_addr: in6_addr,\n+                    pub sin6_scope_id: u32,\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct in6_addr {\n+                    pub s6_addr: [u16; 8]\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct ip_mreq {\n+                    pub imr_multiaddr: in_addr,\n+                    pub imr_interface: in_addr,\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct ip6_mreq {\n+                    pub ipv6mr_multiaddr: in6_addr,\n+                    pub ipv6mr_interface: c_uint,\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct addrinfo {\n+                    pub ai_flags: c_int,\n+                    pub ai_family: c_int,\n+                    pub ai_socktype: c_int,\n+                    pub ai_protocol: c_int,\n+                    pub ai_addrlen: socklen_t,\n+                    pub ai_addr: *mut sockaddr,\n+                    pub ai_canonname: *mut c_char,\n+                    pub ai_next: *mut addrinfo,\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct sockaddr_un {\n+                    pub sun_len: u8,\n+                    pub sun_family: sa_family_t,\n+                    pub sun_path: [c_char; 104]\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct ifaddrs {\n+                    pub ifa_next: *mut ifaddrs,\n+                    pub ifa_name: *mut c_char,\n+                    pub ifa_flags: c_uint,\n+                    pub ifa_addr: *mut sockaddr,\n+                    pub ifa_netmask: *mut sockaddr,\n+                    pub ifa_dstaddr: *mut sockaddr,\n+                    pub ifa_data: *mut c_void\n+                }\n+\n+            }\n+        }\n+\n+        #[cfg(target_arch = \"x86_64\")]\n+        pub mod arch {\n+            pub mod c95 {\n+                pub type c_char = i8;\n+                pub type c_schar = i8;\n+                pub type c_uchar = u8;\n+                pub type c_short = i16;\n+                pub type c_ushort = u16;\n+                pub type c_int = i32;\n+                pub type c_uint = u32;\n+                pub type c_long = i64;\n+                pub type c_ulong = u64;\n+                pub type c_float = f32;\n+                pub type c_double = f64;\n+                pub type size_t = u64;\n+                pub type ptrdiff_t = i64;\n+                pub type clock_t = i64;\n+                pub type time_t = i64;\n+                pub type suseconds_t = i64;\n+                pub type wchar_t = i32;\n+            }\n+            pub mod c99 {\n+                pub type c_longlong = i64;\n+                pub type c_ulonglong = u64;\n+                pub type intptr_t = i64;\n+                pub type uintptr_t = u64;\n+                pub type intmax_t = i64;\n+                pub type uintmax_t = u64;\n+            }\n+            pub mod posix88 {\n+                pub type off_t = i64;\n+                pub type dev_t = u32;\n+                pub type ino_t = u64;\n+                pub type pid_t = i32;\n+                pub type uid_t = u32;\n+                pub type gid_t = u32;\n+                pub type useconds_t = u32;\n+                pub type mode_t = u32;\n+                pub type ssize_t = i64;\n+            }\n+            pub mod posix01 {\n+                use types::common::c95::{c_void};\n+                use types::common::c99::{uint32_t, uint64_t};\n+                use types::os::arch::c95::{c_long, time_t};\n+                use types::os::arch::posix88::{dev_t, gid_t};\n+                use types::os::arch::posix88::{mode_t, off_t};\n+                use types::os::arch::posix88::{uid_t};\n+\n+                pub type nlink_t = u32;\n+                pub type blksize_t = uint32_t;\n+                pub type ino_t = uint64_t;\n+                pub type blkcnt_t = i64;\n+                pub type fflags_t = u32; // type not declared, but struct stat have u_int32_t\n+\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct stat {\n+                    pub st_mode: mode_t,\n+                    pub st_dev: dev_t,\n+                    pub st_ino: ino_t,\n+                    pub st_nlink: nlink_t,\n+                    pub st_uid: uid_t,\n+                    pub st_gid: gid_t,\n+                    pub st_rdev: dev_t,\n+                    pub st_atime: time_t,\n+                    pub st_atime_nsec: c_long,\n+                    pub st_mtime: time_t,\n+                    pub st_mtime_nsec: c_long,\n+                    pub st_ctime: time_t,\n+                    pub st_ctime_nsec: c_long,\n+                    pub st_size: off_t,\n+                    pub st_blocks: blkcnt_t,\n+                    pub st_blksize: blksize_t,\n+                    pub st_flags: fflags_t,\n+                    pub st_gen: uint32_t,\n+                    pub st_birthtime: time_t,\n+                    pub st_birthtime_nsec: c_long,\n+                }\n+                #[repr(C)]\n+                #[derive(Copy)] pub struct utimbuf {\n+                    pub actime: time_t,\n+                    pub modtime: time_t,\n+                }\n+\n+                pub type pthread_attr_t = *mut c_void;\n+            }\n+            pub mod posix08 {\n+            }\n+            pub mod bsd44 {\n+            }\n+            pub mod extra {\n+            }\n+        }\n+    }\n+\n     #[cfg(target_os = \"windows\")]\n     pub mod os {\n         pub mod common {\n@@ -3254,7 +3482,8 @@ pub mod consts {\n         }\n     }\n \n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+    #[cfg(any(target_os = \"freebsd\",\n+              target_os = \"dragonfly\"))]\n     pub mod os {\n         pub mod c95 {\n             use types::os::arch::c95::{c_int, c_uint};\n@@ -3663,7 +3892,7 @@ pub mod consts {\n         }\n     }\n \n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    #[cfg(target_os = \"openbsd\")]\n     pub mod os {\n         pub mod c95 {\n             use types::os::arch::c95::{c_int, c_uint};\n@@ -3751,14 +3980,11 @@ pub mod consts {\n             pub const MCL_CURRENT : c_int = 0x0001;\n             pub const MCL_FUTURE : c_int = 0x0002;\n \n+            pub const MS_SYNC : c_int = 0x0002; // changed\n             pub const MS_ASYNC : c_int = 0x0001;\n-            pub const MS_INVALIDATE : c_int = 0x0002;\n-            pub const MS_SYNC : c_int = 0x0010;\n-\n-            pub const MS_KILLPAGES : c_int = 0x0004;\n-            pub const MS_DEACTIVATE : c_int = 0x0008;\n+            pub const MS_INVALIDATE : c_int = 0x0004; // changed\n \n-            pub const EPERM : c_int = 1;\n+            pub const EPERM : c_int = 1; // not checked\n             pub const ENOENT : c_int = 2;\n             pub const ESRCH : c_int = 3;\n             pub const EINTR : c_int = 4;\n@@ -3793,7 +4019,7 @@ pub mod consts {\n             pub const EDOM : c_int = 33;\n             pub const ERANGE : c_int = 34;\n             pub const EAGAIN : c_int = 35;\n-            pub const EWOULDBLOCK : c_int = EAGAIN;\n+            pub const EWOULDBLOCK : c_int = 35;\n             pub const EINPROGRESS : c_int = 36;\n             pub const EALREADY : c_int = 37;\n             pub const ENOTSOCK : c_int = 38;\n@@ -3803,7 +4029,7 @@ pub mod consts {\n             pub const ENOPROTOOPT : c_int = 42;\n             pub const EPROTONOSUPPORT : c_int = 43;\n             pub const ESOCKTNOSUPPORT : c_int = 44;\n-            pub const ENOTSUP : c_int = 45;\n+            pub const EOPNOTSUPP : c_int = 45;\n             pub const EPFNOSUPPORT : c_int = 46;\n             pub const EAFNOSUPPORT : c_int = 47;\n             pub const EADDRINUSE : c_int = 48;\n@@ -3840,30 +4066,428 @@ pub mod consts {\n             pub const EFTYPE : c_int = 79;\n             pub const EAUTH : c_int = 80;\n             pub const ENEEDAUTH : c_int = 81;\n-            pub const EPWROFF : c_int = 82;\n-            pub const EDEVERR : c_int = 83;\n+            pub const EIDRM : c_int = 82;\n+            pub const ENOMSG : c_int = 83;\n             pub const EOVERFLOW : c_int = 84;\n-            pub const EBADEXEC : c_int = 85;\n-            pub const EBADARCH : c_int = 86;\n-            pub const ESHLIBVERS : c_int = 87;\n-            pub const EBADMACHO : c_int = 88;\n-            pub const ECANCELED : c_int = 89;\n-            pub const EIDRM : c_int = 90;\n-            pub const ENOMSG : c_int = 91;\n-            pub const EILSEQ : c_int = 92;\n-            pub const ENOATTR : c_int = 93;\n-            pub const EBADMSG : c_int = 94;\n-            pub const EMULTIHOP : c_int = 95;\n-            pub const ENODATA : c_int = 96;\n-            pub const ENOLINK : c_int = 97;\n-            pub const ENOSR : c_int = 98;\n-            pub const ENOSTR : c_int = 99;\n-            pub const EPROTO : c_int = 100;\n-            pub const ETIME : c_int = 101;\n-            pub const EOPNOTSUPP : c_int = 102;\n-            pub const ENOPOLICY : c_int = 103;\n-            pub const ENOTRECOVERABLE : c_int = 104;\n-            pub const EOWNERDEAD : c_int = 105;\n+            pub const ECANCELED : c_int = 85;\n+            pub const EILSEQ : c_int = 86;\n+            pub const ENOATTR : c_int = 87;\n+            pub const EDOOFUS : c_int = 88;\n+            pub const EBADMSG : c_int = 89;\n+            pub const EMULTIHOP : c_int = 90;\n+            pub const ENOLINK : c_int = 91;\n+            pub const EPROTO : c_int = 92;\n+            pub const ENOMEDIUM : c_int = 93;\n+            pub const EUNUSED94 : c_int = 94;\n+            pub const EUNUSED95 : c_int = 95;\n+            pub const EUNUSED96 : c_int = 96;\n+            pub const EUNUSED97 : c_int = 97;\n+            pub const EUNUSED98 : c_int = 98;\n+            pub const EASYNC : c_int = 99;\n+            pub const ELAST : c_int = 99;\n+        }\n+        pub mod posix01 {\n+            use types::os::arch::c95::{c_int, size_t};\n+\n+            pub const F_DUPFD : c_int = 0;\n+            pub const F_GETFD : c_int = 1;\n+            pub const F_SETFD : c_int = 2;\n+            pub const F_GETFL : c_int = 3;\n+            pub const F_SETFL : c_int = 4;\n+\n+            pub const SIGTRAP : c_int = 5;\n+            pub const SIGPIPE: c_int = 13;\n+            pub const SIG_IGN: size_t = 1;\n+\n+            pub const GLOB_APPEND   : c_int = 0x0001;\n+            pub const GLOB_DOOFFS   : c_int = 0x0002;\n+            pub const GLOB_ERR      : c_int = 0x0004;\n+            pub const GLOB_MARK     : c_int = 0x0008;\n+            pub const GLOB_NOCHECK  : c_int = 0x0010;\n+            pub const GLOB_NOSORT   : c_int = 0x0020;\n+            pub const GLOB_NOESCAPE : c_int = 0x1000; // changed\n+\n+            pub const GLOB_NOSPACE  : c_int = -1;\n+            pub const GLOB_ABORTED  : c_int = -2;\n+            pub const GLOB_NOMATCH  : c_int = -3;\n+\n+            pub const POSIX_MADV_NORMAL : c_int = 0;\n+            pub const POSIX_MADV_RANDOM : c_int = 1;\n+            pub const POSIX_MADV_SEQUENTIAL : c_int = 2;\n+            pub const POSIX_MADV_WILLNEED : c_int = 3;\n+            pub const POSIX_MADV_DONTNEED : c_int = 4;\n+\n+            pub const _SC_IOV_MAX : c_int = 51; // all changed...\n+            pub const _SC_GETGR_R_SIZE_MAX : c_int = 100;\n+            pub const _SC_GETPW_R_SIZE_MAX : c_int = 101;\n+            pub const _SC_LOGIN_NAME_MAX : c_int = 102;\n+            pub const _SC_MQ_PRIO_MAX : c_int = 59;\n+            pub const _SC_THREAD_ATTR_STACKADDR : c_int = 77;\n+            pub const _SC_THREAD_ATTR_STACKSIZE : c_int = 78;\n+            pub const _SC_THREAD_DESTRUCTOR_ITERATIONS : c_int = 80;\n+            pub const _SC_THREAD_KEYS_MAX : c_int = 81;\n+            pub const _SC_THREAD_PRIO_INHERIT : c_int = 82;\n+            pub const _SC_THREAD_PRIO_PROTECT : c_int = 83;\n+            pub const _SC_THREAD_PRIORITY_SCHEDULING : c_int = 84;\n+            pub const _SC_THREAD_PROCESS_SHARED : c_int = 85;\n+            pub const _SC_THREAD_SAFE_FUNCTIONS : c_int = 103;\n+            pub const _SC_THREAD_STACK_MIN : c_int = 89;\n+            pub const _SC_THREAD_THREADS_MAX : c_int = 90;\n+            pub const _SC_THREADS : c_int = 91;\n+            pub const _SC_TTY_NAME_MAX : c_int = 107;\n+            pub const _SC_ATEXIT_MAX : c_int = 46;\n+            pub const _SC_XOPEN_CRYPT : c_int = 117;\n+            pub const _SC_XOPEN_ENH_I18N : c_int = 118;\n+            pub const _SC_XOPEN_LEGACY : c_int = 119;\n+            pub const _SC_XOPEN_REALTIME : c_int = 120;\n+            pub const _SC_XOPEN_REALTIME_THREADS : c_int = 121;\n+            pub const _SC_XOPEN_SHM : c_int = 30;\n+            pub const _SC_XOPEN_UNIX : c_int = 123;\n+            pub const _SC_XOPEN_VERSION : c_int = 125;\n+            //pub const _SC_XOPEN_XCU_VERSION : c_int = ;\n+\n+            pub const PTHREAD_CREATE_JOINABLE: c_int = 0;\n+            pub const PTHREAD_CREATE_DETACHED: c_int = 1;\n+            pub const PTHREAD_STACK_MIN: size_t = 2048;\n+\n+            pub const CLOCK_REALTIME: c_int = 0;\n+            pub const CLOCK_MONOTONIC: c_int = 3;\n+        }\n+        pub mod posix08 {\n+        }\n+        pub mod bsd44 {\n+            use types::os::arch::c95::c_int;\n+\n+            pub const MADV_NORMAL : c_int = 0;\n+            pub const MADV_RANDOM : c_int = 1;\n+            pub const MADV_SEQUENTIAL : c_int = 2;\n+            pub const MADV_WILLNEED : c_int = 3;\n+            pub const MADV_DONTNEED : c_int = 4;\n+            pub const MADV_FREE : c_int = 6; // changed\n+            //pub const MADV_NOSYNC : c_int = ;\n+            //pub const MADV_AUTOSYNC : c_int = ;\n+            //pub const MADV_NOCORE : c_int = ;\n+            //pub const MADV_CORE : c_int = ;\n+            //pub const MADV_PROTECT : c_int = ;\n+\n+            //pub const MINCORE_INCORE : c_int =  ;\n+            //pub const MINCORE_REFERENCED : c_int = ;\n+            //pub const MINCORE_MODIFIED : c_int = ;\n+            //pub const MINCORE_REFERENCED_OTHER : c_int = ;\n+            //pub const MINCORE_MODIFIED_OTHER : c_int = ;\n+            //pub const MINCORE_SUPER : c_int = ;\n+\n+            pub const AF_INET: c_int = 2;\n+            pub const AF_INET6: c_int = 24; // changed\n+            pub const AF_UNIX: c_int = 1;\n+            pub const SOCK_STREAM: c_int = 1;\n+            pub const SOCK_DGRAM: c_int = 2;\n+            pub const SOCK_RAW: c_int = 3;\n+            pub const IPPROTO_TCP: c_int = 6;\n+            pub const IPPROTO_IP: c_int = 0;\n+            pub const IPPROTO_IPV6: c_int = 41;\n+            pub const IP_MULTICAST_TTL: c_int = 10;\n+            pub const IP_MULTICAST_LOOP: c_int = 11;\n+            pub const IP_TTL: c_int = 4;\n+            pub const IP_HDRINCL: c_int = 2;\n+            pub const IP_ADD_MEMBERSHIP: c_int = 12;\n+            pub const IP_DROP_MEMBERSHIP: c_int = 13;\n+            // don't exist, keep same as IP_ADD_MEMBERSHIP\n+            pub const IPV6_ADD_MEMBERSHIP: c_int = 12;\n+            // don't exist, keep same as IP_DROP_MEMBERSHIP\n+            pub const IPV6_DROP_MEMBERSHIP: c_int = 13;\n+\n+            pub const TCP_NODELAY: c_int = 1;\n+            //pub const TCP_KEEPIDLE: c_int = ;\n+            pub const SOL_SOCKET: c_int = 0xffff;\n+            pub const SO_KEEPALIVE: c_int = 0x0008;\n+            pub const SO_BROADCAST: c_int = 0x0020;\n+            pub const SO_REUSEADDR: c_int = 0x0004;\n+            pub const SO_ERROR: c_int = 0x1007;\n+\n+            pub const IFF_LOOPBACK: c_int = 0x8;\n+\n+            pub const SHUT_RD: c_int = 0;\n+            pub const SHUT_WR: c_int = 1;\n+            pub const SHUT_RDWR: c_int = 2;\n+        }\n+        pub mod extra {\n+            use types::os::arch::c95::c_int;\n+\n+            pub const O_SYNC : c_int = 128;\n+            pub const O_NONBLOCK : c_int = 4;\n+            pub const CTL_KERN: c_int = 1;\n+            pub const KERN_PROC: c_int = 66;\n+\n+            pub const MAP_COPY : c_int = 0x0002;\n+            pub const MAP_RENAME : c_int = 0x0000; // changed\n+            pub const MAP_NORESERVE : c_int = 0x0000; // changed\n+            pub const MAP_HASSEMAPHORE : c_int = 0x0000; // changed\n+            //pub const MAP_STACK : c_int = ;\n+            //pub const MAP_NOSYNC : c_int = ;\n+            //pub const MAP_NOCORE : c_int = ;\n+\n+            pub const IPPROTO_RAW : c_int = 255;\n+        }\n+        pub mod sysconf {\n+            use types::os::arch::c95::c_int;\n+\n+            pub const _SC_ARG_MAX : c_int = 1;\n+            pub const _SC_CHILD_MAX : c_int = 2;\n+            pub const _SC_CLK_TCK : c_int = 3;\n+            pub const _SC_NGROUPS_MAX : c_int = 4;\n+            pub const _SC_OPEN_MAX : c_int = 5;\n+            pub const _SC_JOB_CONTROL : c_int = 6;\n+            pub const _SC_SAVED_IDS : c_int = 7;\n+            pub const _SC_VERSION : c_int = 8;\n+            pub const _SC_BC_BASE_MAX : c_int = 9;\n+            pub const _SC_BC_DIM_MAX : c_int = 10;\n+            pub const _SC_BC_SCALE_MAX : c_int = 11;\n+            pub const _SC_BC_STRING_MAX : c_int = 12;\n+            pub const _SC_COLL_WEIGHTS_MAX : c_int = 13;\n+            pub const _SC_EXPR_NEST_MAX : c_int = 14;\n+            pub const _SC_LINE_MAX : c_int = 15;\n+            pub const _SC_RE_DUP_MAX : c_int = 16;\n+            pub const _SC_2_VERSION : c_int = 17;\n+            pub const _SC_2_C_BIND : c_int = 18;\n+            pub const _SC_2_C_DEV : c_int = 19;\n+            pub const _SC_2_CHAR_TERM : c_int = 20;\n+            pub const _SC_2_FORT_DEV : c_int = 21;\n+            pub const _SC_2_FORT_RUN : c_int = 22;\n+            pub const _SC_2_LOCALEDEF : c_int = 23;\n+            pub const _SC_2_SW_DEV : c_int = 24;\n+            pub const _SC_2_UPE : c_int = 25;\n+            pub const _SC_STREAM_MAX : c_int = 26;\n+            pub const _SC_TZNAME_MAX : c_int = 27;\n+            pub const _SC_ASYNCHRONOUS_IO : c_int = 45; // changed...\n+            pub const _SC_MAPPED_FILES : c_int = 53;\n+            pub const _SC_MEMLOCK : c_int = 54;\n+            pub const _SC_MEMLOCK_RANGE : c_int = 55;\n+            pub const _SC_MEMORY_PROTECTION : c_int = 56;\n+            pub const _SC_MESSAGE_PASSING : c_int = 57;\n+            pub const _SC_PRIORITIZED_IO : c_int = 60;\n+            pub const _SC_PRIORITY_SCHEDULING : c_int = 61;\n+            pub const _SC_REALTIME_SIGNALS : c_int = 64;\n+            pub const _SC_SEMAPHORES : c_int = 67;\n+            pub const _SC_FSYNC : c_int = 29;\n+            pub const _SC_SHARED_MEMORY_OBJECTS : c_int = 68;\n+            pub const _SC_SYNCHRONIZED_IO : c_int = 75;\n+            pub const _SC_TIMERS : c_int = 94; // ...changed\n+            pub const _SC_AIO_LISTIO_MAX : c_int = 42;\n+            pub const _SC_AIO_MAX : c_int = 43;\n+            pub const _SC_AIO_PRIO_DELTA_MAX : c_int = 44;\n+            pub const _SC_DELAYTIMER_MAX : c_int = 50; // changed...\n+            pub const _SC_MQ_OPEN_MAX : c_int = 58;\n+            pub const _SC_PAGESIZE : c_int = 28;\n+            pub const _SC_RTSIG_MAX : c_int = 66;\n+            pub const _SC_SEM_NSEMS_MAX : c_int = 31;\n+            pub const _SC_SEM_VALUE_MAX : c_int = 32;\n+            pub const _SC_SIGQUEUE_MAX : c_int = 70;\n+            pub const _SC_TIMER_MAX : c_int = 93;\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    pub mod os {\n+        pub mod c95 {\n+            use types::os::arch::c95::{c_int, c_uint};\n+\n+            pub const EXIT_FAILURE : c_int = 1;\n+            pub const EXIT_SUCCESS : c_int = 0;\n+            pub const RAND_MAX : c_int = 2147483647;\n+            pub const EOF : c_int = -1;\n+            pub const SEEK_SET : c_int = 0;\n+            pub const SEEK_CUR : c_int = 1;\n+            pub const SEEK_END : c_int = 2;\n+            pub const _IOFBF : c_int = 0;\n+            pub const _IONBF : c_int = 2;\n+            pub const _IOLBF : c_int = 1;\n+            pub const BUFSIZ : c_uint = 1024_u32;\n+            pub const FOPEN_MAX : c_uint = 20_u32;\n+            pub const FILENAME_MAX : c_uint = 1024_u32;\n+            pub const L_tmpnam : c_uint = 1024_u32;\n+            pub const TMP_MAX : c_uint = 308915776_u32;\n+        }\n+        pub mod c99 {\n+        }\n+        pub mod posix88 {\n+            use types::common::c95::c_void;\n+            use types::os::arch::c95::c_int;\n+            use types::os::arch::posix88::mode_t;\n+\n+            pub const O_RDONLY : c_int = 0;\n+            pub const O_WRONLY : c_int = 1;\n+            pub const O_RDWR : c_int = 2;\n+            pub const O_APPEND : c_int = 8;\n+            pub const O_CREAT : c_int = 512;\n+            pub const O_EXCL : c_int = 2048;\n+            pub const O_TRUNC : c_int = 1024;\n+            pub const S_IFIFO : mode_t = 4096;\n+            pub const S_IFCHR : mode_t = 8192;\n+            pub const S_IFBLK : mode_t = 24576;\n+            pub const S_IFDIR : mode_t = 16384;\n+            pub const S_IFREG : mode_t = 32768;\n+            pub const S_IFLNK : mode_t = 40960;\n+            pub const S_IFMT : mode_t = 61440;\n+            pub const S_IEXEC : mode_t = 64;\n+            pub const S_IWRITE : mode_t = 128;\n+            pub const S_IREAD : mode_t = 256;\n+            pub const S_IRWXU : mode_t = 448;\n+            pub const S_IXUSR : mode_t = 64;\n+            pub const S_IWUSR : mode_t = 128;\n+            pub const S_IRUSR : mode_t = 256;\n+            pub const F_OK : c_int = 0;\n+            pub const R_OK : c_int = 4;\n+            pub const W_OK : c_int = 2;\n+            pub const X_OK : c_int = 1;\n+            pub const STDIN_FILENO : c_int = 0;\n+            pub const STDOUT_FILENO : c_int = 1;\n+            pub const STDERR_FILENO : c_int = 2;\n+            pub const F_LOCK : c_int = 1;\n+            pub const F_TEST : c_int = 3;\n+            pub const F_TLOCK : c_int = 2;\n+            pub const F_ULOCK : c_int = 0;\n+            pub const SIGHUP : c_int = 1;\n+            pub const SIGINT : c_int = 2;\n+            pub const SIGQUIT : c_int = 3;\n+            pub const SIGILL : c_int = 4;\n+            pub const SIGABRT : c_int = 6;\n+            pub const SIGFPE : c_int = 8;\n+            pub const SIGKILL : c_int = 9;\n+            pub const SIGSEGV : c_int = 11;\n+            pub const SIGPIPE : c_int = 13;\n+            pub const SIGALRM : c_int = 14;\n+            pub const SIGTERM : c_int = 15;\n+\n+            pub const PROT_NONE : c_int = 0;\n+            pub const PROT_READ : c_int = 1;\n+            pub const PROT_WRITE : c_int = 2;\n+            pub const PROT_EXEC : c_int = 4;\n+\n+            pub const MAP_FILE : c_int = 0x0000;\n+            pub const MAP_SHARED : c_int = 0x0001;\n+            pub const MAP_PRIVATE : c_int = 0x0002;\n+            pub const MAP_FIXED : c_int = 0x0010;\n+            pub const MAP_ANON : c_int = 0x1000;\n+\n+            pub const MAP_FAILED : *mut c_void = -1 as *mut c_void;\n+\n+            pub const MCL_CURRENT : c_int = 0x0001;\n+            pub const MCL_FUTURE : c_int = 0x0002;\n+\n+            pub const MS_ASYNC : c_int = 0x0001;\n+            pub const MS_INVALIDATE : c_int = 0x0002;\n+            pub const MS_SYNC : c_int = 0x0010;\n+\n+            pub const MS_KILLPAGES : c_int = 0x0004;\n+            pub const MS_DEACTIVATE : c_int = 0x0008;\n+\n+            pub const EPERM : c_int = 1;\n+            pub const ENOENT : c_int = 2;\n+            pub const ESRCH : c_int = 3;\n+            pub const EINTR : c_int = 4;\n+            pub const EIO : c_int = 5;\n+            pub const ENXIO : c_int = 6;\n+            pub const E2BIG : c_int = 7;\n+            pub const ENOEXEC : c_int = 8;\n+            pub const EBADF : c_int = 9;\n+            pub const ECHILD : c_int = 10;\n+            pub const EDEADLK : c_int = 11;\n+            pub const ENOMEM : c_int = 12;\n+            pub const EACCES : c_int = 13;\n+            pub const EFAULT : c_int = 14;\n+            pub const ENOTBLK : c_int = 15;\n+            pub const EBUSY : c_int = 16;\n+            pub const EEXIST : c_int = 17;\n+            pub const EXDEV : c_int = 18;\n+            pub const ENODEV : c_int = 19;\n+            pub const ENOTDIR : c_int = 20;\n+            pub const EISDIR : c_int = 21;\n+            pub const EINVAL : c_int = 22;\n+            pub const ENFILE : c_int = 23;\n+            pub const EMFILE : c_int = 24;\n+            pub const ENOTTY : c_int = 25;\n+            pub const ETXTBSY : c_int = 26;\n+            pub const EFBIG : c_int = 27;\n+            pub const ENOSPC : c_int = 28;\n+            pub const ESPIPE : c_int = 29;\n+            pub const EROFS : c_int = 30;\n+            pub const EMLINK : c_int = 31;\n+            pub const EPIPE : c_int = 32;\n+            pub const EDOM : c_int = 33;\n+            pub const ERANGE : c_int = 34;\n+            pub const EAGAIN : c_int = 35;\n+            pub const EWOULDBLOCK : c_int = EAGAIN;\n+            pub const EINPROGRESS : c_int = 36;\n+            pub const EALREADY : c_int = 37;\n+            pub const ENOTSOCK : c_int = 38;\n+            pub const EDESTADDRREQ : c_int = 39;\n+            pub const EMSGSIZE : c_int = 40;\n+            pub const EPROTOTYPE : c_int = 41;\n+            pub const ENOPROTOOPT : c_int = 42;\n+            pub const EPROTONOSUPPORT : c_int = 43;\n+            pub const ESOCKTNOSUPPORT : c_int = 44;\n+            pub const ENOTSUP : c_int = 45;\n+            pub const EPFNOSUPPORT : c_int = 46;\n+            pub const EAFNOSUPPORT : c_int = 47;\n+            pub const EADDRINUSE : c_int = 48;\n+            pub const EADDRNOTAVAIL : c_int = 49;\n+            pub const ENETDOWN : c_int = 50;\n+            pub const ENETUNREACH : c_int = 51;\n+            pub const ENETRESET : c_int = 52;\n+            pub const ECONNABORTED : c_int = 53;\n+            pub const ECONNRESET : c_int = 54;\n+            pub const ENOBUFS : c_int = 55;\n+            pub const EISCONN : c_int = 56;\n+            pub const ENOTCONN : c_int = 57;\n+            pub const ESHUTDOWN : c_int = 58;\n+            pub const ETOOMANYREFS : c_int = 59;\n+            pub const ETIMEDOUT : c_int = 60;\n+            pub const ECONNREFUSED : c_int = 61;\n+            pub const ELOOP : c_int = 62;\n+            pub const ENAMETOOLONG : c_int = 63;\n+            pub const EHOSTDOWN : c_int = 64;\n+            pub const EHOSTUNREACH : c_int = 65;\n+            pub const ENOTEMPTY : c_int = 66;\n+            pub const EPROCLIM : c_int = 67;\n+            pub const EUSERS : c_int = 68;\n+            pub const EDQUOT : c_int = 69;\n+            pub const ESTALE : c_int = 70;\n+            pub const EREMOTE : c_int = 71;\n+            pub const EBADRPC : c_int = 72;\n+            pub const ERPCMISMATCH : c_int = 73;\n+            pub const EPROGUNAVAIL : c_int = 74;\n+            pub const EPROGMISMATCH : c_int = 75;\n+            pub const EPROCUNAVAIL : c_int = 76;\n+            pub const ENOLCK : c_int = 77;\n+            pub const ENOSYS : c_int = 78;\n+            pub const EFTYPE : c_int = 79;\n+            pub const EAUTH : c_int = 80;\n+            pub const ENEEDAUTH : c_int = 81;\n+            pub const EPWROFF : c_int = 82;\n+            pub const EDEVERR : c_int = 83;\n+            pub const EOVERFLOW : c_int = 84;\n+            pub const EBADEXEC : c_int = 85;\n+            pub const EBADARCH : c_int = 86;\n+            pub const ESHLIBVERS : c_int = 87;\n+            pub const EBADMACHO : c_int = 88;\n+            pub const ECANCELED : c_int = 89;\n+            pub const EIDRM : c_int = 90;\n+            pub const ENOMSG : c_int = 91;\n+            pub const EILSEQ : c_int = 92;\n+            pub const ENOATTR : c_int = 93;\n+            pub const EBADMSG : c_int = 94;\n+            pub const EMULTIHOP : c_int = 95;\n+            pub const ENODATA : c_int = 96;\n+            pub const ENOLINK : c_int = 97;\n+            pub const ENOSR : c_int = 98;\n+            pub const ENOSTR : c_int = 99;\n+            pub const EPROTO : c_int = 100;\n+            pub const ETIME : c_int = 101;\n+            pub const EOPNOTSUPP : c_int = 102;\n+            pub const ENOPOLICY : c_int = 103;\n+            pub const ENOTRECOVERABLE : c_int = 104;\n+            pub const EOWNERDEAD : c_int = 105;\n             pub const EQFULL : c_int = 106;\n             pub const ELAST : c_int = 106;\n         }\n@@ -4380,7 +5004,8 @@ pub mod funcs {\n               target_os = \"macos\",\n               target_os = \"ios\",\n               target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\"))]\n     pub mod posix88 {\n         pub mod stat_ {\n             use types::os::arch::c95::{c_char, c_int};\n@@ -4394,6 +5019,7 @@ pub mod funcs {\n                 #[cfg(any(target_os = \"linux\",\n                           target_os = \"freebsd\",\n                           target_os = \"dragonfly\",\n+                          target_os = \"openbsd\",\n                           target_os = \"android\",\n                           target_os = \"ios\"))]\n                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n@@ -4408,6 +5034,7 @@ pub mod funcs {\n                 #[cfg(any(target_os = \"linux\",\n                           target_os = \"freebsd\",\n                           target_os = \"dragonfly\",\n+                          target_os = \"openbsd\",\n                           target_os = \"android\",\n                           target_os = \"ios\"))]\n                 pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;\n@@ -4600,7 +5227,8 @@ pub mod funcs {\n               target_os = \"macos\",\n               target_os = \"ios\",\n               target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\"))]\n     pub mod posix01 {\n         pub mod stat_ {\n             use types::os::arch::c95::{c_char, c_int};\n@@ -4610,6 +5238,7 @@ pub mod funcs {\n                 #[cfg(any(target_os = \"linux\",\n                           target_os = \"freebsd\",\n                           target_os = \"dragonfly\",\n+                          target_os = \"openbsd\",\n                           target_os = \"android\",\n                           target_os = \"ios\"))]\n                 pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;\n@@ -4717,7 +5346,8 @@ pub mod funcs {\n               target_os = \"macos\",\n               target_os = \"ios\",\n               target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\"))]\n     pub mod posix08 {\n         pub mod unistd {\n         }\n@@ -4803,7 +5433,8 @@ pub mod funcs {\n     #[cfg(any(target_os = \"macos\",\n               target_os = \"ios\",\n               target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\"))]\n     pub mod bsd44 {\n         use types::common::c95::{c_void};\n         use types::os::arch::c95::{c_char, c_uchar, c_int, c_uint, c_ulong, size_t};\n@@ -4866,7 +5497,9 @@ pub mod funcs {\n         }\n     }\n \n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+    #[cfg(any(target_os = \"freebsd\",\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\"))]\n     pub mod extra {\n     }\n "}, {"sha": "34216518c21d2073bb61909101eae42b6c089c69", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -173,15 +173,15 @@\n #![feature(int_uint)]\n #![feature(core)]\n #![feature(io)]\n-#![feature(os)]\n #![feature(std_misc)]\n+#![feature(env)]\n \n use std::cell::RefCell;\n use std::fmt;\n use std::old_io::LineBufferedWriter;\n use std::old_io;\n use std::mem;\n-use std::os;\n+use std::env;\n use std::ptr;\n use std::rt;\n use std::slice;\n@@ -397,9 +397,9 @@ fn enabled(level: u32,\n /// This is not threadsafe at all, so initialization is performed through a\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n-    let (mut directives, filter) = match os::getenv(\"RUST_LOG\") {\n-        Some(spec) => directive::parse_logging_spec(&spec[]),\n-        None => (Vec::new(), None),\n+    let (mut directives, filter) = match env::var_string(\"RUST_LOG\") {\n+        Ok(spec) => directive::parse_logging_spec(&spec[]),\n+        Err(..) => (Vec::new(), None),\n     };\n \n     // Sort the provided directives by length of their name, this allows a"}, {"sha": "aef6301dad7782db6903df2a11fe851a5fa366f8", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -194,7 +194,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n impl Rand for ChaChaRng {\n     fn rand<R: Rng>(other: &mut R) -> ChaChaRng {\n         let mut key : [u32; KEY_WORDS] = [0; KEY_WORDS];\n-        for word in key.iter_mut() {\n+        for word in &mut key {\n             *word = other.gen();\n         }\n         SeedableRng::from_seed(key.as_slice())"}, {"sha": "4958784f614503cd031ff6e658d73a14e6cc7ca2", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -123,7 +123,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         // we convert the list from individual weights to cumulative\n         // weights so we can binary search. This *could* drop elements\n         // with weight == 0 as an optimisation.\n-        for item in items.iter_mut() {\n+        for item in &mut *items {\n             running_total = match running_total.checked_add(item.weight) {\n                 Some(n) => n,\n                 None => panic!(\"WeightedChoice::new called with a total weight \\\n@@ -305,7 +305,7 @@ mod tests {\n \n                 let mut rng = CountingRng { i: 0 };\n \n-                for &val in expected.iter() {\n+                for &val in &expected {\n                     assert_eq!(wc.ind_sample(&mut rng), val)\n                 }\n             }}"}, {"sha": "ab0b45e7d326891cd3df73a2f2b7e88b8f669c08", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -188,7 +188,7 @@ mod tests {\n                    let v: &[($ty, $ty)] = &[(0, 10),\n                                             (10, 127),\n                                             (Int::min_value(), Int::max_value())];\n-                   for &(low, high) in v.iter() {\n+                   for &(low, high) in v {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in 0u..1000 {\n                             let v = sampler.sample(&mut rng);\n@@ -214,7 +214,7 @@ mod tests {\n                                             (-1e35, -1e25),\n                                             (1e-35, 1e-25),\n                                             (-1e35, 1e35)];\n-                   for &(low, high) in v.iter() {\n+                   for &(low, high) in v {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in 0u..1000 {\n                             let v = sampler.sample(&mut rng);"}, {"sha": "d0f4afdde728a2e76a96631759b439744bed1c6c", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -134,7 +134,7 @@ impl IsaacRng {\n         }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        for &(mr_offset, m2_offset) in r.iter() {\n+        for &(mr_offset, m2_offset) in &r {\n \n             macro_rules! rngstepp {\n                 ($j:expr, $shift:expr) => {{\n@@ -373,7 +373,7 @@ impl Isaac64Rng {\n             }\n         }\n \n-        for &(mr_offset, m2_offset) in MP_VEC.iter() {\n+        for &(mr_offset, m2_offset) in &MP_VEC {\n             for base in (0..MIDPOINT / 4).map(|i| i * 4) {\n \n                 macro_rules! rngstepp {"}, {"sha": "5290e68033306c0da9423e99fb49dd4452d216b9", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -154,7 +154,7 @@ pub trait Rng : Sized {\n         // optimisations are on.\n         let mut count = 0;\n         let mut num = 0;\n-        for byte in dest.iter_mut() {\n+        for byte in dest {\n             if count == 0 {\n                 // we could micro-optimise here by generating a u32 if\n                 // we only need a few more bytes to fill the vector"}, {"sha": "75ac1b2cf44cc6bd758169e4c4773de08a1b671c", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -225,7 +225,7 @@ mod test {\n         // To test that `fill_bytes` actually did something, check that the\n         // average of `v` is not 0.\n         let mut sum = 0.0;\n-        for &x in v.iter() {\n+        for &x in &v {\n             sum += x as f64;\n         }\n         assert!(sum / v.len() as f64 != 0.0);"}, {"sha": "003248204335045969bb5b867fbedcc9ef01c140", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -23,16 +23,14 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n-\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n-#![feature(os)]\n+#![feature(env)]\n #![feature(path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "53054f462c8b6c0cd6eccc16c813a980c97f6638", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -227,7 +227,7 @@ impl LintPass for TypeLimits {\n                                 if (negative && v > (min.abs() as u64)) ||\n                                    (!negative && v > (max.abs() as u64)) {\n                                     cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                                 \"literal out of range for its type\");\n+                                                 &*format!(\"literal out of range for {:?}\", t));\n                                     return;\n                                 }\n                             }\n@@ -246,7 +246,7 @@ impl LintPass for TypeLimits {\n                         };\n                         if  lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                         \"literal out of range for its type\");\n+                                         &*format!(\"literal out of range for {:?}\", t));\n                         }\n                     },\n                     ty::ty_float(t) => {\n@@ -263,7 +263,7 @@ impl LintPass for TypeLimits {\n                         };\n                         if lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                         \"literal out of range for its type\");\n+                                         &*format!(\"literal out of range for {:?}\", t));\n                         }\n                     },\n                     _ => ()\n@@ -459,7 +459,7 @@ impl LintPass for ImproperCTypes {\n         }\n \n         fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n-            for input in decl.inputs.iter() {\n+            for input in &decl.inputs {\n                 check_ty(cx, &*input.ty);\n             }\n             if let ast::Return(ref ret_ty) = decl.output {\n@@ -469,7 +469,7 @@ impl LintPass for ImproperCTypes {\n \n         match it.node {\n             ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n-                for ni in nmod.items.iter() {\n+                for ni in &nmod.items {\n                     match ni.node {\n                         ast::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n                         ast::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n@@ -532,7 +532,7 @@ impl LintPass for BoxPointers {\n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n             ast::ItemStruct(ref struct_def, _) => {\n-                for struct_field in struct_def.fields.iter() {\n+                for struct_field in &struct_def.fields {\n                     self.check_heap_type(cx, struct_field.span,\n                                          ty::node_id_to_type(cx.tcx, struct_field.node.id));\n                 }\n@@ -592,7 +592,15 @@ impl LintPass for RawPointerDerive {\n             return\n         }\n         let did = match item.node {\n-            ast::ItemImpl(..) => {\n+            ast::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n+                // Deriving the Copy trait does not cause a warning\n+                if let &Some(ref trait_ref) = t_ref_opt {\n+                    let def_id = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n+                    if Some(def_id) == cx.tcx.lang_items.copy_trait() {\n+                        return\n+                    }\n+                }\n+\n                 match ty::node_id_to_type(cx.tcx, item.id).sty {\n                     ty::ty_enum(did, _) => did,\n                     ty::ty_struct(did, _) => did,\n@@ -683,7 +691,7 @@ impl LintPass for UnusedAttributes {\n             \"no_builtins\",\n         ];\n \n-        for &name in ATTRIBUTE_WHITELIST.iter() {\n+        for &name in ATTRIBUTE_WHITELIST {\n             if attr.check_name(name) {\n                 break;\n             }\n@@ -785,7 +793,7 @@ impl LintPass for UnusedResults {\n         }\n \n         fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n-            for attr in attrs.iter() {\n+            for attr in attrs {\n                 if attr.check_name(\"must_use\") {\n                     let mut msg = \"unused result which must be used\".to_string();\n                     // check for #[must_use=\"...\"]\n@@ -869,7 +877,7 @@ impl LintPass for NonCamelCaseTypes {\n             ast::ItemEnum(ref enum_definition, _) => {\n                 if has_extern_repr { return }\n                 self.check_case(cx, \"type\", it.ident, it.span);\n-                for variant in enum_definition.variants.iter() {\n+                for variant in &enum_definition.variants {\n                     self.check_case(cx, \"variant\", variant.node.name, variant.span);\n                 }\n             }\n@@ -878,7 +886,7 @@ impl LintPass for NonCamelCaseTypes {\n     }\n \n     fn check_generics(&mut self, cx: &Context, it: &ast::Generics) {\n-        for gen in it.ty_params.iter() {\n+        for gen in &*it.ty_params {\n             self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n         }\n     }\n@@ -1048,7 +1056,7 @@ impl LintPass for NonSnakeCase {\n \n     fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n             _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n-        for sf in s.fields.iter() {\n+        for sf in &s.fields {\n             if let ast::StructField_ { kind: ast::NamedField(ident, _), .. } = sf.node {\n                 self.check_snake_case(cx, \"structure field\", ident, sf.span);\n             }\n@@ -1346,7 +1354,7 @@ impl UnusedMut {\n         // avoid false warnings in match arms with multiple patterns\n \n         let mut mutables = FnvHashMap();\n-        for p in pats.iter() {\n+        for p in pats {\n             pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n@@ -1361,7 +1369,7 @@ impl UnusedMut {\n         }\n \n         let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-        for (_, v) in mutables.iter() {\n+        for (_, v) in &mutables {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n                 cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n                              \"variable does not need to be mutable\");\n@@ -1377,7 +1385,7 @@ impl LintPass for UnusedMut {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n-            for a in arms.iter() {\n+            for a in arms {\n                 self.check_unused_mut_pat(cx, &a.pats[])\n             }\n         }\n@@ -1394,7 +1402,7 @@ impl LintPass for UnusedMut {\n     fn check_fn(&mut self, cx: &Context,\n                 _: visit::FnKind, decl: &ast::FnDecl,\n                 _: &ast::Block, _: Span, _: ast::NodeId) {\n-        for a in decl.inputs.iter() {\n+        for a in &decl.inputs {\n             self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n     }\n@@ -1871,7 +1879,7 @@ impl LintPass for UnconditionalRecursion {\n             if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n                 let sess = cx.sess();\n                 // offer some help to the programmer.\n-                for call in self_call_spans.iter() {\n+                for call in &self_call_spans {\n                     sess.span_note(*call, \"recursive call site\")\n                 }\n                 sess.span_help(sp, \"a `loop` may express intention better if this is on purpose\")\n@@ -2006,7 +2014,7 @@ declare_lint! {\n \n declare_lint! {\n     pub UNUSED_FEATURES,\n-    Deny,\n+    Warn,\n     \"unused or unknown features found in crate-level #[feature] directives\"\n }\n "}, {"sha": "91dba90b0d2e2508d1da2c9e571ca0c7096fd6c1", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -116,7 +116,7 @@ impl LintStore {\n \n     pub fn register_pass(&mut self, sess: Option<&Session>,\n                          from_plugin: bool, pass: LintPassObject) {\n-        for &lint in pass.get_lints().iter() {\n+        for &lint in pass.get_lints() {\n             self.lints.push((*lint, from_plugin));\n \n             let id = LintId::of(*lint);\n@@ -260,7 +260,7 @@ impl LintStore {\n     }\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n-        for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n+        for &(ref lint_name, level) in &sess.opts.lint_opts {\n             match self.find_lint(&lint_name[], sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n@@ -329,7 +329,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n     // iterate over it mutably while passing `$cx` to the methods.\n     let mut passes = $cx.lints.passes.take().unwrap();\n-    for obj in passes.iter_mut() {\n+    for obj in &mut passes {\n         obj.$f($cx, $($args),*);\n     }\n     $cx.lints.passes = Some(passes);\n@@ -340,7 +340,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n pub fn gather_attrs(attrs: &[ast::Attribute])\n                     -> Vec<Result<(InternedString, Level, Span), Span>> {\n     let mut out = vec!();\n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         let level = match Level::from_str(attr.name().get()) {\n             None => continue,\n             Some(lvl) => lvl,\n@@ -357,7 +357,7 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n             }\n         };\n \n-        for meta in metas.iter() {\n+        for meta in metas {\n             out.push(match meta.node {\n                 ast::MetaWord(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n                 _ => Err(meta.span),\n@@ -417,11 +417,11 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n-    for note in note.into_iter() {\n+    if let Some(note) = note {\n         sess.note(&note[]);\n     }\n \n-    for span in def.into_iter() {\n+    if let Some(span) = def {\n         sess.span_note(span, \"lint level defined here\");\n     }\n }\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         // specified closure\n         let mut pushed = 0;\n \n-        for result in gather_attrs(attrs).into_iter() {\n+        for result in gather_attrs(attrs) {\n             let v = match result {\n                 Err(span) => {\n                     self.tcx.sess.span_err(span, \"malformed lint attribute\");\n@@ -519,7 +519,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                 }\n             };\n \n-            for (lint_id, level, span) in v.into_iter() {\n+            for (lint_id, level, span) in v {\n                 let now = self.lints.get_level_source(lint_id).0;\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n@@ -727,7 +727,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n         match self.tcx.sess.lints.borrow_mut().remove(&id) {\n             None => {}\n             Some(lints) => {\n-                for (lint_id, span, msg) in lints.into_iter() {\n+                for (lint_id, span, msg) in lints {\n                     self.span_lint(lint_id.lint, span, &msg[])\n                 }\n             }\n@@ -794,8 +794,8 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    for (id, v) in tcx.sess.lints.borrow().iter() {\n-        for &(lint, span, ref msg) in v.iter() {\n+    for (id, v) in &*tcx.sess.lints.borrow() {\n+        for &(lint, span, ref msg) in v {\n             tcx.sess.span_bug(span,\n                               format!(\"unprocessed lint {} at {}: {}\",\n                                       lint.as_str(), tcx.map.node_to_string(*id), *msg).as_slice())"}, {"sha": "a787369dc633c35e23b8973dfee31e08222e0838", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -162,7 +162,7 @@ impl<'a> CrateReader<'a> {\n             dump_crates(&self.sess.cstore);\n         }\n \n-        for &(ref name, kind) in self.sess.opts.libs.iter() {\n+        for &(ref name, kind) in &self.sess.opts.libs {\n             register_native_lib(self.sess, None, name.clone(), kind);\n         }\n     }\n@@ -235,7 +235,7 @@ impl<'a> CrateReader<'a> {\n                         None\n                     })\n                     .collect::<Vec<&ast::Attribute>>();\n-                for m in link_args.iter() {\n+                for m in &link_args {\n                     match m.value_str() {\n                         Some(linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n                         None => { /* fallthrough */ }\n@@ -250,7 +250,7 @@ impl<'a> CrateReader<'a> {\n                         None\n                     })\n                     .collect::<Vec<&ast::Attribute>>();\n-                for m in link_args.iter() {\n+                for m in &link_args {\n                     match m.meta_item_list() {\n                         Some(items) => {\n                             let kind = items.iter().find(|k| {\n@@ -330,6 +330,7 @@ impl<'a> CrateReader<'a> {\n                 if found {\n                     ret = Some(cnum);\n                 }\n+                return\n             }\n \n             // Alright, so we've gotten this far which means that `data` has the"}, {"sha": "619cfc1b52c09b4b96c98684f445b26089be6892", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -382,7 +382,7 @@ pub fn get_stability(cstore: &cstore::CStore,\n pub fn is_staged_api(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n     let attrs = decoder::get_crate_attributes(cdata.data());\n-    for attr in attrs.iter() {\n+    for attr in &attrs {\n         if attr.name().get() == \"staged_api\" {\n             match attr.node.value.node { ast::MetaWord(_) => return true, _ => (/*pass*/) }\n         }"}, {"sha": "0a3e173b35ee517cde4025249d01381356729d71", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -113,7 +113,7 @@ impl CStore {\n     pub fn iter_crate_data<I>(&self, mut i: I) where\n         I: FnMut(ast::CrateNum, &crate_metadata),\n     {\n-        for (&k, v) in self.metas.borrow().iter() {\n+        for (&k, v) in &*self.metas.borrow() {\n             i(k, &**v);\n         }\n     }\n@@ -122,7 +122,7 @@ impl CStore {\n     pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n         I: FnMut(ast::CrateNum, &crate_metadata, Option<CrateSource>),\n     {\n-        for (&k, v) in self.metas.borrow().iter() {\n+        for (&k, v) in &*self.metas.borrow() {\n             let origin = self.get_used_crate_source(k);\n             origin.as_ref().map(|cs| { assert!(k == cs.cnum); });\n             i(k, &**v, origin);\n@@ -167,12 +167,12 @@ impl CStore {\n                  ordering: &mut Vec<ast::CrateNum>) {\n             if ordering.contains(&cnum) { return }\n             let meta = cstore.get_crate_data(cnum);\n-            for (_, &dep) in meta.cnum_map.iter() {\n+            for (_, &dep) in &meta.cnum_map {\n                 visit(cstore, dep, ordering);\n             }\n             ordering.push(cnum);\n         };\n-        for (&num, _) in self.metas.borrow().iter() {\n+        for (&num, _) in &*self.metas.borrow() {\n             visit(self, num, &mut ordering);\n         }\n         ordering.reverse();"}, {"sha": "3a70490771eba706c670e72f935a80d88b81a954", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1022,7 +1022,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n     });\n \n     let mut impl_methods = Vec::new();\n-    for impl_method_id in impl_method_ids.iter() {\n+    for impl_method_id in &impl_method_ids {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data());\n         let family = item_family(impl_method_doc);\n         match family {\n@@ -1189,7 +1189,7 @@ fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n     try!(write!(out, \"=Crate Attributes ({})=\\n\", *hash));\n \n     let r = get_attributes(md);\n-    for attr in r.iter() {\n+    for attr in &r {\n         try!(write!(out, \"{}\\n\", pprust::attribute_to_string(attr)));\n     }\n \n@@ -1232,7 +1232,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n \n fn list_crate_deps(data: &[u8], out: &mut old_io::Writer) -> old_io::IoResult<()> {\n     try!(write!(out, \"=External Dependencies=\\n\"));\n-    for dep in get_crate_deps(data).iter() {\n+    for dep in &get_crate_deps(data) {\n         try!(write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash));\n     }\n     try!(write!(out, \"\\n\"));"}, {"sha": "ccd524a2c03955a950b3929a96dae1659de9fffc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -288,7 +288,7 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n fn encode_struct_fields(rbml_w: &mut Encoder,\n                         fields: &[ty::field_ty],\n                         origin: DefId) {\n-    for f in fields.iter() {\n+    for f in fields {\n         if f.name == special_idents::unnamed_field.name {\n             rbml_w.start_tag(tag_item_unnamed_field);\n         } else {\n@@ -316,7 +316,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n                                DefId { krate: ast::LOCAL_CRATE, node: id });\n-    for variant in variants.iter() {\n+    for variant in variants {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n             val: variant.node.id as i64,\n@@ -367,7 +367,7 @@ fn encode_path<PI: Iterator<Item=PathElem>>(rbml_w: &mut Encoder, path: PI) {\n     let path = path.collect::<Vec<_>>();\n     rbml_w.start_tag(tag_path);\n     rbml_w.wr_tagged_u32(tag_path_len, path.len() as u32);\n-    for pe in path.iter() {\n+    for pe in &path {\n         let tag = match *pe {\n             ast_map::PathMod(_) => tag_path_elem_mod,\n             ast_map::PathName(_) => tag_path_elem_name\n@@ -402,8 +402,8 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n     let impl_items = ecx.tcx.impl_items.borrow();\n     match ecx.tcx.inherent_impls.borrow().get(&exp.def_id) {\n         Some(implementations) => {\n-            for base_impl_did in implementations.iter() {\n-                for &method_did in (*impl_items)[*base_impl_did].iter() {\n+            for base_impl_did in &**implementations {\n+                for &method_did in &*(*impl_items)[*base_impl_did] {\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n@@ -431,7 +431,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           -> bool {\n     match ecx.tcx.trait_items_cache.borrow().get(&exp.def_id) {\n         Some(trait_items) => {\n-            for trait_item in trait_items.iter() {\n+            for trait_item in &**trait_items {\n                 if let ty::MethodTraitItem(ref m) = *trait_item {\n                     encode_reexported_static_method(rbml_w,\n                                                     exp,\n@@ -517,9 +517,9 @@ fn encode_reexports(ecx: &EncodeContext,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n     match ecx.reexports.get(&id) {\n-        Some(ref exports) => {\n+        Some(exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n-            for exp in exports.iter() {\n+            for exp in exports {\n                 debug!(\"(encoding info for module) reexport '{}' ({}/{}) for \\\n                         {}\",\n                        exp.name,\n@@ -559,7 +559,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n-    for item in md.items.iter() {\n+    for item in &md.items {\n         rbml_w.start_tag(tag_mod_child);\n         rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n@@ -665,9 +665,9 @@ fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n \n fn encode_provided_source(rbml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n-    for source in source_opt.iter() {\n+    if let Some(source) = source_opt {\n         rbml_w.start_tag(tag_item_method_provided_source);\n-        let s = def_to_string(*source);\n+        let s = def_to_string(source);\n         rbml_w.writer.write_all(s.as_bytes());\n         rbml_w.end_tag();\n     }\n@@ -684,7 +684,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n     let mut index = Vec::new();\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-    for field in fields.iter() {\n+    for field in fields {\n         let nm = field.name;\n         let id = field.id.node;\n \n@@ -783,7 +783,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.wr_tagged_u64(tag_region_param_def_index,\n                              param.index as u64);\n \n-        for &bound_region in param.bounds.iter() {\n+        for &bound_region in &param.bounds {\n             encode_region(ecx, rbml_w, bound_region);\n         }\n \n@@ -911,7 +911,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n fn encode_method_argument_names(rbml_w: &mut Encoder,\n                                 decl: &ast::FnDecl) {\n     rbml_w.start_tag(tag_method_argument_names);\n-    for arg in decl.inputs.iter() {\n+    for arg in &decl.inputs {\n         rbml_w.start_tag(tag_method_argument_name);\n         if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n             let name = token::get_ident(path1.node);\n@@ -926,7 +926,7 @@ fn encode_repr_attrs(rbml_w: &mut Encoder,\n                      ecx: &EncodeContext,\n                      attrs: &[ast::Attribute]) {\n     let mut repr_attrs = Vec::new();\n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n                                                 attr).into_iter());\n     }\n@@ -962,7 +962,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().get(&def_id) {\n         None => {}\n         Some(implementations) => {\n-            for &impl_def_id in implementations.iter() {\n+            for &impl_def_id in &**implementations {\n                 rbml_w.start_tag(tag_items_data_item_inherent_impl);\n                 encode_def_id(rbml_w, impl_def_id);\n                 rbml_w.end_tag();\n@@ -978,7 +978,7 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n     match ecx.tcx.trait_impls.borrow().get(&trait_def_id) {\n         None => {}\n         Some(implementations) => {\n-            for &impl_def_id in implementations.borrow().iter() {\n+            for &impl_def_id in &*implementations.borrow() {\n                 rbml_w.start_tag(tag_items_data_item_extension_impl);\n                 encode_def_id(rbml_w, impl_def_id);\n                 rbml_w.end_tag();\n@@ -1091,7 +1091,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n \n         // Encode all the items in this module.\n-        for foreign_item in fm.items.iter() {\n+        for foreign_item in &fm.items {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(&def_to_string(local_def(foreign_item.id))[]);\n             rbml_w.end_tag();\n@@ -1123,7 +1123,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs[]);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n-        for v in (*enum_definition).variants.iter() {\n+        for v in &enum_definition.variants {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n@@ -1216,7 +1216,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        for &item_def_id in items.iter() {\n+        for &item_def_id in items {\n             rbml_w.start_tag(tag_item_impl_item);\n             match item_def_id {\n                 ty::MethodTraitItemId(item_def_id) => {\n@@ -1230,7 +1230,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        for ast_trait_ref in opt_trait.iter() {\n+        if let Some(ref ast_trait_ref) = *opt_trait {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n@@ -1314,7 +1314,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, &item.attrs[]);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n+        for &method_def_id in &*ty::trait_item_def_ids(tcx, def_id) {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n                 ty::MethodTraitItemId(method_def_id) => {\n@@ -1589,7 +1589,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     T: Hash<SipHasher>,\n {\n     let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n-    for elt in index.into_iter() {\n+    for elt in index {\n         let mut s = SipHasher::new();\n         elt.val.hash(&mut s);\n         let h = s.finish() as uint;\n@@ -1599,10 +1599,10 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     rbml_w.start_tag(tag_index);\n     let mut bucket_locs = Vec::new();\n     rbml_w.start_tag(tag_index_buckets);\n-    for bucket in buckets.iter() {\n+    for bucket in &buckets {\n         bucket_locs.push(rbml_w.writer.tell().unwrap());\n         rbml_w.start_tag(tag_index_buckets_bucket);\n-        for elt in bucket.iter() {\n+        for elt in bucket {\n             rbml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             {\n@@ -1616,7 +1616,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     }\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_index_table);\n-    for pos in bucket_locs.iter() {\n+    for pos in &bucket_locs {\n         assert!(*pos < 0xffff_ffff);\n         let wr: &mut SeekableMemWriter = rbml_w.writer;\n         wr.write_be_u32(*pos as u32);\n@@ -1660,7 +1660,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n         rbml_w.start_tag(tag_meta_item_name);\n         rbml_w.writer.write_all(name.get().as_bytes());\n         rbml_w.end_tag();\n-        for inner_item in items.iter() {\n+        for inner_item in items {\n             encode_meta_item(rbml_w, &**inner_item);\n         }\n         rbml_w.end_tag();\n@@ -1670,7 +1670,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n \n fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     rbml_w.start_tag(tag_attributes);\n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         rbml_w.start_tag(tag_attribute);\n         rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n         encode_meta_item(rbml_w, &*attr.node.value);\n@@ -1694,7 +1694,7 @@ fn encode_paren_sugar(rbml_w: &mut Encoder, paren_sugar: bool) {\n \n fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[ast::Name]) {\n     rbml_w.start_tag(tag_associated_type_names);\n-    for &name in names.iter() {\n+    for &name in names {\n         rbml_w.wr_tagged_str(tag_associated_type_name, token::get_name(name).get());\n     }\n     rbml_w.end_tag();\n@@ -1726,7 +1726,7 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        for n in deps.iter() {\n+        for n in &deps {\n             assert_eq!(n.cnum, expected_cnum);\n             expected_cnum += 1;\n         }\n@@ -1740,7 +1740,7 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     // but is enough to get transitive crate dependencies working.\n     rbml_w.start_tag(tag_crate_deps);\n     let r = get_ordered_deps(cstore);\n-    for dep in r.iter() {\n+    for dep in &r {\n         encode_crate_dep(rbml_w, (*dep).clone());\n     }\n     rbml_w.end_tag();\n@@ -1749,8 +1749,8 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_lang_items);\n \n-    for (i, def_id) in ecx.tcx.lang_items.items() {\n-        for id in def_id.iter() {\n+    for (i, &def_id) in ecx.tcx.lang_items.items() {\n+        if let Some(id) = def_id {\n             if id.krate == ast::LOCAL_CRATE {\n                 rbml_w.start_tag(tag_lang_items_item);\n \n@@ -1773,7 +1773,7 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n         }\n     }\n \n-    for i in ecx.tcx.lang_items.missing.iter() {\n+    for i in &ecx.tcx.lang_items.missing {\n         rbml_w.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n     }\n \n@@ -1817,7 +1817,7 @@ fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n fn encode_macro_defs(rbml_w: &mut Encoder,\n                      krate: &ast::Crate) {\n     rbml_w.start_tag(tag_macro_defs);\n-    for def in krate.exported_macros.iter() {\n+    for def in &krate.exported_macros {\n         rbml_w.start_tag(tag_macro_def);\n \n         encode_name(rbml_w, def.ident.name);\n@@ -1911,7 +1911,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n                     rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n-    for item in krate.module.items.iter() {\n+    for item in &krate.module.items {\n         rbml_w.start_tag(tag_mod_child);\n         rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n@@ -1935,7 +1935,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_reachable_extern_fns);\n \n-    for id in ecx.reachable.iter() {\n+    for id in ecx.reachable {\n         if let Some(ast_map::NodeItem(i)) = ecx.tcx.map.find(*id) {\n             if let ast::ItemFn(_, _, abi, ref generics, _) = i.node {\n                 if abi != abi::Rust && !generics.is_type_parameterized() {\n@@ -2150,7 +2150,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n     stats.total_bytes = rbml_w.writer.tell().unwrap();\n \n     if tcx.sess.meta_stats() {\n-        for e in rbml_w.writer.get_ref().iter() {\n+        for e in rbml_w.writer.get_ref() {\n             if *e == 0 {\n                 stats.zero_bytes += 1;\n             }"}, {"sha": "1b2d82e68c19f2fbcb96f60fc937f898badbe0b6", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -13,9 +13,9 @@\n pub use self::FileMatch::*;\n \n use std::collections::HashSet;\n+use std::env;\n use std::old_io::fs::PathExtensions;\n use std::old_io::fs;\n-use std::os;\n \n use util::fs as myfs;\n use session::search_paths::{SearchPaths, PathKind};\n@@ -66,7 +66,7 @@ impl<'a> FileSearch<'a> {\n         // Try RUST_PATH\n         if !found {\n             let rustpath = rust_path();\n-            for path in rustpath.iter() {\n+            for path in &rustpath {\n                 let tlib_path = make_rustpkg_lib_path(\n                     self.sysroot, path, self.triple);\n                 debug!(\"is {} in visited_dirs? {}\", tlib_path.display(),\n@@ -194,7 +194,7 @@ pub fn get_or_default_sysroot() -> Path {\n             })\n     }\n \n-    match canonicalize(os::self_exe_name()) {\n+    match canonicalize(env::current_exe().ok()) {\n         Some(mut p) => { p.pop(); p.pop(); p }\n         None => panic!(\"can't determine value for sysroot\")\n     }\n@@ -207,7 +207,7 @@ static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n \n /// Returns RUST_PATH as a string, without default paths added\n pub fn get_rust_path() -> Option<String> {\n-    os::getenv(\"RUST_PATH\").map(|x| x.to_string())\n+    env::var_string(\"RUST_PATH\").ok()\n }\n \n /// Returns the value of RUST_PATH, as a list\n@@ -224,7 +224,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         None => Vec::new()\n     };\n-    let mut cwd = os::getcwd().unwrap();\n+    let mut cwd = env::current_dir().unwrap();\n     // now add in default entries\n     let cwd_dot_rust = cwd.join(\".rust\");\n     if !env_rust_path.contains(&cwd_dot_rust) {\n@@ -243,8 +243,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         cwd.pop();\n     }\n-    let h = os::homedir();\n-    for h in h.iter() {\n+    if let Some(h) = env::home_dir() {\n         let p = h.join(\".rust\");\n         if !env_rust_path.contains(&p) && p.exists() {\n             env_rust_path.push(p);"}, {"sha": "2fb5a6b64a6520b244f041346fc643b860fa5636", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -425,7 +425,7 @@ impl<'a> Context<'a> {\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n         let mut libraries = Vec::new();\n-        for (_hash, (rlibs, dylibs)) in candidates.into_iter() {\n+        for (_hash, (rlibs, dylibs)) in candidates {\n             let mut metadata = None;\n             let rlib = self.extract_one(rlibs, \"rlib\", &mut metadata);\n             let dylib = self.extract_one(dylibs, \"dylib\", &mut metadata);\n@@ -452,7 +452,7 @@ impl<'a> Context<'a> {\n                     &format!(\"multiple matching crates for `{}`\",\n                             self.crate_name)[]);\n                 self.sess.note(\"candidates:\");\n-                for lib in libraries.iter() {\n+                for lib in &libraries {\n                     match lib.dylib {\n                         Some((ref p, _)) => {\n                             self.sess.note(&format!(\"path: {}\",\n@@ -501,7 +501,7 @@ impl<'a> Context<'a> {\n             }\n         }\n \n-        for (lib, kind) in m.into_iter() {\n+        for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let metadata = match get_metadata_section(self.target.options.is_like_osx,\n                                                       &lib) {\n@@ -610,7 +610,7 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashMap::new();\n         let mut dylibs = HashMap::new();\n         {\n-            let mut locs = locs.iter().map(|l| Path::new(&l[])).filter(|loc| {\n+            let locs = locs.iter().map(|l| Path::new(&l[])).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n                                      self.crate_name, loc.display())[]);"}, {"sha": "4c0aefaf83d9721863ba1972379c3047b4b7fc18", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -249,7 +249,7 @@ fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n     F: FnMut(&mut PState<'a, 'tcx>) -> T,\n {\n     let mut r = VecPerParamSpace::empty();\n-    for &space in subst::ParamSpace::all().iter() {\n+    for &space in &subst::ParamSpace::all() {\n         assert_eq!(next(st), '[');\n         while peek(st) != ']' {\n             r.push(space, f(st));"}, {"sha": "f8081e2c3098ea84056221c689c67994bd87f786", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -97,7 +97,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         }\n         ty::ty_tup(ref ts) => {\n             mywrite!(w, \"T[\");\n-            for t in ts.iter() { enc_ty(w, cx, *t); }\n+            for t in ts { enc_ty(w, cx, *t); }\n             mywrite!(w, \"]\");\n         }\n         ty::ty_uniq(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n@@ -206,9 +206,9 @@ fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut SeekableMemWriter,\n                                            mut op: F) where\n     F: FnMut(&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T),\n {\n-    for &space in subst::ParamSpace::all().iter() {\n+    for &space in &subst::ParamSpace::all() {\n         mywrite!(w, \"[\");\n-        for t in v.get_slice(space).iter() {\n+        for t in v.get_slice(space) {\n             op(w, cx, t);\n         }\n         mywrite!(w, \"]\");\n@@ -337,7 +337,7 @@ pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                         fsig: &ty::PolyFnSig<'tcx>) {\n     mywrite!(w, \"[\");\n-    for ty in fsig.0.inputs.iter() {\n+    for ty in &fsig.0.inputs {\n         enc_ty(w, cx, *ty);\n     }\n     mywrite!(w, \"]\");\n@@ -357,7 +357,7 @@ fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n }\n \n pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n-    for bound in bs.iter() {\n+    for bound in bs {\n         match bound {\n             ty::BoundSend => mywrite!(w, \"S\"),\n             ty::BoundSized => mywrite!(w, \"Z\"),\n@@ -383,17 +383,17 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                             bs: &ty::ParamBounds<'tcx>) {\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n \n-    for &r in bs.region_bounds.iter() {\n+    for &r in &bs.region_bounds {\n         mywrite!(w, \"R\");\n         enc_region(w, cx, r);\n     }\n \n-    for tp in bs.trait_bounds.iter() {\n+    for tp in &bs.trait_bounds {\n         mywrite!(w, \"I\");\n         enc_trait_ref(w, cx, &*tp.0);\n     }\n \n-    for tp in bs.projection_bounds.iter() {\n+    for tp in &bs.projection_bounds {\n         mywrite!(w, \"P\");\n         enc_projection_predicate(w, cx, &tp.0);\n     }"}, {"sha": "4130195ae40d1fc0d133587e717f8ed115a37975", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -766,7 +766,7 @@ fn encode_vec_per_param_space<T, F>(rbml_w: &mut Encoder,\n                                     mut f: F) where\n     F: FnMut(&mut Encoder, &T),\n {\n-    for &space in subst::ParamSpace::all().iter() {\n+    for &space in &subst::ParamSpace::all() {\n         rbml_w.emit_from_vec(v.get_slice(space),\n                              |rbml_w, n| Ok(f(rbml_w, n))).unwrap();\n     }\n@@ -1156,14 +1156,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n-    for def in tcx.def_map.borrow().get(&id).iter() {\n+    if let Some(def) = tcx.def_map.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_def, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| (*def).encode(rbml_w).unwrap());\n         })\n     }\n \n-    for &ty in tcx.node_types.borrow().get(&id).iter() {\n+    if let Some(ty) = tcx.node_types.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1172,7 +1172,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &item_substs in tcx.item_substs.borrow().get(&id).iter() {\n+    if let Some(item_substs) = tcx.item_substs.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1181,7 +1181,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &fv in tcx.freevars.borrow().get(&id).iter() {\n+    if let Some(fv) = tcx.freevars.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1191,7 +1191,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             })\n         });\n \n-        for freevar in fv.iter() {\n+        for freevar in fv {\n             rbml_w.tag(c::tag_table_upvar_capture_map, |rbml_w| {\n                 rbml_w.id(id);\n                 rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1209,7 +1209,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-    for &type_scheme in tcx.tcache.borrow().get(&lid).iter() {\n+    if let Some(type_scheme) = tcx.tcache.borrow().get(&lid) {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1218,7 +1218,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &type_param_def in tcx.ty_param_defs.borrow().get(&id).iter() {\n+    if let Some(type_param_def) = tcx.ty_param_defs.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_param_defs, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1228,7 +1228,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let method_call = MethodCall::expr(id);\n-    for &method in tcx.method_map.borrow().get(&method_call).iter() {\n+    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1237,7 +1237,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &trait_ref in tcx.object_cast_map.borrow().get(&id).iter() {\n+    if let Some(trait_ref) = tcx.object_cast_map.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1246,11 +1246,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &adjustment in tcx.adjustments.borrow().get(&id).iter() {\n+    if let Some(adjustment) = tcx.adjustments.borrow().get(&id) {\n         match *adjustment {\n             _ if ty::adjust_is_object(adjustment) => {\n                 let method_call = MethodCall::autoobject(id);\n-                for &method in tcx.method_map.borrow().get(&method_call).iter() {\n+                if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n                     rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                         rbml_w.id(id);\n                         rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1263,7 +1263,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                 assert!(!ty::adjust_is_object(adjustment));\n                 for autoderef in 0..adj.autoderefs {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n-                    for &method in tcx.method_map.borrow().get(&method_call).iter() {\n+                    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n                             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1287,7 +1287,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &closure_type in tcx.closure_tys.borrow().get(&ast_util::local_def(id)).iter() {\n+    if let Some(closure_type) = tcx.closure_tys.borrow().get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1296,11 +1296,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &&closure_kind in tcx.closure_kinds.borrow().get(&ast_util::local_def(id)).iter() {\n+    if let Some(closure_kind) = tcx.closure_kinds.borrow().get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                encode_closure_kind(rbml_w, closure_kind)\n+                encode_closure_kind(rbml_w, *closure_kind)\n             })\n         })\n     }"}, {"sha": "d39b94a202e4ae1ab12648d14fbbcfaf51928115", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -68,7 +68,7 @@ fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n-        for stmt in blk.stmts.iter() {\n+        for stmt in &blk.stmts {\n             stmts_exit = self.stmt(&**stmt, stmts_exit);\n         }\n \n@@ -166,7 +166,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             self.pat(&*pats[0], pred)\n         } else {\n             let collect = self.add_dummy_node(&[]);\n-            for pat in pats.iter() {\n+            for pat in pats {\n                 let pat_exit = self.pat(&**pat, pred);\n                 self.add_contained_edge(pat_exit, collect);\n             }\n@@ -325,7 +325,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n                 let expr_exit = self.add_node(expr.id, &[]);\n                 let mut cond_exit = discr_exit;\n-                for arm in arms.iter() {\n+                for arm in arms {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n                     let pats_exit = self.pats_any(&arm.pats[],\n                                                   cond_exit);            // 3\n@@ -522,7 +522,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             assert!(!self.exit_map.contains_key(&id));\n             self.exit_map.insert(id, node);\n         }\n-        for &pred in preds.iter() {\n+        for &pred in preds {\n             self.add_contained_edge(pred, node);\n         }\n         node\n@@ -574,7 +574,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             Some(_) => {\n                 match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(&def::DefLabel(loop_id)) => {\n-                        for l in self.loop_scopes.iter() {\n+                        for l in &self.loop_scopes {\n                             if l.loop_id == loop_id {\n                                 return *l;\n                             }"}, {"sha": "925bd5b6395beea35e6a2b718cb4410563c69b61", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n             }\n             ast::ItemEnum(ref enum_definition, _) => {\n                 self.inside_const(|v| {\n-                    for var in enum_definition.variants.iter() {\n+                    for var in &enum_definition.variants {\n                         if let Some(ref ex) = var.node.disr_expr {\n                             v.visit_expr(&**ex);\n                         }\n@@ -137,7 +137,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n         }\n         ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n-            for stmt in block.stmts.iter() {\n+            for stmt in &block.stmts {\n                 let block_span_err = |&: span|\n                     span_err!(v.tcx.sess, span, E0016,\n                               \"blocks in constants are limited to items and \\"}, {"sha": "38084d1c2c06fe42aa067491284e23e4a7a5707c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -77,7 +77,7 @@ impl<'a> fmt::Debug for Matrix<'a> {\n         let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n         let br = repeat('+').take(total_width).collect::<String>();\n         try!(write!(f, \"{}\\n\", br));\n-        for row in pretty_printed_matrix.into_iter() {\n+        for row in pretty_printed_matrix {\n             try!(write!(f, \"+\"));\n             for (column, pat_str) in row.into_iter().enumerate() {\n                 try!(write!(f, \" \"));\n@@ -157,7 +157,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n         ast::ExprMatch(ref scrut, ref arms, source) => {\n-            for arm in arms.iter() {\n+            for arm in arms {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n@@ -285,8 +285,8 @@ fn check_arms(cx: &MatchCheckCtxt,\n               source: ast::MatchSource) {\n     let mut seen = Matrix(vec![]);\n     let mut printed_if_let_err = false;\n-    for &(ref pats, guard) in arms.iter() {\n-        for pat in pats.iter() {\n+    for &(ref pats, guard) in arms {\n+        for pat in pats {\n             let v = vec![&**pat];\n \n             match is_useful(cx, &seen, &v[], LeaveOutWitness) {\n@@ -979,7 +979,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n \n     visit::walk_fn(cx, kind, decl, body, sp);\n \n-    for input in decl.inputs.iter() {\n+    for input in &decl.inputs {\n         is_refutable(cx, &*input.pat, |pat| {\n             span_err!(cx.tcx.sess, input.pat.span, E0006,\n                 \"refutable pattern in function argument: `{}` not covered\",\n@@ -1012,7 +1012,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     let tcx = cx.tcx;\n     let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n-    for pat in pats.iter() {\n+    for pat in pats {\n         pat_bindings(def_map, &**pat, |bm, _, span, _path| {\n             match bm {\n                 ast::BindByRef(_) => {\n@@ -1039,7 +1039,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         }\n     };\n \n-    for pat in pats.iter() {\n+    for pat in pats {\n         walk_pat(&**pat, |p| {\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {"}, {"sha": "fa5d5227be535394e135d200740ec5b462011969", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -104,7 +104,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                             -> Option<&'a Expr> {\n     fn variant_expr<'a>(variants: &'a [P<ast::Variant>], id: ast::NodeId)\n                         -> Option<&'a Expr> {\n-        for variant in variants.iter() {\n+        for variant in variants {\n             if variant.node.id == id {\n                 return variant.node.disr_expr.as_ref().map(|e| &**e);\n             }"}, {"sha": "8f5906db589003dd27aaa7292e796b6c258e6921", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             let mut orig_kills = self.kills[start.. end].to_vec();\n \n             let mut changed = false;\n-            for &node_id in edge.data.exiting_scopes.iter() {\n+            for &node_id in &edge.data.exiting_scopes {\n                 let opt_cfg_idx = self.nodeid_to_index.get(&node_id).map(|&i|i);\n                 match opt_cfg_idx {\n                     Some(cfg_idx) => {\n@@ -501,7 +501,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n \n     fn reset(&mut self, bits: &mut [uint]) {\n         let e = if self.dfcx.oper.initial_value() {uint::MAX} else {0};\n-        for b in bits.iter_mut() {\n+        for b in bits {\n             *b = e;\n         }\n     }\n@@ -550,7 +550,7 @@ fn bits_to_string(words: &[uint]) -> String {\n \n     // Note: this is a little endian printout of bytes.\n \n-    for &word in words.iter() {\n+    for &word in words {\n         let mut v = word;\n         for _ in 0..uint::BYTES {\n             result.push(sep);"}, {"sha": "4478e3270874dc43b8642a64b563f260d40afb68", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             }\n         };\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n-        for pat in pats.iter() {\n+        for pat in pats {\n             let field_id = fields.iter()\n                 .find(|field| field.name == pat.node.ident.name).unwrap().id;\n             self.live_symbols.insert(field_id.node);\n@@ -318,7 +318,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     }\n \n     let dead_code = lint::builtin::DEAD_CODE.name_lower();\n-    for attr in lint::gather_attrs(attrs).into_iter() {\n+    for attr in lint::gather_attrs(attrs) {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n                 if name.get() == dead_code => return true,\n@@ -356,7 +356,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n                 self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n             }\n             ast::ItemImpl(_, _, _, Some(ref _trait_ref), _, ref impl_items) => {\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         ast::MethodImplItem(ref method) => {\n                             self.worklist.push(method.id);\n@@ -397,10 +397,10 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n     // depending on whether a crate is built as bin or lib, and we want\n     // the warning to be consistent, we also seed the worklist with\n     // exported symbols.\n-    for id in exported_items.iter() {\n+    for id in exported_items {\n         worklist.push(*id);\n     }\n-    for id in reachable_symbols.iter() {\n+    for id in reachable_symbols {\n         worklist.push(*id);\n     }\n \n@@ -499,8 +499,8 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         match self.tcx.inherent_impls.borrow().get(&local_def(id)) {\n             None => (),\n             Some(impl_list) => {\n-                for impl_did in impl_list.iter() {\n-                    for item_did in (*impl_items)[*impl_did].iter() {\n+                for impl_did in &**impl_list {\n+                    for item_did in &(*impl_items)[*impl_did] {\n                         if self.live_symbols.contains(&item_did.def_id()\n                                                                .node) {\n                             return true;\n@@ -536,7 +536,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         } else {\n             match item.node {\n                 ast::ItemEnum(ref enum_def, _) => {\n-                    for variant in enum_def.variants.iter() {\n+                    for variant in &enum_def.variants {\n                         if self.should_warn_about_variant(&variant.node) {\n                             self.warn_dead_code(variant.node.id, variant.span,\n                                                 variant.node.name, \"variant\");"}, {"sha": "6d35a82d153cd6c5151e9fedd428c0ae963364e6", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -85,7 +85,7 @@ pub type Dependencies = FnvHashMap<config::CrateType, DependencyList>;\n \n pub fn calculate(tcx: &ty::ctxt) {\n     let mut fmts = tcx.dependency_formats.borrow_mut();\n-    for &ty in tcx.sess.crate_types.borrow().iter() {\n+    for &ty in &*tcx.sess.crate_types.borrow() {\n         fmts.insert(ty, calculate_type(&tcx.sess, ty));\n     }\n     tcx.sess.abort_if_errors();\n@@ -148,7 +148,7 @@ fn calculate_type(sess: &session::Session,\n             debug!(\"adding dylib: {}\", data.name);\n             add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n             let deps = csearch::get_dylib_dependency_formats(&sess.cstore, cnum);\n-            for &(depnum, style) in deps.iter() {\n+            for &(depnum, style) in &deps {\n                 debug!(\"adding {:?}: {}\", style,\n                        sess.cstore.get_crate_data(depnum).name.clone());\n                 add_library(sess, depnum, style, &mut formats);"}, {"sha": "24073848edf541eb353b03563a231d3be6e613c8", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -139,7 +139,7 @@ fn configure_main(this: &mut EntryContext) {\n                                but you have one or more functions named 'main' that are not \\\n                                defined at the crate level. Either move the definition or \\\n                                attach the `#[main]` attribute to override this behavior.\");\n-            for &(_, span) in this.non_main_fns.iter() {\n+            for &(_, span) in &this.non_main_fns {\n                 this.session.span_note(span, \"here is a function named 'main'\");\n             }\n             this.session.abort_if_errors();"}, {"sha": "44a816eb2f803c330e7ce9661eae3cd6d4d52a81", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -342,7 +342,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_arg_patterns(&mut self,\n                          decl: &ast::FnDecl,\n                          body: &ast::Block) {\n-        for arg in decl.inputs.iter() {\n+        for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n \n             let fn_body_scope = region::CodeExtent::from_node_id(body.id);\n@@ -372,7 +372,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn consume_exprs(&mut self, exprs: &Vec<P<ast::Expr>>) {\n-        for expr in exprs.iter() {\n+        for expr in exprs {\n             self.consume_expr(&**expr);\n         }\n     }\n@@ -476,7 +476,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             ast::ExprIf(ref cond_expr, ref then_blk, ref opt_else_expr) => {\n                 self.consume_expr(&**cond_expr);\n                 self.walk_block(&**then_blk);\n-                for else_expr in opt_else_expr.iter() {\n+                if let Some(ref else_expr) = *opt_else_expr {\n                     self.consume_expr(&**else_expr);\n                 }\n             }\n@@ -490,7 +490,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n-                for arm in arms.iter() {\n+                for arm in arms {\n                     let mode = self.arm_move_mode(discr_cmt.clone(), arm);\n                     let mode = mode.match_mode();\n                     self.walk_arm(discr_cmt.clone(), arm, mode);\n@@ -511,11 +511,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprInlineAsm(ref ia) => {\n-                for &(_, ref input) in ia.inputs.iter() {\n+                for &(_, ref input) in &ia.inputs {\n                     self.consume_expr(&**input);\n                 }\n \n-                for &(_, ref output, is_rw) in ia.outputs.iter() {\n+                for &(_, ref output, is_rw) in &ia.outputs {\n                     self.mutate_expr(expr, &**output,\n                                            if is_rw { WriteAndRead } else { JustWrite });\n                 }\n@@ -572,7 +572,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprRet(ref opt_expr) => {\n-                for expr in opt_expr.iter() {\n+                if let Some(ref expr) = *opt_expr {\n                     self.consume_expr(&**expr);\n                 }\n             }\n@@ -715,11 +715,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_block(&mut self, blk: &ast::Block) {\n         debug!(\"walk_block(blk.id={})\", blk.id);\n \n-        for stmt in blk.stmts.iter() {\n+        for stmt in &blk.stmts {\n             self.walk_stmt(&**stmt);\n         }\n \n-        for tail_expr in blk.expr.iter() {\n+        if let Some(ref tail_expr) = blk.expr {\n             self.consume_expr(&**tail_expr);\n         }\n     }\n@@ -729,7 +729,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         fields: &Vec<ast::Field>,\n                         opt_with: &Option<P<ast::Expr>>) {\n         // Consume the expressions supplying values for each field.\n-        for field in fields.iter() {\n+        for field in fields {\n             self.consume_expr(&*field.expr);\n         }\n \n@@ -762,7 +762,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         };\n \n         // Consume those fields of the with expression that are needed.\n-        for with_field in with_fields.iter() {\n+        for with_field in &with_fields {\n             if !contains_field_named(with_field, fields) {\n                 let cmt_field = self.mc.cat_field(&*with_expr,\n                                                   with_cmt.clone(),\n@@ -908,7 +908,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         match pass_args {\n             PassArgs::ByValue => {\n                 self.consume_expr(receiver);\n-                for &arg in rhs.iter() {\n+                for &arg in &rhs {\n                     self.consume_expr(arg);\n                 }\n \n@@ -926,26 +926,26 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         let r = ty::ReScope(region::CodeExtent::from_node_id(expr.id));\n         let bk = ty::ImmBorrow;\n \n-        for &arg in rhs.iter() {\n+        for &arg in &rhs {\n             self.borrow_expr(arg, r, bk, OverloadedOperator);\n         }\n         return true;\n     }\n \n     fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) -> TrackMatchMode<Span> {\n         let mut mode = Unknown;\n-        for pat in arm.pats.iter() {\n+        for pat in &arm.pats {\n             self.determine_pat_move_mode(discr_cmt.clone(), &**pat, &mut mode);\n         }\n         mode\n     }\n \n     fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm, mode: MatchMode) {\n-        for pat in arm.pats.iter() {\n+        for pat in &arm.pats {\n             self.walk_pat(discr_cmt.clone(), &**pat, mode);\n         }\n \n-        for guard in arm.guard.iter() {\n+        if let Some(ref guard) = arm.guard {\n             self.consume_expr(&**guard);\n         }\n \n@@ -1195,7 +1195,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n \n         ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n-            for freevar in freevars.iter() {\n+            for freevar in freevars {\n                 let id_var = freevar.def.def_id().node;\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };"}, {"sha": "8cb2774f7dff8290ebba032426df06f65eda5b83", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -116,7 +116,7 @@ pub trait Combine<'tcx> : Sized {\n     {\n         let mut substs = subst::Substs::empty();\n \n-        for &space in subst::ParamSpace::all().iter() {\n+        for &space in &subst::ParamSpace::all() {\n             let a_tps = a_subst.types.get_slice(space);\n             let b_tps = b_subst.types.get_slice(space);\n             let tps = try!(self.tps(space, a_tps, b_tps));\n@@ -129,7 +129,7 @@ pub trait Combine<'tcx> : Sized {\n             }\n \n             (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n-                for &space in subst::ParamSpace::all().iter() {\n+                for &space in &subst::ParamSpace::all() {\n                     let a_regions = a.get_slice(space);\n                     let b_regions = b.get_slice(space);\n \n@@ -139,7 +139,7 @@ pub trait Combine<'tcx> : Sized {\n                             variances.regions.get_slice(space)\n                         }\n                         None => {\n-                            for _ in a_regions.iter() {\n+                            for _ in a_regions {\n                                 invariance.push(ty::Invariant);\n                             }\n                             &invariance[]"}, {"sha": "17b62e463dae3d17ec2d3428707e7f9bbdd8fa88", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -170,7 +170,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             errors: &Vec<RegionResolutionError<'tcx>>) {\n         let p_errors = self.process_errors(errors);\n         let errors = if p_errors.is_empty() { errors } else { &p_errors };\n-        for error in errors.iter() {\n+        for error in errors {\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     self.report_concrete_failure(origin, sub, sup);\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut trace_origins = Vec::new();\n         let mut same_regions = Vec::new();\n         let mut processed_errors = Vec::new();\n-        for error in errors.iter() {\n+        for error in errors {\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     debug!(\"processing ConcreteFailure\");\n@@ -257,7 +257,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n         if !same_regions.is_empty() {\n             let common_scope_id = same_regions[0].scope_id;\n-            for sr in same_regions.iter() {\n+            for sr in &same_regions {\n                 // Since ProcessedErrors is used to reconstruct the function\n                 // declaration, we want to make sure that they are, in fact,\n                 // from the same scope\n@@ -335,7 +335,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   same_frs: &FreeRegionsFromSameFn) {\n             let scope_id = same_frs.scope_id;\n             let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n-            for sr in same_regions.iter_mut() {\n+            for sr in &mut *same_regions {\n                 if sr.contains(&sup_fr.bound_region)\n                    && scope_id == sr.scope_id {\n                     sr.push(sub_fr.bound_region);\n@@ -796,11 +796,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                var_origins: &[RegionVariableOrigin],\n                                trace_origins: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n                                same_regions: &[SameRegions]) {\n-        for vo in var_origins.iter() {\n+        for vo in var_origins {\n             self.report_inference_failure(vo.clone());\n         }\n         self.give_suggestion(same_regions);\n-        for &(ref trace, terr) in trace_origins.iter() {\n+        for &(ref trace, terr) in trace_origins {\n             self.report_type_error(trace.clone(), &terr);\n         }\n     }\n@@ -916,7 +916,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let mut ty_params = self.generics.ty_params.clone();\n         let where_clause = self.generics.where_clause.clone();\n         let mut kept_lifetimes = HashSet::new();\n-        for sr in self.same_regions.iter() {\n+        for sr in self.same_regions {\n             self.cur_anon.set(0);\n             self.offset_cur_anon();\n             let (anon_nums, region_names) =\n@@ -958,7 +958,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             // vector of string and then sort them. However, it makes the\n             // choice of lifetime name deterministic and thus easier to test.\n             let mut names = Vec::new();\n-            for rn in region_names.iter() {\n+            for rn in region_names {\n                 let lt_name = token::get_name(*rn).get().to_string();\n                 names.push(lt_name);\n             }\n@@ -973,7 +973,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                    -> (HashSet<u32>, HashSet<ast::Name>) {\n         let mut anon_nums = HashSet::new();\n         let mut region_names = HashSet::new();\n-        for br in same_regions.regions.iter() {\n+        for br in &same_regions.regions {\n             match *br {\n                 ty::BrAnon(i) => {\n                     anon_nums.insert(i);\n@@ -989,8 +989,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n     fn extract_all_region_names(&self) -> HashSet<ast::Name> {\n         let mut all_region_names = HashSet::new();\n-        for sr in self.same_regions.iter() {\n-            for br in sr.regions.iter() {\n+        for sr in self.same_regions {\n+            for br in &sr.regions {\n                 match *br {\n                     ty::BrNamed(_, name) => {\n                         all_region_names.insert(name);\n@@ -1123,11 +1123,11 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         where_clause: ast::WhereClause)\n                         -> ast::Generics {\n         let mut lifetimes = Vec::new();\n-        for lt in add.iter() {\n+        for lt in add {\n             lifetimes.push(ast::LifetimeDef { lifetime: *lt,\n                                               bounds: Vec::new() });\n         }\n-        for lt in generics.lifetimes.iter() {\n+        for lt in &generics.lifetimes {\n             if keep.contains(&lt.lifetime.name) ||\n                 !remove.contains(&lt.lifetime.name) {\n                 lifetimes.push((*lt).clone());\n@@ -1147,7 +1147,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                        region_names: &HashSet<ast::Name>)\n                        -> Vec<ast::Arg> {\n         let mut new_inputs = Vec::new();\n-        for arg in inputs.iter() {\n+        for arg in inputs {\n             let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n                                                        anon_nums, region_names);\n             let possibly_new_arg = ast::Arg {\n@@ -1729,7 +1729,7 @@ struct LifeGiver {\n impl LifeGiver {\n     fn with_taken(taken: &[ast::LifetimeDef]) -> LifeGiver {\n         let mut taken_ = HashSet::new();\n-        for lt in taken.iter() {\n+        for lt in taken {\n             let lt_name = token::get_name(lt.lifetime.name).get().to_string();\n             taken_.insert(lt_name);\n         }"}, {"sha": "e4eecd919c82b8245d6dbf106d65316f82062729", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -176,7 +176,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             // in both A and B.  Replace the variable with the \"first\"\n             // bound region from A that we find it to be associated\n             // with.\n-            for (a_br, a_r) in a_map.iter() {\n+            for (a_br, a_r) in a_map {\n                 if tainted.iter().any(|x| x == a_r) {\n                     debug!(\"generalize_region(r0={:?}): \\\n                             replacing with {:?}, tainted={:?}\",\n@@ -258,7 +258,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             let mut a_r = None;\n             let mut b_r = None;\n             let mut only_new_vars = true;\n-            for r in tainted.iter() {\n+            for r in &tainted {\n                 if is_var_in_set(a_vars, *r) {\n                     if a_r.is_some() {\n                         return fresh_bound_variable(infcx, debruijn);\n@@ -315,7 +315,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                       a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n                       r: ty::Region) -> ty::Region\n         {\n-            for (a_br, a_r) in a_map.iter() {\n+            for (a_br, a_r) in a_map {\n                 if *a_r == r {\n                     return ty::ReLateBound(ty::DebruijnIndex::new(1), *a_br);\n                 }\n@@ -497,9 +497,9 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n            skol_map.repr(infcx.tcx));\n \n     let new_vars = infcx.region_vars_confined_to_snapshot(snapshot);\n-    for (&skol_br, &skol) in skol_map.iter() {\n+    for (&skol_br, &skol) in skol_map {\n         let tainted = infcx.tainted_regions(snapshot, skol);\n-        for &tainted_region in tainted.iter() {\n+        for &tainted_region in &tainted {\n             // Each skolemized should only be relatable to itself\n             // or new variables:\n             match tainted_region {"}, {"sha": "f8dae3e92da6e86b5dca35473301a96b84397742", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -998,8 +998,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n                     error_str)[]);\n \n-                for err in err.iter() {\n-                    ty::note_and_explain_type_err(self.tcx, *err)\n+                if let Some(err) = err {\n+                    ty::note_and_explain_type_err(self.tcx, err)\n                 }\n             }\n         }"}, {"sha": "87ea5436dab6b545662d33faec5b9a0fed89ed7a", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -27,7 +27,7 @@ use util::ppaux::Repr;\n \n use std::collections::hash_map::Entry::Vacant;\n use std::old_io::{self, File};\n-use std::os;\n+use std::env;\n use std::sync::atomic::{AtomicBool, Ordering, ATOMIC_BOOL_INIT};\n use syntax::ast;\n \n@@ -59,13 +59,13 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n \n     let requested_node : Option<ast::NodeId> =\n-        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s| s.parse().ok());\n+        env::var_string(\"RUST_REGION_GRAPH_NODE\").ok().and_then(|s| s.parse().ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;\n     }\n \n-    let requested_output = os::getenv(\"RUST_REGION_GRAPH\");\n+    let requested_output = env::var_string(\"RUST_REGION_GRAPH\").ok();\n     debug!(\"requested_output: {:?} requested_node: {:?}\",\n            requested_output, requested_node);\n "}, {"sha": "919ea0a25202c5ed5a4f1246e2d2f4e1e07f1b4c", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -667,7 +667,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                     a, b);\n                             }\n                             VerifyGenericBound(_, _, a, ref bs) => {\n-                                for &b in bs.iter() {\n+                                for &b in bs {\n                                     consider_adding_bidirectional_edges(\n                                         &mut result_set, r,\n                                         a, b);\n@@ -1200,7 +1200,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                       errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         let mut reg_reg_dups = FnvHashSet();\n-        for verify in self.verifys.borrow().iter() {\n+        for verify in &*self.verifys.borrow() {\n             match *verify {\n                 VerifyRegSubReg(ref origin, sub, sup) => {\n                     if self.is_subregion_of(sub, sup) {\n@@ -1333,7 +1333,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n         let dummy_idx = graph.add_node(());\n \n-        for (constraint, _) in constraints.iter() {\n+        for (constraint, _) in &*constraints {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n                     graph.add_edge(NodeIndex(a_id.index as uint),\n@@ -1393,8 +1393,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         lower_bounds.sort_by(|a, b| { free_regions_first(a, b) });\n         upper_bounds.sort_by(|a, b| { free_regions_first(a, b) });\n \n-        for lower_bound in lower_bounds.iter() {\n-            for upper_bound in upper_bounds.iter() {\n+        for lower_bound in &lower_bounds {\n+            for upper_bound in &upper_bounds {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n@@ -1435,8 +1435,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             return;\n         }\n \n-        for upper_bound_1 in upper_bounds.iter() {\n-            for upper_bound_2 in upper_bounds.iter() {\n+        for upper_bound_1 in &upper_bounds {\n+            for upper_bound_2 in &upper_bounds {\n                 match self.glb_concrete_regions(upper_bound_1.region,\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}\n@@ -1554,7 +1554,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            for (constraint, _) in self.constraints.borrow().iter() {\n+            for (constraint, _) in &*self.constraints.borrow() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {}\","}, {"sha": "9b8a4a844120ddd328c27e0f9b8db38be69ccb28", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                                already instantiated\")\n         };\n \n-        for &(dir, vid) in relations.iter() {\n+        for &(dir, vid) in &relations {\n             stack.push((ty, dir, vid));\n         }\n \n@@ -165,7 +165,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         let mut escaping_types = Vec::new();\n         let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n         debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n-        for action in actions_since_snapshot.iter() {\n+        for action in actions_since_snapshot {\n             match *action {\n                 sv::UndoLog::NewElem(index) => {\n                     // if any new variables were created during the"}, {"sha": "d9b90c1935a396058540d43958e475542b5300d7", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -120,7 +120,7 @@ impl LanguageItems {\n             (self.fn_once_trait(), ty::FnOnceClosureKind),\n             ];\n \n-        for &(opt_def_id, kind) in def_id_kinds.iter() {\n+        for &(opt_def_id, kind) in &def_id_kinds {\n             if Some(id) == opt_def_id {\n                 return Some(kind);\n             }\n@@ -217,7 +217,7 @@ impl<'a> LanguageItemCollector<'a> {\n }\n \n pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n-    for attribute in attrs.iter() {\n+    for attribute in attrs {\n         match attribute.value_str() {\n             Some(ref value) if attribute.check_name(\"lang\") => {\n                 return Some(value.clone());"}, {"sha": "e40e04bdee86acc308e66d45cf80fccbea0b78c7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -378,7 +378,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n-    for arg in decl.inputs.iter() {\n+    for arg in &decl.inputs {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n                                &*arg.pat,\n                                |_bm, arg_id, _x, path1| {\n@@ -427,7 +427,7 @@ fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n }\n \n fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n-    for pat in arm.pats.iter() {\n+    for pat in &arm.pats {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n@@ -464,7 +464,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // construction site.\n         let mut call_caps = Vec::new();\n         ty::with_freevars(ir.tcx, expr.id, |freevars| {\n-            for fv in freevars.iter() {\n+            for fv in freevars {\n                 if let DefLocal(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     call_caps.push(CaptureInfo {ln: fv_ln,\n@@ -1049,7 +1049,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            for arm in arms.iter() {\n+            for arm in arms {\n                 let body_succ =\n                     self.propagate_through_expr(&*arm.body, succ);\n                 let guard_succ =\n@@ -1445,12 +1445,12 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       }\n \n       ast::ExprInlineAsm(ref ia) => {\n-        for &(_, ref input) in ia.inputs.iter() {\n+        for &(_, ref input) in &ia.inputs {\n           this.visit_expr(&**input);\n         }\n \n         // Output operands must be lvalues\n-        for &(_, ref out, _) in ia.outputs.iter() {\n+        for &(_, ref out, _) in &ia.outputs {\n           this.check_lvalue(&**out);\n           this.visit_expr(&**out);\n         }\n@@ -1590,7 +1590,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn warn_about_unused_args(&self, decl: &ast::FnDecl, entry_ln: LiveNode) {\n-        for arg in decl.inputs.iter() {\n+        for arg in &decl.inputs {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n                                    &*arg.pat,\n                                    |_bm, p_id, sp, path1| {\n@@ -1620,7 +1620,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                          -> bool {\n         if !self.used_on_entry(ln, var) {\n             let r = self.should_warn(var);\n-            for name in r.iter() {\n+            if let Some(name) = r {\n \n                 // annoying: for parameters in funcs like `fn(x: int)\n                 // {ret}`, there is only one node, so asking about\n@@ -1634,10 +1634,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 if is_assigned {\n                     self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         format!(\"variable `{}` is assigned to, but never used\",\n-                                *name));\n+                                name));\n                 } else {\n                     self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n-                        format!(\"unused variable: `{}`\", *name));\n+                        format!(\"unused variable: `{}`\", name));\n                 }\n             }\n             true\n@@ -1653,9 +1653,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                               var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n-            for name in r.iter() {\n+            if let Some(name) = r {\n                 self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n-                    format!(\"value assigned to `{}` is never read\", *name));\n+                    format!(\"value assigned to `{}` is never read\", name));\n             }\n         }\n     }"}, {"sha": "1ae483be2696d83a93183a58d73da756e7ada219", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1208,7 +1208,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     }\n                 }\n                 Some(&def::DefConst(..)) => {\n-                    for subpat in subpats.iter() {\n+                    for subpat in subpats {\n                         try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }\n                 }\n@@ -1230,7 +1230,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n-            for fp in field_pats.iter() {\n+            for fp in field_pats {\n                 let field_ty = try!(self.pat_ty(&*fp.node.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.ident.name, field_ty);\n                 try!(self.cat_pattern_(cmt_field, &*fp.node.pat, op));\n@@ -1259,15 +1259,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::PatVec(ref before, ref slice, ref after) => {\n               let elt_cmt = try!(self.cat_index(pat, try!(self.deref_vec(pat, cmt))));\n-              for before_pat in before.iter() {\n+              for before_pat in before {\n                   try!(self.cat_pattern_(elt_cmt.clone(), &**before_pat, op));\n               }\n-              for slice_pat in slice.iter() {\n+              if let Some(ref slice_pat) = *slice {\n                   let slice_ty = try!(self.pat_ty(&**slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n                   try!(self.cat_pattern_(slice_cmt, &**slice_pat, op));\n               }\n-              for after_pat in after.iter() {\n+              for after_pat in after {\n                   try!(self.cat_pattern_(elt_cmt.clone(), &**after_pat, op));\n               }\n           }"}, {"sha": "0af226de251a182afe820b6c8ed4fe350b123d78", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&mut self) {\n-        for (_, destructor_def_id) in self.tcx.destructor_for_type.borrow().iter() {\n+        for (_, destructor_def_id) in &*self.tcx.destructor_for_type.borrow() {\n             if destructor_def_id.krate == ast::LOCAL_CRATE {\n                 self.reachable_symbols.insert(destructor_def_id.node);\n             }\n@@ -371,7 +371,7 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     //         other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    for id in exported_items.iter() {\n+    for id in exported_items {\n         reachable_context.worklist.push(*id);\n     }\n     for (_, item) in tcx.lang_items.items() {"}, {"sha": "7dcd358165c9248d88c7dbe3238b4797906465b4", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -20,7 +20,7 @@ use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n \n pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n-    for attr in krate.attrs.iter() {\n+    for attr in &krate.attrs {\n         if !attr.check_name(\"recursion_limit\") {\n             continue;\n         }"}, {"sha": "87d386d94c97270c3fc4a75af0a6d60f2c469a2d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -888,14 +888,14 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n                 record_rvalue_scope(visitor, &**subexpr, blk_id);\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n-                for field in fields.iter() {\n+                for field in fields {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &*field.expr, blk_id);\n                 }\n             }\n             ast::ExprVec(ref subexprs) |\n             ast::ExprTup(ref subexprs) => {\n-                for subexpr in subexprs.iter() {\n+                for subexpr in subexprs {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &**subexpr, blk_id);\n                 }"}, {"sha": "365355c4a2a0b3db38fd2594d0742d208c445cac", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -187,14 +187,14 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n+        for ty_param in &*generics.ty_params {\n             visit::walk_ty_param_bounds_helper(self, &ty_param.bounds);\n             match ty_param.default {\n                 Some(ref ty) => self.visit_ty(&**ty),\n                 None => {}\n             }\n         }\n-        for predicate in generics.where_clause.predicates.iter() {\n+        for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ ref bounded_ty,\n                                                                                ref bounds,\n@@ -207,7 +207,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                                                                                 .. }) => {\n \n                     self.visit_lifetime_ref(lifetime);\n-                    for bound in bounds.iter() {\n+                    for bound in bounds {\n                         self.visit_lifetime_ref(bound);\n                     }\n                 }\n@@ -229,7 +229,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n         self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n             this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n-            for lifetime in trait_ref.bound_lifetimes.iter() {\n+            for lifetime in &trait_ref.bound_lifetimes {\n                 this.visit_lifetime_def(lifetime);\n             }\n             this.visit_trait_ref(&trait_ref.trait_ref)\n@@ -408,7 +408,7 @@ impl<'a> LifetimeContext<'a> {\n             let lifetime_i = &lifetimes[i];\n \n             let special_idents = [special_idents::static_lifetime];\n-            for lifetime in lifetimes.iter() {\n+            for lifetime in lifetimes {\n                 if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n                     span_err!(self.sess, lifetime.lifetime.span, E0262,\n                         \"illegal lifetime parameter name: `{}`\",\n@@ -431,7 +431,7 @@ impl<'a> LifetimeContext<'a> {\n             // It is a soft error to shadow a lifetime within a parent scope.\n             self.check_lifetime_def_for_shadowing(old_scope, &lifetime_i.lifetime);\n \n-            for bound in lifetime_i.bounds.iter() {\n+            for bound in &lifetime_i.bounds {\n                 self.resolve_lifetime_ref(bound);\n             }\n         }\n@@ -535,10 +535,10 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n         let mut collector =\n             FreeLifetimeCollector { early_bound: &mut early_bound,\n                                     late_bound: &mut late_bound };\n-        for ty_param in generics.ty_params.iter() {\n+        for ty_param in &*generics.ty_params {\n             visit::walk_ty_param_bounds_helper(&mut collector, &ty_param.bounds);\n         }\n-        for predicate in generics.where_clause.predicates.iter() {\n+        for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounds,\n                                                                               ref bounded_ty,\n@@ -551,7 +551,7 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n                                                                                 ..}) => {\n                     collector.visit_lifetime_ref(lifetime);\n \n-                    for bound in bounds.iter() {\n+                    for bound in bounds {\n                         collector.visit_lifetime_ref(bound);\n                     }\n                 }\n@@ -562,11 +562,11 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n \n     // Any lifetime that either has a bound or is referenced by a\n     // bound is early.\n-    for lifetime_def in generics.lifetimes.iter() {\n+    for lifetime_def in &generics.lifetimes {\n         if !lifetime_def.bounds.is_empty() {\n             shuffle(&mut early_bound, &mut late_bound,\n                     lifetime_def.lifetime.name);\n-            for bound in lifetime_def.bounds.iter() {\n+            for bound in &lifetime_def.bounds {\n                 shuffle(&mut early_bound, &mut late_bound,\n                         bound.name);\n             }"}, {"sha": "5028a1322cac1aaff0a6d369b72acef40883e531", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -148,7 +148,7 @@ impl Index {\n     /// Construct the stability index for a crate being compiled.\n     pub fn build(sess: &Session, krate: &Crate) -> Index {\n         let mut staged_api = false;\n-        for attr in krate.attrs.iter() {\n+        for attr in &krate.attrs {\n             if attr.name().get() == \"staged_api\" {\n                 match attr.node.value.node {\n                     ast::MetaWord(_) => {\n@@ -273,7 +273,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n             maybe_do_stability_check(tcx, id, item.span, cb);\n         }\n         ast::ItemTrait(_, _, ref supertraits, _) => {\n-            for t in supertraits.iter() {\n+            for t in &**supertraits {\n                 if let ast::TraitTyParamBound(ref t, _) = *t {\n                     let id = ty::trait_ref_to_def_id(tcx, &t.trait_ref);\n                     maybe_do_stability_check(tcx, id, t.trait_ref.path.span, cb);\n@@ -410,11 +410,11 @@ pub fn check_unused_features(sess: &Session,\n     let mut active_lib_features: FnvHashMap<InternedString, Span>\n         = lib_features.clone().into_iter().collect();\n \n-    for used_feature in used_lib_features.iter() {\n+    for used_feature in used_lib_features {\n         active_lib_features.remove(used_feature);\n     }\n \n-    for (_, &span) in active_lib_features.iter() {\n+    for (_, &span) in &active_lib_features {\n         sess.add_lint(lint::builtin::UNUSED_FEATURES,\n                       ast::CRATE_NODE_ID,\n                       span,"}, {"sha": "eb6bc4c38353a43e05d8107cc83c4892ef524df0", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -241,7 +241,7 @@ pub struct SeparateVecsPerParamSpace<T> {\n impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"VecPerParamSpace {{\"));\n-        for space in ParamSpace::all().iter() {\n+        for space in &ParamSpace::all() {\n             try!(write!(fmt, \"{:?}: {:?}, \", *space, self.get_slice(*space)));\n         }\n         try!(write!(fmt, \"}}\"));\n@@ -317,7 +317,7 @@ impl<T> VecPerParamSpace<T> {\n     ///\n     /// Unlike the `extend` method in `Vec`, this should not be assumed\n     /// to be a cheap operation (even when amortized over many calls).\n-    pub fn extend<I:Iterator<Item=T>>(&mut self, space: ParamSpace, mut values: I) {\n+    pub fn extend<I:Iterator<Item=T>>(&mut self, space: ParamSpace, values: I) {\n         // This could be made more efficient, obviously.\n         for item in values {\n             self.push(space, item);\n@@ -352,7 +352,7 @@ impl<T> VecPerParamSpace<T> {\n     pub fn replace(&mut self, space: ParamSpace, elems: Vec<T>) {\n         // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n         self.truncate(space, 0);\n-        for t in elems.into_iter() {\n+        for t in elems {\n             self.push(space, t);\n         }\n     }"}, {"sha": "8ce4e38896ecd2502726d577516e088af7052623", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -35,7 +35,7 @@ provide an impl. To see what I mean, consider the body of `clone_slice`:\n \n     fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n         let mut v = Vec::new();\n-        for e in x.iter() {\n+        for e in &x {\n             v.push((*e).clone()); // (*)\n         }\n     }"}, {"sha": "b8886fa65baa8c8db2e1d45be14068d364a30d9f", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -28,7 +28,7 @@ use util::ppaux::{Repr, UserString};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                            errors: &Vec<FulfillmentError<'tcx>>) {\n-    for error in errors.iter() {\n+    for error in errors {\n         report_fulfillment_error(infcx, error);\n     }\n }\n@@ -68,7 +68,7 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                      span: Span) -> Option<String> {\n     let def_id = trait_ref.def_id;\n     let mut report = None;\n-    for item in ty::get_attrs(infcx.tcx, def_id).iter() {\n+    for item in &*ty::get_attrs(infcx.tcx, def_id) {\n         if item.check_name(\"rustc_on_unimplemented\") {\n             let err_sp = if item.meta().span == DUMMY_SP {\n                 span"}, {"sha": "8adcd256ccebcccc825e70aa72fa7dee0b608918", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -125,7 +125,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         let mut selcx = SelectionContext::new(infcx, typer);\n         let normalized = project::normalize_projection_type(&mut selcx, projection_ty, cause, 0);\n \n-        for obligation in normalized.obligations.into_iter() {\n+        for obligation in normalized.obligations {\n             self.register_predicate_obligation(infcx, obligation);\n         }\n \n@@ -289,7 +289,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n             // Now go through all the successful ones,\n             // registering any nested obligations for the future.\n-            for new_obligation in new_obligations.into_iter() {\n+            for new_obligation in new_obligations {\n                 self.register_predicate_obligation(selcx.infcx(), new_obligation);\n             }\n         }"}, {"sha": "f69bf31626f628591c721d2d3628988c470e9ddd", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -438,7 +438,7 @@ pub fn normalize_param_env<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx\n         let mut fulfill_cx = FulfillmentContext::new();\n         let Normalized { value: predicates, obligations } =\n             project::normalize(selcx, cause, &param_env.caller_bounds);\n-        for obligation in obligations.into_iter() {\n+        for obligation in obligations {\n             fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n         }\n         try!(fulfill_cx.select_all_or_error(selcx.infcx(), param_env));"}, {"sha": "c88e58266a07631aa32659791835aa356482cea6", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -176,7 +176,7 @@ fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // The `Self` type is erased, so it should not appear in list of\n     // arguments or return type apart from the receiver.\n     let ref sig = method.fty.sig;\n-    for &input_ty in sig.0.inputs[1..].iter() {\n+    for &input_ty in &sig.0.inputs[1..] {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }"}, {"sha": "3ede6bbb965ef4f823f2dd5056db4b1e6ff2d639", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -802,7 +802,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n \n     let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n     let mut impl_ty = None;\n-    for impl_item in impl_items.iter() {\n+    for impl_item in impl_items {\n         let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n             ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n             ty::MethodTraitItem(..) => { continue; }"}, {"sha": "000572cdd40a34f10c3edad3f8e7cca3d07fd022", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -295,7 +295,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n                                                 stack: Option<&TraitObligationStack<'o, 'tcx>>,\n-                                                mut predicates: I)\n+                                                predicates: I)\n                                                 -> EvaluationResult<'tcx>\n         where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n@@ -1089,7 +1089,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"assemble_candidates_from_impls(self_ty={})\", self_ty.repr(self.tcx()));\n \n         let all_impls = self.all_impls(obligation.predicate.def_id());\n-        for &impl_def_id in all_impls.iter() {\n+        for &impl_def_id in &all_impls {\n             self.infcx.probe(|snapshot| {\n                 let (skol_obligation_trait_pred, skol_map) =\n                     self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);"}, {"sha": "45ce692bb076354e7bbb86bc891bc36d77fb4a05", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -343,7 +343,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n \n         let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n-        for trait_item in trait_items.iter() {\n+        for trait_item in &**trait_items {\n             match *trait_item {\n                 ty::MethodTraitItem(_) => method_count += 1,\n                 ty::TypeTraitItem(_) => {}"}, {"sha": "a772555d8fcb6eabb9821a8ab9d8239254e5eec0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -872,7 +872,7 @@ macro_rules! sty_debug_print {\n                 $(let mut $variant = total;)*\n \n \n-                for (_, t) in tcx.interner.borrow().iter() {\n+                for (_, t) in &*tcx.interner.borrow() {\n                     let variant = match t.sty {\n                         ty::ty_bool | ty::ty_char | ty::ty_int(..) | ty::ty_uint(..) |\n                             ty::ty_float(..) | ty::ty_str => continue,\n@@ -2579,7 +2579,7 @@ impl FlagComputation {\n             &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_substs(principal.0.substs);\n-                for projection_bound in bounds.projection_bounds.iter() {\n+                for projection_bound in &bounds.projection_bounds {\n                     let mut proj_computation = FlagComputation::new();\n                     proj_computation.add_projection_predicate(&projection_bound.0);\n                     computation.add_bound_computation(&proj_computation);\n@@ -2618,7 +2618,7 @@ impl FlagComputation {\n     }\n \n     fn add_tys(&mut self, tys: &[Ty]) {\n-        for &ty in tys.iter() {\n+        for &ty in tys {\n             self.add_ty(ty);\n         }\n     }\n@@ -3099,10 +3099,7 @@ pub fn type_is_unsafe_ptr(ty: Ty) -> bool {\n \n pub fn type_is_unique(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_uniq(_) => match ty.sty {\n-            ty_trait(..) => false,\n-            _ => true\n-        },\n+        ty_uniq(_) => true,\n         _ => false\n     }\n }\n@@ -3530,7 +3527,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         // make no assumptions (other than that it cannot have an\n         // in-scope type parameter within, which makes no sense).\n         let mut tc = TC::All - TC::InteriorParam;\n-        for bound in bounds.builtin_bounds.iter() {\n+        for bound in &bounds.builtin_bounds {\n             tc = tc - match bound {\n                 BoundSync | BoundSend | BoundCopy => TC::None,\n                 BoundSized => TC::Nonsized,\n@@ -4644,7 +4641,7 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0;\n-    for f in fields.iter() { if f.name == name { return i; } i += 1; }\n+    for f in fields { if f.name == name { return i; } i += 1; }\n     tcx.sess.bug(&format!(\n         \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n@@ -5468,25 +5465,25 @@ pub fn predicates<'tcx>(\n {\n     let mut vec = Vec::new();\n \n-    for builtin_bound in bounds.builtin_bounds.iter() {\n+    for builtin_bound in &bounds.builtin_bounds {\n         match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n             Ok(trait_ref) => { vec.push(trait_ref.as_predicate()); }\n             Err(ErrorReported) => { }\n         }\n     }\n \n-    for &region_bound in bounds.region_bounds.iter() {\n+    for &region_bound in &bounds.region_bounds {\n         // account for the binder being introduced below; no need to shift `param_ty`\n         // because, at present at least, it can only refer to early-bound regions\n         let region_bound = ty_fold::shift_region(region_bound, 1);\n         vec.push(ty::Binder(ty::OutlivesPredicate(param_ty, region_bound)).as_predicate());\n     }\n \n-    for bound_trait_ref in bounds.trait_bounds.iter() {\n+    for bound_trait_ref in &bounds.trait_bounds {\n         vec.push(bound_trait_ref.as_predicate());\n     }\n \n-    for projection in bounds.projection_bounds.iter() {\n+    for projection in &bounds.projection_bounds {\n         vec.push(projection.as_predicate());\n     }\n \n@@ -5931,17 +5928,17 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n         // Record the trait->implementation mappings, if applicable.\n         let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n-        for trait_ref in associated_traits.iter() {\n+        if let Some(ref trait_ref) = associated_traits {\n             record_trait_implementation(tcx, trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for impl_item_def_id in impl_items.iter() {\n+        for impl_item_def_id in &impl_items {\n             let method_def_id = impl_item_def_id.def_id();\n             match impl_or_trait_item(tcx, method_def_id) {\n                 MethodTraitItem(method) => {\n-                    for &source in method.provided_source.iter() {\n+                    if let Some(source) = method.provided_source {\n                         tcx.provided_method_sources\n                            .borrow_mut()\n                            .insert(method_def_id, source);\n@@ -5985,11 +5982,11 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for impl_item_def_id in impl_items.iter() {\n+        for impl_item_def_id in &impl_items {\n             let method_def_id = impl_item_def_id.def_id();\n             match impl_or_trait_item(tcx, method_def_id) {\n                 MethodTraitItem(method) => {\n-                    for &source in method.provided_source.iter() {\n+                    if let Some(source) = method.provided_source {\n                         tcx.provided_method_sources\n                            .borrow_mut()\n                            .insert(method_def_id, source);\n@@ -6121,7 +6118,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n         };\n         let fn_sig = |&: state: &mut SipHasher, sig: &Binder<FnSig<'tcx>>| {\n             let sig = anonymize_late_bound_regions(tcx, sig).0;\n-            for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n+            for a in &sig.inputs { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {\n                 helper(tcx, output, svh, state);\n             }\n@@ -6270,15 +6267,15 @@ pub fn construct_free_substs<'a,'tcx>(\n                           free_id: ast::NodeId,\n                           region_params: &[RegionParameterDef])\n     {\n-        for r in region_params.iter() {\n+        for r in region_params {\n             regions.push(r.space, ty::free_region_from_def(free_id, r));\n         }\n     }\n \n     fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   types: &mut VecPerParamSpace<Ty<'tcx>>,\n                                   defs: &[TypeParameterDef<'tcx>]) {\n-        for def in defs.iter() {\n+        for def in defs {\n             debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n                    def.repr(tcx));\n             let ty = ty::mk_param_from_def(tcx, def);\n@@ -6351,7 +6348,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, predicates: &[ty::Predicate<'tcx>]) {\n         debug!(\"record_region_bounds(predicates={:?})\", predicates.repr(tcx));\n \n-        for predicate in predicates.iter() {\n+        for predicate in predicates {\n             match *predicate {\n                 Predicate::Projection(..) |\n                 Predicate::Trait(..) |\n@@ -6870,7 +6867,7 @@ pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tc\n     let did = match self_type.sty {\n         ty::ty_struct(struct_did, substs) => {\n             let fields = ty::struct_fields(tcx, struct_did, substs);\n-            for field in fields.iter() {\n+            for field in &fields {\n                 if type_moves_by_default(param_env, span, field.mt.ty) {\n                     return Err(FieldDoesNotImplementCopy(field.name))\n                 }\n@@ -6879,8 +6876,8 @@ pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tc\n         }\n         ty::ty_enum(enum_did, substs) => {\n             let enum_variants = ty::enum_variants(tcx, enum_did);\n-            for variant in enum_variants.iter() {\n-                for variant_arg_type in variant.args.iter() {\n+            for variant in &*enum_variants {\n+                for variant_arg_type in &variant.args {\n                     let substd_arg_type =\n                         variant_arg_type.subst(tcx, substs);\n                     if type_moves_by_default(param_env, span, substd_arg_type) {"}, {"sha": "425c9a4c9f7748dd8c01406559d1727e34da3658", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -78,7 +78,7 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n \n     let mut missing = HashSet::new();\n     sess.cstore.iter_crate_data(|cnum, _| {\n-        for item in csearch::get_missing_lang_items(&sess.cstore, cnum).iter() {\n+        for item in &csearch::get_missing_lang_items(&sess.cstore, cnum) {\n             missing.insert(*item);\n         }\n     });"}, {"sha": "110e672b70f87888484a02c1d07f4cc81c6e73a5", "filename": "src/librustc/plugin/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -48,7 +48,7 @@ pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n         },\n         _ => {\n             diagnostic.handler().err(\"multiple plugin registration functions found\");\n-            for &(_, span) in finder.registrars.iter() {\n+            for &(_, span) in &finder.registrars {\n                 diagnostic.span_note(span, \"one is here\");\n             }\n             diagnostic.handler().abort_if_errors();"}, {"sha": "dd0b0a63ced9de64a3b63eddf14ace3d25b26bc6", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -15,7 +15,7 @@ use metadata::creader::{CrateOrString, CrateReader};\n use plugin::registry::Registry;\n \n use std::mem;\n-use std::os;\n+use std::env;\n use std::dynamic_lib::DynamicLibrary;\n use std::collections::HashSet;\n use syntax::ast;\n@@ -73,7 +73,7 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n     // We need to error on `#[macro_use] extern crate` when it isn't at the\n     // crate root, because `$crate` won't work properly. Identify these by\n     // spans, because the crate map isn't set up yet.\n-    for item in krate.module.items.iter() {\n+    for item in &krate.module.items {\n         if let ast::ItemExternCrate(_) = item.node {\n             loader.span_whitelist.insert(item.span);\n         }\n@@ -82,7 +82,7 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n     visit::walk_crate(&mut loader, krate);\n \n     if let Some(plugins) = addl_plugins {\n-        for plugin in plugins.iter() {\n+        for plugin in &plugins {\n             loader.load_plugin(CrateOrString::Str(plugin.as_slice()),\n                                                   None, None, None)\n         }\n@@ -107,7 +107,7 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n         let mut plugin_attr = None;\n         let mut macro_selection = Some(HashSet::new());  // None => load all\n         let mut reexport = HashSet::new();\n-        for attr in item.attrs.iter() {\n+        for attr in &item.attrs {\n             let mut used = true;\n             match attr.name().get() {\n                 \"phase\" => {\n@@ -127,7 +127,7 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n                         macro_selection = None;\n                     }\n                     if let (Some(sel), Some(names)) = (macro_selection.as_mut(), names) {\n-                        for name in names.iter() {\n+                        for name in names {\n                             if let ast::MetaWord(ref name) = name.node {\n                                 sel.insert(name.clone());\n                             } else {\n@@ -145,7 +145,7 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n                         }\n                     };\n \n-                    for name in names.iter() {\n+                    for name in names {\n                         if let ast::MetaWord(ref name) = name.node {\n                             reexport.insert(name.clone());\n                         } else {\n@@ -204,7 +204,7 @@ impl<'a> PluginLoader<'a> {\n             }\n         }\n \n-        for mut def in macros.into_iter() {\n+        for mut def in macros {\n             let name = token::get_ident(def.ident);\n             def.use_locally = match macro_selection.as_ref() {\n                 None => true,\n@@ -233,7 +233,7 @@ impl<'a> PluginLoader<'a> {\n                         path: Path,\n                         symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n-        let path = os::make_absolute(&path).unwrap();\n+        let path = env::current_dir().unwrap().join(&path);\n \n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,"}, {"sha": "88f6dc673cf18f8e4b8ab2aaf97e92b03c840272", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -300,13 +300,13 @@ macro_rules! options {\n     pub fn $buildfn(matches: &getopts::Matches) -> $struct_name\n     {\n         let mut op = $defaultfn();\n-        for option in matches.opt_strs($prefix).into_iter() {\n+        for option in matches.opt_strs($prefix) {\n             let mut iter = option.splitn(1, '=');\n             let key = iter.next().unwrap();\n             let value = iter.next();\n             let option_to_lookup = key.replace(\"-\", \"_\");\n             let mut found = false;\n-            for &(candidate, setter, opt_type_desc, _) in $stat.iter() {\n+            for &(candidate, setter, opt_type_desc, _) in $stat {\n                 if option_to_lookup != candidate { continue }\n                 if !setter(&mut op, value) {\n                     match (value, opt_type_desc) {\n@@ -830,8 +830,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n \n-    for &level in [lint::Allow, lint::Warn, lint::Deny, lint::Forbid].iter() {\n-        for lint_name in matches.opt_strs(level.as_str()).into_iter() {\n+    for &level in &[lint::Allow, lint::Warn, lint::Deny, lint::Forbid] {\n+        for lint_name in matches.opt_strs(level.as_str()) {\n             if lint_name == \"help\" {\n                 describe_lints = true;\n             } else {\n@@ -853,7 +853,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let mut output_types = Vec::new();\n     if !debugging_opts.parse_only && !no_trans {\n         let unparsed_output_types = matches.opt_strs(\"emit\");\n-        for unparsed_output_type in unparsed_output_types.iter() {\n+        for unparsed_output_type in &unparsed_output_types {\n             for part in unparsed_output_type.split(',') {\n                 let output_type = match part.as_slice() {\n                     \"asm\" => OutputTypeAssembly,\n@@ -923,7 +923,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n \n     let mut search_paths = SearchPaths::new();\n-    for s in matches.opt_strs(\"L\").iter() {\n+    for s in &matches.opt_strs(\"L\") {\n         search_paths.add_path(&s[]);\n     }\n \n@@ -997,7 +997,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n \n     let mut externs = HashMap::new();\n-    for arg in matches.opt_strs(\"extern\").iter() {\n+    for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n@@ -1049,7 +1049,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateType>, String> {\n \n     let mut crate_types: Vec<CrateType> = Vec::new();\n-    for unparsed_crate_type in list_list.iter() {\n+    for unparsed_crate_type in &list_list {\n         for part in unparsed_crate_type.split(',') {\n             let new_part = match part {\n                 \"lib\"       => default_lib_output(),"}, {"sha": "07fbecbdebcfc26aff93e7f6a69ab460d8d3ced6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -27,7 +27,7 @@ use syntax::{ast, codemap};\n \n use rustc_back::target::Target;\n \n-use std::os;\n+use std::env;\n use std::cell::{Cell, RefCell};\n \n pub mod config;\n@@ -347,7 +347,7 @@ pub fn build_session_(sopts: config::Options,\n         if path.is_absolute() {\n             path.clone()\n         } else {\n-            os::getcwd().unwrap().join(&path)\n+            env::current_dir().unwrap().join(&path)\n         }\n     );\n \n@@ -370,7 +370,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n-        working_dir: os::getcwd().unwrap(),\n+        working_dir: env::current_dir().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n         crate_types: RefCell::new(Vec::new()),"}, {"sha": "b77a70f1f5d5a6467378f6262760eee94573d963", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -163,7 +163,7 @@ pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n     while i < queue.len() {\n         match edges_map.get(&queue[i]) {\n             Some(edges) => {\n-                for target in edges.iter() {\n+                for target in edges {\n                     if *target == destination {\n                         return true;\n                     }"}, {"sha": "8da06e63daefcf07ee3d07d7d876d3447e442ea8", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -62,7 +62,7 @@ impl Hasher for FnvHasher {\n impl Writer for FnvHasher {\n     fn write(&mut self, bytes: &[u8]) {\n         let FnvHasher(mut hash) = *self;\n-        for byte in bytes.iter() {\n+        for byte in bytes {\n             hash = hash ^ (*byte as u64);\n             hash = hash * 0x100000001b3;\n         }"}, {"sha": "458701f2dd7626c2746206c5bccacfb5fa5641bd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -494,11 +494,11 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         0\n     };\n \n-    for t in tps[..tps.len() - num_defaults].iter() {\n+    for t in &tps[..tps.len() - num_defaults] {\n         strs.push(ty_to_string(cx, *t))\n     }\n \n-    for projection in projections.iter() {\n+    for projection in projections {\n         strs.push(format!(\"{}={}\",\n                           projection.projection_ty.item_name.user_string(cx),\n                           projection.ty.user_string(cx)));\n@@ -665,7 +665,7 @@ impl<'tcx> UserString<'tcx> for ty::TyTrait<'tcx> {\n         components.push(tap.user_string(tcx));\n \n         // Builtin bounds.\n-        for bound in bounds.builtin_bounds.iter() {\n+        for bound in &bounds.builtin_bounds {\n             components.push(bound.user_string(tcx));\n         }\n \n@@ -748,7 +748,7 @@ impl<'tcx> Repr<'tcx> for subst::RegionSubsts {\n impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         let mut res = Vec::new();\n-        for b in self.iter() {\n+        for b in self {\n             res.push(match b {\n                 ty::BoundSend => \"Send\".to_string(),\n                 ty::BoundSized => \"Sized\".to_string(),\n@@ -764,7 +764,7 @@ impl<'tcx> Repr<'tcx> for ty::ParamBounds<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n         res.push(self.builtin_bounds.repr(tcx));\n-        for t in self.trait_bounds.iter() {\n+        for t in &self.trait_bounds {\n             res.push(t.repr(tcx));\n         }\n         res.connect(\"+\")\n@@ -1157,7 +1157,7 @@ impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n         if !s.is_empty() {\n             result.push(s);\n         }\n-        for n in self.trait_bounds.iter() {\n+        for n in &self.trait_bounds {\n             result.push(n.user_string(tcx));\n         }\n         result.connect(\" + \")\n@@ -1173,11 +1173,11 @@ impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n             res.push(region_str);\n         }\n \n-        for bound in self.builtin_bounds.iter() {\n+        for bound in &self.builtin_bounds {\n             res.push(bound.user_string(tcx));\n         }\n \n-        for projection_bound in self.projection_bounds.iter() {\n+        for projection_bound in &self.projection_bounds {\n             res.push(projection_bound.user_string(tcx));\n         }\n "}, {"sha": "b779963a2191711774c1edbcb54171b5dd30d357", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -14,7 +14,7 @@ use std::old_io::fs::PathExtensions;\n use std::old_io::process::{Command, ProcessOutput};\n use std::old_io::{fs, TempDir};\n use std::old_io;\n-use std::os;\n+use std::env;\n use std::str;\n use syntax::diagnostic::Handler as ErrorHandler;\n \n@@ -99,7 +99,7 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n     let oslibname = format!(\"{}{}{}\", osprefix, name, ossuffix);\n     let unixlibname = format!(\"lib{}.a\", name);\n \n-    for path in search_paths.iter() {\n+    for path in search_paths {\n         debug!(\"looking for {} inside {:?}\", name, path.display());\n         let test = path.join(&oslibname[]);\n         if test.exists() { return test }\n@@ -224,7 +224,7 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn build(self) -> Archive<'a> {\n         // Get an absolute path to the destination, so `ar` will work even\n         // though we run it from `self.work_dir`.\n-        let abs_dst = os::getcwd().unwrap().join(&self.archive.dst);\n+        let abs_dst = env::current_dir().unwrap().join(&self.archive.dst);\n         assert!(!abs_dst.is_relative());\n         let mut args = vec![&abs_dst];\n         let mut total_len = abs_dst.as_vec().len();\n@@ -244,7 +244,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // 32,768, and we leave a bit of extra space for the program name.\n         static ARG_LENGTH_LIMIT: uint = 32000;\n \n-        for member_name in self.members.iter() {\n+        for member_name in &self.members {\n             let len = member_name.as_vec().len();\n \n             // `len + 1` to account for the space that's inserted before each\n@@ -283,7 +283,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // First, extract the contents of the archive to a temporary directory.\n         // We don't unpack directly into `self.work_dir` due to the possibility\n         // of filename collisions.\n-        let archive = os::make_absolute(archive).unwrap();\n+        let archive = env::current_dir().unwrap().join(archive);\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n                \"x\", Some(loc.path()), &[&archive]);\n \n@@ -297,7 +297,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n         let files = try!(fs::readdir(loc.path()));\n-        for file in files.iter() {\n+        for file in &files {\n             let filename = file.filename_str().unwrap();\n             if skip(filename) { continue }\n             if filename.contains(\".SYMDEF\") { continue }"}, {"sha": "a4417b49f1c41e771fd65a0e18dbc692183597dd", "filename": "src/librustc_back/arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farm.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -61,7 +61,7 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -a:0:64-n32\".to_string()\n           }\n \n-          abi::OsFreebsd | abi::OsDragonfly => {\n+          abi::OsFreebsd | abi::OsDragonfly | abi::OsOpenbsd => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\"}, {"sha": "acf49d1ca46e3b6d7a3c55cc44a607d48aea0681", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -10,13 +10,13 @@\n \n use std::old_io;\n use std::old_io::fs;\n-use std::os;\n+use std::env;\n \n /// Returns an absolute path in the filesystem that `path` points to. The\n /// returned path does not contain any symlinks in its hierarchy.\n pub fn realpath(original: &Path) -> old_io::IoResult<Path> {\n     static MAX_LINKS_FOLLOWED: uint = 256;\n-    let original = os::make_absolute(original).unwrap();\n+    let original = try!(env::current_dir()).join(original);\n \n     // Right now lstat on windows doesn't work quite well\n     if cfg!(windows) {"}, {"sha": "54b3e8f208125e8253ddc528957bd0d774a84684", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -40,6 +40,7 @@\n #![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(env)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "cb44fe117f54645d7740dd287e0355f2b3fb40d1", "filename": "src/librustc_back/mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fmips.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -56,7 +56,7 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -a:0:64-n32\".to_string()\n           }\n \n-          abi::OsFreebsd | abi::OsDragonfly => {\n+          abi::OsFreebsd | abi::OsDragonfly | abi::OsOpenbsd => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\"}, {"sha": "7ee357fb1eaf35d7a28c8e4ea5c1559872535119", "filename": "src/librustc_back/mipsel.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fmipsel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fmipsel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fmipsel.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -56,7 +56,7 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -a:0:64-n32\".to_string()\n           }\n \n-          abi::OsFreebsd | abi::OsDragonfly => {\n+          abi::OsFreebsd | abi::OsDragonfly | abi::OsOpenbsd => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\"}, {"sha": "36bbd4b987297d020e5fe867d36b604bfbf9211f", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,7 +10,7 @@\n \n \n use std::collections::HashSet;\n-use std::os;\n+use std::env;\n use std::old_io::IoError;\n use syntax::ast;\n \n@@ -51,7 +51,7 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n \n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n-    for rpath in rpaths.iter() {\n+    for rpath in rpaths {\n         ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)[]));\n     }\n     return ret;\n@@ -63,7 +63,7 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n {\n     debug!(\"output: {:?}\", config.out_filename.display());\n     debug!(\"libs:\");\n-    for libpath in libs.iter() {\n+    for libpath in libs {\n         debug!(\"    {:?}\", libpath.display());\n     }\n \n@@ -77,7 +77,7 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n \n     fn log_rpaths(desc: &str, rpaths: &[String]) {\n         debug!(\"{} rpaths:\", desc);\n-        for rpath in rpaths.iter() {\n+        for rpath in rpaths {\n             debug!(\"    {}\", *rpath);\n         }\n     }\n@@ -105,18 +105,17 @@ fn get_rpath_relative_to_output<F, G>(config: &mut RPathConfig<F, G>, lib: &Path\n     F: FnOnce() -> Path,\n     G: FnMut(&Path) -> Result<Path, IoError>,\n {\n-    use std::os;\n-\n     // Mac doesn't appear to support $ORIGIN\n     let prefix = if config.is_like_osx {\n         \"@loader_path\"\n     } else {\n         \"$ORIGIN\"\n     };\n \n-    let mut lib = (config.realpath)(&os::make_absolute(lib).unwrap()).unwrap();\n+    let cwd = env::current_dir().unwrap();\n+    let mut lib = (config.realpath)(&cwd.join(lib)).unwrap();\n     lib.pop();\n-    let mut output = (config.realpath)(&os::make_absolute(&config.out_filename).unwrap()).unwrap();\n+    let mut output = (config.realpath)(&cwd.join(&config.out_filename)).unwrap();\n     output.pop();\n     let relative = lib.path_relative_from(&output);\n     let relative = relative.expect(\"could not create rpath relative to output\");\n@@ -131,15 +130,15 @@ fn get_install_prefix_rpath<F, G>(config: RPathConfig<F, G>) -> String where\n     G: FnMut(&Path) -> Result<Path, IoError>,\n {\n     let path = (config.get_install_prefix_lib_path)();\n-    let path = os::make_absolute(&path).unwrap();\n+    let path = env::current_dir().unwrap().join(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     path.as_str().expect(\"non-utf8 component in rpath\").to_string()\n }\n \n fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n-    for rpath in rpaths.iter() {\n+    for rpath in rpaths {\n         if set.insert(&rpath[]) {\n             minimized.push(rpath.clone());\n         }\n@@ -214,7 +213,9 @@ mod test {\n     }\n \n     #[test]\n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+    #[cfg(any(target_os = \"freebsd\",\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\"))]\n     fn test_rpath_relative() {\n         let config = &mut RPathConfig {\n             used_crates: Vec::new(),"}, {"sha": "c15b4114aa7b896cc19ffceacb2e37b462f59d37", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -557,15 +557,15 @@ mod tests {\n \n     fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n         // Test that it works when accepting the message all at once\n-        for t in tests.iter() {\n+        for t in tests {\n             sh.reset();\n             sh.input_str(t.input.as_slice());\n             let out_str = sh.result_str();\n             assert!(out_str == t.output_str);\n         }\n \n         // Test that it works when accepting the message in pieces\n-        for t in tests.iter() {\n+        for t in tests {\n             sh.reset();\n             let len = t.input.len();\n             let mut left = len;"}, {"sha": "a14f4775ec135be769035af2485329b12f4efabf", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -79,7 +79,7 @@ impl Svh {\n         //        avoid collisions.\n         let mut state = SipHasher::new();\n \n-        for data in metadata.iter() {\n+        for data in metadata {\n             data.hash(&mut state);\n         }\n \n@@ -97,7 +97,7 @@ impl Svh {\n         //\n         // We hash only the MetaItems instead of the entire Attribute\n         // to avoid hashing the AttrId\n-        for attr in krate.attrs.iter() {\n+        for attr in &krate.attrs {\n             attr.node.value.hash(&mut state);\n         }\n "}, {"sha": "4b3833b687c5b53e176fe511c949a67382357409", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -56,6 +56,7 @@ mod apple_base;\n mod apple_ios_base;\n mod freebsd_base;\n mod dragonfly_base;\n+mod openbsd_base;\n \n mod armv7_apple_ios;\n mod armv7s_apple_ios;\n@@ -80,6 +81,7 @@ mod x86_64_pc_windows_gnu;\n mod x86_64_unknown_freebsd;\n mod x86_64_unknown_dragonfly;\n mod x86_64_unknown_linux_gnu;\n+mod x86_64_unknown_openbsd;\n \n /// Everything `rustc` knows about how to compile for a specific target.\n ///\n@@ -301,7 +303,8 @@ impl Target {\n     /// The error string could come from any of the APIs called, including filesystem access and\n     /// JSON decoding.\n     pub fn search(target: &str) -> Result<Target, String> {\n-        use std::os;\n+        use std::env;\n+        use std::ffi::OsString;\n         use std::old_io::File;\n         use std::path::Path;\n         use serialize::json;\n@@ -352,6 +355,8 @@ impl Target {\n             i686_unknown_dragonfly,\n             x86_64_unknown_dragonfly,\n \n+            x86_64_unknown_openbsd,\n+\n             x86_64_apple_darwin,\n             i686_apple_darwin,\n \n@@ -379,12 +384,12 @@ impl Target {\n             Path::new(target)\n         };\n \n-        let target_path = os::getenv(\"RUST_TARGET_PATH\").unwrap_or(String::new());\n+        let target_path = env::var(\"RUST_TARGET_PATH\")\n+                              .unwrap_or(OsString::from_str(\"\"));\n \n-        let paths = os::split_paths(&target_path[]);\n         // FIXME 16351: add a sane default search path?\n \n-        for dir in paths.iter() {\n+        for dir in env::split_paths(&target_path) {\n             let p =  dir.join(path.clone());\n             if p.is_file() {\n                 return load_file(&p);"}, {"sha": "42220a87bd414891ea17830790cdfcdeefeaeb9d", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        linker: \"cc\".to_string(),\n+        dynamic_linking: true,\n+        executables: true,\n+        morestack: false,\n+        linker_is_gnu: true,\n+        has_rpath: true,\n+        pre_link_args: vec!(\n+        ),\n+        position_independent_executables: true,\n+        .. Default::default()\n+    }\n+}\n+"}, {"sha": "d2667dcd1dd9e8f8bfac358b72f2d4a46f788698", "filename": "src/librustc_back/target/x86_64_unknown_openbsd.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::openbsd_base::opts();\n+    base.pre_link_args.push(\"-m64\".to_string());\n+\n+    Target {\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                     f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n+                     s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n+        llvm_target: \"x86_64-unknown-openbsd\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"openbsd\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "9d1b7347d0651039a799e10bccfd7e3a1113fd21", "filename": "src/librustc_back/x86.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fx86.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -51,6 +51,9 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os)\n           abi::OsDragonfly => {\n             \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string()\n           }\n+          abi::OsOpenbsd => {\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string()\n+          }\n \n         },\n "}, {"sha": "2f13bb3158119ad6e8a8f1661bd36b2014f431f7", "filename": "src/librustc_back/x86_64.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_back%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fx86_64.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -57,6 +57,11 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                 s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n+          abi::OsOpenbsd => {\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n+                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n+          }\n \n         },\n "}, {"sha": "b8d736ab9ca677fcf9e97fd555357b69c67479f6", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         let loan_path = owned_ptr_base_path(loan_path);\n         let cont = self.each_in_scope_loan(scope, |loan| {\n             let mut ret = true;\n-            for restr_path in loan.restricted_paths.iter() {\n+            for restr_path in &loan.restricted_paths {\n                 if **restr_path == *loan_path {\n                     if !op(loan) {\n                         ret = false;\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n         self.each_issued_loan(scope, |issued_loan| {\n-            for &new_loan_index in new_loan_indices.iter() {\n+            for &new_loan_index in &new_loan_indices {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n@@ -370,7 +370,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         for (i, &x) in new_loan_indices.iter().enumerate() {\n             let old_loan = &self.all_loans[x];\n-            for &y in new_loan_indices[(i+1) ..].iter() {\n+            for &y in &new_loan_indices[(i+1) ..] {\n                 let new_loan = &self.all_loans[y];\n                 self.report_error_if_loans_conflict(old_loan, new_loan);\n             }\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         }\n \n         let loan2_base_path = owned_ptr_base_path_rc(&loan2.loan_path);\n-        for restr_path in loan1.restricted_paths.iter() {\n+        for restr_path in &loan1.restricted_paths {\n             if *restr_path != loan2_base_path { continue; }\n \n             // If new_loan is something like `x.a`, and old_loan is something like `x.b`, we would"}, {"sha": "6f51ba3118278836f7822b13b9c4673300975b20", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -204,14 +204,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned[]));\n \n     // Second, build parents from the moved and assigned.\n-    for m in moved.iter() {\n+    for m in &moved {\n         let mut p = this.path_parent(*m);\n         while p != InvalidMovePathIndex {\n             parents.push(p);\n             p = this.path_parent(p);\n         }\n     }\n-    for a in assigned.iter() {\n+    for a in &assigned {\n         let mut p = this.path_parent(*a);\n         while p != InvalidMovePathIndex {\n             parents.push(p);\n@@ -231,15 +231,15 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned[]));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n-    for m in moved.iter() {\n+    for m in &moved {\n         let lp = this.path_loan_path(*m);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n-    for a in assigned.iter() {\n+    for a in &assigned {\n         let lp = this.path_loan_path(*a);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n-    for p in parents.iter() {\n+    for p in &parents {\n         let lp = this.path_loan_path(*p);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n@@ -369,7 +369,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let fields = ty::lookup_struct_fields(tcx, def_id);\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n-                    for f in fields.iter() {\n+                    for f in &fields {\n                         if f.name == ast_name {\n                             continue;\n                         }\n@@ -407,7 +407,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n                     let variant_arg_names = variant_info.arg_names.as_ref().unwrap();\n-                    for variant_arg_ident in variant_arg_names.iter() {\n+                    for variant_arg_ident in variant_arg_names {\n                         if variant_arg_ident.name == ast_name {\n                             continue;\n                         }"}, {"sha": "d9e86bd4b6d68d466c0a8cf147efb16405b0577a", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -67,10 +67,10 @@ pub struct GroupedMoveErrors<'tcx> {\n fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 errors: &Vec<MoveError<'tcx>>) {\n     let grouped_errors = group_errors_with_same_origin(errors);\n-    for error in grouped_errors.iter() {\n+    for error in &grouped_errors {\n         report_cannot_move_out_of(bccx, error.move_from.clone());\n         let mut is_first_note = true;\n-        for move_to in error.move_to_places.iter() {\n+        for move_to in &error.move_to_places {\n             note_move_destination(bccx, move_to.span,\n                                   &move_to.ident, is_first_note);\n             is_first_note = false;\n@@ -81,7 +81,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n                                        -> Vec<GroupedMoveErrors<'tcx>> {\n     let mut grouped_errors = Vec::new();\n-    for error in errors.iter() {\n+    for error in errors {\n         append_to_grouped_errors(&mut grouped_errors, error)\n     }\n     return grouped_errors;\n@@ -95,7 +95,7 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n         } else {\n             Vec::new()\n         };\n-        for ge in grouped_errors.iter_mut() {\n+        for ge in &mut *grouped_errors {\n             if move_from_id == ge.move_from.id && error.move_to.is_some() {\n                 debug!(\"appending move_to to list\");\n                 ge.move_to_places.extend(move_to.into_iter());"}, {"sha": "76c431fa4c58f477bdd3ae971193f36989357da5", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -475,13 +475,13 @@ impl<'tcx> MoveData<'tcx> {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n-        for assignment in self.path_assignments.borrow().iter() {\n+        for assignment in &*self.path_assignments.borrow() {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n         // Kill all moves related to a variable `x` when\n         // it goes out of scope:\n-        for path in self.paths.borrow().iter() {\n+        for path in &*self.paths.borrow() {\n             match path.loan_path.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n@@ -633,11 +633,11 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n \n         let mut ret = None;\n-        for loan_path_index in self.move_data.path_map.borrow().get(&*loan_path).iter() {\n+        if let Some(loan_path_index) = self.move_data.path_map.borrow().get(&*loan_path) {\n             self.dfcx_moves.each_gen_bit(id, |move_index| {\n                 let the_move = self.move_data.moves.borrow();\n                 let the_move = (*the_move)[move_index];\n-                if the_move.path == **loan_path_index {\n+                if the_move.path == *loan_path_index {\n                     ret = Some(the_move.kind);\n                     false\n                 } else {\n@@ -688,7 +688,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                     ret = false;\n                 }\n             } else {\n-                for &loan_path_index in opt_loan_path_index.iter() {\n+                if let Some(loan_path_index) = opt_loan_path_index {\n                     let cont = self.move_data.each_base_path(moved_path, |p| {\n                         if p == loan_path_index {\n                             // Scenario 3: some extension of `loan_path`\n@@ -699,7 +699,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                             true\n                         }\n                     });\n-                    if !cont { ret = false; break }\n+                    if !cont { ret = false; }\n                 }\n             }\n             ret"}, {"sha": "8b1b156691af7379ae852699a52e19c51eb9450b", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;\n-        for &variant in self.variants.iter() {\n+        for &variant in &self.variants {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");"}, {"sha": "9b9cc14c4761510dd53634732a23eb4a2a9513ae", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -30,9 +30,10 @@ use rustc_privacy;\n \n use serialize::json;\n \n-use std::old_io;\n+use std::env;\n+use std::ffi::OsString;\n use std::old_io::fs;\n-use std::os;\n+use std::old_io;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::attr;\n@@ -424,7 +425,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                 diagnostics::plugin::expand_build_diagnostic_array);\n         }\n \n-        for registrar in registrars.into_iter() {\n+        for registrar in registrars {\n             registry.args_hidden = Some(registrar.args);\n             (registrar.fun)(&mut registry);\n         }\n@@ -434,11 +435,11 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     {\n         let mut ls = sess.lint_store.borrow_mut();\n-        for pass in lint_passes.into_iter() {\n+        for pass in lint_passes {\n             ls.register_pass(Some(sess), true, pass);\n         }\n \n-        for (name, to) in lint_groups.into_iter() {\n+        for (name, to) in lint_groups {\n             ls.register_group(Some(sess), true, name, to);\n         }\n     }\n@@ -460,12 +461,12 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             // dependent dlls. Note that this uses cfg!(windows) as opposed to\n             // targ_cfg because syntax extensions are always loaded for the host\n             // compiler, not for the target.\n-            let mut _old_path = String::new();\n+            let mut _old_path = OsString::from_str(\"\");\n             if cfg!(windows) {\n-                _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n+                _old_path = env::var(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n-                new_path.extend(os::split_paths(&_old_path[]).into_iter());\n-                os::setenv(\"PATH\", os::join_paths(&new_path[]).unwrap());\n+                new_path.extend(env::split_paths(&_old_path));\n+                env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n@@ -478,7 +479,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                               syntax_exts,\n                                               krate);\n             if cfg!(windows) {\n-                os::setenv(\"PATH\", _old_path);\n+                env::set_var(\"PATH\", &_old_path);\n             }\n             ret\n         }\n@@ -734,18 +735,18 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n-    let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n+    let old_path = env::var(\"PATH\").unwrap_or(OsString::from_str(\"\"));\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n-    new_path.extend(os::split_paths(&old_path[]).into_iter());\n-    os::setenv(\"PATH\", os::join_paths(&new_path[]).unwrap());\n+    new_path.extend(env::split_paths(&old_path));\n+    env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n                            &trans.link.crate_name[]));\n \n-    os::setenv(\"PATH\", old_path);\n+    env::set_var(\"PATH\", &old_path);\n }\n \n fn escape_dep_filename(filename: &str) -> String {\n@@ -760,11 +761,11 @@ fn write_out_deps(sess: &Session,\n                   id: &str) {\n \n     let mut out_filenames = Vec::new();\n-    for output_type in sess.opts.output_types.iter() {\n+    for output_type in &sess.opts.output_types {\n         let file = outputs.path(*output_type);\n         match *output_type {\n             config::OutputTypeExe => {\n-                for output in sess.crate_types.borrow().iter() {\n+                for output in &*sess.crate_types.borrow() {\n                     let p = link::filename_for_input(sess, *output,\n                                                      id, &file);\n                     out_filenames.push(p);\n@@ -800,7 +801,7 @@ fn write_out_deps(sess: &Session,\n                                    .map(|fmap| escape_dep_filename(&fmap.name[]))\n                                    .collect();\n         let mut file = try!(old_io::File::create(&deps_filename));\n-        for path in out_filenames.iter() {\n+        for path in &out_filenames {\n             try!(write!(&mut file as &mut Writer,\n                           \"{}: {}\\n\\n\", path.display(), files.connect(\" \")));\n         }"}, {"sha": "d71e85e6a55c60a918c210e4cbe483d1bbe7c743", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -26,6 +26,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(env)]\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n@@ -74,7 +75,7 @@ use rustc::util::common::time;\n use std::cmp::Ordering::Equal;\n use std::old_io;\n use std::iter::repeat;\n-use std::os;\n+use std::env;\n use std::sync::mpsc::channel;\n use std::thread;\n \n@@ -252,7 +253,7 @@ pub fn get_unstable_features_setting() -> UnstableFeatures {\n     // subverting the unstable features lints\n     let bootstrap_secret_key = option_env!(\"CFG_BOOTSTRAP_KEY\");\n     // The matching key to the above, only known by the build system\n-    let bootstrap_provided_key = os::getenv(\"RUSTC_BOOTSTRAP_KEY\");\n+    let bootstrap_provided_key = env::var_string(\"RUSTC_BOOTSTRAP_KEY\").ok();\n     match (disable_unstable_features, bootstrap_secret_key, bootstrap_provided_key) {\n         (_, Some(ref s), Some(ref p)) if s == p => UnstableFeatures::Cheat,\n         (true, _, _) => UnstableFeatures::Disallow,\n@@ -373,7 +374,7 @@ Available lint options:\n     println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n \n     let print_lints = |&: lints: Vec<&Lint>| {\n-        for lint in lints.into_iter() {\n+        for lint in lints {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n                      padded(&name[]), lint.default_level.as_str(), lint.desc);\n@@ -400,7 +401,7 @@ Available lint options:\n     println!(\"    {}  {}\", padded(\"----\"), \"---------\");\n \n     let print_lint_groups = |&: lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n-        for (name, to) in lints.into_iter() {\n+        for (name, to) in lints {\n             let name = name.chars().map(|x| x.to_lowercase())\n                            .collect::<String>().replace(\"_\", \"-\");\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n@@ -435,7 +436,7 @@ Available lint options:\n \n fn describe_debug_flags() {\n     println!(\"\\nAvailable debug options:\\n\");\n-    for &(name, _, opt_type_desc, desc) in config::DB_OPTIONS.iter() {\n+    for &(name, _, opt_type_desc, desc) in config::DB_OPTIONS {\n         let (width, extra) = match opt_type_desc {\n             Some(..) => (21, \"=val\"),\n             None => (25, \"\")\n@@ -447,7 +448,7 @@ fn describe_debug_flags() {\n \n fn describe_codegen_flags() {\n     println!(\"\\nAvailable codegen options:\\n\");\n-    for &(name, _, opt_type_desc, desc) in config::CG_OPTIONS.iter() {\n+    for &(name, _, opt_type_desc, desc) in config::CG_OPTIONS {\n         let (width, extra) = match opt_type_desc {\n             Some(..) => (21, \"=val\"),\n             None => (25, \"\")\n@@ -542,7 +543,7 @@ fn print_crate_info(sess: &Session,\n     if sess.opts.prints.len() == 0 { return false }\n \n     let attrs = input.map(|input| parse_crate_attrs(sess, input));\n-    for req in sess.opts.prints.iter() {\n+    for req in &sess.opts.prints {\n         match *req {\n             PrintRequest::Sysroot => println!(\"{}\", sess.sysroot().display()),\n             PrintRequest::FileNames |\n@@ -566,7 +567,7 @@ fn print_crate_info(sess: &Session,\n                 let crate_types = driver::collect_crate_types(sess, attrs);\n                 let metadata = driver::collect_crate_metadata(sess, attrs);\n                 *sess.crate_metadata.borrow_mut() = metadata;\n-                for &style in crate_types.iter() {\n+                for &style in &crate_types {\n                     let fname = link::filename_for_input(sess, style,\n                                                          id.as_slice(),\n                                                          &t_outputs.with_extension(\"\"));\n@@ -618,7 +619,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n \n     // FIXME: Hacks on hacks. If the env is trying to override the stack size\n     // then *don't* set it explicitly.\n-    if os::getenv(\"RUST_MIN_STACK\").is_none() {\n+    if env::var(\"RUST_MIN_STACK\").is_none() {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n@@ -645,7 +646,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n                             BUG_REPORT_URL),\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n-                for note in xs.iter() {\n+                for note in &xs {\n                     emitter.emit(None, &note[], None, diagnostic::Note)\n                 }\n \n@@ -682,8 +683,8 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n }\n \n pub fn main() {\n-    let args = std::os::args();\n-    let result = run(args);\n-    std::os::set_exit_status(result);\n+    let args = env::args().map(|s| s.into_string().unwrap());\n+    let result = run(args.collect());\n+    std::env::set_exit_status(result as i32);\n }\n "}, {"sha": "20bf77190be720b5ede3d834f7c08f411f98f702", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn create_region_hierarchy(&self, rh: &RH) {\n-        for child_rh in rh.sub.iter() {\n+        for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh);\n             self.infcx.tcx.region_maps.record_encl_scope(\n                 CodeExtent::from_node_id(child_rh.id),\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                       names: &[String])\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n-            for item in m.items.iter() {\n+            for item in &m.items {\n                 if item.ident.user_string(this.infcx.tcx) == names[idx] {\n                     return search(this, &**item, idx+1, names);\n                 }"}, {"sha": "a1532c044e3dcd5fdbd7e772998d89a4f5f741f7", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 55, "deletions": 45, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -63,8 +63,9 @@ use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n use libc::{c_longlong, c_ulonglong, c_void};\n use debuginfo::{DIBuilderRef, DIDescriptor,\n                 DIFile, DILexicalBlock, DISubprogram, DIType,\n-                DIBasicType, DIDerivedType, DICompositeType,\n-                DIVariable, DIGlobalVariable, DIArray, DISubrange};\n+                DIBasicType, DIDerivedType, DICompositeType, DIScope,\n+                DIVariable, DIGlobalVariable, DIArray, DISubrange,\n+                DITemplateTypeParameter, DIEnumerator, DINameSpace};\n \n pub mod archive_ro;\n pub mod diagnostic;\n@@ -261,13 +262,13 @@ impl AttrBuilder {\n     }\n \n     pub fn apply_llfn(&self, llfn: ValueRef) {\n-        for &(idx, ref attr) in self.attrs.iter() {\n+        for &(idx, ref attr) in &self.attrs {\n             attr.apply_llfn(idx as c_uint, llfn);\n         }\n     }\n \n     pub fn apply_callsite(&self, callsite: ValueRef) {\n-        for &(idx, ref attr) in self.attrs.iter() {\n+        for &(idx, ref attr) in &self.attrs {\n             attr.apply_callsite(idx as c_uint, callsite);\n         }\n     }\n@@ -442,6 +443,9 @@ pub type TypeRef = *mut Type_opaque;\n pub enum Value_opaque {}\n pub type ValueRef = *mut Value_opaque;\n #[allow(missing_copy_implementations)]\n+pub enum Metadata_opaque {}\n+pub type MetadataRef = *mut Metadata_opaque;\n+#[allow(missing_copy_implementations)]\n pub enum BasicBlock_opaque {}\n pub type BasicBlockRef = *mut BasicBlock_opaque;\n #[allow(missing_copy_implementations)]\n@@ -501,18 +505,19 @@ pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_v\n \n pub mod debuginfo {\n     pub use self::DIDescriptorFlags::*;\n-    use super::{ValueRef};\n+    use super::{MetadataRef};\n \n     #[allow(missing_copy_implementations)]\n     pub enum DIBuilder_opaque {}\n     pub type DIBuilderRef = *mut DIBuilder_opaque;\n \n-    pub type DIDescriptor = ValueRef;\n+    pub type DIDescriptor = MetadataRef;\n     pub type DIScope = DIDescriptor;\n     pub type DILocation = DIDescriptor;\n     pub type DIFile = DIScope;\n     pub type DILexicalBlock = DIScope;\n     pub type DISubprogram = DIScope;\n+    pub type DINameSpace = DIScope;\n     pub type DIType = DIDescriptor;\n     pub type DIBasicType = DIType;\n     pub type DIDerivedType = DIType;\n@@ -521,6 +526,8 @@ pub mod debuginfo {\n     pub type DIGlobalVariable = DIDescriptor;\n     pub type DIArray = DIDescriptor;\n     pub type DISubrange = DIDescriptor;\n+    pub type DIEnumerator = DIDescriptor;\n+    pub type DITemplateTypeParameter = DIDescriptor;\n \n     #[derive(Copy)]\n     pub enum DIDescriptorFlags {\n@@ -1778,8 +1785,8 @@ extern {\n                                        Flags: c_uint,\n                                        isOptimized: bool,\n                                        Fn: ValueRef,\n-                                       TParam: ValueRef,\n-                                       Decl: ValueRef)\n+                                       TParam: DIArray,\n+                                       Decl: DIDescriptor)\n                                        -> DISubprogram;\n \n     pub fn LLVMDIBuilderCreateBasicType(Builder: DIBuilderRef,\n@@ -1807,7 +1814,7 @@ extern {\n                                          DerivedFrom: DIType,\n                                          Elements: DIArray,\n                                          RunTimeLang: c_uint,\n-                                         VTableHolder: ValueRef,\n+                                         VTableHolder: DIType,\n                                          UniqueId: *const c_char)\n                                          -> DICompositeType;\n \n@@ -1824,25 +1831,25 @@ extern {\n                                          -> DIDerivedType;\n \n     pub fn LLVMDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n-                                           Scope: DIDescriptor,\n+                                           Scope: DIScope,\n                                            File: DIFile,\n                                            Line: c_uint,\n                                            Col: c_uint)\n                                            -> DILexicalBlock;\n \n     pub fn LLVMDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n-                                             Context: DIDescriptor,\n+                                             Context: DIScope,\n                                              Name: *const c_char,\n                                              LinkageName: *const c_char,\n                                              File: DIFile,\n                                              LineNo: c_uint,\n                                              Ty: DIType,\n                                              isLocalToUnit: bool,\n                                              Val: ValueRef,\n-                                             Decl: ValueRef)\n+                                             Decl: DIDescriptor)\n                                              -> DIGlobalVariable;\n \n-    pub fn LLVMDIBuilderCreateLocalVariable(Builder: DIBuilderRef,\n+    pub fn LLVMDIBuilderCreateVariable(Builder: DIBuilderRef,\n                                             Tag: c_uint,\n                                             Scope: DIDescriptor,\n                                             Name: *const c_char,\n@@ -1851,6 +1858,8 @@ extern {\n                                             Ty: DIType,\n                                             AlwaysPreserve: bool,\n                                             Flags: c_uint,\n+                                            AddrOps: *const i64,\n+                                            AddrOpsCount: c_uint,\n                                             ArgNo: c_uint)\n                                             -> DIVariable;\n \n@@ -1881,79 +1890,80 @@ extern {\n     pub fn LLVMDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n                                            Val: ValueRef,\n                                            VarInfo: DIVariable,\n+                                           AddrOps: *const i64,\n+                                           AddrOpsCount: c_uint,\n                                            InsertAtEnd: BasicBlockRef)\n                                            -> ValueRef;\n \n     pub fn LLVMDIBuilderInsertDeclareBefore(Builder: DIBuilderRef,\n                                             Val: ValueRef,\n                                             VarInfo: DIVariable,\n+                                            AddrOps: *const i64,\n+                                            AddrOpsCount: c_uint,\n                                             InsertBefore: ValueRef)\n                                             -> ValueRef;\n \n     pub fn LLVMDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n                                          Name: *const c_char,\n                                          Val: c_ulonglong)\n-                                         -> ValueRef;\n+                                         -> DIEnumerator;\n \n     pub fn LLVMDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n-                                              Scope: ValueRef,\n+                                              Scope: DIScope,\n                                               Name: *const c_char,\n-                                              File: ValueRef,\n+                                              File: DIFile,\n                                               LineNumber: c_uint,\n                                               SizeInBits: c_ulonglong,\n                                               AlignInBits: c_ulonglong,\n-                                              Elements: ValueRef,\n-                                              ClassType: ValueRef)\n-                                              -> ValueRef;\n+                                              Elements: DIArray,\n+                                              ClassType: DIType)\n+                                              -> DIType;\n \n     pub fn LLVMDIBuilderCreateUnionType(Builder: DIBuilderRef,\n-                                        Scope: ValueRef,\n+                                        Scope: DIScope,\n                                         Name: *const c_char,\n-                                        File: ValueRef,\n+                                        File: DIFile,\n                                         LineNumber: c_uint,\n                                         SizeInBits: c_ulonglong,\n                                         AlignInBits: c_ulonglong,\n                                         Flags: c_uint,\n-                                        Elements: ValueRef,\n+                                        Elements: DIArray,\n                                         RunTimeLang: c_uint,\n                                         UniqueId: *const c_char)\n-                                        -> ValueRef;\n+                                        -> DIType;\n \n     pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n \n     pub fn LLVMDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n-                                                    Scope: ValueRef,\n+                                                    Scope: DIScope,\n                                                     Name: *const c_char,\n-                                                    Ty: ValueRef,\n-                                                    File: ValueRef,\n+                                                    Ty: DIType,\n+                                                    File: DIFile,\n                                                     LineNo: c_uint,\n                                                     ColumnNo: c_uint)\n-                                                    -> ValueRef;\n-\n-    pub fn LLVMDIBuilderCreateOpDeref(IntType: TypeRef) -> ValueRef;\n+                                                    -> DITemplateTypeParameter;\n \n-    pub fn LLVMDIBuilderCreateOpPlus(IntType: TypeRef) -> ValueRef;\n+    pub fn LLVMDIBuilderCreateOpDeref() -> i64;\n \n-    pub fn LLVMDIBuilderCreateComplexVariable(Builder: DIBuilderRef,\n-                                              Tag: c_uint,\n-                                              Scope: ValueRef,\n-                                              Name: *const c_char,\n-                                              File: ValueRef,\n-                                              LineNo: c_uint,\n-                                              Ty: ValueRef,\n-                                              AddrOps: *const ValueRef,\n-                                              AddrOpsCount: c_uint,\n-                                              ArgNo: c_uint)\n-                                              -> ValueRef;\n+    pub fn LLVMDIBuilderCreateOpPlus() -> i64;\n \n     pub fn LLVMDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n-                                        Scope: ValueRef,\n+                                        Scope: DIScope,\n                                         Name: *const c_char,\n-                                        File: ValueRef,\n+                                        File: DIFile,\n                                         LineNo: c_uint)\n-                                        -> ValueRef;\n+                                        -> DINameSpace;\n+\n+    pub fn LLVMDIBuilderCreateDebugLocation(Context: ContextRef,\n+                                            Line: c_uint,\n+                                            Column: c_uint,\n+                                            Scope: DIScope,\n+                                            InlinedAt: MetadataRef)\n+                                            -> ValueRef;\n \n-    pub fn LLVMDICompositeTypeSetTypeArray(CompositeType: ValueRef, TypeArray: ValueRef);\n+    pub fn LLVMDICompositeTypeSetTypeArray(Builder: DIBuilderRef,\n+                                           CompositeType: DIType,\n+                                           TypeArray: DIArray);\n     pub fn LLVMWriteTypeToString(Type: TypeRef, s: RustStringRef);\n     pub fn LLVMWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n "}, {"sha": "c398ff72f504a351a6326e6b4372a8141993ea0c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -79,7 +79,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             // Enum variants are parented to the enum definition itself because\n             // they inherit privacy\n             ast::ItemEnum(ref def, _) => {\n-                for variant in def.variants.iter() {\n+                for variant in &def.variants {\n                     // The parent is considered the enclosing enum because the\n                     // enum will dictate the privacy visibility of this variant\n                     // instead.\n@@ -93,7 +93,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             // parent all the methods to the trait to indicate that they're\n             // private.\n             ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n-                for m in methods.iter() {\n+                for m in methods {\n                     match *m {\n                         ast::ProvidedMethod(ref m) => {\n                             self.parents.insert(m.id, item.id);\n@@ -139,7 +139,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n \n         // While we have the id of the struct definition, go ahead and parent\n         // all the fields.\n-        for field in s.fields.iter() {\n+        for field in &s.fields {\n             self.parents.insert(field.node.id, self.curparent);\n         }\n         visit::walk_struct_def(self, s)\n@@ -233,7 +233,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // Enum variants inherit from their parent, so if the enum is\n             // public all variants are public unless they're explicitly priv\n             ast::ItemEnum(ref def, _) if public_first => {\n-                for variant in def.variants.iter() {\n+                for variant in &def.variants {\n                     self.exported_items.insert(variant.node.id);\n                 }\n             }\n@@ -278,7 +278,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 });\n \n                 if public_ty || public_trait {\n-                    for impl_item in impl_items.iter() {\n+                    for impl_item in impl_items {\n                         match *impl_item {\n                             ast::MethodImplItem(ref method) => {\n                                 let meth_public =\n@@ -299,7 +299,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // Default methods on traits are all public so long as the trait\n             // is public\n             ast::ItemTrait(_, _, _, ref methods) if public_first => {\n-                for method in methods.iter() {\n+                for method in methods {\n                     match *method {\n                         ast::ProvidedMethod(ref m) => {\n                             debug!(\"provided {}\", m.id);\n@@ -359,7 +359,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // crate module gets processed as well.\n         if self.prev_exported {\n             assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n-            for export in self.export_map[id].iter() {\n+            for export in &self.export_map[id] {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -837,7 +837,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 match vpath.node {\n                     ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n                     ast::ViewPathList(ref prefix, ref list) => {\n-                        for pid in list.iter() {\n+                        for pid in list {\n                             match pid.node {\n                                 ast::PathListIdent { id, name } => {\n                                     debug!(\"privacy - ident item {}\", id);\n@@ -898,15 +898,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             ast::ExprStruct(_, ref fields, _) => {\n                 match ty::expr_ty(self.tcx, expr).sty {\n                     ty::ty_struct(id, _) => {\n-                        for field in (*fields).iter() {\n+                        for field in &(*fields) {\n                             self.check_field(expr.span, id,\n                                              NamedField(field.ident.node));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow()[expr.id].clone() {\n                             def::DefVariant(_, variant_id, _) => {\n-                                for field in fields.iter() {\n+                                for field in fields {\n                                     self.check_field(expr.span, variant_id,\n                                                      NamedField(field.ident.node));\n                                 }\n@@ -971,15 +971,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             ast::PatStruct(_, ref fields, _) => {\n                 match ty::pat_ty(self.tcx, pattern).sty {\n                     ty::ty_struct(id, _) => {\n-                        for field in fields.iter() {\n+                        for field in fields {\n                             self.check_field(pattern.span, id,\n                                              NamedField(field.node.ident));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().get(&pattern.id) {\n                             Some(&def::DefVariant(_, variant_id, _)) => {\n-                                for field in fields.iter() {\n+                                for field in fields {\n                                     self.check_field(pattern.span, variant_id,\n                                                      NamedField(field.node.ident));\n                                 }\n@@ -1091,7 +1091,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 check_inherited(item.span, item.vis,\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         ast::MethodImplItem(ref m) => {\n                             check_inherited(m.span, m.pe_vis(), \"\");\n@@ -1112,7 +1112,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             }\n \n             ast::ItemEnum(ref def, _) => {\n-                for v in def.variants.iter() {\n+                for v in &def.variants {\n                     match v.node.vis {\n                         ast::Public => {\n                             if item.vis == ast::Public {\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             }\n \n             ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods.iter() {\n+                for m in methods {\n                     match *m {\n                         ast::ProvidedMethod(ref m) => {\n                             check_inherited(m.span, m.pe_vis(),\n@@ -1157,7 +1157,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             }\n         }\n         let check_struct = |&: def: &ast::StructDef| {\n-            for f in def.fields.iter() {\n+            for f in &def.fields {\n                match f.node.kind {\n                     ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n                     ast::UnnamedField(..) => {}\n@@ -1167,7 +1167,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n         check_inherited(tcx, item.span, item.vis);\n         match item.node {\n             ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         ast::MethodImplItem(ref m) => {\n                             check_inherited(tcx, m.span, m.pe_vis());\n@@ -1177,20 +1177,20 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ItemForeignMod(ref fm) => {\n-                for i in fm.items.iter() {\n+                for i in &fm.items {\n                     check_inherited(tcx, i.span, i.vis);\n                 }\n             }\n             ast::ItemEnum(ref def, _) => {\n-                for v in def.variants.iter() {\n+                for v in &def.variants {\n                     check_inherited(tcx, v.span, v.node.vis);\n                 }\n             }\n \n             ast::ItemStruct(ref def, _) => check_struct(&**def),\n \n             ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods.iter() {\n+                for m in methods {\n                     match *m {\n                         ast::RequiredMethod(..) => {}\n                         ast::ProvidedMethod(ref m) => check_inherited(tcx, m.span,\n@@ -1302,7 +1302,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     return\n                 }\n \n-                for bound in bounds.iter() {\n+                for bound in &**bounds {\n                     self.check_ty_param_bound(bound)\n                 }\n             }\n@@ -1371,7 +1371,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                     match *trait_ref {\n                         None => {\n-                            for impl_item in impl_items.iter() {\n+                            for impl_item in impl_items {\n                                 match *impl_item {\n                                     ast::MethodImplItem(ref method) => {\n                                         visit::walk_method_helper(self, &**method)\n@@ -1400,7 +1400,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // impl Public<Private> { ... }. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n-                    for impl_item in impl_items.iter() {\n+                    for impl_item in impl_items {\n                         match *impl_item {\n                             ast::MethodImplItem(ref method) => {\n                                 if method.pe_explicit_self().node ==\n@@ -1439,15 +1439,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            for bound in ty_param.bounds.iter() {\n+        for ty_param in &*generics.ty_params {\n+            for bound in &*ty_param.bounds {\n                 self.check_ty_param_bound(bound)\n             }\n         }\n-        for predicate in generics.where_clause.predicates.iter() {\n+        for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                    for bound in bound_pred.bounds.iter() {\n+                    for bound in &*bound_pred.bounds {\n                         self.check_ty_param_bound(bound)\n                     }\n                 }"}, {"sha": "a503398d4844fb2fdbbc0132444a3ffc71f21ac3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -223,8 +223,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                              token::get_name(name))[]);\n                     {\n                         let r = child.span_for_namespace(ns);\n-                        for sp in r.iter() {\n-                            self.session.span_note(*sp,\n+                        if let Some(sp) = r {\n+                            self.session.span_note(sp,\n                                  &format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n                                       token::get_name(name))[]);\n@@ -238,7 +238,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // Check each statement.\n-        for statement in block.stmts.iter() {\n+        for statement in &block.stmts {\n             match statement.node {\n                 StmtDecl(ref declaration, _) => {\n                     match declaration.node {\n@@ -338,7 +338,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             }\n                         }\n \n-                        for source_item in source_items.iter() {\n+                        for source_item in source_items {\n                             let (module_path, name) = match source_item.node {\n                                 PathListIdent { name, .. } =>\n                                     (module_path.clone(), name.name),\n@@ -477,7 +477,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 let module = name_bindings.get_module();\n \n-                for variant in (*enum_definition).variants.iter() {\n+                for variant in &(*enum_definition).variants {\n                     self.build_reduced_graph_for_variant(\n                         &**variant,\n                         local_def(item.id),\n@@ -591,7 +591,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 };\n \n                 // For each implementation item...\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         MethodImplItem(ref method) => {\n                             // Add the method to the module.\n@@ -675,7 +675,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let def_id = local_def(item.id);\n \n                 // Add the names of all the items to the trait info.\n-                for trait_item in items.iter() {\n+                for trait_item in items {\n                     let (name, kind) = match *trait_item {\n                         ast::RequiredMethod(_) |\n                         ast::ProvidedMethod(_) => {\n@@ -926,7 +926,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n               let trait_item_def_ids =\n                 csearch::get_trait_item_def_ids(&self.session.cstore, def_id);\n-              for trait_item_def_id in trait_item_def_ids.iter() {\n+              for trait_item_def_id in &trait_item_def_ids {\n                   let (trait_item_name, trait_item_kind) =\n                       csearch::get_trait_item_name_and_kind(\n                           &self.session.cstore,\n@@ -1082,7 +1082,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                                 // Add each static method to the module.\n                                 let new_parent = type_module;\n-                                for method_info in methods.iter() {\n+                                for method_info in methods {\n                                     let name = method_info.name;\n                                     debug!(\"(building reduced graph for \\\n                                              external crate) creating \\"}, {"sha": "a239c73c110dbd67e96353ad8efca3f20b6b82b5", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                     }\n \n                     ViewPathList(_, ref list) => {\n-                        for i in list.iter() {\n+                        for i in list {\n                             self.finalize_import(i.node.id(), i.span);\n                         }\n                     }"}, {"sha": "a5fb57eadc41d0901d6d4f77043c8292b5ee9f39", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1031,7 +1031,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.current_module = orig_module;\n \n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n-        for (_, child_node) in module_.children.borrow().iter() {\n+        for (_, child_node) in &*module_.children.borrow() {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -1042,7 +1042,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        for (_, child_module) in module_.anonymous_children.borrow().iter() {\n+        for (_, child_module) in &*module_.anonymous_children.borrow() {\n             self.resolve_imports_for_module_subtree(child_module.clone());\n         }\n     }\n@@ -1087,7 +1087,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn names_to_string(&self, names: &[Name]) -> String {\n         let mut first = true;\n         let mut result = String::new();\n-        for name in names.iter() {\n+        for name in names {\n             if first {\n                 first = false\n             } else {\n@@ -1596,7 +1596,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Add all resolved imports from the containing module.\n         let import_resolutions = containing_module.import_resolutions.borrow();\n-        for (ident, target_import_resolution) in import_resolutions.iter() {\n+        for (ident, target_import_resolution) in &*import_resolutions {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n                    token::get_name(*ident),\n@@ -1657,7 +1657,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Add all children from the containing module.\n         build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n \n-        for (&name, name_bindings) in containing_module.children.borrow().iter() {\n+        for (&name, name_bindings) in &*containing_module.children.borrow() {\n             self.merge_import_resolution(module_,\n                                          containing_module.clone(),\n                                          import_directive,\n@@ -1667,7 +1667,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Add external module children from the containing module.\n-        for (&name, module) in containing_module.external_module_children.borrow().iter() {\n+        for (&name, module) in &*containing_module.external_module_children.borrow() {\n             let name_bindings =\n                 Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n             self.merge_import_resolution(module_,\n@@ -2519,7 +2519,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Descend into children and anonymous children.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n-        for (_, child_node) in module_.children.borrow().iter() {\n+        for (_, child_node) in &*module_.children.borrow() {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Continue.\n@@ -2530,7 +2530,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        for (_, module_) in module_.anonymous_children.borrow().iter() {\n+        for (_, module_) in &*module_.anonymous_children.borrow() {\n             self.report_unresolved_imports(module_.clone());\n         }\n     }\n@@ -2609,7 +2609,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n                 let mut def = d;\n-                for rib in ribs.iter() {\n+                for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind => {\n                             // Nothing to do. Continue.\n@@ -2680,7 +2680,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             DlDef(def @ DefTyParam(..)) |\n             DlDef(def @ DefSelfTy(..)) => {\n-                for rib in ribs.iter() {\n+                for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ClosureRibKind(..) => {\n                             // Nothing to do. Continue.\n@@ -2795,8 +2795,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n             ItemEnum(ref enum_def, ref generics) => {\n-                for variant in (*enum_def).variants.iter() {\n-                    for dis_expr in variant.node.disr_expr.iter() {\n+                for variant in &(*enum_def).variants {\n+                    if let Some(ref dis_expr) = variant.node.disr_expr {\n                         // resolve the discriminator expr\n                         // as a constant\n                         self.with_constant_rib(|this| {\n@@ -2863,7 +2863,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.resolve_type_parameter_bounds(item.id, bounds,\n                                                        TraitDerivation);\n \n-                    for trait_item in (*trait_items).iter() {\n+                    for trait_item in &(*trait_items) {\n                         // Create a new rib for the trait_item-specific type\n                         // parameters.\n                         //\n@@ -2885,7 +2885,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 this.resolve_where_clause(&ty_m.generics\n                                                                .where_clause);\n \n-                                for argument in ty_m.decl.inputs.iter() {\n+                                for argument in &ty_m.decl.inputs {\n                                     this.resolve_type(&*argument.ty);\n                                 }\n \n@@ -2929,7 +2929,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ItemForeignMod(ref foreign_module) => {\n                 self.with_scope(Some(name), |this| {\n-                    for foreign_item in foreign_module.items.iter() {\n+                    for foreign_item in &foreign_module.items {\n                         match foreign_item.node {\n                             ForeignItemFn(_, ref generics) => {\n                                 this.with_type_parameter_rib(\n@@ -3075,7 +3075,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n                 Some(declaration) => {\n                     let mut bindings_list = HashMap::new();\n-                    for argument in declaration.inputs.iter() {\n+                    for argument in &declaration.inputs {\n                         this.resolve_pattern(&*argument.pat,\n                                              ArgumentIrrefutableMode,\n                                              &mut bindings_list);\n@@ -3103,14 +3103,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_type_parameters(&mut self,\n                                type_parameters: &OwnedSlice<TyParam>) {\n-        for type_parameter in type_parameters.iter() {\n+        for type_parameter in &**type_parameters {\n             self.resolve_type_parameter(type_parameter);\n         }\n     }\n \n     fn resolve_type_parameter(&mut self,\n                               type_parameter: &TyParam) {\n-        for bound in type_parameter.bounds.iter() {\n+        for bound in &*type_parameter.bounds {\n             self.resolve_type_parameter_bound(type_parameter.id, bound,\n                                               TraitBoundingTypeParameter);\n         }\n@@ -3124,7 +3124,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      id: NodeId,\n                                      type_parameter_bounds: &OwnedSlice<TyParamBound>,\n                                      reference_type: TraitReferenceType) {\n-        for type_parameter_bound in type_parameter_bounds.iter() {\n+        for type_parameter_bound in &**type_parameter_bounds {\n             self.resolve_type_parameter_bound(id, type_parameter_bound,\n                                               reference_type);\n         }\n@@ -3193,12 +3193,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_where_clause(&mut self, where_clause: &ast::WhereClause) {\n-        for predicate in where_clause.predicates.iter() {\n+        for predicate in &where_clause.predicates {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n                     self.resolve_type(&*bound_pred.bounded_ty);\n \n-                    for bound in bound_pred.bounds.iter() {\n+                    for bound in &*bound_pred.bounds {\n                         self.resolve_type_parameter_bound(bound_pred.bounded_ty.id, bound,\n                                                           TraitBoundingTypeParameter);\n                     }\n@@ -3236,7 +3236,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             this.resolve_where_clause(&generics.where_clause);\n \n             // Resolve fields.\n-            for field in fields.iter() {\n+            for field in fields {\n                 this.resolve_type(&*field.node.ty);\n             }\n         });\n@@ -3320,7 +3320,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 this.resolve_type(self_type);\n \n                 this.with_current_self_type(self_type, |this| {\n-                    for impl_item in impl_items.iter() {\n+                    for impl_item in impl_items {\n                         match *impl_item {\n                             MethodImplItem(ref method) => {\n                                 // If this is a trait impl, ensure the method\n@@ -3375,7 +3375,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn check_trait_item(&self, name: Name, span: Span) {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n-        for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n+        if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if self.trait_item_map.get(&(name, did)).is_none() {\n                 let path_str = self.path_names_to_string(&trait_ref.path);\n                 self.resolve_error(span,\n@@ -3442,7 +3442,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for (i, p) in arm.pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(&**p);\n \n-            for (&key, &binding_0) in map_0.iter() {\n+            for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                   None => {\n                     self.resolve_error(\n@@ -3465,7 +3465,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            for (&key, &binding) in map_i.iter() {\n+            for (&key, &binding) in &map_i {\n                 if !map_0.contains_key(&key) {\n                     self.resolve_error(\n                         binding.span,\n@@ -3482,7 +3482,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.value_ribs.push(Rib::new(NormalRibKind));\n \n         let mut bindings_list = HashMap::new();\n-        for pattern in arm.pats.iter() {\n+        for pattern in &arm.pats {\n             self.resolve_pattern(&**pattern, RefutableMode, &mut bindings_list);\n         }\n \n@@ -3513,7 +3513,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Check for imports appearing after non-item statements.\n         let mut found_non_item = false;\n-        for statement in block.stmts.iter() {\n+        for statement in &block.stmts {\n             if let ast::StmtDecl(ref declaration, _) = statement.node {\n                 if let ast::DeclItem(ref i) = declaration.node {\n                     match i.node {\n@@ -3607,10 +3607,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             TyQPath(ref qpath) => {\n                 self.resolve_type(&*qpath.self_type);\n                 self.resolve_trait_reference(ty.id, &*qpath.trait_ref, TraitQPath);\n-                for ty in qpath.item_path.parameters.types().into_iter() {\n+                for ty in qpath.item_path.parameters.types() {\n                     self.resolve_type(&**ty);\n                 }\n-                for binding in qpath.item_path.parameters.bindings().into_iter() {\n+                for binding in qpath.item_path.parameters.bindings() {\n                     self.resolve_type(&*binding.ty);\n                 }\n             }\n@@ -4365,7 +4365,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut values: Vec<uint> = Vec::new();\n \n         for rib in this.value_ribs.iter().rev() {\n-            for (&k, _) in rib.bindings.iter() {\n+            for (&k, _) in &rib.bindings {\n                 maybes.push(token::get_name(k));\n                 values.push(uint::MAX);\n             }\n@@ -4640,7 +4640,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             build_reduced_graph::populate_module_if_necessary(self, &search_module);\n \n             {\n-                for (_, child_names) in search_module.children.borrow().iter() {\n+                for (_, child_names) in &*search_module.children.borrow() {\n                     let def = match child_names.def_for_namespace(TypeNS) {\n                         Some(def) => def,\n                         None => continue\n@@ -4656,7 +4656,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             // Look for imports.\n-            for (_, import) in search_module.import_resolutions.borrow().iter() {\n+            for (_, import) in &*search_module.import_resolutions.borrow() {\n                 let target = match import.target_for_namespace(TypeNS) {\n                     None => continue,\n                     Some(target) => target,\n@@ -4766,13 +4766,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"Children:\");\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n-        for (&name, _) in module_.children.borrow().iter() {\n+        for (&name, _) in &*module_.children.borrow() {\n             debug!(\"* {}\", token::get_name(name));\n         }\n \n         debug!(\"Import resolutions:\");\n         let import_resolutions = module_.import_resolutions.borrow();\n-        for (&name, import_resolution) in import_resolutions.iter() {\n+        for (&name, import_resolution) in &*import_resolutions {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = \"\".to_string(); }"}, {"sha": "5d025f40d32398490597b23e1be838c23a5d2e7a", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         self.record_exports_for_module(&*module_);\n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n \n-        for (_, child_name_bindings) in module_.children.borrow().iter() {\n+        for (_, child_name_bindings) in &*module_.children.borrow() {\n             match child_name_bindings.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -91,7 +91,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n             }\n         }\n \n-        for (_, child_module) in module_.anonymous_children.borrow().iter() {\n+        for (_, child_module) in &*module_.anonymous_children.borrow() {\n             self.record_exports_for_module_subtree(child_module.clone());\n         }\n     }\n@@ -133,12 +133,12 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n     fn add_exports_for_module(&mut self,\n                               exports: &mut Vec<Export>,\n                               module_: &Module) {\n-        for (name, importresolution) in module_.import_resolutions.borrow().iter() {\n+        for (name, importresolution) in &*module_.import_resolutions.borrow() {\n             if !importresolution.is_public {\n                 continue\n             }\n             let xs = [TypeNS, ValueNS];\n-            for &ns in xs.iter() {\n+            for &ns in &xs {\n                 match importresolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\","}, {"sha": "be55ab9fda37889bac41a145c9ae6614e213c541", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -194,7 +194,7 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     symbol_hasher.input_str(&link_meta.crate_name[]);\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n-    for meta in tcx.sess.crate_metadata.borrow().iter() {\n+    for meta in &*tcx.sess.crate_metadata.borrow() {\n         symbol_hasher.input_str(&meta[]);\n     }\n     symbol_hasher.input_str(\"-\");\n@@ -265,7 +265,7 @@ pub fn sanitize(s: &str) -> String {\n     return result;\n }\n \n-pub fn mangle<PI: Iterator<Item=PathElem>>(mut path: PI,\n+pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n                                       hash: Option<&str>) -> String {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n@@ -370,7 +370,7 @@ pub fn link_binary(sess: &Session,\n                    outputs: &OutputFilenames,\n                    crate_name: &str) -> Vec<Path> {\n     let mut out_filenames = Vec::new();\n-    for &crate_type in sess.crate_types.borrow().iter() {\n+    for &crate_type in &*sess.crate_types.borrow() {\n         if invalid_output_for_target(sess, crate_type) {\n             sess.bug(&format!(\"invalid output type `{:?}` for target os `{}`\",\n                              crate_type, sess.opts.target_triple)[]);\n@@ -535,7 +535,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     let mut ab = ArchiveBuilder::create(config);\n     ab.add_file(obj_filename).unwrap();\n \n-    for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n+    for &(ref l, kind) in &*sess.cstore.get_used_libraries().borrow() {\n         match kind {\n             cstore::NativeStatic => {\n                 ab.add_native_library(&l[]).unwrap();\n@@ -721,7 +721,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     let mut all_native_libs = vec![];\n \n-    for &(cnum, ref path) in crates.iter() {\n+    for &(cnum, ref path) in &crates {\n         let ref name = sess.cstore.get_crate_data(cnum).name;\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n@@ -740,13 +740,13 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n     let _ = ab.build();\n \n     if !all_native_libs.is_empty() {\n-        sess.warn(\"link against the following native artifacts when linking against \\\n+        sess.note(\"link against the following native artifacts when linking against \\\n                   this static library\");\n         sess.note(\"the order and any duplication can be significant on some platforms, \\\n                   and so may need to be preserved\");\n     }\n \n-    for &(kind, ref lib) in all_native_libs.iter() {\n+    for &(kind, ref lib) in &all_native_libs {\n         let name = match kind {\n             cstore::NativeStatic => \"static library\",\n             cstore::NativeUnknown => \"library\",\n@@ -1055,10 +1055,10 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n     let libs = sess.cstore.get_used_libraries();\n     let libs = libs.borrow();\n \n-    let mut staticlibs = libs.iter().filter_map(|&(ref l, kind)| {\n+    let staticlibs = libs.iter().filter_map(|&(ref l, kind)| {\n         if kind == cstore::NativeStatic {Some(l)} else {None}\n     });\n-    let mut others = libs.iter().filter(|&&(_, kind)| {\n+    let others = libs.iter().filter(|&&(_, kind)| {\n         kind != cstore::NativeStatic\n     });\n \n@@ -1133,7 +1133,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // crates.\n     let deps = sess.cstore.get_used_crates(cstore::RequireDynamic);\n \n-    for &(cnum, _) in deps.iter() {\n+    for &(cnum, _) in &deps {\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n@@ -1275,9 +1275,9 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n     // we're just getting an ordering of crate numbers, we're not worried about\n     // the paths.\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n-    for (cnum, _) in crates.into_iter() {\n+    for (cnum, _) in crates {\n         let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n-        for &(kind, ref lib) in libs.iter() {\n+        for &(kind, ref lib) in &libs {\n             match kind {\n                 cstore::NativeUnknown => {\n                     cmd.arg(format!(\"-l{}\", *lib));"}, {"sha": "38c68bc9fa426005e6add8fc17fd3a2f29ade027", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -34,7 +34,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     }\n \n     // Make sure we actually can run LTO\n-    for crate_type in sess.crate_types.borrow().iter() {\n+    for crate_type in &*sess.crate_types.borrow() {\n         match *crate_type {\n             config::CrateTypeExecutable | config::CrateTypeStaticlib => {}\n             _ => {\n@@ -48,7 +48,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n-    for (cnum, path) in crates.into_iter() {\n+    for (cnum, path) in crates {\n         let name = sess.cstore.get_crate_data(cnum).name.clone();\n         let path = match path {\n             Some(p) => p,"}, {"sha": "5312d2ca1ddeee3d40675c631a80262e4b82599e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -100,7 +100,7 @@ impl SharedEmitter {\n \n     fn dump(&mut self, handler: &Handler) {\n         let mut buffer = self.buffer.lock().unwrap();\n-        for diag in buffer.iter() {\n+        for diag in &*buffer {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n@@ -452,7 +452,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                      config.no_builtins);\n             }\n \n-            for pass in config.passes.iter() {\n+            for pass in &config.passes {\n                 let pass = CString::from_slice(pass.as_bytes());\n                 if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n                     cgcx.handler.warn(format!(\"unknown pass {:?}, ignoring\",\n@@ -597,7 +597,7 @@ pub fn run_passes(sess: &Session,\n         modules_config.emit_bc = true;\n     }\n \n-    for output_type in output_types.iter() {\n+    for output_type in output_types {\n         match *output_type {\n             config::OutputTypeBitcode => { modules_config.emit_bc = true; },\n             config::OutputTypeLlvmAssembly => { modules_config.emit_ir = true; },\n@@ -761,7 +761,7 @@ pub fn run_passes(sess: &Session,\n     // Otherwise, we produced it only as a temporary output, and will need\n     // to get rid of it.\n     let mut user_wants_bitcode = false;\n-    for output_type in output_types.iter() {\n+    for output_type in output_types {\n         match *output_type {\n             config::OutputTypeBitcode => {\n                 user_wants_bitcode = true;\n@@ -941,7 +941,7 @@ fn run_work_multithreaded(sess: &Session,\n     }\n \n     let mut panicked = false;\n-    for rx in futures.into_iter() {\n+    for rx in futures {\n         match rx.recv() {\n             Ok(()) => {},\n             Err(_) => {\n@@ -1015,7 +1015,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         // FIXME #21627 disable faulty FastISel on AArch64 (even for -O0)\n         if sess.target.target.arch.as_slice() == \"aarch64\" { add(\"-fast-isel=0\"); }\n \n-        for arg in sess.opts.cg.llvm_args.iter() {\n+        for arg in &sess.opts.cg.llvm_args {\n             add(&(*arg)[]);\n         }\n     }"}, {"sha": "94a1d4dd5b2a42f89546bd1e2d4412fe92daefc4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -23,17 +23,15 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n-\n #![feature(alloc)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n+#![feature(env)]\n #![feature(libc)]\n-#![feature(os)]\n #![feature(path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "7758039e40a418ddbf2a522ee0c55ad68f53f75a", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -34,7 +34,7 @@ use middle::ty::{self, Ty};\n \n use std::cell::Cell;\n use std::old_io::{self, File, fs};\n-use std::os;\n+use std::env;\n \n use syntax::ast_util::{self, PostExpansionMethod};\n use syntax::ast::{self, NodeId, DefId};\n@@ -113,7 +113,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             error!(\"Mis-calculated spans for path '{}'. \\\n                     Found {} spans, expected {}. Found spans:\",\n                    path_to_string(path), spans.len(), path.segments.len());\n-            for s in spans.iter() {\n+            for s in &spans {\n                 let loc = self.sess.codemap().lookup_char_pos(s.lo);\n                 error!(\"    '{}' in {}, line {}\",\n                        self.span.snippet(*s), loc.file.name, loc.line);\n@@ -204,7 +204,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return;\n         }\n         let sub_paths = &sub_paths[..len-2];\n-        for &(ref span, ref qualname) in sub_paths.iter() {\n+        for &(ref span, ref qualname) in sub_paths {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      &qualname[],\n@@ -264,13 +264,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n-        for arg in formals.iter() {\n+        for arg in formals {\n             assert!(self.collected_paths.len() == 0 && !self.collecting);\n             self.collecting = true;\n             self.visit_pat(&*arg.pat);\n             self.collecting = false;\n             let span_utils = self.span.clone();\n-            for &(id, ref p, _, _) in self.collected_paths.iter() {\n+            for &(id, ref p, _, _) in &self.collected_paths {\n                 let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n                     (*self.analysis.ty_cx.node_types.borrow())[id]);\n                 // get the span only for the name of the variable (I hope the path is only ever a\n@@ -389,7 +389,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.process_formals(&method.pe_fn_decl().inputs, qualname);\n \n         // walk arg and return types\n-        for arg in method.pe_fn_decl().inputs.iter() {\n+        for arg in &method.pe_fn_decl().inputs {\n             self.visit_ty(&*arg.ty);\n         }\n \n@@ -493,7 +493,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.process_formals(&decl.inputs, &qualname[]);\n \n         // walk arg and return types\n-        for arg in decl.inputs.iter() {\n+        for arg in &decl.inputs {\n             self.visit_ty(&*arg.ty);\n         }\n \n@@ -580,7 +580,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             &val[]);\n \n         // fields\n-        for field in def.fields.iter() {\n+        for field in &def.fields {\n             self.process_struct_field_def(field, &qualname[], item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n@@ -605,7 +605,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                        &format!(\"Could not find subspan for enum {}\",\n                                                enum_name)[]),\n         }\n-        for variant in enum_definition.variants.iter() {\n+        for variant in &enum_definition.variants {\n             let name = get_ident(variant.node.name);\n             let name = name.get();\n             let mut qualname = enum_name.clone();\n@@ -623,7 +623,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                &enum_name[],\n                                                &val[],\n                                                item.id);\n-                    for arg in args.iter() {\n+                    for arg in args {\n                         self.visit_ty(&*arg.ty);\n                     }\n                 }\n@@ -642,7 +642,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         &val[],\n                         item.id);\n \n-                    for field in struct_def.fields.iter() {\n+                    for field in &struct_def.fields {\n                         self.process_struct_field_def(field, qualname.as_slice(), variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n@@ -701,7 +701,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n-        for impl_item in impl_items.iter() {\n+        for impl_item in impl_items {\n             match *impl_item {\n                 ast::MethodImplItem(ref method) => {\n                     visit::walk_method_helper(self, &**method)\n@@ -729,7 +729,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                            &val[]);\n \n         // super-traits\n-        for super_bound in trait_refs.iter() {\n+        for super_bound in &**trait_refs {\n             let trait_ref = match *super_bound {\n                 ast::TraitTyParamBound(ref trait_ref, _) => {\n                     trait_ref\n@@ -759,7 +759,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // walk generics and methods\n         self.process_generic_params(generics, item.span, &qualname[], item.id);\n-        for method in methods.iter() {\n+        for method in methods {\n             self.visit_trait_item(method)\n         }\n     }\n@@ -912,11 +912,11 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             _ => None\n         };\n \n-        for field in fields.iter() {\n+        for field in fields {\n             match struct_def {\n                 Some(struct_def) => {\n                     let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for f in fields.iter() {\n+                    for f in &fields {\n                         if generated_code(field.ident.span) {\n                             continue;\n                         }\n@@ -1010,10 +1010,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                    self.span.snippet(p.span))[]);\n                     }\n                 };\n-                for &Spanned { node: ref field, span } in fields.iter() {\n+                for &Spanned { node: ref field, span } in fields {\n                     let sub_span = self.span.span_for_first_ident(span);\n                     let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for f in fields.iter() {\n+                    for f in fields {\n                         if f.name == field.ident.name {\n                             self.fmt.ref_str(recorder::VarRef,\n                                              span,\n@@ -1104,7 +1104,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         let glob_map = &self.analysis.glob_map;\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&item.id) {\n-                            for n in glob_map[item.id].iter() {\n+                            for n in &glob_map[item.id] {\n                                 if name_string.len() > 0 {\n                                     name_string.push_str(\", \");\n                                 }\n@@ -1122,7 +1122,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         self.write_sub_paths(path, true);\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n-                        for plid in list.iter() {\n+                        for plid in list {\n                             match plid.node {\n                                 ast::PathListIdent { id, .. } => {\n                                     match self.lookup_type_ref(id) {\n@@ -1208,8 +1208,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for param in generics.ty_params.iter() {\n-            for bound in param.bounds.iter() {\n+        for param in &*generics.ty_params {\n+            for bound in &*param.bounds {\n                 if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n                     self.process_trait_ref(&trait_ref.trait_ref);\n                 }\n@@ -1270,7 +1270,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                          scope_id);\n \n                 // walk arg and return types\n-                for arg in method_type.decl.inputs.iter() {\n+                for arg in &method_type.decl.inputs {\n                     self.visit_ty(&*arg.ty);\n                 }\n \n@@ -1349,7 +1349,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 match *ty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n-                        for f in fields.iter() {\n+                        for f in &fields {\n                             if f.name == ident.node.name {\n                                 let sub_span = self.span.span_for_last_ident(ex.span);\n                                 self.fmt.ref_str(recorder::VarRef,\n@@ -1404,7 +1404,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.process_formals(&decl.inputs, &id[]);\n \n                 // walk arg and return types\n-                for arg in decl.inputs.iter() {\n+                for arg in &decl.inputs {\n                     self.visit_ty(&*arg.ty);\n                 }\n \n@@ -1435,15 +1435,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     fn visit_arm(&mut self, arm: &ast::Arm) {\n         assert!(self.collected_paths.len() == 0 && !self.collecting);\n         self.collecting = true;\n-        for pattern in arm.pats.iter() {\n+        for pattern in &arm.pats {\n             // collect paths from the arm's patterns\n             self.visit_pat(&**pattern);\n         }\n \n         // This is to get around borrow checking, because we need mut self to call process_path.\n         let mut paths_to_process = vec![];\n         // process collected paths\n-        for &(id, ref p, ref immut, ref_kind) in self.collected_paths.iter() {\n+        for &(id, ref p, ref immut, ref_kind) in &self.collected_paths {\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n@@ -1477,7 +1477,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                             *def)\n             }\n         }\n-        for &(id, ref path, ref_kind) in paths_to_process.iter() {\n+        for &(id, ref path, ref_kind) in &paths_to_process {\n             self.process_path(id, path.span, path, ref_kind);\n         }\n         self.collecting = false;\n@@ -1508,7 +1508,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n         let value = self.span.snippet(l.span);\n \n-        for &(id, ref p, ref immut, _) in self.collected_paths.iter() {\n+        for &(id, ref p, ref immut, _) in &self.collected_paths {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n             let types = self.analysis.ty_cx.node_types.borrow();\n             let typ = ppaux::ty_to_string(&self.analysis.ty_cx, (*types)[id]);\n@@ -1551,9 +1551,9 @@ pub fn process_crate(sess: &Session,\n     info!(\"Dumping crate {}\", cratename);\n \n     // find a path to dump our data to\n-    let mut root_path = match os::getenv(\"DXR_RUST_TEMP_FOLDER\") {\n-        Some(val) => Path::new(val),\n-        None => match odir {\n+    let mut root_path = match env::var_string(\"DXR_RUST_TEMP_FOLDER\") {\n+        Ok(val) => Path::new(val),\n+        Err(..) => match odir {\n             Some(val) => val.join(\"dxr\"),\n             None => Path::new(\"dxr-temp\"),\n         },"}, {"sha": "52fe8797592b5b72c8bfedc006fdfb8a07ef21ac", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -366,7 +366,7 @@ impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n }\n \n fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n-    for br in m.iter() {\n+    for br in m {\n         match br.pats[col].node {\n             ast::PatIdent(_, _, Some(_)) => return true,\n             _ => ()\n@@ -561,7 +561,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n \n     let mut found: Vec<Opt> = vec![];\n-    for br in m.iter() {\n+    for br in m {\n         let cur = br.pats[col];\n         let opt = match cur.node {\n             ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n@@ -827,7 +827,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                bindings_map: &BindingsMap<'tcx>,\n                                cs: Option<cleanup::ScopeId>)\n                                -> Block<'blk, 'tcx> {\n-    for (&ident, &binding_info) in bindings_map.iter() {\n+    for (&ident, &binding_info) in bindings_map {\n         let llval = match binding_info.trmode {\n             // By value mut binding for a copy type: load from the ptr\n             // into the matched value and copy to our alloca\n@@ -883,15 +883,15 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let val = unpack_datum!(bcx, expr::trans(bcx, guard_expr));\n     let val = val.to_llbool(bcx);\n \n-    for (_, &binding_info) in data.bindings_map.iter() {\n+    for (_, &binding_info) in &data.bindings_map {\n         if let TrByCopy(llbinding) = binding_info.trmode {\n             call_lifetime_end(bcx, llbinding);\n         }\n     }\n \n     with_cond(bcx, Not(bcx, val, guard_expr.debug_loc()), |bcx| {\n         // Guard does not match: remove all bindings from the lllocals table\n-        for (_, &binding_info) in data.bindings_map.iter() {\n+        for (_, &binding_info) in &data.bindings_map {\n             call_lifetime_end(bcx, binding_info.llmatch);\n             bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n         }\n@@ -949,7 +949,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         None => {\n             let data = &m[0].data;\n-            for &(ref ident, ref value_ptr) in m[0].bound_ptrs.iter() {\n+            for &(ref ident, ref value_ptr) in &m[0].bound_ptrs {\n                 let llmatch = data.bindings_map[*ident].llmatch;\n                 call_lifetime_start(bcx, llmatch);\n                 Store(bcx, *value_ptr, llmatch);\n@@ -1055,7 +1055,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             Variant(_, ref repr, _) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n                 kind = the_kind;\n-                for &tval in val_opt.iter() { test_val = tval; }\n+                if let Some(tval) = val_opt { test_val = tval; }\n             }\n             SliceLengthEqual(_) | SliceLengthGreaterOrEqual(_, _) => {\n                 let (_, len) = tvec::get_base_and_len(bcx, val, left_ty);\n@@ -1064,7 +1064,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n     }\n-    for o in opts.iter() {\n+    for o in &opts {\n         match *o {\n             ConstantRange(_, _) => { kind = Compare; break },\n             SliceLengthGreaterOrEqual(_, _) => { kind = CompareSliceLength; break },\n@@ -1410,7 +1410,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     compile_submatch(bcx, &matches[], &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n-    for arm_data in arm_datas.iter() {\n+    for arm_data in &arm_datas {\n         let mut bcx = arm_data.bodycx;\n \n         // insert bindings into the lllocals map and add cleanups\n@@ -1623,7 +1623,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     });\n             }\n \n-            for inner_pat in inner.iter() {\n+            if let Some(ref inner_pat) = *inner {\n                 bcx = bind_irrefutable_pat(bcx, &**inner_pat, val, cleanup_scope);\n             }\n         }\n@@ -1639,7 +1639,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     &*repr,\n                                                     vinfo.disr_val,\n                                                     val);\n-                    for sub_pat in sub_pats.iter() {\n+                    if let Some(ref sub_pat) = *sub_pats {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n                             bcx = bind_irrefutable_pat(bcx, &*sub_pat[i],\n                                                        argval, cleanup_scope);\n@@ -1673,7 +1673,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n-                for f in fields.iter() {\n+                for f in fields {\n                     let ix = ty::field_idx_strict(tcx, f.node.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);"}, {"sha": "b99622ce911d2f2b6ee0f393874335e78eee358d", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -285,7 +285,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // alignment of the type.\n             let (_, align) = union_size_and_align(fields.as_slice());\n             let mut use_align = true;\n-            for st in fields.iter() {\n+            for st in &fields {\n                 // Get the first non-zero-sized field\n                 let field = st.fields.iter().skip(1).filter(|ty| {\n                     let t = type_of::sizing_type_of(cx, **ty);\n@@ -519,7 +519,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             cx.tcx().sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n         }\n     }\n-    for &ity in attempts.iter() {\n+    for &ity in attempts {\n         if bounds_usable(cx, ity, bounds) {\n             return ity;\n         }\n@@ -563,7 +563,7 @@ fn ensure_struct_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                  packed: bool,\n                                                  scapegoat: Ty<'tcx>) {\n     let mut offset = 0;\n-    for &llty in fields.iter() {\n+    for &llty in fields {\n         // Invariant: offset < ccx.obj_size_bound() <= 1<<61\n         if !packed {\n             let type_align = machine::llalign_of_min(ccx, llty);\n@@ -1097,7 +1097,7 @@ fn compute_struct_field_offsets<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut offsets = vec!();\n \n     let mut offset = 0;\n-    for &ty in st.fields.iter() {\n+    for &ty in &st.fields {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         if !st.packed {\n             let type_align = type_of::align_of(ccx, ty);"}, {"sha": "9e561fc883bb043366e5c7de7198d9863b5e3323", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -350,7 +350,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        for attr in ty::get_attrs(ccx.tcx(), did).iter() {\n+        for attr in &*ty::get_attrs(ccx.tcx(), did) {\n             if attr.check_name(\"thread_local\") {\n                 llvm::set_thread_local(c, true);\n             }\n@@ -442,7 +442,7 @@ pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: Val\n         InlineNone   => { /* fallthrough */ }\n     }\n \n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         let mut used = true;\n         match attr.name().get() {\n             \"no_stack_check\" => unset_split_stack(llfn),\n@@ -765,7 +765,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                         n_variants);\n                   let next_cx = fcx.new_temp_block(\"enum-iter-next\");\n \n-                  for variant in (*variants).iter() {\n+                  for variant in &(*variants) {\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               &format!(\"enum-iter-variant-{}\",\n@@ -970,7 +970,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if need_invoke(bcx) {\n         debug!(\"invoking {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n-        for &llarg in llargs.iter() {\n+        for &llarg in llargs {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n         let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n@@ -986,7 +986,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return (llresult, normal_bcx);\n     } else {\n         debug!(\"calling {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n-        for &llarg in llargs.iter() {\n+        for &llarg in llargs {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n \n@@ -1830,7 +1830,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n         }\n     };\n-    for monomorphized_arg_type in monomorphized_arg_types.iter() {\n+    for monomorphized_arg_type in &monomorphized_arg_types {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\",\n                ty_to_string(ccx.tcx(), *monomorphized_arg_type));\n     }\n@@ -1908,7 +1908,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // This somewhat improves single-stepping experience in debugger.\n     unsafe {\n         let llreturn = fcx.llreturn.get();\n-        for &llreturn in llreturn.iter() {\n+        if let Some(llreturn) = llreturn {\n             llvm::LLVMMoveBasicBlockAfter(llreturn, bcx.llbb);\n         }\n     }\n@@ -2019,7 +2019,11 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let bcx = match dest {\n         expr::SaveIn(_) => bcx,\n         expr::Ignore => {\n-            glue::drop_ty(bcx, llresult, result_ty, debug_loc)\n+            let bcx = glue::drop_ty(bcx, llresult, result_ty, debug_loc);\n+            if !type_is_zero_size(ccx, result_ty) {\n+                call_lifetime_end(bcx, llresult);\n+            }\n+            bcx\n         }\n     };\n \n@@ -2109,7 +2113,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     let avar = adt::represent_type(ccx, ty);\n     match *avar {\n         adt::General(_, ref variants, _) => {\n-            for var in variants.iter() {\n+            for var in variants {\n                 let mut size = 0;\n                 for field in var.fields.iter().skip(1) {\n                     // skip the discriminant\n@@ -2382,7 +2386,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n // and control visibility.\n pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n-    for item in m.items.iter() {\n+    for item in &m.items {\n         trans_item(ccx, &**item);\n     }\n }\n@@ -3161,7 +3165,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         stats.fn_stats.borrow_mut().sort_by(|&(_, insns_a), &(_, insns_b)| {\n             insns_b.cmp(&insns_a)\n         });\n-        for tuple in stats.fn_stats.borrow().iter() {\n+        for tuple in &*stats.fn_stats.borrow() {\n             match *tuple {\n                 (ref name, insns) => {\n                     println!(\"{} insns, {}\", insns, *name);\n@@ -3170,7 +3174,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         }\n     }\n     if shared_ccx.sess().count_llvm_insns() {\n-        for (k, v) in shared_ccx.stats().llvm_insns.borrow().iter() {\n+        for (k, v) in &*shared_ccx.stats().llvm_insns.borrow() {\n             println!(\"{:7} {}\", *v, *k);\n         }\n     }"}, {"sha": "f11c3154274e7f741bb824532795d2e4803c6080", "filename": "src/librustc_trans/trans/basic_block.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -16,12 +16,7 @@ use std::iter::{Filter, Map};\n #[derive(Copy)]\n pub struct BasicBlock(pub BasicBlockRef);\n \n-pub type Preds = Map<\n-    Value,\n-    BasicBlock,\n-    Filter<Value, Users, fn(&Value) -> bool>,\n-    fn(Value) -> BasicBlock,\n->;\n+pub type Preds = Map<Filter<Users, fn(&Value) -> bool>, fn(Value) -> BasicBlock>;\n \n /// Wrapper for LLVM BasicBlockRef\n impl BasicBlock {"}, {"sha": "5d1e6d2c9e84400a54e52c8ae6ac96351ce0acde", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -150,7 +150,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     let mut arg_tys = Vec::new();\n-    for &aty in atys.iter() {\n+    for &aty in atys {\n         let ty = classify_arg_ty(ccx, aty);\n         arg_tys.push(ty);\n     }"}, {"sha": "50014230df67b2f88a5207f42f9901d4d2f24739", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -186,7 +186,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     };\n \n     let mut arg_tys = Vec::new();\n-    for &aty in atys.iter() {\n+    for &aty in atys {\n         let ty = classify_arg_ty(ccx, aty, align_fn);\n         arg_tys.push(ty);\n     }"}, {"sha": "fecd1a9013bb2c5bb9f7ea8cb1b278ad951bcccb", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -176,7 +176,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     let mut arg_tys = Vec::new();\n     let mut offset = if sret { 4 } else { 0 };\n \n-    for aty in atys.iter() {\n+    for aty in atys {\n         let ty = classify_arg_ty(ccx, *aty, &mut offset);\n         arg_tys.push(ty);\n     };"}, {"sha": "9583158a0e243971d028b6e0edef7b4a223a9409", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -171,7 +171,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     let mut arg_tys = Vec::new();\n     let mut offset = if sret { 4 } else { 0 };\n \n-    for aty in atys.iter() {\n+    for aty in atys {\n         let ty = classify_arg_ty(ccx, *aty, &mut offset);\n         arg_tys.push(ty);\n     };"}, {"sha": "028d20f308474eea3eed27a71d5059a5edf5a86f", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -60,7 +60,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n-    for &t in atys.iter() {\n+    for &t in atys {\n         let ty = match t.kind() {\n             Struct => {\n                 let size = llsize_of_alloc(ccx, t);"}, {"sha": "2484e74e19349a9f2aa30398d255ba1432a09fa3", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -151,7 +151,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     fn all_mem(cls: &mut [RegClass]) {\n-        for elt in cls.iter_mut() {\n+        for elt in cls {\n             *elt = Memory;\n         }\n     }\n@@ -195,7 +195,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                        off: uint,\n                        packed: bool) {\n         let mut field_off = off;\n-        for ty in tys.iter() {\n+        for ty in tys {\n             if !packed {\n                 field_off = align(field_off, *ty);\n             }\n@@ -333,7 +333,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n     fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1;\n-        for c in cls.iter() {\n+        for c in cls {\n             if *c != SSEUp {\n                 break;\n             }\n@@ -413,7 +413,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     }\n \n     let mut arg_tys = Vec::new();\n-    for t in atys.iter() {\n+    for t in atys {\n         let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n     }"}, {"sha": "9b34c3bf26200a7585b52779c3502ca7b5b72c6a", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -38,7 +38,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n-    for &t in atys.iter() {\n+    for &t in atys {\n         let ty = match t.kind() {\n             Struct => {\n                 match llsize_of_alloc(ccx, t) {"}, {"sha": "5f383d54a68ca5d355fb45fc49e90335dd245dfb", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1045,7 +1045,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             }));\n \n             assert_eq!(arg_tys.len(), 1 + rhs.len());\n-            for (rhs, rhs_id) in rhs.into_iter() {\n+            for (rhs, rhs_id) in rhs {\n                 llargs.push(unpack_result!(bcx, {\n                     trans_arg_datum(bcx, arg_tys[1], rhs,\n                                     arg_cleanup_scope,"}, {"sha": "ac76b52598d15c6e8917093c012173ed38c0e3a4", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -72,7 +72,7 @@ impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n             AstScopeKind(nid) => write!(f, \"AstScopeKind({})\", nid),\n             LoopScopeKind(nid, ref blks) => {\n                 try!(write!(f, \"LoopScopeKind({}, [\", nid));\n-                for blk in blks.iter() {\n+                for blk in blks {\n                     try!(write!(f, \"{:p}, \", blk));\n                 }\n                 write!(f, \"])\")"}, {"sha": "b65d50095b3f09c0397ff10757d884a5d978dd42", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -515,7 +515,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                        -> Block<'a, 'tcx> {\n         let out = self.new_id_block(\"join\", id);\n         let mut reachable = false;\n-        for bcx in in_cxs.iter() {\n+        for bcx in in_cxs {\n             if !bcx.unreachable.get() {\n                 build::Br(*bcx, out.llbb, DebugLoc::None);\n                 reachable = true;\n@@ -778,10 +778,6 @@ pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n     C_integral(Type::i32(ccx), i as u64, true)\n }\n \n-pub fn C_i64(ccx: &CrateContext, i: i64) -> ValueRef {\n-    C_integral(Type::i64(ccx), i as u64, true)\n-}\n-\n pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n     C_integral(Type::i64(ccx), i, false)\n }"}, {"sha": "651058a567485e8638d8d84f676631404bf05fea", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -96,7 +96,7 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(), b.id, b.span, true);\n     fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n \n-    for s in b.stmts.iter() {\n+    for s in &b.stmts {\n         bcx = trans_stmt(bcx, &**s);\n     }\n "}, {"sha": "39d17f45ffa084da44e13bbf65aa316aa0a93548", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -199,6 +199,9 @@ impl KindOps for Rvalue {\n                               -> Block<'blk, 'tcx> {\n         // No cleanup is scheduled for an rvalue, so we don't have\n         // to do anything after a move to cancel or duplicate it.\n+        if self.is_by_ref() {\n+            call_lifetime_end(bcx, _val);\n+        }\n         bcx\n     }\n \n@@ -320,6 +323,7 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n                     ByValue => DatumBlock::new(bcx, self),\n                     ByRef => {\n                         let llval = load_ty(bcx, self.val, self.ty);\n+                        call_lifetime_end(bcx, self.val);\n                         DatumBlock::new(bcx, Datum::new(llval, self.ty, Rvalue::new(ByValue)))\n                     }\n                 }"}, {"sha": "66bb299273d9f86aa7aa4861f7468f3eddf783b0", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 64, "deletions": 75, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -197,7 +197,7 @@ use metadata::csearch;\n use middle::subst::{self, Substs};\n use trans::{self, adt, machine, type_of};\n use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n-                    C_bytes, C_i32, C_i64, NormalizingClosureTyper};\n+                    C_bytes, NormalizingClosureTyper};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -375,7 +375,7 @@ impl<'tcx> TypeMap<'tcx> {\n             },\n             ty::ty_tup(ref component_types) => {\n                 unique_type_id.push_str(\"tuple \");\n-                for &component_type in component_types.iter() {\n+                for &component_type in component_types {\n                     let component_type_id =\n                         self.get_unique_type_id_of_type(cx, component_type);\n                     let component_type_id =\n@@ -447,7 +447,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n \n-                for &parameter_type in sig.inputs.iter() {\n+                for &parameter_type in &sig.inputs {\n                     let parameter_type_id =\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n@@ -533,7 +533,7 @@ impl<'tcx> TypeMap<'tcx> {\n             if tps.len() > 0 {\n                 output.push('<');\n \n-                for &type_parameter in tps.iter() {\n+                for &type_parameter in tps {\n                     let param_type_id =\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n@@ -563,7 +563,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n         let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n \n-        for &parameter_type in sig.inputs.iter() {\n+        for &parameter_type in &sig.inputs {\n             let parameter_type_id =\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n@@ -702,7 +702,7 @@ enum VariableAccess<'a> {\n     DirectVariable { alloca: ValueRef },\n     // The llptr given is an alloca containing the start of some pointer chain\n     // leading to the variable's content.\n-    IndirectVariable { alloca: ValueRef, address_operations: &'a [ValueRef] }\n+    IndirectVariable { alloca: ValueRef, address_operations: &'a [i64] }\n }\n \n enum VariableKind {\n@@ -928,10 +928,10 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                               env_index);\n \n     let address_operations = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref(Type::i64(cx).to_ref()),\n-         llvm::LLVMDIBuilderCreateOpPlus(Type::i64(cx).to_ref()),\n-         C_i64(cx, byte_offset_of_var_in_env as i64),\n-         llvm::LLVMDIBuilderCreateOpDeref(Type::i64(cx).to_ref())]\n+        [llvm::LLVMDIBuilderCreateOpDeref(),\n+         llvm::LLVMDIBuilderCreateOpPlus(),\n+         byte_offset_of_var_in_env as i64,\n+         llvm::LLVMDIBuilderCreateOpDeref()]\n     };\n \n     let address_op_count = if captured_by_ref {\n@@ -969,7 +969,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let scope_metadata = scope_metadata(bcx.fcx, binding.id, binding.span);\n     let aops = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref(bcx.ccx().int_type().to_ref())]\n+        [llvm::LLVMDIBuilderCreateOpDeref()]\n     };\n     // Regardless of the actual type (`T`) we're always passed the stack slot (alloca)\n     // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n@@ -1440,7 +1440,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n \n         // Arguments types\n-        for arg in fn_decl.inputs.iter() {\n+        for arg in &fn_decl.inputs {\n             assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n             let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n             let arg_type = monomorphize::apply_param_substs(cx.tcx(),\n@@ -1657,11 +1657,11 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     let name = CString::from_slice(name.get().as_bytes());\n-    let (var_alloca, var_metadata) = match variable_access {\n-        DirectVariable { alloca } => (\n-            alloca,\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(\n+    match (variable_access, [].as_slice()) {\n+        (DirectVariable { alloca }, address_operations) |\n+        (IndirectVariable {alloca, address_operations}, _) => {\n+            let metadata = unsafe {\n+                llvm::LLVMDIBuilderCreateVariable(\n                     DIB(cx),\n                     dwarf_tag,\n                     scope_metadata,\n@@ -1671,38 +1671,25 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     type_metadata,\n                     cx.sess().opts.optimize != config::No,\n                     0,\n-                    argument_index)\n-            }\n-        ),\n-        IndirectVariable { alloca, address_operations } => (\n-            alloca,\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateComplexVariable(\n-                    DIB(cx),\n-                    dwarf_tag,\n-                    scope_metadata,\n-                    name.as_ptr(),\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n                     address_operations.as_ptr(),\n                     address_operations.len() as c_uint,\n                     argument_index)\n-            }\n-        )\n-    };\n-\n-    set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n+            };\n+            set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n                                                       loc.line,\n                                                       loc.col.to_usize()));\n-    unsafe {\n-        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-            DIB(cx),\n-            var_alloca,\n-            var_metadata,\n-            bcx.llbb);\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                    DIB(cx),\n+                    alloca,\n+                    metadata,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    bcx.llbb);\n \n-        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+            }\n+        }\n     }\n \n     match variable_kind {\n@@ -2050,7 +2037,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // The `Ty` values returned by `ty::struct_fields` can still contain\n     // `ty_projection` variants, so normalize those away.\n-    for field in fields.iter_mut() {\n+    for field in &mut fields {\n         field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n     }\n \n@@ -2674,7 +2661,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n \n     unsafe {\n         let type_array = create_DIArray(DIB(cx), &member_metadata[]);\n-        llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n+        llvm::LLVMDICompositeTypeSetTypeArray(DIB(cx), composite_type_metadata, type_array);\n     }\n }\n \n@@ -2838,7 +2825,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     });\n \n     // regular arguments\n-    for &argument_type in signature.inputs.iter() {\n+    for &argument_type in &signature.inputs {\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n \n@@ -3108,12 +3095,14 @@ fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation)\n             // Always set the column to zero like Clang and GCC\n             let col = UNKNOWN_COLUMN_NUMBER;\n             debug!(\"setting debug location to {} {}\", line, col);\n-            let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32),\n-                            scope, ptr::null_mut()];\n+\n             unsafe {\n-                metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n-                                                          elements.as_ptr(),\n-                                                          elements.len() as c_uint);\n+                metadata_node = llvm::LLVMDIBuilderCreateDebugLocation(\n+                    debug_context(cx).llcontext,\n+                    line as c_uint,\n+                    col as c_uint,\n+                    scope,\n+                    ptr::null_mut());\n             }\n         }\n         UnknownLocation => {\n@@ -3226,7 +3215,7 @@ fn create_scope_map(cx: &CrateContext,\n \n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n-    for arg in args.iter() {\n+    for arg in args {\n         pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                ident: Some(path1.node) });\n@@ -3292,7 +3281,7 @@ fn create_scope_map(cx: &CrateContext,\n         scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n \n         // The interesting things here are statements and the concluding expression.\n-        for statement in block.stmts.iter() {\n+        for statement in &block.stmts {\n             scope_map.insert(ast_util::stmt_id(&**statement),\n                              scope_stack.last().unwrap().scope_metadata);\n \n@@ -3306,7 +3295,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n         }\n \n-        for exp in block.expr.iter() {\n+        if let Some(ref exp) = block.expr {\n             walk_expr(cx, &**exp, scope_stack, scope_map);\n         }\n     }\n@@ -3321,7 +3310,7 @@ fn create_scope_map(cx: &CrateContext,\n \n                 walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n \n-                for exp in local.init.iter() {\n+                if let Some(ref exp) = local.init {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n             }\n@@ -3407,7 +3396,7 @@ fn create_scope_map(cx: &CrateContext,\n \n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for sub_pat in sub_pat_opt.iter() {\n+                if let Some(ref sub_pat) = *sub_pat_opt {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n@@ -3419,8 +3408,8 @@ fn create_scope_map(cx: &CrateContext,\n             ast::PatEnum(_, ref sub_pats_opt) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for sub_pats in sub_pats_opt.iter() {\n-                    for p in sub_pats.iter() {\n+                if let Some(ref sub_pats) = *sub_pats_opt {\n+                    for p in sub_pats {\n                         walk_pattern(cx, &**p, scope_stack, scope_map);\n                     }\n                 }\n@@ -3440,7 +3429,7 @@ fn create_scope_map(cx: &CrateContext,\n             ast::PatTup(ref sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for sub_pat in sub_pats.iter() {\n+                for sub_pat in sub_pats {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n@@ -3464,15 +3453,15 @@ fn create_scope_map(cx: &CrateContext,\n             ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for sub_pat in front_sub_pats.iter() {\n+                for sub_pat in front_sub_pats {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n \n-                for sub_pat in middle_sub_pats.iter() {\n+                if let Some(ref sub_pat) = *middle_sub_pats {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n \n-                for sub_pat in back_sub_pats.iter() {\n+                for sub_pat in back_sub_pats {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n@@ -3534,7 +3523,7 @@ fn create_scope_map(cx: &CrateContext,\n \n             ast::ExprVec(ref init_expressions) |\n             ast::ExprTup(ref init_expressions) => {\n-                for ie in init_expressions.iter() {\n+                for ie in init_expressions {\n                     walk_expr(cx, &**ie, scope_stack, scope_map);\n                 }\n             }\n@@ -3612,7 +3601,7 @@ fn create_scope_map(cx: &CrateContext,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    for &ast::Arg { pat: ref pattern, .. } in decl.inputs.iter() {\n+                    for &ast::Arg { pat: ref pattern, .. } in &decl.inputs {\n                         walk_pattern(cx, &**pattern, scope_stack, scope_map);\n                     }\n \n@@ -3623,13 +3612,13 @@ fn create_scope_map(cx: &CrateContext,\n             ast::ExprCall(ref fn_exp, ref args) => {\n                 walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n \n-                for arg_exp in args.iter() {\n+                for arg_exp in args {\n                     walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                for arg_exp in args.iter() {\n+                for arg_exp in args {\n                     walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n                 }\n             }\n@@ -3642,19 +3631,19 @@ fn create_scope_map(cx: &CrateContext,\n                 // walk only one pattern per arm, as they all must contain the\n                 // same binding names.\n \n-                for arm_ref in arms.iter() {\n+                for arm_ref in arms {\n                     let arm_span = arm_ref.pats[0].span;\n \n                     with_new_scope(cx,\n                                    arm_span,\n                                    scope_stack,\n                                    scope_map,\n                                    |cx, scope_stack, scope_map| {\n-                        for pat in arm_ref.pats.iter() {\n+                        for pat in &arm_ref.pats {\n                             walk_pattern(cx, &**pat, scope_stack, scope_map);\n                         }\n \n-                        for guard_exp in arm_ref.guard.iter() {\n+                        if let Some(ref guard_exp) = arm_ref.guard {\n                             walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n                         }\n \n@@ -3664,7 +3653,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprStruct(_, ref fields, ref base_exp) => {\n-                for &ast::Field { expr: ref exp, .. } in fields.iter() {\n+                for &ast::Field { expr: ref exp, .. } in fields {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n \n@@ -3678,11 +3667,11 @@ fn create_scope_map(cx: &CrateContext,\n                                                 ref outputs,\n                                                 .. }) => {\n                 // inputs, outputs: Vec<(String, P<Expr>)>\n-                for &(_, ref exp) in inputs.iter() {\n+                for &(_, ref exp) in inputs {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n \n-                for &(_, ref exp, _) in outputs.iter() {\n+                for &(_, ref exp, _) in outputs {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n             }\n@@ -3737,7 +3726,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         ty::ty_tup(ref component_types) => {\n             output.push('(');\n-            for &component_type in component_types.iter() {\n+            for &component_type in component_types {\n                 push_debuginfo_type_name(cx, component_type, true, output);\n                 output.push_str(\", \");\n             }\n@@ -3802,7 +3791,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n             if sig.inputs.len() > 0 {\n-                for &parameter_type in sig.inputs.iter() {\n+                for &parameter_type in &sig.inputs {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n@@ -3848,7 +3837,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       def_id: ast::DefId,\n                       qualified: bool,\n                       output: &mut String) {\n-        ty::with_path(cx.tcx(), def_id, |mut path| {\n+        ty::with_path(cx.tcx(), def_id, |path| {\n             if qualified {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     output.push_str(crate_root_namespace(cx));"}, {"sha": "bed43a5c838823e36f062f1faeab10063ab48344", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1451,7 +1451,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n     // First we trans the base, if we have one, to the dest\n-    for base in optbase.iter() {\n+    if let Some(base) = optbase {\n         assert_eq!(discr, 0);\n \n         match ty::expr_kind(bcx.tcx(), &*base.expr) {\n@@ -1461,7 +1461,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\"),\n             _ => {\n                 let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n-                for &(i, t) in base.fields.iter() {\n+                for &(i, t) in &base.fields {\n                     let datum = base_datum.get_element(\n                             bcx, t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n                     assert!(type_is_sized(bcx.tcx(), datum.ty));\n@@ -1485,7 +1485,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // (i.e. avoid GEPi and `store`s to an alloca) .\n         let mut vec_val = C_undef(llty);\n \n-        for &(i, ref e) in fields.iter() {\n+        for &(i, ref e) in fields {\n             let block_datum = trans(bcx, &**e);\n             bcx = block_datum.bcx;\n             let position = C_uint(bcx.ccx(), i);\n@@ -1495,7 +1495,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Store(bcx, vec_val, addr);\n     } else {\n         // Now, we just overwrite the fields we've explicitly specified\n-        for &(i, ref e) in fields.iter() {\n+        for &(i, ref e) in fields {\n             let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n             let e_ty = expr_ty_adjusted(bcx, &**e);\n             bcx = trans_into(bcx, &**e, SaveIn(dest));"}, {"sha": "00bb3036546763787988d23ea4e5559e939d4bf0", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -352,7 +352,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     arg_idx += 1;\n-    for arg_ty in fn_type.arg_tys.iter() {\n+    for arg_ty in &fn_type.arg_tys {\n         if arg_ty.is_ignore() {\n             continue;\n         }\n@@ -453,7 +453,7 @@ fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n \n pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n-    for foreign_item in foreign_mod.items.iter() {\n+    for foreign_item in &foreign_mod.items {\n         let lname = link_name(&**foreign_item);\n \n         if let ast::ForeignItemFn(ref decl, _) = foreign_item.node {\n@@ -936,7 +936,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n         }\n     };\n \n-    for &arg_ty in tys.fn_ty.arg_tys.iter() {\n+    for &arg_ty in &tys.fn_ty.arg_tys {\n         if arg_ty.is_ignore() {\n             continue;\n         }\n@@ -987,7 +987,7 @@ fn add_argument_attributes(tys: &ForeignTypes,\n \n     i += 1;\n \n-    for &arg_ty in tys.fn_ty.arg_tys.iter() {\n+    for &arg_ty in &tys.fn_ty.arg_tys {\n         if arg_ty.is_ignore() {\n             continue;\n         }"}, {"sha": "5d26daab5cd8739f19f9d6d6a1e285ddb015fdfd", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -572,7 +572,7 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs().set(true);\n     let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n-    for (_, ti) in ccx.tydescs().borrow().iter() {\n+    for (_, ti) in &*ccx.tydescs().borrow() {\n         // Each of the glue functions needs to be cast to a generic type\n         // before being put into the tydesc because we only have a singleton\n         // tydesc type. Then we'll recast each function to its real type when"}, {"sha": "6228043eeb1a9b307bf50dfa4e57f33ed0189e28", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -92,7 +92,7 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Opti\n /// the only intrinsic that needs such verification is `transmute`.\n pub fn check_intrinsics(ccx: &CrateContext) {\n     let mut last_failing_id = None;\n-    for transmute_restriction in ccx.tcx().transmute_restrictions.borrow().iter() {\n+    for transmute_restriction in &*ccx.tcx().transmute_restrictions.borrow() {\n         // Sometimes, a single call to transmute will push multiple\n         // type pairs to test in order to exhaustively test the\n         // possibility around a type parameter. If one of those fails,\n@@ -243,7 +243,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     dest\n                 };\n \n-                fcx.pop_custom_cleanup_scope(cleanup_scope);\n+                fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n+                fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n \n                 return match dest {\n                     expr::SaveIn(d) => Result::new(bcx, d),\n@@ -268,17 +269,19 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              false,\n                              RustIntrinsic);\n \n-    fcx.pop_custom_cleanup_scope(cleanup_scope);\n+    fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n     let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n \n     // These are the only intrinsic functions that diverge.\n     if name.get() == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n         Call(bcx, llfn, &[], None, call_debug_location);\n+        fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n     } else if name.get() == \"unreachable\" {\n+        fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_nil(ccx));\n     }\n@@ -765,6 +768,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         expr::SaveIn(_) => {}\n     }\n \n+    fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n+\n     Result::new(bcx, llresult)\n }\n "}, {"sha": "f522024c2e7e910ec782cb5ad4fbd0233fbb0adb", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -65,7 +65,7 @@ pub fn trans_impl(ccx: &CrateContext,\n     // items that we need to translate.\n     if !generics.ty_params.is_empty() {\n         let mut v = TransItemVisitor{ ccx: ccx };\n-        for impl_item in impl_items.iter() {\n+        for impl_item in impl_items {\n             match *impl_item {\n                 ast::MethodImplItem(ref method) => {\n                     visit::walk_method_helper(&mut v, &**method);\n@@ -75,7 +75,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         }\n         return;\n     }\n-    for impl_item in impl_items.iter() {\n+    for impl_item in impl_items {\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0 {"}, {"sha": "b3d388b0f0236b3e8f257db91d197b44fceba0bd", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -333,7 +333,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n            obligations.repr(tcx));\n \n     let mut fulfill_cx = traits::FulfillmentContext::new();\n-    for obligation in obligations.into_iter() {\n+    for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n     let result = drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &result);"}, {"sha": "66f603cbe07f2aea9c9d7bad2617e69f5da54e4e", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -263,7 +263,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprVec(ref elements) => {\n             match dest {\n                 Ignore => {\n-                    for element in elements.iter() {\n+                    for element in elements {\n                         bcx = expr::trans_into(bcx, &**element, Ignore);\n                     }\n                 }"}, {"sha": "2243982c20d61fcea680e035475493a91c4779a7", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -84,7 +84,7 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match inputs[inputs.len() - 1].sty {\n         ty::ty_tup(ref tupled_arguments) => {\n             debug!(\"untuple_arguments_if_necessary(): untupling arguments\");\n-            for &tupled_argument in tupled_arguments.iter() {\n+            for &tupled_argument in tupled_arguments {\n                 result.push(tupled_argument);\n             }\n         }"}, {"sha": "8809931cd80c23b23f81096be36772dd5b33d520", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -373,7 +373,7 @@ fn create_substs_for_ast_path<'tcx>(\n         }\n     }\n \n-    for param in ty_param_defs[supplied_ty_param_count..].iter() {\n+    for param in &ty_param_defs[supplied_ty_param_count..] {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter.\n@@ -537,7 +537,7 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n         instantiate_trait_ref(this, &shifted_rscope, &ast_trait_ref.trait_ref,\n                               self_ty, Some(&mut projections));\n \n-    for projection in projections.into_iter() {\n+    for projection in projections {\n         poly_projections.push(ty::Binder(projection));\n     }\n \n@@ -659,7 +659,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             prohibit_projections(this.tcx(), assoc_bindings.as_slice());\n         }\n         Some(ref mut v) => {\n-            for binding in assoc_bindings.iter() {\n+            for binding in &assoc_bindings {\n                 match ast_type_binding_to_projection_predicate(this, trait_ref.clone(),\n                                                                self_ty, binding) {\n                     Ok(pp) => { v.push(pp); }\n@@ -733,7 +733,7 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     // If converting for an object type, then remove the dummy-ty from `Self` now.\n     // Yuckety yuck.\n     if self_ty.is_none() {\n-        for candidate in candidates.iter_mut() {\n+        for candidate in &mut candidates {\n             let mut dummy_substs = candidate.0.substs.clone();\n             assert!(dummy_substs.self_ty() == Some(dummy_self_ty));\n             dummy_substs.types.pop(SelfSpace);\n@@ -979,7 +979,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                   token::get_name(assoc_name),\n                                   token::get_name(ty_param_name));\n \n-        for suitable_bound in suitable_bounds.iter() {\n+        for suitable_bound in &suitable_bounds {\n             span_note!(this.tcx().sess, ast_ty.span,\n                        \"associated type `{}` could derive from `{}`\",\n                        token::get_name(ty_param_name),\n@@ -1710,7 +1710,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n     let mut trait_def_ids = DefIdMap();\n-    for ast_bound in ast_bounds.iter() {\n+    for ast_bound in ast_bounds {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n                 match ::lookup_def_tcx(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {"}, {"sha": "174a902953476da2db8519a7cca58188dbb3bb2e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -240,7 +240,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // below for details.\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n-            for elt in before.iter() {\n+            for elt in before {\n                 check_pat(pcx, &**elt, inner_ty);\n             }\n             if let Some(ref slice) = *slice {\n@@ -254,7 +254,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 });\n                 check_pat(pcx, &**slice, slice_ty);\n             }\n-            for elt in after.iter() {\n+            for elt in after {\n                 check_pat(pcx, &**elt, inner_ty);\n             }\n         }\n@@ -348,12 +348,12 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n-    for arm in arms.iter() {\n+    for arm in arms {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(&tcx.def_map, &*arm.pats[0]),\n         };\n-        for p in arm.pats.iter() {\n+        for p in &arm.pats {\n             check_pat(&mut pcx, &**p, discrim_ty);\n         }\n     }\n@@ -439,7 +439,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n                 \"use of trait `{}` in a struct pattern\", name);\n             fcx.write_error(pat.id);\n \n-            for field in fields.iter() {\n+            for field in fields {\n                 check_pat(pcx, &*field.node.pat, tcx.types.err);\n             }\n             return;\n@@ -458,7 +458,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n                         \"`{}` does not name a struct or a struct variant\", name);\n                     fcx.write_error(pat.id);\n \n-                    for field in fields.iter() {\n+                    for field in fields {\n                         check_pat(pcx, &*field.node.pat, tcx.types.err);\n                     }\n                     return;\n@@ -540,7 +540,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             fcx.write_error(pat.id);\n \n             if let Some(subpats) = subpats {\n-                for pat in subpats.iter() {\n+                for pat in subpats {\n                     check_pat(pcx, &**pat, tcx.types.err);\n                 }\n             }\n@@ -558,7 +558,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                       \"this pattern has {} field{}, but the corresponding {} has no fields\",\n                       subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n \n-            for pat in subpats.iter() {\n+            for pat in subpats {\n                 check_pat(pcx, &**pat, tcx.types.err);\n             }\n         } else {\n@@ -568,7 +568,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                       kind_name,\n                       arg_tys.len(), if arg_tys.len() == 1 {\"\"} else {\"s\"});\n \n-            for pat in subpats.iter() {\n+            for pat in subpats {\n                 check_pat(pcx, &**pat, tcx.types.err);\n             }\n         }\n@@ -598,7 +598,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let mut used_fields = FnvHashMap();\n \n     // Typecheck each field.\n-    for &Spanned { node: ref field, span } in fields.iter() {\n+    for &Spanned { node: ref field, span } in fields {\n         let field_type = match used_fields.entry(field.ident.name) {\n             Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,"}, {"sha": "377af080526b7084a961c372de6535587d5cb511", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -33,7 +33,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     debug!(\"normalize_associated_types_in: result={} predicates={}\",\n            result.repr(infcx.tcx),\n            obligations.repr(infcx.tcx));\n-    for obligation in obligations.into_iter() {\n+    for obligation in obligations {\n         fulfillment_cx.register_predicate_obligation(infcx, obligation);\n     }\n     result"}, {"sha": "04a3f423dce11015ed08cf935ee13edf6c4784f1", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -353,7 +353,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     assert!(ty_substs_a.len() == ty_substs_b.len());\n \n                     let mut result = None;\n-                    let mut tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n+                    let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n                     for (i, (tp_a, tp_b)) in tps {\n                         if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n                             continue;"}, {"sha": "dc4d7d466472800a9ddb633e0207c32e5be7c9e4", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -248,7 +248,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n \n-    for predicate in impl_pred.fns.into_iter() {\n+    for predicate in impl_pred.fns {\n         let traits::Normalized { value: predicate, .. } =\n             traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n "}, {"sha": "a988fb4cc6e19015e0b58ec43b737db33bbd6742", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -134,7 +134,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Create a list of simplified self types, if we can.\n     let mut simplified_steps = Vec::new();\n-    for step in steps.iter() {\n+    for step in &steps {\n         match fast_reject::simplify_type(fcx.tcx(), step.self_ty, true) {\n             None => { break; }\n             Some(simplified_type) => { simplified_steps.push(simplified_type); }\n@@ -236,7 +236,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_inherent_candidates(&mut self) {\n         let steps = self.steps.clone();\n-        for step in steps.iter() {\n+        for step in &*steps {\n             self.assemble_probe(step.self_ty);\n         }\n     }\n@@ -268,8 +268,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), def_id);\n \n-        for impl_infos in self.tcx().inherent_impls.borrow().get(&def_id).iter() {\n-            for &impl_def_id in impl_infos.iter() {\n+        if let Some(impl_infos) = self.tcx().inherent_impls.borrow().get(&def_id) {\n+            for &impl_def_id in &***impl_infos {\n                 self.assemble_inherent_impl_probe(impl_def_id);\n             }\n         }\n@@ -448,8 +448,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     {\n         let mut duplicates = HashSet::new();\n         let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n-        for applicable_traits in opt_applicable_traits.into_iter() {\n-            for &trait_did in applicable_traits.iter() {\n+        if let Some(applicable_traits) = opt_applicable_traits {\n+            for &trait_did in applicable_traits {\n                 if duplicates.insert(trait_did) {\n                     try!(self.assemble_extension_candidates_for_trait(trait_did));\n                 }\n@@ -530,7 +530,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             Some(impls) => impls,\n         };\n \n-        for &impl_def_id in impl_def_ids.borrow().iter() {\n+        for &impl_def_id in &*impl_def_ids.borrow() {\n             debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={} impl_def_id={}\",\n                    trait_def_id.repr(self.tcx()),\n                    impl_def_id.repr(self.tcx()));\n@@ -601,7 +601,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // Check if there is an unboxed-closure self-type in the list of receivers.\n         // If so, add \"synthetic impls\".\n         let steps = self.steps.clone();\n-        for step in steps.iter() {\n+        for step in &*steps {\n             let (closure_def_id, _, _) = match step.self_ty.sty {\n                 ty::ty_closure(a, b, ref c) => (a, b, c),\n                 _ => continue,\n@@ -653,7 +653,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                method.repr(self.tcx()),\n                method_index);\n \n-        for step in self.steps.iter() {\n+        for step in &*self.steps {\n             debug!(\"assemble_projection_candidates: step={}\",\n                    step.repr(self.tcx()));\n "}, {"sha": "70e5d44ca672541b6aa87478390d0a964a21b6f8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -735,7 +735,7 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n               None => { }\n           }\n \n-        for impl_item in impl_items.iter() {\n+        for impl_item in impl_items {\n             match *impl_item {\n                 ast::MethodImplItem(ref m) => {\n                     check_method_body(ccx, &impl_pty.generics, &**m);\n@@ -750,7 +750,7 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemTrait(_, ref generics, _, ref trait_methods) => {\n         check_trait_on_unimplemented(ccx, generics, it);\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n-        for trait_method in trait_methods.iter() {\n+        for trait_method in trait_methods {\n             match *trait_method {\n                 RequiredMethod(..) => {\n                     // Nothing to do, since required methods don't have\n@@ -774,11 +774,11 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       }\n       ast::ItemForeignMod(ref m) => {\n         if m.abi == abi::RustIntrinsic {\n-            for item in m.items.iter() {\n+            for item in &m.items {\n                 check_intrinsic_type(ccx, &**item);\n             }\n         } else {\n-            for item in m.items.iter() {\n+            for item in &m.items {\n                 let pty = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n                 if !pty.generics.types.is_empty() {\n                     span_err!(ccx.tcx.sess, item.span, E0044,\n@@ -805,7 +805,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n         if let Some(ref istring) = attr.value_str() {\n-            let mut parser = Parser::new(istring.get());\n+            let parser = Parser::new(istring.get());\n             let types = generics.ty_params.as_slice();\n             for token in parser {\n                 match token {\n@@ -879,7 +879,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n-    for impl_item in impl_items.iter() {\n+    for impl_item in impl_items {\n         match *impl_item {\n             ast::MethodImplItem(ref impl_method) => {\n                 let impl_method_def_id = local_def(impl_method.id);\n@@ -969,7 +969,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check for missing items from trait\n     let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n     let mut missing_methods = Vec::new();\n-    for trait_item in trait_items.iter() {\n+    for trait_item in &*trait_items {\n         match *trait_item {\n             ty::MethodTraitItem(ref trait_method) => {\n                 let is_implemented =\n@@ -1341,7 +1341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n     pub fn default_type_parameters(&self) {\n         use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n-        for (_, &mut ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n+        for (_, &mut ref ty) in &mut *self.inh.node_types.borrow_mut() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n@@ -2321,7 +2321,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // of arguments when we typecheck the functions. This isn't really the\n     // right way to do this.\n     let xs = [false, true];\n-    for check_blocks in xs.iter() {\n+    for check_blocks in &xs {\n         let check_blocks = *check_blocks;\n         debug!(\"check_blocks={}\", check_blocks);\n \n@@ -2858,11 +2858,19 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             BinopAssignment => PreferMutLvalue,\n             SimpleBinop => NoPreference\n         };\n-        check_expr_with_lvalue_pref(fcx, &*lhs, lvalue_pref);\n+        check_expr_with_lvalue_pref(fcx, lhs, lvalue_pref);\n \n         // Callee does bot / err checking\n-        let lhs_t = structurally_resolved_type(fcx, lhs.span,\n-                                               fcx.expr_ty(&*lhs));\n+        let lhs_t =\n+            structurally_resolve_type_or_else(fcx, lhs.span, fcx.expr_ty(lhs), || {\n+                if ast_util::is_symmetric_binop(op.node) {\n+                    // Try RHS first\n+                    check_expr(fcx, &**rhs);\n+                    fcx.expr_ty(&**rhs)\n+                } else {\n+                    fcx.tcx().types.err\n+                }\n+            });\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op.node) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n@@ -3101,7 +3109,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let mut best_dist = name.len();\n         let fields = ty::lookup_struct_fields(tcx, id);\n         let mut best = None;\n-        for elem in fields.iter() {\n+        for elem in &fields {\n             let n = elem.name.as_str();\n             // ignore already set fields\n             if skip.iter().any(|&x| x == n) {\n@@ -3199,14 +3207,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let mut class_field_map = FnvHashMap();\n         let mut fields_found = 0;\n-        for field in field_types.iter() {\n+        for field in field_types {\n             class_field_map.insert(field.name, (field.id, false));\n         }\n \n         let mut error_happened = false;\n \n         // Typecheck each field.\n-        for field in ast_fields.iter() {\n+        for field in ast_fields {\n             let mut expected_field_type = tcx.types.err;\n \n             let pair = class_field_map.get(&field.ident.node.name).map(|x| *x);\n@@ -3273,7 +3281,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             assert!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n                 let mut missing_fields = Vec::new();\n-                for class_field in field_types.iter() {\n+                for class_field in field_types {\n                     let name = class_field.name;\n                     let (_, seen) = class_field_map[name];\n                     if !seen {\n@@ -3374,7 +3382,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // Make sure to still write the types\n         // otherwise we might ICE\n         fcx.write_error(id);\n-        for field in fields.iter() {\n+        for field in fields {\n             check_expr(fcx, &*field.expr);\n         }\n         match *base_expr {\n@@ -3628,10 +3636,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           constrain_path_type_parameters(fcx, expr);\n       }\n       ast::ExprInlineAsm(ref ia) => {\n-          for &(_, ref input) in ia.inputs.iter() {\n+          for &(_, ref input) in &ia.inputs {\n               check_expr(fcx, &**input);\n           }\n-          for &(_, ref out, _) in ia.outputs.iter() {\n+          for &(_, ref out, _) in &ia.outputs {\n               check_expr(fcx, &**out);\n           }\n           fcx.write_nil(id);\n@@ -3764,14 +3772,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let typ = match uty {\n             Some(uty) => {\n-                for e in args.iter() {\n+                for e in args {\n                     check_expr_coercable_to_type(fcx, &**e, uty);\n                 }\n                 uty\n             }\n             None => {\n                 let t: Ty = fcx.infcx().next_ty_var();\n-                for e in args.iter() {\n+                for e in args {\n                     check_expr_has_type(fcx, &**e, t);\n                 }\n                 t\n@@ -4270,7 +4278,7 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let mut warned = false;\n     let mut any_diverges = false;\n     let mut any_err = false;\n-    for s in blk.stmts.iter() {\n+    for s in &blk.stmts {\n         check_stmt(fcx, &**s);\n         let s_id = ast_util::stmt_id(&**s);\n         let s_ty = fcx.node_ty(s_id);\n@@ -4506,7 +4514,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n         let mut prev_disr_val: Option<ty::Disr> = None;\n \n-        for v in vs.iter() {\n+        for v in vs {\n \n             // If the discriminant value is specified explicitly in the enum check whether the\n             // initialization expression is valid, otherwise use the last value plus one.\n@@ -4838,7 +4846,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // variables. If the user provided some types, we may still need\n     // to add defaults. If the user provided *too many* types, that's\n     // a problem.\n-    for &space in ParamSpace::all().iter() {\n+    for &space in &ParamSpace::all() {\n         adjust_type_parameters(fcx, span, space, type_defs, &mut substs);\n         assert_eq!(substs.types.len(space), type_defs.len(space));\n \n@@ -4870,13 +4878,13 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx: &FnCtxt,\n         segment: &ast::PathSegment)\n     {\n-        for typ in segment.parameters.types().iter() {\n+        for typ in &segment.parameters.types() {\n             span_err!(fcx.tcx().sess, typ.span, E0085,\n                 \"type parameters may not appear here\");\n             break;\n         }\n \n-        for lifetime in segment.parameters.lifetimes().iter() {\n+        for lifetime in &segment.parameters.lifetimes() {\n             span_err!(fcx.tcx().sess, lifetime.span, E0086,\n                 \"lifetime parameters may not appear here\");\n             break;\n@@ -5114,28 +5122,45 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-// Resolves `typ` by a single level if `typ` is a type variable.  If no\n-// resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                            sp: Span,\n-                                            ty: Ty<'tcx>)\n-                                            -> Ty<'tcx>\n+fn structurally_resolve_type_or_else<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                  sp: Span,\n+                                                  ty: Ty<'tcx>,\n+                                                  f: F) -> Ty<'tcx>\n+    where F: Fn() -> Ty<'tcx>\n {\n     let mut ty = fcx.resolve_type_vars_if_possible(ty);\n \n-    // If not, error.\n     if ty::type_is_ty_var(ty) {\n-        fcx.type_error_message(sp, |_actual| {\n-            \"the type of this value must be known in this \\\n-             context\".to_string()\n-        }, ty, None);\n-        demand::suptype(fcx, sp, fcx.tcx().types.err, ty);\n-        ty = fcx.tcx().types.err;\n+        let alternative = f();\n+\n+        // If not, error.\n+        if ty::type_is_ty_var(alternative) || ty::type_is_error(alternative) {\n+            fcx.type_error_message(sp, |_actual| {\n+                \"the type of this value must be known in this context\".to_string()\n+            }, ty, None);\n+            demand::suptype(fcx, sp, fcx.tcx().types.err, ty);\n+            ty = fcx.tcx().types.err;\n+        } else {\n+            demand::suptype(fcx, sp, alternative, ty);\n+            ty = alternative;\n+        }\n     }\n \n     ty\n }\n \n+// Resolves `typ` by a single level if `typ` is a type variable.  If no\n+// resolution is possible, then an error is reported.\n+pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                            sp: Span,\n+                                            ty: Ty<'tcx>)\n+                                            -> Ty<'tcx>\n+{\n+    structurally_resolve_type_or_else(fcx, sp, ty, || {\n+        fcx.tcx().types.err\n+    })\n+}\n+\n // Returns true if b contains a break that can exit from b\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately"}, {"sha": "94414d842c9dfd0daee79c3cfd8dfcb2a46d681d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -148,7 +148,7 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   span: Span,\n                                                   component_tys: &[Ty<'tcx>]) {\n     let mut rcx = Rcx::new(fcx, Repeating(0), SubjectNode::None);\n-    for &component_ty in component_tys.iter() {\n+    for &component_ty in component_tys {\n         // Check that each type outlives the empty region. Since the\n         // empty region is a subregion of all others, this can't fail\n         // unless the type does not meet the well-formedness\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                                        .region_obligations(node_id)\n                                        .to_vec();\n \n-        for r_o in region_obligations.iter() {\n+        for r_o in &region_obligations {\n             debug!(\"visit_region_obligations: r_o={}\",\n                    r_o.repr(self.tcx()));\n             let sup_type = self.resolve_type(r_o.sup_type);\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         debug!(\"relate_free_regions >>\");\n         let tcx = self.tcx();\n \n-        for &ty in fn_sig_tys.iter() {\n+        for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={})\", ty.repr(tcx));\n             let body_scope = CodeExtent::from_node_id(body_id);\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                     tcx,\n                     ty,\n                     body_scope);\n-            for constraint in constraints.iter() {\n+            for constraint in &constraints {\n                 debug!(\"constraint: {}\", constraint.repr(tcx));\n                 match *constraint {\n                     regionmanip::RegionSubRegionConstraint(_,\n@@ -424,7 +424,7 @@ fn visit_block(rcx: &mut Rcx, b: &ast::Block) {\n \n fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n     // see above\n-    for p in arm.pats.iter() {\n+    for p in &arm.pats {\n         constrain_bindings_in_pat(&**p, rcx);\n     }\n \n@@ -487,13 +487,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n-    for &adjustment in rcx.fcx.inh.adjustments.borrow().get(&expr.id).iter() {\n+    if let Some(adjustment) = rcx.fcx.inh.adjustments.borrow().get(&expr.id) {\n         debug!(\"adjustment={:?}\", adjustment);\n         match *adjustment {\n             ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n-                for autoref in opt_autoref.iter() {\n+                if let Some(ref autoref) = *opt_autoref {\n                     link_autoref(rcx, expr, autoderefs, autoref);\n \n                     // Require that the resulting region encompasses\n@@ -753,7 +753,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         debug!(\"ensure_free_variable_types_outlive_closure_bound({}, {})\",\n                bounds.region_bound.repr(tcx), expr.repr(tcx));\n \n-        for freevar in freevars.iter() {\n+        for freevar in freevars {\n             let var_node_id = {\n                 let def_id = freevar.def.def_id();\n                 assert!(def_id.krate == ast::LOCAL_CRATE);\n@@ -779,7 +779,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             };\n \n             // Check that the type meets the criteria of the existential bounds:\n-            for builtin_bound in bounds.builtin_bounds.iter() {\n+            for builtin_bound in &bounds.builtin_bounds {\n                 let code = traits::ClosureCapture(var_node_id, expr.span, builtin_bound);\n                 let cause = traits::ObligationCause::new(freevar.span, rcx.fcx.body_id, code);\n                 rcx.fcx.register_builtin_bound(var_ty, builtin_bound, cause);\n@@ -802,7 +802,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"constrain_captured_variables({}, {})\",\n                region_bound.repr(tcx), expr.repr(tcx));\n-        for freevar in freevars.iter() {\n+        for freevar in freevars {\n             debug!(\"constrain_captured_variables: freevar.def={:?}\", freevar.def);\n \n             // Identify the variable being closed over and its node-id.\n@@ -854,7 +854,7 @@ fn constrain_callee(rcx: &mut Rcx,\n fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n                                                        call_expr: &ast::Expr,\n                                                        receiver: Option<&ast::Expr>,\n-                                                       mut arg_exprs: I,\n+                                                       arg_exprs: I,\n                                                        implicitly_ref_args: bool) {\n     //! Invoked on every call site (i.e., normal calls, method calls,\n     //! and overloaded operators). Constrains the regions which appear\n@@ -897,13 +897,13 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     }\n \n     // as loop above, but for receiver\n-    for r in receiver.iter() {\n+    if let Some(r) = receiver {\n         debug!(\"receiver: {}\", r.repr(tcx));\n         type_of_node_must_outlive(\n             rcx, infer::CallRcvr(r.span),\n             r.id, callee_region);\n         if implicitly_ref_args {\n-            link_by_ref(rcx, &**r, callee_scope);\n+            link_by_ref(rcx, &*r, callee_scope);\n         }\n     }\n }\n@@ -1079,8 +1079,8 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n-    for arm in arms.iter() {\n-        for root_pat in arm.pats.iter() {\n+    for arm in arms {\n+        for root_pat in &arm.pats {\n             link_pattern(rcx, mc, discr_cmt.clone(), &**root_pat);\n         }\n     }\n@@ -1092,7 +1092,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n     debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    for arg in args.iter() {\n+    for arg in args {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n         let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n@@ -1418,7 +1418,7 @@ fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n             rcx.tcx(),\n             ty,\n             region);\n-    for constraint in constraints.iter() {\n+    for constraint in &constraints {\n         debug!(\"constraint: {}\", constraint.repr(rcx.tcx()));\n         match *constraint {\n             regionmanip::RegionSubRegionConstraint(None, r_a, r_b) => {\n@@ -1479,7 +1479,7 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // The problem is that the type of `x` is `&'a A`. To be\n     // well-formed, then, A must be lower-generic by `'a`, but we\n     // don't know that this holds from first principles.\n-    for &(ref r, ref p) in rcx.region_bound_pairs.iter() {\n+    for &(ref r, ref p) in &rcx.region_bound_pairs {\n         debug!(\"generic={} p={}\",\n                generic.repr(rcx.tcx()),\n                p.repr(rcx.tcx()));"}, {"sha": "4a0e2acc854441a0cd2da7b950441b350e4417ea", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             }\n \n             ty::ty_tup(ref tuptys) => {\n-                for &tupty in tuptys.iter() {\n+                for &tupty in tuptys {\n                     self.accumulate_from_ty(tupty);\n                 }\n             }\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         // Variance of each type/region parameter.\n         let variances = ty::item_variances(self.tcx, def_id);\n \n-        for &space in ParamSpace::all().iter() {\n+        for &space in &ParamSpace::all() {\n             let region_params = substs.regions().get_slice(space);\n             let region_variances = variances.regions.get_slice(space);\n             let region_param_defs = generics.regions.get_slice(space);\n@@ -272,7 +272,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                     }\n                 }\n \n-                for &region_bound in region_param_def.bounds.iter() {\n+                for &region_bound in &region_param_def.bounds {\n                     // The type declared a constraint like\n                     //\n                     //     'b : 'a\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n                 // Inspect bounds on this type parameter for any\n                 // region bounds.\n-                for &r in type_param_def.bounds.region_bounds.iter() {\n+                for &r in &type_param_def.bounds.region_bounds {\n                     self.stack.push((r, Some(ty)));\n                     self.accumulate_from_ty(type_param_ty);\n                     self.stack.pop().unwrap();\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         // And then, in turn, to be well-formed, the\n         // `region_bound` that user specified must imply the\n         // region bounds required from all of the trait types:\n-        for &r_d in required_region_bounds.iter() {\n+        for &r_d in &required_region_bounds {\n             // Each of these is an instance of the `'c <= 'b`\n             // constraint above\n             self.out.push(RegionSubRegionConstraint(Some(ty), r_d, r_c));"}, {"sha": "b52e01f9a7a7684dd39b362ccac0d3c91aaeb7b6", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -138,7 +138,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n         }\n \n         ty::with_freevars(self.tcx(), expr.id, |freevars| {\n-            for freevar in freevars.iter() {\n+            for freevar in freevars {\n                 let var_node_id = freevar.def.local_node_id();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                              closure_expr_id: expr.id };"}, {"sha": "6f66010925ec0b5411d059312947ce6bdb08c573", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -142,7 +142,7 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ty::item_path_str(tcx, object_trait_ref.def_id()));\n \n     let violations = traits::object_safety_violations(tcx, object_trait_ref.clone());\n-    for violation in violations.into_iter() {\n+    for violation in violations {\n         match violation {\n             ObjectSafetyViolation::SizedSelf => {\n                 tcx.sess.span_note(\n@@ -221,7 +221,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // bounds attached to the object cast. (In other words, if the\n     // object type is Foo+Send, this would create an obligation\n     // for the Send check.)\n-    for builtin_bound in object_trait.bounds.builtin_bounds.iter() {\n+    for builtin_bound in &object_trait.bounds.builtin_bounds {\n         fcx.register_builtin_bound(\n             referent_ty,\n             builtin_bound,\n@@ -231,7 +231,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Create obligations for the projection predicates.\n     let projection_bounds =\n         object_trait.projection_bounds_with_self_ty(fcx.tcx(), referent_ty);\n-    for projection_bound in projection_bounds.iter() {\n+    for projection_bound in &projection_bounds {\n         let projection_obligation =\n             Obligation::new(cause.clone(), projection_bound.as_predicate());\n         fcx.register_predicate(projection_obligation);\n@@ -263,13 +263,13 @@ fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n         })\n         .collect();\n \n-    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n+    for projection_bound in &object_trait.bounds.projection_bounds {\n         let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n                     projection_bound.0.projection_ty.item_name);\n         associated_types.remove(&pair);\n     }\n \n-    for (trait_def_id, name) in associated_types.into_iter() {\n+    for (trait_def_id, name) in associated_types {\n         span_err!(tcx.sess, span, E0191,\n             \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                     name.user_string(tcx),"}, {"sha": "71b495af444dd240f313e5a53f59ecedd489355c", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -147,15 +147,15 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         item.span,\n                                                         region::CodeExtent::from_node_id(item.id),\n                                                         Some(&mut this.cache));\n-            for variant in variants.iter() {\n-                for field in variant.fields.iter() {\n+            for variant in &variants {\n+                for field in &variant.fields {\n                     // Regions are checked below.\n                     bounds_checker.check_traits_in_ty(field.ty);\n                 }\n \n                 // For DST, all intermediate types must be sized.\n                 if variant.fields.len() > 0 {\n-                    for field in variant.fields.init().iter() {\n+                    for field in variant.fields.init() {\n                         fcx.register_builtin_bound(\n                             field.ty,\n                             ty::BoundSized,\n@@ -268,10 +268,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx);\n                 traits::normalize(selcx, cause.clone(), &predicates)\n             };\n-            for predicate in predicates.value.into_iter() {\n+            for predicate in predicates.value {\n                 fcx.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n             }\n-            for obligation in predicates.obligations.into_iter() {\n+            for obligation in predicates.obligations {\n                 fcx.register_predicate(obligation);\n             }\n         });\n@@ -323,7 +323,7 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n         .map(|tp| tp.name).collect::<HashSet<_>>();\n \n-    for method_param in generics.types.get_slice(subst::FnSpace).iter() {\n+    for method_param in generics.types.get_slice(subst::FnSpace) {\n         if impl_params.contains(&method_param.name) {\n             span_err!(tcx.sess, span, E0194,\n                 \"type parameter `{}` shadows another type parameter of the same name\","}, {"sha": "52b1eb490cc257c23204268dc6f581b41bbeff28", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -49,7 +49,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     assert_eq!(fcx.writeback_errors.get(), false);\n     let mut wbcx = WritebackCx::new(fcx);\n     wbcx.visit_block(blk);\n-    for arg in decl.inputs.iter() {\n+    for arg in &decl.inputs {\n         wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n         wbcx.visit_pat(&*arg.pat);\n \n@@ -119,7 +119,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n \n         match e.node {\n             ast::ExprClosure(_, _, ref decl, _) => {\n-                for input in decl.inputs.iter() {\n+                for input in &decl.inputs {\n                     let _ = self.visit_node_id(ResolvingExpr(e.span),\n                                                input.id);\n                 }\n@@ -182,7 +182,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        for (upvar_id, upvar_capture) in self.fcx.inh.upvar_capture_map.borrow().iter() {\n+        for (upvar_id, upvar_capture) in &*self.fcx.inh.upvar_capture_map.borrow() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n@@ -204,12 +204,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return\n         }\n \n-        for (def_id, closure_ty) in self.fcx.inh.closure_tys.borrow().iter() {\n+        for (def_id, closure_ty) in &*self.fcx.inh.closure_tys.borrow() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(*def_id));\n             self.fcx.tcx().closure_tys.borrow_mut().insert(*def_id, closure_ty);\n         }\n \n-        for (def_id, &closure_kind) in self.fcx.inh.closure_kinds.borrow().iter() {\n+        for (def_id, &closure_kind) in &*self.fcx.inh.closure_kinds.borrow() {\n             self.fcx.tcx().closure_kinds.borrow_mut().insert(*def_id, closure_kind);\n         }\n     }"}, {"sha": "ed340b0882ca3de3eb5398301559a260ccf476f4", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         // the tcx.\n         let mut tcx_inherent_impls =\n             self.crate_context.tcx.inherent_impls.borrow_mut();\n-        for (k, v) in self.inherent_impls.borrow().iter() {\n+        for (k, v) in &*self.inherent_impls.borrow() {\n             tcx_inherent_impls.insert((*k).clone(),\n                                       Rc::new((*v.borrow()).clone()));\n         }\n@@ -167,7 +167,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         let impl_items = self.create_impl_from_item(item);\n \n-        for associated_trait in associated_traits.iter() {\n+        for associated_trait in associated_traits {\n             let trait_ref = ty::node_id_to_trait_ref(self.crate_context.tcx,\n                                                      associated_trait.ref_id);\n             debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n \n         let prov = ty::provided_trait_methods(tcx, trait_ref.def_id);\n-        for trait_method in prov.iter() {\n+        for trait_method in &prov {\n             // Synthesize an ID.\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                             }\n                         }).collect();\n \n-                for trait_ref in trait_refs.iter() {\n+                if let Some(ref trait_ref) = *trait_refs {\n                     let ty_trait_ref = ty::node_id_to_trait_ref(\n                         self.crate_context.tcx,\n                         trait_ref.ref_id);\n@@ -345,17 +345,17 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         assert!(associated_traits.is_some());\n \n         // Record all the trait items.\n-        for trait_ref in associated_traits.iter() {\n+        if let Some(trait_ref) = associated_traits {\n             self.add_trait_impl(trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for item_def_id in impl_items.iter() {\n+        for item_def_id in &impl_items {\n             let impl_item = ty::impl_or_trait_item(tcx, item_def_id.def_id());\n             match impl_item {\n                 ty::MethodTraitItem(ref method) => {\n-                    for &source in method.provided_source.iter() {\n+                    if let Some(source) = method.provided_source {\n                         tcx.provided_method_sources\n                            .borrow_mut()\n                            .insert(item_def_id.def_id(), source);\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Some(found_impls) => found_impls\n         };\n \n-        for &impl_did in trait_impls.borrow().iter() {\n+        for &impl_did in &*trait_impls.borrow() {\n             let items = &(*impl_items)[impl_did];\n             if items.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n@@ -465,7 +465,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         // Clone first to avoid a double borrow error.\n         let trait_impls = trait_impls.borrow().clone();\n \n-        for &impl_did in trait_impls.iter() {\n+        for &impl_did in &trait_impls {\n             debug!(\"check_implementations_of_copy: impl_did={}\",\n                    impl_did.repr(tcx));\n \n@@ -559,7 +559,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // replace the type parameters declared on the trait with those\n     // from the impl\n-    for &space in [subst::TypeSpace, subst::SelfSpace].iter() {\n+    for &space in &[subst::TypeSpace, subst::SelfSpace] {\n         method_generics.types.replace(\n             space,\n             impl_type_scheme.generics.types.get_slice(space).to_vec());"}, {"sha": "403dcf1e25abaa52b4cefba4b6086aa2c413135a", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -46,7 +46,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                 (k, v.borrow().clone())\n             }).collect();\n \n-        for &(trait_def_id, ref impls) in trait_def_ids.iter() {\n+        for &(trait_def_id, ref impls) in &trait_def_ids {\n             self.check_for_overlapping_impls_of_trait(trait_def_id, impls);\n         }\n     }\n@@ -65,7 +65,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                 continue;\n             }\n \n-            for &impl2_def_id in trait_impls[(i+1)..].iter() {\n+            for &impl2_def_id in &trait_impls[(i+1)..] {\n                 self.check_if_impls_overlap(trait_def_id,\n                                             impl1_def_id,\n                                             impl2_def_id);"}, {"sha": "7dfa5298fb4c78b092d2e438b8b4694193f8ba27", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -203,7 +203,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n-    for variant in variants.iter() {\n+    for variant in variants {\n         let variant_def_id = local_def(variant.node.id);\n \n         // Nullary enum constructors get turned into constants; n-ary enum\n@@ -249,7 +249,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         if let ast::ItemTrait(_, _, _, ref trait_items) = item.node {\n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.impl_or_trait_items` table:\n-            for trait_item in trait_items.iter() {\n+            for trait_item in trait_items {\n                 match *trait_item {\n                     ast::RequiredMethod(_) |\n                     ast::ProvidedMethod(_) => {\n@@ -439,7 +439,7 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  container: ImplOrTraitItemContainer,\n-                                 mut ms: I,\n+                                 ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n@@ -527,8 +527,8 @@ fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n                                  thing: &'static str) {\n     let mut warn = false;\n \n-    for ty_param in generics.ty_params.iter() {\n-        for bound in ty_param.bounds.iter() {\n+    for ty_param in &*generics.ty_params {\n+        for bound in &*ty_param.bounds {\n             match *bound {\n                 ast::TraitTyParamBound(..) => {\n                     warn = true;\n@@ -596,7 +596,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n             };\n \n             let mut methods = Vec::new();\n-            for impl_item in impl_items.iter() {\n+            for impl_item in impl_items {\n                 match *impl_item {\n                     ast::MethodImplItem(ref method) => {\n                         let body_id = method.pe_body().id;\n@@ -644,7 +644,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                             &ty_generics,\n                             parent_visibility);\n \n-            for trait_ref in opt_trait_ref.iter() {\n+            if let Some(ref trait_ref) = *opt_trait_ref {\n                 astconv::instantiate_trait_ref(ccx,\n                                                &ExplicitRscope,\n                                                trait_ref,\n@@ -663,7 +663,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                    it.ident.repr(ccx.tcx),\n                    trait_def.repr(ccx.tcx));\n \n-            for trait_method in trait_methods.iter() {\n+            for trait_method in trait_methods {\n                 let self_type = ty::mk_self_type(tcx);\n                 match *trait_method {\n                     ast::RequiredMethod(ref type_method) => {\n@@ -1109,7 +1109,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     debug!(\"ty_generics_for_trait: assoc_predicates={}\", assoc_predicates.repr(ccx.tcx));\n \n-    for assoc_predicate in assoc_predicates.into_iter() {\n+    for assoc_predicate in assoc_predicates {\n         generics.predicates.push(subst::TypeSpace, assoc_predicate);\n     }\n \n@@ -1168,7 +1168,7 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n {\n     // Try to find an unbound in bounds.\n     let mut unbound = None;\n-    for ab in ast_bounds.iter() {\n+    for ab in ast_bounds {\n         if let &ast::TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = ab  {\n             if unbound.is_none() {\n                 assert!(ptr.bound_lifetimes.is_empty());\n@@ -1249,12 +1249,12 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     create_predicates(ccx.tcx, &mut result, space);\n \n     // Add the bounds not associated with a type parameter\n-    for predicate in where_clause.predicates.iter() {\n+    for predicate in &where_clause.predicates {\n         match predicate {\n             &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*bound_pred.bounded_ty);\n \n-                for bound in bound_pred.bounds.iter() {\n+                for bound in &*bound_pred.bounds {\n                     match bound {\n                         &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n@@ -1269,7 +1269,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n \n                             result.predicates.push(space, trait_ref.as_predicate());\n \n-                            for projection in projections.iter() {\n+                            for projection in &projections {\n                                 result.predicates.push(space, projection.as_predicate());\n                             }\n                         }\n@@ -1285,7 +1285,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n \n             &ast::WherePredicate::RegionPredicate(ref region_pred) => {\n                 let r1 = ast_region_to_region(ccx.tcx, &region_pred.lifetime);\n-                for bound in region_pred.bounds.iter() {\n+                for bound in &region_pred.bounds {\n                     let r2 = ast_region_to_region(ccx.tcx, bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     result.predicates.push(space, ty::Predicate::RegionOutlives(pred))\n@@ -1308,16 +1308,16 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n         result: &mut ty::Generics<'tcx>,\n         space: subst::ParamSpace)\n     {\n-        for type_param_def in result.types.get_slice(space).iter() {\n+        for type_param_def in result.types.get_slice(space) {\n             let param_ty = ty::mk_param_from_def(tcx, type_param_def);\n-            for predicate in ty::predicates(tcx, param_ty, &type_param_def.bounds).into_iter() {\n+            for predicate in ty::predicates(tcx, param_ty, &type_param_def.bounds) {\n                 result.predicates.push(space, predicate);\n             }\n         }\n \n-        for region_param_def in result.regions.get_slice(space).iter() {\n+        for region_param_def in result.regions.get_slice(space) {\n             let region = region_param_def.to_early_bound_region();\n-            for &bound_region in region_param_def.bounds.iter() {\n+            for &bound_region in &region_param_def.bounds {\n                 // account for new binder introduced in the predicate below; no need\n                 // to shift `region` because it is never a late-bound region\n                 let bound_region = ty_fold::shift_region(bound_region, 1);\n@@ -1480,7 +1480,7 @@ fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                        ast_generics: &ast::Generics,\n                                        abi: abi::Abi)\n                                        -> ty::TypeScheme<'tcx> {\n-    for i in decl.inputs.iter() {\n+    for i in &decl.inputs {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n             ast::PatWild(ast::PatWildSingle) => (),\n@@ -1655,7 +1655,7 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     loop {\n         let num_inputs = input_parameters.len();\n \n-        let mut projection_predicates =\n+        let projection_predicates =\n             impl_scheme.generics.predicates\n             .iter()\n             .filter_map(|predicate| {"}, {"sha": "a07179b31bbd897725af62686a63778b9f63e2eb", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -73,7 +73,6 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(non_camel_case_types)]\n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n \n #![feature(box_syntax)]\n #![feature(collections)]"}, {"sha": "ddb485d9776d14d244d643494aed017142b0295c", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -165,7 +165,7 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n     {\n         match self.base_scope.anon_regions(span, count) {\n             Ok(mut v) => {\n-                for r in v.iter_mut() {\n+                for r in &mut v {\n                     *r = ty_fold::shift_region(*r, 1);\n                 }\n                 Ok(v)"}, {"sha": "40197ee2c4988bf3eb0c717340f8a502d52a1864", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -499,12 +499,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                 // `ty::VariantInfo::from_ast_variant()` ourselves\n                 // here, mainly so as to mask the differences between\n                 // struct-like enums and so forth.\n-                for ast_variant in enum_definition.variants.iter() {\n+                for ast_variant in &enum_definition.variants {\n                     let variant =\n                         ty::VariantInfo::from_ast_variant(tcx,\n                                                           &**ast_variant,\n                                                           /*discriminant*/ 0);\n-                    for arg_ty in variant.args.iter() {\n+                    for arg_ty in &variant.args {\n                         self.add_constraints_from_ty(generics, *arg_ty, self.covariant);\n                     }\n                 }\n@@ -513,7 +513,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             ast::ItemStruct(..) => {\n                 let generics = &ty::lookup_item_type(tcx, did).generics;\n                 let struct_fields = ty::lookup_struct_fields(tcx, did);\n-                for field_info in struct_fields.iter() {\n+                for field_info in &struct_fields {\n                     assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n                     let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n                     self.add_constraints_from_ty(generics, field_ty, self.covariant);\n@@ -522,7 +522,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n             ast::ItemTrait(..) => {\n                 let trait_items = ty::trait_items(tcx, did);\n-                for trait_item in trait_items.iter() {\n+                for trait_item in &*trait_items {\n                     match *trait_item {\n                         ty::MethodTraitItem(ref method) => {\n                             self.add_constraints_from_sig(&method.generics,\n@@ -759,7 +759,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ty_tup(ref subtys) => {\n-                for &subty in subtys.iter() {\n+                for &subty in subtys {\n                     self.add_constraints_from_ty(generics, subty, variance);\n                 }\n             }\n@@ -821,7 +821,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 let projections = data.projection_bounds_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);\n-                for projection in projections.iter() {\n+                for projection in &projections {\n                     self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n                 }\n             }\n@@ -866,7 +866,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n \n-        for p in type_param_defs.iter() {\n+        for p in type_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n                                        p.space, p.index as uint);\n@@ -875,7 +875,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n         }\n \n-        for p in region_param_defs.iter() {\n+        for p in region_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id,\n                                        RegionParam, p.space, p.index as uint);\n@@ -892,7 +892,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                 sig: &ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n-        for &input in sig.0.inputs.iter() {\n+        for &input in &sig.0.inputs {\n             self.add_constraints_from_ty(generics, input, contra);\n         }\n         if let ty::FnConverging(result_type) = sig.0.output {\n@@ -990,7 +990,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         while changed {\n             changed = false;\n \n-            for constraint in self.constraints.iter() {\n+            for constraint in &self.constraints {\n                 let Constraint { inferred, variance: term } = *constraint;\n                 let InferredIndex(inferred) = inferred;\n                 let variance = self.evaluate(term);"}, {"sha": "07679480bfb39ef6f6f2702070d99df4c98cdf09", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                 _ => unreachable!(),\n             };\n             let mut tmp = Vec::new();\n-            for child in m.items.iter_mut() {\n+            for child in &mut m.items {\n                 match child.inner {\n                     ModuleItem(..) => {}\n                     _ => continue,\n@@ -254,7 +254,7 @@ impl Item {\n     /// Finds the `doc` attribute as a List and returns the list of attributes\n     /// nested inside.\n     pub fn doc_list<'a>(&'a self) -> Option<&'a [Attribute]> {\n-        for attr in self.attrs.iter() {\n+        for attr in &self.attrs {\n             match *attr {\n                 List(ref x, ref list) if \"doc\" == *x => {\n                     return Some(list.as_slice());\n@@ -268,7 +268,7 @@ impl Item {\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n-        for attr in self.attrs.iter() {\n+        for attr in &self.attrs {\n             match *attr {\n                 NameValue(ref x, ref v) if \"doc\" == *x => {\n                     return Some(v.as_slice());\n@@ -281,8 +281,8 @@ impl Item {\n \n     pub fn is_hidden_from_doc(&self) -> bool {\n         match self.doc_list() {\n-            Some(ref l) => {\n-                for innerattr in l.iter() {\n+            Some(l) => {\n+                for innerattr in l {\n                     match *innerattr {\n                         Word(ref s) if \"hidden\" == *s => {\n                             return true\n@@ -508,12 +508,12 @@ impl<'tcx> Clean<(Vec<TyParamBound>, Vec<TypeBinding>)> for ty::ExistentialBound\n     fn clean(&self, cx: &DocContext) -> (Vec<TyParamBound>, Vec<TypeBinding>) {\n         let mut tp_bounds = vec![];\n         self.region_bound.clean(cx).map(|b| tp_bounds.push(RegionBound(b)));\n-        for bb in self.builtin_bounds.iter() {\n+        for bb in &self.builtin_bounds {\n             tp_bounds.push(bb.clean(cx));\n         }\n \n         let mut bindings = vec![];\n-        for &ty::Binder(ref pb) in self.projection_bounds.iter() {\n+        for &ty::Binder(ref pb) in &self.projection_bounds {\n             bindings.push(TypeBinding {\n                 name: pb.projection_ty.item_name.clean(cx),\n                 ty: pb.ty.clean(cx)\n@@ -636,10 +636,10 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n \n         // collect any late bound regions\n         let mut late_bounds = vec![];\n-        for &ty_s in self.substs.types.get_slice(ParamSpace::TypeSpace).iter() {\n+        for &ty_s in self.substs.types.get_slice(ParamSpace::TypeSpace) {\n             use rustc::middle::ty::{Region, sty};\n             if let sty::ty_tup(ref ts) = ty_s.sty {\n-                for &ty_s in ts.iter() {\n+                for &ty_s in ts {\n                     if let sty::ty_rptr(ref reg, _) = ty_s.sty {\n                         if let &Region::ReLateBound(_, _) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n@@ -662,7 +662,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n impl<'tcx> Clean<Vec<TyParamBound>> for ty::ParamBounds<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n         let mut v = Vec::new();\n-        for t in self.trait_bounds.iter() {\n+        for t in &self.trait_bounds {\n             v.push(t.clean(cx));\n         }\n         for r in self.region_bounds.iter().filter_map(|r| r.clean(cx)) {\n@@ -872,7 +872,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n                     Some(did) => did,\n                     None => return false\n                 };\n-                for bound in bounds.iter() {\n+                for bound in bounds {\n                     if let TyParamBound::TraitBound(PolyTrait {\n                         trait_: Type::ResolvedPath { did, .. }, ..\n                     }, TBM::None) = *bound {\n@@ -915,7 +915,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n         }).collect::<Vec<_>>();\n         // Finally, run through the type parameters again and insert a ?Sized unbound for\n         // any we didn't find to be Sized.\n-        for tp in stripped_typarams.iter() {\n+        for tp in &stripped_typarams {\n             if !sized_params.contains(&tp.name) {\n                 let mut sized_bound = ty::BuiltinBound::BoundSized.clean(cx);\n                 if let TyParamBound::TraitBound(_, ref mut tbm) = sized_bound {\n@@ -1420,12 +1420,12 @@ impl PrimitiveType {\n     }\n \n     fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n-        for attr in attrs.iter() {\n+        for attr in attrs {\n             let list = match *attr {\n                 List(ref k, ref l) if *k == \"doc\" => l,\n                 _ => continue,\n             };\n-            for sub_attr in list.iter() {\n+            for sub_attr in list {\n                 let value = match *sub_attr {\n                     NameValue(ref k, ref v)\n                         if *k == \"primitive\" => v.as_slice(),\n@@ -2175,7 +2175,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n                 let mut ret = vec![];\n                 let remaining = if !denied {\n                     let mut remaining = vec![];\n-                    for path in list.iter() {\n+                    for path in list {\n                         match inline::try_inline(cx, path.node.id(), None) {\n                             Some(items) => {\n                                 ret.extend(items.into_iter());"}, {"sha": "84e88158219ae584273f5e524d4c205f2d13d84d", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -62,7 +62,7 @@ macro_rules! load_or_return {\n \n pub fn load_external_files(names: &[String]) -> Option<String> {\n     let mut out = String::new();\n-    for name in names.iter() {\n+    for name in names {\n         out.push_str(load_or_return!(name.as_slice(), None, None).as_slice());\n         out.push('\\n');\n     }"}, {"sha": "a7cf5eb89187f2a99ac4b6133e33fea74d710062", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -64,7 +64,7 @@ mod imp {\n         pub const F_SETLKW: libc::c_int = 13;\n     }\n \n-    #[cfg(target_os = \"dragonfly\")]\n+    #[cfg(any(target_os = \"dragonfly\", target_os = \"openbsd\"))]\n     mod os {\n         use libc;\n "}, {"sha": "e86c0e39714083faacbcaf37bf61441b0562f9cb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -212,21 +212,21 @@ impl fmt::Display for clean::PathParameters {\n                 if lifetimes.len() > 0 || types.len() > 0 || bindings.len() > 0 {\n                     try!(f.write_str(\"&lt;\"));\n                     let mut comma = false;\n-                    for lifetime in lifetimes.iter() {\n+                    for lifetime in lifetimes {\n                         if comma {\n                             try!(f.write_str(\", \"));\n                         }\n                         comma = true;\n                         try!(write!(f, \"{}\", *lifetime));\n                     }\n-                    for ty in types.iter() {\n+                    for ty in types {\n                         if comma {\n                             try!(f.write_str(\", \"));\n                         }\n                         comma = true;\n                         try!(write!(f, \"{}\", *ty));\n                     }\n-                    for binding in bindings.iter() {\n+                    for binding in bindings {\n                         if comma {\n                             try!(f.write_str(\", \"));\n                         }\n@@ -239,7 +239,7 @@ impl fmt::Display for clean::PathParameters {\n             clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n                 try!(f.write_str(\"(\"));\n                 let mut comma = false;\n-                for ty in inputs.iter() {\n+                for ty in inputs {\n                     if comma {\n                         try!(f.write_str(\", \"));\n                     }\n@@ -332,7 +332,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments[..amt].iter() {\n+                for seg in &path.segments[..amt] {\n                     if \"super\" == seg.name ||\n                             \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -347,7 +347,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n                 }\n             }\n             None => {\n-                for seg in path.segments[..amt].iter() {\n+                for seg in &path.segments[..amt] {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }\n@@ -359,7 +359,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n             let mut url = String::from_str(abs_root.unwrap().as_slice());\n             let to_link = &fqp[..fqp.len() - 1];\n-            for component in to_link.iter() {\n+            for component in to_link {\n                 url.push_str(component.as_slice());\n                 url.push_str(\"/\");\n             }\n@@ -440,7 +440,7 @@ fn tybounds(w: &mut fmt::Formatter,\n             typarams: &Option<Vec<clean::TyParamBound> >) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n-            for param in params.iter() {\n+            for param in params {\n                 try!(write!(w, \" + \"));\n                 try!(write!(w, \"{}\", *param));\n             }\n@@ -770,7 +770,7 @@ impl fmt::Display for ModuleSummary {\n                         (100 * cnt.unmarked) as f64/tot as f64));\n             try!(write!(f, \"</td></tr>\"));\n \n-            for submodule in m.submodules.iter() {\n+            for submodule in &m.submodules {\n                 try!(fmt_inner(f, context, submodule));\n             }\n             context.pop();"}, {"sha": "6247c6dad1496dd23b3e2a9fce432e2427621e94", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -283,7 +283,7 @@ pub fn run(mut krate: clean::Crate,\n     let default: &[_] = &[];\n     match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(default)) {\n         Some(attrs) => {\n-            for attr in attrs.iter() {\n+            for attr in attrs {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n                             if \"html_favicon_url\" == *x => {\n@@ -353,7 +353,7 @@ pub fn run(mut krate: clean::Crate,\n     krate = cache.fold_crate(krate);\n \n     // Cache where all our extern crates are located\n-    for &(n, ref e) in krate.externs.iter() {\n+    for &(n, ref e) in &krate.externs {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n         let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n         cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n@@ -364,11 +364,11 @@ pub fn run(mut krate: clean::Crate,\n     // Favor linking to as local extern as possible, so iterate all crates in\n     // reverse topological order.\n     for &(n, ref e) in krate.externs.iter().rev() {\n-        for &prim in e.primitives.iter() {\n+        for &prim in &e.primitives {\n             cache.primitive_locations.insert(prim, n);\n         }\n     }\n-    for &prim in krate.primitives.iter() {\n+    for &prim in &krate.primitives {\n         cache.primitive_locations.insert(prim, ast::LOCAL_CRATE);\n     }\n \n@@ -402,7 +402,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<Stri\n \n         // Attach all orphan methods to the type's definition if the type\n         // has since been learned.\n-        for &(pid, ref item) in orphan_methods.iter() {\n+        for &(pid, ref item) in orphan_methods {\n             let did = ast_util::local_def(pid);\n             match paths.get(&did) {\n                 Some(&(ref fqp, _)) => {\n@@ -420,7 +420,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<Stri\n \n         // Reduce `NodeId` in paths into smaller sequential numbers,\n         // and prune the paths that do not appear in the index.\n-        for item in search_index.iter() {\n+        for item in &*search_index {\n             match item.parent {\n                 Some(nodeid) => {\n                     if !nodeid_to_pathid.contains_key(&nodeid) {\n@@ -542,15 +542,15 @@ fn write_shared(cx: &Context,\n     let mut w = try!(File::create(&dst));\n     try!(writeln!(&mut w, \"var searchIndex = {{}};\"));\n     try!(writeln!(&mut w, \"{}\", search_index));\n-    for index in all_indexes.iter() {\n+    for index in &all_indexes {\n         try!(writeln!(&mut w, \"{}\", *index));\n     }\n     try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n     try!(mkdir(&dst));\n-    for (&did, imps) in cache.implementors.iter() {\n+    for (&did, imps) in &cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n@@ -564,7 +564,7 @@ fn write_shared(cx: &Context,\n         };\n \n         let mut mydst = dst.clone();\n-        for part in remote_path[..remote_path.len() - 1].iter() {\n+        for part in &remote_path[..remote_path.len() - 1] {\n             mydst.push(part.as_slice());\n             try!(mkdir(&mydst));\n         }\n@@ -578,12 +578,12 @@ fn write_shared(cx: &Context,\n         let mut f = BufferedWriter::new(try!(File::create(&mydst)));\n         try!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"));\n \n-        for implementor in all_implementors.iter() {\n+        for implementor in &all_implementors {\n             try!(write!(&mut f, \"{}\", *implementor));\n         }\n \n         try!(write!(&mut f, r\"implementors['{}'] = [\", krate.name));\n-        for imp in imps.iter() {\n+        for imp in imps {\n             // If the trait and implementation are in the same crate, then\n             // there's no need to emit information about it (there's inlining\n             // going on). If they're in different crates then the crate defining\n@@ -679,10 +679,10 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    for attr in e.attrs.iter() {\n+    for attr in &e.attrs {\n         match *attr {\n             clean::List(ref x, ref list) if \"doc\" == *x => {\n-                for attr in list.iter() {\n+                for attr in list {\n                     match *attr {\n                         clean::NameValue(ref x, ref s)\n                                 if \"html_root_url\" == *x => {\n@@ -1043,7 +1043,7 @@ impl DocFolder for Cache {\n \n impl<'a> Cache {\n     fn generics(&mut self, generics: &clean::Generics) {\n-        for typ in generics.type_params.iter() {\n+        for typ in &generics.type_params {\n             self.typarams.insert(typ.did, typ.name.clone());\n         }\n     }\n@@ -1190,7 +1190,7 @@ impl Context {\n                                            .collect::<String>();\n                 match cache().paths.get(&it.def_id) {\n                     Some(&(ref names, _)) => {\n-                        for name in (&names[..names.len() - 1]).iter() {\n+                        for name in &names[..names.len() - 1] {\n                             url.push_str(name.as_slice());\n                             url.push_str(\"/\");\n                         }\n@@ -1231,7 +1231,7 @@ impl Context {\n                         _ => unreachable!()\n                     };\n                     this.sidebar = this.build_sidebar(&m);\n-                    for item in m.items.into_iter() {\n+                    for item in m.items {\n                         f(this,item);\n                     }\n                     Ok(())\n@@ -1252,7 +1252,7 @@ impl Context {\n \n     fn build_sidebar(&self, m: &clean::Module) -> HashMap<String, Vec<NameDoc>> {\n         let mut map = HashMap::new();\n-        for item in m.items.iter() {\n+        for item in &m.items {\n             if self.ignore_private_item(item) { continue }\n \n             // avoid putting foreign items to the sidebar.\n@@ -1270,7 +1270,7 @@ impl Context {\n             v.push(NameDoc(myname, Some(shorter_line(item.doc_value()))));\n         }\n \n-        for (_, items) in map.iter_mut() {\n+        for (_, items) in &mut map {\n             items.sort();\n         }\n         return map;\n@@ -1536,7 +1536,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n     debug!(\"{:?}\", indices);\n     let mut curty = None;\n-    for &idx in indices.iter() {\n+    for &idx in &indices {\n         let myitem = &items[idx];\n \n         let myty = Some(shortty(myitem));\n@@ -1696,23 +1696,23 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"{{ }}\"));\n     } else {\n         try!(write!(w, \"{{\\n\"));\n-        for t in types.iter() {\n+        for t in &types {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, t.item()));\n             try!(write!(w, \";\\n\"));\n         }\n         if types.len() > 0 && required.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n-        for m in required.iter() {\n+        for m in &required {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m.item()));\n             try!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n-        for m in provided.iter() {\n+        for m in &provided {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m.item()));\n             try!(write!(w, \" {{ ... }}\\n\"));\n@@ -1741,7 +1741,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <h2 id='associated-types'>Associated Types</h2>\n             <div class='methods'>\n         \"));\n-        for t in types.iter() {\n+        for t in &types {\n             try!(trait_item(w, *t));\n         }\n         try!(write!(w, \"</div>\"));\n@@ -1753,7 +1753,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <h2 id='required-methods'>Required Methods</h2>\n             <div class='methods'>\n         \"));\n-        for m in required.iter() {\n+        for m in &required {\n             try!(trait_item(w, *m));\n         }\n         try!(write!(w, \"</div>\"));\n@@ -1763,7 +1763,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <h2 id='provided-methods'>Provided Methods</h2>\n             <div class='methods'>\n         \"));\n-        for m in provided.iter() {\n+        for m in &provided {\n             try!(trait_item(w, *m));\n         }\n         try!(write!(w, \"</div>\"));\n@@ -1776,7 +1776,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     \"));\n     match cache.implementors.get(&it.def_id) {\n         Some(implementors) => {\n-            for i in implementors.iter() {\n+            for i in implementors {\n                 try!(writeln!(w, \"<li>{}<code>impl{} {} for {}{}</code></li>\",\n                               ConciseStability(&i.stability),\n                               i.generics, i.trait_, i.for_, WhereClause(&i.generics)));\n@@ -1890,7 +1890,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \" {{}}\"));\n     } else {\n         try!(write!(w, \" {{\\n\"));\n-        for v in e.variants.iter() {\n+        for v in &e.variants {\n             try!(write!(w, \"    \"));\n             let name = v.name.as_ref().unwrap().as_slice();\n             match v.inner {\n@@ -1933,7 +1933,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     try!(document(w, it));\n     if e.variants.len() > 0 {\n         try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n-        for variant in e.variants.iter() {\n+        for variant in &e.variants {\n             try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n                           stab = ConciseStability(&variant.stability),\n                           name = variant.name.as_ref().unwrap().as_slice()));\n@@ -1996,7 +1996,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n         doctree::Plain => {\n             try!(write!(w, \" {{\\n{}\", tab));\n             let mut fields_stripped = false;\n-            for field in fields.iter() {\n+            for field in fields {\n                 match field.inner {\n                     clean::StructFieldItem(clean::HiddenStructField) => {\n                         fields_stripped = true;\n@@ -2049,7 +2049,7 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n                 .partition(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n-                for i in non_trait.iter() {\n+                for i in &non_trait {\n                     try!(render_impl(w, i));\n                 }\n             }\n@@ -2058,13 +2058,13 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n                                   Implementations</h2>\"));\n                 let (derived, manual): (Vec<_>, _) = traits.into_iter()\n                     .partition(|i| i.impl_.derived);\n-                for i in manual.iter() {\n+                for i in &manual {\n                     try!(render_impl(w, i));\n                 }\n                 if derived.len() > 0 {\n                     try!(write!(w, \"<h3 id='derived_implementations'>Derived Implementations \\\n                                 </h3>\"));\n-                    for i in derived.iter() {\n+                    for i in &derived {\n                         try!(render_impl(w, i));\n                     }\n                 }\n@@ -2137,14 +2137,14 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     }\n \n     try!(write!(w, \"<div class='impl-items'>\"));\n-    for trait_item in i.impl_.items.iter() {\n+    for trait_item in &i.impl_.items {\n         try!(doctraititem(w, trait_item, true));\n     }\n \n     fn render_default_methods(w: &mut fmt::Formatter,\n                               t: &clean::Trait,\n                               i: &clean::Impl) -> fmt::Result {\n-        for trait_item in t.items.iter() {\n+        for trait_item in &t.items {\n             let n = trait_item.item().name.clone();\n             match i.items.iter().find(|m| { m.name == n }) {\n                 Some(..) => continue,\n@@ -2209,7 +2209,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                 None => return Ok(())\n             };\n             try!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n-            for &NameDoc(ref name, ref doc) in items.iter() {\n+            for &NameDoc(ref name, ref doc) in items {\n                 let curty = shortty(cur).to_static_str();\n                 let class = if cur.name.as_ref().unwrap() == name &&\n                                short == curty { \"current\" } else { \"\" };"}, {"sha": "7790c7d6a50f7262d2990c31c0d45488ec626015", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -185,7 +185,7 @@ impl fmt::Debug for Toc {\n impl fmt::Display for Toc {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"<ul>\"));\n-        for entry in self.entries.iter() {\n+        for entry in &self.entries {\n             // recursively format this table of contents (the\n             // `{children}` is the key).\n             try!(write!(fmt,"}, {"sha": "f4b8bbd5f8a518772bd64d88473e428ba94b2d24", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -21,6 +21,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(env)]\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n@@ -50,6 +51,7 @@ extern crate \"serialize\" as rustc_serialize; // used by deriving\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n+use std::env;\n use std::old_io::File;\n use std::old_io;\n use std::rc::Rc;\n@@ -121,9 +123,10 @@ struct Output {\n pub fn main() {\n     static STACK_SIZE: uint = 32000000; // 32MB\n     let res = std::thread::Builder::new().stack_size(STACK_SIZE).scoped(move || {\n-        main_args(std::os::args().as_slice())\n+        let s = env::args().map(|s| s.into_string().unwrap());\n+        main_args(&s.collect::<Vec<_>>())\n     }).join();\n-    std::os::set_exit_status(res.ok().unwrap());\n+    env::set_exit_status(res.ok().unwrap() as i32);\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {\n@@ -197,11 +200,11 @@ pub fn main_args(args: &[String]) -> int {\n \n     if matches.opt_strs(\"passes\") == [\"list\"] {\n         println!(\"Available passes for running rustdoc:\");\n-        for &(name, _, description) in PASSES.iter() {\n+        for &(name, _, description) in PASSES {\n             println!(\"{:>20} - {}\", name, description);\n         }\n         println!(\"{}\", \"\\nDefault passes for rustdoc:\"); // FIXME: #9970\n-        for &name in DEFAULT_PASSES.iter() {\n+        for &name in DEFAULT_PASSES {\n             println!(\"{:>20}\", name);\n         }\n         return 0;\n@@ -217,7 +220,7 @@ pub fn main_args(args: &[String]) -> int {\n     let input = matches.free[0].as_slice();\n \n     let mut libs = SearchPaths::new();\n-    for s in matches.opt_strs(\"L\").iter() {\n+    for s in &matches.opt_strs(\"L\") {\n         libs.add_path(s.as_slice());\n     }\n     let externs = match parse_externs(&matches) {\n@@ -319,7 +322,7 @@ fn acquire_input(input: &str,\n /// error message.\n fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n-    for arg in matches.opt_strs(\"extern\").iter() {\n+    for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n@@ -353,7 +356,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     // First, parse the crate and extract all relevant information.\n     let mut paths = SearchPaths::new();\n-    for s in matches.opt_strs(\"L\").iter() {\n+    for s in &matches.opt_strs(\"L\") {\n         paths.add_path(s.as_slice());\n     }\n     let cfgs = matches.opt_strs(\"cfg\");\n@@ -383,7 +386,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // with the passes which we are supposed to run.\n     match krate.module.as_ref().unwrap().doc_list() {\n         Some(nested) => {\n-            for inner in nested.iter() {\n+            for inner in nested {\n                 match *inner {\n                     clean::Word(ref x)\n                             if \"no_default_passes\" == *x => {\n@@ -417,7 +420,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     let path = matches.opt_str(\"plugin-path\")\n                       .unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n     let mut pm = plugins::PluginManager::new(Path::new(path));\n-    for pass in passes.iter() {\n+    for pass in &passes {\n         let plugin = match PASSES.iter()\n                                  .position(|&(p, _, _)| {\n                                      p == *pass\n@@ -431,7 +434,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n         pm.add_plugin(plugin);\n     }\n     info!(\"loading plugins...\");\n-    for pname in plugins.into_iter() {\n+    for pname in plugins {\n         pm.load_plugin(pname);\n     }\n "}, {"sha": "365fb78cfae63cecbcf7073000fae4f7d12bce5d", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -47,7 +47,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n     output.set_extension(\"html\");\n \n     let mut css = String::new();\n-    for name in matches.opt_strs(\"markdown-css\").iter() {\n+    for name in &matches.opt_strs(\"markdown-css\") {\n         let s = format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\", name);\n         css.push_str(s.as_slice())\n     }"}, {"sha": "e1c6bf1f4cfdd341322a65e128377234f0df2f99", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -255,7 +255,7 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n             let mut i = i;\n             let mut avec: Vec<clean::Attribute> = Vec::new();\n-            for attr in i.attrs.iter() {\n+            for attr in &i.attrs {\n                 match attr {\n                     &clean::NameValue(ref x, ref s)\n                             if \"doc\" == *x => {\n@@ -280,7 +280,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n             let mut docstr = String::new();\n             let mut i = i;\n-            for attr in i.attrs.iter() {\n+            for attr in &i.attrs {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n                             if \"doc\" == *x => {"}, {"sha": "a2afba091f4a1f8aaf3ffc4248ac73741f14585c", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -64,7 +64,7 @@ impl PluginManager {\n     pub fn run_plugins(&self, krate: clean::Crate) -> (clean::Crate, Vec<PluginJson> ) {\n         let mut out_json = Vec::new();\n         let mut krate = krate;\n-        for &callback in self.callbacks.iter() {\n+        for &callback in &self.callbacks {\n             let (c, res) = callback(krate);\n             krate = c;\n             out_json.push(res);"}, {"sha": "29abea009e547f2580a9b2a9e76d804ac06c9e33", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -13,7 +13,7 @@ use std::sync::mpsc::channel;\n use std::dynamic_lib::DynamicLibrary;\n use std::old_io::{Command, TempDir};\n use std::old_io;\n-use std::os;\n+use std::env;\n use std::str;\n use std::thread::Thread;\n use std::thunk::Thunk;\n@@ -49,7 +49,7 @@ pub fn run(input: &str,\n     let input = config::Input::File(input_path.clone());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n+        maybe_sysroot: Some(env::current_exe().unwrap().dir_path().dir_path()),\n         search_paths: libs.clone(),\n         crate_types: vec!(config::CrateTypeDylib),\n         externs: externs.clone(),\n@@ -119,7 +119,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let input = config::Input::Str(test.to_string());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n+        maybe_sysroot: Some(env::current_exe().unwrap().dir_path().dir_path()),\n         search_paths: libs,\n         crate_types: vec!(config::CrateTypeExecutable),\n         output_types: vec!(config::OutputTypeExe),"}, {"sha": "5bcda778cbbb0d4284a3c924be7f4015985198f0", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.vis = vis;\n         om.stab = self.stability(id);\n         om.id = id;\n-        for i in m.items.iter() {\n+        for i in &m.items {\n             self.visit_item(&**i, None, &mut om);\n         }\n         om\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if glob {\n                     match it.node {\n                         ast::ItemMod(ref m) => {\n-                            for i in m.items.iter() {\n+                            for i in &m.items {\n                                 self.visit_item(&**i, None, om);\n                             }\n                         }"}, {"sha": "d61d5b68462610ec82307d7625715505befa4b91", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -74,7 +74,7 @@ impl<\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n-            for (key, val) in self.iter() {\n+            for (key, val) in self {\n                 try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n                 try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n                 i += 1;\n@@ -107,7 +107,7 @@ impl<\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n-            for e in self.iter() {\n+            for e in self {\n                 try!(s.emit_seq_elt(i, |s| e.encode(s)));\n                 i += 1;\n             }\n@@ -135,7 +135,7 @@ impl<\n > Encodable for EnumSet<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         let mut bits = 0;\n-        for item in self.iter() {\n+        for item in self {\n             bits |= item.to_uint();\n         }\n         s.emit_uint(bits)\n@@ -166,7 +166,7 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n-            for (key, val) in self.iter() {\n+            for (key, val) in self {\n                 try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n                 try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n                 i += 1;\n@@ -204,7 +204,7 @@ impl<T, S> Encodable for HashSet<T, S>\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n-            for e in self.iter() {\n+            for e in self {\n                 try!(s.emit_seq_elt(i, |s| e.encode(s)));\n                 i += 1;\n             }"}, {"sha": "a34ae1087dbbe3ccb5ec599cc014a8abf3aa3115", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -42,7 +42,7 @@ impl ToHex for [u8] {\n     /// ```\n     fn to_hex(&self) -> String {\n         let mut v = Vec::with_capacity(self.len() * 2);\n-        for &byte in self.iter() {\n+        for &byte in self {\n             v.push(CHARS[(byte >> 4) as uint]);\n             v.push(CHARS[(byte & 0xf) as uint]);\n         }"}, {"sha": "3bc9e699035da3b2f70eef1f2f2bb23aa87a69b4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1051,7 +1051,7 @@ impl Json {\n     /// Otherwise, it will return the Json value associated with the final key.\n     pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json>{\n         let mut target = self;\n-        for key in keys.iter() {\n+        for key in keys {\n             match target.find(*key) {\n                 Some(t) => { target = t; },\n                 None => return None\n@@ -1069,7 +1069,7 @@ impl Json {\n                 match map.get(key) {\n                     Some(json_value) => Some(json_value),\n                     None => {\n-                        for (_, v) in map.iter() {\n+                        for (_, v) in map {\n                             match v.search(key) {\n                                 x if x.is_some() => return x,\n                                 _ => ()\n@@ -1367,7 +1367,7 @@ impl Stack {\n     // Used by Parser to insert StackElement::Key elements at the top of the stack.\n     fn push_key(&mut self, key: string::String) {\n         self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n-        for c in key.as_bytes().iter() {\n+        for c in key.as_bytes() {\n             self.str_buffer.push(*c);\n         }\n     }\n@@ -2371,7 +2371,7 @@ impl ::Decoder for Decoder {\n     {\n         let obj = try!(expect!(self.pop(), Object));\n         let len = obj.len();\n-        for (key, value) in obj.into_iter() {\n+        for (key, value) in obj {\n             self.stack.push(value);\n             self.stack.push(Json::String(key));\n         }\n@@ -2497,7 +2497,7 @@ impl<A: ToJson> ToJson for Vec<A> {\n impl<A: ToJson> ToJson for BTreeMap<string::String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = BTreeMap::new();\n-        for (key, value) in self.iter() {\n+        for (key, value) in self {\n             d.insert((*key).clone(), value.to_json());\n         }\n         Json::Object(d)\n@@ -2507,7 +2507,7 @@ impl<A: ToJson> ToJson for BTreeMap<string::String, A> {\n impl<A: ToJson> ToJson for HashMap<string::String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = BTreeMap::new();\n-        for (key, value) in self.iter() {\n+        for (key, value) in self {\n             d.insert((*key).clone(), value.to_json());\n         }\n         Json::Object(d)\n@@ -2670,7 +2670,7 @@ mod tests {\n     fn mk_object(items: &[(string::String, Json)]) -> Json {\n         let mut d = BTreeMap::new();\n \n-        for item in items.iter() {\n+        for item in items {\n             match *item {\n                 (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n             }\n@@ -3044,7 +3044,7 @@ mod tests {\n                  (\"\\\"\\\\u12ab\\\"\", \"\\u{12ab}\"),\n                  (\"\\\"\\\\uAB12\\\"\", \"\\u{AB12}\")];\n \n-        for &(i, o) in s.iter() {\n+        for &(i, o) in &s {\n             let v: string::String = super::decode(i).unwrap();\n             assert_eq!(v, o);\n         }"}, {"sha": "274c669d8dfc2ce902dafc027b35275a7006a6fd", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -134,15 +134,15 @@ impl AsciiExt<Vec<u8>> for [u8] {\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_uppercase(mut self) -> Vec<u8> {\n-        for byte in self.iter_mut() {\n+        for byte in &mut self {\n             *byte = byte.to_ascii_uppercase();\n         }\n         self\n     }\n \n     #[inline]\n     fn into_ascii_lowercase(mut self) -> Vec<u8> {\n-        for byte in self.iter_mut() {\n+        for byte in &mut self {\n             *byte = byte.to_ascii_lowercase();\n         }\n         self\n@@ -232,7 +232,7 @@ pub fn escape_default<F>(c: u8, mut f: F) where\n         _ => {\n             f(b'\\\\');\n             f(b'x');\n-            for &offset in [4u, 0u].iter() {\n+            for &offset in &[4u, 0u] {\n                 match ((c as i32) >> offset) & 0xf {\n                     i @ 0 ... 9 => f(b'0' + (i as u8)),\n                     i => f(b'a' + (i as u8 - 10)),"}, {"sha": "7b3cc434f0ca3e2201951d7f86f887a1578921e8", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -20,7 +20,7 @@ use cmp::{max, Eq, PartialEq};\n use default::Default;\n use fmt::{self, Debug};\n use hash::{self, Hash, SipHasher};\n-use iter::{self, Iterator, ExactSizeIterator, IteratorExt, FromIterator, Extend, Map};\n+use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n use mem::{self, replace};\n use num::{Int, UnsignedInt};\n@@ -1300,18 +1300,13 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// HashMap move iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    inner: iter::Map<\n-        (SafeHash, K, V),\n-        (K, V),\n-        table::IntoIter<K, V>,\n-        fn((SafeHash, K, V)) -> (K, V),\n-    >\n+    inner: iter::Map<table::IntoIter<K, V>, fn((SafeHash, K, V)) -> (K, V)>\n }\n \n /// HashMap keys iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1326,7 +1321,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n /// HashMap values iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1342,12 +1337,7 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n #[unstable(feature = \"std_misc\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n-    inner: iter::Map<\n-        (SafeHash, K, V),\n-        (K, V),\n-        table::Drain<'a, K, V>,\n-        fn((SafeHash, K, V)) -> (K, V),\n-    >\n+    inner: iter::Map<table::Drain<'a, K, V>, fn((SafeHash, K, V)) -> (K, V)>\n }\n \n /// A view into a single occupied location in a HashMap.\n@@ -1385,6 +1375,42 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n+impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = IterMut<'a, K, V>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, K, V> {\n+        self.iter_mut()\n+    }\n+}\n+\n+impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = IntoIter<K, V>;\n+\n+    fn into_iter(self) -> IntoIter<K, V> {\n+        self.into_iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n@@ -1539,7 +1565,7 @@ impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n-    fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n+    fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -1941,7 +1967,7 @@ mod test_map {\n \n         let mut observed: u32 = 0;\n \n-        for (k, v) in m.iter() {\n+        for (k, v) in &m {\n             assert_eq!(*v, *k * 2);\n             observed |= 1 << *k;\n         }\n@@ -2131,7 +2157,7 @@ mod test_map {\n \n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n-        for &(k, v) in xs.iter() {\n+        for &(k, v) in &xs {\n             assert_eq!(map.get(&k), Some(&v));\n         }\n     }"}, {"sha": "f5877e1dd99d8e6fcb62f3ed608bd598a69af076", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -18,7 +18,9 @@ use default::Default;\n use fmt::Debug;\n use fmt;\n use hash::{self, Hash};\n-use iter::{Iterator, ExactSizeIterator, IteratorExt, FromIterator, Map, Chain, Extend};\n+use iter::{\n+    Iterator, IntoIterator, ExactSizeIterator, IteratorExt, FromIterator, Map, Chain, Extend,\n+};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n \n@@ -634,7 +636,7 @@ impl<T, S, H> Extend<T> for HashSet<T, S>\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n-    fn extend<I: Iterator<Item=T>>(&mut self, mut iter: I) {\n+    fn extend<I: Iterator<Item=T>>(&mut self, iter: I) {\n         for k in iter {\n             self.insert(k);\n         }\n@@ -794,13 +796,13 @@ pub struct Iter<'a, K: 'a> {\n /// HashSet move iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n-    iter: Map<(K, ()), K, map::IntoIter<K, ()>, fn((K, ())) -> K>\n+    iter: Map<map::IntoIter<K, ()>, fn((K, ())) -> K>\n }\n \n /// HashSet drain iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n-    iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n+    iter: Map<map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n }\n \n /// Intersection iterator\n@@ -833,6 +835,30 @@ pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n+impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<T, S, H> IntoIterator for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Iter<'a, K> {\n     type Item = &'a K;\n@@ -1007,7 +1033,7 @@ mod test_set {\n             assert!(a.insert(i));\n         }\n         let mut observed: u32 = 0;\n-        for k in a.iter() {\n+        for k in &a {\n             observed |= 1 << *k;\n         }\n         assert_eq!(observed, 0xFFFF_FFFF);\n@@ -1128,7 +1154,7 @@ mod test_set {\n \n         let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n \n-        for x in xs.iter() {\n+        for x in &xs {\n             assert!(set.contains(x));\n         }\n     }\n@@ -1214,7 +1240,7 @@ mod test_set {\n                 assert_eq!(last_i, 49);\n             }\n \n-            for _ in s.iter() { panic!(\"s should be empty!\"); }\n+            for _ in &s { panic!(\"s should be empty!\"); }\n \n             // reset to try again.\n             s.extend(1..100);"}, {"sha": "68ae0f7e5b5f3ace6049fb6e7ae9f43fbf3b8aba", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -19,7 +19,7 @@ use prelude::v1::*;\n \n use ffi::CString;\n use mem;\n-use os;\n+use env;\n use str;\n \n #[allow(missing_copy_implementations)]\n@@ -68,8 +68,8 @@ impl DynamicLibrary {\n         let mut search_path = DynamicLibrary::search_path();\n         search_path.insert(0, path.clone());\n         let newval = DynamicLibrary::create_path(search_path.as_slice());\n-        os::setenv(DynamicLibrary::envvar(),\n-                   str::from_utf8(newval.as_slice()).unwrap());\n+        env::set_var(DynamicLibrary::envvar(),\n+                     str::from_utf8(newval.as_slice()).unwrap());\n     }\n \n     /// From a slice of paths, create a new vector which is suitable to be an\n@@ -102,18 +102,10 @@ impl DynamicLibrary {\n     /// Returns the current search path for dynamic libraries being used by this\n     /// process\n     pub fn search_path() -> Vec<Path> {\n-        let mut ret = Vec::new();\n-        match os::getenv_as_bytes(DynamicLibrary::envvar()) {\n-            Some(env) => {\n-                for portion in\n-                        env.as_slice()\n-                           .split(|a| *a == DynamicLibrary::separator()) {\n-                    ret.push(Path::new(portion));\n-                }\n-            }\n-            None => {}\n+        match env::var(DynamicLibrary::envvar()) {\n+            Some(var) => env::split_paths(&var).collect(),\n+            None => Vec::new(),\n         }\n-        return ret;\n     }\n \n     /// Access the value at the symbol of the dynamic library\n@@ -173,7 +165,8 @@ mod test {\n     #[cfg(any(target_os = \"linux\",\n               target_os = \"macos\",\n               target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\"))]\n     fn test_errors_do_not_crash() {\n         // Open /dev/null as a library to get an error, and make sure\n         // that only causes an error, and not a crash.\n@@ -190,7 +183,8 @@ mod test {\n           target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n mod dl {\n     use prelude::v1::*;\n \n@@ -254,7 +248,6 @@ mod dl {\n         dlclose(handle as *mut libc::c_void); ()\n     }\n \n-    #[link_name = \"dl\"]\n     extern {\n         fn dlopen(filename: *const libc::c_char,\n                   flag: libc::c_int) -> *mut libc::c_void;"}, {"sha": "5070f8c547ab0663501b84ce25d29b291c84c561", "filename": "src/libstd/env.rs", "status": "added", "additions": 833, "deletions": 0, "changes": 833, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -0,0 +1,833 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Inspection and manipulation of the process's environment.\n+//!\n+//! This module contains methods to inspect various aspects such as\n+//! environment varibles, process arguments, the current directory, and various\n+//! other important directories.\n+\n+#![unstable(feature = \"env\", reason = \"recently added via RFC 578\")]\n+\n+use prelude::v1::*;\n+\n+use error::Error;\n+use ffi::{OsString, AsOsStr};\n+use fmt;\n+use old_io::IoResult;\n+use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n+use sync::{StaticMutex, MUTEX_INIT};\n+use sys::os as os_imp;\n+\n+/// Returns the current working directory as a `Path`.\n+///\n+/// # Errors\n+///\n+/// Returns an `Err` if the current working directory value is invalid.\n+/// Possible cases:\n+///\n+/// * Current directory does not exist.\n+/// * There are insufficient permissions to access the current directory.\n+/// * The internal buffer is not large enough to hold the path.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// // We assume that we are in a valid directory.\n+/// let p = env::current_dir().unwrap();\n+/// println!(\"The current directory is {}\", p.display());\n+/// ```\n+pub fn current_dir() -> IoResult<Path> {\n+    os_imp::getcwd()\n+}\n+\n+/// Changes the current working directory to the specified path, returning\n+/// whether the change was completed successfully or not.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+/// use std::path::Path;\n+///\n+/// let root = Path::new(\"/\");\n+/// assert!(env::set_current_dir(&root).is_ok());\n+/// println!(\"Successfully changed working directory to {}!\", root.display());\n+/// ```\n+pub fn set_current_dir(p: &Path) -> IoResult<()> {\n+    os_imp::chdir(p)\n+}\n+\n+static ENV_LOCK: StaticMutex = MUTEX_INIT;\n+\n+/// An iterator over a snapshot of the environment variables of this process.\n+///\n+/// This iterator is created through `std::env::vars()` and yields `(OsString,\n+/// OsString)` pairs.\n+pub struct Vars { inner: os_imp::Env }\n+\n+/// Returns an iterator of (variable, value) pairs, for all the environment\n+/// variables of the current process.\n+///\n+/// The returned iterator contains a snapshot of the process's environment\n+/// variables at the time of this invocation, modifications to environment\n+/// variables afterwards will not be reflected in the returned iterator.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// // We will iterate through the references to the element returned by\n+/// // env::vars();\n+/// for (key, value) in env::vars() {\n+///     println!(\"{:?}: {:?}\", key, value);\n+/// }\n+/// ```\n+pub fn vars() -> Vars {\n+    let _g = ENV_LOCK.lock();\n+    Vars { inner: os_imp::env() }\n+}\n+\n+impl Iterator for Vars {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+\n+/// Fetches the environment variable `key` from the current process, returning\n+/// None if the variable isn't set.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// let key = \"HOME\";\n+/// match env::var(key) {\n+///     Some(val) => println!(\"{}: {:?}\", key, val),\n+///     None => println!(\"{} is not defined in the environment.\", key)\n+/// }\n+/// ```\n+pub fn var<K: ?Sized>(key: &K) -> Option<OsString> where K: AsOsStr {\n+    let _g = ENV_LOCK.lock();\n+    os_imp::getenv(key.as_os_str())\n+}\n+\n+/// Fetches the environment variable `key` from the current process.\n+///\n+/// The returned result is `Ok(s)` if the environment variable is present and is\n+/// valid unicode. If the environment variable is not present, or it is not\n+/// valid unicode, then `Err` will be returned.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// let key = \"HOME\";\n+/// match env::var_string(key) {\n+///     Ok(val) => println!(\"{}: {:?}\", key, val),\n+///     Err(e) => println!(\"couldn't interpret {}: {}\", key, e),\n+/// }\n+/// ```\n+pub fn var_string<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr {\n+    match var(key) {\n+        Some(s) => s.into_string().map_err(VarError::NotUnicode),\n+        None => Err(VarError::NotPresent)\n+    }\n+}\n+\n+/// Possible errors from the `env::var` method.\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum VarError {\n+    /// The specified environment variable was not present in the current\n+    /// process's environment.\n+    NotPresent,\n+\n+    /// The specified environment variable was found, but it did not contain\n+    /// valid unicode data. The found data is returned as a payload of this\n+    /// variant.\n+    NotUnicode(OsString),\n+}\n+\n+impl fmt::Display for VarError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            VarError::NotPresent => write!(f, \"environment variable not found\"),\n+            VarError::NotUnicode(ref s) => {\n+                write!(f, \"environment variable was not valid unicode: {:?}\", s)\n+            }\n+        }\n+    }\n+}\n+\n+impl Error for VarError {\n+    fn description(&self) -> &str {\n+        match *self {\n+            VarError::NotPresent => \"environment variable not found\",\n+            VarError::NotUnicode(..) => \"environment variable was not valid unicode\",\n+        }\n+    }\n+}\n+\n+/// Sets the environment variable `k` to the value `v` for the currently running\n+/// process.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// let key = \"KEY\";\n+/// env::set_var(key, \"VALUE\");\n+/// assert_eq!(env::var_string(key), Ok(\"VALUE\".to_string()));\n+/// ```\n+pub fn set_var<K: ?Sized, V: ?Sized>(k: &K, v: &V)\n+    where K: AsOsStr, V: AsOsStr\n+{\n+    let _g = ENV_LOCK.lock();\n+    os_imp::setenv(k.as_os_str(), v.as_os_str())\n+}\n+\n+/// Remove a variable from the environment entirely.\n+pub fn remove_var<K: ?Sized>(k: &K) where K: AsOsStr {\n+    let _g = ENV_LOCK.lock();\n+    os_imp::unsetenv(k.as_os_str())\n+}\n+\n+/// An iterator over `Path` instances for parsing an environment variable\n+/// according to platform-specific conventions.\n+///\n+/// This structure is returned from `std::env::split_paths`.\n+pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }\n+\n+/// Parses input according to platform conventions for the `PATH`\n+/// environment variable.\n+///\n+/// Returns an iterator over the paths contained in `unparsed`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// let key = \"PATH\";\n+/// match env::var(key) {\n+///     Some(paths) => {\n+///         for path in env::split_paths(&paths) {\n+///             println!(\"'{}'\", path.display());\n+///         }\n+///     }\n+///     None => println!(\"{} is not defined in the environment.\", key)\n+/// }\n+/// ```\n+pub fn split_paths<T: AsOsStr + ?Sized>(unparsed: &T) -> SplitPaths {\n+    SplitPaths { inner: os_imp::split_paths(unparsed.as_os_str()) }\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = Path;\n+    fn next(&mut self) -> Option<Path> { self.inner.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+\n+/// Error type returned from `std::env::join_paths` when paths fail to be\n+/// joined.\n+#[derive(Debug)]\n+pub struct JoinPathsError {\n+    inner: os_imp::JoinPathsError\n+}\n+\n+/// Joins a collection of `Path`s appropriately for the `PATH`\n+/// environment variable.\n+///\n+/// Returns an `OsString` on success.\n+///\n+/// Returns an `Err` (containing an error message) if one of the input\n+/// `Path`s contains an invalid character for constructing the `PATH`\n+/// variable (a double quote on Windows or a colon on Unix).\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// if let Some(path) = env::var(\"PATH\") {\n+///     let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n+///     paths.push(Path::new(\"/home/xyz/bin\"));\n+///     let new_path = env::join_paths(paths.iter()).unwrap();\n+///     env::set_var(\"PATH\", &new_path);\n+/// }\n+/// ```\n+pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsOsStr\n+{\n+    os_imp::join_paths(paths).map_err(|e| {\n+        JoinPathsError { inner: e }\n+    })\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.inner.fmt(f)\n+    }\n+}\n+\n+impl Error for JoinPathsError {\n+    fn description(&self) -> &str { self.inner.description() }\n+}\n+\n+/// Optionally returns the path to the current user's home directory if known.\n+///\n+/// # Unix\n+///\n+/// Returns the value of the 'HOME' environment variable if it is set\n+/// and not equal to the empty string.\n+///\n+/// # Windows\n+///\n+/// Returns the value of the 'HOME' environment variable if it is\n+/// set and not equal to the empty string. Otherwise, returns the value of the\n+/// 'USERPROFILE' environment variable if it is set and not equal to the empty\n+/// string.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// match env::home_dir() {\n+///     Some(ref p) => println!(\"{}\", p.display()),\n+///     None => println!(\"Impossible to get your home dir!\")\n+/// }\n+/// ```\n+pub fn home_dir() -> Option<Path> {\n+    os_imp::home_dir()\n+}\n+\n+/// Returns the path to a temporary directory.\n+///\n+/// On Unix, returns the value of the 'TMPDIR' environment variable if it is\n+/// set, otherwise for non-Android it returns '/tmp'. If Android, since there\n+/// is no global temporary folder (it is usually allocated per-app), we return\n+/// '/data/local/tmp'.\n+///\n+/// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n+/// 'USERPROFILE' environment variable  if any are set and not the empty\n+/// string. Otherwise, tmpdir returns the path to the Windows directory.\n+pub fn temp_dir() -> Path {\n+    os_imp::temp_dir()\n+}\n+\n+/// Optionally returns the filesystem path to the current executable which is\n+/// running but with the executable name.\n+///\n+/// The path returned is not necessarily a \"real path\" to the executable as\n+/// there may be intermediate symlinks.\n+///\n+/// # Errors\n+///\n+/// Acquring the path to the current executable is a platform-specific operation\n+/// that can fail for a good number of reasons. Some errors can include, but not\n+/// be limited to filesystem operations failing or general syscall failures.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// match env::current_exe() {\n+///     Ok(exe_path) => println!(\"Path of this executable is: {}\",\n+///                               exe_path.display()),\n+///     Err(e) => println!(\"failed to get current exe path: {}\", e),\n+/// };\n+/// ```\n+pub fn current_exe() -> IoResult<Path> {\n+    os_imp::current_exe()\n+}\n+\n+static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n+\n+/// Sets the process exit code\n+///\n+/// Sets the exit code returned by the process if all supervised tasks\n+/// terminate successfully (without panicking). If the current root task panics\n+/// and is supervised by the scheduler then any user-specified exit status is\n+/// ignored and the process exits with the default panic status.\n+///\n+/// Note that this is not synchronized against modifications of other threads.\n+pub fn set_exit_status(code: i32) {\n+    EXIT_STATUS.store(code as isize, Ordering::SeqCst)\n+}\n+\n+/// Fetches the process's current exit code. This defaults to 0 and can change\n+/// by calling `set_exit_status`.\n+pub fn get_exit_status() -> i32 {\n+    EXIT_STATUS.load(Ordering::SeqCst) as i32\n+}\n+\n+/// An iterator over the arguments of a process, yielding an `OsString` value\n+/// for each argument.\n+///\n+/// This structure is created through the `std::env::args` method.\n+pub struct Args { inner: os_imp::Args }\n+\n+/// Returns the arguments which this program was started with (normally passed\n+/// via the command line).\n+///\n+/// The first element is traditionally the path to the executable, but it can be\n+/// set to arbitrary text, and it may not even exist, so this property should\n+/// not be relied upon for security purposes.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// // Prints each argument on a separate line\n+/// for argument in env::args() {\n+///     println!(\"{:?}\", argument);\n+/// }\n+/// ```\n+pub fn args() -> Args {\n+    Args { inner: os_imp::args() }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.inner.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+\n+/// Returns the page size of the current architecture in bytes.\n+pub fn page_size() -> usize {\n+    os_imp::page_size()\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"linux\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `linux`.\n+    pub const OS: &'static str = \"linux\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"macos\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `macos`.\n+    pub const OS: &'static str = \"macos\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.dylib`.\n+    pub const DLL_SUFFIX: &'static str = \".dylib\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `dylib`.\n+    pub const DLL_EXTENSION: &'static str = \"dylib\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"ios\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `ios`.\n+    pub const OS: &'static str = \"ios\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"freebsd\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `freebsd`.\n+    pub const OS: &'static str = \"freebsd\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"dragonfly\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `dragonfly`.\n+    pub const OS: &'static str = \"dragonfly\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"android\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `android`.\n+    pub const OS: &'static str = \"android\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"windows\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"windows\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `windows`.\n+    pub const OS: &'static str = \"windows\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, the empty string.\n+    pub const DLL_PREFIX: &'static str = \"\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.dll`.\n+    pub const DLL_SUFFIX: &'static str = \".dll\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `dll`.\n+    pub const DLL_EXTENSION: &'static str = \"dll\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, `.exe`.\n+    pub const EXE_SUFFIX: &'static str = \".exe\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, `exe`.\n+    pub const EXE_EXTENSION: &'static str = \"exe\";\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"x86\";\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"x86_64\";\n+}\n+\n+#[cfg(target_arch = \"arm\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"arm\";\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"aarch64\";\n+}\n+\n+#[cfg(target_arch = \"mips\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"mips\";\n+}\n+\n+#[cfg(target_arch = \"mipsel\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"mipsel\";\n+}\n+\n+#[cfg(target_arch = \"powerpc\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"powerpc\";\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use super::*;\n+    use iter::repeat;\n+    use rand::{self, Rng};\n+    use ffi::{OsString, OsStr};\n+\n+    fn make_rand_name() -> OsString {\n+        let mut rng = rand::thread_rng();\n+        let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10)\n+                                     .collect::<String>());\n+        let n = OsString::from_string(n);\n+        assert!(var(&n).is_none());\n+        n\n+    }\n+\n+    fn eq(a: Option<OsString>, b: Option<&str>) {\n+        assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::from_str).map(|s| &*s));\n+    }\n+\n+    #[test]\n+    fn test_set_var() {\n+        let n = make_rand_name();\n+        set_var(&n, \"VALUE\");\n+        eq(var(&n), Some(\"VALUE\"));\n+    }\n+\n+    #[test]\n+    fn test_remove_var() {\n+        let n = make_rand_name();\n+        set_var(&n, \"VALUE\");\n+        remove_var(&n);\n+        eq(var(&n), None);\n+    }\n+\n+    #[test]\n+    fn test_set_var_overwrite() {\n+        let n = make_rand_name();\n+        set_var(&n, \"1\");\n+        set_var(&n, \"2\");\n+        eq(var(&n), Some(\"2\"));\n+        set_var(&n, \"\");\n+        eq(var(&n), Some(\"\"));\n+    }\n+\n+    #[test]\n+    fn test_var_big() {\n+        let mut s = \"\".to_string();\n+        let mut i = 0;\n+        while i < 100 {\n+            s.push_str(\"aaaaaaaaaa\");\n+            i += 1;\n+        }\n+        let n = make_rand_name();\n+        set_var(&n, s.as_slice());\n+        eq(var(&n), Some(s.as_slice()));\n+    }\n+\n+    #[test]\n+    fn test_self_exe_path() {\n+        let path = current_exe();\n+        assert!(path.is_ok());\n+        let path = path.unwrap();\n+\n+        // Hard to test this function\n+        assert!(path.is_absolute());\n+    }\n+\n+    #[test]\n+    fn test_env_set_get_huge() {\n+        let n = make_rand_name();\n+        let s = repeat(\"x\").take(10000).collect::<String>();\n+        set_var(&n, &s);\n+        eq(var(&n), Some(s.as_slice()));\n+        remove_var(&n);\n+        eq(var(&n), None);\n+    }\n+\n+    #[test]\n+    fn test_env_set_var() {\n+        let n = make_rand_name();\n+\n+        let mut e = vars();\n+        set_var(&n, \"VALUE\");\n+        assert!(!e.any(|(k, v)| {\n+            &*k == &*n && &*v == \"VALUE\"\n+        }));\n+\n+        assert!(vars().any(|(k, v)| {\n+            &*k == &*n && &*v == \"VALUE\"\n+        }));\n+    }\n+\n+    #[test]\n+    fn test() {\n+        assert!((!Path::new(\"test-path\").is_absolute()));\n+\n+        current_dir().unwrap();\n+    }\n+\n+    #[test]\n+    #[cfg(windows)]\n+    fn split_paths_windows() {\n+        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+            split_paths(unparsed).collect::<Vec<_>>() ==\n+                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n+        }\n+\n+        assert!(check_parse(\"\", &mut [\"\"]));\n+        assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n+        assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n+        assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n+        assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n+        assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n+                            &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n+        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n+        assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n+                            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n+    }\n+\n+    #[test]\n+    #[cfg(unix)]\n+    fn split_paths_unix() {\n+        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+            split_paths(unparsed).collect::<Vec<_>>() ==\n+                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n+        }\n+\n+        assert!(check_parse(\"\", &mut [\"\"]));\n+        assert!(check_parse(\"::\", &mut [\"\", \"\", \"\"]));\n+        assert!(check_parse(\"/\", &mut [\"/\"]));\n+        assert!(check_parse(\"/:\", &mut [\"/\", \"\"]));\n+        assert!(check_parse(\"/:/usr/local\", &mut [\"/\", \"/usr/local\"]));\n+    }\n+\n+    #[test]\n+    #[cfg(unix)]\n+    fn join_paths_unix() {\n+        fn test_eq(input: &[&str], output: &str) -> bool {\n+            &*join_paths(input.iter().map(|s| *s)).unwrap() ==\n+                OsStr::from_str(output)\n+        }\n+\n+        assert!(test_eq(&[], \"\"));\n+        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n+                         \"/bin:/usr/bin:/usr/local/bin\"));\n+        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n+                         \":/bin:::/usr/bin:\"));\n+        assert!(join_paths([\"/te:st\"].iter().map(|s| *s)).is_err());\n+    }\n+\n+    #[test]\n+    #[cfg(windows)]\n+    fn join_paths_windows() {\n+        fn test_eq(input: &[&str], output: &str) -> bool {\n+            &*join_paths(input.iter().map(|s| *s)).unwrap() ==\n+                OsStr::from_str(output)\n+        }\n+\n+        assert!(test_eq(&[], \"\"));\n+        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"],\n+                        r\"c:\\windows;c:\\\"));\n+        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"],\n+                        r\";c:\\windows;;;c:\\;\"));\n+        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"],\n+                        r#\"\"c:\\te;st\";c:\\\"#));\n+        assert!(join_paths([r#\"c:\\te\"st\"#].iter().map(|s| *s)).is_err());\n+    }\n+    }"}, {"sha": "76f925a23f17412e3cd4bac2a6a707ccadc9caa3", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -20,7 +20,12 @@ pub use self::c_str::c_str_to_bytes_with_nul;\n \n pub use self::os_str::OsString;\n pub use self::os_str::OsStr;\n-pub use self::os_str::AsOsStr;\n \n mod c_str;\n mod os_str;\n+\n+/// Freely convertible to an `&OsStr` slice.\n+pub trait AsOsStr {\n+    /// Convert to an `&OsStr` slice.\n+    fn as_os_str(&self) -> &OsStr;\n+}"}, {"sha": "b8d770e6ad694e12734ac08d4c606b77ebdd0001", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 82, "deletions": 15, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -41,9 +41,11 @@ use string::{String, CowString};\n use ops;\n use cmp;\n use hash::{Hash, Hasher, Writer};\n+use path::{Path, GenericPath};\n \n use sys::os_str::{Buf, Slice};\n use sys_common::{AsInner, IntoInner, FromInner};\n+use super::AsOsStr;\n \n /// Owned, mutable OS strings.\n #[derive(Clone)]\n@@ -69,6 +71,11 @@ impl OsString {\n         OsString { inner: Buf::from_str(s) }\n     }\n \n+    /// Constructs a new empty `OsString`.\n+    pub fn new() -> OsString {\n+        OsString { inner: Buf::from_string(String::new()) }\n+    }\n+\n     /// Convert the `OsString` into a `String` if it contains valid Unicode data.\n     ///\n     /// On failure, ownership of the original `OsString` is returned.\n@@ -82,17 +89,6 @@ impl OsString {\n     }\n }\n \n-#[cfg(stage0)]\n-impl ops::Index<ops::FullRange> for OsString {\n-    type Output = OsStr;\n-\n-    #[inline]\n-    fn index(&self, _index: &ops::FullRange) -> &OsStr {\n-        unsafe { mem::transmute(self.inner.as_slice()) }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl ops::Index<ops::RangeFull> for OsString {\n     type Output = OsStr;\n \n@@ -117,6 +113,62 @@ impl Debug for OsString {\n     }\n }\n \n+impl PartialEq for OsString {\n+    fn eq(&self, other: &OsString) -> bool {\n+        &**self == &**other\n+    }\n+}\n+\n+impl PartialEq<str> for OsString {\n+    fn eq(&self, other: &str) -> bool {\n+        &**self == other\n+    }\n+}\n+\n+impl PartialEq<OsString> for str {\n+    fn eq(&self, other: &OsString) -> bool {\n+        &**other == self\n+    }\n+}\n+\n+impl Eq for OsString {}\n+\n+impl PartialOrd for OsString {\n+    #[inline]\n+    fn partial_cmp(&self, other: &OsString) -> Option<cmp::Ordering> {\n+        (&**self).partial_cmp(&**other)\n+    }\n+    #[inline]\n+    fn lt(&self, other: &OsString) -> bool { &**self < &**other }\n+    #[inline]\n+    fn le(&self, other: &OsString) -> bool { &**self <= &**other }\n+    #[inline]\n+    fn gt(&self, other: &OsString) -> bool { &**self > &**other }\n+    #[inline]\n+    fn ge(&self, other: &OsString) -> bool { &**self >= &**other }\n+}\n+\n+impl PartialOrd<str> for OsString {\n+    #[inline]\n+    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n+        (&**self).partial_cmp(other)\n+    }\n+}\n+\n+impl Ord for OsString {\n+    #[inline]\n+    fn cmp(&self, other: &OsString) -> cmp::Ordering {\n+        (&**self).cmp(&**other)\n+    }\n+}\n+\n+impl<'a, S: Hasher + Writer> Hash<S> for OsString {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (&**self).hash(state)\n+    }\n+}\n+\n impl OsStr {\n     /// Coerce directly from a `&str` slice to a `&OsStr` slice.\n     pub fn from_str(s: &str) -> &OsStr {\n@@ -222,10 +274,10 @@ impl ToOwned<OsString> for OsStr {\n     fn to_owned(&self) -> OsString { self.to_os_string() }\n }\n \n-/// Freely convertible to an `&OsStr` slice.\n-pub trait AsOsStr {\n-    /// Convert to an `&OsStr` slice.\n-    fn as_os_str(&self) -> &OsStr;\n+impl<'a, T: AsOsStr + ?Sized> AsOsStr for &'a T {\n+    fn as_os_str(&self) -> &OsStr {\n+        (*self).as_os_str()\n+    }\n }\n \n impl AsOsStr for OsStr {\n@@ -252,6 +304,21 @@ impl AsOsStr for String {\n     }\n }\n \n+#[cfg(unix)]\n+impl AsOsStr for Path {\n+    fn as_os_str(&self) -> &OsStr {\n+        unsafe { mem::transmute(self.as_vec()) }\n+    }\n+}\n+\n+#[cfg(windows)]\n+impl AsOsStr for Path {\n+    fn as_os_str(&self) -> &OsStr {\n+        // currently .as_str() is actually infallible on windows\n+        OsStr::from_str(self.as_str().unwrap())\n+    }\n+}\n+\n impl FromInner<Buf> for OsString {\n     fn from_inner(buf: Buf) -> OsString {\n         OsString { inner: buf }"}, {"sha": "47f5d64e2607cb11a024c488bb9a0c5f4137fa34", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -413,10 +413,6 @@ pub use core::fmt::{LowerExp, UpperExp};\n pub use core::fmt::Error;\n pub use core::fmt::{ArgumentV1, Arguments, write, radix, Radix, RadixFmt};\n \n-#[doc(hidden)]\n-#[cfg(stage0)]\n-pub use core::fmt::{argument, argumentuint};\n-\n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///"}, {"sha": "839983d336d765e819cde518e8432b1c60731b4b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -120,14 +120,13 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![cfg_attr(not(stage0), feature(macro_reexport))]\n+#![feature(macro_reexport)]\n #![cfg_attr(test, feature(test))]\n \n // Don't link to std. We are std.\n #![no_std]\n \n #![deny(missing_docs)]\n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n \n #[cfg(test)]\n #[macro_use]\n@@ -250,6 +249,7 @@ pub mod ffi;\n pub mod fmt;\n pub mod old_io;\n pub mod os;\n+pub mod env;\n pub mod path;\n pub mod rand;\n pub mod time;"}, {"sha": "d729c2800ce13c3c134206866b219468fe0155e6", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -406,12 +406,12 @@ mod test {\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n \n         let mut writer = Vec::new();\n-        for i in uints.iter() {\n+        for i in &uints {\n             writer.write_le_u64(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer);\n-        for i in uints.iter() {\n+        for i in &uints {\n             assert!(reader.read_le_u64().unwrap() == *i);\n         }\n     }\n@@ -422,12 +422,12 @@ mod test {\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n \n         let mut writer = Vec::new();\n-        for i in uints.iter() {\n+        for i in &uints {\n             writer.write_be_u64(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer);\n-        for i in uints.iter() {\n+        for i in &uints {\n             assert!(reader.read_be_u64().unwrap() == *i);\n         }\n     }\n@@ -437,12 +437,12 @@ mod test {\n         let ints = [::i32::MIN, -123456, -42, -5, 0, 1, ::i32::MAX];\n \n         let mut writer = Vec::new();\n-        for i in ints.iter() {\n+        for i in &ints {\n             writer.write_be_i32(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer);\n-        for i in ints.iter() {\n+        for i in &ints {\n             // this tests that the sign extension is working\n             // (comparing the values as i32 would not test this)\n             assert!(reader.read_be_int_n(4).unwrap() == *i as i64);"}, {"sha": "abf215988bb4b859982967ee3dda5ceeb3294d65", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -597,7 +597,7 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n         return Ok(())\n     }\n \n-    let mut comps = path.components();\n+    let comps = path.components();\n     let mut curpath = path.root_path().unwrap_or(Path::new(\".\"));\n \n     for c in comps {\n@@ -649,7 +649,7 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n \n         // delete all regular files in the way and push subdirs\n         // on the stack\n-        for child in children.into_iter() {\n+        for child in children {\n             // FIXME(#12795) we should use lstat in all cases\n             let child_type = match cfg!(windows) {\n                 true => try!(update_err(stat(&child), path)),\n@@ -1110,7 +1110,7 @@ mod test {\n         }\n         let files = check!(readdir(dir));\n         let mut mem = [0u8; 4];\n-        for f in files.iter() {\n+        for f in &files {\n             {\n                 let n = f.filestem_str();\n                 check!(File::open(f).read(&mut mem));"}, {"sha": "2b7506b5c34a3f6edef804b3d0cf4abf30d29c0a", "filename": "src/libstd/old_io/net/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -121,7 +121,7 @@ mod test {\n         let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n         let mut found_local = false;\n         let local_addr = &Ipv4Addr(127, 0, 0, 1);\n-        for addr in ipaddrs.iter() {\n+        for addr in &ipaddrs {\n             found_local = found_local || addr == local_addr;\n         }\n         assert!(found_local);"}, {"sha": "d85251795c887d254af8c696f8e57f9a2c9e5fb4", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n     // Return result of first successful parser\n     fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])\n                -> Option<T> {\n-        for pf in parsers.iter_mut() {\n+        for pf in parsers {\n             match self.read_atomically(|p: &mut Parser| pf.call_mut((p,))) {\n                 Some(r) => return Some(r),\n                 None => {}"}, {"sha": "bbe3a71dcc0d17a12057884758c81e22de430900", "filename": "src/libstd/old_io/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -36,7 +36,7 @@ fn with_addresses<A, T, F>(addr: A, mut action: F) -> IoResult<T> where\n \n     let addresses = try!(addr.to_socket_addr_all());\n     let mut err = DEFAULT_ERROR;\n-    for addr in addresses.into_iter() {\n+    for addr in addresses {\n         match action(addr) {\n             Ok(r) => return Ok(r),\n             Err(e) => err = e"}, {"sha": "61a07bc8208eda35ffc5b3a96b6e329943e621d9", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -231,6 +231,7 @@ impl Command {\n         self\n     }\n     // Get a mutable borrow of the environment variable map for this `Command`.\n+    #[allow(deprecated)]\n     fn get_env_map<'a>(&'a mut self) -> &'a mut EnvMap {\n         match self.env {\n             Some(ref mut map) => map,\n@@ -400,7 +401,7 @@ impl fmt::Debug for Command {\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{:?}\", self.program));\n-        for arg in self.args.iter() {\n+        for arg in &self.args {\n             try!(write!(f, \" '{:?}'\", arg));\n         }\n         Ok(())\n@@ -1045,7 +1046,7 @@ mod tests {\n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n         let r = os::env();\n-        for &(ref k, ref v) in r.iter() {\n+        for &(ref k, ref v) in &r {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() ||\n                     output.contains(format!(\"{}={}\", *k, *v).as_slice()),\n@@ -1063,7 +1064,7 @@ mod tests {\n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n         let r = os::env();\n-        for &(ref k, ref v) in r.iter() {\n+        for &(ref k, ref v) in &r {\n             // don't check android RANDOM variables\n             if *k != \"RANDOM\".to_string() {\n                 assert!(output.contains(format!(\"{}={}\","}, {"sha": "83a42549424d698dabee5242ff2075df1c04ceb0", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -10,13 +10,13 @@\n \n //! Temporary files and directories\n \n+use env;\n+use iter::{IteratorExt};\n use old_io::{fs, IoError, IoErrorKind, IoResult};\n use old_io;\n-use iter::IteratorExt;\n use ops::Drop;\n-use option::Option;\n use option::Option::{None, Some};\n-use os;\n+use option::Option;\n use path::{Path, GenericPath};\n use rand::{Rng, thread_rng};\n use result::Result::{Ok, Err};\n@@ -97,8 +97,8 @@ impl TempDir {\n     /// If no directory can be created, `Err` is returned.\n     pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n         if !tmpdir.is_absolute() {\n-            let abs_tmpdir = try!(os::make_absolute(tmpdir));\n-            return TempDir::new_in(&abs_tmpdir, prefix);\n+            let cur_dir = try!(env::current_dir());\n+            return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n         }\n \n         let mut rng = thread_rng();\n@@ -132,7 +132,7 @@ impl TempDir {\n     ///\n     /// If no directory can be created, `Err` is returned.\n     pub fn new(prefix: &str) -> IoResult<TempDir> {\n-        TempDir::new_in(&os::tmpdir(), prefix)\n+        TempDir::new_in(&env::temp_dir(), prefix)\n     }\n \n     /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper."}, {"sha": "ee72beccfa8488f61fa0f997809ea11b8bc8c3fa", "filename": "src/libstd/old_io/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -12,8 +12,8 @@\n \n use prelude::v1::*;\n \n+use env;\n use libc;\n-use os;\n use std::old_io::net::ip::*;\n use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n@@ -41,7 +41,7 @@ fn next_test_unix_socket() -> String {\n pub fn next_test_unix() -> Path {\n     let string = next_test_unix_socket();\n     if cfg!(unix) {\n-        os::tmpdir().join(string)\n+        env::temp_dir().join(string)\n     } else {\n         Path::new(format!(\"{}{}\", r\"\\\\.\\pipe\\\", string))\n     }\n@@ -87,12 +87,12 @@ fn base_port() -> u16 {\n     ];\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let path = os::getcwd().unwrap();\n+    let path = env::current_dir().unwrap();\n     let path_s = path.as_str().unwrap();\n \n     let mut final_base = base;\n \n-    for &(dir, base) in bases.iter() {\n+    for &(dir, base) in &bases {\n         if path_s.contains(dir) {\n             final_base = base;\n             break;"}, {"sha": "f78e3ac1f14dad01c1a2a4583b01026c70cf8b9d", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -144,15 +144,15 @@ impl<W> MultiWriter<W> where W: Writer {\n impl<W> Writer for MultiWriter<W> where W: Writer {\n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> old_io::IoResult<()> {\n-        for writer in self.writers.iter_mut() {\n+        for writer in &mut self.writers {\n             try!(writer.write_all(buf));\n         }\n         Ok(())\n     }\n \n     #[inline]\n     fn flush(&mut self) -> old_io::IoResult<()> {\n-        for writer in self.writers.iter_mut() {\n+        for writer in &mut self.writers {\n             try!(writer.flush());\n         }\n         Ok(())"}, {"sha": "d92f361af0bf24508fe18e9e4b11d5ed30aa5299", "filename": "src/libstd/os.rs", "status": "modified", "additions": 145, "deletions": 148, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -34,29 +34,32 @@ use self::MemoryMapKind::*;\n use self::MapOption::*;\n use self::MapError::*;\n \n+use boxed::Box;\n use clone::Clone;\n+use env;\n use error::{FromError, Error};\n+use ffi::{OsString, OsStr};\n use fmt;\n-use old_io::{IoResult, IoError};\n use iter::{Iterator, IteratorExt};\n-use marker::{Copy, Send};\n use libc::{c_void, c_int, c_char};\n use libc;\n-use boxed::Box;\n+use marker::{Copy, Send};\n+use old_io::{IoResult, IoError};\n use ops::{Drop, FnOnce};\n-use option::Option;\n use option::Option::{Some, None};\n+use option::Option;\n use path::{Path, GenericPath, BytesContainer};\n-use sys;\n-use sys::os as os_imp;\n use ptr::PtrExt;\n use ptr;\n-use result::Result;\n use result::Result::{Err, Ok};\n+use result::Result;\n use slice::{AsSlice, SliceExt};\n use str::{Str, StrExt};\n+use str;\n use string::{String, ToString};\n use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n+use sys::os as os_imp;\n+use sys;\n use vec::Vec;\n \n #[cfg(unix)] use ffi::{self, CString};\n@@ -97,23 +100,10 @@ pub const TMPBUF_SZ : uint = 1000u;\n /// let current_working_directory = os::getcwd().unwrap();\n /// println!(\"The current directory is {:?}\", current_working_directory.display());\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to std::env::current_dir\")]\n+#[unstable(feature = \"os\")]\n pub fn getcwd() -> IoResult<Path> {\n-    sys::os::getcwd()\n-}\n-\n-/*\n-Accessing environment variables is not generally threadsafe.\n-Serialize access through a global lock.\n-*/\n-fn with_env_lock<T, F>(f: F) -> T where\n-    F: FnOnce() -> T,\n-{\n-    use sync::{StaticMutex, MUTEX_INIT};\n-\n-    static LOCK: StaticMutex = MUTEX_INIT;\n-\n-    let _guard = LOCK.lock();\n-    f()\n+    env::current_dir()\n }\n \n /// Returns a vector of (variable, value) pairs, for all the environment\n@@ -132,37 +122,22 @@ fn with_env_lock<T, F>(f: F) -> T where\n ///     println!(\"'{}': '{}'\", key, value );\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"use env::vars instead\")]\n+#[unstable(feature = \"os\")]\n pub fn env() -> Vec<(String,String)> {\n-    env_as_bytes().into_iter().map(|(k,v)| {\n-        let k = String::from_utf8_lossy(k.as_slice()).into_owned();\n-        let v = String::from_utf8_lossy(v.as_slice()).into_owned();\n-        (k,v)\n+    env::vars().map(|(k, v)| {\n+        (k.to_string_lossy().into_owned(), v.to_string_lossy().into_owned())\n     }).collect()\n }\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n-pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n-    unsafe {\n-        fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n-            let mut pairs = Vec::new();\n-            for p in input.iter() {\n-                let mut it = p.splitn(1, |b| *b == b'=');\n-                let key = it.next().unwrap().to_vec();\n-                let default: &[u8] = &[];\n-                let val = it.next().unwrap_or(default).to_vec();\n-                pairs.push((key, val));\n-            }\n-            pairs\n-        }\n-        with_env_lock(|| {\n-            let unparsed_environ = sys::os::get_env_pairs();\n-            env_convert(unparsed_environ)\n-        })\n-    }\n+#[deprecated(since = \"1.0.0\", reason = \"use env::vars instead\")]\n+#[unstable(feature = \"os\")]\n+pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n+    env::vars().map(|(k, v)| (byteify(k), byteify(v))).collect()\n }\n \n-#[cfg(unix)]\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n ///\n@@ -184,52 +159,32 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"use env::var or env::var_string instead\")]\n+#[unstable(feature = \"os\")]\n pub fn getenv(n: &str) -> Option<String> {\n-    getenv_as_bytes(n).map(|v| String::from_utf8_lossy(v.as_slice()).into_owned())\n+    env::var_string(n).ok()\n }\n \n-#[cfg(unix)]\n /// Fetches the environment variable `n` byte vector from the current process,\n /// returning None if the variable isn't set.\n ///\n /// # Panics\n ///\n /// Panics if `n` has any interior NULs.\n+#[deprecated(since = \"1.0.0\", reason = \"use env::var instead\")]\n+#[unstable(feature = \"os\")]\n pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n-    unsafe {\n-        with_env_lock(|| {\n-            let s = CString::from_slice(n.as_bytes());\n-            let s = libc::getenv(s.as_ptr()) as *const _;\n-            if s.is_null() {\n-                None\n-            } else {\n-                Some(ffi::c_str_to_bytes(&s).to_vec())\n-            }\n-        })\n-    }\n+    env::var(n).map(byteify)\n }\n \n-#[cfg(windows)]\n-/// Fetches the environment variable `n` from the current process, returning\n-/// None if the variable isn't set.\n-pub fn getenv(n: &str) -> Option<String> {\n-    unsafe {\n-        with_env_lock(|| {\n-            use sys::os::fill_utf16_buf_and_decode;\n-            let mut n: Vec<u16> = n.utf16_units().collect();\n-            n.push(0);\n-            fill_utf16_buf_and_decode(|buf, sz| {\n-                libc::GetEnvironmentVariableW(n.as_ptr(), buf, sz)\n-            })\n-        })\n-    }\n+#[cfg(unix)]\n+fn byteify(s: OsString) -> Vec<u8> {\n+    use os::unix::*;\n+    s.into_vec()\n }\n-\n #[cfg(windows)]\n-/// Fetches the environment variable `n` byte vector from the current process,\n-/// returning None if the variable isn't set.\n-pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n-    getenv(n).map(|s| s.into_bytes())\n+fn byteify(s: OsString) -> Vec<u8> {\n+    s.to_string_lossy().as_bytes().to_vec()\n }\n \n /// Sets the environment variable `n` to the value `v` for the currently running\n@@ -247,68 +202,30 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_var\")]\n+#[unstable(feature = \"os\")]\n pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n     #[cfg(unix)]\n     fn _setenv(n: &str, v: &[u8]) {\n-        unsafe {\n-            with_env_lock(|| {\n-                let k = CString::from_slice(n.as_bytes());\n-                let v = CString::from_slice(v);\n-                if libc::funcs::posix01::unistd::setenv(k.as_ptr(),\n-                                                        v.as_ptr(), 1) != 0 {\n-                    panic!(IoError::last_error());\n-                }\n-            })\n-        }\n+        use os::unix::*;\n+        let v: OsString = OsStringExt::from_vec(v.to_vec());\n+        env::set_var(n, &v)\n     }\n \n     #[cfg(windows)]\n     fn _setenv(n: &str, v: &[u8]) {\n-        let mut n: Vec<u16> = n.utf16_units().collect();\n-        n.push(0);\n-        let mut v: Vec<u16> = ::str::from_utf8(v).unwrap().utf16_units().collect();\n-        v.push(0);\n-\n-        unsafe {\n-            with_env_lock(|| {\n-                if libc::SetEnvironmentVariableW(n.as_ptr(), v.as_ptr()) == 0 {\n-                    panic!(IoError::last_error());\n-                }\n-            })\n-        }\n+        let v = str::from_utf8(v).unwrap();\n+        env::set_var(n, v)\n     }\n \n     _setenv(n, v.container_as_bytes())\n }\n \n /// Remove a variable from the environment entirely.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::remove_var\")]\n+#[unstable(feature = \"os\")]\n pub fn unsetenv(n: &str) {\n-    #[cfg(unix)]\n-    fn _unsetenv(n: &str) {\n-        unsafe {\n-            with_env_lock(|| {\n-                let nbuf = CString::from_slice(n.as_bytes());\n-                if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n-                    panic!(IoError::last_error());\n-                }\n-            })\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn _unsetenv(n: &str) {\n-        let mut n: Vec<u16> = n.utf16_units().collect();\n-        n.push(0);\n-        unsafe {\n-            with_env_lock(|| {\n-                if libc::SetEnvironmentVariableW(n.as_ptr(), ptr::null()) == 0 {\n-                    panic!(IoError::last_error());\n-                }\n-            })\n-        }\n-    }\n-\n-    _unsetenv(n)\n+    env::remove_var(n)\n }\n \n /// Parses input according to platform conventions for the `PATH`\n@@ -328,8 +245,12 @@ pub fn unsetenv(n: &str) {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::split_paths\")]\n+#[unstable(feature = \"os\")]\n pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    sys::os::split_paths(unparsed.container_as_bytes())\n+    let b = unparsed.container_as_bytes();\n+    let s = str::from_utf8(b).unwrap();\n+    env::split_paths(s).collect()\n }\n \n /// Joins a collection of `Path`s appropriately for the `PATH`\n@@ -353,8 +274,14 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n /// paths.push(Path::new(\"/home/xyz/bin\"));\n /// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::join_paths\")]\n+#[unstable(feature = \"os\")]\n pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-    sys::os::join_paths(paths)\n+    env::join_paths(paths.iter().map(|s| {\n+        str::from_utf8(s.container_as_bytes()).unwrap()\n+    })).map(|s| {\n+        s.to_string_lossy().into_owned().into_bytes()\n+    }).map_err(|_| \"failed to join paths\")\n }\n \n /// A low-level OS in-memory pipe.\n@@ -388,6 +315,8 @@ pub unsafe fn pipe() -> IoResult<Pipe> {\n /// Returns the proper dll filename for the given basename of a file\n /// as a String.\n #[cfg(not(target_os=\"ios\"))]\n+#[deprecated(since = \"1.0.0\", reason = \"this function will be removed, use the constants directly\")]\n+#[unstable(feature = \"os\")]\n pub fn dll_filename(base: &str) -> String {\n     format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n }\n@@ -405,8 +334,10 @@ pub fn dll_filename(base: &str) -> String {\n ///     None => println!(\"Unable to get the path of this executable!\")\n /// };\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::current_exe\")]\n+#[unstable(feature = \"os\")]\n pub fn self_exe_name() -> Option<Path> {\n-    sys::os::load_self().and_then(Path::new_opt)\n+    env::current_exe().ok()\n }\n \n /// Optionally returns the filesystem path to the current executable which is\n@@ -424,8 +355,10 @@ pub fn self_exe_name() -> Option<Path> {\n ///     None => println!(\"Impossible to fetch the path of this executable.\")\n /// };\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"use env::current_exe + dir_path/pop\")]\n+#[unstable(feature = \"os\")]\n pub fn self_exe_path() -> Option<Path> {\n-    self_exe_name().map(|mut p| { p.pop(); p })\n+    env::current_exe().ok().map(|mut p| { p.pop(); p })\n }\n \n /// Optionally returns the path to the current user's home directory if known.\n@@ -452,6 +385,9 @@ pub fn self_exe_path() -> Option<Path> {\n ///     None => println!(\"Impossible to get your home dir!\")\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::home_dir\")]\n+#[allow(deprecated)]\n+#[unstable(feature = \"os\")]\n pub fn homedir() -> Option<Path> {\n     #[inline]\n     #[cfg(unix)]\n@@ -487,6 +423,9 @@ pub fn homedir() -> Option<Path> {\n /// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n /// 'USERPROFILE' environment variable  if any are set and not the empty\n /// string. Otherwise, tmpdir returns the path to the Windows directory.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::temp_dir\")]\n+#[allow(deprecated)]\n+#[unstable(feature = \"os\")]\n pub fn tmpdir() -> Path {\n     return lookup();\n \n@@ -542,11 +481,13 @@ pub fn tmpdir() -> Path {\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n+#[deprecated(since = \"1.0.0\", reason = \"use env::current_dir + .join directly\")]\n+#[unstable(feature = \"os\")]\n pub fn make_absolute(p: &Path) -> IoResult<Path> {\n     if p.is_absolute() {\n         Ok(p.clone())\n     } else {\n-        getcwd().map(|mut cwd| {\n+        env::current_dir().map(|mut cwd| {\n             cwd.push(p);\n             cwd\n         })\n@@ -565,6 +506,8 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n /// assert!(os::change_dir(&root).is_ok());\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_current_dir\")]\n+#[unstable(feature = \"os\")]\n pub fn change_dir(p: &Path) -> IoResult<()> {\n     return sys::os::chdir(p);\n }\n@@ -592,8 +535,6 @@ pub fn last_os_error() -> String {\n     error_string(errno() as uint)\n }\n \n-static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n-\n /// Sets the process exit code\n ///\n /// Sets the exit code returned by the process if all supervised tasks\n@@ -602,14 +543,18 @@ static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n /// ignored and the process exits with the default panic status.\n ///\n /// Note that this is not synchronized against modifications of other threads.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_exit_status\")]\n+#[unstable(feature = \"os\")]\n pub fn set_exit_status(code: int) {\n-    EXIT_STATUS.store(code, Ordering::SeqCst)\n+    env::set_exit_status(code as i32)\n }\n \n /// Fetches the process's current exit code. This defaults to 0 and can change\n /// by calling `set_exit_status`.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::get_exit_status\")]\n+#[unstable(feature = \"os\")]\n pub fn get_exit_status() -> int {\n-    EXIT_STATUS.load(Ordering::SeqCst)\n+    env::get_exit_status() as isize\n }\n \n #[cfg(target_os = \"macos\")]\n@@ -693,7 +638,8 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n #[cfg(any(target_os = \"linux\",\n           target_os = \"android\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     use rt;\n     rt::args::clone().unwrap_or_else(|| vec![])\n@@ -726,7 +672,7 @@ fn real_args() -> Vec<String> {\n         // Push it onto the list.\n         let ptr = ptr as *const u16;\n         let buf = slice::from_raw_buf(&ptr, len);\n-        let opt_s = String::from_utf16(sys::os::truncate_utf16_at_nul(buf));\n+        let opt_s = String::from_utf16(sys::truncate_utf16_at_nul(buf));\n         opt_s.ok().expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     }).collect();\n \n@@ -777,24 +723,30 @@ extern \"system\" {\n ///     println!(\"{}\", argument);\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"use env::args instead\")]\n+#[unstable(feature = \"os\")]\n pub fn args() -> Vec<String> {\n     real_args()\n }\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line) as byte vectors.\n+#[deprecated(since = \"1.0.0\", reason = \"use env::args_raw instead\")]\n+#[unstable(feature = \"os\")]\n pub fn args_as_bytes() -> Vec<Vec<u8>> {\n     real_args_as_bytes()\n }\n \n #[cfg(target_os = \"macos\")]\n extern {\n     // These functions are in crt_externs.h.\n-    pub fn _NSGetArgc() -> *mut c_int;\n-    pub fn _NSGetArgv() -> *mut *mut *mut c_char;\n+    fn _NSGetArgc() -> *mut c_int;\n+    fn _NSGetArgv() -> *mut *mut *mut c_char;\n }\n \n /// Returns the page size of the current architecture in bytes.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::page_size\")]\n+#[unstable(feature = \"os\")]\n pub fn page_size() -> uint {\n     sys::os::page_size()\n }\n@@ -970,9 +922,9 @@ impl MemoryMap {\n         let mut fd = -1;\n         let mut offset = 0;\n         let mut custom_flags = false;\n-        let len = round_up(min_len, page_size());\n+        let len = round_up(min_len, env::page_size());\n \n-        for &o in options.iter() {\n+        for &o in options {\n             match o {\n                 MapReadable => { prot |= libc::PROT_READ; },\n                 MapWritable => { prot |= libc::PROT_WRITE; },\n@@ -1020,7 +972,7 @@ impl MemoryMap {\n     /// Granularity that the offset or address must be for `MapOffset` and\n     /// `MapAddr` respectively.\n     pub fn granularity() -> uint {\n-        page_size()\n+        env::page_size()\n     }\n }\n \n@@ -1049,9 +1001,9 @@ impl MemoryMap {\n         let mut executable = false;\n         let mut handle: HANDLE = libc::INVALID_HANDLE_VALUE;\n         let mut offset: uint = 0;\n-        let len = round_up(min_len, page_size());\n+        let len = round_up(min_len, env::page_size());\n \n-        for &o in options.iter() {\n+        for &o in options {\n             match o {\n                 MapReadable => { readable = true; },\n                 MapWritable => { writable = true; },\n@@ -1184,6 +1136,8 @@ impl MemoryMap {\n }\n \n #[cfg(target_os = \"linux\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1215,6 +1169,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"macos\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1246,6 +1202,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"ios\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1265,6 +1223,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"freebsd\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1296,6 +1256,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"dragonfly\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1326,7 +1288,40 @@ pub mod consts {\n     pub const EXE_EXTENSION: &'static str = \"\";\n }\n \n+#[cfg(target_os = \"openbsd\")]\n+pub mod consts {\n+    pub use os::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `openbsd`.\n+    pub const SYSNAME: &'static str = \"openbsd\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n #[cfg(target_os = \"android\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1358,6 +1353,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"windows\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1522,7 +1519,7 @@ mod tests {\n     fn test_env_getenv() {\n         let e = env();\n         assert!(e.len() > 0u);\n-        for p in e.iter() {\n+        for p in &e {\n             let (n, v) = (*p).clone();\n             debug!(\"{}\", n);\n             let v2 = getenv(n.as_slice());\n@@ -1577,7 +1574,7 @@ mod tests {\n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n \n-        for s in oldhome.iter() {\n+        if let Some(s) = oldhome {\n             setenv(\"HOME\", s.as_slice());\n         }\n     }\n@@ -1606,10 +1603,10 @@ mod tests {\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n         assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n \n-        for s in oldhome.iter() {\n+        if let Some(s) = oldhome {\n             setenv(\"HOME\", s.as_slice());\n         }\n-        for s in olduserprofile.iter() {\n+        if let Some(s) = olduserprofile {\n             setenv(\"USERPROFILE\", s.as_slice());\n         }\n     }"}, {"sha": "0d80258d7e04f1f3b590e30db7057f2b97bed0b9", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -68,8 +68,6 @@ use fmt;\n use iter::IteratorExt;\n use option::Option;\n use option::Option::{None, Some};\n-#[cfg(stage0)]\n-use ops::FullRange;\n use str;\n use str::StrExt;\n use string::{String, CowString};\n@@ -625,11 +623,11 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     fn push_many<T: BytesContainer>(&mut self, paths: &[T]) {\n         let t: Option<&T> = None;\n         if BytesContainer::is_str(t) {\n-            for p in paths.iter() {\n+            for p in paths {\n                 self.push(p.container_as_str().unwrap())\n             }\n         } else {\n-            for p in paths.iter() {\n+            for p in paths {\n                 self.push(p.container_as_bytes())\n             }\n         }"}, {"sha": "69f815e3f8b771bc4fc2bf9289d1f54554697441", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -31,7 +31,7 @@ pub type Components<'a> = Split<'a, u8, fn(&u8) -> bool>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n pub type StrComponents<'a> =\n-    Map<&'a [u8], Option<&'a str>, Components<'a>, fn(&[u8]) -> Option<&str>>;\n+    Map<Components<'a>, fn(&[u8]) -> Option<&str>>;\n \n /// Represents a POSIX file path\n #[derive(Clone)]"}, {"sha": "fcdebaf2cd3eb9856f69330fc2750bea18446530", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -25,8 +25,6 @@ use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option::{self, Some, None};\n-#[cfg(stage0)]\n-use ops::FullRange;\n use result::Result::{self, Ok, Err};\n use slice::{SliceExt, SliceConcatExt};\n use str::{SplitTerminator, FromStr, StrExt};\n@@ -40,11 +38,11 @@ use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n pub type StrComponents<'a> =\n-    Map<&'a str, Option<&'a str>, SplitTerminator<'a, char>, fn(&'a str) -> Option<&'a str>>;\n+    Map<SplitTerminator<'a, char>, fn(&'a str) -> Option<&'a str>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n pub type Components<'a> =\n-    Map<Option<&'a str>, &'a [u8], StrComponents<'a>, fn(Option<&str>) -> &[u8]>;\n+    Map<StrComponents<'a>, fn(Option<&str>) -> &[u8]>;\n \n /// Represents a Windows path\n // Notes for Windows path impl:"}, {"sha": "2398485afefb7ab481eaa38a0c18bd59ab941691", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -18,10 +18,6 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n-#[cfg(stage0)]\n-#[unstable(feature = \"std_misc\")]\n-#[doc(no_inline)] pub use ops::FullRange;\n-\n // Reexported functions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use mem::drop;"}, {"sha": "cc72c5bed99dc905102e3bffb0345abeb5f4676f", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -464,7 +464,7 @@ mod test {\n         // check every remainder mod 8, both in small and big vectors.\n         let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n                        80, 81, 82, 83, 84, 85, 86, 87];\n-        for &n in lengths.iter() {\n+        for &n in &lengths {\n             let mut v = repeat(0u8).take(n).collect::<Vec<_>>();\n             r.fill_bytes(v.as_mut_slice());\n "}, {"sha": "4b45d5501c2351a2797c5d3f7c9ee86a913c1618", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -404,7 +404,7 @@ mod test {\n         }\n \n         // start all the tasks\n-        for tx in txs.iter() {\n+        for tx in &txs {\n             tx.send(()).unwrap();\n         }\n     }"}, {"sha": "b3bed4af96248dd4cdf70c25cad961aa7ac8b53f", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -42,7 +42,8 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n #[cfg(any(target_os = \"linux\",\n           target_os = \"android\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n mod imp {\n     use prelude::v1::*;\n "}, {"sha": "3f15cf71ec3f74974e2f1fc8397ae1f9144c294b", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -58,7 +58,7 @@ pub fn cleanup() {\n         // If we never called init, not need to cleanup!\n         if queue as uint != 0 {\n             let queue: Box<Queue> = mem::transmute(queue);\n-            for to_run in queue.into_iter() {\n+            for to_run in *queue {\n                 to_run.invoke(());\n             }\n         }"}, {"sha": "905cc06c4f007f11d5640e31d1d8f3756a88fc8e", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -14,7 +14,7 @@\n \n use prelude::v1::*;\n \n-use os;\n+use env;\n use sync::atomic::{self, Ordering};\n \n pub use sys::backtrace::write;\n@@ -29,7 +29,7 @@ pub fn log_enabled() -> bool {\n         _ => {}\n     }\n \n-    let val = match os::getenv(\"RUST_BACKTRACE\") {\n+    let val = match env::var(\"RUST_BACKTRACE\") {\n         Some(..) => 2,\n         None => 1,\n     };"}, {"sha": "43e3a43f56d3632ce38017ebf3df9511aed42709", "filename": "src/libstd/rt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -101,7 +101,7 @@ pub type _Unwind_Exception_Cleanup_Fn =\n #[link(name = \"gcc_s\")]\n extern {}\n \n-#[cfg(target_os = \"android\")]\n+#[cfg(any(target_os = \"android\", target_os = \"openbsd\"))]\n #[link(name = \"gcc\")]\n extern {}\n "}, {"sha": "00088d6d99a0a6af49b02b8910da11c29832cd00", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -65,7 +65,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use prelude::v1::*;\n \n     use mem;\n-    use os;\n+    use env;\n     use rt;\n     use sys_common::thread_info::{self, NewThread};\n     use sys_common;\n@@ -131,7 +131,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     if failed {\n         rt::DEFAULT_ERROR_CODE\n     } else {\n-        os::get_exit_status()\n+        env::get_exit_status() as isize\n     }\n }\n "}, {"sha": "81ca5aa0e8a6e3d4bc6aa332f4488daee05e202a", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -160,7 +160,7 @@ pub fn panicking() -> bool {\n // An uninlined, unmangled function upon which to slap yer breakpoints\n #[inline(never)]\n #[no_mangle]\n-#[cfg_attr(not(stage0), allow(private_no_mangle_fns))]\n+#[allow(private_no_mangle_fns)]\n fn rust_panic(cause: Box<Any + Send>) -> ! {\n     rtdebug!(\"begin_unwind()\");\n \n@@ -238,7 +238,7 @@ pub mod eabi {\n \n     #[lang=\"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n-    #[cfg_attr(not(stage0), allow(private_no_mangle_fns))]\n+    #[allow(private_no_mangle_fns)]\n     extern fn rust_eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,\n@@ -551,7 +551,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n         let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n         &CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n     };\n-    for cb in callbacks.iter() {\n+    for cb in callbacks {\n         match cb.load(Ordering::SeqCst) {\n             0 => {}\n             n => {"}, {"sha": "86d21cf72782ed51a3b71db9225c346d1dc52e71", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -13,6 +13,7 @@\n use prelude::v1::*;\n \n use cmp;\n+use env;\n use fmt;\n use intrinsics;\n use libc::{self, uintptr_t};\n@@ -51,7 +52,7 @@ pub fn min_stack() -> uint {\n         0 => {}\n         n => return n - 1,\n     }\n-    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| s.parse().ok());\n+    let amt = env::var_string(\"RUST_MIN_STACK\").ok().and_then(|s| s.parse().ok());\n     let amt = amt.unwrap_or(2 * 1024 * 1024);\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n@@ -62,15 +63,15 @@ pub fn min_stack() -> uint {\n /// Get's the number of scheduler threads requested by the environment\n /// either `RUST_THREADS` or `num_cpus`.\n pub fn default_sched_threads() -> uint {\n-    match os::getenv(\"RUST_THREADS\") {\n-        Some(nstr) => {\n+    match env::var_string(\"RUST_THREADS\") {\n+        Ok(nstr) => {\n             let opt_n: Option<uint> = nstr.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => panic!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n             }\n         }\n-        None => {\n+        Err(..) => {\n             if limit_thread_creation_due_to_osx_and_valgrind() {\n                 1\n             } else {"}, {"sha": "1392bc815c4f9d68d31a93aa47ae87e3a72af478", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -39,7 +39,7 @@ extern {}\n #[link(name = \"pthread\")]\n extern {}\n \n-#[cfg(target_os = \"dragonfly\")]\n+#[cfg(any(target_os = \"dragonfly\", target_os = \"openbsd\"))]\n #[link(name = \"pthread\")]\n extern {}\n "}, {"sha": "2dfc708e15bebdc7386d96469e0451551b651251", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -508,7 +508,7 @@ mod tests {\n         }\n \n         // Wait for children to pass their asserts\n-        for r in children.into_iter() {\n+        for r in children {\n             assert!(r.join().is_ok());\n         }\n "}, {"sha": "0ca228267003db79e76a9e5b96a06dd1eed35b41", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -24,13 +24,6 @@ unsafe impl Sync for Mutex {}\n pub const MUTEX_INIT: Mutex = Mutex(imp::MUTEX_INIT);\n \n impl Mutex {\n-    /// Creates a newly initialized mutex.\n-    ///\n-    /// Behavior is undefined if the mutex is moved after the first method is\n-    /// called on the mutex.\n-    #[inline]\n-    pub unsafe fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n-\n     /// Lock the mutex blocking the current thread until it is available.\n     ///\n     /// Behavior is undefined if the mutex has been moved between this and any"}, {"sha": "833de8adda49dfbb41ce8fb95fa3dbf65a443279", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -554,7 +554,7 @@ pub fn await(fds: &[sock_t], deadline: Option<u64>,\n              status: SocketStatus) -> IoResult<()> {\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n     let mut max = 0;\n-    for &fd in fds.iter() {\n+    for &fd in fds {\n         c::fd_set(&mut set, fd);\n         max = cmp::max(max, fd + 1);\n     }\n@@ -694,10 +694,16 @@ impl TcpStream {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n                    seconds as libc::c_int)\n     }\n+    #[cfg(target_os = \"openbsd\")]\n+    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::SO_KEEPALIVE,\n+                   seconds as libc::c_int)\n+    }\n     #[cfg(not(any(target_os = \"macos\",\n                   target_os = \"ios\",\n                   target_os = \"freebsd\",\n-                  target_os = \"dragonfly\")))]\n+                  target_os = \"dragonfly\",\n+                  target_os = \"openbsd\")))]\n     fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n         Ok(())\n     }"}, {"sha": "fe374e1fd78a3dd55ac97c08234d60054832fe90", "filename": "src/libstd/sys/common/rwlock.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -21,13 +21,6 @@ pub struct RWLock(imp::RWLock);\n pub const RWLOCK_INIT: RWLock = RWLock(imp::RWLOCK_INIT);\n \n impl RWLock {\n-    /// Creates a new instance of an RWLock.\n-    ///\n-    /// Usage of an RWLock is undefined if it is moved after its first use (any\n-    /// function calls below).\n-    #[inline]\n-    pub unsafe fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n-\n     /// Acquire shared access to the underlying lock, blocking the current\n     /// thread to do so.\n     ///"}, {"sha": "8dd2f154fa8e3028fd5c0cd31cbc71060cca6b93", "filename": "src/libstd/sys/common/stack.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -227,18 +227,13 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     }\n \n     // aarch64 - FIXME(AARCH64): missing...\n-    #[cfg(target_arch = \"aarch64\")]\n-    unsafe fn target_record_sp_limit(_: uint) {\n-    }\n-\n     // powerpc - FIXME(POWERPC): missing...\n-    #[cfg(target_arch = \"powerpc\")]\n-    unsafe fn target_record_sp_limit(_: uint) {\n-    }\n-\n-\n-    // iOS segmented stack is disabled for now, see related notes\n-    #[cfg(all(target_arch = \"arm\", target_os = \"ios\"))] #[inline(always)]\n+    // arm-ios - iOS segmented stack is disabled for now, see related notes\n+    // openbsd - segmented stack is disabled\n+    #[cfg(any(target_arch = \"aarch64\",\n+              target_arch = \"powerpc\",\n+              all(target_arch = \"arm\", target_os = \"ios\"),\n+              target_os = \"openbsd\"))]\n     unsafe fn target_record_sp_limit(_: uint) {\n     }\n }\n@@ -327,21 +322,17 @@ pub unsafe fn get_sp_limit() -> uint {\n     }\n \n     // aarch64 - FIXME(AARCH64): missing...\n-    #[cfg(target_arch = \"aarch64\")]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        1024\n-    }\n-\n-    // powepc - FIXME(POWERPC): missing...\n-    #[cfg(target_arch = \"powerpc\")]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        1024\n-    }\n-\n-    // iOS doesn't support segmented stacks yet. This function might\n-    // be called by runtime though so it is unsafe to mark it as\n-    // unreachable, let's return a fixed constant.\n-    #[cfg(all(target_arch = \"arm\", target_os = \"ios\"))] #[inline(always)]\n+    // powerpc - FIXME(POWERPC): missing...\n+    // arm-ios - iOS doesn't support segmented stacks yet.\n+    // openbsd - OpenBSD doesn't support segmented stacks.\n+    //\n+    // This function might be called by runtime though\n+    // so it is unsafe to unreachable, let's return a fixed constant.\n+    #[cfg(any(target_arch = \"aarch64\",\n+              target_arch = \"powerpc\",\n+              all(target_arch = \"arm\", target_os = \"ios\"),\n+              target_os = \"openbsd\"))]\n+    #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         1024\n     }"}, {"sha": "b30af10986b9952235c200e4de4a81db959d64e8", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -366,7 +366,7 @@ impl FromIterator<CodePoint> for Wtf8Buf {\n /// This replaces surrogate code point pairs with supplementary code points,\n /// like concatenating ill-formed UTF-16 strings effectively would.\n impl Extend<CodePoint> for Wtf8Buf {\n-    fn extend<T: Iterator<Item=CodePoint>>(&mut self, mut iterator: T) {\n+    fn extend<T: Iterator<Item=CodePoint>>(&mut self, iterator: T) {\n         let (low, _high) = iterator.size_hint();\n         // Lower bound of one byte per code point (ASCII only)\n         self.bytes.reserve(low);\n@@ -680,17 +680,6 @@ impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     }\n }\n \n-#[cfg(stage0)]\n-impl ops::Index<ops::FullRange> for Wtf8 {\n-    type Output = Wtf8;\n-\n-    #[inline]\n-    fn index(&self, _range: &ops::FullRange) -> &Wtf8 {\n-        self\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl ops::Index<ops::RangeFull> for Wtf8 {\n     type Output = Wtf8;\n "}, {"sha": "5e512e9261b1dfe475ec84ecad7adcb36c608c44", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -240,7 +240,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-    use os;\n+    use env;\n     use ptr;\n \n     ////////////////////////////////////////////////////////////////////////\n@@ -318,8 +318,9 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         static mut LAST_FILENAME: [libc::c_char; 256] = [0; 256];\n         if !STATE.is_null() { return STATE }\n         let selfname = if cfg!(target_os = \"freebsd\") ||\n-                          cfg!(target_os = \"dragonfly\") {\n-            os::self_exe_name()\n+                          cfg!(target_os = \"dragonfly\") ||\n+                          cfg!(target_os = \"openbsd\") {\n+            env::current_exe().ok()\n         } else {\n             None\n         };"}, {"sha": "89bd9a2340652e550070abe0e2774fb101065863", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -23,7 +23,8 @@ use libc;\n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n pub const FIONBIO: libc::c_ulong = 0x8004667e;\n #[cfg(any(all(target_os = \"linux\",\n               any(target_arch = \"x86\",\n@@ -41,7 +42,8 @@ pub const FIONBIO: libc::c_ulong = 0x667e;\n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n pub const FIOCLEX: libc::c_ulong = 0x20006601;\n #[cfg(any(all(target_os = \"linux\",\n               any(target_arch = \"x86\",\n@@ -59,13 +61,61 @@ pub const FIOCLEX: libc::c_ulong = 0x6601;\n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n pub const MSG_DONTWAIT: libc::c_int = 0x80;\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub const MSG_DONTWAIT: libc::c_int = 0x40;\n \n pub const WNOHANG: libc::c_int = 1;\n \n+#[cfg(target_os = \"linux\")]\n+pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 70;\n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"freebsd\"))]\n+pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 71;\n+#[cfg(target_os = \"android\")]\n+pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 0x0048;\n+\n+#[repr(C)]\n+#[cfg(target_os = \"linux\")]\n+pub struct passwd {\n+    pub pw_name: *mut libc::c_char,\n+    pub pw_passwd: *mut libc::c_char,\n+    pub pw_uid: libc::uid_t,\n+    pub pw_gid: libc::gid_t,\n+    pub pw_gecos: *mut libc::c_char,\n+    pub pw_dir: *mut libc::c_char,\n+    pub pw_shell: *mut libc::c_char,\n+}\n+\n+#[repr(C)]\n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"freebsd\"))]\n+pub struct passwd {\n+    pub pw_name: *mut libc::c_char,\n+    pub pw_passwd: *mut libc::c_char,\n+    pub pw_uid: libc::uid_t,\n+    pub pw_gid: libc::gid_t,\n+    pub pw_change: libc::time_t,\n+    pub pw_class: *mut libc::c_char,\n+    pub pw_gecos: *mut libc::c_char,\n+    pub pw_dir: *mut libc::c_char,\n+    pub pw_shell: *mut libc::c_char,\n+    pub pw_expire: libc::time_t,\n+}\n+\n+#[repr(C)]\n+#[cfg(target_os = \"android\")]\n+pub struct passwd {\n+    pub pw_name: *mut libc::c_char,\n+    pub pw_passwd: *mut libc::c_char,\n+    pub pw_uid: libc::uid_t,\n+    pub pw_gid: libc::gid_t,\n+    pub pw_dir: *mut libc::c_char,\n+    pub pw_shell: *mut libc::c_char,\n+}\n+\n extern {\n     pub fn gettimeofday(timeval: *mut libc::timeval,\n                         tzp: *mut libc::c_void) -> libc::c_int;\n@@ -92,6 +142,12 @@ extern {\n     pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n     pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n     pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;\n+\n+    pub fn getpwuid_r(uid: libc::uid_t,\n+                      pwd: *mut passwd,\n+                      buf: *mut libc::c_char,\n+                      buflen: libc::size_t,\n+                      result: *mut *mut passwd) -> libc::c_int;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n@@ -111,6 +167,7 @@ mod select {\n #[cfg(any(target_os = \"android\",\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\",\n+          target_os = \"openbsd\",\n           target_os = \"linux\"))]\n mod select {\n     use uint;\n@@ -235,7 +292,8 @@ mod signal {\n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n mod signal {\n     use libc;\n \n@@ -248,7 +306,9 @@ mod signal {\n     pub const SA_SIGINFO: libc::c_int = 0x0040;\n     pub const SIGCHLD: libc::c_int = 20;\n \n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"openbsd\"))]\n     pub type sigset_t = u32;\n     #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n     #[repr(C)]"}, {"sha": "b03b9046966a02dc3dccc99307c8a9900cbb6750", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -141,7 +141,7 @@ pub fn retry<T, F> (mut f: F) -> T where\n     let one: T = Int::one();\n     loop {\n         let n = f();\n-        if n == -one && os::errno() == libc::EINTR as int { }\n+        if n == -one && os::errno() == libc::EINTR as i32 { }\n         else { return n }\n     }\n }\n@@ -155,7 +155,7 @@ pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n \n pub fn wouldblock() -> bool {\n     let err = os::errno();\n-    err == libc::EWOULDBLOCK as int || err == libc::EAGAIN as int\n+    err == libc::EWOULDBLOCK as i32 || err == libc::EAGAIN as i32\n }\n \n pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {"}, {"sha": "b3f3796294580b1b1b8358be300672a8a318cf45", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 349, "deletions": 113, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,93 +11,74 @@\n //! Implementation of `std::os` functionality for unix systems\n \n use prelude::v1::*;\n+use os::unix::*;\n \n-use error::{FromError, Error};\n-use ffi::{self, CString};\n+use error::Error as StdError;\n+use ffi::{self, CString, OsString, OsStr, AsOsStr};\n use fmt;\n-use old_io::{IoError, IoResult};\n+use iter;\n use libc::{self, c_int, c_char, c_void};\n-use os::TMPBUF_SZ;\n-use os;\n-use path::{BytesContainer};\n+use mem;\n+use old_io::{IoResult, IoError, fs};\n use ptr;\n+use slice;\n use str;\n+use sys::c;\n use sys::fs::FileDesc;\n+use vec;\n \n-const BUF_BYTES : uint = 2048u;\n+const BUF_BYTES: usize = 2048;\n+const TMPBUF_SZ: usize = 128;\n \n /// Returns the platform-specific value of errno\n-pub fn errno() -> int {\n+pub fn errno() -> i32 {\n     #[cfg(any(target_os = \"macos\",\n               target_os = \"ios\",\n               target_os = \"freebsd\"))]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __error() -> *const c_int;\n-        }\n-        unsafe {\n-            __error()\n-        }\n+    unsafe fn errno_location() -> *const c_int {\n+        extern { fn __error() -> *const c_int; }\n+        __error()\n     }\n \n     #[cfg(target_os = \"dragonfly\")]\n+    unsafe fn errno_location() -> *const c_int {\n+        extern { fn __dfly_error() -> *const c_int; }\n+        __dfly_error()\n+    }\n+\n+    #[cfg(target_os = \"openbsd\")]\n     fn errno_location() -> *const c_int {\n         extern {\n-            fn __dfly_error() -> *const c_int;\n+            fn __errno() -> *const c_int;\n         }\n         unsafe {\n-            __dfly_error()\n+            __errno()\n         }\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __errno_location() -> *const c_int;\n-        }\n-        unsafe {\n-            __errno_location()\n-        }\n+    unsafe fn errno_location() -> *const c_int {\n+        extern { fn __errno_location() -> *const c_int; }\n+        __errno_location()\n     }\n \n     unsafe {\n-        (*errno_location()) as int\n+        (*errno_location()) as i32\n     }\n }\n \n /// Get a detailed string description for the given error number\n pub fn error_string(errno: i32) -> String {\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"ios\",\n-              target_os = \"android\",\n-              target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n-    fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n-                  -> c_int {\n-        extern {\n-            fn strerror_r(errnum: c_int, buf: *mut c_char,\n-                          buflen: libc::size_t) -> c_int;\n-        }\n-        unsafe {\n-            strerror_r(errnum, buf, buflen)\n-        }\n-    }\n-\n-    // GNU libc provides a non-compliant version of strerror_r by default\n-    // and requires macros to instead use the POSIX compliant variant.\n-    // So we just use __xpg_strerror_r which is always POSIX compliant\n     #[cfg(target_os = \"linux\")]\n-    fn strerror_r(errnum: c_int, buf: *mut c_char,\n-                  buflen: libc::size_t) -> c_int {\n-        extern {\n-            fn __xpg_strerror_r(errnum: c_int,\n-                                buf: *mut c_char,\n-                                buflen: libc::size_t)\n-                                -> c_int;\n-        }\n-        unsafe {\n-            __xpg_strerror_r(errnum, buf, buflen)\n-        }\n+    extern {\n+        #[link_name = \"__xpg_strerror_r\"]\n+        fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                      buflen: libc::size_t) -> c_int;\n+    }\n+    #[cfg(not(target_os = \"linux\"))]\n+    extern {\n+        fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                      buflen: libc::size_t) -> c_int;\n     }\n \n     let mut buf = [0 as c_char; TMPBUF_SZ];\n@@ -113,15 +94,6 @@ pub fn error_string(errno: i32) -> String {\n     }\n }\n \n-pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n-    let mut fds = [0; 2];\n-    if libc::pipe(fds.as_mut_ptr()) == 0 {\n-        Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n-    } else {\n-        Err(super::last_error())\n-    }\n-}\n-\n pub fn getcwd() -> IoResult<Path> {\n     let mut buf = [0 as c_char; BUF_BYTES];\n     unsafe {\n@@ -133,43 +105,68 @@ pub fn getcwd() -> IoResult<Path> {\n     }\n }\n \n-pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-    extern {\n-        fn rust_env_pairs() -> *const *const c_char;\n-    }\n-    let mut environ = rust_env_pairs();\n-    if environ as uint == 0 {\n-        panic!(\"os::env() failure getting env string from OS: {}\",\n-               os::last_os_error());\n+pub fn chdir(p: &Path) -> IoResult<()> {\n+    let p = CString::from_slice(p.as_vec());\n+    unsafe {\n+        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n+            true => Ok(()),\n+            false => Err(IoError::last_error()),\n+        }\n     }\n-    let mut result = Vec::new();\n-    while *environ != ptr::null() {\n-        let env_pair = ffi::c_str_to_bytes(&*environ).to_vec();\n-        result.push(env_pair);\n-        environ = environ.offset(1);\n+}\n+\n+pub struct SplitPaths<'a> {\n+    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>,\n+                    fn(&'a [u8]) -> Path>,\n+}\n+\n+pub fn split_paths<'a>(unparsed: &'a OsStr) -> SplitPaths<'a> {\n+    fn is_colon(b: &u8) -> bool { *b == b':' }\n+    let unparsed = unparsed.as_byte_slice();\n+    SplitPaths {\n+        iter: unparsed.split(is_colon as fn(&u8) -> bool)\n+                      .map(Path::new as fn(&'a [u8]) ->  Path)\n     }\n-    result\n }\n \n-pub fn split_paths(unparsed: &[u8]) -> Vec<Path> {\n-    unparsed.split(|b| *b == b':').map(Path::new).collect()\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = Path;\n+    fn next(&mut self) -> Option<Path> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsOsStr\n+{\n     let mut joined = Vec::new();\n     let sep = b':';\n \n-    for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+    for (i, path) in paths.enumerate() {\n+        let path = path.as_os_str().as_byte_slice();\n         if i > 0 { joined.push(sep) }\n-        if path.contains(&sep) { return Err(\"path segment contains separator `:`\") }\n+        if path.contains(&sep) {\n+            return Err(JoinPathsError)\n+        }\n         joined.push_all(path);\n     }\n+    Ok(OsStringExt::from_vec(joined))\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"path segment contains separator `:`\".fmt(f)\n+    }\n+}\n \n-    Ok(joined)\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str { \"failed to join paths\" }\n }\n \n #[cfg(target_os = \"freebsd\")]\n-pub fn load_self() -> Option<Vec<u8>> {\n+pub fn current_exe() -> IoResult<Path> {\n     unsafe {\n         use libc::funcs::bsd44::*;\n         use libc::consts::os::extra::*;\n@@ -181,66 +178,305 @@ pub fn load_self() -> Option<Vec<u8>> {\n         let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                          ptr::null_mut(), &mut sz, ptr::null_mut(),\n                          0u as libc::size_t);\n-        if err != 0 { return None; }\n-        if sz == 0 { return None; }\n+        if err != 0 { return Err(IoError::last_error()); }\n+        if sz == 0 { return Err(IoError::last_error()); }\n         let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n         let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                          v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n                          ptr::null_mut(), 0u as libc::size_t);\n-        if err != 0 { return None; }\n-        if sz == 0 { return None; }\n+        if err != 0 { return Err(IoError::last_error()); }\n+        if sz == 0 { return Err(IoError::last_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Some(v)\n+        Ok(Path::new(v))\n     }\n }\n \n #[cfg(target_os = \"dragonfly\")]\n+pub fn current_exe() -> IoResult<Path> {\n+    fs::readlink(&Path::new(\"/proc/curproc/file\"))\n+}\n+\n+#[cfg(target_os = \"openbsd\")]\n pub fn load_self() -> Option<Vec<u8>> {\n-    use old_io;\n+    use sync::{StaticMutex, MUTEX_INIT};\n \n-    match old_io::fs::readlink(&Path::new(\"/proc/curproc/file\")) {\n-        Ok(path) => Some(path.into_vec()),\n-        Err(..) => None\n+    static LOCK: StaticMutex = MUTEX_INIT;\n+\n+    extern {\n+        fn rust_load_self() -> *const c_char;\n     }\n-}\n \n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn load_self() -> Option<Vec<u8>> {\n-    use old_io;\n+    let _guard = LOCK.lock();\n \n-    match old_io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n-        Ok(path) => Some(path.into_vec()),\n-        Err(..) => None\n+    unsafe {\n+        let v = rust_load_self();\n+        if v.is_null() {\n+            None\n+        } else {\n+            Some(ffi::c_str_to_bytes(&v).to_vec())\n+        }\n     }\n }\n \n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub fn current_exe() -> IoResult<Path> {\n+    fs::readlink(&Path::new(\"/proc/self/exe\"))\n+}\n+\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-pub fn load_self() -> Option<Vec<u8>> {\n+pub fn current_exe() -> IoResult<Path> {\n     unsafe {\n         use libc::funcs::extra::_NSGetExecutablePath;\n         let mut sz: u32 = 0;\n         _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n-        if sz == 0 { return None; }\n+        if sz == 0 { return Err(IoError::last_error()); }\n         let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n         let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n-        if err != 0 { return None; }\n+        if err != 0 { return Err(IoError::last_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Some(v)\n+        Ok(Path::new(v))\n     }\n }\n \n-pub fn chdir(p: &Path) -> IoResult<()> {\n-    let p = CString::from_slice(p.as_vec());\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: *mut (),\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+/// Returns the command line arguments\n+///\n+/// Returns a list of the command line arguments.\n+#[cfg(target_os = \"macos\")]\n+pub fn args() -> Args {\n+    extern {\n+        // These functions are in crt_externs.h.\n+        fn _NSGetArgc() -> *mut c_int;\n+        fn _NSGetArgv() -> *mut *mut *mut c_char;\n+    }\n+\n+    let vec = unsafe {\n+        let (argc, argv) = (*_NSGetArgc() as isize,\n+                            *_NSGetArgv() as *const *const c_char);\n+        range(0, argc as isize).map(|i| {\n+            let bytes = ffi::c_str_to_bytes(&*argv.offset(i)).to_vec();\n+            OsStringExt::from_vec(bytes)\n+        }).collect::<Vec<_>>()\n+    };\n+    Args {\n+        iter: vec.into_iter(),\n+        _dont_send_or_sync_me: 0 as *mut (),\n+    }\n+}\n+\n+// As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n+// and use underscores in their names - they're most probably\n+// are considered private and therefore should be avoided\n+// Here is another way to get arguments using Objective C\n+// runtime\n+//\n+// In general it looks like:\n+// res = Vec::new()\n+// let args = [[NSProcessInfo processInfo] arguments]\n+// for i in range(0, [args count])\n+//      res.push([args objectAtIndex:i])\n+// res\n+#[cfg(target_os = \"ios\")]\n+pub fn args() -> Args {\n+    use iter::range;\n+    use mem;\n+\n+    #[link(name = \"objc\")]\n+    extern {\n+        fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n+        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n+        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n+    }\n+\n+    #[link(name = \"Foundation\", kind = \"framework\")]\n+    extern {}\n+\n+    type Sel = *const libc::c_void;\n+    type NsId = *const libc::c_void;\n+\n+    let mut res = Vec::new();\n+\n     unsafe {\n-        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n-            true => Ok(()),\n-            false => Err(IoError::last_error()),\n+        let processInfoSel = sel_registerName(\"processInfo\\0\".as_ptr());\n+        let argumentsSel = sel_registerName(\"arguments\\0\".as_ptr());\n+        let utf8Sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n+        let countSel = sel_registerName(\"count\\0\".as_ptr());\n+        let objectAtSel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n+\n+        let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n+        let info = objc_msgSend(klass, processInfoSel);\n+        let args = objc_msgSend(info, argumentsSel);\n+\n+        let cnt: int = mem::transmute(objc_msgSend(args, countSel));\n+        for i in range(0, cnt) {\n+            let tmp = objc_msgSend(args, objectAtSel, i);\n+            let utf_c_str: *const libc::c_char =\n+                mem::transmute(objc_msgSend(tmp, utf8Sel));\n+            let bytes = ffi::c_str_to_bytes(&utf_c_str).to_vec();\n+            res.push(OsString::from_vec(bytes))\n+        }\n+    }\n+\n+    Args { iter: res.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n+}\n+\n+#[cfg(any(target_os = \"linux\",\n+          target_os = \"android\",\n+          target_os = \"freebsd\",\n+          target_os = \"dragonfly\"))]\n+pub fn args() -> Args {\n+    use rt;\n+    let bytes = rt::args::clone().unwrap_or(Vec::new());\n+    let v: Vec<OsString> = bytes.into_iter().map(|v| {\n+        OsStringExt::from_vec(v)\n+    }).collect();\n+    Args { iter: v.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n+}\n+\n+pub struct Env {\n+    iter: vec::IntoIter<(OsString, OsString)>,\n+    _dont_send_or_sync_me: *mut (),\n+}\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+pub unsafe fn environ() -> *mut *const *const c_char {\n+    extern { fn _NSGetEnviron() -> *mut *const *const c_char; }\n+    _NSGetEnviron()\n+}\n+\n+#[cfg(not(target_os = \"macos\"))]\n+pub unsafe fn environ() -> *mut *const *const c_char {\n+    extern { static mut environ: *const *const c_char; }\n+    &mut environ\n+}\n+\n+/// Returns a vector of (variable, value) byte-vector pairs for all the\n+/// environment variables of the current process.\n+pub fn env() -> Env {\n+    return unsafe {\n+        let mut environ = *environ();\n+        if environ as usize == 0 {\n+            panic!(\"os::env() failure getting env string from OS: {}\",\n+                   IoError::last_error());\n+        }\n+        let mut result = Vec::new();\n+        while *environ != ptr::null() {\n+            result.push(parse(ffi::c_str_to_bytes(&*environ)));\n+            environ = environ.offset(1);\n+        }\n+        Env { iter: result.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n+    };\n+\n+    fn parse(input: &[u8]) -> (OsString, OsString) {\n+        let mut it = input.splitn(1, |b| *b == b'=');\n+        let key = it.next().unwrap().to_vec();\n+        let default: &[u8] = &[];\n+        let val = it.next().unwrap_or(default).to_vec();\n+        (OsStringExt::from_vec(key), OsStringExt::from_vec(val))\n+    }\n+}\n+\n+pub fn getenv(k: &OsStr) -> Option<OsString> {\n+    unsafe {\n+        let s = CString::from_slice(k.as_byte_slice());\n+        let s = libc::getenv(s.as_ptr()) as *const _;\n+        if s.is_null() {\n+            None\n+        } else {\n+            Some(OsStringExt::from_vec(ffi::c_str_to_bytes(&s).to_vec()))\n+        }\n+    }\n+}\n+\n+pub fn setenv(k: &OsStr, v: &OsStr) {\n+    unsafe {\n+        let k = CString::from_slice(k.as_byte_slice());\n+        let v = CString::from_slice(v.as_byte_slice());\n+        if libc::funcs::posix01::unistd::setenv(k.as_ptr(), v.as_ptr(), 1) != 0 {\n+            panic!(\"failed setenv: {}\", IoError::last_error());\n+        }\n+    }\n+}\n+\n+pub fn unsetenv(n: &OsStr) {\n+    unsafe {\n+        let nbuf = CString::from_slice(n.as_byte_slice());\n+        if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n+            panic!(\"failed unsetenv: {}\", IoError::last_error());\n         }\n     }\n }\n \n-pub fn page_size() -> uint {\n+pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n+    let mut fds = [0; 2];\n+    if libc::pipe(fds.as_mut_ptr()) == 0 {\n+        Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n+    } else {\n+        Err(IoError::last_error())\n+    }\n+}\n+\n+pub fn page_size() -> usize {\n     unsafe {\n-        libc::sysconf(libc::_SC_PAGESIZE) as uint\n+        libc::sysconf(libc::_SC_PAGESIZE) as usize\n+    }\n+}\n+\n+pub fn temp_dir() -> Path {\n+    getenv(\"TMPDIR\".as_os_str()).map(|p| Path::new(p.into_vec())).unwrap_or_else(|| {\n+        if cfg!(target_os = \"android\") {\n+            Path::new(\"/data/local/tmp\")\n+        } else {\n+            Path::new(\"/tmp\")\n+        }\n+    })\n+}\n+\n+pub fn home_dir() -> Option<Path> {\n+    return getenv(\"HOME\".as_os_str()).or_else(|| unsafe {\n+        fallback()\n+    }).map(|os| {\n+        Path::new(os.into_vec())\n+    });\n+\n+    #[cfg(target_os = \"android\")]\n+    unsafe fn fallback() -> Option<OsString> { None }\n+    #[cfg(not(target_os = \"android\"))]\n+    unsafe fn fallback() -> Option<OsString> {\n+        let mut amt = match libc::sysconf(c::_SC_GETPW_R_SIZE_MAX) {\n+            n if n < 0 => 512 as usize,\n+            n => n as usize,\n+        };\n+        let me = libc::getuid();\n+        loop {\n+            let mut buf = Vec::with_capacity(amt);\n+            let mut passwd: c::passwd = mem::zeroed();\n+            let mut result = 0 as *mut _;\n+            match c::getpwuid_r(me, &mut passwd, buf.as_mut_ptr(),\n+                                buf.capacity() as libc::size_t,\n+                                &mut result) {\n+                0 if !result.is_null() => {}\n+                _ => return None\n+            }\n+            let ptr = passwd.pw_dir as *const _;\n+            let bytes = ffi::c_str_to_bytes(&ptr).to_vec();\n+            return Some(OsStringExt::from_vec(bytes))\n+        }\n     }\n }"}, {"sha": "7e117b10a347c5ed80ffe46edb465a78d2836ff7", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -72,18 +72,6 @@ impl Process {\n             }\n         }\n \n-        #[cfg(target_os = \"macos\")]\n-        unsafe fn set_environ(envp: *const c_void) {\n-            extern { fn _NSGetEnviron() -> *mut *const c_void; }\n-\n-            *_NSGetEnviron() = envp;\n-        }\n-        #[cfg(not(target_os = \"macos\"))]\n-        unsafe fn set_environ(envp: *const c_void) {\n-            extern { static mut environ: *const c_void; }\n-            environ = envp;\n-        }\n-\n         unsafe fn set_cloexec(fd: c_int) {\n             let ret = c::ioctl(fd, c::FIOCLEX);\n             assert_eq!(ret, 0);\n@@ -269,7 +257,7 @@ impl Process {\n                     fail(&mut output);\n                 }\n                 if !envp.is_null() {\n-                    set_environ(envp);\n+                    *sys::os::environ() = envp as *const _;\n                 }\n                 let _ = execvp(*argv, argv as *mut _);\n                 fail(&mut output);\n@@ -570,7 +558,7 @@ fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n         Some(env) => {\n             let mut tmps = Vec::with_capacity(env.len());\n \n-            for pair in env.iter() {\n+            for pair in env {\n                 let mut kv = Vec::new();\n                 kv.push_all(pair.0.container_as_bytes());\n                 kv.push('=' as u8);\n@@ -604,7 +592,8 @@ fn translate_status(status: c_int) -> ProcessExit {\n     #[cfg(any(target_os = \"macos\",\n               target_os = \"ios\",\n               target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\"))]\n     mod imp {\n         pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n         pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }"}, {"sha": "3512fa36eb3b7fc07e61b56a0103fc1c02ca4ba4", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -32,7 +32,9 @@ impl Drop for Handler {\n     }\n }\n \n-#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+#[cfg(any(target_os = \"linux\",\n+          target_os = \"macos\",\n+          target_os = \"openbsd\"))]\n mod imp {\n     use core::prelude::*;\n     use sys_common::stack;\n@@ -203,7 +205,7 @@ mod imp {\n \n     }\n \n-    #[cfg(target_os = \"macos\")]\n+    #[cfg(any(target_os = \"macos\", target_os = \"openbsd\"))]\n     mod signal {\n         use libc;\n         use super::sighandler_t;\n@@ -212,14 +214,18 @@ mod imp {\n         pub const SA_SIGINFO: libc::c_int = 0x0040;\n         pub const SIGBUS: libc::c_int = 10;\n \n+        #[cfg(target_os = \"macos\")]\n         pub const SIGSTKSZ: libc::size_t = 131072;\n+        #[cfg(target_os = \"openbsd\")]\n+        pub const SIGSTKSZ: libc::size_t = 40960;\n \n         pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n \n         pub type sigset_t = u32;\n \n         // This structure has more fields, but we're not all that interested in\n         // them.\n+        #[cfg(target_os = \"macos\")]\n         #[repr(C)]\n         pub struct siginfo {\n             pub si_signo: libc::c_int,\n@@ -231,6 +237,16 @@ mod imp {\n             pub si_addr: *mut libc::c_void\n         }\n \n+        #[cfg(target_os = \"openbsd\")]\n+        #[repr(C)]\n+        pub struct siginfo {\n+            pub si_signo: libc::c_int,\n+            pub si_code: libc::c_int,\n+            pub si_errno: libc::c_int,\n+            // union\n+            pub si_addr: *mut libc::c_void,\n+        }\n+\n         #[repr(C)]\n         pub struct sigaltstack {\n             pub ss_sp: *mut libc::c_void,\n@@ -260,7 +276,8 @@ mod imp {\n }\n \n #[cfg(not(any(target_os = \"linux\",\n-              target_os = \"macos\")))]\n+              target_os = \"macos\",\n+              target_os = \"openbsd\")))]\n mod imp {\n     use libc;\n "}, {"sha": "bc93513af63d4609f2593ba42ef213608c23dbe6", "filename": "src/libstd/sys/unix/sync.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fsync.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -44,7 +44,9 @@ extern {\n     pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n }\n \n-#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+#[cfg(any(target_os = \"freebsd\",\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n mod os {\n     use libc;\n "}, {"sha": "6f030ee91fe2d6db045ca5daec23dc3dc8240c8c", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -31,7 +31,9 @@ pub extern fn thread_start(main: *mut libc::c_void) -> rust_thread_return {\n     return start_thread(main);\n }\n \n-#[cfg(all(not(target_os = \"linux\"), not(target_os = \"macos\")))]\n+#[cfg(all(not(target_os = \"linux\"),\n+          not(target_os = \"macos\"),\n+          not(target_os = \"openbsd\")))]\n pub mod guard {\n     pub unsafe fn current() -> uint {\n         0\n@@ -45,10 +47,15 @@ pub mod guard {\n     }\n }\n \n-#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+\n+#[cfg(any(target_os = \"linux\",\n+          target_os = \"macos\",\n+          target_os = \"openbsd\"))]\n pub mod guard {\n     use super::*;\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    #[cfg(any(target_os = \"linux\",\n+              target_os = \"android\",\n+              target_os = \"openbsd\"))]\n     use mem;\n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     use ptr;\n@@ -64,7 +71,7 @@ pub mod guard {\n     static mut PAGE_SIZE: uint = 0;\n     static mut GUARD_PAGE: uint = 0;\n \n-    #[cfg(target_os = \"macos\")]\n+    #[cfg(any(target_os = \"macos\", target_os = \"openbsd\"))]\n     unsafe fn get_stack_start() -> *mut libc::c_void {\n         current() as *mut libc::c_void\n     }\n@@ -141,6 +148,23 @@ pub mod guard {\n          pthread_get_stacksize_np(pthread_self())) as uint\n     }\n \n+    #[cfg(target_os = \"openbsd\")]\n+    pub unsafe fn current() -> uint {\n+        let mut current_stack: stack_t = mem::zeroed();\n+        if pthread_stackseg_np(pthread_self(), &mut current_stack) != 0 {\n+            panic!(\"failed to get current stack: pthread_stackseg_np\")\n+        }\n+\n+        if pthread_main_np() == 1 {\n+            // main thread\n+            current_stack.ss_sp as uint - current_stack.ss_size as uint + 3 * PAGE_SIZE as uint\n+\n+        } else {\n+            // new thread\n+            current_stack.ss_sp as uint - current_stack.ss_size as uint\n+        }\n+    }\n+\n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     pub unsafe fn current() -> uint {\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n@@ -224,7 +248,9 @@ pub unsafe fn set_name(name: &str) {\n     }\n }\n \n-#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+#[cfg(any(target_os = \"freebsd\",\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n pub unsafe fn set_name(name: &str) {\n     // pthread_set_name_np() since almost forever on all BSDs\n     let cname = CString::from_slice(name.as_bytes());\n@@ -290,7 +316,9 @@ extern {\n                                  stacksize: *mut libc::size_t) -> libc::c_int;\n }\n \n-#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+#[cfg(any(target_os = \"freebsd\",\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n extern {\n     pub fn pthread_self() -> libc::pthread_t;\n     fn pthread_set_name_np(tid: libc::pthread_t, name: *const libc::c_char);\n@@ -304,6 +332,21 @@ extern {\n     fn pthread_setname_np(name: *const libc::c_char) -> libc::c_int;\n }\n \n+#[cfg(target_os = \"openbsd\")]\n+extern {\n+        pub fn pthread_stackseg_np(thread: libc::pthread_t,\n+                                   sinfo: *mut stack_t) -> libc::c_uint;\n+        pub fn pthread_main_np() -> libc::c_uint;\n+}\n+\n+#[cfg(target_os = \"openbsd\")]\n+#[repr(C)]\n+pub struct stack_t {\n+    pub ss_sp: *mut libc::c_void,\n+    pub ss_size: libc::size_t,\n+    pub ss_flags: libc::c_int,\n+}\n+\n extern {\n     fn pthread_create(native: *mut libc::pthread_t,\n                       attr: *const libc::pthread_attr_t,"}, {"sha": "62d9a33c83d7af78d0280a0118e950844b59c99b", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -42,13 +42,15 @@ pub unsafe fn destroy(key: Key) {\n type pthread_key_t = ::libc::c_ulong;\n \n #[cfg(any(target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n+          target_os = \"dragonfly\",\n+          target_os = \"openbsd\"))]\n type pthread_key_t = ::libc::c_int;\n \n #[cfg(not(any(target_os = \"macos\",\n               target_os = \"ios\",\n               target_os = \"freebsd\",\n-              target_os = \"dragonfly\")))]\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\")))]\n type pthread_key_t = ::libc::c_uint;\n \n extern {"}, {"sha": "bddf7b075df96ab365f534484bde9e6cff17e373", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -80,7 +80,8 @@ mod inner {\n     }\n \n     // Apparently android provides this in some other library?\n-    #[cfg(not(target_os = \"android\"))]\n+    // OpenBSD provide it via libc\n+    #[cfg(not(any(target_os = \"android\", target_os = \"openbsd\")))]\n     #[link(name = \"rt\")]\n     extern {}\n "}, {"sha": "3a79047445cdd8d10a5a70b6c9df8d36e60649f7", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -21,7 +21,8 @@ pub struct TTY {\n }\n \n #[cfg(any(target_os = \"macos\",\n-          target_os = \"freebsd\"))]\n+          target_os = \"freebsd\",\n+          target_os = \"openbsd\"))]\n const TIOCGWINSZ: c_ulong = 0x40087468;\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n@@ -53,7 +54,8 @@ impl TTY {\n     #[cfg(any(target_os = \"linux\",\n               target_os = \"android\",\n               target_os = \"macos\",\n-              target_os = \"freebsd\"))]\n+              target_os = \"freebsd\",\n+              target_os = \"openbsd\"))]\n     pub fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         unsafe {\n             #[repr(C)]"}, {"sha": "66712b9e3a1e6e6edfbd0bd50a0b3821b46fb555", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -7,29 +7,31 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-/// As always, windows has something very different than unix, we mainly want\n-/// to avoid having to depend too much on libunwind for windows.\n-///\n-/// If you google around, you'll find a fair bit of references to built-in\n-/// functions to get backtraces on windows. It turns out that most of these are\n-/// in an external library called dbghelp. I was unable to find this library\n-/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n-/// of it.\n-///\n-/// You'll also find that there's a function called CaptureStackBackTrace\n-/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n-/// copy of that function in my mingw install (maybe it was broken?). Instead,\n-/// this takes the route of using StackWalk64 in order to walk the stack.\n+\n+//! As always, windows has something very different than unix, we mainly want\n+//! to avoid having to depend too much on libunwind for windows.\n+//!\n+//! If you google around, you'll find a fair bit of references to built-in\n+//! functions to get backtraces on windows. It turns out that most of these are\n+//! in an external library called dbghelp. I was unable to find this library\n+//! via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n+//! of it.\n+//!\n+//! You'll also find that there's a function called CaptureStackBackTrace\n+//! mentioned frequently (which is also easy to use), but sadly I didn't have a\n+//! copy of that function in my mingw install (maybe it was broken?). Instead,\n+//! this takes the route of using StackWalk64 in order to walk the stack.\n+\n+#![allow(dead_code)]\n \n use dynamic_lib::DynamicLibrary;\n use ffi;\n-use core::ops::Index;\n use intrinsics;\n use old_io::{IoResult, Writer};\n use libc;\n use mem;\n use ops::Drop;\n-use option::Option::{Some, None};\n+use option::Option::{Some};\n use path::Path;\n use ptr;\n use result::Result::{Ok, Err};\n@@ -296,7 +298,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n     static LOCK: StaticMutex = MUTEX_INIT;\n-    let _g = unsafe { LOCK.lock() };\n+    let _g = LOCK.lock();\n \n     // Open up dbghelp.dll, we don't link to it explicitly because it can't\n     // always be found. Additionally, it's nice having fewer dependencies."}, {"sha": "0355565cf00f29d9b52c912b0f144eeba68b3b25", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 150, "deletions": 40, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -10,17 +10,21 @@\n \n //! C definitions used by libnative that don't belong in liblibc\n \n-#![allow(overflowing_literals)]\n-#![allow(dead_code)]\n-#![allow(non_camel_case_types)]\n+#![allow(bad_style, dead_code, overflowing_literals)]\n \n use libc;\n-use prelude::v1::*;\n \n-pub const WSADESCRIPTION_LEN: uint = 256;\n-pub const WSASYS_STATUS_LEN: uint = 128;\n+pub use self::GET_FILEEX_INFO_LEVELS::*;\n+pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n+pub use libc::consts::os::extra::{\n+    FILE_ATTRIBUTE_READONLY,\n+    FILE_ATTRIBUTE_DIRECTORY,\n+};\n+\n+pub const WSADESCRIPTION_LEN: usize = 256;\n+pub const WSASYS_STATUS_LEN: usize = 128;\n pub const FIONBIO: libc::c_long = 0x8004667e;\n-pub const FD_SETSIZE: uint = 64;\n+pub const FD_SETSIZE: usize = 64;\n pub const MSG_DONTWAIT: libc::c_int = 0;\n pub const ERROR_ILLEGAL_CHARACTER: libc::c_int = 582;\n pub const ENABLE_ECHO_INPUT: libc::DWORD = 0x4;\n@@ -32,12 +36,15 @@ pub const ENABLE_QUICK_EDIT_MODE: libc::DWORD = 0x40;\n pub const WSA_INVALID_EVENT: WSAEVENT = 0 as WSAEVENT;\n \n pub const FD_ACCEPT: libc::c_long = 0x08;\n-pub const FD_MAX_EVENTS: uint = 10;\n+pub const FD_MAX_EVENTS: usize = 10;\n pub const WSA_INFINITE: libc::DWORD = libc::INFINITE;\n pub const WSA_WAIT_TIMEOUT: libc::DWORD = libc::consts::os::extra::WAIT_TIMEOUT;\n pub const WSA_WAIT_EVENT_0: libc::DWORD = libc::consts::os::extra::WAIT_OBJECT_0;\n pub const WSA_WAIT_FAILED: libc::DWORD = libc::consts::os::extra::WAIT_FAILED;\n \n+pub const ERROR_NO_MORE_FILES: libc::DWORD = 18;\n+pub const TOKEN_READ: libc::DWORD = 0x20008;\n+\n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n pub struct WSADATA {\n@@ -80,7 +87,7 @@ pub struct fd_set {\n }\n \n pub fn fd_set(set: &mut fd_set, s: libc::SOCKET) {\n-    set.fd_array[set.fd_count as uint] = s;\n+    set.fd_array[set.fd_count as usize] = s;\n     set.fd_count += 1;\n }\n \n@@ -110,6 +117,69 @@ pub struct CONSOLE_SCREEN_BUFFER_INFO {\n }\n pub type PCONSOLE_SCREEN_BUFFER_INFO = *mut CONSOLE_SCREEN_BUFFER_INFO;\n \n+#[repr(C)]\n+pub struct WIN32_FILE_ATTRIBUTE_DATA {\n+    pub dwFileAttributes: libc::DWORD,\n+    pub ftCreationTime: libc::FILETIME,\n+    pub ftLastAccessTime: libc::FILETIME,\n+    pub ftLastWriteTime: libc::FILETIME,\n+    pub nFileSizeHigh: libc::DWORD,\n+    pub nFileSizeLow: libc::DWORD,\n+}\n+\n+#[repr(C)]\n+pub struct BY_HANDLE_FILE_INFORMATION {\n+    pub dwFileAttributes: libc::DWORD,\n+    pub ftCreationTime: libc::FILETIME,\n+    pub ftLastAccessTime: libc::FILETIME,\n+    pub ftLastWriteTime: libc::FILETIME,\n+    pub dwVolumeSerialNumber: libc::DWORD,\n+    pub nFileSizeHigh: libc::DWORD,\n+    pub nFileSizeLow: libc::DWORD,\n+    pub nNumberOfLinks: libc::DWORD,\n+    pub nFileIndexHigh: libc::DWORD,\n+    pub nFileIndexLow: libc::DWORD,\n+}\n+\n+pub type LPBY_HANDLE_FILE_INFORMATION = *mut BY_HANDLE_FILE_INFORMATION;\n+\n+#[repr(C)]\n+pub enum GET_FILEEX_INFO_LEVELS {\n+    GetFileExInfoStandard,\n+    GetFileExMaxInfoLevel\n+}\n+\n+#[repr(C)]\n+pub enum FILE_INFO_BY_HANDLE_CLASS {\n+    FileBasicInfo                   = 0,\n+    FileStandardInfo                = 1,\n+    FileNameInfo                    = 2,\n+    FileRenameInfo                  = 3,\n+    FileDispositionInfo             = 4,\n+    FileAllocationInfo              = 5,\n+    FileEndOfFileInfo               = 6,\n+    FileStreamInfo                  = 7,\n+    FileCompressionInfo             = 8,\n+    FileAttributeTagInfo            = 9,\n+    FileIdBothDirectoryInfo         = 10, // 0xA\n+    FileIdBothDirectoryRestartInfo  = 11, // 0xB\n+    FileIoPriorityHintInfo          = 12, // 0xC\n+    FileRemoteProtocolInfo          = 13, // 0xD\n+    FileFullDirectoryInfo           = 14, // 0xE\n+    FileFullDirectoryRestartInfo    = 15, // 0xF\n+    FileStorageInfo                 = 16, // 0x10\n+    FileAlignmentInfo               = 17, // 0x11\n+    FileIdInfo                      = 18, // 0x12\n+    FileIdExtdDirectoryInfo         = 19, // 0x13\n+    FileIdExtdDirectoryRestartInfo  = 20, // 0x14\n+    MaximumFileInfoByHandlesClass\n+}\n+\n+#[repr(C)]\n+pub struct FILE_END_OF_FILE_INFO {\n+    pub EndOfFile: libc::LARGE_INTEGER,\n+}\n+\n #[link(name = \"ws2_32\")]\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: libc::WORD,\n@@ -156,31 +226,29 @@ extern \"system\" {\n }\n \n pub mod compat {\n-    use intrinsics::{atomic_store_relaxed, transmute};\n-    use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n     use prelude::v1::*;\n+\n     use ffi::CString;\n+    use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n+    use sync::atomic::{AtomicUsize, Ordering};\n \n     extern \"system\" {\n         fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n         fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n     }\n \n-    // store_func() is idempotent, so using relaxed ordering for the atomics\n-    // should be enough.  This way, calling a function in this compatibility\n-    // layer (after it's loaded) shouldn't be any slower than a regular DLL\n-    // call.\n-    unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) {\n+    fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n+                  fallback: usize) -> usize {\n         let mut module: Vec<u16> = module.utf16_units().collect();\n         module.push(0);\n         let symbol = CString::from_slice(symbol.as_bytes());\n-        let handle = GetModuleHandleW(module.as_ptr());\n-        let func: uint = transmute(GetProcAddress(handle, symbol.as_ptr()));\n-        atomic_store_relaxed(ptr, if func == 0 {\n-            fallback\n-        } else {\n-            func\n-        })\n+        let func = unsafe {\n+            let handle = GetModuleHandleW(module.as_ptr());\n+            GetProcAddress(handle, symbol.as_ptr()) as usize\n+        };\n+        let value = if func == 0 {fallback} else {func};\n+        ptr.store(value, Ordering::SeqCst);\n+        value\n     }\n \n     /// Macro for creating a compatibility fallback for a Windows function\n@@ -192,29 +260,36 @@ pub mod compat {\n     /// })\n     /// ```\n     ///\n-    /// Note that arguments unused by the fallback implementation should not be called `_` as\n-    /// they are used to be passed to the real function if available.\n+    /// Note that arguments unused by the fallback implementation should not be\n+    /// called `_` as they are used to be passed to the real function if\n+    /// available.\n     macro_rules! compat_fn {\n         ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*)\n                                       -> $rettype:ty { $fallback:expr }) => (\n             #[inline(always)]\n             pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n-                static mut ptr: extern \"system\" fn($($argname: $argtype),*) -> $rettype = thunk;\n-\n-                extern \"system\" fn thunk($($argname: $argtype),*) -> $rettype {\n-                    unsafe {\n-                        ::sys::c::compat::store_func(&mut ptr as *mut _ as *mut uint,\n-                                                    stringify!($module),\n-                                                    stringify!($symbol),\n-                                                    fallback as uint);\n-                        ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n-                    }\n+                use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+                use mem;\n+\n+                static PTR: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+                fn load() -> usize {\n+                    ::sys::c::compat::store_func(&PTR,\n+                                                 stringify!($module),\n+                                                 stringify!($symbol),\n+                                                 fallback as usize)\n                 }\n \n                 extern \"system\" fn fallback($($argname: $argtype),*)\n                                             -> $rettype { $fallback }\n \n-                ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                let addr = match PTR.load(Ordering::SeqCst) {\n+                    0 => load(),\n+                    n => n,\n+                };\n+                let f: extern \"system\" fn($($argtype),*) -> $rettype =\n+                    mem::transmute(addr);\n+                f($($argname),*)\n             }\n         )\n     }\n@@ -229,10 +304,7 @@ pub mod compat {\n         use libc::c_uint;\n         use libc::types::os::arch::extra::{DWORD, LPCWSTR, BOOLEAN, HANDLE};\n         use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n-\n-        extern \"system\" {\n-            fn SetLastError(dwErrCode: DWORD);\n-        }\n+        use sys::c::SetLastError;\n \n         compat_fn! {\n             kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n@@ -282,4 +354,42 @@ extern \"system\" {\n         hConsoleOutput: libc::HANDLE,\n         lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO,\n     ) -> libc::BOOL;\n+\n+    pub fn GetFileAttributesExW(lpFileName: libc::LPCWSTR,\n+                                fInfoLevelId: GET_FILEEX_INFO_LEVELS,\n+                                lpFileInformation: libc::LPVOID) -> libc::BOOL;\n+    pub fn RemoveDirectoryW(lpPathName: libc::LPCWSTR) -> libc::BOOL;\n+    pub fn SetFileAttributesW(lpFileName: libc::LPCWSTR,\n+                              dwFileAttributes: libc::DWORD) -> libc::BOOL;\n+    pub fn GetFileAttributesW(lpFileName: libc::LPCWSTR) -> libc::DWORD;\n+    pub fn GetFileInformationByHandle(hFile: libc::HANDLE,\n+                            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION)\n+                            -> libc::BOOL;\n+\n+    pub fn SetLastError(dwErrCode: libc::DWORD);\n+    pub fn GetCommandLineW() -> *mut libc::LPCWSTR;\n+    pub fn LocalFree(ptr: *mut libc::c_void);\n+    pub fn CommandLineToArgvW(lpCmdLine: *mut libc::LPCWSTR,\n+                              pNumArgs: *mut libc::c_int) -> *mut *mut u16;\n+    pub fn SetFileTime(hFile: libc::HANDLE,\n+                       lpCreationTime: *const libc::FILETIME,\n+                       lpLastAccessTime: *const libc::FILETIME,\n+                       lpLastWriteTime: *const libc::FILETIME) -> libc::BOOL;\n+    pub fn SetFileInformationByHandle(hFile: libc::HANDLE,\n+                    FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n+                    lpFileInformation: libc::LPVOID,\n+                    dwBufferSize: libc::DWORD) -> libc::BOOL;\n+    pub fn GetTempPathW(nBufferLength: libc::DWORD,\n+                        lpBuffer: libc::LPCWSTR) -> libc::DWORD;\n+    pub fn OpenProcessToken(ProcessHandle: libc::HANDLE,\n+                            DesiredAccess: libc::DWORD,\n+                            TokenHandle: *mut libc::HANDLE) -> libc::BOOL;\n+    pub fn GetCurrentProcess() -> libc::HANDLE;\n+}\n+\n+#[link(name = \"userenv\")]\n+extern \"system\" {\n+    pub fn GetUserProfileDirectoryW(hToken: libc::HANDLE,\n+                                    lpProfileDir: libc::LPCWSTR,\n+                                    lpcchSize: *mut libc::DWORD) -> libc::BOOL;\n }"}, {"sha": "304d7e015327960747c3fc6dbb0e413d4b5845fd", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -10,20 +10,15 @@\n \n //! Blocking Windows-based file I/O\n \n-use alloc::arc::Arc;\n use libc::{self, c_int};\n \n use mem;\n-use sys::os::fill_utf16_buf_and_decode;\n-use path;\n use ptr;\n-use str;\n use old_io;\n \n use prelude::v1::*;\n use sys;\n-use sys::os;\n-use sys_common::{keep_going, eof, mkerr_libc};\n+use sys_common::{mkerr_libc};\n \n use old_io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use old_io::{IoResult, IoError, FileStat, SeekStyle};\n@@ -262,7 +257,7 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n             let mut more_files = 1 as libc::BOOL;\n             while more_files != 0 {\n                 {\n-                    let filename = os::truncate_utf16_at_nul(&wfd.cFileName);\n+                    let filename = super::truncate_utf16_at_nul(&wfd.cFileName);\n                     match String::from_utf16(filename) {\n                         Ok(filename) => paths.push(Path::new(filename)),\n                         Err(..) => {\n@@ -368,19 +363,12 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n     }\n     // Specify (sz - 1) because the documentation states that it's the size\n     // without the null pointer\n-    let ret = fill_utf16_buf_and_decode(|buf, sz| unsafe {\n+    let ret = super::fill_utf16_buf(|buf, sz| unsafe {\n         GetFinalPathNameByHandleW(handle,\n                                   buf as *const u16,\n                                   sz - 1,\n                                   libc::VOLUME_NAME_DOS)\n-    });\n-    let ret = match ret {\n-        Some(ref s) if s.starts_with(r\"\\\\?\\\") => { // \"\n-            Ok(Path::new(&s[4..]))\n-        }\n-        Some(s) => Ok(Path::new(s)),\n-        None => Err(super::last_error()),\n-    };\n+    }, super::os2path);\n     assert!(unsafe { libc::CloseHandle(handle) } != 0);\n     return ret;\n }"}, {"sha": "6737eeef12532604554536076e75b641197bdd69", "filename": "src/libstd/sys/windows/handle.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use libc::{self, HANDLE};\n+\n+pub struct Handle(HANDLE);\n+\n+unsafe impl Send for Handle {}\n+unsafe impl Sync for Handle {}\n+\n+impl Handle {\n+    pub fn new(handle: HANDLE) -> Handle {\n+        Handle(handle)\n+    }\n+}\n+\n+impl Drop for Handle {\n+    fn drop(&mut self) {\n+        unsafe { let _ = libc::CloseHandle(self.0); }\n+    }\n+}\n+"}, {"sha": "8dd467eba9e2a885e5ffff07ee34ec4d28d08e26", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 92, "deletions": 19, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -11,18 +11,14 @@\n #![allow(missing_docs)]\n #![allow(non_camel_case_types)]\n #![allow(non_snake_case)]\n-#![allow(unused_imports)]\n-#![allow(dead_code)]\n-#![allow(unused_unsafe)]\n-#![allow(unused_mut)]\n-\n-extern crate libc;\n \n use prelude::v1::*;\n \n-use num;\n+use ffi::OsStr;\n+use libc;\n use mem;\n use old_io::{self, IoResult, IoError};\n+use os::windows::OsStrExt;\n use sync::{Once, ONCE_INIT};\n \n macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n@@ -38,22 +34,23 @@ macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n \n pub mod backtrace;\n pub mod c;\n-pub mod ext;\n pub mod condvar;\n+pub mod ext;\n pub mod fs;\n+pub mod handle;\n pub mod helper_signal;\n pub mod mutex;\n pub mod os;\n pub mod os_str;\n pub mod pipe;\n pub mod process;\n pub mod rwlock;\n-pub mod sync;\n pub mod stack_overflow;\n+pub mod sync;\n pub mod tcp;\n-pub mod time;\n pub mod thread;\n pub mod thread_local;\n+pub mod time;\n pub mod timer;\n pub mod tty;\n pub mod udp;\n@@ -158,7 +155,7 @@ pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n \n pub fn wouldblock() -> bool {\n     let err = os::errno();\n-    err == libc::WSAEWOULDBLOCK as uint\n+    err == libc::WSAEWOULDBLOCK as i32\n }\n \n pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n@@ -191,17 +188,93 @@ pub fn unimpl() -> IoError {\n     }\n }\n \n-pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n+fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n     match s {\n-        Some(s) => Ok({\n-            let mut s = s.utf16_units().collect::<Vec<u16>>();\n-            s.push(0);\n-            s\n-        }),\n+        Some(s) => Ok(to_utf16_os(OsStr::from_str(s))),\n         None => Err(IoError {\n             kind: old_io::InvalidInput,\n             desc: \"valid unicode input required\",\n-            detail: None\n-        })\n+            detail: None,\n+        }),\n+    }\n+}\n+\n+fn to_utf16_os(s: &OsStr) -> Vec<u16> {\n+    let mut v: Vec<_> = s.encode_wide().collect();\n+    v.push(0);\n+    v\n+}\n+\n+// Many Windows APIs follow a pattern of where we hand the a buffer and then\n+// they will report back to us how large the buffer should be or how many bytes\n+// currently reside in the buffer. This function is an abstraction over these\n+// functions by making them easier to call.\n+//\n+// The first callback, `f1`, is yielded a (pointer, len) pair which can be\n+// passed to a syscall. The `ptr` is valid for `len` items (u16 in this case).\n+// The closure is expected to return what the syscall returns which will be\n+// interpreted by this function to determine if the syscall needs to be invoked\n+// again (with more buffer space).\n+//\n+// Once the syscall has completed (errors bail out early) the second closure is\n+// yielded the data which has been read from the syscall. The return value\n+// from this closure is then the return value of the function.\n+fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> IoResult<T>\n+    where F1: FnMut(*mut u16, libc::DWORD) -> libc::DWORD,\n+          F2: FnOnce(&[u16]) -> T\n+{\n+    // Start off with a stack buf but then spill over to the heap if we end up\n+    // needing more space.\n+    let mut stack_buf = [0u16; 512];\n+    let mut heap_buf = Vec::new();\n+    unsafe {\n+        let mut n = stack_buf.len();\n+        loop {\n+            let buf = if n <= stack_buf.len() {\n+                &mut stack_buf[]\n+            } else {\n+                let extra = n - heap_buf.len();\n+                heap_buf.reserve(extra);\n+                heap_buf.set_len(n);\n+                &mut heap_buf[]\n+            };\n+\n+            // This function is typically called on windows API functions which\n+            // will return the correct length of the string, but these functions\n+            // also return the `0` on error. In some cases, however, the\n+            // returned \"correct length\" may actually be 0!\n+            //\n+            // To handle this case we call `SetLastError` to reset it to 0 and\n+            // then check it again if we get the \"0 error value\". If the \"last\n+            // error\" is still 0 then we interpret it as a 0 length buffer and\n+            // not an actual error.\n+            c::SetLastError(0);\n+            let k = match f1(buf.as_mut_ptr(), n as libc::DWORD) {\n+                0 if libc::GetLastError() == 0 => 0,\n+                0 => return Err(IoError::last_error()),\n+                n => n,\n+            } as usize;\n+            if k == n && libc::GetLastError() ==\n+                            libc::ERROR_INSUFFICIENT_BUFFER as libc::DWORD {\n+                n *= 2;\n+            } else if k >= n {\n+                n = k;\n+            } else {\n+                return Ok(f2(&buf[..k]))\n+            }\n+        }\n+    }\n+}\n+\n+fn os2path(s: &[u16]) -> Path {\n+    // FIXME: this should not be a panicking conversion (aka path reform)\n+    Path::new(String::from_utf16(s).unwrap())\n+}\n+\n+pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n+    match v.iter().position(|c| *c == 0) {\n+        // don't include the 0\n+        Some(i) => &v[..i],\n+        None => v\n     }\n }"}, {"sha": "75495efc7cbb60f9d2a7f12ffa78980f2540ab39", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -37,8 +37,6 @@ pub unsafe fn raw(m: &Mutex) -> ffi::PSRWLOCK {\n // no guarantees of fairness.\n \n impl Mutex {\n-    #[inline]\n-    pub unsafe fn new() -> Mutex { MUTEX_INIT }\n     #[inline]\n     pub unsafe fn lock(&self) {\n         ffi::AcquireSRWLockExclusive(self.inner.get())"}, {"sha": "c71e2d057c35117af1cea05e2506f25fdf2f075a", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 246, "deletions": 207, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -10,48 +10,32 @@\n \n //! Implementation of `std::os` functionality for Windows\n \n-// FIXME: move various extern bindings from here into liblibc or\n-// something similar\n+#![allow(bad_style)]\n \n use prelude::v1::*;\n+use os::windows::*;\n \n+use error::Error as StdError;\n+use ffi::{OsString, OsStr, AsOsStr};\n use fmt;\n-use old_io::{IoResult, IoError};\n-use iter::repeat;\n-use libc::{c_int, c_void};\n-use libc;\n-use os;\n-use path::BytesContainer;\n+use iter::Range;\n+use libc::types::os::arch::extra::LPWCH;\n+use libc::{self, c_int, c_void};\n+use mem;\n+use old_io::{IoError, IoResult};\n use ptr;\n use slice;\n+use sys::c;\n use sys::fs::FileDesc;\n+use sys::handle::Handle as RawHandle;\n \n-use os::TMPBUF_SZ;\n-use libc::types::os::arch::extra::DWORD;\n+use libc::funcs::extra::kernel32::{\n+    GetEnvironmentStringsW,\n+    FreeEnvironmentStringsW\n+};\n \n-const BUF_BYTES : uint = 2048u;\n-\n-/// Return a slice of `v` ending at (and not including) the first NUL\n-/// (0).\n-pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n-    match v.iter().position(|c| *c == 0) {\n-        // don't include the 0\n-        Some(i) => &v[..i],\n-        None => v\n-    }\n-}\n-\n-pub fn errno() -> uint {\n-    use libc::types::os::arch::extra::DWORD;\n-\n-    #[link_name = \"kernel32\"]\n-    extern \"system\" {\n-        fn GetLastError() -> DWORD;\n-    }\n-\n-    unsafe {\n-        GetLastError() as uint\n-    }\n+pub fn errno() -> i32 {\n+    unsafe { libc::GetLastError() as i32 }\n }\n \n /// Get a detailed string description for the given error number\n@@ -80,7 +64,7 @@ pub fn error_string(errnum: i32) -> String {\n     // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n     let langId = 0x0800 as DWORD;\n \n-    let mut buf = [0 as WCHAR; TMPBUF_SZ];\n+    let mut buf = [0 as WCHAR; 2048];\n \n     unsafe {\n         let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n@@ -94,200 +78,170 @@ pub fn error_string(errnum: i32) -> String {\n         if res == 0 {\n             // Sometimes FormatMessageW can fail e.g. system doesn't like langId,\n             let fm_err = errno();\n-            return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n+            return format!(\"OS Error {} (FormatMessageW() returned error {})\",\n+                           errnum, fm_err);\n         }\n \n-        let msg = String::from_utf16(truncate_utf16_at_nul(&buf));\n+        let b = buf.iter().position(|&b| b == 0).unwrap_or(buf.len());\n+        let msg = String::from_utf16(&buf[..b]);\n         match msg {\n-            Ok(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n+            Ok(msg) => msg,\n             Err(..) => format!(\"OS Error {} (FormatMessageW() returned \\\n                                 invalid UTF-16)\", errnum),\n         }\n     }\n }\n \n-pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n-    // Windows pipes work subtly differently than unix pipes, and their\n-    // inheritance has to be handled in a different way that I do not\n-    // fully understand. Here we explicitly make the pipe non-inheritable,\n-    // which means to pass it to a subprocess they need to be duplicated\n-    // first, as in std::run.\n-    let mut fds = [0; 2];\n-    match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n-                     (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n-        0 => {\n-            assert!(fds[0] != -1 && fds[0] != 0);\n-            assert!(fds[1] != -1 && fds[1] != 0);\n-            Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n-        }\n-        _ => Err(IoError::last_error()),\n-    }\n+pub struct Env {\n+    base: LPWCH,\n+    cur: LPWCH,\n }\n \n-pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n-    F: FnMut(*mut u16, DWORD) -> DWORD,\n-{\n-    unsafe {\n-        let mut n = TMPBUF_SZ as DWORD;\n-        let mut res = None;\n-        let mut done = false;\n-        while !done {\n-            let mut buf: Vec<u16> = repeat(0u16).take(n as uint).collect();\n-            let k = f(buf.as_mut_ptr(), n);\n-            if k == (0 as DWORD) {\n-                done = true;\n-            } else if k == n &&\n-                      libc::GetLastError() ==\n-                      libc::ERROR_INSUFFICIENT_BUFFER as DWORD {\n-                n *= 2 as DWORD;\n-            } else if k >= n {\n-                n = k;\n-            } else {\n-                done = true;\n-            }\n-            if k != 0 && done {\n-                let sub = &buf[.. (k as uint)];\n-                // We want to explicitly catch the case when the\n-                // closure returned invalid UTF-16, rather than\n-                // set `res` to None and continue.\n-                let s = String::from_utf16(sub).ok()\n-                    .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n-                res = Some(s)\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        unsafe {\n+            if *self.cur == 0 { return None }\n+            let p = &*self.cur;\n+            let mut len = 0;\n+            while *(p as *const _).offset(len) != 0 {\n+                len += 1;\n             }\n+            let p = p as *const u16;\n+            let s = slice::from_raw_buf(&p, len as usize);\n+            self.cur = self.cur.offset(len + 1);\n+\n+            let (k, v) = match s.iter().position(|&b| b == '=' as u16) {\n+                Some(n) => (&s[..n], &s[n+1..]),\n+                None => (s, &[][]),\n+            };\n+            Some((OsStringExt::from_wide(k), OsStringExt::from_wide(v)))\n         }\n-        return res;\n     }\n }\n \n-pub fn getcwd() -> IoResult<Path> {\n-    use libc::DWORD;\n-    use libc::GetCurrentDirectoryW;\n-    use old_io::OtherIoError;\n+impl Drop for Env {\n+    fn drop(&mut self) {\n+        unsafe { FreeEnvironmentStringsW(self.base); }\n+    }\n+}\n \n-    let mut buf = [0 as u16; BUF_BYTES];\n+pub fn env() -> Env {\n     unsafe {\n-        if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n-            return Err(IoError::last_error());\n+        let ch = GetEnvironmentStringsW();\n+        if ch as usize == 0 {\n+            panic!(\"failure getting env string from OS: {}\",\n+                   IoError::last_error());\n         }\n+        Env { base: ch, cur: ch }\n     }\n+}\n \n-    match String::from_utf16(truncate_utf16_at_nul(&buf)) {\n-        Ok(ref cwd) => Ok(Path::new(cwd)),\n-        Err(..) => Err(IoError {\n-            kind: OtherIoError,\n-            desc: \"GetCurrentDirectoryW returned invalid UTF-16\",\n-            detail: None,\n-        }),\n-    }\n+pub struct SplitPaths<'a> {\n+    data: EncodeWide<'a>,\n+    must_yield: bool,\n }\n \n-pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-    use libc::funcs::extra::kernel32::{\n-        GetEnvironmentStringsW,\n-        FreeEnvironmentStringsW\n-    };\n-    let ch = GetEnvironmentStringsW();\n-    if ch as uint == 0 {\n-        panic!(\"os::env() failure getting env string from OS: {}\",\n-               os::last_os_error());\n+pub fn split_paths(unparsed: &OsStr) -> SplitPaths {\n+    SplitPaths {\n+        data: unparsed.encode_wide(),\n+        must_yield: true,\n     }\n-    // Here, we lossily decode the string as UTF16.\n-    //\n-    // The docs suggest that the result should be in Unicode, but\n-    // Windows doesn't guarantee it's actually UTF16 -- it doesn't\n-    // validate the environment string passed to CreateProcess nor\n-    // SetEnvironmentVariable.  Yet, it's unlikely that returning a\n-    // raw u16 buffer would be of practical use since the result would\n-    // be inherently platform-dependent and introduce additional\n-    // complexity to this code.\n-    //\n-    // Using the non-Unicode version of GetEnvironmentStrings is even\n-    // worse since the result is in an OEM code page.  Characters that\n-    // can't be encoded in the code page would be turned into question\n-    // marks.\n-    let mut result = Vec::new();\n-    let mut i = 0;\n-    while *ch.offset(i) != 0 {\n-        let p = &*ch.offset(i);\n-        let mut len = 0;\n-        while *(p as *const _).offset(len) != 0 {\n-            len += 1;\n-        }\n-        let p = p as *const u16;\n-        let s = slice::from_raw_buf(&p, len as uint);\n-        result.push(String::from_utf16_lossy(s).into_bytes());\n-        i += len as int + 1;\n-    }\n-    FreeEnvironmentStringsW(ch);\n-    result\n }\n \n-pub fn split_paths(unparsed: &[u8]) -> Vec<Path> {\n-    // On Windows, the PATH environment variable is semicolon separated.  Double\n-    // quotes are used as a way of introducing literal semicolons (since\n-    // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n-    // permitted in path names, so there is no way to escape a double quote.\n-    // Quoted regions can appear in arbitrary locations, so\n-    //\n-    //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n-    //\n-    // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n-    //\n-    // (The above is based on testing; there is no clear reference available\n-    // for the grammar.)\n-\n-    let mut parsed = Vec::new();\n-    let mut in_progress = Vec::new();\n-    let mut in_quote = false;\n-\n-    for b in unparsed.iter() {\n-        match *b {\n-            b';' if !in_quote => {\n-                parsed.push(Path::new(in_progress.as_slice()));\n-                in_progress.truncate(0)\n-            }\n-            b'\"' => {\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = Path;\n+    fn next(&mut self) -> Option<Path> {\n+        // On Windows, the PATH environment variable is semicolon separated.\n+        // Double quotes are used as a way of introducing literal semicolons\n+        // (since c:\\some;dir is a valid Windows path). Double quotes are not\n+        // themselves permitted in path names, so there is no way to escape a\n+        // double quote.  Quoted regions can appear in arbitrary locations, so\n+        //\n+        //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n+        //\n+        // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n+        //\n+        // (The above is based on testing; there is no clear reference available\n+        // for the grammar.)\n+\n+\n+        let must_yield = self.must_yield;\n+        self.must_yield = false;\n+\n+        let mut in_progress = Vec::new();\n+        let mut in_quote = false;\n+        for b in self.data.by_ref() {\n+            if b == '\"' as u16 {\n                 in_quote = !in_quote;\n+            } else if b == ';' as u16 && !in_quote {\n+                self.must_yield = true;\n+                break\n+            } else {\n+                in_progress.push(b)\n             }\n-            _  => {\n-                in_progress.push(*b);\n-            }\n+        }\n+\n+        if !must_yield && in_progress.is_empty() {\n+            None\n+        } else {\n+            Some(super::os2path(&in_progress[]))\n         }\n     }\n-    parsed.push(Path::new(in_progress));\n-    parsed\n }\n \n-pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+#[derive(Show)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsOsStr\n+{\n     let mut joined = Vec::new();\n-    let sep = b';';\n+    let sep = b';' as u16;\n \n-    for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+    for (i, path) in paths.enumerate() {\n+        let path = path.as_os_str();\n         if i > 0 { joined.push(sep) }\n-        if path.contains(&b'\"') {\n-            return Err(\"path segment contains `\\\"`\");\n-        } else if path.contains(&sep) {\n-            joined.push(b'\"');\n-            joined.push_all(path);\n-            joined.push(b'\"');\n+        let v = path.encode_wide().collect::<Vec<u16>>();\n+        if v.contains(&(b'\"' as u16)) {\n+            return Err(JoinPathsError)\n+        } else if v.contains(&sep) {\n+            joined.push(b'\"' as u16);\n+            joined.push_all(&v[]);\n+            joined.push(b'\"' as u16);\n         } else {\n-            joined.push_all(path);\n+            joined.push_all(&v[]);\n         }\n     }\n \n-    Ok(joined)\n+    Ok(OsStringExt::from_wide(&joined[]))\n }\n \n-pub fn load_self() -> Option<Vec<u8>> {\n-    unsafe {\n-        fill_utf16_buf_and_decode(|buf, sz| {\n-            libc::GetModuleFileNameW(ptr::null_mut(), buf, sz)\n-        }).map(|s| s.to_string().into_bytes())\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"path segment contains `\\\"`\".fmt(f)\n     }\n }\n \n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str { \"failed to join paths\" }\n+}\n+\n+pub fn current_exe() -> IoResult<Path> {\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        libc::GetModuleFileNameW(ptr::null_mut(), buf, sz)\n+    }, super::os2path)\n+}\n+\n+pub fn getcwd() -> IoResult<Path> {\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        libc::GetCurrentDirectoryW(sz, buf)\n+    }, super::os2path)\n+}\n+\n pub fn chdir(p: &Path) -> IoResult<()> {\n-    let mut p = p.as_str().unwrap().utf16_units().collect::<Vec<u16>>();\n+    let mut p = p.as_os_str().encode_wide().collect::<Vec<_>>();\n     p.push(0);\n \n     unsafe {\n@@ -298,39 +252,124 @@ pub fn chdir(p: &Path) -> IoResult<()> {\n     }\n }\n \n-pub fn page_size() -> uint {\n-    use mem;\n+pub fn getenv(k: &OsStr) -> Option<OsString> {\n+    let k = super::to_utf16_os(k);\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        libc::GetEnvironmentVariableW(k.as_ptr(), buf, sz)\n+    }, |buf| {\n+        OsStringExt::from_wide(buf)\n+    }).ok()\n+}\n+\n+pub fn setenv(k: &OsStr, v: &OsStr) {\n+    let k = super::to_utf16_os(k);\n+    let v = super::to_utf16_os(v);\n+\n     unsafe {\n-        let mut info = mem::zeroed();\n-        libc::GetSystemInfo(&mut info);\n+        if libc::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr()) == 0 {\n+            panic!(\"failed to set env: {}\", IoError::last_error());\n+        }\n+    }\n+}\n \n-        return info.dwPageSize as uint;\n+pub fn unsetenv(n: &OsStr) {\n+    let v = super::to_utf16_os(n);\n+    unsafe {\n+        if libc::SetEnvironmentVariableW(v.as_ptr(), ptr::null()) == 0 {\n+            panic!(\"failed to unset env: {}\", IoError::last_error());\n+        }\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use super::truncate_utf16_at_nul;\n+pub struct Args {\n+    range: Range<isize>,\n+    cur: *mut *mut u16,\n+}\n \n-    #[test]\n-    fn test_truncate_utf16_at_nul() {\n-        let v = [];\n-        let b: &[u16] = &[];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        self.range.next().map(|i| unsafe {\n+            let ptr = *self.cur.offset(i);\n+            let mut len = 0;\n+            while *ptr.offset(len) != 0 { len += 1; }\n+\n+            // Push it onto the list.\n+            let ptr = ptr as *const u16;\n+            let buf = slice::from_raw_buf(&ptr, len as usize);\n+            OsStringExt::from_wide(buf)\n+        })\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n \n-        let v = [0, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+impl Drop for Args {\n+    fn drop(&mut self) {\n+        unsafe { c::LocalFree(self.cur as *mut c_void); }\n+    }\n+}\n \n-        let v = [1, 0, 3];\n-        let b: &[u16] = &[1];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+pub fn args() -> Args {\n+    unsafe {\n+        let mut nArgs: c_int = 0;\n+        let lpCmdLine = c::GetCommandLineW();\n+        let szArgList = c::CommandLineToArgvW(lpCmdLine, &mut nArgs);\n \n-        let v = [1, 2, 0];\n-        let b: &[u16] = &[1, 2];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+        Args { cur: szArgList, range: range(0, nArgs as isize) }\n+    }\n+}\n \n-        let v = [1, 2, 3];\n-        let b: &[u16] = &[1, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+pub fn page_size() -> usize {\n+    unsafe {\n+        let mut info = mem::zeroed();\n+        libc::GetSystemInfo(&mut info);\n+        return info.dwPageSize as usize;\n+    }\n+}\n+\n+pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n+    // Windows pipes work subtly differently than unix pipes, and their\n+    // inheritance has to be handled in a different way that I do not\n+    // fully understand. Here we explicitly make the pipe non-inheritable,\n+    // which means to pass it to a subprocess they need to be duplicated\n+    // first, as in std::run.\n+    let mut fds = [0; 2];\n+    match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n+    (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n+        0 => {\n+            assert!(fds[0] != -1 && fds[0] != 0);\n+            assert!(fds[1] != -1 && fds[1] != 0);\n+            Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n+        }\n+        _ => Err(IoError::last_error()),\n     }\n }\n+\n+pub fn temp_dir() -> Path {\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        c::GetTempPathW(sz, buf)\n+    }, super::os2path).unwrap()\n+}\n+\n+pub fn home_dir() -> Option<Path> {\n+    getenv(\"HOME\".as_os_str()).or_else(|| {\n+        getenv(\"USERPROFILE\".as_os_str())\n+    }).map(|os| {\n+        // FIXME: OsString => Path\n+        Path::new(os.to_str().unwrap())\n+    }).or_else(|| unsafe {\n+        let me = c::GetCurrentProcess();\n+        let mut token = ptr::null_mut();\n+        if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {\n+            return None\n+        }\n+        let _handle = RawHandle::new(token);\n+        super::fill_utf16_buf(|buf, mut sz| {\n+            match c::GetUserProfileDirectoryW(token, buf, &mut sz) {\n+                0 if libc::GetLastError() != 0 => 0,\n+                0 => sz,\n+                n => n as libc::DWORD,\n+            }\n+        }, super::os2path).ok()\n+    })\n+}"}, {"sha": "1f228b7d32e35042131cefcbce51e8fab742409a", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -352,7 +352,7 @@ impl UnixStream {\n \n     fn cancel_io(&self) -> IoResult<()> {\n         match unsafe { c::CancelIoEx(self.handle(), ptr::null_mut()) } {\n-            0 if os::errno() == libc::ERROR_NOT_FOUND as uint => {\n+            0 if os::errno() == libc::ERROR_NOT_FOUND as i32 => {\n                 Ok(())\n             }\n             0 => Err(super::last_error()),\n@@ -374,7 +374,7 @@ impl UnixStream {\n         // acquire the lock.\n         //\n         // See comments in close_read() about why this lock is necessary.\n-        let guard = unsafe { self.inner.lock.lock() };\n+        let guard = self.inner.lock.lock();\n         if self.read_closed() {\n             return Err(eof())\n         }\n@@ -392,7 +392,7 @@ impl UnixStream {\n \n         // If our errno doesn't say that the I/O is pending, then we hit some\n         // legitimate error and return immediately.\n-        if os::errno() != libc::ERROR_IO_PENDING as uint {\n+        if os::errno() != libc::ERROR_IO_PENDING as i32 {\n             return Err(super::last_error())\n         }\n \n@@ -417,7 +417,7 @@ impl UnixStream {\n             // If we succeeded, or we failed for some reason other than\n             // CancelIoEx, return immediately\n             if ret != 0 { return Ok(bytes_read as uint) }\n-            if os::errno() != libc::ERROR_OPERATION_ABORTED as uint {\n+            if os::errno() != libc::ERROR_OPERATION_ABORTED as i32 {\n                 return Err(super::last_error())\n             }\n \n@@ -450,7 +450,7 @@ impl UnixStream {\n             // going after we woke up.\n             //\n             // See comments in close_read() about why this lock is necessary.\n-            let guard = unsafe { self.inner.lock.lock() };\n+            let guard = self.inner.lock.lock();\n             if self.write_closed() {\n                 return Err(epipe())\n             }\n@@ -465,7 +465,7 @@ impl UnixStream {\n             drop(guard);\n \n             if ret == 0 {\n-                if err != libc::ERROR_IO_PENDING as uint {\n+                if err != libc::ERROR_IO_PENDING as i32 {\n                     return Err(decode_error_detailed(err as i32))\n                 }\n                 // Process a timeout if one is pending\n@@ -481,7 +481,7 @@ impl UnixStream {\n                 // aborted, then check to see if the write half was actually\n                 // closed or whether we woke up from the read half closing.\n                 if ret == 0 {\n-                    if os::errno() != libc::ERROR_OPERATION_ABORTED as uint {\n+                    if os::errno() != libc::ERROR_OPERATION_ABORTED as i32 {\n                         return Err(super::last_error())\n                     }\n                     if !wait_succeeded.is_ok() {\n@@ -525,14 +525,14 @@ impl UnixStream {\n         // close_read() between steps 1 and 2. By atomically executing steps 1\n         // and 2 with a lock with respect to close_read(), we're guaranteed that\n         // no thread will erroneously sit in a read forever.\n-        let _guard = unsafe { self.inner.lock.lock() };\n+        let _guard = self.inner.lock.lock();\n         self.inner.read_closed.store(true, Ordering::SeqCst);\n         self.cancel_io()\n     }\n \n     pub fn close_write(&mut self) -> IoResult<()> {\n         // see comments in close_read() for why this lock is necessary\n-        let _guard = unsafe { self.inner.lock.lock() };\n+        let _guard = self.inner.lock.lock();\n         self.inner.write_closed.store(true, Ordering::SeqCst);\n         self.cancel_io()\n     }"}, {"sha": "3ca735f7fdfd347bfba8c86d39b9afe345c35bd5", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -10,28 +10,27 @@\n \n use prelude::v1::*;\n \n+use collections::hash_map::Hasher;\n use collections;\n+use env;\n use ffi::CString;\n use hash::Hash;\n-use collections::hash_map::Hasher;\n+use libc::{pid_t, c_void};\n+use libc;\n+use mem;\n use old_io::fs::PathExtensions;\n-use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use old_io::process::{ProcessExit, ExitStatus};\n use old_io::{IoResult, IoError};\n use old_io;\n-use libc::{pid_t, c_void, c_int};\n-use libc;\n-use mem;\n use os;\n use path::BytesContainer;\n use ptr;\n use str;\n-use sys::fs::FileDesc;\n use sync::{StaticMutex, MUTEX_INIT};\n+use sys::fs::FileDesc;\n \n-use sys::fs;\n-use sys::{self, retry, c, wouldblock, set_nonblocking, ms_to_timeval, timer};\n-use sys_common::helper_thread::Helper;\n-use sys_common::{AsInner, mkerr_libc, timeout};\n+use sys::timer;\n+use sys_common::{AsInner, timeout};\n \n pub use sys_common::ProcessConfig;\n \n@@ -106,6 +105,7 @@ impl Process {\n         return ret;\n     }\n \n+    #[allow(deprecated)]\n     pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n@@ -128,7 +128,7 @@ impl Process {\n         use libc::funcs::extra::msvcrt::get_osfhandle;\n \n         use mem;\n-        use iter::{Iterator, IteratorExt};\n+        use iter::IteratorExt;\n         use str::StrExt;\n \n         if cfg.gid().is_some() || cfg.uid().is_some() {\n@@ -142,14 +142,14 @@ impl Process {\n         // To have the spawning semantics of unix/windows stay the same, we need to\n         // read the *child's* PATH if one is provided. See #15149 for more details.\n         let program = cfg.env().and_then(|env| {\n-            for (key, v) in env.iter() {\n+            for (key, v) in env {\n                 if b\"PATH\" != key.container_as_bytes() { continue }\n \n                 // Split the value and test each path to see if the\n                 // program exists.\n-                for path in os::split_paths(v.container_as_bytes()).into_iter() {\n+                for path in os::split_paths(v.container_as_bytes()) {\n                     let path = path.join(cfg.program().as_bytes())\n-                                   .with_extension(os::consts::EXE_EXTENSION);\n+                                   .with_extension(env::consts::EXE_EXTENSION);\n                     if path.exists() {\n                         return Some(CString::from_slice(path.as_vec()))\n                     }\n@@ -372,7 +372,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     let mut cmd = String::new();\n     append_arg(&mut cmd, str::from_utf8(prog.as_bytes()).ok()\n                              .expect(\"expected program name to be utf-8 encoded\"));\n-    for arg in args.iter() {\n+    for arg in args {\n         cmd.push(' ');\n         append_arg(&mut cmd, str::from_utf8(arg.as_bytes()).ok()\n                                 .expect(\"expected argument to be utf-8 encoded\"));\n@@ -437,7 +437,7 @@ fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T\n         Some(env) => {\n             let mut blk = Vec::new();\n \n-            for pair in env.iter() {\n+            for pair in env {\n                 let kv = format!(\"{}={}\",\n                                  pair.0.container_as_str().unwrap(),\n                                  pair.1.container_as_str().unwrap());"}, {"sha": "76fe352ed7717cf6ca623bb693a1fcf48663d5c1", "filename": "src/libstd/sys/windows/rwlock.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -18,9 +18,6 @@ pub const RWLOCK_INIT: RWLock = RWLock {\n };\n \n impl RWLock {\n-    #[inline]\n-    pub unsafe fn new() -> RWLock { RWLOCK_INIT }\n-\n     #[inline]\n     pub unsafe fn read(&self) {\n         ffi::AcquireSRWLockShared(self.inner.get())"}, {"sha": "b0410701ee1012817ece41b7fb16eda28c47cd08", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -14,7 +14,7 @@ use ptr;\n use mem;\n use libc;\n use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n-use sys_common::{stack, thread_info};\n+use sys_common::stack;\n \n pub struct Handler {\n     _data: *mut libc::c_void\n@@ -30,14 +30,6 @@ impl Drop for Handler {\n     fn drop(&mut self) {}\n }\n \n-// get_task_info is called from an exception / signal handler.\n-// It returns the guard page of the current task or 0 if that\n-// guard page doesn't exist. None is returned if there's currently\n-// no local task.\n-unsafe fn get_task_guard_page() -> uint {\n-    thread_info::stack_guard()\n-}\n-\n // This is initialized in init() and only read from after\n static mut PAGE_SIZE: uint = 0;\n "}, {"sha": "7614104c98bf37bd8759f6832b6fcaa39d70b4a9", "filename": "src/libstd/sys/windows/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{BOOL, DWORD, c_void, LPVOID, c_ulong};\n+use libc::{BOOL, DWORD, LPVOID, c_ulong};\n use libc::types::os::arch::extra::BOOLEAN;\n \n pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;"}, {"sha": "4804ca510cb0ba0e9be1b8fffdbd75285e78a703", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -14,12 +14,11 @@ use libc;\n use mem;\n use ptr;\n use prelude::v1::*;\n-use super::{last_error, last_net_error, retry, sock_t};\n+use super::{last_error, last_net_error, sock_t};\n use sync::Arc;\n use sync::atomic::{AtomicBool, Ordering};\n-use sys::fs::FileDesc;\n use sys::{self, c, set_nonblocking, wouldblock, timer};\n-use sys_common::{self, timeout, eof, net};\n+use sys_common::{timeout, eof, net};\n \n pub use sys_common::net::TcpStream;\n \n@@ -202,10 +201,6 @@ impl TcpAcceptor {\n         Err(eof())\n     }\n \n-    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n-        net::sockname(self.socket(), libc::getsockname)\n-    }\n-\n     pub fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }"}, {"sha": "a38dc9b2d340770d643d9539e349abe706044292", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n use boxed::Box;\n use cmp;\n use mem;"}, {"sha": "54a32e43daf5917909e1b5594b7003f646d71fa4", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -233,6 +233,7 @@ unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n     }\n }\n \n+#[allow(dead_code)] // actually called above\n unsafe fn run_dtors() {\n     let mut any_run = true;\n     for _ in 0..5 {\n@@ -248,7 +249,7 @@ unsafe fn run_dtors() {\n             DTOR_LOCK.unlock();\n             ret\n         };\n-        for &(key, dtor) in dtors.iter() {\n+        for &(key, dtor) in &dtors {\n             let ptr = TlsGetValue(key);\n             if !ptr.is_null() {\n                 TlsSetValue(key, ptr::null_mut());"}, {"sha": "d156dd801f974905fa2d2adc64d461bbdd1f7525", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -28,8 +28,6 @@ use ptr;\n \n use old_io::IoResult;\n use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n-use sys::c;\n-use sys::fs::FileDesc;\n use sys_common::helper_thread::Helper;\n \n helper_init! { static HELPER: Helper<Req> }"}, {"sha": "f02c8e49f4188d1b26c783ffcd20ace768c8e8f7", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -38,7 +38,7 @@ use str::from_utf8;\n use super::c::{ENABLE_ECHO_INPUT, ENABLE_EXTENDED_FLAGS};\n use super::c::{ENABLE_INSERT_MODE, ENABLE_LINE_INPUT};\n use super::c::{ENABLE_PROCESSED_INPUT, ENABLE_QUICK_EDIT_MODE};\n-use super::c::{ERROR_ILLEGAL_CHARACTER, CONSOLE_SCREEN_BUFFER_INFO};\n+use super::c::{CONSOLE_SCREEN_BUFFER_INFO};\n use super::c::{ReadConsoleW, WriteConsoleW, GetConsoleMode, SetConsoleMode};\n use super::c::{GetConsoleScreenBufferInfo};\n \n@@ -155,9 +155,6 @@ impl TTY {\n                      (info.srWindow.Bottom + 1 - info.srWindow.Top) as int)),\n         }\n     }\n-\n-    // Let us magically declare this as a TTY\n-    pub fn isatty(&self) -> bool { true }\n }\n \n impl Drop for TTY {"}, {"sha": "d4d777789dd5db204c8b45af81bb5f8e0f453de5", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -425,7 +425,7 @@ mod imp {\n         unsafe extern fn run_dtors(mut ptr: *mut u8) {\n             while !ptr.is_null() {\n                 let list: Box<List> = mem::transmute(ptr);\n-                for &(ptr, dtor) in list.iter() {\n+                for &(ptr, dtor) in &*list {\n                     dtor(ptr);\n                 }\n                 ptr = DTORS.get();"}, {"sha": "de3fa1135b161382d5cb13eb363c026cd72c6aae", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -24,6 +24,7 @@ pub enum Os {\n     OsFreebsd,\n     OsiOS,\n     OsDragonfly,\n+    OsOpenbsd,\n }\n \n #[derive(PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Clone, Copy, Debug)]\n@@ -134,7 +135,8 @@ impl fmt::Display for Os {\n             OsiOS => \"ios\".fmt(f),\n             OsAndroid => \"android\".fmt(f),\n             OsFreebsd => \"freebsd\".fmt(f),\n-            OsDragonfly => \"dragonfly\".fmt(f)\n+            OsDragonfly => \"dragonfly\".fmt(f),\n+            OsOpenbsd => \"openbsd\".fmt(f),\n         }\n     }\n }"}, {"sha": "5535e5911e0c2fd5e85ae763a14dcaef7e18915a", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -730,7 +730,7 @@ impl<'ast> NodeCollector<'ast> {\n     }\n \n     fn visit_fn_decl(&mut self, decl: &'ast FnDecl) {\n-        for a in decl.inputs.iter() {\n+        for a in &decl.inputs {\n             self.insert(a.id, NodeArg(&*a.pat));\n         }\n     }\n@@ -743,7 +743,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent = i.id;\n         match i.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         MethodImplItem(ref m) => {\n                             self.insert(m.id, NodeImplItem(impl_item));\n@@ -755,12 +755,12 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n-                for v in enum_definition.variants.iter() {\n+                for v in &enum_definition.variants {\n                     self.insert(v.node.id, NodeVariant(&**v));\n                 }\n             }\n             ItemForeignMod(ref nm) => {\n-                for nitem in nm.items.iter() {\n+                for nitem in &nm.items {\n                     self.insert(nitem.id, NodeForeignItem(&**nitem));\n                 }\n             }\n@@ -774,13 +774,13 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                 }\n             }\n             ItemTrait(_, _, ref bounds, ref trait_items) => {\n-                for b in bounds.iter() {\n+                for b in &**bounds {\n                     if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n                         self.insert(t.trait_ref.ref_id, NodeItem(i));\n                     }\n                 }\n \n-                for tm in trait_items.iter() {\n+                for tm in trait_items {\n                     match *tm {\n                         RequiredMethod(ref m) => {\n                             self.insert(m.id, NodeTraitItem(tm));"}, {"sha": "c62f76564a7013ada7ba7c1ff4ee0899293d4e66", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -102,6 +102,20 @@ pub fn is_by_value_binop(b: BinOp_) -> bool {\n     }\n }\n \n+/// Returns `true` if the binary operator is symmetric in the sense that LHS\n+/// and RHS must have the same type. So the type of LHS can serve as an hint\n+/// for the type of RHS and vice versa.\n+pub fn is_symmetric_binop(b: BinOp_) -> bool {\n+    match b {\n+        BiAdd | BiSub | BiMul | BiDiv | BiRem |\n+        BiBitXor | BiBitAnd | BiBitOr |\n+        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => {\n+            true\n+        }\n+        _ => false\n+    }\n+}\n+\n /// Returns `true` if the unary operator takes its argument by value\n pub fn is_by_value_unop(u: UnOp) -> bool {\n     match u {\n@@ -302,7 +316,7 @@ pub fn split_trait_methods(trait_methods: &[TraitItem])\n                            -> (Vec<TypeMethod>, Vec<P<Method>> ) {\n     let mut reqd = Vec::new();\n     let mut provd = Vec::new();\n-    for trt_method in trait_methods.iter() {\n+    for trt_method in trait_methods {\n         match *trt_method {\n             RequiredMethod(ref tm) => reqd.push((*tm).clone()),\n             ProvidedMethod(ref m) => provd.push((*m).clone()),\n@@ -322,21 +336,21 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n pub fn operator_prec(op: ast::BinOp_) -> usize {\n   match op {\n       // 'as' sits here with 12\n-      BiMul | BiDiv | BiRem     => 11us,\n-      BiAdd | BiSub             => 10us,\n-      BiShl | BiShr             =>  9us,\n-      BiBitAnd                  =>  8us,\n-      BiBitXor                  =>  7us,\n-      BiBitOr                   =>  6us,\n-      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3us,\n-      BiAnd                     =>  2us,\n-      BiOr                      =>  1us\n+      BiMul | BiDiv | BiRem     => 11,\n+      BiAdd | BiSub             => 10,\n+      BiShl | BiShr             =>  9,\n+      BiBitAnd                  =>  8,\n+      BiBitXor                  =>  7,\n+      BiBitOr                   =>  6,\n+      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3,\n+      BiAnd                     =>  2,\n+      BiOr                      =>  1\n   }\n }\n \n /// Precedence of the `as` operator, which is a binary operator\n /// not appearing in the prior table.\n-pub const AS_PREC: usize = 12us;\n+pub const AS_PREC: usize = 12;\n \n pub fn empty_generics() -> Generics {\n     Generics {\n@@ -391,10 +405,10 @@ pub struct IdVisitor<'a, O:'a> {\n \n impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n     fn visit_generics_helper(&mut self, generics: &Generics) {\n-        for type_parameter in generics.ty_params.iter() {\n+        for type_parameter in &*generics.ty_params {\n             self.operation.visit_id(type_parameter.id)\n         }\n-        for lifetime in generics.lifetimes.iter() {\n+        for lifetime in &generics.lifetimes {\n             self.operation.visit_id(lifetime.lifetime.id)\n         }\n     }\n@@ -430,14 +444,14 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n                     ViewPathSimple(_, _) |\n                     ViewPathGlob(_) => {}\n                     ViewPathList(_, ref paths) => {\n-                        for path in paths.iter() {\n+                        for path in paths {\n                             self.operation.visit_id(path.node.id())\n                         }\n                     }\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n-                for variant in enum_definition.variants.iter() {\n+                for variant in &enum_definition.variants {\n                     self.operation.visit_id(variant.node.id)\n                 }\n             }\n@@ -511,7 +525,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n             visit::FkFnBlock => {}\n         }\n \n-        for argument in function_declaration.inputs.iter() {\n+        for argument in &function_declaration.inputs {\n             self.operation.visit_id(argument.id)\n         }\n "}, {"sha": "301a18892d8e3684d6b6688878550771be4a3f0c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -373,7 +373,7 @@ impl fmt::Display for StabilityLevel {\n fn find_stability_generic<'a,\n                               AM: AttrMetaMethods,\n                               I: Iterator<Item=&'a AM>>\n-                             (diagnostic: &SpanHandler, mut attrs: I, item_sp: Span)\n+                             (diagnostic: &SpanHandler, attrs: I, item_sp: Span)\n                              -> (Option<Stability>, Vec<&'a AM>) {\n \n     let mut stab: Option<Stability> = None;\n@@ -394,7 +394,7 @@ fn find_stability_generic<'a,\n                 let mut feature = None;\n                 let mut since = None;\n                 let mut reason = None;\n-                for meta in metas.iter() {\n+                for meta in metas {\n                     if meta.name().get() == \"feature\" {\n                         match meta.value_str() {\n                             Some(v) => feature = Some(v),\n@@ -490,13 +490,13 @@ fn find_stability_generic<'a,\n pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n                       item_sp: Span) -> Option<Stability> {\n     let (s, used) = find_stability_generic(diagnostic, attrs.iter(), item_sp);\n-    for used in used.into_iter() { mark_used(used) }\n+    for used in used { mark_used(used) }\n     return s;\n }\n \n pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n     let mut set = HashSet::new();\n-    for meta in metas.iter() {\n+    for meta in metas {\n         let name = meta.name();\n \n         if !set.insert(name.clone()) {\n@@ -518,7 +518,7 @@ pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAt\n     match attr.node.value.node {\n         ast::MetaList(ref s, ref items) if *s == \"repr\" => {\n             mark_used(attr);\n-            for item in items.iter() {\n+            for item in items {\n                 match item.node {\n                     ast::MetaWord(ref word) => {\n                         let hint = match word.get() {"}, {"sha": "00857d10f439e763e4cdb3af4cbf160d09f0fc39", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -431,7 +431,7 @@ impl CodeMap {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = Vec::new();\n-        for i in lo.line - 1us..hi.line as usize {\n+        for i in lo.line - 1..hi.line as usize {\n             lines.push(i);\n         };\n         FileLines {file: lo.file, lines: lines}\n@@ -453,7 +453,7 @@ impl CodeMap {\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n-        for fm in self.files.borrow().iter() {\n+        for fm in &*self.files.borrow() {\n             if filename == fm.name {\n                 return fm.clone();\n             }\n@@ -477,7 +477,7 @@ impl CodeMap {\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        for mbc in map.multibyte_chars.borrow().iter() {\n+        for mbc in &*map.multibyte_chars.borrow() {\n             debug!(\"{}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 // every character is at least one byte, so we only\n@@ -499,10 +499,10 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let files = &*files;\n         let len = files.len();\n-        let mut a = 0us;\n+        let mut a = 0;\n         let mut b = len;\n-        while b - a > 1us {\n-            let m = (a + b) / 2us;\n+        while b - a > 1 {\n+            let m = (a + b) / 2;\n             if files[m].start_pos > pos {\n                 b = m;\n             } else {\n@@ -538,12 +538,12 @@ impl CodeMap {\n \n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n-        let mut a = 0us;\n+        let mut a = 0;\n         {\n             let lines = f.lines.borrow();\n             let mut b = lines.len();\n-            while b - a > 1us {\n-                let m = (a + b) / 2us;\n+            while b - a > 1 {\n+                let m = (a + b) / 2;\n                 if (*lines)[m] > pos { b = m; } else { a = m; }\n             }\n         }\n@@ -552,7 +552,7 @@ impl CodeMap {\n \n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n-        let line = a + 1us; // Line numbers start at 1\n+        let line = a + 1; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n         let linebpos = (*f.lines.borrow())[a];\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n@@ -763,7 +763,7 @@ mod test {\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(file_lines.lines[0], 1us);\n+        assert_eq!(file_lines.lines[0], 1);\n     }\n \n     #[test]"}, {"sha": "d22054d8ed0c44a45a5668887a852653ed7e22cc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -25,7 +25,7 @@ use term::WriterWrapper;\n use term;\n \n /// maximum number of lines we will print for each error; arbitrary.\n-static MAX_LINES: usize = 6us;\n+static MAX_LINES: usize = 6;\n \n #[derive(Clone, Copy)]\n pub enum RenderSpan {\n@@ -155,19 +155,19 @@ impl Handler {\n         self.bump_err_count();\n     }\n     pub fn bump_err_count(&self) {\n-        self.err_count.set(self.err_count.get() + 1us);\n+        self.err_count.set(self.err_count.get() + 1);\n     }\n     pub fn err_count(&self) -> usize {\n         self.err_count.get()\n     }\n     pub fn has_errors(&self) -> bool {\n-        self.err_count.get() > 0us\n+        self.err_count.get() > 0\n     }\n     pub fn abort_if_errors(&self) {\n         let s;\n         match self.err_count.get() {\n-          0us => return,\n-          1us => s = \"aborting due to previous error\".to_string(),\n+          0 => return,\n+          1 => s = \"aborting due to previous error\".to_string(),\n           _   => {\n             s = format!(\"aborting due to {} previous errors\",\n                         self.err_count.get());\n@@ -457,43 +457,43 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let mut elided = false;\n     let mut display_lines = &lines.lines[];\n     if display_lines.len() > MAX_LINES {\n-        display_lines = &display_lines[0us..MAX_LINES];\n+        display_lines = &display_lines[0..MAX_LINES];\n         elided = true;\n     }\n     // Print the offending lines\n-    for &line_number in display_lines.iter() {\n+    for &line_number in display_lines {\n         if let Some(line) = fm.get_line(line_number) {\n             try!(write!(&mut err.dst, \"{}:{} {}\\n\", fm.name,\n                         line_number + 1, line));\n         }\n     }\n     if elided {\n-        let last_line = display_lines[display_lines.len() - 1us];\n-        let s = format!(\"{}:{} \", fm.name, last_line + 1us);\n+        let last_line = display_lines[display_lines.len() - 1];\n+        let s = format!(\"{}:{} \", fm.name, last_line + 1);\n         try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n     // FIXME (#3260)\n     // If there's one line at fault we can easily point to the problem\n-    if lines.lines.len() == 1us {\n+    if lines.lines.len() == 1 {\n         let lo = cm.lookup_char_pos(sp.lo);\n-        let mut digits = 0us;\n-        let mut num = (lines.lines[0] + 1us) / 10us;\n+        let mut digits = 0;\n+        let mut num = (lines.lines[0] + 1) / 10;\n \n         // how many digits must be indent past?\n-        while num > 0us { num /= 10us; digits += 1us; }\n+        while num > 0 { num /= 10; digits += 1; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let left = fm.name.len() + digits + lo.col.to_usize() + 3us;\n+        let left = fm.name.len() + digits + lo.col.to_usize() + 3;\n         let mut s = String::new();\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n-        let skip = fm.name.len() + digits + 3us;\n+        let skip = fm.name.len() + digits + 3;\n         for _ in 0..skip {\n             s.push(' ');\n         }\n         if let Some(orig) = fm.get_line(lines.lines[0]) {\n-            for pos in 0us..left - skip {\n+            for pos in 0..left - skip {\n                 let cur_char = orig.as_bytes()[pos] as char;\n                 // Whenever a tab occurs on the previous line, we insert one on\n                 // the error-point-squiggly-line as well (instead of a space).\n@@ -511,7 +511,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n-            let num_squigglies = hi.col.to_usize() - lo.col.to_usize() - 1us;\n+            let num_squigglies = hi.col.to_usize() - lo.col.to_usize() - 1;\n             for _ in 0..num_squigglies {\n                 s.push('~');\n             }\n@@ -550,7 +550,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                         last_line_number + 1, last_line));\n         }\n     } else {\n-        for &line_number in lines.iter() {\n+        for &line_number in lines {\n             if let Some(line) = fm.get_line(line_number) {\n                 try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n                             line_number + 1, line));"}, {"sha": "4e10cc9aacc08cf1e625f3b10e890d5153fb165f", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -25,7 +25,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n         None => return base::DummyResult::expr(sp)\n     };\n     let mut accumulator = String::new();\n-    for e in es.into_iter() {\n+    for e in es {\n         match e.node {\n             ast::ExprLit(ref lit) => {\n                 match lit.node {"}, {"sha": "02982039be0a3bf5a9ed8921bb1407d32d91c205", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -427,7 +427,7 @@ impl<'a> TraitDef<'a> {\n             bounds.push(cx.typarambound(trait_path.clone()));\n \n             // also add in any bounds from the declaration\n-            for declared_bound in ty_param.bounds.iter() {\n+            for declared_bound in &*ty_param.bounds {\n                 bounds.push((*declared_bound).clone());\n             }\n \n@@ -770,7 +770,7 @@ impl<'a> MethodDef<'a> {\n         let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = Vec::new();\n-        for i in 0us..self_args.len() {\n+        for i in 0..self_args.len() {\n             let struct_path= cx.path(DUMMY_SP, vec!( type_ident ));\n             let (pat, ident_expr) =\n                 trait_.create_struct_pattern(cx,\n@@ -859,8 +859,8 @@ impl<'a> MethodDef<'a> {\n     ///             (&A2(ref __self_0),\n     ///              &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n     ///             _ => {\n-    ///                 let __self_vi = match *self { A1(..) => 0us, A2(..) => 1us };\n-    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0us, A2(..) => 1us };\n+    ///                 let __self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n+    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0, A2(..) => 1 };\n     ///                 false\n     ///             }\n     ///         }\n@@ -904,8 +904,8 @@ impl<'a> MethodDef<'a> {\n     ///   (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n     ///   ...\n     ///   _ => {\n-    ///     let __this_vi = match this { Variant1 => 0us, Variant2 => 1us, ... };\n-    ///     let __that_vi = match that { Variant1 => 0us, Variant2 => 1us, ... };\n+    ///     let __this_vi = match this { Variant1 => 0, Variant2 => 1, ... };\n+    ///     let __that_vi = match that { Variant1 => 0, Variant2 => 1, ... };\n     ///     ... // catch-all remainder can inspect above variant index values.\n     ///   }\n     /// }\n@@ -974,7 +974,7 @@ impl<'a> MethodDef<'a> {\n                     subpats.push(p);\n                     idents\n                 };\n-                for self_arg_name in self_arg_names.tail().iter() {\n+                for self_arg_name in self_arg_names.tail() {\n                     let (p, idents) = mk_self_pat(cx, &self_arg_name[]);\n                     subpats.push(p);\n                     self_pats_idents.push(idents);\n@@ -1067,13 +1067,13 @@ impl<'a> MethodDef<'a> {\n             //\n             // ```\n             // let __self0_vi = match   self {\n-            //     A => 0us, B(..) => 1us, C(..) => 2us\n+            //     A => 0, B(..) => 1, C(..) => 2\n             // };\n             // let __self1_vi = match __arg1 {\n-            //     A => 0us, B(..) => 1us, C(..) => 2us\n+            //     A => 0, B(..) => 1, C(..) => 2\n             // };\n             // let __self2_vi = match __arg2 {\n-            //     A => 0us, B(..) => 1us, C(..) => 2us\n+            //     A => 0, B(..) => 1, C(..) => 2\n             // };\n             // ```\n             let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();"}, {"sha": "efd9322661862b480226e6c9abb66ff95e1b2a5a", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -100,7 +100,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         _ => cx.span_bug(trait_span, \"impossible substructure in `derive(Hash)`\")\n     };\n \n-    for &FieldInfo { ref self_, span, .. } in fields.iter() {\n+    for &FieldInfo { ref self_, span, .. } in fields {\n         stmts.push(call_hash(span, self_.clone()));\n     }\n "}, {"sha": "ae7b20f7853fb0bd52f2f1f30142e02c81d848d6", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -93,7 +93,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n \n             let mut arms = Vec::new();\n \n-            for variant in enum_def.variants.iter() {\n+            for variant in &enum_def.variants {\n                 match variant.node.kind {\n                     ast::TupleVariantKind(ref args) => {\n                         if !args.is_empty() {"}, {"sha": "9aa454ae8d5c9c567395e92d4a39c9997be1bb09", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -21,7 +21,7 @@ use ext::base;\n use ext::build::AstBuilder;\n use parse::token;\n \n-use std::os;\n+use std::env;\n \n pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n@@ -30,8 +30,8 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n         Some(v) => v\n     };\n \n-    let e = match os::getenv(&var[]) {\n-      None => {\n+    let e = match env::var_string(&var[]) {\n+      Err(..) => {\n           cx.expr_path(cx.path_all(sp,\n                                    true,\n                                    vec!(cx.ident_of(\"std\"),\n@@ -48,7 +48,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n                                                    ast::MutImmutable)),\n                                    Vec::new()))\n       }\n-      Some(s) => {\n+      Ok(s) => {\n           cx.expr_call_global(sp,\n                               vec!(cx.ident_of(\"std\"),\n                                    cx.ident_of(\"option\"),\n@@ -101,12 +101,12 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    let e = match os::getenv(var.get()) {\n-        None => {\n+    let e = match env::var_string(var.get()) {\n+        Err(..) => {\n             cx.span_err(sp, msg.get());\n             cx.expr_usize(sp, 0)\n         }\n-        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(&s[]))\n+        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s[]))\n     };\n     MacExpr::new(e)\n }"}, {"sha": "6eacb3440189454f279f31b05b9a03e3ac16eed7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -362,7 +362,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n         // in this file.\n         // Token-tree macros:\n         MacInvocTT(pth, tts, _) => {\n-            if pth.segments.len() > 1us {\n+            if pth.segments.len() > 1 {\n                 fld.cx.span_err(pth.span,\n                                 \"expected macro name without module \\\n                                 separators\");\n@@ -504,7 +504,7 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n         return it.expect_item();\n     }\n \n-    for attr in modifiers.iter() {\n+    for attr in &modifiers {\n         let mname = attr.name();\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n@@ -552,7 +552,7 @@ fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Ite\n \n // does this attribute list contain \"macro_use\" ?\n fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool {\n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         let mut is_use = attr.check_name(\"macro_use\");\n         if attr.check_name(\"macro_escape\") {\n             fld.cx.span_warn(attr.span, \"macro_escape is a deprecated synonym for macro_use\");\n@@ -853,7 +853,7 @@ impl<'v> Visitor<'v> for PatIdentFinder {\n             ast::Pat { id: _, node: ast::PatIdent(_, ref path1, ref inner), span: _ } => {\n                 self.ident_accumulator.push(path1.node);\n                 // visit optional subpattern of PatIdent:\n-                for subpat in inner.iter() {\n+                if let Some(ref subpat) = *inner {\n                     self.visit_pat(&**subpat)\n                 }\n             }\n@@ -873,7 +873,7 @@ fn pattern_bindings(pat: &ast::Pat) -> Vec<ast::Ident> {\n /// find the PatIdent paths in a\n fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n     let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n-    for arg in fn_decl.inputs.iter() {\n+    for arg in &fn_decl.inputs {\n         pat_idents.visit_pat(&*arg.pat);\n     }\n     pat_idents.ident_accumulator\n@@ -931,7 +931,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             },\n             _ => unreachable!()\n         };\n-        if pth.segments.len() > 1us {\n+        if pth.segments.len() > 1 {\n             fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n             return DummyResult::raw_pat(span);\n         }\n@@ -1063,7 +1063,7 @@ fn expand_annotatable(a: Annotatable,\n \n     let mut decorator_items = SmallVector::zero();\n     let mut new_attrs = Vec::new();\n-    for attr in a.attrs().iter() {\n+    for attr in a.attrs() {\n         let mname = attr.name();\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n@@ -1218,7 +1218,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n         return it\n     }\n \n-    for attr in modifiers.iter() {\n+    for attr in &modifiers {\n         let mname = attr.name();\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n@@ -1420,11 +1420,11 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     let mut expander = MacroExpander::new(&mut cx);\n \n-    for def in imported_macros.into_iter() {\n+    for def in imported_macros {\n         expander.cx.insert_macro(def);\n     }\n \n-    for (name, extension) in user_exts.into_iter() {\n+    for (name, extension) in user_exts {\n         expander.cx.syntax_env.insert(name, extension);\n     }\n "}, {"sha": "16aaccb0207a2d4beed76bc1e2b6a0c07db2d23f", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                                             self.ecx.expr_ident(e.span, name)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n-        for name in self.name_ordering.iter() {\n+        for name in &self.name_ordering {\n             let e = match self.names.remove(name) {\n                 Some(e) => e,\n                 None => continue\n@@ -706,7 +706,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n             cx.ecx.span_err(cx.args[i].span, \"argument never used\");\n         }\n     }\n-    for (name, e) in cx.names.iter() {\n+    for (name, e) in &cx.names {\n         if !cx.name_types.contains_key(name) {\n             cx.ecx.span_err(e.span, \"named argument never used\");\n         }"}, {"sha": "9092169e1820067e1f7a4833e6e3b29792639626", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -694,7 +694,7 @@ fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n \n fn mk_tts(cx: &ExtCtxt, tts: &[ast::TokenTree]) -> Vec<P<ast::Stmt>> {\n     let mut ss = Vec::new();\n-    for tt in tts.iter() {\n+    for tt in tts {\n         ss.extend(mk_tt(cx, tt).into_iter());\n     }\n     ss\n@@ -709,7 +709,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     // try removing it when enough of them are gone.\n \n     let mut p = cx.new_parser_from_tts(tts);\n-    p.quote_depth += 1us;\n+    p.quote_depth += 1;\n \n     let cx_expr = p.parse_expr();\n     if !p.eat(&token::Comma) {"}, {"sha": "823efdd3eed225362d1f46ac3ab6a47a1dad22fa", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -171,11 +171,11 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n         stack: vec![],\n         top_elts: TtSeq(ms),\n         sep: sep,\n-        idx: 0us,\n+        idx: 0,\n         up: None,\n         matches: matches,\n-        match_lo: 0us,\n-        match_cur: 0us,\n+        match_lo: 0,\n+        match_cur: 0,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n     }\n@@ -209,12 +209,12 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n              ret_val: &mut HashMap<Ident, Rc<NamedMatch>>, idx: &mut usize) {\n         match m {\n             &TtSequence(_, ref seq) => {\n-                for next_m in seq.tts.iter() {\n+                for next_m in &seq.tts {\n                     n_rec(p_s, next_m, res, ret_val, idx)\n                 }\n             }\n             &TtDelimited(_, ref delim) => {\n-                for next_m in delim.tts.iter() {\n+                for next_m in &delim.tts {\n                     n_rec(p_s, next_m, res, ret_val, idx)\n                 }\n             }\n@@ -238,8 +238,8 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    let mut idx = 0us;\n-    for m in ms.iter() { n_rec(p_s, m, res, &mut ret_val, &mut idx) }\n+    let mut idx = 0;\n+    for m in ms { n_rec(p_s, m, res, &mut ret_val, &mut idx) }\n     ret_val\n }\n \n@@ -383,7 +383,7 @@ pub fn parse(sess: &ParseSess,\n                         if seq.op == ast::ZeroOrMore {\n                             let mut new_ei = ei.clone();\n                             new_ei.match_cur += seq.num_captures;\n-                            new_ei.idx += 1us;\n+                            new_ei.idx += 1;\n                             //we specifically matched zero repeats.\n                             for idx in ei.match_cur..ei.match_cur + seq.num_captures {\n                                 (&mut new_ei.matches[idx]).push(Rc::new(MatchedSeq(vec![], sp)));\n@@ -398,7 +398,7 @@ pub fn parse(sess: &ParseSess,\n                         cur_eis.push(box MatcherPos {\n                             stack: vec![],\n                             sep: seq.separator.clone(),\n-                            idx: 0us,\n+                            idx: 0,\n                             matches: matches,\n                             match_lo: ei_t.match_cur,\n                             match_cur: ei_t.match_cur,\n@@ -442,20 +442,20 @@ pub fn parse(sess: &ParseSess,\n \n         /* error messages here could be improved with links to orig. rules */\n         if token_name_eq(&tok, &token::Eof) {\n-            if eof_eis.len() == 1us {\n+            if eof_eis.len() == 1 {\n                 let mut v = Vec::new();\n-                for dv in (&mut eof_eis[0]).matches.iter_mut() {\n+                for dv in &mut (&mut eof_eis[0]).matches {\n                     v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, &v[]));\n-            } else if eof_eis.len() > 1us {\n+            } else if eof_eis.len() > 1 {\n                 return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {\n                 return Failure(sp, \"unexpected end of macro invocation\".to_string());\n             }\n         } else {\n-            if (bb_eis.len() > 0us && next_eis.len() > 0us)\n-                || bb_eis.len() > 1us {\n+            if (bb_eis.len() > 0 && next_eis.len() > 0)\n+                || bb_eis.len() > 1 {\n                 let nts = bb_eis.iter().map(|ei| {\n                     match ei.top_elts.get_tt(ei.idx) {\n                       TtToken(_, MatchNt(bind, name, _, _)) => {\n@@ -469,12 +469,12 @@ pub fn parse(sess: &ParseSess,\n                     \"local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\",\n                     nts, next_eis.len()).to_string());\n-            } else if bb_eis.len() == 0us && next_eis.len() == 0us {\n+            } else if bb_eis.len() == 0 && next_eis.len() == 0 {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n                             pprust::token_to_string(&tok)).to_string());\n-            } else if next_eis.len() > 0us {\n+            } else if next_eis.len() > 0 {\n                 /* Now process the next token */\n-                while next_eis.len() > 0us {\n+                while next_eis.len() > 0 {\n                     cur_eis.push(next_eis.pop().unwrap());\n                 }\n                 rdr.next_token();\n@@ -488,7 +488,7 @@ pub fn parse(sess: &ParseSess,\n                     let match_cur = ei.match_cur;\n                     (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n                         parse_nt(&mut rust_parser, span, name_string.get()))));\n-                    ei.idx += 1us;\n+                    ei.idx += 1;\n                     ei.match_cur += 1;\n                   }\n                   _ => panic!()\n@@ -501,16 +501,16 @@ pub fn parse(sess: &ParseSess,\n             }\n         }\n \n-        assert!(cur_eis.len() > 0us);\n+        assert!(cur_eis.len() > 0);\n     }\n }\n \n pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n     match name {\n         \"tt\" => {\n-            p.quote_depth += 1us; //but in theory, non-quoted tts might be useful\n+            p.quote_depth += 1; //but in theory, non-quoted tts might be useful\n             let res = token::NtTT(P(p.parse_token_tree()));\n-            p.quote_depth -= 1us;\n+            p.quote_depth -= 1;\n             return res;\n         }\n         _ => {}"}, {"sha": "ac9f375e0a4a90535f1aa9ac299423d9c521102d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -259,7 +259,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n-    for lhs in lhses.iter() {\n+    for lhs in &lhses {\n         check_lhs_nt_follows(cx, &**lhs, def.span);\n     }\n "}, {"sha": "83234e3b7a5d8468b55ff442a74c6df9f3e92cfe", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -223,7 +223,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.repeat_len.pop();\n             }\n         } else { /* repeat */\n-            *r.repeat_idx.last_mut().unwrap() += 1us;\n+            *r.repeat_idx.last_mut().unwrap() += 1;\n             r.stack.last_mut().unwrap().idx = 0;\n             match r.stack.last().unwrap().sep.clone() {\n                 Some(tk) => {"}, {"sha": "4e76359e93040d80f731e5f726501f7aed83cc76", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, i: &ast::Item) {\n-        for attr in i.attrs.iter() {\n+        for attr in &i.attrs {\n             if attr.name() == \"thread_local\" {\n                 self.gate_feature(\"thread_local\", i.span,\n                                   \"`#[thread_local]` is an experimental feature, and does not \\\n@@ -508,7 +508,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n \n     let mut unknown_features = Vec::new();\n \n-    for attr in krate.attrs.iter() {\n+    for attr in &krate.attrs {\n         if !attr.check_name(\"feature\") {\n             continue\n         }\n@@ -519,7 +519,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n                                                   expected #![feature(...)]\");\n             }\n             Some(list) => {\n-                for mi in list.iter() {\n+                for mi in list {\n                     let name = match mi.node {\n                         ast::MetaWord(ref word) => (*word).clone(),\n                         _ => {"}, {"sha": "9012ec2114d07462f6b3783183ba3dea8953df6c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -37,7 +37,7 @@ pub trait MoveMap<T> {\n \n impl<T> MoveMap<T> for Vec<T> {\n     fn move_map<F>(mut self, mut f: F) -> Vec<T> where F: FnMut(T) -> T {\n-        for p in self.iter_mut() {\n+        for p in &mut self {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n                 ptr::write(p, f(ptr::read_and_zero(p)));\n@@ -1117,7 +1117,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n         }, vec![], span)\n     };\n \n-    for def in exported_macros.iter_mut() {\n+    for def in &mut exported_macros {\n         def.id = folder.new_id(def.id);\n     }\n "}, {"sha": "08e795ef80d046002a7fd6eb1f40ca6a592b4eab", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -23,16 +23,14 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n-\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(env)]\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n-#![feature(os)]\n #![feature(path)]\n #![feature(quote, unsafe_destructor)]\n #![feature(rustc_private)]"}, {"sha": "06e8728d23672d101463d36144b5c9bee83c6be8", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -13,7 +13,7 @@ use ast;\n use codemap::{spanned, Spanned, mk_sp, Span};\n use parse::common::*; //resolve bug?\n use parse::token;\n-use parse::parser::Parser;\n+use parse::parser::{Parser, TokenType};\n use ptr::P;\n \n /// A parser that can parse attributes.\n@@ -69,7 +69,9 @@ impl<'a> ParserAttr for Parser<'a> {\n                 let lo = self.span.lo;\n                 self.bump();\n \n-                let style = if self.eat(&token::Not) {\n+                if permit_inner { self.expected_tokens.push(TokenType::Token(token::Not)); }\n+                let style = if self.token == token::Not {\n+                    self.bump();\n                     if !permit_inner {\n                         let span = self.span;\n                         self.span_err(span,\n@@ -96,7 +98,8 @@ impl<'a> ParserAttr for Parser<'a> {\n             }\n         };\n \n-        if permit_inner && self.eat(&token::Semi) {\n+        if permit_inner && self.token == token::Semi {\n+            self.bump();\n             self.span_warn(span, \"this inner attribute syntax is deprecated. \\\n                            The new syntax is `#![foo]`, with a bang and no semicolon\");\n             style = ast::AttrInner;"}, {"sha": "b17fc7fe82e6c66b09da7c36c0b9cd80b239fb34", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -62,7 +62,7 @@ pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: Vec<String> ) -> Vec<String> {\n-        let mut i = 0us;\n+        let mut i = 0;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n         if lines.len() > 0 &&\n@@ -90,7 +90,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut i = usize::MAX;\n         let mut can_trim = true;\n         let mut first = true;\n-        for line in lines.iter() {\n+        for line in &lines {\n             for (j, c) in line.chars().enumerate() {\n                 if j > i || !\"* \\t\".contains_char(c) {\n                     can_trim = false;\n@@ -125,7 +125,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n     // one-line comments lose their prefix\n     static ONLINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n-    for prefix in ONLINERS.iter() {\n+    for prefix in ONLINERS {\n         if comment.starts_with(*prefix) {\n             return (&comment[prefix.len()..]).to_string();\n         }\n@@ -158,7 +158,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader,\n                                            comments: &mut Vec<Comment>) {\n     while is_whitespace(rdr.curr) && !rdr.is_eof() {\n-        if rdr.col == CharPos(0us) && rdr.curr_is('\\n') {\n+        if rdr.col == CharPos(0) && rdr.curr_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         rdr.bump();\n@@ -305,7 +305,7 @@ fn read_block_comment(rdr: &mut StringReader,\n \n     let mut style = if code_to_the_left { Trailing } else { Isolated };\n     rdr.consume_non_eol_whitespace();\n-    if !rdr.is_eof() && !rdr.curr_is('\\n') && lines.len() == 1us {\n+    if !rdr.is_eof() && !rdr.curr_is('\\n') && lines.len() == 1 {\n         style = Mixed;\n     }\n     debug!(\"<<< block comment\");"}, {"sha": "e6da47304cee39cebf6ce3b96c34b4007d2ed9b9", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -279,7 +279,7 @@ impl<'a> StringReader<'a> {\n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n     fn translate_crlf<'b>(&self, start: BytePos,\n                           s: &'b str, errmsg: &'b str) -> CowString<'b> {\n-        let mut i = 0us;\n+        let mut i = 0;\n         while i < s.len() {\n             let str::CharRange { ch, next } = s.char_range_at(i);\n             if ch == '\\r' {\n@@ -331,10 +331,10 @@ impl<'a> StringReader<'a> {\n             let byte_offset_diff = next.next - current_byte_offset;\n             self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n             self.curr = Some(next.ch);\n-            self.col = self.col + CharPos(1us);\n+            self.col = self.col + CharPos(1);\n             if last_char == '\\n' {\n                 self.filemap.next_line(self.last_pos);\n-                self.col = CharPos(0us);\n+                self.col = CharPos(0);\n             }\n \n             if byte_offset_diff > 1 {\n@@ -472,7 +472,7 @@ impl<'a> StringReader<'a> {\n                 cmap.files.borrow_mut().push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.last_pos);\n                 debug!(\"Skipping a shebang\");\n-                if loc.line == 1us && loc.col == CharPos(0us) {\n+                if loc.line == 1 && loc.col == CharPos(0) {\n                     // FIXME: Add shebang \"token\", return it\n                     let start = self.last_pos;\n                     while !self.curr_is('\\n') && !self.is_eof() { self.bump(); }\n@@ -646,7 +646,7 @@ impl<'a> StringReader<'a> {\n     /// Scan through any digits (base `radix`) or underscores, and return how\n     /// many digits there were.\n     fn scan_digits(&mut self, radix: usize) -> usize {\n-        let mut len = 0us;\n+        let mut len = 0;\n         loop {\n             let c = self.curr;\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n@@ -799,14 +799,14 @@ impl<'a> StringReader<'a> {\n                                 if self.curr == Some('{') {\n                                     self.scan_unicode_escape(delim)\n                                 } else {\n-                                    let res = self.scan_hex_digits(4us, delim, false);\n+                                    let res = self.scan_hex_digits(4, delim, false);\n                                     let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n                                     self.old_escape_warning(sp);\n                                     res\n                                 }\n                             }\n                             'U' if !ascii_only => {\n-                                let res = self.scan_hex_digits(8us, delim, false);\n+                                let res = self.scan_hex_digits(8, delim, false);\n                                 let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n                                 self.old_escape_warning(sp);\n                                 res\n@@ -877,7 +877,7 @@ impl<'a> StringReader<'a> {\n     fn scan_unicode_escape(&mut self, delim: char) -> bool {\n         self.bump(); // past the {\n         let start_bpos = self.last_pos;\n-        let mut count = 0us;\n+        let mut count = 0;\n         let mut accum_int = 0;\n \n         while !self.curr_is('}') && count <= 6 {\n@@ -937,10 +937,10 @@ impl<'a> StringReader<'a> {\n     /// error if it isn't.\n     fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: usize) {\n         match base {\n-            16us => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n+            16 => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n                                    supported\"),\n-            8us => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n-            2us => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n+            8 => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n+            2 => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n             _   => ()\n         }\n     }\n@@ -1189,7 +1189,7 @@ impl<'a> StringReader<'a> {\n           'r' => {\n             let start_bpos = self.last_pos;\n             self.bump();\n-            let mut hash_count = 0us;\n+            let mut hash_count = 0;\n             while self.curr_is('#') {\n                 self.bump();\n                 hash_count += 1;\n@@ -1374,7 +1374,7 @@ impl<'a> StringReader<'a> {\n     fn scan_raw_byte_string(&mut self) -> token::Lit {\n         let start_bpos = self.last_pos;\n         self.bump();\n-        let mut hash_count = 0us;\n+        let mut hash_count = 0;\n         while self.curr_is('#') {\n             self.bump();\n             hash_count += 1;\n@@ -1526,7 +1526,7 @@ mod test {\n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n     fn check_tokenization (mut string_reader: StringReader, expected: Vec<token::Token> ) {\n-        for expected_tok in expected.iter() {\n+        for expected_tok in &expected {\n             assert_eq!(&string_reader.next_token().tok, expected_tok);\n         }\n     }"}, {"sha": "eecd7d87185434c88501ed2fdcd4365eec2dd30f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7858cb432d3f2efc0374424cb2b51518f697c172/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7858cb432d3f2efc0374424cb2b51518f697c172", "patch": "@@ -181,7 +181,7 @@ pub fn parse_tts_from_source_str(name: String,\n         name,\n         source\n     );\n-    p.quote_depth += 1us;\n+    p.quote_depth += 1;\n     // right now this is re-creating the token trees from ... token trees.\n     maybe_aborted(p.parse_all_token_trees(),p)\n }\n@@ -324,7 +324,7 @@ pub mod with_hygiene {\n             name,\n             source\n         );\n-        p.quote_depth += 1us;\n+        p.quote_depth += 1;\n         // right now this is re-creating the token trees from ... token trees.\n         maybe_aborted(p.parse_all_token_trees(),p)\n     }\n@@ -436,7 +436,7 @@ pub fn str_lit(lit: &str) -> String {\n     let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n-    fn eat<'a>(it: &mut iter::Peekable<(usize, char), str::CharIndices<'a>>) {\n+    fn eat<'a>(it: &mut iter::Peekable<str::CharIndices<'a>>) {\n         loop {\n             match it.peek().map(|x| x.1) {\n                 Some(' ') | Some('\\n') | Some('\\r') | Some('\\t') => {\n@@ -605,7 +605,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n-    fn eat<'a, I: Iterator<Item=(usize, u8)>>(it: &mut iter::Peekable<(usize, u8), I>) {\n+    fn eat<'a, I: Iterator<Item=(usize, u8)>>(it: &mut iter::Peekable<I>) {\n         loop {\n             match it.peek().map(|x| x.1) {\n                 Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') => {\n@@ -683,9 +683,9 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     match suffix {\n         Some(suf) if looks_like_width_suffix(&['f'], suf) => {\n             match base {\n-                16us => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n-                8us => sd.span_err(sp, \"octal float literal is not supported\"),\n-                2us => sd.span_err(sp, \"binary float literal is not supported\"),\n+                16 => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n+                8 => sd.span_err(sp, \"octal float literal is not supported\"),\n+                2 => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n             let ident = token::intern_and_get_ident(&*s);\n@@ -755,6 +755,7 @@ mod test {\n     use ast;\n     use abi;\n     use attr::{first_attr_value_str_by_name, AttrMetaMethods};\n+    use parse;\n     use parse::parser::Parser;\n     use parse::token::{str_to_ident};\n     use print::pprust::item_to_string;\n@@ -1163,7 +1164,7 @@ mod test {\n                     \"impl z { fn a (self: Foo, &myarg: i32) {} }\",\n                     ];\n \n-        for &src in srcs.iter() {\n+        for &src in &srcs {\n             let spans = get_spans_of_pat_idents(src);\n             let Span{ lo, hi, .. } = spans[0];\n             assert!(\"self\" == &src[lo.to_usize()..hi.to_usize()],\n@@ -1214,4 +1215,26 @@ mod test {\n         let doc = first_attr_value_str_by_name(item.attrs.as_slice(), \"doc\").unwrap();\n         assert_eq!(doc.get(), \"/** doc comment\\n *  with CRLF */\");\n     }\n+\n+    #[test]\n+    fn ttdelim_span() {\n+        let sess = parse::new_parse_sess();\n+        let expr = parse::parse_expr_from_source_str(\"foo\".to_string(),\n+            \"foo!( fn main() { body } )\".to_string(), vec![], &sess);\n+\n+        let tts = match expr.node {\n+            ast::ExprMac(ref mac) => {\n+                let ast::MacInvocTT(_, ref tts, _) = mac.node;\n+                tts.clone()\n+            }\n+            _ => panic!(\"not a macro\"),\n+        };\n+\n+        let span = tts.iter().rev().next().unwrap().get_span();\n+\n+        match sess.span_diagnostic.cm.span_to_snippet(span) {\n+            Some(s) => assert_eq!(&s[], \"{ body }\"),\n+            None => panic!(\"could not get snippet\"),\n+        }\n+    }\n }"}]}