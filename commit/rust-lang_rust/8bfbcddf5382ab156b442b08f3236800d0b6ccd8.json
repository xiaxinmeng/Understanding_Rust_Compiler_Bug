{"sha": "8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZmJjZGRmNTM4MmFiMTU2YjQ0MmIwOGYzMjM2ODAwZDBiNmNjZDg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-06T16:13:40Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-08T12:28:25Z"}, "message": "rustdoc: fix fallout from the addition of a 'tcx lifetime on tcx.", "tree": {"sha": "8b1eee8a3cae0bd97bde68c6edc54d342b51be4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b1eee8a3cae0bd97bde68c6edc54d342b51be4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "html_url": "https://github.com/rust-lang/rust/commit/8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7a997be05e364248521ee4d11ab57fcb2e99a40", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7a997be05e364248521ee4d11ab57fcb2e99a40", "html_url": "https://github.com/rust-lang/rust/commit/f7a997be05e364248521ee4d11ab57fcb2e99a40"}], "stats": {"total": 910, "additions": 438, "deletions": 472}, "files": [{"sha": "e0afb80ad37f5ee203f30366849e54d619c19791", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 52, "deletions": 57, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "patch": "@@ -21,7 +21,7 @@ use rustc::middle::ty;\n use rustc::middle::subst;\n use rustc::middle::stability;\n \n-use core;\n+use core::DocContext;\n use doctree;\n use clean;\n \n@@ -39,24 +39,23 @@ use super::Clean;\n ///\n /// The returned value is `None` if the `id` could not be inlined, and `Some`\n /// of a vector of items if it was successfully expanded.\n-pub fn try_inline(id: ast::NodeId, into: Option<ast::Ident>)\n+pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Ident>)\n                   -> Option<Vec<clean::Item>> {\n-    let cx = ::ctxtkey.get().unwrap();\n-    let tcx = match cx.maybe_typed {\n-        core::Typed(ref tycx) => tycx,\n-        core::NotTyped(_) => return None,\n+    let tcx = match cx.tcx_opt() {\n+        Some(tcx) => tcx,\n+        None => return None,\n     };\n     let def = match tcx.def_map.borrow().find(&id) {\n         Some(def) => *def,\n         None => return None,\n     };\n     let did = def.def_id();\n     if ast_util::is_local(did) { return None }\n-    try_inline_def(&**cx, tcx, def).map(|vec| {\n+    try_inline_def(cx, tcx, def).map(|vec| {\n         vec.move_iter().map(|mut item| {\n             match into {\n                 Some(into) if item.name.is_some() => {\n-                    item.name = Some(into.clean());\n+                    item.name = Some(into.clean(cx));\n                 }\n                 _ => {}\n             }\n@@ -65,15 +64,14 @@ pub fn try_inline(id: ast::NodeId, into: Option<ast::Ident>)\n     })\n }\n \n-fn try_inline_def(cx: &core::DocContext,\n-                  tcx: &ty::ctxt,\n+fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n                   def: def::Def) -> Option<Vec<clean::Item>> {\n     let mut ret = Vec::new();\n     let did = def.def_id();\n     let inner = match def {\n         def::DefTrait(did) => {\n             record_extern_fqn(cx, did, clean::TypeTrait);\n-            clean::TraitItem(build_external_trait(tcx, did))\n+            clean::TraitItem(build_external_trait(cx, tcx, did))\n         }\n         def::DefFn(did, style) => {\n             // If this function is a tuple struct constructor, we just skip it\n@@ -82,17 +80,17 @@ fn try_inline_def(cx: &core::DocContext,\n                 return None\n             }\n             record_extern_fqn(cx, did, clean::TypeFunction);\n-            clean::FunctionItem(build_external_function(tcx, did, style))\n+            clean::FunctionItem(build_external_function(cx, tcx, did, style))\n         }\n         def::DefStruct(did) => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n             ret.extend(build_impls(cx, tcx, did).move_iter());\n-            clean::StructItem(build_struct(tcx, did))\n+            clean::StructItem(build_struct(cx, tcx, did))\n         }\n         def::DefTy(did) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n             ret.extend(build_impls(cx, tcx, did).move_iter());\n-            build_type(tcx, did)\n+            build_type(cx, tcx, did)\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n@@ -103,7 +101,7 @@ fn try_inline_def(cx: &core::DocContext,\n         }\n         def::DefStatic(did, mtbl) => {\n             record_extern_fqn(cx, did, clean::TypeStatic);\n-            clean::StaticItem(build_static(tcx, did, mtbl))\n+            clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n         _ => return None,\n     };\n@@ -112,20 +110,21 @@ fn try_inline_def(cx: &core::DocContext,\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n         name: Some(fqn.last().unwrap().to_string()),\n-        attrs: load_attrs(tcx, did),\n+        attrs: load_attrs(cx, tcx, did),\n         inner: inner,\n         visibility: Some(ast::Public),\n-        stability: stability::lookup(tcx, did).clean(),\n+        stability: stability::lookup(tcx, did).clean(cx),\n         def_id: did,\n     });\n     Some(ret)\n }\n \n-pub fn load_attrs(tcx: &ty::ctxt, did: ast::DefId) -> Vec<clean::Attribute> {\n+pub fn load_attrs(cx: &DocContext, tcx: &ty::ctxt,\n+                  did: ast::DefId) -> Vec<clean::Attribute> {\n     let mut attrs = Vec::new();\n     csearch::get_item_attrs(&tcx.sess.cstore, did, |v| {\n         attrs.extend(v.move_iter().map(|a| {\n-            a.clean()\n+            a.clean(cx)\n         }));\n     });\n     attrs\n@@ -135,22 +134,21 @@ pub fn load_attrs(tcx: &ty::ctxt, did: ast::DefId) -> Vec<clean::Attribute> {\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n-pub fn record_extern_fqn(cx: &core::DocContext,\n-                         did: ast::DefId,\n-                         kind: clean::TypeKind) {\n-    match cx.maybe_typed {\n-        core::Typed(ref tcx) => {\n+pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind) {\n+    match cx.tcx_opt() {\n+        Some(tcx) => {\n             let fqn = csearch::get_item_path(tcx, did);\n             let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n             cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n         }\n-        core::NotTyped(..) => {}\n+        None => {}\n     }\n }\n \n-pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n+pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n+                            did: ast::DefId) -> clean::Trait {\n     let def = ty::lookup_trait_def(tcx, did);\n-    let trait_items = ty::trait_items(tcx, did).clean();\n+    let trait_items = ty::trait_items(tcx, did).clean(cx);\n     let provided = ty::provided_trait_methods(tcx, did);\n     let mut items = trait_items.move_iter().map(|trait_item| {\n         if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n@@ -160,29 +158,29 @@ pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n         }\n     });\n     let trait_def = ty::lookup_trait_def(tcx, did);\n-    let bounds = trait_def.bounds.clean();\n+    let bounds = trait_def.bounds.clean(cx);\n     clean::Trait {\n-        generics: (&def.generics, subst::TypeSpace).clean(),\n+        generics: (&def.generics, subst::TypeSpace).clean(cx),\n         items: items.collect(),\n         bounds: bounds,\n     }\n }\n \n-fn build_external_function(tcx: &ty::ctxt,\n+fn build_external_function(cx: &DocContext, tcx: &ty::ctxt,\n                            did: ast::DefId,\n                            style: ast::FnStyle) -> clean::Function {\n     let t = ty::lookup_item_type(tcx, did);\n     clean::Function {\n         decl: match ty::get(t.ty).sty {\n-            ty::ty_bare_fn(ref f) => (did, &f.sig).clean(),\n+            ty::ty_bare_fn(ref f) => (did, &f.sig).clean(cx),\n             _ => fail!(\"bad function\"),\n         },\n-        generics: (&t.generics, subst::FnSpace).clean(),\n+        generics: (&t.generics, subst::FnSpace).clean(cx),\n         fn_style: style,\n     }\n }\n \n-fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n+fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n     use syntax::parse::token::special_idents::unnamed_field;\n \n     let t = ty::lookup_item_type(tcx, did);\n@@ -195,33 +193,32 @@ fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n             [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n-        generics: (&t.generics, subst::TypeSpace).clean(),\n-        fields: fields.clean(),\n+        generics: (&t.generics, subst::TypeSpace).clean(cx),\n+        fields: fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n-fn build_type(tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n+fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n     let t = ty::lookup_item_type(tcx, did);\n     match ty::get(t.ty).sty {\n         ty::ty_enum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n-                generics: (&t.generics, subst::TypeSpace).clean(),\n+                generics: (&t.generics, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n-                variants: ty::enum_variants(tcx, edid).clean(),\n+                variants: ty::enum_variants(tcx, edid).clean(cx),\n             })\n         }\n         _ => {}\n     }\n \n     clean::TypedefItem(clean::Typedef {\n-        type_: t.ty.clean(),\n-        generics: (&t.generics, subst::TypeSpace).clean(),\n+        type_: t.ty.clean(cx),\n+        generics: (&t.generics, subst::TypeSpace).clean(cx),\n     })\n }\n \n-fn build_impls(cx: &core::DocContext,\n-               tcx: &ty::ctxt,\n+fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n                did: ast::DefId) -> Vec<clean::Item> {\n     ty::populate_implementations_for_type_if_necessary(tcx, did);\n     let mut impls = Vec::new();\n@@ -248,8 +245,7 @@ fn build_impls(cx: &core::DocContext,\n             populate_impls(cx, tcx, def, &mut impls)\n         });\n \n-        fn populate_impls(cx: &core::DocContext,\n-                          tcx: &ty::ctxt,\n+        fn populate_impls(cx: &DocContext, tcx: &ty::ctxt,\n                           def: decoder::DefLike,\n                           impls: &mut Vec<Option<clean::Item>>) {\n             match def {\n@@ -269,8 +265,7 @@ fn build_impls(cx: &core::DocContext,\n     impls.move_iter().filter_map(|a| a).collect()\n }\n \n-fn build_impl(cx: &core::DocContext,\n-              tcx: &ty::ctxt,\n+fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n               did: ast::DefId) -> Option<clean::Item> {\n     if !cx.inlined.borrow_mut().as_mut().unwrap().insert(did) {\n         return None\n@@ -280,15 +275,15 @@ fn build_impl(cx: &core::DocContext,\n     // If this is an impl for a #[doc(hidden)] trait, be sure to not inline it.\n     match associated_trait {\n         Some(ref t) => {\n-            let trait_attrs = load_attrs(tcx, t.def_id);\n+            let trait_attrs = load_attrs(cx, tcx, t.def_id);\n             if trait_attrs.iter().any(|a| is_doc_hidden(a)) {\n                 return None\n             }\n         }\n         None => {}\n     }\n \n-    let attrs = load_attrs(tcx, did);\n+    let attrs = load_attrs(cx, tcx, did);\n     let ty = ty::lookup_item_type(tcx, did);\n     let trait_items = csearch::get_impl_items(&tcx.sess.cstore, did)\n             .iter()\n@@ -300,7 +295,7 @@ fn build_impl(cx: &core::DocContext,\n                 if method.vis != ast::Public && associated_trait.is_none() {\n                     return None\n                 }\n-                let mut item = method.clean();\n+                let mut item = method.clean(cx);\n                 item.inner = match item.inner.clone() {\n                     clean::TyMethodItem(clean::TyMethod {\n                         fn_style, decl, self_, generics\n@@ -321,21 +316,21 @@ fn build_impl(cx: &core::DocContext,\n     return Some(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             derived: clean::detect_derived(attrs.as_slice()),\n-            trait_: associated_trait.clean().map(|bound| {\n+            trait_: associated_trait.clean(cx).map(|bound| {\n                 match bound {\n                     clean::TraitBound(ty) => ty,\n                     clean::RegionBound => unreachable!(),\n                 }\n             }),\n-            for_: ty.ty.clean(),\n-            generics: (&ty.generics, subst::TypeSpace).clean(),\n+            for_: ty.ty.clean(cx),\n+            generics: (&ty.generics, subst::TypeSpace).clean(cx),\n             items: trait_items,\n         }),\n         source: clean::Span::empty(),\n         name: None,\n         attrs: attrs,\n         visibility: Some(ast::Inherited),\n-        stability: stability::lookup(tcx, did).clean(),\n+        stability: stability::lookup(tcx, did).clean(cx),\n         def_id: did,\n     });\n \n@@ -354,7 +349,7 @@ fn build_impl(cx: &core::DocContext,\n     }\n }\n \n-fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n+fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n                 did: ast::DefId) -> clean::Module {\n     let mut items = Vec::new();\n     fill_in(cx, tcx, did, &mut items);\n@@ -365,7 +360,7 @@ fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n \n     // FIXME: this doesn't handle reexports inside the module itself.\n     //        Should they be handled?\n-    fn fill_in(cx: &core::DocContext, tcx: &ty::ctxt, did: ast::DefId,\n+    fn fill_in(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId,\n                items: &mut Vec<clean::Item>) {\n         csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, vis| {\n             match def {\n@@ -387,11 +382,11 @@ fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n     }\n }\n \n-fn build_static(tcx: &ty::ctxt,\n+fn build_static(cx: &DocContext, tcx: &ty::ctxt,\n                 did: ast::DefId,\n                 mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: ty::lookup_item_type(tcx, did).ty.clean(),\n+        type_: ty::lookup_item_type(tcx, did).ty.clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }"}, {"sha": "c1a91f26dbf802c9e725cc8e533aebd33fa5f8e1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 355, "deletions": 380, "changes": 735, "blob_url": "https://github.com/rust-lang/rust/blob/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "patch": "@@ -36,7 +36,7 @@ use std::rc::Rc;\n use std::u32;\n use std::gc::{Gc, GC};\n \n-use core;\n+use core::DocContext;\n use doctree;\n use visit_ast;\n \n@@ -46,57 +46,51 @@ pub static SCHEMA_VERSION: &'static str = \"0.8.3\";\n \n mod inline;\n \n-// load the current DocContext from TLD\n-fn get_cx() -> Gc<core::DocContext> {\n-    *super::ctxtkey.get().unwrap()\n-}\n-\n-// extract the stability index for a node from TLD, if possible\n-fn get_stability(def_id: ast::DefId) -> Option<Stability> {\n-    get_cx().tcx_opt().and_then(|tcx| stability::lookup(tcx, def_id))\n-            .map(|stab| stab.clean())\n+// extract the stability index for a node from tcx, if possible\n+fn get_stability(cx: &DocContext, def_id: ast::DefId) -> Option<Stability> {\n+    cx.tcx_opt().and_then(|tcx| stability::lookup(tcx, def_id)).clean(cx)\n }\n \n pub trait Clean<T> {\n-    fn clean(&self) -> T;\n+    fn clean(&self, cx: &DocContext) -> T;\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for Vec<T> {\n-    fn clean(&self) -> Vec<U> {\n-        self.iter().map(|x| x.clean()).collect()\n+    fn clean(&self, cx: &DocContext) -> Vec<U> {\n+        self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U> Clean<VecPerParamSpace<U>> for VecPerParamSpace<T> {\n-    fn clean(&self) -> VecPerParamSpace<U> {\n-        self.map(|x| x.clean())\n+    fn clean(&self, cx: &DocContext) -> VecPerParamSpace<U> {\n+        self.map(|x| x.clean(cx))\n     }\n }\n \n impl<T: 'static + Clean<U>, U> Clean<U> for Gc<T> {\n-    fn clean(&self) -> U {\n-        (**self).clean()\n+    fn clean(&self, cx: &DocContext) -> U {\n+        (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n-    fn clean(&self) -> U {\n-        (**self).clean()\n+    fn clean(&self, cx: &DocContext) -> U {\n+        (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n-    fn clean(&self) -> Option<U> {\n+    fn clean(&self, cx: &DocContext) -> Option<U> {\n         match self {\n             &None => None,\n-            &Some(ref v) => Some(v.clean())\n+            &Some(ref v) => Some(v.clean(cx))\n         }\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n-    fn clean(&self) -> Vec<U> {\n-        self.iter().map(|x| x.clean()).collect()\n+    fn clean(&self, cx: &DocContext) -> Vec<U> {\n+        self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n@@ -108,13 +102,11 @@ pub struct Crate {\n     pub primitives: Vec<Primitive>,\n }\n \n-impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n-    fn clean(&self) -> Crate {\n-        let cx = get_cx();\n-\n+impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n+    fn clean(&self, cx: &DocContext) -> Crate {\n         let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n-            externs.push((n, meta.clean()));\n+            externs.push((n, meta.clean(cx)));\n         });\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n@@ -124,7 +116,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n \n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n-        let mut module = self.module.clean();\n+        let mut module = self.module.clean(cx);\n \n         // Collect all inner modules which are tagged as implementations of\n         // primitives.\n@@ -199,23 +191,23 @@ pub struct ExternalCrate {\n }\n \n impl Clean<ExternalCrate> for cstore::crate_metadata {\n-    fn clean(&self) -> ExternalCrate {\n+    fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let mut primitives = Vec::new();\n-        get_cx().tcx_opt().map(|tcx| {\n+        cx.tcx_opt().map(|tcx| {\n             csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n                                                   self.cnum,\n                                                   |def, _, _| {\n                 let did = match def {\n                     decoder::DlDef(def::DefMod(did)) => did,\n                     _ => return\n                 };\n-                let attrs = inline::load_attrs(tcx, did);\n+                let attrs = inline::load_attrs(cx, tcx, did);\n                 Primitive::find(attrs.as_slice()).map(|prim| primitives.push(prim));\n             })\n         });\n         ExternalCrate {\n             name: self.name.to_string(),\n-            attrs: decoder::get_crate_attributes(self.data()).clean(),\n+            attrs: decoder::get_crate_attributes(self.data()).clean(cx),\n             primitives: primitives,\n         }\n     }\n@@ -334,38 +326,37 @@ pub struct Module {\n }\n \n impl Clean<Item> for doctree::Module {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let name = if self.name.is_some() {\n-            self.name.unwrap().clean()\n+            self.name.unwrap().clean(cx)\n         } else {\n             \"\".to_string()\n         };\n         let mut foreigns = Vec::new();\n-        for subforeigns in self.foreigns.clean().move_iter() {\n+        for subforeigns in self.foreigns.clean(cx).move_iter() {\n             for foreign in subforeigns.move_iter() {\n                 foreigns.push(foreign)\n             }\n         }\n         let items: Vec<Vec<Item> > = vec!(\n-            self.structs.clean(),\n-            self.enums.clean(),\n-            self.fns.clean(),\n+            self.structs.clean(cx),\n+            self.enums.clean(cx),\n+            self.fns.clean(cx),\n             foreigns,\n-            self.mods.clean(),\n-            self.typedefs.clean(),\n-            self.statics.clean(),\n-            self.traits.clean(),\n-            self.impls.clean(),\n-            self.view_items.clean().move_iter()\n+            self.mods.clean(cx),\n+            self.typedefs.clean(cx),\n+            self.statics.clean(cx),\n+            self.traits.clean(cx),\n+            self.impls.clean(cx),\n+            self.view_items.clean(cx).move_iter()\n                            .flat_map(|s| s.move_iter()).collect(),\n-            self.macros.clean(),\n+            self.macros.clean(cx),\n         );\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let whence = {\n-            let ctxt = super::ctxtkey.get().unwrap();\n-            let cm = ctxt.sess().codemap();\n+            let cm = cx.sess().codemap();\n             let outer = cm.lookup_char_pos(self.where_outer.lo);\n             let inner = cm.lookup_char_pos(self.where_inner.lo);\n             if outer.file.start_pos == inner.file.start_pos {\n@@ -379,10 +370,10 @@ impl Clean<Item> for doctree::Module {\n \n         Item {\n             name: Some(name),\n-            attrs: self.attrs.clean(),\n-            source: whence.clean(),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            attrs: self.attrs.clean(cx),\n+            source: whence.clean(cx),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n@@ -402,11 +393,11 @@ pub enum Attribute {\n }\n \n impl Clean<Attribute> for ast::MetaItem {\n-    fn clean(&self) -> Attribute {\n+    fn clean(&self, cx: &DocContext) -> Attribute {\n         match self.node {\n             ast::MetaWord(ref s) => Word(s.get().to_string()),\n             ast::MetaList(ref s, ref l) => {\n-                List(s.get().to_string(), l.clean())\n+                List(s.get().to_string(), l.clean(cx))\n             }\n             ast::MetaNameValue(ref s, ref v) => {\n                 NameValue(s.get().to_string(), lit_to_string(v))\n@@ -416,8 +407,8 @@ impl Clean<Attribute> for ast::MetaItem {\n }\n \n impl Clean<Attribute> for ast::Attribute {\n-    fn clean(&self) -> Attribute {\n-        self.desugar_doc().node.value.clean()\n+    fn clean(&self, cx: &DocContext) -> Attribute {\n+        self.desugar_doc().node.value.clean(cx)\n     }\n }\n \n@@ -456,25 +447,25 @@ pub struct TyParam {\n }\n \n impl Clean<TyParam> for ast::TyParam {\n-    fn clean(&self) -> TyParam {\n+    fn clean(&self, cx: &DocContext) -> TyParam {\n         TyParam {\n-            name: self.ident.clean(),\n+            name: self.ident.clean(cx),\n             did: ast::DefId { krate: ast::LOCAL_CRATE, node: self.id },\n-            bounds: self.bounds.clean(),\n-            default: self.default.clean()\n+            bounds: self.bounds.clean(cx),\n+            default: self.default.clean(cx)\n         }\n     }\n }\n \n impl Clean<TyParam> for ty::TypeParameterDef {\n-    fn clean(&self) -> TyParam {\n-        get_cx().external_typarams.borrow_mut().as_mut().unwrap()\n-                .insert(self.def_id, self.ident.clean());\n+    fn clean(&self, cx: &DocContext) -> TyParam {\n+        cx.external_typarams.borrow_mut().as_mut().unwrap()\n+          .insert(self.def_id, self.ident.clean(cx));\n         TyParam {\n-            name: self.ident.clean(),\n+            name: self.ident.clean(cx),\n             did: self.def_id,\n-            bounds: self.bounds.clean(),\n-            default: self.default.clean()\n+            bounds: self.bounds.clean(cx),\n+            default: self.default.clean(cx)\n         }\n     }\n }\n@@ -486,35 +477,35 @@ pub enum TyParamBound {\n }\n \n impl Clean<TyParamBound> for ast::TyParamBound {\n-    fn clean(&self) -> TyParamBound {\n+    fn clean(&self, cx: &DocContext) -> TyParamBound {\n         match *self {\n             ast::RegionTyParamBound(_) => RegionBound,\n             ast::UnboxedFnTyParamBound(_) => {\n                 // FIXME(pcwalton): Wrong.\n                 RegionBound\n             }\n-            ast::TraitTyParamBound(ref t) => TraitBound(t.clean()),\n+            ast::TraitTyParamBound(ref t) => TraitBound(t.clean(cx)),\n         }\n     }\n }\n \n impl Clean<Vec<TyParamBound>> for ty::ExistentialBounds {\n-    fn clean(&self) -> Vec<TyParamBound> {\n+    fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n         let mut vec = vec!(RegionBound);\n         for bb in self.builtin_bounds.iter() {\n-            vec.push(bb.clean());\n+            vec.push(bb.clean(cx));\n         }\n         vec\n     }\n }\n \n-fn external_path(name: &str, substs: &subst::Substs) -> Path {\n+fn external_path(cx: &DocContext, name: &str, substs: &subst::Substs) -> Path {\n     let lifetimes = substs.regions().get_slice(subst::TypeSpace)\n                     .iter()\n-                    .filter_map(|v| v.clean())\n+                    .filter_map(|v| v.clean(cx))\n                     .collect();\n     let types = Vec::from_slice(substs.types.get_slice(subst::TypeSpace));\n-    let types = types.clean();\n+    let types = types.clean(cx);\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n@@ -526,26 +517,25 @@ fn external_path(name: &str, substs: &subst::Substs) -> Path {\n }\n \n impl Clean<TyParamBound> for ty::BuiltinBound {\n-    fn clean(&self) -> TyParamBound {\n-        let cx = get_cx();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => return RegionBound,\n+    fn clean(&self, cx: &DocContext) -> TyParamBound {\n+        let tcx = match cx.tcx_opt() {\n+            Some(tcx) => tcx,\n+            None => return RegionBound,\n         };\n         let empty = subst::Substs::empty();\n         let (did, path) = match *self {\n             ty::BoundSend =>\n                 (tcx.lang_items.send_trait().unwrap(),\n-                 external_path(\"Send\", &empty)),\n+                 external_path(cx, \"Send\", &empty)),\n             ty::BoundSized =>\n                 (tcx.lang_items.sized_trait().unwrap(),\n-                 external_path(\"Sized\", &empty)),\n+                 external_path(cx, \"Sized\", &empty)),\n             ty::BoundCopy =>\n                 (tcx.lang_items.copy_trait().unwrap(),\n-                 external_path(\"Copy\", &empty)),\n+                 external_path(cx, \"Copy\", &empty)),\n             ty::BoundSync =>\n                 (tcx.lang_items.sync_trait().unwrap(),\n-                 external_path(\"Sync\", &empty)),\n+                 external_path(cx, \"Sync\", &empty)),\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n         let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n@@ -560,16 +550,15 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n }\n \n impl Clean<TyParamBound> for ty::TraitRef {\n-    fn clean(&self) -> TyParamBound {\n-        let cx = get_cx();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => return RegionBound,\n+    fn clean(&self, cx: &DocContext) -> TyParamBound {\n+        let tcx = match cx.tcx_opt() {\n+            Some(tcx) => tcx,\n+            None => return RegionBound,\n         };\n         let fqn = csearch::get_item_path(tcx, self.def_id);\n         let fqn = fqn.move_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n-        let path = external_path(fqn.last().unwrap().as_slice(),\n+        let path = external_path(cx, fqn.last().unwrap().as_slice(),\n                                  &self.substs);\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n@@ -582,25 +571,25 @@ impl Clean<TyParamBound> for ty::TraitRef {\n }\n \n impl Clean<Vec<TyParamBound>> for ty::ParamBounds {\n-    fn clean(&self) -> Vec<TyParamBound> {\n+    fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n         let mut v = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             if b != ty::BoundSized {\n-                v.push(b.clean());\n+                v.push(b.clean(cx));\n             }\n         }\n         for t in self.trait_bounds.iter() {\n-            v.push(t.clean());\n+            v.push(t.clean(cx));\n         }\n         return v;\n     }\n }\n \n impl Clean<Option<Vec<TyParamBound>>> for subst::Substs {\n-    fn clean(&self) -> Option<Vec<TyParamBound>> {\n+    fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions().iter().map(|_| RegionBound));\n-        v.extend(self.types.iter().map(|t| TraitBound(t.clean())));\n+        v.extend(self.types.iter().map(|t| TraitBound(t.clean(cx))));\n         if v.len() > 0 {Some(v)} else {None}\n     }\n }\n@@ -617,30 +606,30 @@ impl Lifetime {\n }\n \n impl Clean<Lifetime> for ast::Lifetime {\n-    fn clean(&self) -> Lifetime {\n+    fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(token::get_name(self.name).get().to_string())\n     }\n }\n \n impl Clean<Lifetime> for ast::LifetimeDef {\n-    fn clean(&self) -> Lifetime {\n+    fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(token::get_name(self.lifetime.name).get().to_string())\n     }\n }\n \n impl Clean<Lifetime> for ty::RegionParameterDef {\n-    fn clean(&self) -> Lifetime {\n+    fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(token::get_name(self.name).get().to_string())\n     }\n }\n \n impl Clean<Option<Lifetime>> for ty::Region {\n-    fn clean(&self) -> Option<Lifetime> {\n+    fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime(\"'static\".to_string())),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n                 Some(Lifetime(token::get_name(name).get().to_string())),\n-            ty::ReEarlyBound(_, _, _, name) => Some(Lifetime(name.clean())),\n+            ty::ReEarlyBound(_, _, _, name) => Some(Lifetime(name.clean(cx))),\n \n             ty::ReLateBound(..) |\n             ty::ReFree(..) |\n@@ -659,20 +648,20 @@ pub struct Generics {\n }\n \n impl Clean<Generics> for ast::Generics {\n-    fn clean(&self) -> Generics {\n+    fn clean(&self, cx: &DocContext) -> Generics {\n         Generics {\n-            lifetimes: self.lifetimes.clean(),\n-            type_params: self.ty_params.clean(),\n+            lifetimes: self.lifetimes.clean(cx),\n+            type_params: self.ty_params.clean(cx),\n         }\n     }\n }\n \n impl<'a> Clean<Generics> for (&'a ty::Generics, subst::ParamSpace) {\n-    fn clean(&self) -> Generics {\n+    fn clean(&self, cx: &DocContext) -> Generics {\n         let (me, space) = *self;\n         Generics {\n-            type_params: Vec::from_slice(me.types.get_slice(space)).clean(),\n-            lifetimes: Vec::from_slice(me.regions.get_slice(space)).clean(),\n+            type_params: Vec::from_slice(me.types.get_slice(space)).clean(cx),\n+            lifetimes: Vec::from_slice(me.regions.get_slice(space)).clean(cx),\n         }\n     }\n }\n@@ -686,30 +675,30 @@ pub struct Method {\n }\n \n impl Clean<Item> for ast::Method {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => all_inputs.as_slice(),\n             _ => all_inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.iter().map(|x| x.clean()).collect(),\n+                values: inputs.iter().map(|x| x.clean(cx)).collect(),\n             },\n-            output: (self.pe_fn_decl().output.clean()),\n-            cf: self.pe_fn_decl().cf.clean(),\n+            output: (self.pe_fn_decl().output.clean(cx)),\n+            cf: self.pe_fn_decl().cf.clean(cx),\n             attrs: Vec::new()\n         };\n         Item {\n-            name: Some(self.pe_ident().clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.span.clean(),\n+            name: Some(self.pe_ident().clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.span.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.pe_vis().clean(),\n-            stability: get_stability(ast_util::local_def(self.id)),\n+            visibility: self.pe_vis().clean(cx),\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n             inner: MethodItem(Method {\n-                generics: self.pe_generics().clean(),\n-                self_: self.pe_explicit_self().node.clean(),\n+                generics: self.pe_generics().clean(cx),\n+                self_: self.pe_explicit_self().node.clean(cx),\n                 fn_style: self.pe_fn_style().clone(),\n                 decl: decl,\n             }),\n@@ -726,31 +715,31 @@ pub struct TyMethod {\n }\n \n impl Clean<Item> for ast::TypeMethod {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => self.decl.inputs.as_slice(),\n             _ => self.decl.inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.iter().map(|x| x.clean()).collect(),\n+                values: inputs.iter().map(|x| x.clean(cx)).collect(),\n             },\n-            output: (self.decl.output.clean()),\n-            cf: self.decl.cf.clean(),\n+            output: (self.decl.output.clean(cx)),\n+            cf: self.decl.cf.clean(cx),\n             attrs: Vec::new()\n         };\n         Item {\n-            name: Some(self.ident.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.span.clean(),\n+            name: Some(self.ident.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.span.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             visibility: None,\n-            stability: get_stability(ast_util::local_def(self.id)),\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fn_style.clone(),\n                 decl: decl,\n-                self_: self.explicit_self.node.clean(),\n-                generics: self.generics.clean(),\n+                self_: self.explicit_self.node.clean(cx),\n+                generics: self.generics.clean(cx),\n             }),\n         }\n     }\n@@ -765,14 +754,14 @@ pub enum SelfTy {\n }\n \n impl Clean<SelfTy> for ast::ExplicitSelf_ {\n-    fn clean(&self) -> SelfTy {\n+    fn clean(&self, cx: &DocContext) -> SelfTy {\n         match *self {\n             ast::SelfStatic => SelfStatic,\n             ast::SelfValue(_) => SelfValue,\n             ast::SelfRegion(lt, mt, _) => {\n-                SelfBorrowed(lt.clean(), mt.clean())\n+                SelfBorrowed(lt.clean(cx), mt.clean(cx))\n             }\n-            ast::SelfExplicit(typ, _) => SelfExplicit(typ.clean()),\n+            ast::SelfExplicit(typ, _) => SelfExplicit(typ.clean(cx)),\n         }\n     }\n }\n@@ -785,17 +774,17 @@ pub struct Function {\n }\n \n impl Clean<Item> for doctree::Function {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             inner: FunctionItem(Function {\n-                decl: self.decl.clean(),\n-                generics: self.generics.clean(),\n+                decl: self.decl.clean(cx),\n+                generics: self.generics.clean(cx),\n                 fn_style: self.fn_style,\n             }),\n         }\n@@ -812,13 +801,13 @@ pub struct ClosureDecl {\n }\n \n impl Clean<ClosureDecl> for ast::ClosureTy {\n-    fn clean(&self) -> ClosureDecl {\n+    fn clean(&self, cx: &DocContext) -> ClosureDecl {\n         ClosureDecl {\n-            lifetimes: self.lifetimes.clean(),\n-            decl: self.decl.clean(),\n+            lifetimes: self.lifetimes.clean(cx),\n+            decl: self.decl.clean(cx),\n             onceness: self.onceness,\n             fn_style: self.fn_style,\n-            bounds: self.bounds.clean()\n+            bounds: self.bounds.clean(cx)\n         }\n     }\n }\n@@ -837,21 +826,20 @@ pub struct Arguments {\n }\n \n impl Clean<FnDecl> for ast::FnDecl {\n-    fn clean(&self) -> FnDecl {\n+    fn clean(&self, cx: &DocContext) -> FnDecl {\n         FnDecl {\n             inputs: Arguments {\n-                values: self.inputs.iter().map(|x| x.clean()).collect(),\n+                values: self.inputs.clean(cx),\n             },\n-            output: (self.output.clean()),\n-            cf: self.cf.clean(),\n+            output: self.output.clean(cx),\n+            cf: self.cf.clean(cx),\n             attrs: Vec::new()\n         }\n     }\n }\n \n impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n-    fn clean(&self) -> FnDecl {\n-        let cx = get_cx();\n+    fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if did.node != 0 {\n             csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).move_iter()\n@@ -862,13 +850,13 @@ impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n             let _ = names.next();\n         }\n         FnDecl {\n-            output: sig.output.clean(),\n+            output: sig.output.clean(cx),\n             cf: Return,\n             attrs: Vec::new(),\n             inputs: Arguments {\n                 values: sig.inputs.iter().map(|t| {\n                     Argument {\n-                        type_: t.clean(),\n+                        type_: t.clean(cx),\n                         id: 0,\n                         name: names.next().unwrap_or(\"\".to_string()),\n                     }\n@@ -886,10 +874,10 @@ pub struct Argument {\n }\n \n impl Clean<Argument> for ast::Arg {\n-    fn clean(&self) -> Argument {\n+    fn clean(&self, cx: &DocContext) -> Argument {\n         Argument {\n             name: name_from_pat(&*self.pat),\n-            type_: (self.ty.clean()),\n+            type_: (self.ty.clean(cx)),\n             id: self.id\n         }\n     }\n@@ -902,7 +890,7 @@ pub enum RetStyle {\n }\n \n impl Clean<RetStyle> for ast::RetStyle {\n-    fn clean(&self) -> RetStyle {\n+    fn clean(&self, _: &DocContext) -> RetStyle {\n         match *self {\n             ast::Return => Return,\n             ast::NoReturn => NoReturn\n@@ -918,26 +906,26 @@ pub struct Trait {\n }\n \n impl Clean<Item> for doctree::Trait {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: TraitItem(Trait {\n-                items: self.items.clean(),\n-                generics: self.generics.clean(),\n-                bounds: self.bounds.clean(),\n+                items: self.items.clean(cx),\n+                generics: self.generics.clean(cx),\n+                bounds: self.bounds.clean(cx),\n             }),\n         }\n     }\n }\n \n impl Clean<Type> for ast::TraitRef {\n-    fn clean(&self) -> Type {\n-        resolve_type(self.path.clean(), None, self.ref_id)\n+    fn clean(&self, cx: &DocContext) -> Type {\n+        resolve_type(cx, self.path.clean(cx), None, self.ref_id)\n     }\n }\n \n@@ -969,10 +957,10 @@ impl TraitItem {\n }\n \n impl Clean<TraitItem> for ast::TraitItem {\n-    fn clean(&self) -> TraitItem {\n+    fn clean(&self, cx: &DocContext) -> TraitItem {\n         match self {\n-            &ast::RequiredMethod(ref t) => RequiredMethod(t.clean()),\n-            &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean()),\n+            &ast::RequiredMethod(ref t) => RequiredMethod(t.clean(cx)),\n+            &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean(cx)),\n         }\n     }\n }\n@@ -983,18 +971,17 @@ pub enum ImplItem {\n }\n \n impl Clean<ImplItem> for ast::ImplItem {\n-    fn clean(&self) -> ImplItem {\n+    fn clean(&self, cx: &DocContext) -> ImplItem {\n         match self {\n-            &ast::MethodImplItem(ref t) => MethodImplItem(t.clean()),\n+            &ast::MethodImplItem(ref t) => MethodImplItem(t.clean(cx)),\n         }\n     }\n }\n \n impl Clean<Item> for ty::Method {\n-    fn clean(&self) -> Item {\n-        let cx = get_cx();\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let (self_, sig) = match self.explicit_self {\n-            ty::StaticExplicitSelfCategory => (ast::SelfStatic.clean(),\n+            ty::StaticExplicitSelfCategory => (ast::SelfStatic.clean(cx),\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n@@ -1006,13 +993,13 @@ impl Clean<Item> for ty::Method {\n                     ty::ByReferenceExplicitSelfCategory(..) => {\n                         match ty::get(self.fty.sig.inputs[0]).sty {\n                             ty::ty_rptr(r, mt) => {\n-                                SelfBorrowed(r.clean(), mt.mutbl.clean())\n+                                SelfBorrowed(r.clean(cx), mt.mutbl.clean(cx))\n                             }\n                             _ => unreachable!(),\n                         }\n                     }\n                     ty::ByBoxExplicitSelfCategory => {\n-                        SelfExplicit(self.fty.sig.inputs[0].clean())\n+                        SelfExplicit(self.fty.sig.inputs[0].clean(cx))\n                     }\n                     ty::StaticExplicitSelfCategory => unreachable!(),\n                 };\n@@ -1021,26 +1008,26 @@ impl Clean<Item> for ty::Method {\n         };\n \n         Item {\n-            name: Some(self.ident.clean()),\n+            name: Some(self.ident.clean(cx)),\n             visibility: Some(ast::Inherited),\n-            stability: get_stability(self.def_id),\n+            stability: get_stability(cx, self.def_id),\n             def_id: self.def_id,\n-            attrs: inline::load_attrs(cx.tcx(), self.def_id),\n+            attrs: inline::load_attrs(cx, cx.tcx(), self.def_id),\n             source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fty.fn_style,\n-                generics: (&self.generics, subst::FnSpace).clean(),\n+                generics: (&self.generics, subst::FnSpace).clean(cx),\n                 self_: self_,\n-                decl: (self.def_id, &sig).clean(),\n+                decl: (self.def_id, &sig).clean(cx),\n             })\n         }\n     }\n }\n \n impl Clean<Item> for ty::ImplOrTraitItem {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         match *self {\n-            ty::MethodTraitItem(ref mti) => mti.clean(),\n+            ty::MethodTraitItem(ref mti) => mti.clean(cx),\n         }\n     }\n }\n@@ -1194,37 +1181,35 @@ impl Primitive {\n }\n \n impl Clean<Type> for ast::Ty {\n-    fn clean(&self) -> Type {\n+    fn clean(&self, cx: &DocContext) -> Type {\n         use syntax::ast::*;\n         match self.node {\n             TyNil => Primitive(Unit),\n-            TyPtr(ref m) => RawPointer(m.mutbl.clean(), box m.ty.clean()),\n+            TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyRptr(ref l, ref m) =>\n-                BorrowedRef {lifetime: l.clean(), mutability: m.mutbl.clean(),\n-                             type_: box m.ty.clean()},\n-            TyBox(ty) => Managed(box ty.clean()),\n-            TyUniq(ty) => Unique(box ty.clean()),\n-            TyVec(ty) => Vector(box ty.clean()),\n-            TyFixedLengthVec(ty, ref e) => FixedVector(box ty.clean(),\n-                                                       e.span.to_src()),\n-            TyTup(ref tys) => Tuple(tys.iter().map(|x| x.clean()).collect()),\n+                BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n+                             type_: box m.ty.clean(cx)},\n+            TyBox(ty) => Managed(box ty.clean(cx)),\n+            TyUniq(ty) => Unique(box ty.clean(cx)),\n+            TyVec(ty) => Vector(box ty.clean(cx)),\n+            TyFixedLengthVec(ty, ref e) => FixedVector(box ty.clean(cx),\n+                                                       e.span.to_src(cx)),\n+            TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(ref p, ref tpbs, id) => {\n-                resolve_type(p.clean(),\n-                             tpbs.clean().map(|x| x),\n-                             id)\n+                resolve_type(cx, p.clean(cx), tpbs.clean(cx), id)\n             }\n-            TyClosure(ref c) => Closure(box c.clean()),\n-            TyProc(ref c) => Proc(box c.clean()),\n-            TyBareFn(ref barefn) => BareFunction(box barefn.clean()),\n-            TyParen(ref ty) => ty.clean(),\n+            TyClosure(ref c) => Closure(box c.clean(cx)),\n+            TyProc(ref c) => Proc(box c.clean(cx)),\n+            TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n+            TyParen(ref ty) => ty.clean(cx),\n             TyBot => Bottom,\n             ref x => fail!(\"Unimplemented type {:?}\", x),\n         }\n     }\n }\n \n impl Clean<Type> for ty::t {\n-    fn clean(&self) -> Type {\n+    fn clean(&self, cx: &DocContext) -> Type {\n         match ty::get(*self).sty {\n             ty::ty_bot => Bottom,\n             ty::ty_nil => Primitive(Unit),\n@@ -1244,41 +1229,41 @@ impl Clean<Type> for ty::t {\n             ty::ty_float(ast::TyF64) => Primitive(F64),\n             ty::ty_str => Primitive(Str),\n             ty::ty_box(t) => {\n-                let gc_did = get_cx().tcx_opt().and_then(|tcx| {\n+                let gc_did = cx.tcx_opt().and_then(|tcx| {\n                     tcx.lang_items.gc()\n                 });\n-                lang_struct(gc_did, t, \"Gc\", Managed)\n+                lang_struct(cx, gc_did, t, \"Gc\", Managed)\n             }\n             ty::ty_uniq(t) => {\n-                let box_did = get_cx().tcx_opt().and_then(|tcx| {\n+                let box_did = cx.tcx_opt().and_then(|tcx| {\n                     tcx.lang_items.owned_box()\n                 });\n-                lang_struct(box_did, t, \"Box\", Unique)\n+                lang_struct(cx, box_did, t, \"Box\", Unique)\n             }\n-            ty::ty_vec(ty, None) => Vector(box ty.clean()),\n-            ty::ty_vec(ty, Some(i)) => FixedVector(box ty.clean(),\n+            ty::ty_vec(ty, None) => Vector(box ty.clean(cx)),\n+            ty::ty_vec(ty, Some(i)) => FixedVector(box ty.clean(cx),\n                                                    format!(\"{}\", i)),\n-            ty::ty_ptr(mt) => RawPointer(mt.mutbl.clean(), box mt.ty.clean()),\n+            ty::ty_ptr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n             ty::ty_rptr(r, mt) => BorrowedRef {\n-                lifetime: r.clean(),\n-                mutability: mt.mutbl.clean(),\n-                type_: box mt.ty.clean(),\n+                lifetime: r.clean(cx),\n+                mutability: mt.mutbl.clean(cx),\n+                type_: box mt.ty.clean(cx),\n             },\n             ty::ty_bare_fn(ref fty) => BareFunction(box BareFunctionDecl {\n                 fn_style: fty.fn_style,\n                 generics: Generics {\n                     lifetimes: Vec::new(), type_params: Vec::new()\n                 },\n-                decl: (ast_util::local_def(0), &fty.sig).clean(),\n+                decl: (ast_util::local_def(0), &fty.sig).clean(cx),\n                 abi: fty.abi.to_string(),\n             }),\n             ty::ty_closure(ref fty) => {\n                 let decl = box ClosureDecl {\n                     lifetimes: Vec::new(), // FIXME: this looks wrong...\n-                    decl: (ast_util::local_def(0), &fty.sig).clean(),\n+                    decl: (ast_util::local_def(0), &fty.sig).clean(cx),\n                     onceness: fty.onceness,\n                     fn_style: fty.fn_style,\n-                    bounds: fty.bounds.clean(),\n+                    bounds: fty.bounds.clean(cx),\n                 };\n                 match fty.store {\n                     ty::UniqTraitStore => Proc(decl),\n@@ -1288,7 +1273,7 @@ impl Clean<Type> for ty::t {\n             ty::ty_struct(did, ref substs) |\n             ty::ty_enum(did, ref substs) |\n             ty::ty_trait(box ty::TyTrait { def_id: did, ref substs, .. }) => {\n-                let fqn = csearch::get_item_path(get_cx().tcx(), did);\n+                let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<String> = fqn.move_iter().map(|i| {\n                     i.to_string()\n                 }).collect();\n@@ -1297,17 +1282,16 @@ impl Clean<Type> for ty::t {\n                     ty::ty_trait(..) => TypeTrait,\n                     _ => TypeEnum,\n                 };\n-                let path = external_path(fqn.last().unwrap().to_string().as_slice(),\n+                let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n                                          substs);\n-                get_cx().external_paths.borrow_mut().as_mut().unwrap()\n-                                       .insert(did, (fqn, kind));\n+                cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n                 ResolvedPath {\n                     path: path,\n                     typarams: None,\n                     did: did,\n                 }\n             }\n-            ty::ty_tup(ref t) => Tuple(t.iter().map(|t| t.clean()).collect()),\n+            ty::ty_tup(ref t) => Tuple(t.clean(cx)),\n \n             ty::ty_param(ref p) => {\n                 if p.space == subst::SelfSpace {\n@@ -1333,59 +1317,54 @@ pub enum StructField {\n }\n \n impl Clean<Item> for ast::StructField {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let (name, vis) = match self.node.kind {\n             ast::NamedField(id, vis) => (Some(id), vis),\n             ast::UnnamedField(vis) => (None, vis)\n         };\n         Item {\n-            name: name.clean(),\n-            attrs: self.node.attrs.clean(),\n-            source: self.span.clean(),\n+            name: name.clean(cx),\n+            attrs: self.node.attrs.clean(cx),\n+            source: self.span.clean(cx),\n             visibility: Some(vis),\n-            stability: get_stability(ast_util::local_def(self.node.id)),\n+            stability: get_stability(cx, ast_util::local_def(self.node.id)),\n             def_id: ast_util::local_def(self.node.id),\n-            inner: StructFieldItem(TypedStructField(self.node.ty.clean())),\n+            inner: StructFieldItem(TypedStructField(self.node.ty.clean(cx))),\n         }\n     }\n }\n \n impl Clean<Item> for ty::field_ty {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         use syntax::parse::token::special_idents::unnamed_field;\n         use rustc::metadata::csearch;\n \n-        let cx = get_cx();\n-        let attrs;\n-\n         let attr_map = csearch::get_struct_field_attrs(&cx.tcx().sess.cstore, self.id);\n \n-        let name = if self.name == unnamed_field.name {\n-            attrs = None;\n-            None\n+        let (name, attrs) = if self.name == unnamed_field.name {\n+            (None, None)\n         } else {\n-            attrs = Some(attr_map.find(&self.id.node).unwrap());\n-            Some(self.name)\n+            (Some(self.name), Some(attr_map.find(&self.id.node).unwrap()))\n         };\n \n         let ty = ty::lookup_item_type(cx.tcx(), self.id);\n \n         Item {\n-            name: name.clean(),\n-            attrs: attrs.unwrap_or(&Vec::new()).clean(),\n+            name: name.clean(cx),\n+            attrs: attrs.unwrap_or(&Vec::new()).clean(cx),\n             source: Span::empty(),\n             visibility: Some(self.vis),\n-            stability: get_stability(self.id),\n+            stability: get_stability(cx, self.id),\n             def_id: self.id,\n-            inner: StructFieldItem(TypedStructField(ty.ty.clean())),\n+            inner: StructFieldItem(TypedStructField(ty.ty.clean(cx))),\n         }\n     }\n }\n \n pub type Visibility = ast::Visibility;\n \n impl Clean<Option<Visibility>> for ast::Visibility {\n-    fn clean(&self) -> Option<Visibility> {\n+    fn clean(&self, _: &DocContext) -> Option<Visibility> {\n         Some(*self)\n     }\n }\n@@ -1399,18 +1378,18 @@ pub struct Struct {\n }\n \n impl Clean<Item> for doctree::Struct {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: StructItem(Struct {\n                 struct_type: self.struct_type,\n-                generics: self.generics.clean(),\n-                fields: self.fields.clean(),\n+                generics: self.generics.clean(cx),\n+                fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n         }\n@@ -1428,10 +1407,10 @@ pub struct VariantStruct {\n }\n \n impl Clean<VariantStruct> for syntax::ast::StructDef {\n-    fn clean(&self) -> VariantStruct {\n+    fn clean(&self, cx: &DocContext) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n-            fields: self.fields.clean(),\n+            fields: self.fields.clean(cx),\n             fields_stripped: false,\n         }\n     }\n@@ -1445,17 +1424,17 @@ pub struct Enum {\n }\n \n impl Clean<Item> for doctree::Enum {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: EnumItem(Enum {\n-                variants: self.variants.clean(),\n-                generics: self.generics.clean(),\n+                variants: self.variants.clean(cx),\n+                generics: self.generics.clean(cx),\n                 variants_stripped: false,\n             }),\n         }\n@@ -1468,29 +1447,28 @@ pub struct Variant {\n }\n \n impl Clean<Item> for doctree::Variant {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             inner: VariantItem(Variant {\n-                kind: self.kind.clean(),\n+                kind: self.kind.clean(cx),\n             }),\n         }\n     }\n }\n \n impl Clean<Item> for ty::VariantInfo {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n-        let cx = get_cx();\n         let kind = match self.arg_names.as_ref().map(|s| s.as_slice()) {\n             None | Some([]) if self.args.len() == 0 => CLikeVariant,\n             None | Some([]) => {\n-                TupleVariant(self.args.iter().map(|t| t.clean()).collect())\n+                TupleVariant(self.args.clean(cx))\n             }\n             Some(s) => {\n                 StructVariant(VariantStruct {\n@@ -1499,7 +1477,7 @@ impl Clean<Item> for ty::VariantInfo {\n                     fields: s.iter().zip(self.args.iter()).map(|(name, ty)| {\n                         Item {\n                             source: Span::empty(),\n-                            name: Some(name.clean()),\n+                            name: Some(name.clean(cx)),\n                             attrs: Vec::new(),\n                             visibility: Some(ast::Public),\n                             // FIXME: this is not accurate, we need an id for\n@@ -1510,23 +1488,23 @@ impl Clean<Item> for ty::VariantInfo {\n                             //        more infrastructure work before we can get\n                             //        at the needed information here.\n                             def_id: self.id,\n-                            stability: get_stability(self.id),\n+                            stability: get_stability(cx, self.id),\n                             inner: StructFieldItem(\n-                                TypedStructField(ty.clean())\n+                                TypedStructField(ty.clean(cx))\n                             )\n                         }\n                     }).collect()\n                 })\n             }\n         };\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: inline::load_attrs(cx.tcx(), self.id),\n+            name: Some(self.name.clean(cx)),\n+            attrs: inline::load_attrs(cx, cx.tcx(), self.id),\n             source: Span::empty(),\n             visibility: Some(ast::Public),\n             def_id: self.id,\n             inner: VariantItem(Variant { kind: kind }),\n-            stability: get_stability(self.id),\n+            stability: get_stability(cx, self.id),\n         }\n     }\n }\n@@ -1539,16 +1517,16 @@ pub enum VariantKind {\n }\n \n impl Clean<VariantKind> for ast::VariantKind {\n-    fn clean(&self) -> VariantKind {\n+    fn clean(&self, cx: &DocContext) -> VariantKind {\n         match self {\n             &ast::TupleVariantKind(ref args) => {\n                 if args.len() == 0 {\n                     CLikeVariant\n                 } else {\n-                    TupleVariant(args.iter().map(|x| x.ty.clean()).collect())\n+                    TupleVariant(args.iter().map(|x| x.ty.clean(cx)).collect())\n                 }\n             },\n-            &ast::StructVariantKind(ref sd) => StructVariant(sd.clean()),\n+            &ast::StructVariantKind(ref sd) => StructVariant(sd.clean(cx)),\n         }\n     }\n }\n@@ -1573,9 +1551,8 @@ impl Span {\n }\n \n impl Clean<Span> for syntax::codemap::Span {\n-    fn clean(&self) -> Span {\n-        let ctxt = super::ctxtkey.get().unwrap();\n-        let cm = ctxt.sess().codemap();\n+    fn clean(&self, cx: &DocContext) -> Span {\n+        let cm = cx.sess().codemap();\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo);\n         let hi = cm.lookup_char_pos(self.hi);\n@@ -1596,10 +1573,10 @@ pub struct Path {\n }\n \n impl Clean<Path> for ast::Path {\n-    fn clean(&self) -> Path {\n+    fn clean(&self, cx: &DocContext) -> Path {\n         Path {\n             global: self.global,\n-            segments: self.segments.clean(),\n+            segments: self.segments.clean(cx),\n         }\n     }\n }\n@@ -1612,11 +1589,11 @@ pub struct PathSegment {\n }\n \n impl Clean<PathSegment> for ast::PathSegment {\n-    fn clean(&self) -> PathSegment {\n+    fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n-            name: self.identifier.clean(),\n-            lifetimes: self.lifetimes.clean(),\n-            types: self.types.clean(),\n+            name: self.identifier.clean(cx),\n+            lifetimes: self.lifetimes.clean(cx),\n+            types: self.types.clean(cx),\n         }\n     }\n }\n@@ -1636,13 +1613,13 @@ fn path_to_string(p: &ast::Path) -> String {\n }\n \n impl Clean<String> for ast::Ident {\n-    fn clean(&self) -> String {\n+    fn clean(&self, _: &DocContext) -> String {\n         token::get_ident(*self).get().to_string()\n     }\n }\n \n impl Clean<String> for ast::Name {\n-    fn clean(&self) -> String {\n+    fn clean(&self, _: &DocContext) -> String {\n         token::get_name(*self).get().to_string()\n     }\n }\n@@ -1654,17 +1631,17 @@ pub struct Typedef {\n }\n \n impl Clean<Item> for doctree::Typedef {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id.clone()),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: TypedefItem(Typedef {\n-                type_: self.ty.clean(),\n-                generics: self.gen.clean(),\n+                type_: self.ty.clean(cx),\n+                generics: self.gen.clean(cx),\n             }),\n         }\n     }\n@@ -1679,14 +1656,14 @@ pub struct BareFunctionDecl {\n }\n \n impl Clean<BareFunctionDecl> for ast::BareFnTy {\n-    fn clean(&self) -> BareFunctionDecl {\n+    fn clean(&self, cx: &DocContext) -> BareFunctionDecl {\n         BareFunctionDecl {\n             fn_style: self.fn_style,\n             generics: Generics {\n-                lifetimes: self.lifetimes.clean(),\n+                lifetimes: self.lifetimes.clean(cx),\n                 type_params: Vec::new(),\n             },\n-            decl: self.decl.clean(),\n+            decl: self.decl.clean(cx),\n             abi: self.abi.to_string(),\n         }\n     }\n@@ -1703,19 +1680,19 @@ pub struct Static {\n }\n \n impl Clean<Item> for doctree::Static {\n-    fn clean(&self) -> Item {\n-        debug!(\"claning static {}: {:?}\", self.name.clean(), self);\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        debug!(\"claning static {}: {:?}\", self.name.clean(cx), self);\n         Item {\n-            name: Some(self.name.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: StaticItem(Static {\n-                type_: self.type_.clean(),\n-                mutability: self.mutability.clean(),\n-                expr: self.expr.span.to_src(),\n+                type_: self.type_.clean(cx),\n+                mutability: self.mutability.clean(cx),\n+                expr: self.expr.span.to_src(cx),\n             }),\n         }\n     }\n@@ -1728,7 +1705,7 @@ pub enum Mutability {\n }\n \n impl Clean<Mutability> for ast::Mutability {\n-    fn clean(&self) -> Mutability {\n+    fn clean(&self, _: &DocContext) -> Mutability {\n         match self {\n             &ast::MutMutable => Mutable,\n             &ast::MutImmutable => Immutable,\n@@ -1750,19 +1727,19 @@ fn detect_derived<M: AttrMetaMethods>(attrs: &[M]) -> bool {\n }\n \n impl Clean<Item> for doctree::Impl {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n             name: None,\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: self.stab.clean(),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n             inner: ImplItem(Impl {\n-                generics: self.generics.clean(),\n-                trait_: self.trait_.clean(),\n-                for_: self.for_.clean(),\n-                items: self.items.clean().move_iter().map(|ti| {\n+                generics: self.generics.clean(cx),\n+                trait_: self.trait_.clean(cx),\n+                for_: self.for_.clean(cx),\n+                items: self.items.clean(cx).move_iter().map(|ti| {\n                         match ti {\n                             MethodImplItem(i) => i,\n                         }\n@@ -1779,7 +1756,7 @@ pub struct ViewItem {\n }\n \n impl Clean<Vec<Item>> for ast::ViewItem {\n-    fn clean(&self) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n@@ -1792,12 +1769,12 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n         let convert = |node: &ast::ViewItem_| {\n             Item {\n                 name: None,\n-                attrs: self.attrs.clean(),\n-                source: self.span.clean(),\n+                attrs: self.attrs.clean(cx),\n+                source: self.span.clean(cx),\n                 def_id: ast_util::local_def(0),\n-                visibility: self.vis.clean(),\n+                visibility: self.vis.clean(cx),\n                 stability: None,\n-                inner: ViewItemItem(ViewItem { inner: node.clean() }),\n+                inner: ViewItemItem(ViewItem { inner: node.clean(cx) }),\n             }\n         };\n         let mut ret = Vec::new();\n@@ -1810,7 +1787,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                         // to keep any non-inlineable reexports so they can be\n                         // listed in the documentation.\n                         let remaining = list.iter().filter(|path| {\n-                            match inline::try_inline(path.node.id(), None) {\n+                            match inline::try_inline(cx, path.node.id(), None) {\n                                 Some(items) => {\n                                     ret.extend(items.move_iter()); false\n                                 }\n@@ -1826,7 +1803,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                         }\n                     }\n                     ast::ViewPathSimple(ident, _, id) => {\n-                        match inline::try_inline(id, Some(ident)) {\n+                        match inline::try_inline(cx, id, Some(ident)) {\n                             Some(items) => ret.extend(items.move_iter()),\n                             None => ret.push(convert(&self.node)),\n                         }\n@@ -1846,17 +1823,17 @@ pub enum ViewItemInner {\n }\n \n impl Clean<ViewItemInner> for ast::ViewItem_ {\n-    fn clean(&self) -> ViewItemInner {\n+    fn clean(&self, cx: &DocContext) -> ViewItemInner {\n         match self {\n             &ast::ViewItemExternCrate(ref i, ref p, ref id) => {\n                 let string = match *p {\n                     None => None,\n                     Some((ref x, _)) => Some(x.get().to_string()),\n                 };\n-                ExternCrate(i.clean(), string, *id)\n+                ExternCrate(i.clean(cx), string, *id)\n             }\n             &ast::ViewItemUse(ref vp) => {\n-                Import(vp.clean())\n+                Import(vp.clean(cx))\n             }\n         }\n     }\n@@ -1879,15 +1856,15 @@ pub struct ImportSource {\n }\n \n impl Clean<ViewPath> for ast::ViewPath {\n-    fn clean(&self) -> ViewPath {\n+    fn clean(&self, cx: &DocContext) -> ViewPath {\n         match self.node {\n             ast::ViewPathSimple(ref i, ref p, id) =>\n-                SimpleImport(i.clean(), resolve_use_source(p.clean(), id)),\n+                SimpleImport(i.clean(cx), resolve_use_source(cx, p.clean(cx), id)),\n             ast::ViewPathGlob(ref p, id) =>\n-                GlobImport(resolve_use_source(p.clean(), id)),\n+                GlobImport(resolve_use_source(cx, p.clean(cx), id)),\n             ast::ViewPathList(ref p, ref pl, id) => {\n-                ImportList(resolve_use_source(p.clean(), id),\n-                           pl.clean())\n+                ImportList(resolve_use_source(cx, p.clean(cx), id),\n+                           pl.clean(cx))\n             }\n         }\n     }\n@@ -1900,51 +1877,51 @@ pub struct ViewListIdent {\n }\n \n impl Clean<ViewListIdent> for ast::PathListItem {\n-    fn clean(&self) -> ViewListIdent {\n+    fn clean(&self, cx: &DocContext) -> ViewListIdent {\n         match self.node {\n             ast::PathListIdent { id, name } => ViewListIdent {\n-                name: name.clean(),\n-                source: resolve_def(id)\n+                name: name.clean(cx),\n+                source: resolve_def(cx, id)\n             },\n             ast::PathListMod { id } => ViewListIdent {\n                 name: \"mod\".to_string(),\n-                source: resolve_def(id)\n+                source: resolve_def(cx, id)\n             }\n         }\n     }\n }\n \n impl Clean<Vec<Item>> for ast::ForeignMod {\n-    fn clean(&self) -> Vec<Item> {\n-        self.items.clean()\n+    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+        self.items.clean(cx)\n     }\n }\n \n impl Clean<Item> for ast::ForeignItem {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n             ast::ForeignItemFn(ref decl, ref generics) => {\n                 ForeignFunctionItem(Function {\n-                    decl: decl.clean(),\n-                    generics: generics.clean(),\n+                    decl: decl.clean(cx),\n+                    generics: generics.clean(cx),\n                     fn_style: ast::UnsafeFn,\n                 })\n             }\n             ast::ForeignItemStatic(ref ty, mutbl) => {\n                 ForeignStaticItem(Static {\n-                    type_: ty.clean(),\n+                    type_: ty.clean(cx),\n                     mutability: if mutbl {Mutable} else {Immutable},\n                     expr: \"\".to_string(),\n                 })\n             }\n         };\n         Item {\n-            name: Some(self.ident.clean()),\n-            attrs: self.attrs.clean(),\n-            source: self.span.clean(),\n+            name: Some(self.ident.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.span.clean(cx),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n-            stability: get_stability(ast_util::local_def(self.id)),\n+            visibility: self.vis.clean(cx),\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n             inner: inner,\n         }\n     }\n@@ -1953,15 +1930,13 @@ impl Clean<Item> for ast::ForeignItem {\n // Utilities\n \n trait ToSource {\n-    fn to_src(&self) -> String;\n+    fn to_src(&self, cx: &DocContext) -> String;\n }\n \n impl ToSource for syntax::codemap::Span {\n-    fn to_src(&self) -> String {\n-        debug!(\"converting span {:?} to snippet\", self.clean());\n-        let ctxt = super::ctxtkey.get().unwrap();\n-        let cm = ctxt.sess().codemap().clone();\n-        let sn = match cm.span_to_snippet(*self) {\n+    fn to_src(&self, cx: &DocContext) -> String {\n+        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n+        let sn = match cx.sess().codemap().span_to_snippet(*self) {\n             Some(x) => x.to_string(),\n             None    => \"\".to_string()\n         };\n@@ -2030,16 +2005,16 @@ fn name_from_pat(p: &ast::Pat) -> String {\n }\n \n /// Given a Type, resolve it using the def_map\n-fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n+fn resolve_type(cx: &DocContext, path: Path,\n+                tpbs: Option<Vec<TyParamBound>>,\n                 id: ast::NodeId) -> Type {\n-    let cx = get_cx();\n-    let tycx = match cx.maybe_typed {\n-        core::Typed(ref tycx) => tycx,\n+    let tcx = match cx.tcx_opt() {\n+        Some(tcx) => tcx,\n         // If we're extracting tests, this return value doesn't matter.\n-        core::NotTyped(_) => return Primitive(Bool),\n+        None => return Primitive(Bool),\n     };\n     debug!(\"searching for {:?} in defmap\", id);\n-    let def = match tycx.def_map.borrow().find(&id) {\n+    let def = match tcx.def_map.borrow().find(&id) {\n         Some(&k) => k,\n         None => fail!(\"unresolved id not in defmap\")\n     };\n@@ -2071,7 +2046,7 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n     ResolvedPath { path: path, typarams: tpbs, did: did }\n }\n \n-fn register_def(cx: &core::DocContext, def: def::Def) -> ast::DefId {\n+fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {\n     let (did, kind) = match def {\n         def::DefFn(i, _) => (i, TypeFunction),\n         def::DefTy(i) => (i, TypeEnum),\n@@ -2083,31 +2058,31 @@ fn register_def(cx: &core::DocContext, def: def::Def) -> ast::DefId {\n         _ => return def.def_id()\n     };\n     if ast_util::is_local(did) { return did }\n-    let tcx = match cx.maybe_typed {\n-        core::Typed(ref t) => t,\n-        core::NotTyped(_) => return did\n+    let tcx = match cx.tcx_opt() {\n+        Some(tcx) => tcx,\n+        None => return did\n     };\n     inline::record_extern_fqn(cx, did, kind);\n     match kind {\n         TypeTrait => {\n-            let t = inline::build_external_trait(tcx, did);\n+            let t = inline::build_external_trait(cx, tcx, did);\n             cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n         }\n         _ => {}\n     }\n     return did;\n }\n \n-fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n+fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSource {\n     ImportSource {\n         path: path,\n-        did: resolve_def(id),\n+        did: resolve_def(cx, id),\n     }\n }\n \n-fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n-    get_cx().tcx_opt().and_then(|tcx| {\n-        tcx.def_map.borrow().find(&id).map(|&def| register_def(&*get_cx(), def))\n+fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n+    cx.tcx_opt().and_then(|tcx| {\n+        tcx.def_map.borrow().find(&id).map(|&def| register_def(cx, def))\n     })\n }\n \n@@ -2117,16 +2092,16 @@ pub struct Macro {\n }\n \n impl Clean<Item> for doctree::Macro {\n-    fn clean(&self) -> Item {\n+    fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(format!(\"{}!\", self.name.clean())),\n-            attrs: self.attrs.clean(),\n-            source: self.whence.clean(),\n-            visibility: ast::Public.clean(),\n-            stability: self.stab.clean(),\n+            name: Some(format!(\"{}!\", self.name.clean(cx))),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            visibility: ast::Public.clean(cx),\n+            stability: self.stab.clean(cx),\n             def_id: ast_util::local_def(self.id),\n             inner: MacroItem(Macro {\n-                source: self.whence.to_src(),\n+                source: self.whence.to_src(cx),\n             }),\n         }\n     }\n@@ -2139,7 +2114,7 @@ pub struct Stability {\n }\n \n impl Clean<Stability> for attr::Stability {\n-    fn clean(&self) -> Stability {\n+    fn clean(&self, _: &DocContext) -> Stability {\n         Stability {\n             level: self.level,\n             text: self.text.as_ref().map_or(\"\".to_string(),\n@@ -2148,18 +2123,18 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n-fn lang_struct(did: Option<ast::DefId>, t: ty::t, name: &str,\n+fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n+               t: ty::t, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {\n     let did = match did {\n         Some(did) => did,\n-        None => return fallback(box t.clean()),\n+        None => return fallback(box t.clean(cx)),\n     };\n-    let fqn = csearch::get_item_path(get_cx().tcx(), did);\n+    let fqn = csearch::get_item_path(cx.tcx(), did);\n     let fqn: Vec<String> = fqn.move_iter().map(|i| {\n         i.to_string()\n     }).collect();\n-    get_cx().external_paths.borrow_mut().as_mut().unwrap()\n-                           .insert(did, (fqn, TypeStruct));\n+    cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, TypeStruct));\n     ResolvedPath {\n         typarams: None,\n         did: did,\n@@ -2168,7 +2143,7 @@ fn lang_struct(did: Option<ast::DefId>, t: ty::t, name: &str,\n             segments: vec![PathSegment {\n                 name: name.to_string(),\n                 lifetimes: vec![],\n-                types: vec![t.clean()],\n+                types: vec![t.clean(cx)],\n             }],\n         },\n     }"}, {"sha": "a8cd9f18d60a52b152a1a3bdaba9cea57be42b74", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "patch": "@@ -22,23 +22,24 @@ use std::cell::RefCell;\n use std::gc::GC;\n use std::os;\n use std::collections::{HashMap, HashSet};\n+use arena::TypedArena;\n \n use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n \n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n-pub enum MaybeTyped {\n-    Typed(middle::ty::ctxt),\n+pub enum MaybeTyped<'tcx> {\n+    Typed(middle::ty::ctxt<'tcx>),\n     NotTyped(driver::session::Session)\n }\n \n pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n                                                 (Vec<String>, clean::TypeKind)>>>;\n \n-pub struct DocContext {\n+pub struct DocContext<'tcx> {\n     pub krate: ast::Crate,\n-    pub maybe_typed: MaybeTyped,\n+    pub maybe_typed: MaybeTyped<'tcx>,\n     pub src: Path,\n     pub external_paths: ExternalPaths,\n     pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n@@ -47,22 +48,22 @@ pub struct DocContext {\n     pub populated_crate_impls: RefCell<HashSet<ast::CrateNum>>,\n }\n \n-impl DocContext {\n+impl<'tcx> DocContext<'tcx> {\n     pub fn sess<'a>(&'a self) -> &'a driver::session::Session {\n         match self.maybe_typed {\n             Typed(ref tcx) => &tcx.sess,\n             NotTyped(ref sess) => sess\n         }\n     }\n \n-    pub fn tcx_opt<'a>(&'a self) -> Option<&'a ty::ctxt> {\n+    pub fn tcx_opt<'a>(&'a self) -> Option<&'a ty::ctxt<'tcx>> {\n         match self.maybe_typed {\n             Typed(ref tcx) => Some(tcx),\n             NotTyped(_) => None\n         }\n     }\n \n-    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         let tcx_opt = self.tcx_opt();\n         tcx_opt.expect(\"tcx not present\")\n     }\n@@ -80,9 +81,10 @@ pub struct CrateAnalysis {\n pub type Externs = HashMap<String, Vec<String>>;\n \n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n-                       externs: Externs, triple: Option<String>)\n-                       -> (DocContext, CrateAnalysis) {\n+fn get_ast_and_resolve<'tcx>(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n+                             externs: Externs, triple: Option<String>,\n+                             type_arena: &'tcx TypedArena<ty::t_box_>)\n+                             -> (DocContext<'tcx>, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n     use rustc::driver::driver::{FileInput,\n                                 phase_1_parse_input,\n@@ -131,7 +133,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n \n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n-    } = phase_3_run_analysis_passes(sess, &krate, ast_map, name);\n+    } = phase_3_run_analysis_passes(sess, &krate, ast_map, type_arena, name);\n \n     debug!(\"crate: {:?}\", krate);\n     (DocContext {\n@@ -156,14 +158,14 @@ fn get_ast_and_resolve(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n                 path: &Path, triple: Option<String>)\n                 -> (clean::Crate, CrateAnalysis) {\n-    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs, triple);\n-    let ctxt = box(GC) ctxt;\n-    super::ctxtkey.replace(Some(ctxt));\n+    let type_arena = TypedArena::new();\n+    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs,\n+                                               triple, &type_arena);\n \n     let krate = {\n-        let mut v = RustdocVisitor::new(&*ctxt, Some(&analysis));\n+        let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n         v.visit(&ctxt.krate);\n-        v.clean()\n+        v.clean(&ctxt)\n     };\n \n     let external_paths = ctxt.external_paths.borrow_mut().take();"}, {"sha": "758af6758c2c47db92c8cbe8f071a171d396986b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "patch": "@@ -17,6 +17,7 @@\n \n #![feature(globs, struct_variant, managed_boxes, macro_rules, phase)]\n \n+extern crate arena;\n extern crate debug;\n extern crate getopts;\n extern crate libc;\n@@ -29,7 +30,6 @@ extern crate time;\n \n use std::io;\n use std::io::{File, MemWriter};\n-use std::gc::Gc;\n use std::collections::HashMap;\n use serialize::{json, Decodable, Encodable};\n use externalfiles::ExternalHtml;\n@@ -83,7 +83,6 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n     \"unindent-comments\",\n ];\n \n-local_data_key!(pub ctxtkey: Gc<core::DocContext>)\n local_data_key!(pub analysiskey: core::CrateAnalysis)\n \n type Output = (clean::Crate, Vec<plugins::PluginJson> );"}, {"sha": "0eb0a9afd751cad7c1791d844ac8061e1f05ae82", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "patch": "@@ -74,7 +74,7 @@ pub fn run(input: &str,\n                                                           \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n-    let ctx = box(GC) core::DocContext {\n+    let ctx = core::DocContext {\n         krate: krate,\n         maybe_typed: core::NotTyped(sess),\n         src: input_path,\n@@ -84,11 +84,10 @@ pub fn run(input: &str,\n         inlined: RefCell::new(None),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n     };\n-    super::ctxtkey.replace(Some(ctx));\n \n-    let mut v = RustdocVisitor::new(&*ctx, None);\n+    let mut v = RustdocVisitor::new(&ctx, None);\n     v.visit(&ctx.krate);\n-    let mut krate = v.clean();\n+    let mut krate = v.clean(&ctx);\n     match crate_name {\n         Some(name) => krate.name = name,\n         None => {}"}, {"sha": "79576cac20af3b759b532b7bdb75eecd47028266", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfbcddf5382ab156b442b08f3236800d0b6ccd8/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8bfbcddf5382ab156b442b08f3236800d0b6ccd8", "patch": "@@ -34,16 +34,16 @@ use doctree::*;\n // also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?\n \n-pub struct RustdocVisitor<'a> {\n+pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n     pub attrs: Vec<ast::Attribute>,\n-    pub cx: &'a core::DocContext,\n+    pub cx: &'a core::DocContext<'tcx>,\n     pub analysis: Option<&'a core::CrateAnalysis>,\n }\n \n-impl<'a> RustdocVisitor<'a> {\n-    pub fn new<'b>(cx: &'b core::DocContext,\n-                   analysis: Option<&'b core::CrateAnalysis>) -> RustdocVisitor<'b> {\n+impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n+    pub fn new(cx: &'a core::DocContext<'tcx>,\n+               analysis: Option<&'a core::CrateAnalysis>) -> RustdocVisitor<'a, 'tcx> {\n         RustdocVisitor {\n             module: Module::new(None),\n             attrs: Vec::new(),\n@@ -53,11 +53,7 @@ impl<'a> RustdocVisitor<'a> {\n     }\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        let tcx = match self.cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => return None\n-        };\n-        stability::lookup(tcx, ast_util::local_def(id))\n+        self.cx.tcx_opt().and_then(|tcx| stability::lookup(tcx, ast_util::local_def(id)))\n     }\n \n     pub fn visit(&mut self, krate: &ast::Crate) {\n@@ -225,9 +221,9 @@ impl<'a> RustdocVisitor<'a> {\n \n     fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Ident>,\n                   glob: bool, om: &mut Module, please_inline: bool) -> bool {\n-        let tcx = match self.cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => return false\n+        let tcx = match self.cx.tcx_opt() {\n+            Some(tcx) => tcx,\n+            None => return false\n         };\n         let def = (*tcx.def_map.borrow())[id].def_id();\n         if !ast_util::is_local(def) { return false }"}]}