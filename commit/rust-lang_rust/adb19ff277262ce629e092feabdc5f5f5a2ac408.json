{"sha": "adb19ff277262ce629e092feabdc5f5f5a2ac408", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYjE5ZmYyNzcyNjJjZTYyOWUwOTJmZWFiZGM1ZjVmNWEyYWM0MDg=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-18T16:13:15Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-09-05T04:26:41Z"}, "message": "Add AdjustNeverToAny in check_expr", "tree": {"sha": "6d6a7645fc7840ad9d1422edfa297b6ab6a35171", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d6a7645fc7840ad9d1422edfa297b6ab6a35171"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adb19ff277262ce629e092feabdc5f5f5a2ac408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adb19ff277262ce629e092feabdc5f5f5a2ac408", "html_url": "https://github.com/rust-lang/rust/commit/adb19ff277262ce629e092feabdc5f5f5a2ac408", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adb19ff277262ce629e092feabdc5f5f5a2ac408/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cd8d7a24f73e7de91cc3ba4461eeb6fe8a086f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cd8d7a24f73e7de91cc3ba4461eeb6fe8a086f3", "html_url": "https://github.com/rust-lang/rust/commit/9cd8d7a24f73e7de91cc3ba4461eeb6fe8a086f3"}], "stats": {"total": 130, "additions": 57, "deletions": 73}, "files": [{"sha": "2a12b7055d4ed1a7b89eae7ece1a06812f101bad", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 57, "deletions": 73, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/adb19ff277262ce629e092feabdc5f5f5a2ac408/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb19ff277262ce629e092feabdc5f5f5a2ac408/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=adb19ff277262ce629e092feabdc5f5f5a2ac408", "patch": "@@ -1530,21 +1530,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n-\n-        // Add adjustments to !-expressions\n-        if ty.is_never() {\n-            if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(node_id) {\n-                let adj_ty = self.next_diverging_ty_var();\n-                let adj = adjustment::AdjustNeverToAny(adj_ty);\n-                self.write_adjustment(node_id, adj);\n-                return adj_ty;\n-            }\n-        }\n-        ty\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -1717,16 +1706,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty_substituted\n     }\n \n-    pub fn write_nil(&self, node_id: ast::NodeId) -> Ty<'tcx> {\n-        self.write_ty(node_id, self.tcx.mk_nil())\n+    pub fn write_nil(&self, node_id: ast::NodeId) {\n+        self.write_ty(node_id, self.tcx.mk_nil());\n     }\n \n-    pub fn write_never(&self, node_id: ast::NodeId) -> Ty<'tcx> {\n-        self.write_ty(node_id, self.tcx.types.never)\n+    pub fn write_never(&self, node_id: ast::NodeId) {\n+        self.write_ty(node_id, self.tcx.types.never);\n     }\n \n-    pub fn write_error(&self, node_id: ast::NodeId) -> Ty<'tcx> {\n-        self.write_ty(node_id, self.tcx.types.err)\n+    pub fn write_error(&self, node_id: ast::NodeId) {\n+        self.write_ty(node_id, self.tcx.types.err);\n     }\n \n     pub fn require_type_meets(&self,\n@@ -3314,20 +3303,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             });\n             let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n-            self.write_ty(id, tcx.mk_box(referent_ty))\n+            tcx.mk_box(referent_ty)\n           }\n \n           hir::ExprLit(ref lit) => {\n-            let typ = self.check_lit(&lit, expected);\n-            self.write_ty(id, typ)\n+            self.check_lit(&lit, expected)\n           }\n           hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            let ty = self.check_binop(expr, op, lhs, rhs);\n-            self.write_ty(id, ty)\n+            self.check_binop(expr, op, lhs, rhs)\n           }\n           hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            let ty = self.check_binop_assign(expr, op, lhs, rhs);\n-            self.write_ty(id, ty)\n+            self.check_binop_assign(expr, op, lhs, rhs)\n           }\n           hir::ExprUnary(unop, ref oprnd) => {\n             let expected_inner = match unop {\n@@ -3386,7 +3372,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            self.write_ty(id, oprnd_t)\n+            oprnd_t\n           }\n           hir::ExprAddrOf(mutbl, ref oprnd) => {\n             let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n@@ -3408,7 +3394,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let ty = self.check_expr_with_expectation_and_lvalue_pref(&oprnd, hint, lvalue_pref);\n \n             let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n-            let oprnd_t = if tm.ty.references_error() {\n+            if tm.ty.references_error() {\n                 tcx.types.err\n             } else {\n                 // Note: at this point, we cannot say what the best lifetime\n@@ -3426,8 +3412,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // as long as it needs to live.\n                 let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n                 tcx.mk_ref(region, tm)\n-            };\n-            self.write_ty(id, oprnd_t)\n+            }\n           }\n           hir::ExprPath(ref opt_qself, ref path) => {\n               let opt_self_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n@@ -3446,7 +3431,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   self.add_wf_bounds(&item_substs.substs, expr);\n               });\n \n-              self.write_ty(id, ty)\n+              ty\n           }\n           hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n               for output in outputs {\n@@ -3455,10 +3440,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               for input in inputs {\n                   self.check_expr(input);\n               }\n-              self.write_nil(id)\n+              tcx.mk_nil()\n           }\n-          hir::ExprBreak(_) => { self.write_never(id) }\n-          hir::ExprAgain(_) => { self.write_never(id) }\n+          hir::ExprBreak(_) => { tcx.types.never }\n+          hir::ExprAgain(_) => { tcx.types.never }\n           hir::ExprRet(ref expr_opt) => {\n             if let Some(ref e) = *expr_opt {\n                 self.check_expr_coercable_to_type(&e, self.ret_ty);\n@@ -3476,7 +3461,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         .emit();\n                 }\n             }\n-            self.write_never(id)\n+            tcx.types.never\n           }\n           hir::ExprAssign(ref lhs, ref rhs) => {\n             let lhs_ty = self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n@@ -3497,55 +3482,49 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n             if lhs_ty.references_error() || rhs_ty.references_error() {\n-                self.write_error(id)\n+                tcx.types.err\n             } else {\n-                self.write_nil(id)\n+                tcx.mk_nil()\n             }\n           }\n           hir::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n-            let if_ty = self.check_then_else(&cond, &then_blk, opt_else_expr.as_ref().map(|e| &**e),\n-                                 expr.span, expected);\n-            self.write_ty(id, if_ty)\n+            self.check_then_else(&cond, &then_blk, opt_else_expr.as_ref().map(|e| &**e),\n+                                 expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n             let cond_ty = self.check_expr_has_type(&cond, tcx.types.bool);\n             self.check_block_no_value(&body);\n             let body_ty = self.node_ty(body.id);\n             if cond_ty.references_error() || body_ty.references_error() {\n-                self.write_error(id)\n+                tcx.types.err\n             }\n             else {\n-                self.write_nil(id)\n+                tcx.mk_nil()\n             }\n           }\n           hir::ExprLoop(ref body, _) => {\n             self.check_block_no_value(&body);\n             if !may_break(tcx, expr.id, &body) {\n-                self.write_never(id)\n+                tcx.types.never\n             } else {\n-                self.write_nil(id)\n+                tcx.mk_nil()\n             }\n           }\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n-            let result_ty = self.check_match(expr, &discrim, arms, expected, match_src);\n-            self.write_ty(expr.id, result_ty)\n+            self.check_match(expr, &discrim, arms, expected, match_src)\n           }\n           hir::ExprClosure(capture, ref decl, ref body, _) => {\n-              let ty = self.check_expr_closure(expr, capture, &decl, &body, expected);\n-              self.write_ty(id, ty)\n+              self.check_expr_closure(expr, capture, &decl, &body, expected)\n           }\n           hir::ExprBlock(ref b) => {\n             self.check_block_with_expected(&b, expected);\n-            let ty = self.node_ty(b.id);\n-            self.write_ty(id, ty)\n+            self.node_ty(b.id)\n           }\n           hir::ExprCall(ref callee, ref args) => {\n-              let ret_ty = self.check_call(expr, &callee, &args[..], expected);\n-              self.write_ty(id, ret_ty)\n+              self.check_call(expr, &callee, &args[..], expected)\n           }\n           hir::ExprMethodCall(name, ref tps, ref args) => {\n-              let ret_ty = self.check_method_call(expr, name, &args[..], &tps[..], expected, lvalue_pref);\n-              self.write_ty(id, ret_ty)\n+              self.check_method_call(expr, name, &args[..], &tps[..], expected, lvalue_pref)\n           }\n           hir::ExprCast(ref e, ref t) => {\n             if let hir::TyFixedLengthVec(_, ref count_expr) = t.node {\n@@ -3561,25 +3540,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Eagerly check for some obvious errors.\n             if t_expr.references_error() || t_cast.references_error() {\n-                self.write_error(id)\n+                tcx.types.err\n             } else {\n                 // Defer other checks until we're done type checking.\n                 let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n                 match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n                     Ok(cast_check) => {\n                         deferred_cast_checks.push(cast_check);\n-                        self.write_ty(id, t_cast)\n+                        t_cast\n                     }\n                     Err(ErrorReported) => {\n-                        self.write_error(id)\n+                        tcx.types.err\n                     }\n                 }\n             }\n           }\n           hir::ExprType(ref e, ref t) => {\n             let typ = self.to_ty(&t);\n             self.check_expr_eq_type(&e, typ);\n-            self.write_ty(id, typ)\n+            typ\n           }\n           hir::ExprVec(ref args) => {\n             let uty = expected.to_option(self).and_then(|uty| {\n@@ -3611,7 +3590,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            self.write_ty(id, tcx.mk_array(unified, args.len()))\n+            tcx.mk_array(unified, args.len())\n           }\n           hir::ExprRepeat(ref element, ref count_expr) => {\n             self.check_expr_has_type(&count_expr, tcx.types.usize);\n@@ -3647,10 +3626,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             if element_ty.references_error() {\n-                self.write_error(id)\n+                tcx.types.err\n             } else {\n-                let t = tcx.mk_array(t, count);\n-                self.write_ty(id, t)\n+                tcx.mk_array(t, count)\n             }\n           }\n           hir::ExprTup(ref elts) => {\n@@ -3677,29 +3655,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 t\n             }).collect();\n             if err_field {\n-                self.write_error(id)\n+                tcx.types.err\n             } else {\n-                let typ = tcx.mk_tup(elt_ts);\n-                self.write_ty(id, typ)\n+                tcx.mk_tup(elt_ts)\n             }\n           }\n           hir::ExprStruct(ref path, ref fields, ref base_expr) => {\n-            let ty = self.check_expr_struct(expr, path, fields, base_expr);\n-            self.write_ty(id, ty)\n+            self.check_expr_struct(expr, path, fields, base_expr)\n           }\n           hir::ExprField(ref base, ref field) => {\n-            let ty = self.check_field(expr, lvalue_pref, &base, field);\n-            self.write_ty(id, ty)\n+            self.check_field(expr, lvalue_pref, &base, field)\n           }\n           hir::ExprTupField(ref base, idx) => {\n-            let ty = self.check_tup_field(expr, lvalue_pref, &base, idx);\n-            self.write_ty(id, ty)\n+            self.check_tup_field(expr, lvalue_pref, &base, idx)\n           }\n           hir::ExprIndex(ref base, ref idx) => {\n               let base_t = self.check_expr_with_lvalue_pref(&base, lvalue_pref);\n               let idx_t = self.check_expr(&idx);\n \n-              let ty = if base_t.references_error() {\n+              if base_t.references_error() {\n                   base_t\n               } else if idx_t.references_error() {\n                   idx_t\n@@ -3747,16 +3721,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           self.tcx().types.err\n                       }\n                   }\n-              };\n-              self.write_ty(id, ty)\n+              }\n            }\n         };\n+        self.write_ty(id, ty);\n \n         debug!(\"type of expr({}) {} is...\", expr.id,\n                pprust::expr_to_string(expr));\n         debug!(\"... {:?}, expected is {:?}\",\n                ty,\n                expected);\n+\n+        // Add adjustments to !-expressions\n+        if ty.is_never() {\n+            if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(id) {\n+                let adj_ty = self.next_diverging_ty_var();\n+                let adj = adjustment::AdjustNeverToAny(adj_ty);\n+                self.write_adjustment(id, adj);\n+                return adj_ty;\n+            }\n+        }\n         ty\n     }\n "}]}