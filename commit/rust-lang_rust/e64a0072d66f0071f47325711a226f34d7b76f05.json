{"sha": "e64a0072d66f0071f47325711a226f34d7b76f05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NGEwMDcyZDY2ZjAwNzFmNDczMjU3MTFhMjI2ZjM0ZDdiNzZmMDU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-15T04:03:34Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-19T15:51:00Z"}, "message": "librustc: use `#[deriving(Copy)]`", "tree": {"sha": "ef361346b8ec0691106128bc98ef7db78ccf1c52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef361346b8ec0691106128bc98ef7db78ccf1c52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e64a0072d66f0071f47325711a226f34d7b76f05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e64a0072d66f0071f47325711a226f34d7b76f05", "html_url": "https://github.com/rust-lang/rust/commit/e64a0072d66f0071f47325711a226f34d7b76f05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e64a0072d66f0071f47325711a226f34d7b76f05/comments", "author": null, "committer": null, "parents": [{"sha": "f2ef2cda526ba601cf5091f65cb12962a0ae0956", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2ef2cda526ba601cf5091f65cb12962a0ae0956", "html_url": "https://github.com/rust-lang/rust/commit/f2ef2cda526ba601cf5091f65cb12962a0ae0956"}], "stats": {"total": 585, "additions": 159, "deletions": 426}, "files": [{"sha": "88b12aa5660c99929c3785e4cd6b72759915f6c8", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -56,10 +56,9 @@ declare_lint! {\n     \"suggest using `loop { }` instead of `while true { }`\"\n }\n \n+#[deriving(Copy)]\n pub struct WhileTrue;\n \n-impl Copy for WhileTrue {}\n-\n impl LintPass for WhileTrue {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(WHILE_TRUE)\n@@ -83,10 +82,9 @@ declare_lint! {\n     \"detects unnecessary type casts that can be removed\"\n }\n \n+#[deriving(Copy)]\n pub struct UnusedCasts;\n \n-impl Copy for UnusedCasts {}\n-\n impl LintPass for UnusedCasts {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_TYPECASTS)\n@@ -126,13 +124,12 @@ declare_lint! {\n     \"shift exceeds the type's number of bits\"\n }\n \n+#[deriving(Copy)]\n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n     negated_expr_id: ast::NodeId,\n }\n \n-impl Copy for TypeLimits {}\n-\n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n         TypeLimits {\n@@ -442,10 +439,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n     }\n }\n \n+#[deriving(Copy)]\n pub struct ImproperCTypes;\n \n-impl Copy for ImproperCTypes {}\n-\n impl LintPass for ImproperCTypes {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(IMPROPER_CTYPES)\n@@ -486,10 +482,9 @@ declare_lint! {\n     \"use of owned (Box type) heap memory\"\n }\n \n+#[deriving(Copy)]\n pub struct BoxPointers;\n \n-impl Copy for BoxPointers {}\n-\n impl BoxPointers {\n     fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n                                  span: Span, ty: Ty<'tcx>) {\n@@ -627,10 +622,9 @@ declare_lint! {\n     \"detects attributes that were not used by the compiler\"\n }\n \n+#[deriving(Copy)]\n pub struct UnusedAttributes;\n \n-impl Copy for UnusedAttributes {}\n-\n impl LintPass for UnusedAttributes {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_ATTRIBUTES)\n@@ -711,10 +705,9 @@ declare_lint! {\n     \"path statements with no effect\"\n }\n \n+#[deriving(Copy)]\n pub struct PathStatements;\n \n-impl Copy for PathStatements {}\n-\n impl LintPass for PathStatements {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(PATH_STATEMENTS)\n@@ -746,10 +739,9 @@ declare_lint! {\n     \"unused result of an expression in a statement\"\n }\n \n+#[deriving(Copy)]\n pub struct UnusedResults;\n \n-impl Copy for UnusedResults {}\n-\n impl LintPass for UnusedResults {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n@@ -815,10 +807,9 @@ declare_lint! {\n     \"types, variants, traits and type parameters should have camel case names\"\n }\n \n+#[deriving(Copy)]\n pub struct NonCamelCaseTypes;\n \n-impl Copy for NonCamelCaseTypes {}\n-\n impl NonCamelCaseTypes {\n     fn check_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_camel_case(ident: ast::Ident) -> bool {\n@@ -939,10 +930,9 @@ declare_lint! {\n     \"methods, functions, lifetime parameters and modules should have snake case names\"\n }\n \n+#[deriving(Copy)]\n pub struct NonSnakeCase;\n \n-impl Copy for NonSnakeCase {}\n-\n impl NonSnakeCase {\n     fn check_snake_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_snake_case(ident: ast::Ident) -> bool {\n@@ -1053,10 +1043,9 @@ declare_lint! {\n     \"static constants should have uppercase identifiers\"\n }\n \n+#[deriving(Copy)]\n pub struct NonUpperCaseGlobals;\n \n-impl Copy for NonUpperCaseGlobals {}\n-\n impl LintPass for NonUpperCaseGlobals {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_UPPER_CASE_GLOBALS)\n@@ -1107,10 +1096,9 @@ declare_lint! {\n     \"`if`, `match`, `while` and `return` do not need parentheses\"\n }\n \n+#[deriving(Copy)]\n pub struct UnusedParens;\n \n-impl Copy for UnusedParens {}\n-\n impl UnusedParens {\n     fn check_unused_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n                                      struct_lit_needs_parens: bool) {\n@@ -1202,10 +1190,9 @@ declare_lint! {\n     \"unnecessary braces around an imported item\"\n }\n \n+#[deriving(Copy)]\n pub struct UnusedImportBraces;\n \n-impl Copy for UnusedImportBraces {}\n-\n impl LintPass for UnusedImportBraces {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_IMPORT_BRACES)\n@@ -1242,10 +1229,9 @@ declare_lint! {\n     \"using `Struct { x: x }` instead of `Struct { x }`\"\n }\n \n+#[deriving(Copy)]\n pub struct NonShorthandFieldPatterns;\n \n-impl Copy for NonShorthandFieldPatterns {}\n-\n impl LintPass for NonShorthandFieldPatterns {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_SHORTHAND_FIELD_PATTERNS)\n@@ -1276,10 +1262,9 @@ declare_lint! {\n     \"unnecessary use of an `unsafe` block\"\n }\n \n+#[deriving(Copy)]\n pub struct UnusedUnsafe;\n \n-impl Copy for UnusedUnsafe {}\n-\n impl LintPass for UnusedUnsafe {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_UNSAFE)\n@@ -1302,10 +1287,9 @@ declare_lint! {\n     \"usage of an `unsafe` block\"\n }\n \n+#[deriving(Copy)]\n pub struct UnsafeBlocks;\n \n-impl Copy for UnsafeBlocks {}\n-\n impl LintPass for UnsafeBlocks {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSAFE_BLOCKS)\n@@ -1327,10 +1311,9 @@ declare_lint! {\n     \"detect mut variables which don't need to be mutable\"\n }\n \n+#[deriving(Copy)]\n pub struct UnusedMut;\n \n-impl Copy for UnusedMut {}\n-\n impl UnusedMut {\n     fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<ast::Pat>]) {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n@@ -1397,10 +1380,9 @@ declare_lint! {\n     \"detects unnecessary allocations that can be eliminated\"\n }\n \n+#[deriving(Copy)]\n pub struct UnusedAllocation;\n \n-impl Copy for UnusedAllocation {}\n-\n impl LintPass for UnusedAllocation {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_ALLOCATION)\n@@ -1589,10 +1571,9 @@ impl LintPass for MissingDoc {\n     }\n }\n \n+#[deriving(Copy)]\n pub struct MissingCopyImplementations;\n \n-impl Copy for MissingCopyImplementations {}\n-\n impl LintPass for MissingCopyImplementations {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MISSING_COPY_IMPLEMENTATIONS)\n@@ -1665,10 +1646,9 @@ declare_lint! {\n \n /// Checks for use of items with `#[deprecated]`, `#[experimental]` and\n /// `#[unstable]` attributes, or no stability attribute.\n+#[deriving(Copy)]\n pub struct Stability;\n \n-impl Copy for Stability {}\n-\n impl Stability {\n     fn lint(&self, cx: &Context, id: ast::DefId, span: Span) {\n         let stability = stability::lookup(cx.tcx, id);\n@@ -1903,10 +1883,9 @@ declare_lint!{\n \n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n+#[deriving(Copy)]\n pub struct HardwiredLints;\n \n-impl Copy for HardwiredLints {}\n-\n impl LintPass for HardwiredLints {\n     fn get_lints(&self) -> LintArray {\n         lint_array!("}, {"sha": "009a1d444dc137b1e5574fdb07d994e959f5346f", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -42,6 +42,7 @@ use syntax::ast;\n pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs};\n \n /// Specification of a single lint.\n+#[deriving(Copy)]\n pub struct Lint {\n     /// A string identifier for the lint.\n     ///\n@@ -64,8 +65,6 @@ pub struct Lint {\n     pub desc: &'static str,\n }\n \n-impl Copy for Lint {}\n-\n impl Lint {\n     /// Get the lint's name, with ASCII letters converted to lowercase.\n     pub fn name_lower(&self) -> String {\n@@ -175,14 +174,12 @@ pub trait LintPass {\n pub type LintPassObject = Box<LintPass + 'static>;\n \n /// Identifies a lint known to the compiler.\n-#[deriving(Clone)]\n+#[deriving(Clone, Copy)]\n pub struct LintId {\n     // Identity is based on pointer equality of this field.\n     lint: &'static Lint,\n }\n \n-impl Copy for LintId {}\n-\n impl PartialEq for LintId {\n     fn eq(&self, other: &LintId) -> bool {\n         (self.lint as *const Lint) == (other.lint as *const Lint)\n@@ -213,13 +210,11 @@ impl LintId {\n }\n \n /// Setting for how to handle a lint.\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+#[deriving(Clone, Copy, PartialEq, PartialOrd, Eq, Ord)]\n pub enum Level {\n     Allow, Warn, Deny, Forbid\n }\n \n-impl Copy for Level {}\n-\n impl Level {\n     /// Convert a level to a lower-case string.\n     pub fn as_str(self) -> &'static str {\n@@ -244,7 +239,7 @@ impl Level {\n }\n \n /// How a lint level was set.\n-#[deriving(Clone, PartialEq, Eq)]\n+#[deriving(Clone, Copy, PartialEq, Eq)]\n pub enum LintSource {\n     /// Lint is at the default level as declared\n     /// in rustc or a plugin.\n@@ -257,8 +252,6 @@ pub enum LintSource {\n     CommandLine,\n }\n \n-impl Copy for LintSource {}\n-\n pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;"}, {"sha": "03e436e98df46390e753c9294c5c2aafe9af7518", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -113,7 +113,7 @@ pub const tag_items_data_item_reexport_def_id: uint = 0x39;\n pub const tag_items_data_item_reexport_name: uint = 0x3a;\n \n // used to encode crate_ctxt side tables\n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n #[repr(uint)]\n pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_ast = 0x40,\n@@ -145,7 +145,6 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_object_cast_map = 0x57,\n }\n \n-impl Copy for astencode_tag {}\n static first_astencode_tag: uint = tag_ast as uint;\n static last_astencode_tag: uint = tag_table_object_cast_map as uint;\n impl astencode_tag {"}, {"sha": "a474af7c6e1ff0dd81173ae09ffce2f8ef91dddc", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -33,14 +33,13 @@ use syntax::parse::token;\n \n use std::collections::hash_map::HashMap;\n \n+#[deriving(Copy)]\n pub struct MethodInfo {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n     pub vis: ast::Visibility,\n }\n \n-impl Copy for MethodInfo {}\n-\n pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> String {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_symbol(cdata.data(), def.node)"}, {"sha": "d5247472c34478fab57665d22a8d91d91c042b28", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -48,23 +48,19 @@ pub struct crate_metadata {\n     pub span: Span,\n }\n \n-#[deriving(Show, PartialEq, Clone)]\n+#[deriving(Copy, Show, PartialEq, Clone)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-impl Copy for LinkagePreference {}\n-\n-#[deriving(Clone, PartialEq, FromPrimitive)]\n+#[deriving(Copy, Clone, PartialEq, FromPrimitive)]\n pub enum NativeLibraryKind {\n     NativeStatic,    // native static library (.a archive)\n     NativeFramework, // OSX-specific\n     NativeUnknown,   // default way to specify a dynamic library\n }\n \n-impl Copy for NativeLibraryKind {}\n-\n // Where a crate came from on the local filesystem. One of these two options\n // must be non-None.\n #[deriving(PartialEq, Clone)]"}, {"sha": "b89c5dbcd0885af2dc093e0b8777bd61de88e77e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -450,15 +450,13 @@ pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n }\n \n // Something that a name can resolve to.\n-#[deriving(Clone,Show)]\n+#[deriving(Copy, Clone, Show)]\n pub enum DefLike {\n     DlDef(def::Def),\n     DlImpl(ast::DefId),\n     DlField\n }\n \n-impl Copy for DefLike {}\n-\n /// Iterates over the language items in the given crate.\n pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n     F: FnMut(ast::NodeId, uint) -> bool,"}, {"sha": "0b859abc531c8f4be5ceac4cc1bfae32e978592f", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -20,13 +20,12 @@ use std::os;\n \n use util::fs as myfs;\n \n+#[deriving(Copy)]\n pub enum FileMatch {\n     FileMatches,\n     FileDoesntMatch,\n }\n \n-impl Copy for FileMatch {}\n-\n // A module for searching for libraries\n // FIXME (#2658): I'm not happy how this module turned out. Should\n // probably just be folded into cstore."}, {"sha": "9d3a2c1d667779997859e4b5dd63924b8dc5bef8", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -44,7 +44,7 @@ use syntax::parse::token;\n // def-id will depend on where it originated from.  Therefore, the conversion\n // function is given an indicator of the source of the def-id.  See\n // astencode.rs for more information.\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n pub enum DefIdSource {\n     // Identifies a struct, trait, enum, etc.\n     NominalType,\n@@ -62,7 +62,6 @@ pub enum DefIdSource {\n     UnboxedClosureSource\n }\n \n-impl Copy for DefIdSource {}\n pub type conv_did<'a> =\n     |source: DefIdSource, ast::DefId|: 'a -> ast::DefId;\n "}, {"sha": "82bed2540317fa7ed7fa5033e6793bdd3aa1c936", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -26,14 +26,13 @@ struct CFGBuilder<'a, 'tcx: 'a> {\n     loop_scopes: Vec<LoopScope>,\n }\n \n+#[deriving(Copy)]\n struct LoopScope {\n     loop_id: ast::NodeId,     // id of loop/while node\n     continue_index: CFGIndex, // where to go on a `loop`\n     break_index: CFGIndex,    // where to go on a `break\n }\n \n-impl Copy for LoopScope {}\n-\n pub fn construct(tcx: &ty::ctxt,\n                  blk: &ast::Block) -> CFG {\n     let mut graph = graph::Graph::new();"}, {"sha": "a74fff5630bfd0d48301c8bd3037731a2f5a4f88", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -26,12 +26,11 @@ pub struct CFG {\n     pub exit: CFGIndex,\n }\n \n+#[deriving(Copy)]\n pub struct CFGNodeData {\n     pub id: ast::NodeId\n }\n \n-impl Copy for CFGNodeData {}\n-\n pub struct CFGEdgeData {\n     pub exiting_scopes: Vec<ast::NodeId>\n }"}, {"sha": "cb454f94dc74c5fecc1094dc3ecdca88d9cdeb66", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -16,20 +16,17 @@ use syntax::codemap::Span;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, Copy, PartialEq)]\n enum Context {\n     Normal, Loop, Closure\n }\n \n-impl Copy for Context {}\n-\n+#[deriving(Copy)]\n struct CheckLoopVisitor<'a> {\n     sess: &'a Session,\n     cx: Context\n }\n \n-impl<'a> Copy for CheckLoopVisitor<'a> {}\n-\n pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n     visit::walk_crate(&mut CheckLoopVisitor { sess: sess, cx: Normal }, krate)\n }"}, {"sha": "79e776c330884fe44fd93367dff18bc9e50ecb87", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -127,13 +127,12 @@ enum Usefulness {\n     NotUseful\n }\n \n+#[deriving(Copy)]\n enum WitnessPreference {\n     ConstructWitness,\n     LeaveOutWitness\n }\n \n-impl Copy for WitnessPreference {}\n-\n impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &ast::Expr) {\n         check_expr(self, ex);"}, {"sha": "21e94d69366d655b26ac0ea82bb709b6a39c7e3a", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -39,16 +39,14 @@ use syntax::visit::Visitor;\n use syntax::codemap::Span;\n use syntax::visit;\n \n-#[deriving(Eq, PartialEq)]\n+#[deriving(Copy, Eq, PartialEq)]\n enum Mode {\n     InConstant,\n     InStatic,\n     InStaticMut,\n     InNothing,\n }\n \n-impl Copy for Mode {}\n-\n struct CheckStaticVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     mode: Mode,"}, {"sha": "9b94335654734a8b0786a511846cdce2b8dcb8e7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -62,14 +62,13 @@ use std::collections::hash_map::Vacant;\n //   - Non-constants: everything else.\n //\n \n+#[deriving(Copy)]\n pub enum constness {\n     integral_const,\n     general_const,\n     non_const\n }\n \n-impl Copy for constness {}\n-\n type constness_cache = DefIdMap<constness>;\n \n pub fn join(a: constness, b: constness) -> constness {"}, {"sha": "17ebd1b94a70877b5160446a174abefffe3a727c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -27,14 +27,12 @@ use syntax::visit;\n use syntax::print::{pp, pprust};\n use util::nodemap::NodeMap;\n \n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n pub enum EntryOrExit {\n     Entry,\n     Exit,\n }\n \n-impl Copy for EntryOrExit {}\n-\n #[deriving(Clone)]\n pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     tcx: &'a ty::ctxt<'tcx>,"}, {"sha": "20a0dbdc1eefa98dc4b1e9cb25d8e10192baeda9", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -15,7 +15,7 @@ use middle::subst::ParamSpace;\n use syntax::ast;\n use syntax::ast_util::local_def;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Def {\n     DefFn(ast::DefId, bool /* is_ctor */),\n     DefStaticMethod(/* method */ ast::DefId, MethodProvenance),\n@@ -56,15 +56,13 @@ pub enum Def {\n     DefMethod(ast::DefId /* method */, Option<ast::DefId> /* trait */, MethodProvenance),\n }\n \n-impl Copy for Def {}\n-\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum MethodProvenance {\n     FromTrait(ast::DefId),\n     FromImpl(ast::DefId),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TyParamProvenance {\n     FromSelf(ast::DefId),\n     FromParam(ast::DefId),\n@@ -81,8 +79,6 @@ impl MethodProvenance {\n     }\n }\n \n-impl Copy for MethodProvenance {}\n-\n impl TyParamProvenance {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n@@ -92,8 +88,6 @@ impl TyParamProvenance {\n     }\n }\n \n-impl Copy for TyParamProvenance {}\n-\n impl Def {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {"}, {"sha": "0c0cba6e53e069e0ca43320fa2cda056b76739bc", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -23,15 +23,13 @@ use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n enum UnsafeContext {\n     SafeContext,\n     UnsafeFn,\n     UnsafeBlock(ast::NodeId),\n }\n \n-impl Copy for UnsafeContext {}\n-\n fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n         ty::ty_bare_fn(ref f) => f.unsafety == ast::Unsafety::Unsafe,"}, {"sha": "abc3c8d0d8fa4add49b24c1cc18c6db246e29926", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -95,7 +95,7 @@ pub trait Delegate<'tcx> {\n               mode: MutateMode);\n }\n \n-#[deriving(PartialEq, Show)]\n+#[deriving(Copy, PartialEq, Show)]\n pub enum LoanCause {\n     ClosureCapture(Span),\n     AddrOf,\n@@ -107,35 +107,27 @@ pub enum LoanCause {\n     MatchDiscriminant\n }\n \n-impl kinds::Copy for LoanCause {}\n-\n-#[deriving(PartialEq, Show)]\n+#[deriving(Copy, PartialEq, Show)]\n pub enum ConsumeMode {\n     Copy,                // reference to x where x has a type that copies\n     Move(MoveReason),    // reference to x where x has a type that moves\n }\n \n-impl kinds::Copy for ConsumeMode {}\n-\n-#[deriving(PartialEq,Show)]\n+#[deriving(Copy, PartialEq, Show)]\n pub enum MoveReason {\n     DirectRefMove,\n     PatBindingMove,\n     CaptureMove,\n }\n \n-impl kinds::Copy for MoveReason {}\n-\n-#[deriving(PartialEq,Show)]\n+#[deriving(Copy, PartialEq, Show)]\n pub enum MatchMode {\n     NonBindingMatch,\n     BorrowingMatch,\n     CopyingMatch,\n     MovingMatch,\n }\n \n-impl kinds::Copy for MatchMode {}\n-\n #[deriving(PartialEq,Show)]\n enum TrackMatchMode<T> {\n     Unknown,\n@@ -205,23 +197,20 @@ impl<T> TrackMatchMode<T> {\n     }\n }\n \n-#[deriving(PartialEq,Show)]\n+#[deriving(Copy, PartialEq, Show)]\n pub enum MutateMode {\n     Init,\n     JustWrite,    // x = y\n     WriteAndRead, // x += y\n }\n \n-impl kinds::Copy for MutateMode {}\n-\n+#[deriving(Copy)]\n enum OverloadedCallType {\n     FnOverloadedCall,\n     FnMutOverloadedCall,\n     FnOnceOverloadedCall,\n }\n \n-impl kinds::Copy for OverloadedCallType {}\n-\n impl OverloadedCallType {\n     fn from_trait_id(tcx: &ty::ctxt, trait_id: ast::DefId)\n                      -> OverloadedCallType {"}, {"sha": "297d6bcb03cb9d007d5f823ffb1052cc56f12be7", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n use self::SimplifiedType::*;\n \n /// See `simplify_type\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,\n@@ -33,8 +33,6 @@ pub enum SimplifiedType {\n     ParameterSimplifiedType,\n }\n \n-impl Copy for SimplifiedType {}\n-\n /// Tries to simplify a type by dropping type parameters, deref'ing away any reference types, etc.\n /// The idea is to get something simple that we can use to quickly decide if two types could unify\n /// during method lookup."}, {"sha": "e73fcd93e0504cb1892d724b02ec6562acc27d4b", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -60,30 +60,24 @@ impl<E: Show> Show for Edge<E> {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Show)]\n+#[deriving(Clone, Copy, PartialEq, Show)]\n pub struct NodeIndex(pub uint);\n #[allow(non_upper_case_globals)]\n pub const InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n-impl Copy for NodeIndex {}\n-\n-#[deriving(PartialEq, Show)]\n+#[deriving(Copy, PartialEq, Show)]\n pub struct EdgeIndex(pub uint);\n #[allow(non_upper_case_globals)]\n pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n \n-impl Copy for EdgeIndex {}\n-\n // Use a private field here to guarantee no more instances are created:\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n pub struct Direction { repr: uint }\n #[allow(non_upper_case_globals)]\n pub const Outgoing: Direction = Direction { repr: 0 };\n #[allow(non_upper_case_globals)]\n pub const Incoming: Direction = Direction { repr: 1 };\n \n-impl Copy for Direction {}\n-\n impl NodeIndex {\n     fn get(&self) -> uint { let NodeIndex(v) = *self; v }\n     /// Returns unique id (unique with respect to the graph holding associated node)."}, {"sha": "25eadae5b92f1203cc5b6c50cfaad2bcea631486", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -97,7 +97,7 @@ pub type SkolemizationMap = FnvHashMap<ty::BoundRegion,ty::Region>;\n /// Why did we require that the two types be related?\n ///\n /// See `error_reporting.rs` for more details\n-#[deriving(Clone, Show)]\n+#[deriving(Clone, Copy, Show)]\n pub enum TypeOrigin {\n     // Not yet categorized in a better way\n     Misc(Span),\n@@ -131,8 +131,6 @@ pub enum TypeOrigin {\n     EquatePredicate(Span),\n }\n \n-impl Copy for TypeOrigin {}\n-\n /// See `error_reporting.rs` for more details\n #[deriving(Clone, Show)]\n pub enum ValuePairs<'tcx> {\n@@ -223,7 +221,7 @@ pub enum SubregionOrigin<'tcx> {\n }\n \n /// Times when we replace late-bound regions with variables:\n-#[deriving(Clone, Show)]\n+#[deriving(Clone, Copy, Show)]\n pub enum LateBoundRegionConversionTime {\n     /// when a fn is called\n     FnCall,\n@@ -232,8 +230,6 @@ pub enum LateBoundRegionConversionTime {\n     HigherRankedType,\n }\n \n-impl Copy for LateBoundRegionConversionTime {}\n-\n /// Reasons to create a region inference variable\n ///\n /// See `error_reporting.rs` for more details\n@@ -270,15 +266,13 @@ pub enum RegionVariableOrigin<'tcx> {\n     BoundRegionInCoherence(ast::Name),\n }\n \n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n     unresolved_float_ty(FloatVid),\n     unresolved_ty(TyVid)\n }\n \n-impl Copy for fixup_err {}\n-\n pub fn fixup_err_to_string(f: fixup_err) -> String {\n     match f {\n       unresolved_int_ty(_) => {"}, {"sha": "bcaf39cc8dbd1fb8dc3e681b9afd4a41550fdeb2", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -40,7 +40,7 @@ mod doc;\n mod graphviz;\n \n // A constraint that influences the inference process.\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum Constraint {\n     // One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n@@ -52,8 +52,6 @@ pub enum Constraint {\n     ConstrainVarSubReg(RegionVid, Region),\n }\n \n-impl Copy for Constraint {}\n-\n // Something we have to verify after region inference is done, but\n // which does not directly influence the inference process\n pub enum Verify<'tcx> {\n@@ -69,15 +67,13 @@ pub enum Verify<'tcx> {\n     VerifyParamBound(ty::ParamTy, SubregionOrigin<'tcx>, Region, Vec<Region>),\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(Copy, PartialEq, Eq, Hash)]\n pub struct TwoRegions {\n     a: Region,\n     b: Region,\n }\n \n-impl Copy for TwoRegions {}\n-\n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n pub enum UndoLogEntry {\n     OpenSnapshot,\n     CommitedSnapshot,\n@@ -88,15 +84,11 @@ pub enum UndoLogEntry {\n     AddCombination(CombineMapType, TwoRegions)\n }\n \n-impl Copy for UndoLogEntry {}\n-\n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n pub enum CombineMapType {\n     Lub, Glb\n }\n \n-impl Copy for CombineMapType {}\n-\n #[deriving(Clone, Show)]\n pub enum RegionResolutionError<'tcx> {\n     /// `ConcreteFailure(o, a, b)`:\n@@ -940,15 +932,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n // ______________________________________________________________________\n \n-#[deriving(PartialEq, Show)]\n+#[deriving(Copy, PartialEq, Show)]\n enum Classification { Expanding, Contracting }\n \n-impl Copy for Classification {}\n-\n+#[deriving(Copy)]\n pub enum VarValue { NoValue, Value(Region), ErrorValue }\n \n-impl Copy for VarValue {}\n-\n struct VarData {\n     classification: Classification,\n     value: VarValue,"}, {"sha": "5e857154871ead14d95c9dbf6c5928e8facf460b", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -46,13 +46,11 @@ struct Delegate;\n \n type Relation = (RelationDir, ty::TyVid);\n \n-#[deriving(PartialEq,Show)]\n+#[deriving(Copy, PartialEq, Show)]\n pub enum RelationDir {\n     SubtypeOf, SupertypeOf, EqTo\n }\n \n-impl Copy for RelationDir {}\n-\n impl RelationDir {\n     fn opposite(self) -> RelationDir {\n         match self {"}, {"sha": "0b81823e9ed1a32a29e7c108ed9cbd800e294a7a", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -90,10 +90,9 @@ pub struct Node<K,V> {\n     pub rank: uint,\n }\n \n+#[deriving(Copy)]\n pub struct Delegate;\n \n-impl Copy for Delegate {}\n-\n // We can't use V:LatticeValue, much as I would like to,\n // because frequently the pattern is that V=Option<U> for some\n // other type parameter U, and we have no way to say"}, {"sha": "2ffc5d8a510a389c1525feb12e9d132d1fa17acb", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -45,13 +45,11 @@ macro_rules! lets_do_this {\n         $( $variant:ident, $name:expr, $method:ident; )*\n     ) => {\n \n-#[deriving(FromPrimitive, PartialEq, Eq, Hash)]\n+#[deriving(Copy, FromPrimitive, PartialEq, Eq, Hash)]\n pub enum LangItem {\n     $($variant),*\n }\n \n-impl Copy for LangItem {}\n-\n pub struct LanguageItems {\n     pub items: Vec<Option<ast::DefId>>,\n     pub missing: Vec<LangItem>,"}, {"sha": "b76d798941ef9dd0f44e56357e7acd9193769181", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -135,16 +135,12 @@ enum LoopKind<'a> {\n     ForLoop(&'a ast::Pat),\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n struct Variable(uint);\n \n-impl Copy for Variable {}\n-\n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n struct LiveNode(uint);\n \n-impl Copy for LiveNode {}\n-\n impl Variable {\n     fn get(&self) -> uint { let Variable(v) = *self; v }\n }\n@@ -159,16 +155,14 @@ impl Clone for LiveNode {\n     }\n }\n \n-#[deriving(PartialEq, Show)]\n+#[deriving(Copy, PartialEq, Show)]\n enum LiveNodeKind {\n     FreeVarNode(Span),\n     ExprNode(Span),\n     VarDefNode(Span),\n     ExitNode\n }\n \n-impl Copy for LiveNodeKind {}\n-\n fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n     let cm = cx.sess.codemap();\n     match lnk {\n@@ -247,24 +241,20 @@ struct CaptureInfo {\n     var_nid: NodeId\n }\n \n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n struct LocalInfo {\n     id: NodeId,\n     ident: ast::Ident\n }\n \n-impl Copy for LocalInfo {}\n-\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n enum VarKind {\n     Arg(NodeId, ast::Ident),\n     Local(LocalInfo),\n     ImplicitRet,\n     CleanExit\n }\n \n-impl Copy for VarKind {}\n-\n struct IrMaps<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n \n@@ -536,15 +526,13 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n // Actually we compute just a bit more than just liveness, but we use\n // the same basic propagation framework in all cases.\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Copy)]\n struct Users {\n     reader: LiveNode,\n     writer: LiveNode,\n     used: bool\n }\n \n-impl Copy for Users {}\n-\n fn invalid_users() -> Users {\n     Users {\n         reader: invalid_node(),\n@@ -553,15 +541,14 @@ fn invalid_users() -> Users {\n     }\n }\n \n+#[deriving(Copy)]\n struct Specials {\n     exit_ln: LiveNode,\n     fallthrough_ln: LiveNode,\n     no_ret_var: Variable,\n     clean_exit_var: Variable\n }\n \n-impl Copy for Specials {}\n-\n static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;"}, {"sha": "dce75579ca0a2111250a883618fce22eeb459214", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -101,7 +101,7 @@ pub enum categorization<'tcx> {\n }\n \n // Represents any kind of upvar\n-#[deriving(Clone, PartialEq, Show)]\n+#[deriving(Clone, Copy, PartialEq, Show)]\n pub struct Upvar {\n     pub id: ty::UpvarId,\n     // Unboxed closure kinds are used even for old-style closures for simplicity\n@@ -110,68 +110,54 @@ pub struct Upvar {\n     pub is_unboxed: bool\n }\n \n-impl Copy for Upvar {}\n-\n // different kinds of pointers:\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum PointerKind {\n     OwnedPtr,\n     BorrowedPtr(ty::BorrowKind, ty::Region),\n     Implicit(ty::BorrowKind, ty::Region),     // Implicit deref of a borrowed ptr.\n     UnsafePtr(ast::Mutability)\n }\n \n-impl Copy for PointerKind {}\n-\n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-impl Copy for InteriorKind {}\n-\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-impl Copy for FieldName {}\n-\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum ElementKind {\n     VecElement,\n     OtherElement,\n }\n \n-impl Copy for ElementKind {}\n-\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable.\n     McInherited, // Inherited from the fact that owner is mutable.\n }\n \n-impl Copy for MutabilityCategory {}\n-\n // A note about the provenance of a `cmt`.  This is used for\n // special-case handling of upvars such as mutability inference.\n // Upvar categorization can generate a variable number of nested\n // derefs.  The note allows detecting them without deep pattern\n // matching on the categorization.\n-#[deriving(Clone, PartialEq, Show)]\n+#[deriving(Clone, Copy, PartialEq, Show)]\n pub enum Note {\n     NoteClosureEnv(ty::UpvarId), // Deref through closure env\n     NoteUpvarRef(ty::UpvarId),   // Deref through by-ref upvar\n     NoteNone                     // Nothing special\n }\n \n-impl Copy for Note {}\n-\n // `cmt`: \"Category, Mutability, and Type\".\n //\n // a complete categorization of a value indicating where it originated\n@@ -200,13 +186,12 @@ pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n+#[deriving(Copy)]\n pub enum deref_kind {\n     deref_ptr(PointerKind),\n     deref_interior(InteriorKind),\n }\n \n-impl Copy for deref_kind {}\n-\n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n@@ -1394,13 +1379,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n }\n \n+#[deriving(Copy)]\n pub enum InteriorSafety {\n     InteriorUnsafe,\n     InteriorSafe\n }\n \n-impl Copy for InteriorSafety {}\n-\n+#[deriving(Copy)]\n pub enum AliasableReason {\n     AliasableBorrowed,\n     AliasableClosure(ast::NodeId), // Aliasable due to capture Fn closure env\n@@ -1409,8 +1394,6 @@ pub enum AliasableReason {\n     AliasableStaticMut(InteriorSafety),\n }\n \n-impl Copy for AliasableReason {}\n-\n impl<'tcx> cmt_<'tcx> {\n     pub fn guarantor(&self) -> cmt<'tcx> {\n         //! Returns `self` after stripping away any owned pointer derefs or"}, {"sha": "e0d5a3a50e6128021fd025338c6e625c1624eb9d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -36,13 +36,11 @@ use syntax::visit::{Visitor, FnKind};\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n pub enum CodeExtent {\n     Misc(ast::NodeId)\n }\n \n-impl Copy for CodeExtent {}\n-\n impl CodeExtent {\n     /// Creates a scope that represents the dynamic extent associated\n     /// with `node_id`.\n@@ -117,15 +115,14 @@ pub struct RegionMaps {\n     terminating_scopes: RefCell<FnvHashSet<CodeExtent>>,\n }\n \n+#[deriving(Copy)]\n pub struct Context {\n     var_parent: Option<ast::NodeId>,\n \n     // Innermost enclosing expression\n     parent: Option<ast::NodeId>,\n }\n \n-impl Copy for Context {}\n-\n struct RegionResolutionVisitor<'a> {\n     sess: &'a Session,\n "}, {"sha": "e1e376c537cbab100cd2653343f60c43802201bb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 19, "deletions": 51, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -89,13 +89,12 @@ use std::uint;\n // Definition mapping\n pub type DefMap = RefCell<NodeMap<Def>>;\n \n+#[deriving(Copy)]\n struct binding_info {\n     span: Span,\n     binding_mode: BindingMode,\n }\n \n-impl Copy for binding_info {}\n-\n // Map from the name in a pattern to its binding mode.\n type BindingMap = HashMap<Name,binding_info>;\n \n@@ -118,7 +117,7 @@ pub type ExternalExports = DefIdSet;\n // FIXME: dox\n pub type LastPrivateMap = NodeMap<LastPrivate>;\n \n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n pub enum LastPrivate {\n     LastMod(PrivateDep),\n     // `use` directives (imports) can refer to two separate definitions in the\n@@ -132,25 +131,19 @@ pub enum LastPrivate {\n                type_used: ImportUse},\n }\n \n-impl Copy for LastPrivate {}\n-\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n pub enum PrivateDep {\n     AllPublic,\n     DependsOn(DefId),\n }\n \n-impl Copy for PrivateDep {}\n-\n // How an import is used.\n-#[deriving(PartialEq, Show)]\n+#[deriving(Copy, PartialEq, Show)]\n pub enum ImportUse {\n     Unused,       // The import is not used.\n     Used,         // The import is used.\n }\n \n-impl Copy for ImportUse {}\n-\n impl LastPrivate {\n     fn or(self, other: LastPrivate) -> LastPrivate {\n         match (self, other) {\n@@ -160,33 +153,27 @@ impl LastPrivate {\n     }\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n enum PatternBindingMode {\n     RefutableMode,\n     LocalIrrefutableMode,\n     ArgumentIrrefutableMode,\n }\n \n-impl Copy for PatternBindingMode {}\n-\n-#[deriving(PartialEq, Eq, Hash, Show)]\n+#[deriving(Copy, PartialEq, Eq, Hash, Show)]\n enum Namespace {\n     TypeNS,\n     ValueNS\n }\n \n-impl Copy for Namespace {}\n-\n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n enum NamespaceError {\n     NoError,\n     ModuleError,\n     TypeError,\n     ValueError\n }\n \n-impl Copy for NamespaceError {}\n-\n /// A NamespaceResult represents the result of resolving an import in\n /// a particular namespace. The result is either definitely-resolved,\n /// definitely- unresolved, or unknown.\n@@ -247,13 +234,12 @@ impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n }\n \n /// Contains data for specific types of import directives.\n+#[deriving(Copy)]\n enum ImportDirectiveSubclass {\n     SingleImport(Name /* target */, Name /* source */),\n     GlobImport\n }\n \n-impl Copy for ImportDirectiveSubclass {}\n-\n /// The context that we thread through while building the reduced graph.\n #[deriving(Clone)]\n enum ReducedGraphParent {\n@@ -293,6 +279,7 @@ enum FallbackSuggestion {\n     TraitMethod(String),\n }\n \n+#[deriving(Copy)]\n enum TypeParameters<'a> {\n     NoTypeParameters,\n     HasTypeParameters(\n@@ -310,11 +297,9 @@ enum TypeParameters<'a> {\n         RibKind)\n }\n \n-impl<'a> Copy for TypeParameters<'a> {}\n-\n // The rib kind controls the translation of local\n // definitions (`DefLocal`) to upvars (`DefUpvar`).\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n@@ -337,38 +322,31 @@ enum RibKind {\n     ConstantItemRibKind\n }\n \n-impl Copy for RibKind {}\n-\n // Methods can be required or provided. RequiredMethod methods only occur in traits.\n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n enum MethodSort {\n     RequiredMethod,\n     ProvidedMethod(NodeId)\n }\n \n-impl Copy for MethodSort {}\n-\n+#[deriving(Copy)]\n enum UseLexicalScopeFlag {\n     DontUseLexicalScope,\n     UseLexicalScope\n }\n \n-impl Copy for UseLexicalScopeFlag {}\n-\n enum ModulePrefixResult {\n     NoPrefixFound,\n     PrefixFound(Rc<Module>, uint)\n }\n \n-#[deriving(Clone, Eq, PartialEq)]\n+#[deriving(Clone, Copy, Eq, PartialEq)]\n pub enum TraitItemKind {\n     NonstaticMethodTraitItemKind,\n     StaticMethodTraitItemKind,\n     TypeTraitItemKind,\n }\n \n-impl Copy for TraitItemKind {}\n-\n impl TraitItemKind {\n     pub fn from_explicit_self_category(explicit_self_category:\n                                        ExplicitSelfCategory)\n@@ -381,7 +359,7 @@ impl TraitItemKind {\n     }\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n enum NameSearchType {\n     /// We're doing a name search in order to resolve a `use` directive.\n     ImportSearch,\n@@ -391,19 +369,16 @@ enum NameSearchType {\n     PathSearch,\n }\n \n-impl Copy for NameSearchType {}\n-\n+#[deriving(Copy)]\n enum BareIdentifierPatternResolution {\n     FoundStructOrEnumVariant(Def, LastPrivate),\n     FoundConst(Def, LastPrivate),\n     BareIdentifierPatternUnresolved\n }\n \n-impl Copy for BareIdentifierPatternResolution {}\n-\n // Specifies how duplicates should be handled when adding a child item if\n // another item exists with the same name in some namespace.\n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n enum DuplicateCheckingMode {\n     ForbidDuplicateModules,\n     ForbidDuplicateTypesAndModules,\n@@ -412,8 +387,6 @@ enum DuplicateCheckingMode {\n     OverwriteDuplicates\n }\n \n-impl Copy for DuplicateCheckingMode {}\n-\n /// One local scope.\n #[deriving(Show)]\n struct Rib {\n@@ -543,7 +516,7 @@ enum ParentLink {\n }\n \n /// The type of module this is.\n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n enum ModuleKind {\n     NormalModuleKind,\n     TraitModuleKind,\n@@ -552,8 +525,6 @@ enum ModuleKind {\n     AnonymousModuleKind,\n }\n \n-impl Copy for ModuleKind {}\n-\n /// One node in the tree of modules.\n struct Module {\n     parent_link: ParentLink,\n@@ -645,15 +616,13 @@ struct TypeNsDef {\n }\n \n // Records a possibly-private value definition.\n-#[deriving(Clone, Show)]\n+#[deriving(Clone, Copy, Show)]\n struct ValueNsDef {\n     modifiers: DefModifiers, // see note in ImportResolution about how to use this\n     def: Def,\n     value_span: Option<Span>,\n }\n \n-impl Copy for ValueNsDef {}\n-\n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n struct NameBindings {\n@@ -662,6 +631,7 @@ struct NameBindings {\n }\n \n /// Ways in which a trait can be referenced\n+#[deriving(Copy)]\n enum TraitReferenceType {\n     TraitImplementation,             // impl SomeTrait for T { ... }\n     TraitDerivation,                 // trait T : SomeTrait { ... }\n@@ -670,8 +640,6 @@ enum TraitReferenceType {\n     TraitQPath,                      // <T as SomeTrait>::\n }\n \n-impl Copy for TraitReferenceType {}\n-\n impl NameBindings {\n     fn new() -> NameBindings {\n         NameBindings {"}, {"sha": "2202137d14936cd8fc02e7f0ffbb613ad7c96f5a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -34,7 +34,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use util::nodemap::NodeMap;\n \n-#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum DefRegion {\n     DefStaticRegion,\n     DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n@@ -46,8 +46,6 @@ pub enum DefRegion {\n                   /* lifetime decl */ ast::NodeId),\n }\n \n-impl Copy for DefRegion {}\n-\n // maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to\n pub type NamedRegionMap = NodeMap<DefRegion>;"}, {"sha": "30a47ff913258924cb2d2814291d13a81f4de2ed", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -187,7 +187,7 @@ impl RegionSubsts {\n ///////////////////////////////////////////////////////////////////////////\n // ParamSpace\n \n-#[deriving(PartialOrd, Ord, PartialEq, Eq,\n+#[deriving(Copy, PartialOrd, Ord, PartialEq, Eq,\n            Clone, Hash, Encodable, Decodable, Show)]\n pub enum ParamSpace {\n     TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n@@ -196,8 +196,6 @@ pub enum ParamSpace {\n     FnSpace,    // Type parameters attached to a method or fn\n }\n \n-impl Copy for ParamSpace {}\n-\n impl ParamSpace {\n     pub fn all() -> [ParamSpace, ..4] {\n         [TypeSpace, SelfSpace, AssocSpace, FnSpace]"}, {"sha": "8ba28b61006bdd775a7c72af76f5d0d849ff6a9a", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -91,7 +91,7 @@ pub enum MethodMatchResult {\n     MethodDidNotMatch,\n }\n \n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n pub enum MethodMatchedData {\n     // In the case of a precise match, we don't really need to store\n     // how the match was found. So don't.\n@@ -102,8 +102,6 @@ pub enum MethodMatchedData {\n     CoerciveMethodMatch(/* impl we matched */ ast::DefId)\n }\n \n-impl Copy for MethodMatchedData {}\n-\n /// The selection process begins by considering all impls, where\n /// clauses, and so forth that might resolve an obligation.  Sometimes\n /// we'll be able to say definitively that (e.g.) an impl does not"}, {"sha": "acf1fced72cae233f12e528eaf19b77cdce495cf", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 45, "deletions": 129, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -107,22 +107,18 @@ pub struct CrateAnalysis<'tcx> {\n     pub name: String,\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(Copy, PartialEq, Eq, Hash)]\n pub struct field<'tcx> {\n     pub name: ast::Name,\n     pub mt: mt<'tcx>\n }\n \n-impl<'tcx> Copy for field<'tcx> {}\n-\n-#[deriving(Clone, Show)]\n+#[deriving(Clone, Copy, Show)]\n pub enum ImplOrTraitItemContainer {\n     TraitContainer(ast::DefId),\n     ImplContainer(ast::DefId),\n }\n \n-impl Copy for ImplOrTraitItemContainer {}\n-\n impl ImplOrTraitItemContainer {\n     pub fn id(&self) -> ast::DefId {\n         match *self {\n@@ -177,14 +173,12 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     }\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Copy)]\n pub enum ImplOrTraitItemId {\n     MethodTraitItemId(ast::DefId),\n     TypeTraitItemId(ast::DefId),\n }\n \n-impl Copy for ImplOrTraitItemId {}\n-\n impl ImplOrTraitItemId {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n@@ -238,78 +232,65 @@ impl<'tcx> Method<'tcx> {\n     }\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Copy)]\n pub struct AssociatedType {\n     pub name: ast::Name,\n     pub vis: ast::Visibility,\n     pub def_id: ast::DefId,\n     pub container: ImplOrTraitItemContainer,\n }\n \n-impl Copy for AssociatedType {}\n-\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub struct mt<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: ast::Mutability,\n }\n \n-impl<'tcx> Copy for mt<'tcx> {}\n-\n-#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum TraitStore {\n     /// Box<Trait>\n     UniqTraitStore,\n     /// &Trait and &mut Trait\n     RegionTraitStore(Region, ast::Mutability),\n }\n \n-impl Copy for TraitStore {}\n-\n-#[deriving(Clone, Show)]\n+#[deriving(Clone, Copy, Show)]\n pub struct field_ty {\n     pub name: Name,\n     pub id: DefId,\n     pub vis: ast::Visibility,\n     pub origin: ast::DefId,  // The DefId of the struct in which the field is declared.\n }\n \n-impl Copy for field_ty {}\n-\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(Copy, PartialEq, Eq, Hash)]\n pub struct creader_cache_key {\n     pub cnum: CrateNum,\n     pub pos: uint,\n     pub len: uint\n }\n \n-impl Copy for creader_cache_key {}\n-\n+#[deriving(Copy)]\n pub enum ast_ty_to_ty_cache_entry<'tcx> {\n     atttce_unresolved,  /* not resolved yet */\n     atttce_resolved(Ty<'tcx>)  /* resolved to a type, irrespective of region */\n }\n \n-impl<'tcx> Copy for ast_ty_to_ty_cache_entry<'tcx> {}\n-\n #[deriving(Clone, PartialEq, Decodable, Encodable)]\n pub struct ItemVariances {\n     pub types: VecPerParamSpace<Variance>,\n     pub regions: VecPerParamSpace<Variance>,\n }\n \n-#[deriving(Clone, PartialEq, Decodable, Encodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, Decodable, Encodable, Show)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n     Contravariant,  // T<A> <: T<B> iff B <: A -- e.g., function param type\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-impl Copy for Variance {}\n-\n #[deriving(Clone, Show)]\n pub enum AutoAdjustment<'tcx> {\n     AdjustAddEnv(ty::TraitStore),\n@@ -449,14 +430,12 @@ pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Opti\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable, PartialEq, PartialOrd, Show)]\n+#[deriving(Clone, Copy, Encodable, Decodable, PartialEq, PartialOrd, Show)]\n pub struct param_index {\n     pub space: subst::ParamSpace,\n     pub index: uint\n }\n \n-impl Copy for param_index {}\n-\n #[deriving(Clone, Show)]\n pub enum MethodOrigin<'tcx> {\n     // fully statically resolved method\n@@ -513,8 +492,6 @@ pub struct MethodCallee<'tcx> {\n     pub substs: subst::Substs<'tcx>\n }\n \n-impl Copy for MethodCall {}\n-\n /// With method calls, we store some extra information in\n /// side tables (i.e method_map). We use\n /// MethodCall as a key to index into these tables instead of\n@@ -527,21 +504,19 @@ impl Copy for MethodCall {}\n /// needed to add to the side tables. Thus to disambiguate\n /// we also keep track of whether there's an adjustment in\n /// our key.\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub struct MethodCall {\n     pub expr_id: ast::NodeId,\n     pub adjustment: ExprAdjustment\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash, Show, Encodable, Decodable)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show, Encodable, Decodable)]\n pub enum ExprAdjustment {\n     NoAdjustment,\n     AutoDeref(uint),\n     AutoObject\n }\n \n-impl Copy for ExprAdjustment {}\n-\n impl MethodCall {\n     pub fn expr(id: ast::NodeId) -> MethodCall {\n         MethodCall {\n@@ -615,6 +590,7 @@ pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::PolyTraitRef<'tcx>>>>;\n \n /// A restriction that certain types must be the same size. The use of\n /// `transmute` gives rise to these restrictions.\n+#[deriving(Copy)]\n pub struct TransmuteRestriction<'tcx> {\n     /// The span from whence the restriction comes.\n     pub span: Span,\n@@ -626,8 +602,6 @@ pub struct TransmuteRestriction<'tcx> {\n     pub id: ast::NodeId,\n }\n \n-impl<'tcx> Copy for TransmuteRestriction<'tcx> {}\n-\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n@@ -923,7 +897,7 @@ pub struct ClosureTy<'tcx> {\n     pub abi: abi::Abi,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum FnOutput<'tcx> {\n     FnConverging(Ty<'tcx>),\n     FnDiverging\n@@ -938,8 +912,6 @@ impl<'tcx> FnOutput<'tcx> {\n     }\n }\n \n-impl<'tcx> Copy for FnOutput<'tcx> {}\n-\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n@@ -955,15 +927,13 @@ pub struct FnSig<'tcx> {\n \n pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n     pub idx: uint,\n     pub def_id: DefId\n }\n \n-impl Copy for ParamTy {}\n-\n /// A [De Bruijn index][dbi] is a standard means of representing\n /// regions (and perhaps later types) in a higher-ranked setting. In\n /// particular, imagine a type like this:\n@@ -1003,15 +973,15 @@ impl Copy for ParamTy {}\n /// is the outer fn.\n ///\n /// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n-#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub struct DebruijnIndex {\n     // We maintain the invariant that this is never 0. So 1 indicates\n     // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n     pub depth: uint,\n }\n \n /// Representation of regions:\n-#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -1052,15 +1022,13 @@ pub enum Region {\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub struct UpvarId {\n     pub var_id: ast::NodeId,\n     pub closure_expr_id: ast::NodeId,\n }\n \n-impl Copy for UpvarId {}\n-\n-#[deriving(Clone, PartialEq, Eq, Hash, Show, Encodable, Decodable)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash, Show, Encodable, Decodable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -1106,8 +1074,6 @@ pub enum BorrowKind {\n     MutBorrow\n }\n \n-impl Copy for BorrowKind {}\n-\n /// Information describing the borrowing of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`. The general idea is\n /// that the compiler analyses treat closures like:\n@@ -1155,16 +1121,14 @@ impl Copy for BorrowKind {}\n /// - Through mutation, the borrowed upvars can actually escape\n ///   the closure, so sometimes it is necessary for them to be larger\n ///   than the closure lifetime itself.\n-#[deriving(PartialEq, Clone, Encodable, Decodable, Show)]\n+#[deriving(Copy, PartialEq, Clone, Encodable, Decodable, Show)]\n pub struct UpvarBorrow {\n     pub kind: BorrowKind,\n     pub region: ty::Region,\n }\n \n pub type UpvarBorrowMap = FnvHashMap<UpvarId, UpvarBorrow>;\n \n-impl Copy for UpvarBorrow {}\n-\n impl Region {\n     pub fn is_bound(&self) -> bool {\n         match *self {\n@@ -1182,19 +1146,15 @@ impl Region {\n     }\n }\n \n-impl Copy for Region {}\n-\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n     pub scope: region::CodeExtent,\n     pub bound_region: BoundRegion\n }\n \n-impl Copy for FreeRegion {}\n-\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(uint),\n@@ -1213,8 +1173,6 @@ pub enum BoundRegion {\n     BrEnv\n }\n \n-impl Copy for BoundRegion {}\n-\n #[inline]\n pub fn mk_prim_t<'tcx>(primitive: &'tcx TyS<'static>) -> Ty<'tcx> {\n     // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n@@ -1378,34 +1336,28 @@ impl<'tcx> PolyTraitRef<'tcx> {\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct Binder<T>(pub T);\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, Copy, PartialEq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),\n     UintType(ast::UintTy),\n }\n \n-impl Copy for IntVarValue {}\n-\n-#[deriving(Clone, Show)]\n+#[deriving(Clone, Copy, Show)]\n pub enum terr_vstore_kind {\n     terr_vec,\n     terr_str,\n     terr_fn,\n     terr_trait\n }\n \n-impl Copy for terr_vstore_kind {}\n-\n-#[deriving(Clone, Show)]\n+#[deriving(Clone, Copy, Show)]\n pub struct expected_found<T> {\n     pub expected: T,\n     pub found: T\n }\n \n-impl<T:Copy> Copy for expected_found<T> {}\n-\n // Data structures used in type unification\n-#[deriving(Clone, Show)]\n+#[deriving(Clone, Copy, Show)]\n pub enum type_err<'tcx> {\n     terr_mismatch,\n     terr_unsafety_mismatch(expected_found<ast::Unsafety>),\n@@ -1438,8 +1390,6 @@ pub enum type_err<'tcx> {\n     terr_convergence_mismatch(expected_found<bool>)\n }\n \n-impl<'tcx> Copy for type_err<'tcx> {}\n-\n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n /// as well as the existential type parameter in an object type.\n #[deriving(PartialEq, Eq, Hash, Clone, Show)]\n@@ -1454,17 +1404,15 @@ pub struct ParamBounds<'tcx> {\n /// major difference between this case and `ParamBounds` is that\n /// general purpose trait bounds are omitted and there must be\n /// *exactly one* region.\n-#[deriving(PartialEq, Eq, Hash, Clone, Show)]\n+#[deriving(Copy, PartialEq, Eq, Hash, Clone, Show)]\n pub struct ExistentialBounds {\n     pub region_bound: ty::Region,\n     pub builtin_bounds: BuiltinBounds\n }\n \n-impl Copy for ExistentialBounds {}\n-\n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Clone, Encodable, PartialEq, Eq, Decodable, Hash, Show)]\n+#[deriving(Copy, Clone, Encodable, PartialEq, Eq, Decodable, Hash, Show)]\n #[repr(uint)]\n pub enum BuiltinBound {\n     BoundSend,\n@@ -1473,8 +1421,6 @@ pub enum BuiltinBound {\n     BoundSync,\n }\n \n-impl Copy for BuiltinBound {}\n-\n pub fn empty_builtin_bounds() -> BuiltinBounds {\n     EnumSet::new()\n }\n@@ -1502,35 +1448,27 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TyVid {\n     pub index: uint\n }\n \n-impl Copy for TyVid {}\n-\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct IntVid {\n     pub index: uint\n }\n \n-impl Copy for IntVid {}\n-\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct FloatVid {\n     pub index: uint\n }\n \n-impl Copy for FloatVid {}\n-\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct RegionVid {\n     pub index: uint\n }\n \n-impl Copy for RegionVid {}\n-\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n@@ -1547,16 +1485,12 @@ pub enum InferTy {\n     FreshIntTy(uint),\n }\n \n-impl Copy for InferTy {}\n-\n-#[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n+#[deriving(Clone, Copy, Encodable, Decodable, Eq, Hash, Show)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, BoundRegion)\n }\n \n-impl Copy for InferRegion {}\n-\n impl cmp::PartialEq for InferRegion {\n     fn eq(&self, other: &InferRegion) -> bool {\n         match ((*self), *other) {\n@@ -2006,15 +1940,13 @@ pub struct UnboxedClosure<'tcx> {\n     pub kind: UnboxedClosureKind,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Show)]\n+#[deriving(Clone, Copy, PartialEq, Eq, Show)]\n pub enum UnboxedClosureKind {\n     FnUnboxedClosureKind,\n     FnMutUnboxedClosureKind,\n     FnOnceUnboxedClosureKind,\n }\n \n-impl Copy for UnboxedClosureKind {}\n-\n impl UnboxedClosureKind {\n     pub fn trait_did(&self, cx: &ctxt) -> ast::DefId {\n         let result = match *self {\n@@ -2795,13 +2727,11 @@ pub fn type_needs_unwind_cleanup<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n /// The reason we compute type contents and not kinds is that it is\n /// easier for me (nmatsakis) to think about what is contained within\n /// a type than to think about what is *not* contained within a type.\n-#[deriving(Clone)]\n+#[deriving(Clone, Copy)]\n pub struct TypeContents {\n     pub bits: u64\n }\n \n-impl Copy for TypeContents {}\n-\n macro_rules! def_type_content_sets {\n     (mod $mname:ident { $($name:ident = $bits:expr),+ }) => {\n         #[allow(non_snake_case)]\n@@ -3443,15 +3373,13 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n ///\n /// The ordering of the cases is significant. They are sorted so that cmp::max\n /// will keep the \"more erroneous\" of two values.\n-#[deriving(PartialOrd, Ord, Eq, PartialEq, Show)]\n+#[deriving(Copy, PartialOrd, Ord, Eq, PartialEq, Show)]\n pub enum Representability {\n     Representable,\n     ContainsRecursive,\n     SelfRecursive,\n }\n \n-impl Copy for Representability {}\n-\n /// Check whether a type is representable. This means it cannot contain unboxed\n /// structural recursion. This check is needed for structs and enums.\n pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n@@ -4228,15 +4156,14 @@ pub fn expr_is_lval(tcx: &ctxt, e: &ast::Expr) -> bool {\n /// two kinds of rvalues is an artifact of trans which reflects how we will\n /// generate code for that kind of expression.  See trans/expr.rs for more\n /// information.\n+#[deriving(Copy)]\n pub enum ExprKind {\n     LvalueExpr,\n     RvalueDpsExpr,\n     RvalueDatumExpr,\n     RvalueStmtExpr\n }\n \n-impl Copy for ExprKind {}\n-\n pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n     if tcx.method_map.borrow().contains_key(&MethodCall::expr(expr.id)) {\n         // Overloaded operations are generally calls, and hence they are\n@@ -4791,15 +4718,13 @@ pub fn associated_type_parameter_index(cx: &ctxt,\n     cx.sess.bug(\"couldn't find associated type parameter index\")\n }\n \n-#[deriving(PartialEq, Eq)]\n+#[deriving(Copy, PartialEq, Eq)]\n pub struct AssociatedTypeInfo {\n     pub def_id: ast::DefId,\n     pub index: uint,\n     pub name: ast::Name,\n }\n \n-impl Copy for AssociatedTypeInfo {}\n-\n impl PartialOrd for AssociatedTypeInfo {\n     fn partial_cmp(&self, other: &AssociatedTypeInfo) -> Option<Ordering> {\n         Some(self.index.cmp(&other.index))\n@@ -4979,13 +4904,12 @@ pub fn item_path_str(cx: &ctxt, id: ast::DefId) -> String {\n     with_path(cx, id, |path| ast_map::path_to_string(path)).to_string()\n }\n \n+#[deriving(Copy)]\n pub enum DtorKind {\n     NoDtor,\n     TraitDtor(DefId, bool)\n }\n \n-impl Copy for DtorKind {}\n-\n impl DtorKind {\n     pub fn is_present(&self) -> bool {\n         match *self {\n@@ -5403,14 +5327,13 @@ pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     }).collect()\n }\n \n+#[deriving(Copy)]\n pub struct UnboxedClosureUpvar<'tcx> {\n     pub def: def::Def,\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n }\n \n-impl<'tcx> Copy for UnboxedClosureUpvar<'tcx> {}\n-\n // Returns a list of `UnboxedClosureUpvar`s for each upvar.\n pub fn unboxed_closure_upvars<'tcx>(tcx: &ctxt<'tcx>, closure_id: ast::DefId, substs: &Substs<'tcx>)\n                                     -> Vec<UnboxedClosureUpvar<'tcx>> {\n@@ -6259,16 +6182,14 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n }\n \n /// The category of explicit self.\n-#[deriving(Clone, Eq, PartialEq, Show)]\n+#[deriving(Clone, Copy, Eq, PartialEq, Show)]\n pub enum ExplicitSelfCategory {\n     StaticExplicitSelfCategory,\n     ByValueExplicitSelfCategory,\n     ByReferenceExplicitSelfCategory(Region, ast::Mutability),\n     ByBoxExplicitSelfCategory,\n }\n \n-impl Copy for ExplicitSelfCategory {}\n-\n /// Pushes all the lifetimes in the given type onto the given list. A\n /// \"lifetime in a type\" is a lifetime specified by a reference or a lifetime\n /// in a list of type substitutions. This does *not* traverse into nominal\n@@ -6329,7 +6250,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n }\n \n /// A free variable referred to in a function.\n-#[deriving(Encodable, Decodable)]\n+#[deriving(Copy, Encodable, Decodable)]\n pub struct Freevar {\n     /// The variable being accessed free.\n     pub def: def::Def,\n@@ -6338,8 +6259,6 @@ pub struct Freevar {\n     pub span: Span\n }\n \n-impl Copy for Freevar {}\n-\n pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n@@ -6469,8 +6388,6 @@ impl DebruijnIndex {\n     }\n }\n \n-impl Copy for DebruijnIndex {}\n-\n impl<'tcx> Repr<'tcx> for AutoAdjustment<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n@@ -6589,14 +6506,13 @@ pub fn make_substs_for_receiver_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n     trait_ref.substs.clone().with_method(meth_tps, meth_regions)\n }\n \n+#[deriving(Copy)]\n pub enum CopyImplementationError {\n     FieldDoesNotImplementCopy(ast::Name),\n     VariantDoesNotImplementCopy(ast::Name),\n     TypeIsStructural,\n }\n \n-impl Copy for CopyImplementationError {}\n-\n pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n                                      self_type: Ty<'tcx>,\n                                      param_env: &ParameterEnvironment<'tcx>)"}, {"sha": "0c014d615caf5da0b695c03ef9c2af38de065a52", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -47,26 +47,22 @@ pub struct Config {\n     pub uint_type: UintTy,\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, Copy, PartialEq)]\n pub enum OptLevel {\n     No, // -O0\n     Less, // -O1\n     Default, // -O2\n     Aggressive // -O3\n }\n \n-impl Copy for OptLevel {}\n-\n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, Copy, PartialEq)]\n pub enum DebugInfoLevel {\n     NoDebugInfo,\n     LimitedDebugInfo,\n     FullDebugInfo,\n }\n \n-impl Copy for DebugInfoLevel {}\n-\n-#[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n+#[deriving(Clone, Copy, PartialEq, PartialOrd, Ord, Eq)]\n pub enum OutputType {\n     OutputTypeBitcode,\n     OutputTypeAssembly,\n@@ -75,8 +71,6 @@ pub enum OutputType {\n     OutputTypeExe,\n }\n \n-impl Copy for OutputType {}\n-\n #[deriving(Clone)]\n pub struct Options {\n     // The crate config requested for the session, which may be combined\n@@ -220,25 +214,21 @@ pub fn basic_options() -> Options {\n // users can have their own entry\n // functions that don't start a\n // scheduler\n-#[deriving(PartialEq)]\n+#[deriving(Copy, PartialEq)]\n pub enum EntryFnType {\n     EntryMain,\n     EntryStart,\n     EntryNone,\n }\n \n-impl Copy for EntryFnType {}\n-\n-#[deriving(PartialEq, PartialOrd, Clone, Ord, Eq, Hash)]\n+#[deriving(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash)]\n pub enum CrateType {\n     CrateTypeExecutable,\n     CrateTypeDylib,\n     CrateTypeRlib,\n     CrateTypeStaticlib,\n }\n \n-impl Copy for CrateType {}\n-\n macro_rules! debugging_opts {\n     ([ $opt:ident ] $cnt:expr ) => (\n         pub const $opt: u64 = 1 << $cnt;"}, {"sha": "bc6fb1be0758f59ad85dfa1f73a7ea3cd65e5a3e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -22,11 +22,9 @@ use syntax::visit::Visitor;\n \n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n-#[deriving(Clone,Show)]\n+#[deriving(Clone, Copy, Show)]\n pub struct ErrorReported;\n \n-impl Copy for ErrorReported {}\n-\n pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n     F: FnOnce(U) -> T,\n {"}, {"sha": "2b05961bb6a05c0951ecffd48180465914335b11", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a0072d66f0071f47325711a226f34d7b76f05/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=e64a0072d66f0071f47325711a226f34d7b76f05", "patch": "@@ -68,11 +68,9 @@ pub mod DefIdSet {\n ///\n /// This uses FNV hashing, as described here:\n /// http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n-#[deriving(Clone, Default)]\n+#[deriving(Clone, Copy, Default)]\n pub struct FnvHasher;\n \n-impl Copy for FnvHasher {}\n-\n #[allow(missing_copy_implementations)]\n pub struct FnvState(u64);\n "}]}