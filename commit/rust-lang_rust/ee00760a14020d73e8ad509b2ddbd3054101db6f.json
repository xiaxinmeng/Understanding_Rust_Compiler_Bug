{"sha": "ee00760a14020d73e8ad509b2ddbd3054101db6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMDA3NjBhMTQwMjBkNzNlOGFkNTA5YjJkZGJkMzA1NDEwMWRiNmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T19:07:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-09T19:07:38Z"}, "message": "Auto merge of #34149 - arielb1:remove-remove-dead-blocks, r=nikomatsakis\n\nMIR cleanups and predecessor cache\n\nThis PR cleans up a few things in MIR and adds a predecessor cache to allow graph algorithms to be run easily.\n\nr? @nikomatsakis", "tree": {"sha": "aeccc6913146ee50e011ecef02d235750bfaa03f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeccc6913146ee50e011ecef02d235750bfaa03f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee00760a14020d73e8ad509b2ddbd3054101db6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee00760a14020d73e8ad509b2ddbd3054101db6f", "html_url": "https://github.com/rust-lang/rust/commit/ee00760a14020d73e8ad509b2ddbd3054101db6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee00760a14020d73e8ad509b2ddbd3054101db6f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0740a93cc290a5419807d2e8c6c442354baf46b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0740a93cc290a5419807d2e8c6c442354baf46b0", "html_url": "https://github.com/rust-lang/rust/commit/0740a93cc290a5419807d2e8c6c442354baf46b0"}, {"sha": "ce4fdefbd824271c342ab253b5e475ab9dc91be9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4fdefbd824271c342ab253b5e475ab9dc91be9", "html_url": "https://github.com/rust-lang/rust/commit/ce4fdefbd824271c342ab253b5e475ab9dc91be9"}], "stats": {"total": 2204, "additions": 1262, "deletions": 942}, "files": [{"sha": "fc2d68d7262e68e07bd437be85df4b9e2407573e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -28,6 +28,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(const_fn)]\n+#![feature(core_intrinsics)]\n #![feature(enumset)]\n #![feature(iter_arith)]\n #![feature(libc)]\n@@ -102,6 +103,7 @@ pub mod middle {\n }\n \n pub mod mir {\n+    mod cache;\n     pub mod repr;\n     pub mod tcx;\n     pub mod visit;"}, {"sha": "138fed2d64e23cb7375060b62dc9d043f6821869", "filename": "src/librustc/mir/cache.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::{Ref, RefCell};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+\n+use mir::repr::{Mir, BasicBlock};\n+\n+use rustc_serialize as serialize;\n+\n+#[derive(Clone)]\n+pub struct Cache {\n+    predecessors: RefCell<Option<IndexVec<BasicBlock, Vec<BasicBlock>>>>\n+}\n+\n+\n+impl serialize::Encodable for Cache {\n+    fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        serialize::Encodable::encode(&(), s)\n+    }\n+}\n+\n+impl serialize::Decodable for Cache {\n+    fn decode<D: serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        serialize::Decodable::decode(d).map(|_v: ()| Self::new())\n+    }\n+}\n+\n+\n+impl Cache {\n+    pub fn new() -> Self {\n+        Cache {\n+            predecessors: RefCell::new(None)\n+        }\n+    }\n+\n+    pub fn invalidate(&self) {\n+        // FIXME: consider being more fine-grained\n+        *self.predecessors.borrow_mut() = None;\n+    }\n+\n+    pub fn predecessors(&self, mir: &Mir) -> Ref<IndexVec<BasicBlock, Vec<BasicBlock>>> {\n+        if self.predecessors.borrow().is_none() {\n+            *self.predecessors.borrow_mut() = Some(calculate_predecessors(mir));\n+        }\n+\n+        Ref::map(self.predecessors.borrow(), |p| p.as_ref().unwrap())\n+    }\n+}\n+\n+fn calculate_predecessors(mir: &Mir) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n+    let mut result = IndexVec::from_elem(vec![], mir.basic_blocks());\n+    for (bb, data) in mir.basic_blocks().iter_enumerated() {\n+        if let Some(ref term) = data.terminator {\n+            for &tgt in term.successors().iter() {\n+                result[tgt].push(bb);\n+            }\n+        }\n+    }\n+\n+    result\n+}"}, {"sha": "03ae91fefb92586f093cad0052bf461ed6f6d32c", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 103, "deletions": 99, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -11,6 +11,7 @@\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n@@ -19,68 +20,129 @@ use rustc_back::slice;\n use hir::InlineAsm;\n use std::ascii;\n use std::borrow::{Cow};\n+use std::cell::Ref;\n use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n use syntax::ast::{self, Name};\n use syntax::codemap::Span;\n \n+use super::cache::Cache;\n+\n+macro_rules! newtype_index {\n+    ($name:ident, $debug_name:expr) => (\n+        #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n+         RustcEncodable, RustcDecodable)]\n+        pub struct $name(u32);\n+\n+        impl Idx for $name {\n+            fn new(value: usize) -> Self {\n+                assert!(value < (u32::MAX) as usize);\n+                $name(value as u32)\n+            }\n+            fn index(self) -> usize {\n+                self.0 as usize\n+            }\n+        }\n+\n+        impl Debug for $name {\n+            fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n+                write!(fmt, \"{}{}\", $debug_name, self.0)\n+            }\n+        }\n+    )\n+}\n+\n /// Lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n-    pub basic_blocks: Vec<BasicBlockData<'tcx>>,\n+    basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n \n     /// List of visibility (lexical) scopes; these are referenced by statements\n     /// and used (eventually) for debuginfo. Indexed by a `VisibilityScope`.\n-    pub visibility_scopes: Vec<VisibilityScopeData>,\n+    pub visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n \n     /// Rvalues promoted from this function, such as borrows of constants.\n     /// Each of them is the Mir of a constant with the fn's type parameters\n     /// in scope, but no vars or args and a separate set of temps.\n-    pub promoted: Vec<Mir<'tcx>>,\n+    pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n \n     /// Return type of the function.\n     pub return_ty: FnOutput<'tcx>,\n \n     /// Variables: these are stack slots corresponding to user variables. They may be\n     /// assigned many times.\n-    pub var_decls: Vec<VarDecl<'tcx>>,\n+    pub var_decls: IndexVec<Var, VarDecl<'tcx>>,\n \n     /// Args: these are stack slots corresponding to the input arguments.\n-    pub arg_decls: Vec<ArgDecl<'tcx>>,\n+    pub arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n \n     /// Temp declarations: stack slots that for temporaries created by\n     /// the compiler. These are assigned once, but they are not SSA\n     /// values in that it is possible to borrow them and mutate them\n     /// through the resulting reference.\n-    pub temp_decls: Vec<TempDecl<'tcx>>,\n+    pub temp_decls: IndexVec<Temp, TempDecl<'tcx>>,\n \n     /// Names and capture modes of all the closure upvars, assuming\n     /// the first argument is either the closure or a reference to it.\n     pub upvar_decls: Vec<UpvarDecl>,\n \n     /// A span representing this MIR, for error reporting\n     pub span: Span,\n+\n+    /// A cache for various calculations\n+    cache: Cache\n }\n \n /// where execution begins\n pub const START_BLOCK: BasicBlock = BasicBlock(0);\n \n impl<'tcx> Mir<'tcx> {\n-    pub fn all_basic_blocks(&self) -> Vec<BasicBlock> {\n-        (0..self.basic_blocks.len())\n-            .map(|i| BasicBlock::new(i))\n-            .collect()\n+    pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+               visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n+               promoted: IndexVec<Promoted, Mir<'tcx>>,\n+               return_ty: FnOutput<'tcx>,\n+               var_decls: IndexVec<Var, VarDecl<'tcx>>,\n+               arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n+               temp_decls: IndexVec<Temp, TempDecl<'tcx>>,\n+               upvar_decls: Vec<UpvarDecl>,\n+               span: Span) -> Self\n+    {\n+        Mir {\n+            basic_blocks: basic_blocks,\n+            visibility_scopes: visibility_scopes,\n+            promoted: promoted,\n+            return_ty: return_ty,\n+            var_decls: var_decls,\n+            arg_decls: arg_decls,\n+            temp_decls: temp_decls,\n+            upvar_decls: upvar_decls,\n+            span: span,\n+            cache: Cache::new()\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.basic_blocks\n     }\n \n-    pub fn basic_block_data(&self, bb: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.basic_blocks[bb.index()]\n+    #[inline]\n+    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        self.cache.invalidate();\n+        &mut self.basic_blocks\n     }\n \n-    pub fn basic_block_data_mut(&mut self, bb: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks[bb.index()]\n+    #[inline]\n+    pub fn predecessors(&self) -> Ref<IndexVec<BasicBlock, Vec<BasicBlock>>> {\n+        self.cache.predecessors(self)\n+    }\n+\n+    #[inline]\n+    pub fn predecessors_for(&self, bb: BasicBlock) -> Ref<Vec<BasicBlock>> {\n+        Ref::map(self.predecessors(), |p| &p[bb])\n     }\n }\n \n@@ -89,14 +151,14 @@ impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n \n     #[inline]\n     fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n-        self.basic_block_data(index)\n+        &self.basic_blocks()[index]\n     }\n }\n \n impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n     #[inline]\n     fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        self.basic_block_data_mut(index)\n+        &mut self.basic_blocks_mut()[index]\n     }\n }\n \n@@ -231,31 +293,7 @@ pub struct UpvarDecl {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlock\n \n-/// The index of a particular basic block. The index is into the `basic_blocks`\n-/// list of the `Mir`.\n-///\n-/// (We use a `u32` internally just to save memory.)\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n-         RustcEncodable, RustcDecodable)]\n-pub struct BasicBlock(u32);\n-\n-impl BasicBlock {\n-    pub fn new(index: usize) -> BasicBlock {\n-        assert!(index < (u32::MAX as usize));\n-        BasicBlock(index as u32)\n-    }\n-\n-    /// Extract the index.\n-    pub fn index(self) -> usize {\n-        self.0 as usize\n-    }\n-}\n-\n-impl Debug for BasicBlock {\n-    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        write!(fmt, \"bb{}\", self.0)\n-    }\n-}\n+newtype_index!(BasicBlock, \"bb\");\n \n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n@@ -336,6 +374,9 @@ pub enum TerminatorKind<'tcx> {\n     /// have been filled in by now. This should occur at most once.\n     Return,\n \n+    /// Indicates a terminator that can never be reached.\n+    Unreachable,\n+\n     /// Drop the Lvalue\n     Drop {\n         location: Lvalue<'tcx>,\n@@ -394,6 +435,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             SwitchInt { targets: ref b, .. } => b[..].into_cow(),\n             Resume => (&[]).into_cow(),\n             Return => (&[]).into_cow(),\n+            Unreachable => (&[]).into_cow(),\n             Call { destination: Some((_, t)), cleanup: Some(c), .. } => vec![t, c].into_cow(),\n             Call { destination: Some((_, ref t)), cleanup: None, .. } =>\n                 slice::ref_slice(t).into_cow(),\n@@ -423,6 +465,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             SwitchInt { targets: ref mut b, .. } => b.iter_mut().collect(),\n             Resume => Vec::new(),\n             Return => Vec::new(),\n+            Unreachable => Vec::new(),\n             Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut c), .. } => vec![t, c],\n             Call { destination: Some((_, ref mut t)), cleanup: None, .. } => vec![t],\n             Call { destination: None, cleanup: Some(ref mut c), .. } => vec![c],\n@@ -501,6 +544,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Return => write!(fmt, \"return\"),\n             Resume => write!(fmt, \"resume\"),\n+            Unreachable => write!(fmt, \"unreachable\"),\n             Drop { ref location, .. } => write!(fmt, \"drop({:?})\", location),\n             DropAndReplace { ref location, ref value, .. } =>\n                 write!(fmt, \"replace({:?} <- {:?})\", location, value),\n@@ -544,7 +588,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n         use self::TerminatorKind::*;\n         match *self {\n-            Return | Resume => vec![],\n+            Return | Resume | Unreachable => vec![],\n             Goto { .. } => vec![\"\".into()],\n             If { .. } => vec![\"true\".into(), \"false\".into()],\n             Switch { ref adt_def, .. } => {\n@@ -616,19 +660,23 @@ impl<'tcx> Debug for Statement<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Lvalues\n \n+newtype_index!(Var, \"var\");\n+newtype_index!(Temp, \"tmp\");\n+newtype_index!(Arg, \"arg\");\n+\n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Lvalue<'tcx> {\n     /// local variable declared by the user\n-    Var(u32),\n+    Var(Var),\n \n     /// temporary introduced during lowering into MIR\n-    Temp(u32),\n+    Temp(Temp),\n \n     /// formal parameter of the function; note that these are NOT the\n     /// bindings that the user declares, which are vars\n-    Arg(u32),\n+    Arg(Arg),\n \n     /// static or static mut variable\n     Static(DefId),\n@@ -696,20 +744,7 @@ pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Operand<'tcx>>;\n /// and the index is an operand.\n pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Operand<'tcx>>;\n \n-/// Index into the list of fields found in a `VariantDef`\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct Field(u32);\n-\n-impl Field {\n-    pub fn new(value: usize) -> Field {\n-        assert!(value < (u32::MAX) as usize);\n-        Field(value as u32)\n-    }\n-\n-    pub fn index(self) -> usize {\n-        self.0 as usize\n-    }\n-}\n+newtype_index!(Field, \"field\");\n \n impl<'tcx> Lvalue<'tcx> {\n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n@@ -737,12 +772,9 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n         use self::Lvalue::*;\n \n         match *self {\n-            Var(id) =>\n-                write!(fmt, \"var{:?}\", id),\n-            Arg(id) =>\n-                write!(fmt, \"arg{:?}\", id),\n-            Temp(id) =>\n-                write!(fmt, \"tmp{:?}\", id),\n+            Var(id) => write!(fmt, \"{:?}\", id),\n+            Arg(id) => write!(fmt, \"{:?}\", id),\n+            Temp(id) => write!(fmt, \"{:?}\", id),\n             Static(def_id) =>\n                 write!(fmt, \"{}\", ty::tls::with(|tcx| tcx.item_path_str(def_id))),\n             ReturnPointer =>\n@@ -777,38 +809,8 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n-impl Index<VisibilityScope> for Vec<VisibilityScopeData> {\n-    type Output = VisibilityScopeData;\n-\n-    #[inline]\n-    fn index(&self, index: VisibilityScope) -> &VisibilityScopeData {\n-        &self[index.index()]\n-    }\n-}\n-\n-impl IndexMut<VisibilityScope> for Vec<VisibilityScopeData> {\n-    #[inline]\n-    fn index_mut(&mut self, index: VisibilityScope) -> &mut VisibilityScopeData {\n-        &mut self[index.index()]\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub struct VisibilityScope(u32);\n-\n-/// The visibility scope all arguments go into.\n-pub const ARGUMENT_VISIBILITY_SCOPE: VisibilityScope = VisibilityScope(0);\n-\n-impl VisibilityScope {\n-    pub fn new(index: usize) -> VisibilityScope {\n-        assert!(index < (u32::MAX as usize));\n-        VisibilityScope(index as u32)\n-    }\n-\n-    pub fn index(self) -> usize {\n-        self.0 as usize\n-    }\n-}\n+newtype_index!(VisibilityScope, \"scope\");\n+pub const ARGUMENT_VISIBILITY_SCOPE : VisibilityScope = VisibilityScope(0);\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VisibilityScopeData {\n@@ -1080,6 +1082,8 @@ impl<'tcx> Debug for TypedConstVal<'tcx> {\n     }\n }\n \n+newtype_index!(Promoted, \"promoted\");\n+\n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n@@ -1091,7 +1095,7 @@ pub enum Literal<'tcx> {\n     },\n     Promoted {\n         // Index into the `promoted` vector of `Mir`.\n-        index: usize\n+        index: Promoted\n     },\n }\n \n@@ -1115,7 +1119,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n                 fmt_const_val(fmt, value)\n             }\n             Promoted { index } => {\n-                write!(fmt, \"promoted{}\", index)\n+                write!(fmt, \"{:?}\", index)\n             }\n         }\n     }"}, {"sha": "e3905c39daa9c593d1d750ea54858bb40542e5bc", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -154,11 +154,11 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n     {\n         match *lvalue {\n             Lvalue::Var(index) =>\n-                LvalueTy::Ty { ty: self.var_decls[index as usize].ty },\n+                LvalueTy::Ty { ty: self.var_decls[index].ty },\n             Lvalue::Temp(index) =>\n-                LvalueTy::Ty { ty: self.temp_decls[index as usize].ty },\n+                LvalueTy::Ty { ty: self.temp_decls[index].ty },\n             Lvalue::Arg(index) =>\n-                LvalueTy::Ty { ty: self.arg_decls[index as usize].ty },\n+                LvalueTy::Ty { ty: self.arg_decls[index].ty },\n             Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n             Lvalue::ReturnPointer =>"}, {"sha": "f17984d380459cd4564da0e2edfd59f565f43cb4", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -17,6 +17,8 @@ use mir::repr::Mir;\n use ty::TyCtxt;\n use syntax::ast::NodeId;\n \n+use std::fmt;\n+\n /// Where a specific Mir comes from.\n #[derive(Debug, Copy, Clone)]\n pub enum MirSource {\n@@ -70,16 +72,34 @@ impl<'a, 'tcx> MirSource {\n \n /// Various information about pass.\n pub trait Pass {\n-    // fn name() for printouts of various sorts?\n     // fn should_run(Session) to check if pass should run?\n     fn dep_node(&self, def_id: DefId) -> DepNode<DefId> {\n         DepNode::MirPass(def_id)\n     }\n+    fn name(&self) -> &str {\n+        unsafe { ::std::intrinsics::type_name::<Self>() }\n+    }\n+    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> { None }\n }\n \n /// A pass which inspects the whole MirMap.\n pub trait MirMapPass<'tcx>: Pass {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>);\n+    fn run_pass<'a>(\n+        &mut self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        map: &mut MirMap<'tcx>,\n+        hooks: &mut [Box<for<'s> MirPassHook<'s>>]);\n+}\n+\n+pub trait MirPassHook<'tcx>: Pass {\n+    fn on_mir_pass<'a>(\n+        &mut self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        src: MirSource,\n+        mir: &Mir<'tcx>,\n+        pass: &Pass,\n+        is_after: bool\n+    );\n }\n \n /// A pass which inspects Mir of functions in isolation.\n@@ -94,16 +114,33 @@ pub trait MirPass<'tcx>: Pass {\n }\n \n impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n+    fn run_pass<'a>(&mut self,\n+                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    map: &mut MirMap<'tcx>,\n+                    hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n+    {\n         for (&id, mir) in &mut map.map {\n             let def_id = tcx.map.local_def_id(id);\n             let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n \n             let src = MirSource::from_node(tcx, id);\n+\n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, mir, self, false);\n+            }\n             MirPass::run_pass(self, tcx, src, mir);\n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, mir, self, true);\n+            }\n \n             for (i, mir) in mir.promoted.iter_mut().enumerate() {\n+                for hook in &mut *hooks {\n+                    hook.on_mir_pass(tcx, src, mir, self, false);\n+                }\n                 self.run_pass_on_promoted(tcx, id, i, mir);\n+                for hook in &mut *hooks {\n+                    hook.on_mir_pass(tcx, src, mir, self, true);\n+                }\n             }\n         }\n     }\n@@ -112,31 +149,38 @@ impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n /// A manager for MIR passes.\n pub struct Passes {\n     passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>,\n+    pass_hooks: Vec<Box<for<'tcx> MirPassHook<'tcx>>>,\n     plugin_passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>\n }\n \n impl<'a, 'tcx> Passes {\n     pub fn new() -> Passes {\n         let passes = Passes {\n             passes: Vec::new(),\n+            pass_hooks: Vec::new(),\n             plugin_passes: Vec::new()\n         };\n         passes\n     }\n \n     pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n         for pass in &mut self.plugin_passes {\n-            pass.run_pass(tcx, map);\n+            pass.run_pass(tcx, map, &mut self.pass_hooks);\n         }\n         for pass in &mut self.passes {\n-            pass.run_pass(tcx, map);\n+            pass.run_pass(tcx, map, &mut self.pass_hooks);\n         }\n     }\n \n     /// Pushes a built-in pass.\n     pub fn push_pass(&mut self, pass: Box<for<'b> MirMapPass<'b>>) {\n         self.passes.push(pass);\n     }\n+\n+    /// Pushes a pass hook.\n+    pub fn push_hook(&mut self, hook: Box<for<'b> MirPassHook<'b>>) {\n+        self.pass_hooks.push(hook);\n+    }\n }\n \n /// Copies the plugin passes."}, {"sha": "1af5123b4df6046828bf6f6d00c3e53152efd780", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -11,6 +11,7 @@\n use std::vec;\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::repr::*;\n \n@@ -44,7 +45,7 @@ impl<'a, 'tcx> Preorder<'a, 'tcx> {\n \n         Preorder {\n             mir: mir,\n-            visited: BitVector::new(mir.basic_blocks.len()),\n+            visited: BitVector::new(mir.basic_blocks().len()),\n             worklist: worklist\n         }\n     }\n@@ -63,7 +64,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n                 continue;\n             }\n \n-            let data = self.mir.basic_block_data(idx);\n+            let data = &self.mir[idx];\n \n             if let Some(ref term) = data.terminator {\n                 for &succ in term.successors().iter() {\n@@ -106,12 +107,12 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n     pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {\n             mir: mir,\n-            visited: BitVector::new(mir.basic_blocks.len()),\n+            visited: BitVector::new(mir.basic_blocks().len()),\n             visit_stack: Vec::new()\n         };\n \n \n-        let data = po.mir.basic_block_data(root);\n+        let data = &po.mir[root];\n \n         if let Some(ref term) = data.terminator {\n             po.visited.insert(root.index());\n@@ -185,9 +186,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n             };\n \n             if self.visited.insert(bb.index()) {\n-                let data = self.mir.basic_block_data(bb);\n-\n-                if let Some(ref term) = data.terminator {\n+                if let Some(ref term) = self.mir[bb].terminator {\n                     let succs = term.successors().into_owned().into_iter();\n                     self.visit_stack.push((bb, succs));\n                 }\n@@ -209,10 +208,7 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n             self.traverse_successor();\n         }\n \n-        next.map(|(bb, _)| {\n-            let data = self.mir.basic_block_data(bb);\n-            (bb, data)\n-        })\n+        next.map(|(bb, _)| (bb, &self.mir[bb]))\n     }\n }\n \n@@ -278,9 +274,6 @@ impl<'a, 'tcx> Iterator for ReversePostorder<'a, 'tcx> {\n         if self.idx == 0 { return None; }\n         self.idx -= 1;\n \n-        self.blocks.get(self.idx).map(|&bb| {\n-            let data = self.mir.basic_block_data(bb);\n-            (bb, data)\n-        })\n+        self.blocks.get(self.idx).map(|&bb| (bb, &self.mir[bb]))\n     }\n }"}, {"sha": "bc45a730c2e21c965987c2d3fb7cdea69c4f6c61", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -15,6 +15,7 @@ use ty::{ClosureSubsts, FnOutput, Region, Ty};\n use mir::repr::*;\n use rustc_const_math::ConstUsize;\n use rustc_data_structures::tuple_slice::TupleSlice;\n+use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::Span;\n \n // # The MIR Visitor\n@@ -251,42 +252,30 @@ macro_rules! make_mir_visitor {\n \n             fn super_mir(&mut self,\n                          mir: & $($mutability)* Mir<'tcx>) {\n-                let Mir {\n-                    ref $($mutability)* basic_blocks,\n-                    ref $($mutability)* visibility_scopes,\n-                    promoted: _, // Visited by passes separately.\n-                    ref $($mutability)* return_ty,\n-                    ref $($mutability)* var_decls,\n-                    ref $($mutability)* arg_decls,\n-                    ref $($mutability)* temp_decls,\n-                    upvar_decls: _,\n-                    ref $($mutability)* span,\n-                } = *mir;\n-\n-                for (index, data) in basic_blocks.into_iter().enumerate() {\n+                for index in 0..mir.basic_blocks().len() {\n                     let block = BasicBlock::new(index);\n-                    self.visit_basic_block_data(block, data);\n+                    self.visit_basic_block_data(block, &$($mutability)* mir[block]);\n                 }\n \n-                for scope in visibility_scopes {\n+                for scope in &$($mutability)* mir.visibility_scopes {\n                     self.visit_visibility_scope_data(scope);\n                 }\n \n-                self.visit_fn_output(return_ty);\n+                self.visit_fn_output(&$($mutability)* mir.return_ty);\n \n-                for var_decl in var_decls {\n+                for var_decl in &$($mutability)* mir.var_decls {\n                     self.visit_var_decl(var_decl);\n                 }\n \n-                for arg_decl in arg_decls {\n+                for arg_decl in &$($mutability)* mir.arg_decls {\n                     self.visit_arg_decl(arg_decl);\n                 }\n \n-                for temp_decl in temp_decls {\n+                for temp_decl in &$($mutability)* mir.temp_decls {\n                     self.visit_temp_decl(temp_decl);\n                 }\n \n-                self.visit_span(span);\n+                self.visit_span(&$($mutability)* mir.span);\n             }\n \n             fn super_basic_block_data(&mut self,\n@@ -397,7 +386,8 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     TerminatorKind::Resume |\n-                    TerminatorKind::Return => {\n+                    TerminatorKind::Return |\n+                    TerminatorKind::Unreachable => {\n                     }\n \n                     TerminatorKind::Drop { ref $($mutability)* location,"}, {"sha": "c8a71ea350555fc6405184abf1ad42a6ba99dd9b", "filename": "src/librustc_borrowck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2FCargo.toml?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -14,4 +14,5 @@ log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_mir = { path = \"../librustc_mir\" }"}, {"sha": "91be50d11f952c68fe9e1bc8a28758ad93ef2300", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -12,6 +12,7 @@\n \n use syntax::ast::NodeId;\n use rustc::mir::repr::{BasicBlock, Mir};\n+use rustc_data_structures::indexed_vec::Idx;\n \n use dot;\n use dot::IntoCow;\n@@ -27,7 +28,7 @@ use std::path::Path;\n use super::super::MoveDataParamEnv;\n use super::super::MirBorrowckCtxtPreDataflow;\n use bitslice::bits_to_string;\n-use indexed_set::{Idx, IdxSet};\n+use indexed_set::{IdxSet};\n use super::{BitDenotation, DataflowState};\n \n impl<O: BitDenotation> DataflowState<O> {\n@@ -126,7 +127,7 @@ pub type Node = BasicBlock;\n pub struct Edge { source: BasicBlock, index: usize }\n \n fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n-    let succ_len = mir.basic_block_data(bb).terminator().successors().len();\n+    let succ_len = mir[bb].terminator().successors().len();\n     (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n }\n \n@@ -312,17 +313,20 @@ impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n     type Node = Node;\n     type Edge = Edge;\n     fn nodes(&self) -> dot::Nodes<Node> {\n-        self.mbcx.mir().all_basic_blocks().into_cow()\n+        self.mbcx.mir()\n+            .basic_blocks()\n+            .indices()\n+            .collect::<Vec<_>>()\n+            .into_cow()\n     }\n \n     fn edges(&self) -> dot::Edges<Edge> {\n         let mir = self.mbcx.mir();\n-        let blocks = mir.all_basic_blocks();\n         // base initial capacity on assumption every block has at\n         // least one outgoing edge (Which should be true for all\n         // blocks but one, the exit-block).\n-        let mut edges = Vec::with_capacity(blocks.len());\n-        for bb in blocks {\n+        let mut edges = Vec::with_capacity(mir.basic_blocks().len());\n+        for bb in mir.basic_blocks().indices() {\n             let outgoing = outgoing(mir, bb);\n             edges.extend(outgoing.into_iter());\n         }\n@@ -335,6 +339,6 @@ impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n \n     fn target(&self, edge: &Edge) -> Node {\n         let mir = self.mbcx.mir();\n-        mir.basic_block_data(edge.source).terminator().successors()[edge.index]\n+        mir[edge.source].terminator().successors()[edge.index]\n     }\n }"}, {"sha": "932b748520170ac11c594920a74f047c7eca3345", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -10,6 +10,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::repr::{self, Mir};\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::super::gather_moves::{Location};\n use super::super::gather_moves::{MoveOutIndex, MovePathIndex};\n@@ -23,7 +24,7 @@ use super::{BitDenotation, BlockSets, DataflowOperator};\n \n use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use bitslice::{BitwiseOperator};\n-use indexed_set::{Idx, IdxSet};\n+use indexed_set::{IdxSet};\n \n // Dataflow analyses are built upon some interpretation of the\n // bitvectors attached to each basic block, represented via a\n@@ -425,7 +426,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                         bb: repr::BasicBlock,\n                         idx: usize) {\n         let (tcx, mir, move_data) = (self.tcx, self.mir, &ctxt.move_data);\n-        let stmt = &mir.basic_block_data(bb).statements[idx];\n+        let stmt = &mir[bb].statements[idx];\n         let loc_map = &move_data.loc_map;\n         let path_map = &move_data.path_map;\n         let rev_lookup = &move_data.rev_lookup;\n@@ -451,7 +452,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                                      move_data,\n                                      move_path_index,\n                                      |mpi| for moi in &path_map[mpi] {\n-                                         assert!(moi.idx() < bits_per_block);\n+                                         assert!(moi.index() < bits_per_block);\n                                          sets.kill_set.add(&moi);\n                                      });\n             }\n@@ -465,14 +466,14 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                          statements_len: usize)\n     {\n         let (mir, move_data) = (self.mir, &ctxt.move_data);\n-        let term = mir.basic_block_data(bb).terminator.as_ref().unwrap();\n+        let term = mir[bb].terminator();\n         let loc_map = &move_data.loc_map;\n         let loc = Location { block: bb, index: statements_len };\n         debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n                term, loc, &loc_map[loc]);\n         let bits_per_block = self.bits_per_block(ctxt);\n         for move_index in &loc_map[loc] {\n-            assert!(move_index.idx() < bits_per_block);\n+            assert!(move_index.index() < bits_per_block);\n             zero_to_one(sets.gen_set.words_mut(), *move_index);\n         }\n     }\n@@ -493,14 +494,14 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                              move_data,\n                              move_path_index,\n                              |mpi| for moi in &path_map[mpi] {\n-                                 assert!(moi.idx() < bits_per_block);\n+                                 assert!(moi.index() < bits_per_block);\n                                  in_out.remove(&moi);\n                              });\n     }\n }\n \n fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n-    let retval = bitvec.set_bit(move_index.idx());\n+    let retval = bitvec.set_bit(move_index.index());\n     assert!(retval);\n }\n "}, {"sha": "a9b4de450967cfa0bcfebe5b82034f5105ca39df", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::{self, Mir};\n \n@@ -21,7 +23,7 @@ use super::MirBorrowckCtxtPreDataflow;\n use super::MoveDataParamEnv;\n \n use bitslice::{bitwise, BitwiseOperator};\n-use indexed_set::{Idx, IdxSet, IdxSetBuf};\n+use indexed_set::{IdxSet, IdxSetBuf};\n \n pub use self::sanity_check::sanity_check_via_rustc_peek;\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n@@ -81,11 +83,10 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n             self.flow_state.operator.start_block_effect(&self.ctxt, sets);\n         }\n \n-        for bb in self.mir.all_basic_blocks() {\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             let &repr::BasicBlockData { ref statements,\n                                         ref terminator,\n-                                        is_cleanup: _ } =\n-                self.mir.basic_block_data(bb);\n+                                        is_cleanup: _ } = data;\n \n             let sets = &mut self.flow_state.sets.for_block(bb.index());\n             for j_stmt in 0..statements.len() {\n@@ -112,7 +113,7 @@ impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD>\n \n     fn walk_cfg(&mut self, in_out: &mut IdxSet<BD::Idx>) {\n         let mir = self.builder.mir;\n-        for (bb_idx, bb_data) in mir.basic_blocks.iter().enumerate() {\n+        for (bb_idx, bb_data) in mir.basic_blocks().iter().enumerate() {\n             let builder = &mut self.builder;\n             {\n                 let sets = builder.flow_state.sets.for_block(bb_idx);\n@@ -396,7 +397,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n         // (now rounded up to multiple of word size)\n         let bits_per_block = words_per_block * usize_bits;\n \n-        let num_blocks = mir.basic_blocks.len();\n+        let num_blocks = mir.basic_blocks().len();\n         let num_overall = num_blocks * bits_per_block;\n \n         let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n@@ -448,7 +449,8 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n     {\n         match bb_data.terminator().kind {\n             repr::TerminatorKind::Return |\n-            repr::TerminatorKind::Resume => {}\n+            repr::TerminatorKind::Resume |\n+            repr::TerminatorKind::Unreachable => {}\n             repr::TerminatorKind::Goto { ref target } |\n             repr::TerminatorKind::Assert { ref target, cleanup: None, .. } |\n             repr::TerminatorKind::Drop { ref target, location: _, unwind: None } |"}, {"sha": "c8d3ff01b6c1a37acce4ed97113b6afd9a6e246a", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -14,6 +14,7 @@ use syntax::codemap::Span;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::repr::{self, Mir};\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::super::gather_moves::{MovePathIndex};\n use super::super::MoveDataParamEnv;\n@@ -49,8 +50,7 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // `dataflow::build_sets`. (But note it is doing non-standard\n     // stuff, so such generalization may not be realistic.)\n \n-    let blocks = mir.all_basic_blocks();\n-    'next_block: for bb in blocks {\n+    for bb in mir.basic_blocks().indices() {\n         each_block(tcx, mir, flow_ctxt, results, bb);\n     }\n }\n@@ -63,10 +63,9 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     O: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>, Idx=MovePathIndex>\n {\n     let move_data = &ctxt.move_data;\n-    let bb_data = mir.basic_block_data(bb);\n-    let &repr::BasicBlockData { ref statements,\n-                                ref terminator,\n-                                is_cleanup: _ } = bb_data;\n+    let repr::BasicBlockData { ref statements,\n+                               ref terminator,\n+                               is_cleanup: _ } = mir[bb];\n \n     let (args, span) = match is_rustc_peek(tcx, terminator) {\n         Some(args_and_span) => args_and_span,"}, {"sha": "74ebad107eb8a9580bace011ecc639af35849f29", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -22,7 +22,7 @@ use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n use rustc::util::nodemap::FnvHashMap;\n-use rustc_mir::pretty;\n+use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::Span;\n \n use std::fmt;\n@@ -65,9 +65,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n                 patch: MirPatch::new(mir),\n             }.elaborate()\n         };\n-        pretty::dump_mir(tcx, \"elaborate_drops\", &0, src, mir, None);\n         elaborate_patch.apply(mir);\n-        pretty::dump_mir(tcx, \"elaborate_drops\", &1, src, mir, None);\n     }\n }\n \n@@ -118,7 +116,7 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     env: &'a MoveDataParamEnv<'tcx>,\n     flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n     flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n-    drop_flags: FnvHashMap<MovePathIndex, u32>,\n+    drop_flags: FnvHashMap<MovePathIndex, Temp>,\n     patch: MirPatch<'tcx>,\n }\n \n@@ -214,8 +212,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn collect_drop_flags(&mut self)\n     {\n-        for bb in self.mir.all_basic_blocks() {\n-            let data = self.mir.basic_block_data(bb);\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             let terminator = data.terminator();\n             let location = match terminator.kind {\n                 TerminatorKind::Drop { ref location, .. } |\n@@ -251,8 +248,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn elaborate_drops(&mut self)\n     {\n-        for bb in self.mir.all_basic_blocks() {\n-            let data = self.mir.basic_block_data(bb);\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             let loc = Location { block: bb, index: data.statements.len() };\n             let terminator = data.terminator();\n \n@@ -312,7 +308,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         unwind: Option<BasicBlock>)\n     {\n         let bb = loc.block;\n-        let data = self.mir.basic_block_data(bb);\n+        let data = &self.mir[bb];\n         let terminator = data.terminator();\n \n         let assign = Statement {\n@@ -931,8 +927,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flags_for_fn_rets(&mut self) {\n-        for bb in self.mir.all_basic_blocks() {\n-            let data = self.mir.basic_block_data(bb);\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             if let TerminatorKind::Call {\n                 destination: Some((ref lv, tgt)), cleanup: Some(_), ..\n             } = data.terminator().kind {\n@@ -964,8 +959,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         // drop flags by themselves, to avoid the drop flags being\n         // clobbered before they are read.\n \n-        for bb in self.mir.all_basic_blocks() {\n-            let data = self.mir.basic_block_data(bb);\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             debug!(\"drop_flags_for_locs({:?})\", data);\n             for i in 0..(data.statements.len()+1) {\n                 debug!(\"drop_flag_for_locs: stmt {}\", i);"}, {"sha": "05412216d487c9e7153b6b2ed9c05d1928cf9c53", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -12,6 +12,7 @@\n use rustc::ty::{FnOutput, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::util::nodemap::FnvHashMap;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use std::cell::{Cell};\n use std::collections::hash_map::Entry;\n@@ -20,7 +21,6 @@ use std::iter;\n use std::ops::Index;\n \n use super::abs_domain::{AbstractElem, Lift};\n-use indexed_set::{Idx};\n \n // This submodule holds some newtype'd Index wrappers that are using\n // NonZero to ensure that Option<Index> occupies only a single word.\n@@ -29,7 +29,7 @@ use indexed_set::{Idx};\n // (which is likely to yield a subtle off-by-one error).\n mod indexes {\n     use core::nonzero::NonZero;\n-    use indexed_set::Idx;\n+    use rustc_data_structures::indexed_vec::Idx;\n \n     macro_rules! new_index {\n         ($Index:ident) => {\n@@ -43,7 +43,7 @@ mod indexes {\n                 fn new(idx: usize) -> Self {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n                 }\n-                fn idx(&self) -> usize {\n+                fn index(self) -> usize {\n                     *self.0 - 1\n                 }\n             }\n@@ -62,7 +62,7 @@ pub use self::indexes::MoveOutIndex;\n \n impl self::indexes::MoveOutIndex {\n     pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {\n-        move_data.moves[self.idx()].path\n+        move_data.moves[self.index()].path\n     }\n }\n \n@@ -176,7 +176,7 @@ pub struct PathMap {\n impl Index<MovePathIndex> for PathMap {\n     type Output = [MoveOutIndex];\n     fn index(&self, index: MovePathIndex) -> &Self::Output {\n-        &self.map[index.idx()]\n+        &self.map[index.index()]\n     }\n }\n \n@@ -196,7 +196,7 @@ pub struct MoveOut {\n \n impl fmt::Debug for MoveOut {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"p{}@{:?}\", self.path.idx(), self.source)\n+        write!(fmt, \"p{}@{:?}\", self.path.index(), self.source)\n     }\n }\n \n@@ -227,14 +227,10 @@ impl<'tcx> MovePathData<'tcx> {\n impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n     type Output = MovePath<'tcx>;\n     fn index(&self, i: MovePathIndex) -> &MovePath<'tcx> {\n-        &self.move_paths[i.idx()]\n+        &self.move_paths[i.index()]\n     }\n }\n \n-/// MovePathInverseMap maps from a uint in an lvalue-category to the\n-/// MovePathIndex for the MovePath for that lvalue.\n-type MovePathInverseMap = Vec<Option<MovePathIndex>>;\n-\n struct MovePathDataBuilder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     pre_move_paths: Vec<PreMovePath<'tcx>>,\n@@ -244,9 +240,9 @@ struct MovePathDataBuilder<'a, 'tcx: 'a> {\n /// Tables mapping from an l-value to its MovePathIndex.\n #[derive(Debug)]\n pub struct MovePathLookup<'tcx> {\n-    vars: MovePathInverseMap,\n-    temps: MovePathInverseMap,\n-    args: MovePathInverseMap,\n+    vars: IndexVec<Var, Option<MovePathIndex>>,\n+    temps: IndexVec<Temp, Option<MovePathIndex>>,\n+    args: IndexVec<Arg, Option<MovePathIndex>>,\n \n     /// The move path representing the return value is constructed\n     /// lazily when we first encounter it in the input MIR.\n@@ -295,15 +291,15 @@ enum LookupKind { Generate, Reuse }\n struct Lookup<T>(LookupKind, T);\n \n impl Lookup<MovePathIndex> {\n-    fn idx(&self) -> usize { (self.1).idx() }\n+    fn index(&self) -> usize { (self.1).index() }\n }\n \n impl<'tcx> MovePathLookup<'tcx> {\n-    fn new() -> Self {\n+    fn new(mir: &Mir) -> Self {\n         MovePathLookup {\n-            vars: vec![],\n-            temps: vec![],\n-            args: vec![],\n+            vars: IndexVec::from_elem(None, &mir.var_decls),\n+            temps: IndexVec::from_elem(None, &mir.temp_decls),\n+            args: IndexVec::from_elem(None, &mir.arg_decls),\n             statics: None,\n             return_ptr: None,\n             projections: vec![],\n@@ -313,15 +309,14 @@ impl<'tcx> MovePathLookup<'tcx> {\n \n     fn next_index(next: &mut MovePathIndex) -> MovePathIndex {\n         let i = *next;\n-        *next = MovePathIndex::new(i.idx() + 1);\n+        *next = MovePathIndex::new(i.index() + 1);\n         i\n     }\n \n-    fn lookup_or_generate(vec: &mut Vec<Option<MovePathIndex>>,\n-                          idx: u32,\n-                          next_index: &mut MovePathIndex) -> Lookup<MovePathIndex> {\n-        let idx = idx as usize;\n-        vec.fill_to_with(idx, None);\n+    fn lookup_or_generate<I: Idx>(vec: &mut IndexVec<I, Option<MovePathIndex>>,\n+                                  idx: I,\n+                                  next_index: &mut MovePathIndex)\n+                                  -> Lookup<MovePathIndex> {\n         let entry = &mut vec[idx];\n         match *entry {\n             None => {\n@@ -335,19 +330,19 @@ impl<'tcx> MovePathLookup<'tcx> {\n         }\n     }\n \n-    fn lookup_var(&mut self, var_idx: u32) -> Lookup<MovePathIndex> {\n+    fn lookup_var(&mut self, var_idx: Var) -> Lookup<MovePathIndex> {\n         Self::lookup_or_generate(&mut self.vars,\n                                  var_idx,\n                                  &mut self.next_index)\n     }\n \n-    fn lookup_temp(&mut self, temp_idx: u32) -> Lookup<MovePathIndex> {\n+    fn lookup_temp(&mut self, temp_idx: Temp) -> Lookup<MovePathIndex> {\n         Self::lookup_or_generate(&mut self.temps,\n                                  temp_idx,\n                                  &mut self.next_index)\n     }\n \n-    fn lookup_arg(&mut self, arg_idx: u32) -> Lookup<MovePathIndex> {\n+    fn lookup_arg(&mut self, arg_idx: Arg) -> Lookup<MovePathIndex> {\n         Self::lookup_or_generate(&mut self.args,\n                                  arg_idx,\n                                  &mut self.next_index)\n@@ -384,8 +379,8 @@ impl<'tcx> MovePathLookup<'tcx> {\n                    base: MovePathIndex) -> Lookup<MovePathIndex> {\n         let MovePathLookup { ref mut projections,\n                              ref mut next_index, .. } = *self;\n-        projections.fill_to(base.idx());\n-        match projections[base.idx()].entry(proj.elem.lift()) {\n+        projections.fill_to(base.index());\n+        match projections[base.index()].entry(proj.elem.lift()) {\n             Entry::Occupied(ent) => {\n                 Lookup(LookupKind::Reuse, *ent.get())\n             }\n@@ -404,14 +399,14 @@ impl<'tcx> MovePathLookup<'tcx> {\n     // unknown l-value; it will simply panic.\n     pub fn find(&self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n         match *lval {\n-            Lvalue::Var(var_idx) => self.vars[var_idx as usize].unwrap(),\n-            Lvalue::Temp(temp_idx) => self.temps[temp_idx as usize].unwrap(),\n-            Lvalue::Arg(arg_idx) => self.args[arg_idx as usize].unwrap(),\n+            Lvalue::Var(var) => self.vars[var].unwrap(),\n+            Lvalue::Temp(temp) => self.temps[temp].unwrap(),\n+            Lvalue::Arg(arg) => self.args[arg].unwrap(),\n             Lvalue::Static(ref _def_id) => self.statics.unwrap(),\n             Lvalue::ReturnPointer => self.return_ptr.unwrap(),\n             Lvalue::Projection(ref proj) => {\n                 let base_index = self.find(&proj.base);\n-                self.projections[base_index.idx()][&proj.elem.lift()]\n+                self.projections[base_index.index()][&proj.elem.lift()]\n             }\n         }\n     }\n@@ -451,7 +446,7 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n \n         // `lookup` is either the previously assigned index or a\n         // newly-allocated one.\n-        debug_assert!(lookup.idx() <= self.pre_move_paths.len());\n+        debug_assert!(lookup.index() <= self.pre_move_paths.len());\n \n         if let Lookup(LookupKind::Generate, mpi) = lookup {\n             let parent;\n@@ -482,7 +477,7 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n                     let idx = self.move_path_for(&proj.base);\n                     parent = Some(idx);\n \n-                    let parent_move_path = &mut self.pre_move_paths[idx.idx()];\n+                    let parent_move_path = &mut self.pre_move_paths[idx.index()];\n \n                     // At last: Swap in the new first_child.\n                     sibling = parent_move_path.first_child.get();\n@@ -524,9 +519,9 @@ enum StmtKind {\n fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveData<'tcx> {\n     use self::StmtKind as SK;\n \n-    let bbs = mir.all_basic_blocks();\n-    let mut moves = Vec::with_capacity(bbs.len());\n-    let mut loc_map: Vec<_> = iter::repeat(Vec::new()).take(bbs.len()).collect();\n+    let bb_count = mir.basic_blocks().len();\n+    let mut moves = vec![];\n+    let mut loc_map: Vec<_> = iter::repeat(Vec::new()).take(bb_count).collect();\n     let mut path_map = Vec::new();\n \n     // this is mutable only because we will move it to and fro' the\n@@ -535,7 +530,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     let mut builder = MovePathDataBuilder {\n         mir: mir,\n         pre_move_paths: Vec::new(),\n-        rev_lookup: MovePathLookup::new(),\n+        rev_lookup: MovePathLookup::new(mir),\n     };\n \n     // Before we analyze the program text, we create the MovePath's\n@@ -546,22 +541,21 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     assert!(mir.var_decls.len() <= ::std::u32::MAX as usize);\n     assert!(mir.arg_decls.len() <= ::std::u32::MAX as usize);\n     assert!(mir.temp_decls.len() <= ::std::u32::MAX as usize);\n-    for var_idx in 0..mir.var_decls.len() {\n-        let path_idx = builder.move_path_for(&Lvalue::Var(var_idx as u32));\n-        path_map.fill_to(path_idx.idx());\n+    for var in mir.var_decls.indices() {\n+        let path_idx = builder.move_path_for(&Lvalue::Var(var));\n+        path_map.fill_to(path_idx.index());\n     }\n-    for arg_idx in 0..mir.arg_decls.len() {\n-        let path_idx = builder.move_path_for(&Lvalue::Arg(arg_idx as u32));\n-        path_map.fill_to(path_idx.idx());\n+    for arg in mir.arg_decls.indices() {\n+        let path_idx = builder.move_path_for(&Lvalue::Arg(arg));\n+        path_map.fill_to(path_idx.index());\n     }\n-    for temp_idx in 0..mir.temp_decls.len() {\n-        let path_idx = builder.move_path_for(&Lvalue::Temp(temp_idx as u32));\n-        path_map.fill_to(path_idx.idx());\n+    for temp in mir.temp_decls.indices() {\n+        let path_idx = builder.move_path_for(&Lvalue::Temp(temp));\n+        path_map.fill_to(path_idx.index());\n     }\n \n-    for bb in bbs {\n+    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n         let loc_map_bb = &mut loc_map[bb.index()];\n-        let bb_data = mir.basic_block_data(bb);\n \n         debug_assert!(loc_map_bb.len() == 0);\n         let len = bb_data.statements.len();\n@@ -585,7 +579,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                     // Ensure that the path_map contains entries even\n                     // if the lvalue is assigned and never read.\n                     let assigned_path = bb_ctxt.builder.move_path_for(lval);\n-                    bb_ctxt.path_map.fill_to(assigned_path.idx());\n+                    bb_ctxt.path_map.fill_to(assigned_path.index());\n \n                     match *rval {\n                         Rvalue::Use(ref operand) => {\n@@ -627,7 +621,9 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n \n         debug!(\"gather_moves({:?})\", bb_data.terminator());\n         match bb_data.terminator().kind {\n-            TerminatorKind::Goto { target: _ } | TerminatorKind::Resume => { }\n+            TerminatorKind::Goto { target: _ } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n                 let source = Location { block: bb,\n@@ -679,7 +675,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             }\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n                 let assigned_path = bb_ctxt.builder.move_path_for(location);\n-                bb_ctxt.path_map.fill_to(assigned_path.idx());\n+                bb_ctxt.path_map.fill_to(assigned_path.index());\n \n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n@@ -699,7 +695,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                     // Ensure that the path_map contains entries even\n                     // if the lvalue is assigned and never read.\n                     let assigned_path = bb_ctxt.builder.move_path_for(destination);\n-                    bb_ctxt.path_map.fill_to(assigned_path.idx());\n+                    bb_ctxt.path_map.fill_to(assigned_path.index());\n \n                     bb_ctxt.builder.create_move_path(destination);\n                 }\n@@ -729,8 +725,8 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n         let mut seen: Vec<_> = move_paths.iter().map(|_| false).collect();\n         for (j, &MoveOut { ref path, ref source }) in moves.iter().enumerate() {\n             debug!(\"MovePathData moves[{}]: MoveOut {{ path: {:?} = {:?}, source: {:?} }}\",\n-                   j, path, move_paths[path.idx()], source);\n-            seen[path.idx()] = true;\n+                   j, path, move_paths[path.index()], source);\n+            seen[path.index()] = true;\n         }\n         for (j, path) in move_paths.iter().enumerate() {\n             if !seen[j] {\n@@ -767,20 +763,20 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n \n         let path = self.builder.move_path_for(lval);\n         self.moves.push(MoveOut { path: path, source: source.clone() });\n-        self.path_map.fill_to(path.idx());\n+        self.path_map.fill_to(path.index());\n \n         debug!(\"ctxt: {:?} add consume of lval: {:?} \\\n                 at index: {:?} \\\n                 to path_map for path: {:?} and \\\n                 to loc_map for loc: {:?}\",\n                stmt_kind, lval, index, path, source);\n \n-        debug_assert!(path.idx() < self.path_map.len());\n+        debug_assert!(path.index() < self.path_map.len());\n         // this is actually a questionable assert; at the very\n         // least, incorrect input code can probably cause it to\n         // fire.\n-        assert!(self.path_map[path.idx()].iter().find(|idx| **idx == index).is_none());\n-        self.path_map[path.idx()].push(index);\n+        assert!(self.path_map[path.index()].iter().find(|idx| **idx == index).is_none());\n+        self.path_map[path.index()].push(index);\n \n         debug_assert!(i < self.loc_map_bb.len());\n         debug_assert!(self.loc_map_bb[i].iter().find(|idx| **idx == index).is_none());"}, {"sha": "36f7c11c8cb8105b6f10e1974f4e33a6507534ad", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -111,7 +111,7 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n         flow_uninits: flow_uninits,\n     };\n \n-    for bb in mir.all_basic_blocks() {\n+    for bb in mir.basic_blocks().indices() {\n         mbcx.process_basic_block(bb);\n     }\n \n@@ -180,8 +180,8 @@ pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n \n impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n     fn process_basic_block(&mut self, bb: BasicBlock) {\n-        let &BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n-            self.mir.basic_block_data(bb);\n+        let BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n+            self.mir[bb];\n         for stmt in statements {\n             self.process_statement(bb, stmt);\n         }\n@@ -327,8 +327,8 @@ fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n     where F: FnMut(MovePathIndex, DropFlagState)\n {\n     let move_data = &ctxt.move_data;\n-    for i in 0..(mir.arg_decls.len() as u32) {\n-        let lvalue = repr::Lvalue::Arg(i);\n+    for (arg, _) in mir.arg_decls.iter_enumerated() {\n+        let lvalue = repr::Lvalue::Arg(arg);\n         let move_path_index = move_data.rev_lookup.find(&lvalue);\n         on_all_children_bits(tcx, mir, move_data,\n                              move_path_index,\n@@ -366,8 +366,8 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n                              |moi| callback(moi, DropFlagState::Absent))\n     }\n \n-    let bb = mir.basic_block_data(loc.block);\n-    match bb.statements.get(loc.index) {\n+    let block = &mir[loc.block];\n+    match block.statements.get(loc.index) {\n         Some(stmt) => match stmt.kind {\n             repr::StatementKind::Assign(ref lvalue, _) => {\n                 debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n@@ -377,8 +377,8 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             }\n         },\n         None => {\n-            debug!(\"drop_flag_effects: replace {:?}\", bb.terminator());\n-            match bb.terminator().kind {\n+            debug!(\"drop_flag_effects: replace {:?}\", block.terminator());\n+            match block.terminator().kind {\n                 repr::TerminatorKind::DropAndReplace { ref location, .. } => {\n                     on_all_children_bits(tcx, mir, move_data,\n                                          move_data.rev_lookup.find(location),"}, {"sha": "417e719a9dcb9f73cee1c24c6736cdaf532ed185", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -11,31 +11,28 @@\n use super::gather_moves::Location;\n use rustc::ty::Ty;\n use rustc::mir::repr::*;\n-\n-use std::iter;\n-use std::u32;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n /// This struct represents a patch to MIR, which can add\n /// new statements and basic blocks and patch over block\n /// terminators.\n pub struct MirPatch<'tcx> {\n-    patch_map: Vec<Option<TerminatorKind<'tcx>>>,\n+    patch_map: IndexVec<BasicBlock, Option<TerminatorKind<'tcx>>>,\n     new_blocks: Vec<BasicBlockData<'tcx>>,\n     new_statements: Vec<(Location, StatementKind<'tcx>)>,\n     new_temps: Vec<TempDecl<'tcx>>,\n     resume_block: BasicBlock,\n-    next_temp: u32,\n+    next_temp: usize,\n }\n \n impl<'tcx> MirPatch<'tcx> {\n     pub fn new(mir: &Mir<'tcx>) -> Self {\n         let mut result = MirPatch {\n-            patch_map: iter::repeat(None)\n-                .take(mir.basic_blocks.len()).collect(),\n+            patch_map: IndexVec::from_elem(None, mir.basic_blocks()),\n             new_blocks: vec![],\n             new_temps: vec![],\n             new_statements: vec![],\n-            next_temp: mir.temp_decls.len() as u32,\n+            next_temp: mir.temp_decls.len(),\n             resume_block: START_BLOCK\n         };\n \n@@ -46,13 +43,12 @@ impl<'tcx> MirPatch<'tcx> {\n \n         let mut resume_block = None;\n         let mut resume_stmt_block = None;\n-        for block in mir.all_basic_blocks() {\n-            let data = mir.basic_block_data(block);\n-            if let TerminatorKind::Resume = data.terminator().kind {\n-                if data.statements.len() > 0 {\n-                    resume_stmt_block = Some(block);\n+        for (bb, block) in mir.basic_blocks().iter_enumerated() {\n+            if let TerminatorKind::Resume = block.terminator().kind {\n+                if block.statements.len() > 0 {\n+                    resume_stmt_block = Some(bb);\n                 } else {\n-                    resume_block = Some(block);\n+                    resume_block = Some(bb);\n                 }\n                 break\n             }\n@@ -83,26 +79,25 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn is_patched(&self, bb: BasicBlock) -> bool {\n-        self.patch_map[bb.index()].is_some()\n+        self.patch_map[bb].is_some()\n     }\n \n     pub fn terminator_loc(&self, mir: &Mir<'tcx>, bb: BasicBlock) -> Location {\n-        let offset = match bb.index().checked_sub(mir.basic_blocks.len()) {\n+        let offset = match bb.index().checked_sub(mir.basic_blocks().len()) {\n             Some(index) => self.new_blocks[index].statements.len(),\n-            None => mir.basic_block_data(bb).statements.len()\n+            None => mir[bb].statements.len()\n         };\n         Location {\n             block: bb,\n             index: offset\n         }\n     }\n \n-    pub fn new_temp(&mut self, ty: Ty<'tcx>) -> u32 {\n+    pub fn new_temp(&mut self, ty: Ty<'tcx>) -> Temp {\n         let index = self.next_temp;\n-        assert!(self.next_temp < u32::MAX);\n         self.next_temp += 1;\n         self.new_temps.push(TempDecl { ty: ty });\n-        index\n+        Temp::new(index as usize)\n     }\n \n     pub fn new_block(&mut self, data: BasicBlockData<'tcx>) -> BasicBlock {\n@@ -114,9 +109,9 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn patch_terminator(&mut self, block: BasicBlock, new: TerminatorKind<'tcx>) {\n-        assert!(self.patch_map[block.index()].is_none());\n+        assert!(self.patch_map[block].is_none());\n         debug!(\"MirPatch: patch_terminator({:?}, {:?})\", block, new);\n-        self.patch_map[block.index()] = Some(new);\n+        self.patch_map[block] = Some(new);\n     }\n \n     pub fn add_statement(&mut self, loc: Location, stmt: StatementKind<'tcx>) {\n@@ -132,13 +127,13 @@ impl<'tcx> MirPatch<'tcx> {\n         debug!(\"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n                self.new_temps.len(), mir.temp_decls.len(), self.new_temps);\n         debug!(\"MirPatch: {} new blocks, starting from index {}\",\n-               self.new_blocks.len(), mir.basic_blocks.len());\n-        mir.basic_blocks.extend(self.new_blocks);\n+               self.new_blocks.len(), mir.basic_blocks().len());\n+        mir.basic_blocks_mut().extend(self.new_blocks);\n         mir.temp_decls.extend(self.new_temps);\n-        for (src, patch) in self.patch_map.into_iter().enumerate() {\n+        for (src, patch) in self.patch_map.into_iter_enumerated() {\n             if let Some(patch) = patch {\n                 debug!(\"MirPatch: patching block {:?}\", src);\n-                mir.basic_blocks[src].terminator_mut().kind = patch;\n+                mir[src].terminator_mut().kind = patch;\n             }\n         }\n \n@@ -156,9 +151,9 @@ impl<'tcx> MirPatch<'tcx> {\n                    stmt, loc, delta);\n             loc.index += delta;\n             let source_info = Self::source_info_for_index(\n-                mir.basic_block_data(loc.block), loc\n+                &mir[loc.block], loc\n             );\n-            mir.basic_block_data_mut(loc.block).statements.insert(\n+            mir[loc.block].statements.insert(\n                 loc.index, Statement {\n                     source_info: source_info,\n                     kind: stmt\n@@ -175,9 +170,9 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn source_info_for_location(&self, mir: &Mir, loc: Location) -> SourceInfo {\n-        let data = match loc.block.index().checked_sub(mir.basic_blocks.len()) {\n+        let data = match loc.block.index().checked_sub(mir.basic_blocks().len()) {\n             Some(new) => &self.new_blocks[new],\n-            None => mir.basic_block_data(loc.block)\n+            None => &mir[loc.block]\n         };\n         Self::source_info_for_index(data, loc)\n     }"}, {"sha": "671aff97d20aa7ff0afafad2ec2978cc4f1d391d", "filename": "src/librustc_borrowck/indexed_set.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Findexed_set.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -17,13 +17,7 @@ use std::ops::{Deref, DerefMut, Range};\n use bitslice::{BitSlice, Word};\n use bitslice::{bitwise, Union, Subtract};\n \n-/// Represents some newtyped `usize` wrapper.\n-///\n-/// (purpose: avoid mixing indexes for different bitvector domains.)\n-pub trait Idx: 'static {\n-    fn new(usize) -> Self;\n-    fn idx(&self) -> usize;\n-}\n+use rustc_data_structures::indexed_vec::Idx;\n \n /// Represents a set (or packed family of sets), of some element type\n /// E, where each E is identified by some unique index type `T`.\n@@ -120,27 +114,27 @@ impl<T: Idx> IdxSet<T> {\n \n     /// Removes `elem` from the set `self`; returns true iff this changed `self`.\n     pub fn remove(&mut self, elem: &T) -> bool {\n-        self.bits.clear_bit(elem.idx())\n+        self.bits.clear_bit(elem.index())\n     }\n \n     /// Adds `elem` to the set `self`; returns true iff this changed `self`.\n     pub fn add(&mut self, elem: &T) -> bool {\n-        self.bits.set_bit(elem.idx())\n+        self.bits.set_bit(elem.index())\n     }\n \n     pub fn range(&self, elems: &Range<T>) -> &Self {\n-        let elems = elems.start.idx()..elems.end.idx();\n+        let elems = elems.start.index()..elems.end.index();\n         unsafe { Self::from_slice(&self.bits[elems]) }\n     }\n \n     pub fn range_mut(&mut self, elems: &Range<T>) -> &mut Self {\n-        let elems = elems.start.idx()..elems.end.idx();\n+        let elems = elems.start.index()..elems.end.index();\n         unsafe { Self::from_slice_mut(&mut self.bits[elems]) }\n     }\n \n     /// Returns true iff set `self` contains `elem`.\n     pub fn contains(&self, elem: &T) -> bool {\n-        self.bits.get_bit(elem.idx())\n+        self.bits.get_bit(elem.index())\n     }\n \n     pub fn words(&self) -> &[Word] {"}, {"sha": "f3c39bd5fd165ad667ceba2b176598f8c21d8ff9", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -34,6 +34,7 @@\n extern crate graphviz as dot;\n #[macro_use]\n extern crate rustc;\n+extern crate rustc_data_structures;\n extern crate rustc_mir;\n extern crate core; // for NonZero\n "}, {"sha": "db054477f75a10517956dc457e03692c8cf43330", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -0,0 +1,228 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::{self, FromIterator};\n+use std::slice;\n+use std::marker::PhantomData;\n+use std::ops::{Index, IndexMut, Range};\n+use std::fmt;\n+use std::vec;\n+\n+use rustc_serialize as serialize;\n+\n+/// Represents some newtyped `usize` wrapper.\n+///\n+/// (purpose: avoid mixing indexes for different bitvector domains.)\n+pub trait Idx: Copy + 'static {\n+    fn new(usize) -> Self;\n+    fn index(self) -> usize;\n+}\n+\n+impl Idx for usize {\n+    fn new(idx: usize) -> Self { idx }\n+    fn index(self) -> usize { self }\n+}\n+\n+#[derive(Clone)]\n+pub struct IndexVec<I: Idx, T> {\n+    pub raw: Vec<T>,\n+    _marker: PhantomData<Fn(&I)>\n+}\n+\n+impl<I: Idx, T: serialize::Encodable> serialize::Encodable for IndexVec<I, T> {\n+    fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        serialize::Encodable::encode(&self.raw, s)\n+    }\n+}\n+\n+impl<I: Idx, T: serialize::Decodable> serialize::Decodable for IndexVec<I, T> {\n+    fn decode<D: serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        serialize::Decodable::decode(d).map(|v| {\n+            IndexVec { raw: v, _marker: PhantomData }\n+        })\n+    }\n+}\n+\n+impl<I: Idx, T: fmt::Debug> fmt::Debug for IndexVec<I, T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.raw, fmt)\n+    }\n+}\n+\n+pub type Enumerated<I, J> = iter::Map<iter::Enumerate<J>, IntoIdx<I>>;\n+\n+impl<I: Idx, T> IndexVec<I, T> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        IndexVec { raw: Vec::new(), _marker: PhantomData }\n+    }\n+\n+    #[inline]\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        IndexVec { raw: Vec::with_capacity(capacity), _marker: PhantomData }\n+    }\n+\n+    #[inline]\n+    pub fn from_elem<S>(elem: T, universe: &IndexVec<I, S>) -> Self\n+        where T: Clone\n+    {\n+        IndexVec { raw: vec![elem; universe.len()], _marker: PhantomData }\n+    }\n+\n+    #[inline]\n+    pub fn push(&mut self, d: T) -> I {\n+        let idx = I::new(self.len());\n+        self.raw.push(d);\n+        idx\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.raw.len()\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.raw.is_empty()\n+    }\n+\n+    #[inline]\n+    pub fn into_iter(self) -> vec::IntoIter<T> {\n+        self.raw.into_iter()\n+    }\n+\n+    #[inline]\n+    pub fn into_iter_enumerated(self) -> Enumerated<I, vec::IntoIter<T>>\n+    {\n+        self.raw.into_iter().enumerate().map(IntoIdx { _marker: PhantomData })\n+    }\n+\n+    #[inline]\n+    pub fn iter(&self) -> slice::Iter<T> {\n+        self.raw.iter()\n+    }\n+\n+    #[inline]\n+    pub fn iter_enumerated(&self) -> Enumerated<I, slice::Iter<T>>\n+    {\n+        self.raw.iter().enumerate().map(IntoIdx { _marker: PhantomData })\n+    }\n+\n+    #[inline]\n+    pub fn indices(&self) -> iter::Map<Range<usize>, IntoIdx<I>> {\n+        (0..self.len()).map(IntoIdx { _marker: PhantomData })\n+    }\n+\n+    #[inline]\n+    pub fn iter_mut(&mut self) -> slice::IterMut<T> {\n+        self.raw.iter_mut()\n+    }\n+\n+    #[inline]\n+    pub fn iter_enumerated_mut(&mut self) -> Enumerated<I, slice::IterMut<T>>\n+    {\n+        self.raw.iter_mut().enumerate().map(IntoIdx { _marker: PhantomData })\n+    }\n+\n+    #[inline]\n+    pub fn last(&self) -> Option<I> {\n+        self.len().checked_sub(1).map(I::new)\n+    }\n+}\n+\n+impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n+    type Output = T;\n+\n+    #[inline]\n+    fn index(&self, index: I) -> &T {\n+        &self.raw[index.index()]\n+    }\n+}\n+\n+impl<I: Idx, T> IndexMut<I> for IndexVec<I, T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: I) -> &mut T {\n+        &mut self.raw[index.index()]\n+    }\n+}\n+\n+impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n+    #[inline]\n+    fn extend<J: IntoIterator<Item = T>>(&mut self, iter: J) {\n+        self.raw.extend(iter);\n+    }\n+}\n+\n+impl<I: Idx, T> FromIterator<T> for IndexVec<I, T> {\n+    #[inline]\n+    fn from_iter<J>(iter: J) -> Self where J: IntoIterator<Item=T> {\n+        IndexVec { raw: FromIterator::from_iter(iter), _marker: PhantomData }\n+    }\n+}\n+\n+impl<I: Idx, T> IntoIterator for IndexVec<I, T> {\n+    type Item = T;\n+    type IntoIter = vec::IntoIter<T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> vec::IntoIter<T> {\n+        self.raw.into_iter()\n+    }\n+\n+}\n+\n+impl<'a, I: Idx, T> IntoIterator for &'a IndexVec<I, T> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> slice::Iter<'a, T> {\n+        self.raw.iter()\n+    }\n+}\n+\n+impl<'a, I: Idx, T> IntoIterator for &'a mut IndexVec<I, T> {\n+    type Item = &'a mut T;\n+    type IntoIter = slice::IterMut<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(mut self) -> slice::IterMut<'a, T> {\n+        self.raw.iter_mut()\n+    }\n+}\n+\n+pub struct IntoIdx<I: Idx> { _marker: PhantomData<fn(&I)> }\n+impl<I: Idx, T> FnOnce<((usize, T),)> for IntoIdx<I> {\n+    type Output = (I, T);\n+\n+    extern \"rust-call\" fn call_once(self, ((n, t),): ((usize, T),)) -> Self::Output {\n+        (I::new(n), t)\n+    }\n+}\n+\n+impl<I: Idx, T> FnMut<((usize, T),)> for IntoIdx<I> {\n+    extern \"rust-call\" fn call_mut(&mut self, ((n, t),): ((usize, T),)) -> Self::Output {\n+        (I::new(n), t)\n+    }\n+}\n+\n+impl<I: Idx> FnOnce<(usize,)> for IntoIdx<I> {\n+    type Output = I;\n+\n+    extern \"rust-call\" fn call_once(self, (n,): (usize,)) -> Self::Output {\n+        I::new(n)\n+    }\n+}\n+\n+impl<I: Idx> FnMut<(usize,)> for IntoIdx<I> {\n+    extern \"rust-call\" fn call_mut(&mut self, (n,): (usize,)) -> Self::Output {\n+        I::new(n)\n+    }\n+}"}, {"sha": "9370ad016ef1ed604af5d4da75ed2452675df02c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -41,6 +41,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod bitvec;\n pub mod graph;\n pub mod ivar;\n+pub mod indexed_vec;\n pub mod obligation_forest;\n pub mod snapshot_map;\n pub mod snapshot_vec;"}, {"sha": "06d8a6c9ac86135cec0aca16c89ea2e4576d9138", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -970,11 +970,13 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         time(time_passes, \"MIR passes\", || {\n             let mut passes = sess.mir_passes.borrow_mut();\n             // Push all the built-in passes.\n-            passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+            passes.push_hook(box mir::transform::dump_mir::DumpMir);\n+            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"initial\"));\n             passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n-            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n-            passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+            passes.push_pass(\n+                box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n+            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"qualify-consts\"));\n             // And run everything.\n             passes.run_passes(tcx, &mut mir_map);\n         });\n@@ -1040,15 +1042,20 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // to LLVM code.\n     time(time_passes, \"Prepare MIR codegen passes\", || {\n         let mut passes = ::rustc::mir::transform::Passes::new();\n+        passes.push_hook(box mir::transform::dump_mir::DumpMir);\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"no-landing-pads\"));\n+\n         passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n+\n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box borrowck::ElaborateDrops);\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n+        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"elaborate-drops\"));\n+\n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n-        passes.push_pass(box mir::transform::dump_mir::DumpMir(\"pre_trans\"));\n+        passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));\n+\n         passes.run_passes(tcx, &mut mir_map);\n     });\n "}, {"sha": "83f8c3b42c850a1eb52d28f78daed875f71a0749", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -18,17 +18,15 @@ use rustc::mir::repr::*;\n \n impl<'tcx> CFG<'tcx> {\n     pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.basic_blocks[blk.index()]\n+        &self.basic_blocks[blk]\n     }\n \n     pub fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks[blk.index()]\n+        &mut self.basic_blocks[blk]\n     }\n \n     pub fn start_new_block(&mut self) -> BasicBlock {\n-        let node_index = self.basic_blocks.len();\n-        self.basic_blocks.push(BasicBlockData::new(None));\n-        BasicBlock::new(node_index)\n+        self.basic_blocks.push(BasicBlockData::new(None))\n     }\n \n     pub fn start_new_cleanup_block(&mut self) -> BasicBlock {\n@@ -80,8 +78,11 @@ impl<'tcx> CFG<'tcx> {\n                      block: BasicBlock,\n                      source_info: SourceInfo,\n                      kind: TerminatorKind<'tcx>) {\n+        debug!(\"terminating block {:?} <- {:?}\", block, kind);\n         debug_assert!(self.block_data(block).terminator.is_none(),\n-                      \"terminate: block {:?} already has a terminator set\", block);\n+                      \"terminate: block {:?}={:?} already has a terminator set\",\n+                      block,\n+                      self.block_data(block));\n         self.block_data_mut(block).terminator = Some(Terminator {\n             source_info: source_info,\n             kind: kind,"}, {"sha": "dd6c9c02f56446e802a792f5490ba0cc1faf504b", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -15,6 +15,8 @@ use build::expr::category::Category;\n use hair::*;\n use rustc::mir::repr::*;\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding an lvalue that we can move from etc.\n     pub fn as_lvalue<M>(&mut self,\n@@ -75,7 +77,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 success.and(slice.index(idx))\n             }\n             ExprKind::SelfRef => {\n-                block.and(Lvalue::Arg(0))\n+                block.and(Lvalue::Arg(Arg::new(0)))\n             }\n             ExprKind::VarRef { id } => {\n                 let index = this.var_indices[&id];"}, {"sha": "c0c27ac5943aadc5d8b9e5bff696052600584ceb", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -14,6 +14,7 @@ use std;\n \n use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};"}, {"sha": "b3315ab7d290f2b5183c19ac56fbd3445e1d6550", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -78,12 +78,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // branch to the appropriate arm block\n         let otherwise = self.match_candidates(span, &mut arm_blocks, candidates, block);\n \n-        // because all matches are exhaustive, in principle we expect\n-        // an empty vector to be returned here, but the algorithm is\n-        // not entirely precise\n         if !otherwise.is_empty() {\n-            let join_block = self.join_otherwise_blocks(span, otherwise);\n-            self.panic(join_block, \"something about matches algorithm not being precise\", span);\n+            // All matches are exhaustive. However, because some matches\n+            // only have exponentially-large exhaustive decision trees, we\n+            // sometimes generate an inexhaustive decision tree.\n+            //\n+            // In that case, the inexhaustive tips of the decision tree\n+            // can't be reached - terminate them with an `unreachable`.\n+            let source_info = self.source_info(span);\n+\n+            let mut otherwise = otherwise;\n+            otherwise.sort();\n+            otherwise.dedup(); // variant switches can introduce duplicate target blocks\n+            for block in otherwise {\n+                self.cfg.terminate(block, source_info, TerminatorKind::Unreachable);\n+            }\n         }\n \n         // all the arm blocks will rejoin here\n@@ -667,25 +676,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        name: Name,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>)\n-                       -> u32\n+                       -> Var\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, source_info={:?})\",\n                var_id, name, var_ty, source_info);\n \n-        let index = self.var_decls.len();\n-        self.var_decls.push(VarDecl::<'tcx> {\n+        let var = self.var_decls.push(VarDecl::<'tcx> {\n             source_info: source_info,\n             mutability: mutability,\n             name: name,\n             ty: var_ty.clone(),\n         });\n-        let index = index as u32;\n         let extent = self.extent_of_innermost_scope();\n-        self.schedule_drop(source_info.span, extent, &Lvalue::Var(index), var_ty);\n-        self.var_indices.insert(var_id, index);\n+        self.schedule_drop(source_info.span, extent, &Lvalue::Var(var), var_ty);\n+        self.var_indices.insert(var_id, var);\n \n-        debug!(\"declare_binding: index={:?}\", index);\n+        debug!(\"declare_binding: var={:?}\", var);\n \n-        index\n+        var\n     }\n }"}, {"sha": "0d7a502834881e6988ce2621bf0e8b62337d2fbc", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -18,7 +18,6 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n \n use rustc::mir::repr::*;\n-use std::u32;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -29,12 +28,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// NB: **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n     pub fn temp(&mut self, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n-        let index = self.temp_decls.len();\n-        self.temp_decls.push(TempDecl { ty: ty });\n-        assert!(index < (u32::MAX) as usize);\n-        let lvalue = Lvalue::Temp(index as u32);\n+        let temp = self.temp_decls.push(TempDecl { ty: ty });\n+        let lvalue = Lvalue::Temp(temp);\n         debug!(\"temp: created temp {:?} with type {:?}\",\n-               lvalue, self.temp_decls.last().unwrap().ty);\n+               lvalue, self.temp_decls[temp].ty);\n         lvalue\n     }\n "}, {"sha": "2626a02281f7dc3a3d55d28b5eb92eb713b6ece9", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 37, "deletions": 54, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -12,15 +12,17 @@ use hair::cx::Cx;\n use rustc::middle::region::{CodeExtent, CodeExtentData, ROOT_CODE_EXTENT};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n-use std::ops::{Index, IndexMut};\n-use std::u32;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n \n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+\n+use std::u32;\n+\n pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     hir: Cx<'a, 'gcx, 'tcx>,\n     cfg: CFG<'tcx>,\n@@ -36,20 +38,20 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ///  but these are liable to get out of date once optimization\n     ///  begins. They are also hopefully temporary, and will be\n     ///  no longer needed when we adopt graph-based regions.\n-    scope_auxiliary: ScopeAuxiliaryVec,\n+    scope_auxiliary: IndexVec<ScopeId, ScopeAuxiliary>,\n \n     /// the current set of loops; see the `scope` module for more\n     /// details\n     loop_scopes: Vec<scope::LoopScope>,\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later\n-    visibility_scopes: Vec<VisibilityScopeData>,\n+    visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n     visibility_scope: VisibilityScope,\n \n-    var_decls: Vec<VarDecl<'tcx>>,\n-    var_indices: FnvHashMap<ast::NodeId, u32>,\n-    temp_decls: Vec<TempDecl<'tcx>>,\n+    var_decls: IndexVec<Var, VarDecl<'tcx>>,\n+    var_indices: NodeMap<Var>,\n+    temp_decls: IndexVec<Temp, TempDecl<'tcx>>,\n     unit_temp: Option<Lvalue<'tcx>>,\n \n     /// cached block with the RESUME terminator; this is created\n@@ -60,19 +62,19 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n struct CFG<'tcx> {\n-    basic_blocks: Vec<BasicBlockData<'tcx>>,\n+    basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct ScopeId(u32);\n \n-impl ScopeId {\n-    pub fn new(index: usize) -> ScopeId {\n+impl Idx for ScopeId {\n+    fn new(index: usize) -> ScopeId {\n         assert!(index < (u32::MAX as usize));\n         ScopeId(index as u32)\n     }\n \n-    pub fn index(self) -> usize {\n+    fn index(self) -> usize {\n         self.0 as usize\n     }\n }\n@@ -109,25 +111,7 @@ pub struct Location {\n     pub statement_index: usize,\n }\n \n-pub struct ScopeAuxiliaryVec {\n-    pub vec: Vec<ScopeAuxiliary>\n-}\n-\n-impl Index<ScopeId> for ScopeAuxiliaryVec {\n-    type Output = ScopeAuxiliary;\n-\n-    #[inline]\n-    fn index(&self, index: ScopeId) -> &ScopeAuxiliary {\n-        &self.vec[index.index()]\n-    }\n-}\n-\n-impl IndexMut<ScopeId> for ScopeAuxiliaryVec {\n-    #[inline]\n-    fn index_mut(&mut self, index: ScopeId) -> &mut ScopeAuxiliary {\n-        &mut self.vec[index.index()]\n-    }\n-}\n+pub type ScopeAuxiliaryVec = IndexVec<ScopeId, ScopeAuxiliary>;\n \n ///////////////////////////////////////////////////////////////////////////\n /// The `BlockAnd` \"monad\" packages up the new basic block along with a\n@@ -213,8 +197,8 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     match tcx.node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n             // RustCall pseudo-ABI untuples the last argument.\n-            if let Some(arg_decl) = arg_decls.last_mut() {\n-                arg_decl.spread = true;\n+            if let Some(last_arg) = arg_decls.last() {\n+                arg_decls[last_arg].spread = true;\n             }\n         }\n         _ => {}\n@@ -271,23 +255,23 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     });\n \n     let ty = tcx.expr_ty_adjusted(ast_expr);\n-    builder.finish(vec![], vec![], ty::FnConverging(ty))\n+    builder.finish(vec![], IndexVec::new(), ty::FnConverging(ty))\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>, span: Span) -> Builder<'a, 'gcx, 'tcx> {\n         let mut builder = Builder {\n             hir: hir,\n-            cfg: CFG { basic_blocks: vec![] },\n+            cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n             scopes: vec![],\n-            visibility_scopes: vec![],\n+            visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n-            scope_auxiliary: ScopeAuxiliaryVec { vec: vec![] },\n+            scope_auxiliary: IndexVec::new(),\n             loop_scopes: vec![],\n-            temp_decls: vec![],\n-            var_decls: vec![],\n-            var_indices: FnvHashMap(),\n+            temp_decls: IndexVec::new(),\n+            var_decls: IndexVec::new(),\n+            var_indices: NodeMap(),\n             unit_temp: None,\n             cached_resume_block: None,\n             cached_return_block: None\n@@ -302,7 +286,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn finish(self,\n               upvar_decls: Vec<UpvarDecl>,\n-              arg_decls: Vec<ArgDecl<'tcx>>,\n+              arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n               return_ty: ty::FnOutput<'tcx>)\n               -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n@@ -311,17 +295,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        (Mir {\n-            basic_blocks: self.cfg.basic_blocks,\n-            visibility_scopes: self.visibility_scopes,\n-            promoted: vec![],\n-            var_decls: self.var_decls,\n-            arg_decls: arg_decls,\n-            temp_decls: self.temp_decls,\n-            upvar_decls: upvar_decls,\n-            return_ty: return_ty,\n-            span: self.fn_span\n-        }, self.scope_auxiliary)\n+        (Mir::new(self.cfg.basic_blocks,\n+                  self.visibility_scopes,\n+                  IndexVec::new(),\n+                  return_ty,\n+                  self.var_decls,\n+                  arg_decls,\n+                  self.temp_decls,\n+                  upvar_decls,\n+                  self.fn_span\n+        ), self.scope_auxiliary)\n     }\n \n     fn args_and_body<A>(&mut self,\n@@ -330,13 +313,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         arguments: A,\n                         argument_extent: CodeExtent,\n                         ast_block: &'gcx hir::Block)\n-                        -> BlockAnd<Vec<ArgDecl<'tcx>>>\n+                        -> BlockAnd<IndexVec<Arg, ArgDecl<'tcx>>>\n         where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n     {\n         // to start, translate the argument patterns and collect the argument types.\n         let mut scope = None;\n         let arg_decls = arguments.enumerate().map(|(index, (ty, pattern))| {\n-            let lvalue = Lvalue::Arg(index as u32);\n+            let lvalue = Lvalue::Arg(Arg::new(index));\n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.irrefutable_pat(pattern);\n                 scope = self.declare_bindings(scope, ast_block.span, &pattern);"}, {"sha": "9cc6b60eec0055d0cf16c06c4ff83c252ba0f18a", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 5, "deletions": 84, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -90,12 +90,10 @@ use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary, ScopeId};\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n use rustc::ty::subst::{Substs, Subst, VecPerParamSpace};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n-use syntax::codemap::{Span, DUMMY_SP};\n-use syntax::parse::token::intern_and_get_ident;\n-use rustc::middle::const_val::ConstVal;\n-use rustc_const_math::ConstInt;\n+use syntax::codemap::Span;\n+use rustc_data_structures::indexed_vec::Idx;\n \n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n@@ -264,7 +262,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// wrapper maybe preferable.\n     pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) {\n         debug!(\"push_scope({:?})\", extent);\n-        let id = ScopeId::new(self.scope_auxiliary.vec.len());\n+        let id = ScopeId::new(self.scope_auxiliary.len());\n         let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n             id: id,\n@@ -274,7 +272,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             free: None,\n             cached_block: None,\n         });\n-        self.scope_auxiliary.vec.push(ScopeAuxiliary {\n+        self.scope_auxiliary.push(ScopeAuxiliary {\n             extent: extent,\n             dom: self.cfg.current_location(entry),\n             postdoms: vec![]\n@@ -555,50 +553,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         next_target.unit()\n     }\n \n-    /// Create diverge cleanup and branch to it from `block`.\n-    // FIXME: Remove this (used only for unreachable cases in match).\n-    pub fn panic(&mut self, block: BasicBlock, msg: &'static str, span: Span) {\n-        // fn(&(msg: &'static str filename: &'static str, line: u32)) -> !\n-        let region = ty::ReStatic; // FIXME(mir-borrowck): use a better region?\n-        let func = self.lang_function(lang_items::PanicFnLangItem);\n-        let args = self.hir.tcx().replace_late_bound_regions(&func.ty.fn_args(), |_| region).0;\n-\n-        let ref_ty = args[0];\n-        let tup_ty = if let ty::TyRef(_, tyandmut) = ref_ty.sty {\n-            tyandmut.ty\n-        } else {\n-            span_bug!(span, \"unexpected panic type: {:?}\", func.ty);\n-        };\n-\n-        let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n-        let (file, line) = self.span_to_fileline_args(span);\n-        let message = Constant {\n-            span: span,\n-            ty: self.hir.tcx().mk_static_str(),\n-            literal: self.hir.str_literal(intern_and_get_ident(msg))\n-        };\n-        let elems = vec![Operand::Constant(message),\n-                         Operand::Constant(file),\n-                         Operand::Constant(line)];\n-        let source_info = self.source_info(span);\n-        // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n-        // icache with cold branch code), however to achieve that we either have to rely on rvalue\n-        // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, source_info, &tuple, // [1]\n-                             Rvalue::Aggregate(AggregateKind::Tuple, elems));\n-        // [1] tuple = (message_arg, file_arg, line_arg);\n-        // FIXME: is this region really correct here?\n-        self.cfg.push_assign(block, source_info, &tuple_ref, // tuple_ref = &tuple;\n-                             Rvalue::Ref(region, BorrowKind::Shared, tuple));\n-        let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, source_info, TerminatorKind::Call {\n-            func: Operand::Constant(func),\n-            args: vec![Operand::Consume(tuple_ref)],\n-            cleanup: cleanup,\n-            destination: None,\n-        });\n-    }\n-\n     /// Create an Assert terminator and return the success block.\n     /// If the boolean condition operand is not the expected value,\n     /// a runtime panic will be caused with the given message.\n@@ -624,39 +578,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         success_block\n     }\n-\n-    fn lang_function(&mut self, lang_item: lang_items::LangItem) -> Constant<'tcx> {\n-        let funcdid = match self.hir.tcx().lang_items.require(lang_item) {\n-            Ok(d) => d,\n-            Err(m) => {\n-                self.hir.tcx().sess.fatal(&m)\n-            }\n-        };\n-        Constant {\n-            span: DUMMY_SP,\n-            ty: self.hir.tcx().lookup_item_type(funcdid).ty,\n-            literal: Literal::Item {\n-                def_id: funcdid,\n-                substs: self.hir.tcx().mk_substs(Substs::empty())\n-            }\n-        }\n-    }\n-\n-    fn span_to_fileline_args(&mut self, span: Span) -> (Constant<'tcx>, Constant<'tcx>) {\n-        let span_lines = self.hir.tcx().sess.codemap().lookup_char_pos(span.lo);\n-        (Constant {\n-            span: span,\n-            ty: self.hir.tcx().mk_static_str(),\n-            literal: self.hir.str_literal(intern_and_get_ident(&span_lines.file.name))\n-        }, Constant {\n-            span: span,\n-            ty: self.hir.tcx().types.u32,\n-            literal: Literal::Value {\n-                value: ConstVal::Integral(ConstInt::U32(span_lines.line as u32)),\n-            },\n-        })\n-    }\n-\n }\n \n /// Builds drops for pop_scope and exit_scope."}, {"sha": "fdfa872b0b698805f140863294837893e86a70e7", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -15,6 +15,8 @@ use std::fmt::Debug;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n /// Write a graphviz DOT graph of a list of MIRs.\n pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                               iter: I, w: &mut W)\n@@ -32,12 +34,12 @@ where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n         write_graph_label(tcx, nodeid, mir, w)?;\n \n         // Nodes\n-        for block in mir.all_basic_blocks() {\n+        for (block, _) in mir.basic_blocks().iter_enumerated() {\n             write_node(block, mir, w)?;\n         }\n \n         // Edges\n-        for source in mir.all_basic_blocks() {\n+        for (source, _) in mir.basic_blocks().iter_enumerated() {\n             write_edges(source, mir, w)?;\n         }\n         writeln!(w, \"}}\")?\n@@ -61,7 +63,7 @@ pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n     where INIT: Fn(&mut W) -> io::Result<()>,\n           FINI: Fn(&mut W) -> io::Result<()>\n {\n-    let data = mir.basic_block_data(block);\n+    let data = &mir[block];\n \n     write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#)?;\n \n@@ -105,7 +107,7 @@ fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<(\n \n /// Write graphviz DOT edges with labels between the given basic block and all of its successors.\n fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n-    let terminator = &mir.basic_block_data(source).terminator();\n+    let terminator = mir[source].terminator();\n     let labels = terminator.kind.fmt_successor_labels();\n \n     for (&target, label) in terminator.successors().iter().zip(labels) {\n@@ -130,7 +132,7 @@ fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if i > 0 {\n             write!(w, \", \")?;\n         }\n-        write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), escape(&arg.ty))?;\n+        write!(w, \"{:?}: {}\", Lvalue::Arg(Arg::new(i)), escape(&arg.ty))?;\n     }\n \n     write!(w, \") -&gt; \")?;\n@@ -150,13 +152,13 @@ fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             write!(w, \"mut \")?;\n         }\n         write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n-               Lvalue::Var(i as u32), escape(&var.ty), var.name)?;\n+               Lvalue::Var(Var::new(i)), escape(&var.ty), var.name)?;\n     }\n \n     // Compiler-introduced temporary types.\n     for (i, temp) in mir.temp_decls.iter().enumerate() {\n         write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n-               Lvalue::Temp(i as u32), escape(&temp.ty))?;\n+               Lvalue::Temp(Temp::new(i)), escape(&temp.ty))?;\n     }\n \n     writeln!(w, \">;\")"}, {"sha": "cebdaad13db48c2bed1df5d7171c4a5152aa1e98", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -10,6 +10,7 @@\n \n use hair::*;\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_math::ConstInt;\n use hair::cx::Cx;\n use hair::cx::block;"}, {"sha": "81b098281d6a19c578b84fac946526e7685c55b6", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -21,6 +21,7 @@ use rustc::mir::transform::MirSource;\n \n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;"}, {"sha": "d527936c8993f70edb49bf7941a512e8464be734", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -11,6 +11,7 @@\n use hair::*;\n use hair::cx::Cx;\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};"}, {"sha": "856d6cda5af0f2cbc3addf020c1a41ff0f846e35", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -14,6 +14,7 @@ use rustc::mir::repr::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::indexed_vec::{Idx};\n use std::fmt::Display;\n use std::fs;\n use std::io::{self, Write};\n@@ -111,9 +112,7 @@ fn scope_entry_exit_annotations(auxiliary: Option<&ScopeAuxiliaryVec>)\n     // compute scope/entry exit annotations\n     let mut annotations = FnvHashMap();\n     if let Some(auxiliary) = auxiliary {\n-        for (index, auxiliary) in auxiliary.vec.iter().enumerate() {\n-            let scope_id = ScopeId::new(index);\n-\n+        for (scope_id, auxiliary) in auxiliary.iter_enumerated() {\n             annotations.entry(auxiliary.dom)\n                        .or_insert(vec![])\n                        .push(Annotation::EnterScope(scope_id));\n@@ -136,9 +135,9 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               -> io::Result<()> {\n     let annotations = scope_entry_exit_annotations(auxiliary);\n     write_mir_intro(tcx, src, mir, w)?;\n-    for block in mir.all_basic_blocks() {\n+    for block in mir.basic_blocks().indices() {\n         write_basic_block(tcx, block, mir, w, &annotations)?;\n-        if block.index() + 1 != mir.basic_blocks.len() {\n+        if block.index() + 1 != mir.basic_blocks().len() {\n             writeln!(w, \"\")?;\n         }\n     }\n@@ -154,7 +153,7 @@ fn write_basic_block(tcx: TyCtxt,\n                      w: &mut Write,\n                      annotations: &FnvHashMap<Location, Vec<Annotation>>)\n                      -> io::Result<()> {\n-    let data = mir.basic_block_data(block);\n+    let data = &mir[block];\n \n     // Basic block label at the top.\n     writeln!(w, \"{}{:?}: {{\", INDENT, block)?;\n@@ -218,7 +217,7 @@ fn write_scope_tree(tcx: TyCtxt,\n         writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n \n         // User variable types (including the user's name in a comment).\n-        for (i, var) in mir.var_decls.iter().enumerate() {\n+        for (id, var) in mir.var_decls.iter_enumerated() {\n             // Skip if not declared in this scope.\n             if var.source_info.scope != child {\n                 continue;\n@@ -235,7 +234,7 @@ fn write_scope_tree(tcx: TyCtxt,\n                                        INDENT,\n                                        indent,\n                                        mut_str,\n-                                       Lvalue::Var(i as u32),\n+                                       id,\n                                        var.ty);\n             writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n                      indented_var,\n@@ -297,11 +296,11 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n         write!(w, \"(\")?;\n \n         // fn argument types.\n-        for (i, arg) in mir.arg_decls.iter().enumerate() {\n-            if i > 0 {\n+        for (i, arg) in mir.arg_decls.iter_enumerated() {\n+            if i.index() != 0 {\n                 write!(w, \", \")?;\n             }\n-            write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), arg.ty)?;\n+            write!(w, \"{:?}: {}\", Lvalue::Arg(i), arg.ty)?;\n         }\n \n         write!(w, \") -> \")?;\n@@ -319,8 +318,8 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n \n fn write_mir_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n     // Compiler-introduced temporary types.\n-    for (i, temp) in mir.temp_decls.iter().enumerate() {\n-        writeln!(w, \"{}let mut {:?}: {};\", INDENT, Lvalue::Temp(i as u32), temp.ty)?;\n+    for (id, temp) in mir.temp_decls.iter_enumerated() {\n+        writeln!(w, \"{}let mut {:?}: {};\", INDENT, id, temp.ty)?;\n     }\n \n     // Wrote any declaration? Add an empty line before the first block is printed."}, {"sha": "63e975128c79240e2de29f889df5ebee7e9f7986", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -11,7 +11,8 @@\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n-use rustc::mir::traversal;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n use pretty;\n \n pub struct AddCallGuards;\n@@ -38,38 +39,27 @@ pub struct AddCallGuards;\n \n impl<'tcx> MirPass<'tcx> for AddCallGuards {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n-        let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n-\n-        // Build the precedecessor map for the MIR\n-        for (_, data) in traversal::preorder(mir) {\n-            if let Some(ref term) = data.terminator {\n-                for &tgt in term.successors().iter() {\n-                    pred_count[tgt.index()] += 1;\n-                }\n-            }\n-        }\n+        let pred_count: IndexVec<_, _> =\n+            mir.predecessors().iter().map(|ps| ps.len()).collect();\n \n         // We need a place to store the new blocks generated\n         let mut new_blocks = Vec::new();\n \n-        let bbs = mir.all_basic_blocks();\n-        let cur_len = mir.basic_blocks.len();\n-\n-        for &bb in &bbs {\n-            let data = mir.basic_block_data_mut(bb);\n+        let cur_len = mir.basic_blocks().len();\n \n-            match data.terminator {\n+        for block in mir.basic_blocks_mut() {\n+            match block.terminator {\n                 Some(Terminator {\n                     kind: TerminatorKind::Call {\n                         destination: Some((_, ref mut destination)),\n                         cleanup: Some(_),\n                         ..\n                     }, source_info\n-                }) if pred_count[destination.index()] > 1 => {\n+                }) if pred_count[*destination] > 1 => {\n                     // It's a critical edge, break it\n                     let call_guard = BasicBlockData {\n                         statements: vec![],\n-                        is_cleanup: data.is_cleanup,\n+                        is_cleanup: block.is_cleanup,\n                         terminator: Some(Terminator {\n                             source_info: source_info,\n                             kind: TerminatorKind::Goto { target: *destination }\n@@ -88,7 +78,7 @@ impl<'tcx> MirPass<'tcx> for AddCallGuards {\n         pretty::dump_mir(tcx, \"break_cleanup_edges\", &0, src, mir, None);\n         debug!(\"Broke {} N edges\", new_blocks.len());\n \n-        mir.basic_blocks.extend_from_slice(&new_blocks);\n+        mir.basic_blocks_mut().extend(new_blocks);\n     }\n }\n "}, {"sha": "642adeee5cd63632b0fccd965d8e25293ea7be0c", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -10,18 +10,64 @@\n \n //! This pass just dumps MIR at a specified point.\n \n+use std::fmt;\n+\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n-use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use rustc::mir::transform::{Pass, MirPass, MirPassHook, MirSource};\n use pretty;\n \n-pub struct DumpMir<'a>(pub &'a str);\n+pub struct Marker<'a>(pub &'a str);\n+\n+impl<'b, 'tcx> MirPass<'tcx> for Marker<'b> {\n+    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _src: MirSource, _mir: &mut Mir<'tcx>)\n+    {}\n+}\n+\n+impl<'b> Pass for Marker<'b> {\n+    fn name(&self) -> &str { self.0 }\n+}\n+\n+pub struct Disambiguator<'a> {\n+    pass: &'a Pass,\n+    is_after: bool\n+}\n+\n+impl<'a> fmt::Display for Disambiguator<'a> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        let title = if self.is_after { \"after\" } else { \"before\" };\n+        if let Some(fmt) = self.pass.disambiguator() {\n+            write!(formatter, \"{}-{}\", fmt, title)\n+        } else {\n+            write!(formatter, \"{}\", title)\n+        }\n+    }\n+}\n+\n+pub struct DumpMir;\n \n-impl<'b, 'tcx> MirPass<'tcx> for DumpMir<'b> {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>) {\n-        pretty::dump_mir(tcx, self.0, &0, src, mir, None);\n+impl<'tcx> MirPassHook<'tcx> for DumpMir {\n+    fn on_mir_pass<'a>(\n+        &mut self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        src: MirSource,\n+        mir: &Mir<'tcx>,\n+        pass: &Pass,\n+        is_after: bool)\n+    {\n+        pretty::dump_mir(\n+            tcx,\n+            pass.name(),\n+            &Disambiguator {\n+                pass: pass,\n+                is_after: is_after\n+            },\n+            src,\n+            mir,\n+            None\n+        );\n     }\n }\n \n-impl<'b> Pass for DumpMir<'b> {}\n+impl<'b> Pass for DumpMir {}"}, {"sha": "7b707b4adb69ac2aa2a7499a505948c5bb41565e", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub mod remove_dead_blocks;\n+pub mod simplify_branches;\n pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;"}, {"sha": "818f060ed445ccff0404d04554de1508991a515b", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -24,6 +24,7 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n             TerminatorKind::Goto { .. } |\n             TerminatorKind::Resume |\n             TerminatorKind::Return |\n+            TerminatorKind::Unreachable |\n             TerminatorKind::If { .. } |\n             TerminatorKind::Switch { .. } |\n             TerminatorKind::SwitchInt { .. } => {"}, {"sha": "3ebfef10d43113444b0fc16d284ea20eb28a49e1", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -30,6 +30,8 @@ use syntax::codemap::Span;\n \n use build::Location;\n \n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+\n use std::mem;\n \n /// State of a temporary during collection and promotion.\n@@ -74,7 +76,7 @@ pub enum Candidate {\n }\n \n struct TempCollector {\n-    temps: Vec<TempState>,\n+    temps: IndexVec<Temp, TempState>,\n     location: Location,\n     span: Span\n }\n@@ -89,7 +91,7 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n                 return;\n             }\n \n-            let temp = &mut self.temps[index as usize];\n+            let temp = &mut self.temps[index];\n             if *temp == TempState::Undefined {\n                 match context {\n                     LvalueContext::Store |\n@@ -134,9 +136,9 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n     }\n }\n \n-pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> Vec<TempState> {\n+pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> IndexVec<Temp, TempState> {\n     let mut collector = TempCollector {\n-        temps: vec![TempState::Undefined; mir.temp_decls.len()],\n+        temps: IndexVec::from_elem(TempState::Undefined, &mir.temp_decls),\n         location: Location {\n             block: START_BLOCK,\n             statement_index: 0\n@@ -152,7 +154,7 @@ pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> Vec<TempState> {\n struct Promoter<'a, 'tcx: 'a> {\n     source: &'a mut Mir<'tcx>,\n     promoted: Mir<'tcx>,\n-    temps: &'a mut Vec<TempState>,\n+    temps: &'a mut IndexVec<Temp, TempState>,\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n@@ -161,23 +163,23 @@ struct Promoter<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     fn new_block(&mut self) -> BasicBlock {\n-        let index = self.promoted.basic_blocks.len();\n-        self.promoted.basic_blocks.push(BasicBlockData {\n+        let span = self.promoted.span;\n+        self.promoted.basic_blocks_mut().push(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n                 source_info: SourceInfo {\n-                    span: self.promoted.span,\n+                    span: span,\n                     scope: ARGUMENT_VISIBILITY_SCOPE\n                 },\n                 kind: TerminatorKind::Return\n             }),\n             is_cleanup: false\n-        });\n-        BasicBlock::new(index)\n+        })\n     }\n \n     fn assign(&mut self, dest: Lvalue<'tcx>, rvalue: Rvalue<'tcx>, span: Span) {\n-        let data = self.promoted.basic_blocks.last_mut().unwrap();\n+        let last = self.promoted.basic_blocks().last().unwrap();\n+        let data = &mut self.promoted[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo {\n                 span: span,\n@@ -189,10 +191,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n     /// Copy the initialization of this temp to the\n     /// promoted MIR, recursing through temps.\n-    fn promote_temp(&mut self, index: u32) -> u32 {\n-        let index = index as usize;\n+    fn promote_temp(&mut self, temp: Temp) -> Temp {\n         let old_keep_original = self.keep_original;\n-        let (bb, stmt_idx) = match self.temps[index] {\n+        let (bb, stmt_idx) = match self.temps[temp] {\n             TempState::Defined {\n                 location: Location { block, statement_index },\n                 uses\n@@ -202,13 +203,13 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 }\n                 (block, statement_index)\n             }\n-            temp =>  {\n-                span_bug!(self.promoted.span, \"tmp{} not promotable: {:?}\",\n-                          index, temp);\n+            state =>  {\n+                span_bug!(self.promoted.span, \"{:?} not promotable: {:?}\",\n+                          temp, state);\n             }\n         };\n         if !self.keep_original {\n-            self.temps[index] = TempState::PromotedOut;\n+            self.temps[temp] = TempState::PromotedOut;\n         }\n \n         let no_stmts = self.source[bb].statements.len();\n@@ -260,34 +261,32 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             self.visit_terminator_kind(bb, call.as_mut().unwrap());\n         }\n \n-        let new_index = self.promoted.temp_decls.len() as u32;\n-        let new_temp = Lvalue::Temp(new_index);\n-        self.promoted.temp_decls.push(TempDecl {\n-            ty: self.source.temp_decls[index].ty\n+        let new_temp = self.promoted.temp_decls.push(TempDecl {\n+            ty: self.source.temp_decls[temp].ty\n         });\n \n         // Inject the Rvalue or Call into the promoted MIR.\n         if stmt_idx < no_stmts {\n-            self.assign(new_temp, rvalue.unwrap(), source_info.span);\n+            self.assign(Lvalue::Temp(new_temp), rvalue.unwrap(), source_info.span);\n         } else {\n-            let last = self.promoted.basic_blocks.len() - 1;\n+            let last = self.promoted.basic_blocks().last().unwrap();\n             let new_target = self.new_block();\n             let mut call = call.unwrap();\n             match call {\n                 TerminatorKind::Call { ref mut destination, ..}  => {\n-                    *destination = Some((new_temp, new_target));\n+                    *destination = Some((Lvalue::Temp(new_temp), new_target));\n                 }\n                 _ => bug!()\n             }\n-            let terminator = &mut self.promoted.basic_blocks[last].terminator_mut();\n+            let terminator = self.promoted[last].terminator_mut();\n             terminator.source_info.span = source_info.span;\n             terminator.kind = call;\n         }\n \n         // Restore the old duplication state.\n         self.keep_original = old_keep_original;\n \n-        new_index\n+        new_temp\n     }\n \n     fn promote_candidate(mut self, candidate: Candidate) {\n@@ -296,7 +295,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             span: span,\n             ty: self.promoted.return_ty.unwrap(),\n             literal: Literal::Promoted {\n-                index: self.source.promoted.len()\n+                index: Promoted::new(self.source.promoted.len())\n             }\n         });\n         let mut rvalue = match candidate {\n@@ -325,16 +324,16 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n /// Replaces all temporaries with their promoted counterparts.\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     fn visit_lvalue(&mut self, lvalue: &mut Lvalue<'tcx>, context: LvalueContext) {\n-        if let Lvalue::Temp(ref mut index) = *lvalue {\n-            *index = self.promote_temp(*index);\n+        if let Lvalue::Temp(ref mut temp) = *lvalue {\n+            *temp = self.promote_temp(*temp);\n         }\n         self.super_lvalue(lvalue, context);\n     }\n }\n \n pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    mut temps: Vec<TempState>,\n+                                    mut temps: IndexVec<Temp, TempState>,\n                                     candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n     for candidate in candidates.into_iter().rev() {\n@@ -343,7 +342,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 let statement = &mir[bb].statements[stmt_idx];\n                 let StatementKind::Assign(ref dest, _) = statement.kind;\n                 if let Lvalue::Temp(index) = *dest {\n-                    if temps[index as usize] == TempState::PromotedOut {\n+                    if temps[index] == TempState::PromotedOut {\n                         // Already promoted.\n                         continue;\n                     }\n@@ -367,20 +366,20 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n \n         let mut promoter = Promoter {\n             source: mir,\n-            promoted: Mir {\n-                basic_blocks: vec![],\n-                visibility_scopes: vec![VisibilityScopeData {\n+            promoted: Mir::new(\n+                IndexVec::new(),\n+                Some(VisibilityScopeData {\n                     span: span,\n                     parent_scope: None\n-                }],\n-                promoted: vec![],\n-                return_ty: ty::FnConverging(ty),\n-                var_decls: vec![],\n-                arg_decls: vec![],\n-                temp_decls: vec![],\n-                upvar_decls: vec![],\n-                span: span\n-            },\n+                }).into_iter().collect(),\n+                IndexVec::new(),\n+                ty::FnConverging(ty),\n+                IndexVec::new(),\n+                IndexVec::new(),\n+                IndexVec::new(),\n+                vec![],\n+                span\n+            ),\n             temps: &mut temps,\n             keep_original: false\n         };\n@@ -389,8 +388,8 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n     }\n \n     // Eliminate assignments to, and drops of promoted temps.\n-    let promoted = |index: u32| temps[index as usize] == TempState::PromotedOut;\n-    for block in &mut mir.basic_blocks {\n+    let promoted = |index: Temp| temps[index] == TempState::PromotedOut;\n+    for block in mir.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match statement.kind {\n                 StatementKind::Assign(Lvalue::Temp(index), _) => {"}, {"sha": "784ddc1ede4f1d4fd32c1529c68a8d8182b1ff0c", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -15,6 +15,7 @@\n //! diagnostics as to why a constant rvalue wasn't promoted.\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n@@ -24,8 +25,8 @@ use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::cast::CastTy;\n use rustc::mir::repr::*;\n use rustc::mir::mir_map::MirMap;\n-use rustc::mir::transform::{Pass, MirMapPass, MirSource};\n use rustc::mir::traversal::{self, ReversePostorder};\n+use rustc::mir::transform::{Pass, MirMapPass, MirPassHook, MirSource};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::util::nodemap::DefIdMap;\n use syntax::abi::Abi;\n@@ -141,12 +142,12 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     param_env: ty::ParameterEnvironment<'tcx>,\n     qualif_map: &'a mut DefIdMap<Qualif>,\n     mir_map: Option<&'a MirMap<'tcx>>,\n-    temp_qualif: Vec<Option<Qualif>>,\n+    temp_qualif: IndexVec<Temp, Option<Qualif>>,\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n     const_fn_arg_vars: BitVector,\n     location: Location,\n-    temp_promotion_state: Vec<TempState>,\n+    temp_promotion_state: IndexVec<Temp, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n \n@@ -172,7 +173,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             param_env: param_env,\n             qualif_map: qualif_map,\n             mir_map: mir_map,\n-            temp_qualif: vec![None; mir.temp_decls.len()],\n+            temp_qualif: IndexVec::from_elem(None, &mir.temp_decls),\n             return_qualif: None,\n             qualif: Qualif::empty(),\n             const_fn_arg_vars: BitVector::new(mir.var_decls.len()),\n@@ -301,22 +302,22 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         // Only handle promotable temps in non-const functions.\n         if self.mode == Mode::Fn {\n             if let Lvalue::Temp(index) = *dest {\n-                if self.temp_promotion_state[index as usize].is_promotable() {\n-                    store(&mut self.temp_qualif[index as usize]);\n+                if self.temp_promotion_state[index].is_promotable() {\n+                    store(&mut self.temp_qualif[index]);\n                 }\n             }\n             return;\n         }\n \n         match *dest {\n-            Lvalue::Temp(index) => store(&mut self.temp_qualif[index as usize]),\n+            Lvalue::Temp(index) => store(&mut self.temp_qualif[index]),\n             Lvalue::ReturnPointer => store(&mut self.return_qualif),\n \n             Lvalue::Projection(box Projection {\n                 base: Lvalue::Temp(index),\n                 elem: ProjectionElem::Deref\n-            }) if self.mir.temp_decls[index as usize].ty.is_unique()\n-               && self.temp_qualif[index as usize].map_or(false, |qualif| {\n+            }) if self.mir.temp_decls[index].ty.is_unique()\n+               && self.temp_qualif[index].map_or(false, |qualif| {\n                     qualif.intersects(Qualif::NOT_CONST)\n                }) => {\n                 // Part of `box expr`, we should've errored\n@@ -336,7 +337,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn qualify_const(&mut self) -> Qualif {\n         let mir = self.mir;\n \n-        let mut seen_blocks = BitVector::new(mir.basic_blocks.len());\n+        let mut seen_blocks = BitVector::new(mir.basic_blocks().len());\n         let mut bb = START_BLOCK;\n         loop {\n             seen_blocks.insert(bb.index());\n@@ -361,17 +362,18 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 TerminatorKind::Switch {..} |\n                 TerminatorKind::SwitchInt {..} |\n                 TerminatorKind::DropAndReplace { .. } |\n-                TerminatorKind::Resume => None,\n+                TerminatorKind::Resume |\n+                TerminatorKind::Unreachable => None,\n \n                 TerminatorKind::Return => {\n                     // Check for unused values. This usually means\n                     // there are extra statements in the AST.\n-                    for i in 0..mir.temp_decls.len() {\n-                        if self.temp_qualif[i].is_none() {\n+                    for temp in mir.temp_decls.indices() {\n+                        if self.temp_qualif[temp].is_none() {\n                             continue;\n                         }\n \n-                        let state = self.temp_promotion_state[i];\n+                        let state = self.temp_promotion_state[temp];\n                         if let TempState::Defined { location, uses: 0 } = state {\n                             let data = &mir[location.block];\n                             let stmt_idx = location.statement_index;\n@@ -393,7 +395,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                     self.qualif = Qualif::NOT_CONST;\n                     for index in 0..mir.var_decls.len() {\n                         if !self.const_fn_arg_vars.contains(index) {\n-                            self.assign(&Lvalue::Var(index as u32));\n+                            self.assign(&Lvalue::Var(Var::new(index)));\n                         }\n                     }\n \n@@ -448,11 +450,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 self.add(Qualif::NOT_CONST);\n             }\n             Lvalue::Temp(index) => {\n-                if !self.temp_promotion_state[index as usize].is_promotable() {\n+                if !self.temp_promotion_state[index].is_promotable() {\n                     self.add(Qualif::NOT_PROMOTABLE);\n                 }\n \n-                if let Some(qualif) = self.temp_qualif[index as usize] {\n+                if let Some(qualif) = self.temp_qualif[index] {\n                     self.add(qualif);\n                 } else {\n                     self.not_const();\n@@ -822,15 +824,15 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n         // Check the allowed const fn argument forms.\n         if let (Mode::ConstFn, &Lvalue::Var(index)) = (self.mode, dest) {\n-            if self.const_fn_arg_vars.insert(index as usize) {\n+            if self.const_fn_arg_vars.insert(index.index()) {\n                 // Direct use of an argument is permitted.\n                 if let Rvalue::Use(Operand::Consume(Lvalue::Arg(_))) = *rvalue {\n                     return;\n                 }\n \n                 // Avoid a generic error for other uses of arguments.\n                 if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n-                    let decl = &self.mir.var_decls[index as usize];\n+                    let decl = &self.mir.var_decls[index];\n                     span_err!(self.tcx.sess, decl.source_info.span, E0022,\n                               \"arguments of constant functions can only \\\n                                be immutable by-value bindings\");\n@@ -907,7 +909,10 @@ pub struct QualifyAndPromoteConstants;\n impl Pass for QualifyAndPromoteConstants {}\n \n impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n+    fn run_pass<'a>(&mut self,\n+                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    map: &mut MirMap<'tcx>,\n+                    hooks: &mut [Box<for<'s> MirPassHook<'s>>]) {\n         let mut qualif_map = DefIdMap();\n \n         // First, visit `const` items, potentially recursing, to get\n@@ -943,6 +948,10 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n             };\n             let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n \n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, mir, self, false);\n+            }\n+\n             if mode == Mode::Fn || mode == Mode::ConstFn {\n                 // This is ugly because Qualifier holds onto mir,\n                 // which can't be mutated until its scope ends.\n@@ -970,6 +979,10 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n                 qualifier.qualify_const();\n             }\n \n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, mir, self, true);\n+            }\n+\n             // Statics must be Sync.\n             if mode == Mode::Static {\n                 let ty = mir.return_ty.unwrap();"}, {"sha": "44f3ce7361cf49f18b7eb14e5d13c505f0eb97ef", "filename": "src/librustc_mir/transform/remove_dead_blocks.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0740a93cc290a5419807d2e8c6c442354baf46b0/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0740a93cc290a5419807d2e8c6c442354baf46b0/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs?ref=0740a93cc290a5419807d2e8c6c442354baf46b0", "patch": "@@ -1,86 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A pass that erases the contents of dead blocks. This pass must\n-//! run before any analysis passes because some of the dead blocks\n-//! can be ill-typed.\n-//!\n-//! The main problem is that typeck lets most blocks whose end is not\n-//! reachable have an arbitrary return type, rather than having the\n-//! usual () return type (as a note, typeck's notion of reachability\n-//! is in fact slightly weaker than MIR CFG reachability - see #31617).\n-//!\n-//! A standard example of the situation is:\n-//! ```rust\n-//!   fn example() {\n-//!       let _a: char = { return; };\n-//!   }\n-//! ```\n-//!\n-//! Here the block (`{ return; }`) has the return type `char`,\n-//! rather than `()`, but the MIR we naively generate still contains\n-//! the `_a = ()` write in the unreachable block \"after\" the return.\n-//!\n-//! As we have to run this pass even when we want to debug the MIR,\n-//! this pass just replaces the blocks with empty \"return\" blocks\n-//! and does not renumber anything.\n-\n-use rustc_data_structures::bitvec::BitVector;\n-use rustc::ty::TyCtxt;\n-use rustc::mir::repr::*;\n-use rustc::mir::transform::{Pass, MirPass, MirSource};\n-\n-pub struct RemoveDeadBlocks;\n-\n-impl<'tcx> MirPass<'tcx> for RemoveDeadBlocks {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource, mir: &mut Mir<'tcx>) {\n-        let mut seen = BitVector::new(mir.basic_blocks.len());\n-        // This block is always required.\n-        seen.insert(START_BLOCK.index());\n-\n-        let mut worklist = Vec::with_capacity(4);\n-        worklist.push(START_BLOCK);\n-        while let Some(bb) = worklist.pop() {\n-            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n-                if seen.insert(succ.index()) {\n-                    worklist.push(*succ);\n-                }\n-            }\n-        }\n-        retain_basic_blocks(mir, &seen);\n-    }\n-}\n-\n-impl Pass for RemoveDeadBlocks {}\n-\n-/// Mass removal of basic blocks to keep the ID-remapping cheap.\n-fn retain_basic_blocks(mir: &mut Mir, keep: &BitVector) {\n-    let num_blocks = mir.basic_blocks.len();\n-\n-    let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n-    let mut used_blocks = 0;\n-    for alive_index in keep.iter() {\n-        replacements[alive_index] = BasicBlock::new(used_blocks);\n-        if alive_index != used_blocks {\n-            // Swap the next alive block data with the current available slot. Since alive_index is\n-            // non-decreasing this is a valid operation.\n-            mir.basic_blocks.swap(alive_index, used_blocks);\n-        }\n-        used_blocks += 1;\n-    }\n-    mir.basic_blocks.truncate(used_blocks);\n-\n-    for bb in mir.all_basic_blocks() {\n-        for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {\n-            *target = replacements[target.index()];\n-        }\n-    }\n-}"}, {"sha": "f93de6ca382bb61298cf758a4519acde6a9e2ab7", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A pass that simplifies branches when their condition is known.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::middle::const_val::ConstVal;\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::repr::*;\n+\n+use std::fmt;\n+\n+pub struct SimplifyBranches<'a> { label: &'a str }\n+\n+impl<'a> SimplifyBranches<'a> {\n+    pub fn new(label: &'a str) -> Self {\n+        SimplifyBranches { label: label }\n+    }\n+}\n+\n+impl<'l, 'tcx> MirPass<'tcx> for SimplifyBranches<'l> {\n+    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n+        for block in mir.basic_blocks_mut() {\n+            let terminator = block.terminator_mut();\n+            terminator.kind = match terminator.kind {\n+                TerminatorKind::If { ref targets, cond: Operand::Constant(Constant {\n+                    literal: Literal::Value {\n+                        value: ConstVal::Bool(cond)\n+                    }, ..\n+                }) } => {\n+                    if cond {\n+                        TerminatorKind::Goto { target: targets.0 }\n+                    } else {\n+                        TerminatorKind::Goto { target: targets.1 }\n+                    }\n+                }\n+\n+                TerminatorKind::Assert { target, cond: Operand::Constant(Constant {\n+                    literal: Literal::Value {\n+                        value: ConstVal::Bool(cond)\n+                    }, ..\n+                }), expected, .. } if cond == expected => {\n+                    TerminatorKind::Goto { target: target }\n+                }\n+\n+                _ => continue\n+            };\n+        }\n+    }\n+}\n+\n+impl<'l> Pass for SimplifyBranches<'l> {\n+    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> {\n+        Some(Box::new(self.label))\n+    }\n+}"}, {"sha": "8bbcc3fe2d70f60ac3a2a9a50f7e18c02c993be7", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 191, "deletions": 149, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -8,197 +8,239 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! A pass that removes various redundancies in the CFG. It should be\n+//! called after every significant CFG modification to tidy things\n+//! up.\n+//!\n+//! This pass must also be run before any analysis passes because it removes\n+//! dead blocks, and some of these can be ill-typed.\n+//!\n+//! The cause of that is that typeck lets most blocks whose end is not\n+//! reachable have an arbitrary return type, rather than having the\n+//! usual () return type (as a note, typeck's notion of reachability\n+//! is in fact slightly weaker than MIR CFG reachability - see #31617).\n+//!\n+//! A standard example of the situation is:\n+//! ```rust\n+//!   fn example() {\n+//!       let _a: char = { return; };\n+//!   }\n+//! ```\n+//!\n+//! Here the block (`{ return; }`) has the return type `char`,\n+//! rather than `()`, but the MIR we naively generate still contains\n+//! the `_a = ()` write in the unreachable block \"after\" the return.\n+\n+\n use rustc_data_structures::bitvec::BitVector;\n-use rustc::middle::const_val::ConstVal;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::traversal;\n-use pretty;\n-use std::mem;\n-\n-use super::remove_dead_blocks::RemoveDeadBlocks;\n+use std::fmt;\n \n-pub struct SimplifyCfg;\n+pub struct SimplifyCfg<'a> { label: &'a str }\n \n-impl SimplifyCfg {\n-    pub fn new() -> SimplifyCfg {\n-        SimplifyCfg\n+impl<'a> SimplifyCfg<'a> {\n+    pub fn new(label: &'a str) -> Self {\n+        SimplifyCfg { label: label }\n     }\n }\n \n-impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n-        simplify_branches(mir);\n-        RemoveDeadBlocks.run_pass(tcx, src, mir);\n-        merge_consecutive_blocks(mir);\n-        RemoveDeadBlocks.run_pass(tcx, src, mir);\n-        pretty::dump_mir(tcx, \"simplify_cfg\", &0, src, mir, None);\n+impl<'l, 'tcx> MirPass<'tcx> for SimplifyCfg<'l> {\n+    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n+        CfgSimplifier::new(mir).simplify();\n+        remove_dead_blocks(mir);\n \n         // FIXME: Should probably be moved into some kind of pass manager\n-        mir.basic_blocks.shrink_to_fit();\n+        mir.basic_blocks_mut().raw.shrink_to_fit();\n     }\n }\n \n-impl Pass for SimplifyCfg {}\n+impl<'l> Pass for SimplifyCfg<'l> {\n+    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> {\n+        Some(Box::new(self.label))\n+    }\n+}\n \n-fn merge_consecutive_blocks(mir: &mut Mir) {\n-    // Build the precedecessor map for the MIR\n-    let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n-    for (_, data) in traversal::preorder(mir) {\n-        if let Some(ref term) = data.terminator {\n-            for &tgt in term.successors().iter() {\n-                pred_count[tgt.index()] += 1;\n+pub struct CfgSimplifier<'a, 'tcx: 'a> {\n+    basic_blocks: &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    pred_count: IndexVec<BasicBlock, u32>\n+}\n+\n+impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n+    fn new(mir: &'a mut Mir<'tcx>) -> Self {\n+        let mut pred_count = IndexVec::from_elem(0u32, mir.basic_blocks());\n+\n+        // we can't use mir.predecessors() here because that counts\n+        // dead blocks, which we don't want to.\n+        for (_, data) in traversal::preorder(mir) {\n+            if let Some(ref term) = data.terminator {\n+                for &tgt in term.successors().iter() {\n+                    pred_count[tgt] += 1;\n+                }\n             }\n         }\n+\n+        let basic_blocks = mir.basic_blocks_mut();\n+\n+        CfgSimplifier {\n+            basic_blocks: basic_blocks,\n+            pred_count: pred_count\n+        }\n     }\n \n-    loop {\n-        let mut changed = false;\n-        let mut seen = BitVector::new(mir.basic_blocks.len());\n-        let mut worklist = vec![START_BLOCK];\n-        while let Some(bb) = worklist.pop() {\n-            // Temporarily take ownership of the terminator we're modifying to keep borrowck happy\n-            let mut terminator = mir.basic_block_data_mut(bb).terminator.take()\n-                .expect(\"invalid terminator state\");\n-\n-            // See if we can merge the target block into this one\n-            loop {\n-                let mut inner_change = false;\n-\n-                if let TerminatorKind::Goto { target } = terminator.kind {\n-                    // Don't bother trying to merge a block into itself\n-                    if target == bb {\n-                        break;\n-                    }\n-\n-                    let num_insts = mir.basic_block_data(target).statements.len();\n-                    match mir.basic_block_data(target).terminator().kind {\n-                        TerminatorKind::Goto { target: new_target } if num_insts == 0 => {\n-                            inner_change = true;\n-                            terminator.kind = TerminatorKind::Goto { target: new_target };\n-                            pred_count[target.index()] -= 1;\n-                            pred_count[new_target.index()] += 1;\n-                        }\n-                        _ if pred_count[target.index()] == 1 => {\n-                            inner_change = true;\n-                            let mut stmts = Vec::new();\n-                            {\n-                                let target_data = mir.basic_block_data_mut(target);\n-                                mem::swap(&mut stmts, &mut target_data.statements);\n-                                mem::swap(&mut terminator, target_data.terminator_mut());\n-                            }\n-\n-                            mir.basic_block_data_mut(bb).statements.append(&mut stmts);\n-                        }\n-                        _ => {}\n-                    };\n+    fn simplify(mut self) {\n+        loop {\n+            let mut changed = false;\n+\n+            for bb in (0..self.basic_blocks.len()).map(BasicBlock::new) {\n+                if self.pred_count[bb] == 0 {\n+                    continue\n                 }\n \n-                for target in terminator.successors_mut() {\n-                    let new_target = match final_target(mir, *target) {\n-                        Some(new_target) => new_target,\n-                        None if mir.basic_block_data(bb).statements.is_empty() => bb,\n-                        None => continue\n-                    };\n-                    if *target != new_target {\n-                        inner_change = true;\n-                        pred_count[target.index()] -= 1;\n-                        pred_count[new_target.index()] += 1;\n-                        *target = new_target;\n-                    }\n+                debug!(\"simplifying {:?}\", bb);\n+\n+                let mut terminator = self.basic_blocks[bb].terminator.take()\n+                    .expect(\"invalid terminator state\");\n+\n+                for successor in terminator.successors_mut() {\n+                    self.collapse_goto_chain(successor, &mut changed);\n                 }\n \n-                changed |= inner_change;\n-                if !inner_change {\n-                    break;\n+                let mut new_stmts = vec![];\n+                let mut inner_changed = true;\n+                while inner_changed {\n+                    inner_changed = false;\n+                    inner_changed |= self.simplify_branch(&mut terminator);\n+                    inner_changed |= self.merge_successor(&mut new_stmts, &mut terminator);\n+                    changed |= inner_changed;\n                 }\n-            }\n \n-            mir.basic_block_data_mut(bb).terminator = Some(terminator);\n+                self.basic_blocks[bb].statements.extend(new_stmts);\n+                self.basic_blocks[bb].terminator = Some(terminator);\n \n-            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n-                if seen.insert(succ.index()) {\n-                    worklist.push(*succ);\n-                }\n+                changed |= inner_changed;\n             }\n-        }\n \n-        if !changed {\n-            break;\n+            if !changed { break }\n         }\n     }\n-}\n \n-// Find the target at the end of the jump chain, return None if there is a loop\n-fn final_target(mir: &Mir, mut target: BasicBlock) -> Option<BasicBlock> {\n-    // Keep track of already seen blocks to detect loops\n-    let mut seen: Vec<BasicBlock> = Vec::with_capacity(8);\n-\n-    while mir.basic_block_data(target).statements.is_empty() {\n-        // NB -- terminator may have been swapped with `None` in\n-        // merge_consecutive_blocks, in which case we have a cycle and just want\n-        // to stop\n-        match mir.basic_block_data(target).terminator {\n-            Some(Terminator { kind: TerminatorKind::Goto { target: next }, .. }) =>  {\n-                if seen.contains(&next) {\n-                    return None;\n-                }\n-                seen.push(next);\n-                target = next;\n+    // Collapse a goto chain starting from `start`\n+    fn collapse_goto_chain(&mut self, start: &mut BasicBlock, changed: &mut bool) {\n+        let mut terminator = match self.basic_blocks[*start] {\n+            BasicBlockData {\n+                ref statements,\n+                terminator: ref mut terminator @ Some(Terminator {\n+                    kind: TerminatorKind::Goto { .. }, ..\n+                }), ..\n+            } if statements.is_empty() => terminator.take(),\n+            // if `terminator` is None, this means we are in a loop. In that\n+            // case, let all the loop collapse to its entry.\n+            _ => return\n+        };\n+\n+        let target = match terminator {\n+            Some(Terminator { kind: TerminatorKind::Goto { ref mut target }, .. }) => {\n+                self.collapse_goto_chain(target, changed);\n+                *target\n             }\n-            _ => break\n-        }\n-    }\n+            _ => unreachable!()\n+        };\n+        self.basic_blocks[*start].terminator = terminator;\n \n-    Some(target)\n-}\n+        debug!(\"collapsing goto chain from {:?} to {:?}\", *start, target);\n \n-fn simplify_branches(mir: &mut Mir) {\n-    loop {\n-        let mut changed = false;\n-\n-        for bb in mir.all_basic_blocks() {\n-            let basic_block = mir.basic_block_data_mut(bb);\n-            let mut terminator = basic_block.terminator_mut();\n-            terminator.kind = match terminator.kind {\n-                TerminatorKind::If { ref targets, .. } if targets.0 == targets.1 => {\n-                    changed = true;\n-                    TerminatorKind::Goto { target: targets.0 }\n-                }\n+        *changed |= *start != target;\n+        self.pred_count[target] += 1;\n+        self.pred_count[*start] -= 1;\n+        *start = target;\n+    }\n \n-                TerminatorKind::If { ref targets, cond: Operand::Constant(Constant {\n-                    literal: Literal::Value {\n-                        value: ConstVal::Bool(cond)\n-                    }, ..\n-                }) } => {\n-                    changed = true;\n-                    if cond {\n-                        TerminatorKind::Goto { target: targets.0 }\n-                    } else {\n-                        TerminatorKind::Goto { target: targets.1 }\n-                    }\n-                }\n+    // merge a block with 1 `goto` predecessor to its parent\n+    fn merge_successor(&mut self,\n+                       new_stmts: &mut Vec<Statement<'tcx>>,\n+                       terminator: &mut Terminator<'tcx>)\n+                       -> bool\n+    {\n+        let target = match terminator.kind {\n+            TerminatorKind::Goto { target }\n+                if self.pred_count[target] == 1\n+                => target,\n+            _ => return false\n+        };\n+\n+        debug!(\"merging block {:?} into {:?}\", target, terminator);\n+        *terminator = match self.basic_blocks[target].terminator.take() {\n+            Some(terminator) => terminator,\n+            None => {\n+                // unreachable loop - this should not be possible, as we\n+                // don't strand blocks, but handle it correctly.\n+                return false\n+            }\n+        };\n+        new_stmts.extend(self.basic_blocks[target].statements.drain(..));\n+        self.pred_count[target] = 0;\n \n-                TerminatorKind::Assert { target, cond: Operand::Constant(Constant {\n-                    literal: Literal::Value {\n-                        value: ConstVal::Bool(cond)\n-                    }, ..\n-                }), expected, .. } if cond == expected => {\n-                    changed = true;\n-                    TerminatorKind::Goto { target: target }\n-                }\n+        true\n+    }\n \n-                TerminatorKind::SwitchInt { ref targets, .. } if targets.len() == 1 => {\n-                    changed = true;\n-                    TerminatorKind::Goto { target: targets[0] }\n+    // turn a branch with all successors identical to a goto\n+    fn simplify_branch(&mut self, terminator: &mut Terminator<'tcx>) -> bool {\n+        match terminator.kind {\n+            TerminatorKind::If { .. } |\n+            TerminatorKind::Switch { .. } |\n+            TerminatorKind::SwitchInt { .. } => {},\n+            _ => return false\n+        };\n+\n+        let first_succ = {\n+            let successors = terminator.successors();\n+            if let Some(&first_succ) = terminator.successors().get(0) {\n+                if successors.iter().all(|s| *s == first_succ) {\n+                    self.pred_count[first_succ] -= (successors.len()-1) as u32;\n+                    first_succ\n+                } else {\n+                    return false\n                 }\n-                _ => continue\n+            } else {\n+                return false\n             }\n+        };\n+\n+        debug!(\"simplifying branch {:?}\", terminator);\n+        terminator.kind = TerminatorKind::Goto { target: first_succ };\n+        true\n+    }\n+}\n+\n+fn remove_dead_blocks(mir: &mut Mir) {\n+    let mut seen = BitVector::new(mir.basic_blocks().len());\n+    for (bb, _) in traversal::preorder(mir) {\n+        seen.insert(bb.index());\n+    }\n+\n+    let basic_blocks = mir.basic_blocks_mut();\n+\n+    let num_blocks = basic_blocks.len();\n+    let mut replacements : Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n+    let mut used_blocks = 0;\n+    for alive_index in seen.iter() {\n+        replacements[alive_index] = BasicBlock::new(used_blocks);\n+        if alive_index != used_blocks {\n+            // Swap the next alive block data with the current available slot. Since alive_index is\n+            // non-decreasing this is a valid operation.\n+            basic_blocks.raw.swap(alive_index, used_blocks);\n         }\n+        used_blocks += 1;\n+    }\n+    basic_blocks.raw.truncate(used_blocks);\n \n-        if !changed {\n-            break;\n+    for block in basic_blocks {\n+        for target in block.terminator_mut().successors_mut() {\n+            *target = replacements[target.index()];\n         }\n     }\n }"}, {"sha": "e4398fcab316326bcaf67f0517e3ae4f6651fda5", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -24,6 +24,8 @@ use rustc::mir::visit::{self, Visitor};\n use std::fmt;\n use syntax::codemap::{Span, DUMMY_SP};\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n         $context.tcx().sess.span_warn(\n@@ -129,11 +131,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>) -> LvalueTy<'tcx> {\n         debug!(\"sanitize_lvalue: {:?}\", lvalue);\n         match *lvalue {\n-            Lvalue::Var(index) => LvalueTy::Ty { ty: self.mir.var_decls[index as usize].ty },\n-            Lvalue::Temp(index) =>\n-                LvalueTy::Ty { ty: self.mir.temp_decls[index as usize].ty },\n-            Lvalue::Arg(index) =>\n-                LvalueTy::Ty { ty: self.mir.arg_decls[index as usize].ty },\n+            Lvalue::Var(index) => LvalueTy::Ty { ty: self.mir.var_decls[index].ty },\n+            Lvalue::Temp(index) => LvalueTy::Ty { ty: self.mir.temp_decls[index].ty },\n+            Lvalue::Arg(index) => LvalueTy::Ty { ty: self.mir.arg_decls[index].ty },\n             Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n             Lvalue::ReturnPointer => {\n@@ -379,6 +379,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             TerminatorKind::Goto { .. } |\n             TerminatorKind::Resume |\n             TerminatorKind::Return |\n+            TerminatorKind::Unreachable |\n             TerminatorKind::Drop { .. } => {\n                 // no checks needed for these\n             }\n@@ -595,6 +596,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     span_mirbug!(self, block, \"return on cleanup block\")\n                 }\n             }\n+            TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. } |\n             TerminatorKind::DropAndReplace { target, unwind, .. } |\n             TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n@@ -626,7 +628,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         bb: BasicBlock,\n                         iscleanuppad: bool)\n     {\n-        if mir.basic_block_data(bb).is_cleanup != iscleanuppad {\n+        if mir[bb].is_cleanup != iscleanuppad {\n             span_mirbug!(self, ctxt, \"cleanuppad mismatch: {:?} should be {:?}\",\n                          bb, iscleanuppad);\n         }\n@@ -635,7 +637,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n-        for block in &mir.basic_blocks {\n+        for block in mir.basic_blocks() {\n             for stmt in &block.statements {\n                 if stmt.source_info.span != DUMMY_SP {\n                     self.last_span = stmt.source_info.span;"}, {"sha": "381bd24d9a4ae59f19938000e53e6d925df5199d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -1844,7 +1844,10 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         attributes::emit_uwtable(llfndecl, true);\n     }\n \n-    debug!(\"trans_closure(..., {})\", instance);\n+    // this is an info! to allow collecting monomorphization statistics\n+    // and to allow finding the last function before LLVM aborts from\n+    // release builds.\n+    info!(\"trans_closure(..., {})\", instance);\n \n     let fn_ty = FnType::new(ccx, abi, sig, &[]);\n "}, {"sha": "f1d9e2c5a571052f3d1fed4cabbb8aeb91b52f3b", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -26,6 +26,7 @@ use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::hir::{self, PatKind};\n \n // This procedure builds the *scope map* for a given function, which maps any\n@@ -69,9 +70,9 @@ pub fn create_scope_map(cx: &CrateContext,\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(fcx: &FunctionContext) -> Vec<DIScope> {\n+pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, DIScope> {\n     let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n-    let mut scopes = vec![ptr::null_mut(); mir.visibility_scopes.len()];\n+    let mut scopes = IndexVec::from_elem(ptr::null_mut(), &mir.visibility_scopes);\n \n     let fn_metadata = match fcx.debug_context {\n         FunctionDebugContext::RegularContext(box ref data) => data.fn_metadata,\n@@ -101,38 +102,37 @@ fn make_mir_scope(ccx: &CrateContext,\n                   has_variables: &BitVector,\n                   fn_metadata: DISubprogram,\n                   scope: VisibilityScope,\n-                  scopes: &mut [DIScope]) {\n-    let idx = scope.index();\n-    if !scopes[idx].is_null() {\n+                  scopes: &mut IndexVec<VisibilityScope, DIScope>) {\n+    if !scopes[scope].is_null() {\n         return;\n     }\n \n     let scope_data = &mir.visibility_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n         make_mir_scope(ccx, mir, has_variables, fn_metadata, parent, scopes);\n-        scopes[parent.index()]\n+        scopes[parent]\n     } else {\n         // The root is the function itself.\n-        scopes[idx] = fn_metadata;\n+        scopes[scope] = fn_metadata;\n         return;\n     };\n \n-    if !has_variables.contains(idx) {\n+    if !has_variables.contains(scope.index()) {\n         // Do not create a DIScope if there are no variables\n         // defined in this MIR Scope, to avoid debuginfo bloat.\n \n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n         if parent_scope != fn_metadata {\n-            scopes[idx] = parent_scope;\n+            scopes[scope] = parent_scope;\n             return;\n         }\n     }\n \n     let loc = span_start(ccx, scope_data.span);\n     let file_metadata = file_metadata(ccx, &loc.file.name);\n-    scopes[idx] = unsafe {\n+    scopes[scope] = unsafe {\n         llvm::LLVMDIBuilderCreateLexicalBlock(\n             DIB(ccx),\n             parent_scope,"}, {"sha": "d1c1053ac46b2c461e2fd089515f15f48e72ae29", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -12,6 +12,7 @@\n //! which do not.\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::repr as mir;\n use rustc::mir::repr::TerminatorKind;\n use rustc::mir::visit::{Visitor, LvalueContext};\n@@ -94,10 +95,10 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n         debug!(\"visit_assign(block={:?}, lvalue={:?}, rvalue={:?})\", block, lvalue, rvalue);\n \n         match *lvalue {\n-            mir::Lvalue::Temp(index) => {\n-                self.mark_assigned(index as usize);\n+            mir::Lvalue::Temp(temp) => {\n+                self.mark_assigned(temp.index());\n                 if !rvalue::rvalue_creates_operand(self.mir, self.bcx, rvalue) {\n-                    self.mark_as_lvalue(index as usize);\n+                    self.mark_as_lvalue(temp.index());\n                 }\n             }\n             _ => {\n@@ -115,8 +116,8 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n \n         // Allow uses of projections of immediate pair fields.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if let mir::Lvalue::Temp(index) = proj.base {\n-                let ty = self.mir.temp_decls[index as usize].ty;\n+            if let mir::Lvalue::Temp(temp) = proj.base {\n+                let ty = self.mir.temp_decls[temp].ty;\n                 let ty = self.bcx.monomorphize(&ty);\n                 if common::type_is_imm_pair(self.bcx.ccx(), ty) {\n                     if let mir::ProjectionElem::Field(..) = proj.elem {\n@@ -129,10 +130,10 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n         }\n \n         match *lvalue {\n-            mir::Lvalue::Temp(index) => {\n+            mir::Lvalue::Temp(temp) => {\n                 match context {\n                     LvalueContext::Call => {\n-                        self.mark_assigned(index as usize);\n+                        self.mark_assigned(temp.index());\n                     }\n                     LvalueContext::Consume => {\n                     }\n@@ -142,7 +143,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n                     LvalueContext::Borrow { .. } |\n                     LvalueContext::Slice { .. } |\n                     LvalueContext::Projection => {\n-                        self.mark_as_lvalue(index as usize);\n+                        self.mark_as_lvalue(temp.index());\n                     }\n                 }\n             }\n@@ -163,15 +164,16 @@ pub enum CleanupKind {\n \n pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n                                 mir: &mir::Mir<'tcx>)\n-                                -> Vec<CleanupKind>\n+                                -> IndexVec<mir::BasicBlock, CleanupKind>\n {\n-    fn discover_masters<'tcx>(result: &mut [CleanupKind], mir: &mir::Mir<'tcx>) {\n-        for bb in mir.all_basic_blocks() {\n-            let data = mir.basic_block_data(bb);\n+    fn discover_masters<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n+                              mir: &mir::Mir<'tcx>) {\n+        for (bb, data) in mir.basic_blocks().iter_enumerated() {\n             match data.terminator().kind {\n                 TerminatorKind::Goto { .. } |\n                 TerminatorKind::Resume |\n                 TerminatorKind::Return |\n+                TerminatorKind::Unreachable |\n                 TerminatorKind::If { .. } |\n                 TerminatorKind::Switch { .. } |\n                 TerminatorKind::SwitchInt { .. } => {\n@@ -184,19 +186,19 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n                     if let Some(unwind) = unwind {\n                         debug!(\"cleanup_kinds: {:?}/{:?} registering {:?} as funclet\",\n                                bb, data, unwind);\n-                        result[unwind.index()] = CleanupKind::Funclet;\n+                        result[unwind] = CleanupKind::Funclet;\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn propagate<'tcx>(result: &mut [CleanupKind], mir: &mir::Mir<'tcx>) {\n-        let mut funclet_succs : Vec<_> =\n-            mir.all_basic_blocks().iter().map(|_| None).collect();\n+    fn propagate<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n+                       mir: &mir::Mir<'tcx>) {\n+        let mut funclet_succs = IndexVec::from_elem(None, mir.basic_blocks());\n \n         let mut set_successor = |funclet: mir::BasicBlock, succ| {\n-            match funclet_succs[funclet.index()] {\n+            match funclet_succs[funclet] {\n                 ref mut s @ None => {\n                     debug!(\"set_successor: updating successor of {:?} to {:?}\",\n                            funclet, succ);\n@@ -210,22 +212,22 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n         };\n \n         for (bb, data) in traversal::reverse_postorder(mir) {\n-            let funclet = match result[bb.index()] {\n+            let funclet = match result[bb] {\n                 CleanupKind::NotCleanup => continue,\n                 CleanupKind::Funclet => bb,\n                 CleanupKind::Internal { funclet } => funclet,\n             };\n \n             debug!(\"cleanup_kinds: {:?}/{:?}/{:?} propagating funclet {:?}\",\n-                   bb, data, result[bb.index()], funclet);\n+                   bb, data, result[bb], funclet);\n \n             for &succ in data.terminator().successors().iter() {\n-                let kind = result[succ.index()];\n+                let kind = result[succ];\n                 debug!(\"cleanup_kinds: propagating {:?} to {:?}/{:?}\",\n                        funclet, succ, kind);\n                 match kind {\n                     CleanupKind::NotCleanup => {\n-                        result[succ.index()] = CleanupKind::Internal { funclet: funclet };\n+                        result[succ] = CleanupKind::Internal { funclet: funclet };\n                     }\n                     CleanupKind::Funclet => {\n                         set_successor(funclet, succ);\n@@ -237,7 +239,7 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n \n                             debug!(\"promoting {:?} to a funclet and updating {:?}\", succ,\n                                    succ_funclet);\n-                            result[succ.index()] = CleanupKind::Funclet;\n+                            result[succ] = CleanupKind::Funclet;\n                             set_successor(succ_funclet, succ);\n                             set_successor(funclet, succ);\n                         }\n@@ -247,8 +249,7 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n         }\n     }\n \n-    let mut result : Vec<_> =\n-        mir.all_basic_blocks().iter().map(|_| CleanupKind::NotCleanup).collect();\n+    let mut result = IndexVec::from_elem(CleanupKind::NotCleanup, mir.basic_blocks());\n \n     discover_masters(&mut result, mir);\n     propagate(&mut result, mir);"}, {"sha": "bdcf3dd8cd41884e61eb24f35ef47fe9d048ed22", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -43,7 +43,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         let mut bcx = self.bcx(bb);\n         let mir = self.mir.clone();\n-        let data = mir.basic_block_data(bb);\n+        let data = &mir[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n \n@@ -52,9 +52,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let cleanup_bundle = bcx.lpad().and_then(|l| l.bundle());\n \n         let funclet_br = |this: &Self, bcx: BlockAndBuilder, bb: mir::BasicBlock| {\n-            let lltarget = this.blocks[bb.index()].llbb;\n+            let lltarget = this.blocks[bb].llbb;\n             if let Some(cp) = cleanup_pad {\n-                match this.cleanup_kind(bb) {\n+                match this.cleanup_kinds[bb] {\n                     CleanupKind::Funclet => {\n                         // micro-optimization: generate a `ret` rather than a jump\n                         // to a return block\n@@ -69,10 +69,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         };\n \n         let llblock = |this: &mut Self, target: mir::BasicBlock| {\n-            let lltarget = this.blocks[target.index()].llbb;\n+            let lltarget = this.blocks[target].llbb;\n \n             if let Some(cp) = cleanup_pad {\n-                match this.cleanup_kind(target) {\n+                match this.cleanup_kinds[target] {\n                     CleanupKind::Funclet => {\n                         // MSVC cross-funclet jump - need a trampoline\n \n@@ -89,7 +89,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             } else {\n                 if let (CleanupKind::NotCleanup, CleanupKind::Funclet) =\n-                    (this.cleanup_kind(bb), this.cleanup_kind(target))\n+                    (this.cleanup_kinds[bb], this.cleanup_kinds[target])\n                 {\n                     // jump *into* cleanup - need a landing pad if GNU\n                     this.landing_pad_to(target).llbb\n@@ -191,6 +191,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 })\n             }\n \n+            mir::TerminatorKind::Unreachable => {\n+                bcx.unreachable();\n+            }\n+\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let lvalue = self.trans_lvalue(&bcx, location);\n                 let ty = lvalue.ty.to_ty(bcx.tcx());\n@@ -209,7 +213,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if let Some(unwind) = unwind {\n                     bcx.invoke(drop_fn,\n                                &[llvalue],\n-                               self.blocks[target.index()].llbb,\n+                               self.blocks[target].llbb,\n                                llblock(self, unwind),\n                                cleanup_bundle);\n                 } else {\n@@ -488,7 +492,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // Many different ways to call a function handled here\n                 if let &Some(cleanup) = cleanup {\n                     let ret_bcx = if let Some((_, target)) = *destination {\n-                        self.blocks[target.index()]\n+                        self.blocks[target]\n                     } else {\n                         self.unreachable_block()\n                     };\n@@ -693,27 +697,23 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    fn cleanup_kind(&self, bb: mir::BasicBlock) -> CleanupKind {\n-        self.cleanup_kinds[bb.index()]\n-    }\n-\n     /// Return the landingpad wrapper around the given basic block\n     ///\n     /// No-op in MSVC SEH scheme.\n     fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> Block<'bcx, 'tcx>\n     {\n-        if let Some(block) = self.landing_pads[target_bb.index()] {\n+        if let Some(block) = self.landing_pads[target_bb] {\n             return block;\n         }\n \n         if base::wants_msvc_seh(self.fcx.ccx.sess()) {\n-            return self.blocks[target_bb.index()];\n+            return self.blocks[target_bb];\n         }\n \n         let target = self.bcx(target_bb);\n \n         let block = self.fcx.new_block(\"cleanup\", None);\n-        self.landing_pads[target_bb.index()] = Some(block);\n+        self.landing_pads[target_bb] = Some(block);\n \n         let bcx = block.build();\n         let ccx = bcx.ccx();\n@@ -729,10 +729,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     pub fn init_cpad(&mut self, bb: mir::BasicBlock) {\n         let bcx = self.bcx(bb);\n-        let data = self.mir.basic_block_data(bb);\n+        let data = &self.mir[bb];\n         debug!(\"init_cpad({:?})\", data);\n \n-        match self.cleanup_kinds[bb.index()] {\n+        match self.cleanup_kinds[bb] {\n             CleanupKind::NotCleanup => {\n                 bcx.set_lpad(None)\n             }\n@@ -763,7 +763,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     fn bcx(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'bcx, 'tcx> {\n-        self.blocks[bb.index()].build()\n+        self.blocks[bb].build()\n     }\n \n     fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n@@ -776,7 +776,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let dest = match *dest {\n             mir::Lvalue::Temp(idx) => {\n                 let ret_ty = self.lvalue_ty(dest);\n-                match self.temps[idx as usize] {\n+                match self.temps[idx] {\n                     TempRef::Lvalue(dest) => dest,\n                     TempRef::Operand(None) => {\n                         // Handle temporary lvalues, specifically Operand ones, as\n@@ -838,6 +838,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         self.store_operand(bcx, cast_ptr, val);\n     }\n \n+\n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n                     bcx: &BlockAndBuilder<'bcx, 'tcx>,\n@@ -851,7 +852,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n             IndirectOperand(tmp, idx) => {\n                 let op = self.trans_load(bcx, tmp, op.ty);\n-                self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                self.temps[idx] = TempRef::Operand(Some(op));\n             }\n             DirectOperand(idx) => {\n                 // If there is a cast, we have to store and reload.\n@@ -864,7 +865,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 } else {\n                     op.unpack_if_pair(bcx)\n                 };\n-                self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                self.temps[idx] = TempRef::Operand(Some(op));\n             }\n         }\n     }\n@@ -876,7 +877,7 @@ enum ReturnDest {\n     // Store the return value to the pointer\n     Store(ValueRef),\n     // Stores an indirect return value to an operand temporary lvalue\n-    IndirectOperand(ValueRef, u32),\n+    IndirectOperand(ValueRef, mir::Temp),\n     // Stores a direct return value to an operand temporary lvalue\n-    DirectOperand(u32)\n+    DirectOperand(mir::Temp)\n }"}, {"sha": "316c7341ef142a8b958571d5ac899945a38ab924", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -22,6 +22,7 @@ use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr};\n use callee::Callee;\n use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n@@ -203,13 +204,13 @@ struct MirConstContext<'a, 'tcx: 'a> {\n     substs: &'tcx Substs<'tcx>,\n \n     /// Arguments passed to a const fn.\n-    args: Vec<Const<'tcx>>,\n+    args: IndexVec<mir::Arg, Const<'tcx>>,\n \n     /// Variable values - specifically, argument bindings of a const fn.\n-    vars: Vec<Option<Const<'tcx>>>,\n+    vars: IndexVec<mir::Var, Option<Const<'tcx>>>,\n \n     /// Temp values.\n-    temps: Vec<Option<Const<'tcx>>>,\n+    temps: IndexVec<mir::Temp, Option<Const<'tcx>>>,\n \n     /// Value assigned to Return, which is the resulting constant.\n     return_value: Option<Const<'tcx>>\n@@ -220,22 +221,22 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn new(ccx: &'a CrateContext<'a, 'tcx>,\n            mir: &'a mir::Mir<'tcx>,\n            substs: &'tcx Substs<'tcx>,\n-           args: Vec<Const<'tcx>>)\n+           args: IndexVec<mir::Arg, Const<'tcx>>)\n            -> MirConstContext<'a, 'tcx> {\n         MirConstContext {\n             ccx: ccx,\n             mir: mir,\n             substs: substs,\n             args: args,\n-            vars: vec![None; mir.var_decls.len()],\n-            temps: vec![None; mir.temp_decls.len()],\n+            vars: IndexVec::from_elem(None, &mir.var_decls),\n+            temps: IndexVec::from_elem(None, &mir.temp_decls),\n             return_value: None\n         }\n     }\n \n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n                  mut instance: Instance<'tcx>,\n-                 args: Vec<Const<'tcx>>)\n+                 args: IndexVec<mir::Arg, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalFailure> {\n         // Try to resolve associated constants.\n         if instance.substs.self_ty().is_some() {\n@@ -279,7 +280,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let mut failure = Ok(());\n \n         loop {\n-            let data = self.mir.basic_block_data(bb);\n+            let data = &self.mir[bb];\n             for statement in &data.statements {\n                 let span = statement.source_info.span;\n                 match statement.kind {\n@@ -342,10 +343,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                        func, fn_ty)\n                     };\n \n-                    let mut const_args = Vec::with_capacity(args.len());\n+                    let mut const_args = IndexVec::with_capacity(args.len());\n                     for arg in args {\n                         match self.const_operand(arg, span) {\n-                            Ok(arg) => const_args.push(arg),\n+                            Ok(arg) => { const_args.push(arg); },\n                             Err(err) => if failure.is_ok() { failure = Err(err); }\n                         }\n                     }\n@@ -366,8 +367,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn store(&mut self, dest: &mir::Lvalue<'tcx>, value: Const<'tcx>, span: Span) {\n         let dest = match *dest {\n-            mir::Lvalue::Var(index) => &mut self.vars[index as usize],\n-            mir::Lvalue::Temp(index) => &mut self.temps[index as usize],\n+            mir::Lvalue::Var(var) => &mut self.vars[var],\n+            mir::Lvalue::Temp(temp) => &mut self.temps[temp],\n             mir::Lvalue::ReturnPointer => &mut self.return_value,\n             _ => span_bug!(span, \"assignment to {:?} in constant\", dest)\n         };\n@@ -378,17 +379,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     -> Result<ConstLvalue<'tcx>, ConstEvalFailure> {\n         let tcx = self.ccx.tcx();\n         let lvalue = match *lvalue {\n-            mir::Lvalue::Var(index) => {\n-                self.vars[index as usize].unwrap_or_else(|| {\n-                    span_bug!(span, \"var{} not initialized\", index)\n+            mir::Lvalue::Var(var) => {\n+                self.vars[var].unwrap_or_else(|| {\n+                    span_bug!(span, \"{:?} not initialized\", var)\n                 }).as_lvalue()\n             }\n-            mir::Lvalue::Temp(index) => {\n-                self.temps[index as usize].unwrap_or_else(|| {\n-                    span_bug!(span, \"tmp{} not initialized\", index)\n+            mir::Lvalue::Temp(temp) => {\n+                self.temps[temp].unwrap_or_else(|| {\n+                    span_bug!(span, \"{:?} not initialized\", temp)\n                 }).as_lvalue()\n             }\n-            mir::Lvalue::Arg(index) => self.args[index as usize].as_lvalue(),\n+            mir::Lvalue::Arg(arg) => self.args[arg].as_lvalue(),\n             mir::Lvalue::Static(def_id) => {\n                 ConstLvalue {\n                     base: Base::Static(consts::get_static(self.ccx, def_id).val),\n@@ -489,11 +490,11 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                         let substs = self.monomorphize(&substs);\n                         let instance = Instance::new(def_id, substs);\n-                        MirConstContext::trans_def(self.ccx, instance, vec![])\n+                        MirConstContext::trans_def(self.ccx, instance, IndexVec::new())\n                     }\n                     mir::Literal::Promoted { index } => {\n                         let mir = &self.mir.promoted[index];\n-                        MirConstContext::new(self.ccx, mir, self.substs, vec![]).trans()\n+                        MirConstContext::new(self.ccx, mir, self.substs, IndexVec::new()).trans()\n                     }\n                     mir::Literal::Value { value } => {\n                         Ok(Const::from_constval(self.ccx, value, ty))\n@@ -914,11 +915,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 let substs = bcx.monomorphize(&substs);\n                 let instance = Instance::new(def_id, substs);\n-                MirConstContext::trans_def(bcx.ccx(), instance, vec![])\n+                MirConstContext::trans_def(bcx.ccx(), instance, IndexVec::new())\n             }\n             mir::Literal::Promoted { index } => {\n                 let mir = &self.mir.promoted[index];\n-                MirConstContext::new(bcx.ccx(), mir, bcx.fcx().param_substs, vec![]).trans()\n+                MirConstContext::new(bcx.ccx(), mir, bcx.fcx().param_substs,\n+                                     IndexVec::new()).trans()\n             }\n             mir::Literal::Value { value } => {\n                 Ok(Const::from_constval(bcx.ccx(), value, ty))\n@@ -945,5 +947,5 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n                                 -> Result<ValueRef, ConstEvalFailure> {\n     let instance = Instance::mono(ccx.shared(), def_id);\n-    MirConstContext::trans_def(ccx, instance, vec![]).map(|c| c.llval)\n+    MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n }"}, {"sha": "0a66a147568e6b986265080bbb066e4882fa11da", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -12,6 +12,7 @@ use llvm::ValueRef;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n+use rustc_data_structures::indexed_vec::Idx;\n use abi;\n use adt;\n use base;\n@@ -90,14 +91,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n         let result = match *lvalue {\n-            mir::Lvalue::Var(index) => self.vars[index as usize],\n-            mir::Lvalue::Temp(index) => match self.temps[index as usize] {\n+            mir::Lvalue::Var(var) => self.vars[var],\n+            mir::Lvalue::Temp(temp) => match self.temps[temp] {\n                 TempRef::Lvalue(lvalue) =>\n                     lvalue,\n                 TempRef::Operand(..) =>\n                     bug!(\"using operand temp {:?} as lvalue\", lvalue),\n             },\n-            mir::Lvalue::Arg(index) => self.args[index as usize],\n+            mir::Lvalue::Arg(arg) => self.args[arg],\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.lvalue_ty(lvalue);\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id).val,\n@@ -233,8 +234,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n     {\n         match *lvalue {\n-            mir::Lvalue::Temp(idx) => {\n-                match self.temps[idx as usize] {\n+            mir::Lvalue::Temp(temp) => {\n+                match self.temps[temp] {\n                     TempRef::Lvalue(lvalue) => f(self, lvalue),\n                     TempRef::Operand(None) => {\n                         let lvalue_ty = self.lvalue_ty(lvalue);\n@@ -243,7 +244,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                        \"lvalue_temp\");\n                         let ret = f(self, lvalue);\n                         let op = self.trans_load(bcx, lvalue.llval, lvalue_ty);\n-                        self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                        self.temps[temp] = TempRef::Operand(Some(op));\n                         ret\n                     }\n                     TempRef::Operand(Some(_)) => {"}, {"sha": "1932a2023fac8cb05f5b078ca88d81b7269ca14b", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -30,6 +30,7 @@ use std::rc::Rc;\n use basic_block::BasicBlock;\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n pub use self::constant::trans_static_initializer;\n \n@@ -71,20 +72,20 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     llpersonalityslot: Option<ValueRef>,\n \n     /// A `Block` for each MIR `BasicBlock`\n-    blocks: Vec<Block<'bcx, 'tcx>>,\n+    blocks: IndexVec<mir::BasicBlock, Block<'bcx, 'tcx>>,\n \n     /// The funclet status of each basic block\n-    cleanup_kinds: Vec<analyze::CleanupKind>,\n+    cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n-    landing_pads: Vec<Option<Block<'bcx, 'tcx>>>,\n+    landing_pads: IndexVec<mir::BasicBlock, Option<Block<'bcx, 'tcx>>>,\n \n     /// Cached unreachable block\n     unreachable_block: Option<Block<'bcx, 'tcx>>,\n \n     /// An LLVM alloca for each MIR `VarDecl`\n-    vars: Vec<LvalueRef<'tcx>>,\n+    vars: IndexVec<mir::Var, LvalueRef<'tcx>>,\n \n     /// The location where each MIR `TempDecl` is stored. This is\n     /// usually an `LvalueRef` representing an alloca, but not always:\n@@ -101,20 +102,20 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     ///\n     /// Avoiding allocs can also be important for certain intrinsics,\n     /// notably `expect`.\n-    temps: Vec<TempRef<'tcx>>,\n+    temps: IndexVec<mir::Temp, TempRef<'tcx>>,\n \n     /// The arguments to the function; as args are lvalues, these are\n     /// always indirect, though we try to avoid creating an alloca\n     /// when we can (and just reuse the pointer the caller provided).\n-    args: Vec<LvalueRef<'tcx>>,\n+    args: IndexVec<mir::Arg, LvalueRef<'tcx>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: Vec<DIScope>\n+    scopes: IndexVec<mir::VisibilityScope, DIScope>\n }\n \n impl<'blk, 'tcx> MirContext<'blk, 'tcx> {\n     pub fn debug_loc(&self, source_info: mir::SourceInfo) -> DebugLoc {\n-        DebugLoc::ScopeAt(self.scopes[source_info.scope.index()], source_info.span)\n+        DebugLoc::ScopeAt(self.scopes[source_info.scope], source_info.span)\n     }\n }\n \n@@ -154,8 +155,6 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let bcx = fcx.init(false, None).build();\n     let mir = bcx.mir();\n \n-    let mir_blocks = mir.all_basic_blocks();\n-\n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n     let (lvalue_temps, cleanup_kinds) = bcx.with_block(|bcx| {\n@@ -173,7 +172,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                             .map(|(mty, decl)| {\n         let lvalue = LvalueRef::alloca(&bcx, mty, &decl.name.as_str());\n \n-        let scope = scopes[decl.source_info.scope.index()];\n+        let scope = scopes[decl.source_info.scope];\n         if !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n             bcx.with_block(|bcx| {\n                 declare_local(bcx, decl.name, mty, scope,\n@@ -200,19 +199,17 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                               .collect();\n \n     // Allocate a `Block` for every basic block\n-    let block_bcxs: Vec<Block<'blk,'tcx>> =\n-        mir_blocks.iter()\n-                  .map(|&bb|{\n-                      if bb == mir::START_BLOCK {\n-                          fcx.new_block(\"start\", None)\n-                      } else {\n-                          fcx.new_block(&format!(\"{:?}\", bb), None)\n-                      }\n-                  })\n-                  .collect();\n+    let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n+        mir.basic_blocks().indices().map(|bb| {\n+            if bb == mir::START_BLOCK {\n+                fcx.new_block(\"start\", None)\n+            } else {\n+                fcx.new_block(&format!(\"{:?}\", bb), None)\n+            }\n+        }).collect();\n \n     // Branch to the START block\n-    let start_bcx = block_bcxs[mir::START_BLOCK.index()];\n+    let start_bcx = block_bcxs[mir::START_BLOCK];\n     bcx.br(start_bcx.llbb);\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n@@ -227,14 +224,14 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         blocks: block_bcxs,\n         unreachable_block: None,\n         cleanup_kinds: cleanup_kinds,\n-        landing_pads: mir_blocks.iter().map(|_| None).collect(),\n+        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n         vars: vars,\n         temps: temps,\n         args: args,\n         scopes: scopes\n     };\n \n-    let mut visited = BitVector::new(mir_blocks.len());\n+    let mut visited = BitVector::new(mir.basic_blocks().len());\n \n     let mut rpo = traversal::reverse_postorder(&mir);\n \n@@ -252,8 +249,8 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     // Remove blocks that haven't been visited, or have no\n     // predecessors.\n-    for &bb in &mir_blocks {\n-        let block = mircx.blocks[bb.index()];\n+    for bb in mir.basic_blocks().indices() {\n+        let block = mircx.blocks[bb];\n         let block = BasicBlock(block.llbb);\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n@@ -271,15 +268,15 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n /// indirect.\n fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               mir: &mir::Mir<'tcx>,\n-                              scopes: &[DIScope])\n-                              -> Vec<LvalueRef<'tcx>> {\n+                              scopes: &IndexVec<mir::VisibilityScope, DIScope>)\n+                              -> IndexVec<mir::Arg, LvalueRef<'tcx>> {\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n-    let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE.index()];\n+    let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n     let arg_scope = if !arg_scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n         Some(arg_scope)\n     } else {"}, {"sha": "80ff0a92d8d4630e517ced286bf62f27c1def5cb", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -11,6 +11,8 @@\n use llvm::ValueRef;\n use rustc::ty::Ty;\n use rustc::mir::repr as mir;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n use base;\n use common::{self, Block, BlockAndBuilder};\n use value::Value;\n@@ -174,7 +176,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // watch out for temporaries that do not have an\n                 // alloca; they are handled somewhat differently\n                 if let &mir::Lvalue::Temp(index) = lvalue {\n-                    match self.temps[index as usize] {\n+                    match self.temps[index] {\n                         TempRef::Operand(Some(o)) => {\n                             return o;\n                         }\n@@ -190,7 +192,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // Moves out of pair fields are trivial.\n                 if let &mir::Lvalue::Projection(ref proj) = lvalue {\n                     if let mir::Lvalue::Temp(index) = proj.base {\n-                        let temp_ref = &self.temps[index as usize];\n+                        let temp_ref = &self.temps[index];\n                         if let &TempRef::Operand(Some(o)) = temp_ref {\n                             match (o.val, &proj.elem) {\n                                 (OperandValue::Pair(a, b),"}, {"sha": "d592f5ee1b936fde2adf9a94e94964e9fc4e56c0", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::mir::repr as mir;\n+\n use common::{self, BlockAndBuilder};\n \n use super::MirContext;\n@@ -28,8 +29,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 match *lvalue {\n                     mir::Lvalue::Temp(index) => {\n-                        let index = index as usize;\n-                        match self.temps[index as usize] {\n+                        match self.temps[index] {\n                             TempRef::Lvalue(tr_dest) => {\n                                 self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n                             }"}, {"sha": "3e8277e28ba73befd71d9946c4ceb46d3d02e8d2", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -87,6 +87,7 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n ]"}, {"sha": "604933d40a12c688d4ee26a13033dbbc8eb2c24c", "filename": "src/test/run-pass-fulldeps/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee00760a14020d73e8ad509b2ddbd3054101db6f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs?ref=ee00760a14020d73e8ad509b2ddbd3054101db6f", "patch": "@@ -29,6 +29,7 @@ use rustc_plugin::Registry;\n struct Pass;\n \n impl transform::Pass for Pass {}\n+\n impl<'tcx> MirPass<'tcx> for Pass {\n     fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n                     _: MirSource, mir: &mut Mir<'tcx>) {"}]}