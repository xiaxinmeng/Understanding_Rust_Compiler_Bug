{"sha": "29e0235415a42299e4a7467c5edb09a159ec680e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZTAyMzU0MTVhNDIyOTllNGE3NDY3YzVlZGIwOWExNTllYzY4MGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-22T01:30:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-10-02T21:52:15Z"}, "message": "Add a platform-abstraction tidy script\n\nThis is intended to maintain existing standards of code organization\nin hopes that the standard library will continue to be refactored to\nisolate platform-specific bits, making porting easier; where \"standard\nlibrary\" roughly means \"all the dependencies of the std and test\ncrates\".\n\nThis generally means placing restrictions on where `cfg(unix)`,\n`cfg(windows)`, `cfg(target_os)` and `cfg(target_env)` may appear,\nthe basic objective being to isolate platform-specific code to the\nplatform-specific `std::sys` modules, and to the allocation,\nunwinding, and libc crates.\n\nFollowing are the basic rules, though there are currently\nexceptions:\n\n- core may not have platform-specific code\n- liballoc_system may have platform-specific code\n- liballoc_jemalloc may have platform-specific code\n- libpanic_abort may have platform-specific code\n- libpanic_unwind may have platform-specific code\n- other crates in the std facade may not\n- std may have platform-specific code in the following places\n  - sys/unix/\n  - sys/windows/\n  - os/\n\nThere are plenty of exceptions today though, noted in the whitelist.", "tree": {"sha": "a23455cc0251918edc2fe61d76da9da9ac5a7a07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a23455cc0251918edc2fe61d76da9da9ac5a7a07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29e0235415a42299e4a7467c5edb09a159ec680e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29e0235415a42299e4a7467c5edb09a159ec680e", "html_url": "https://github.com/rust-lang/rust/commit/29e0235415a42299e4a7467c5edb09a159ec680e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29e0235415a42299e4a7467c5edb09a159ec680e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fb8379ed86f15943e87721f73165138598d19cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb8379ed86f15943e87721f73165138598d19cc", "html_url": "https://github.com/rust-lang/rust/commit/0fb8379ed86f15943e87721f73165138598d19cc"}], "stats": {"total": 242, "additions": 239, "deletions": 3}, "files": [{"sha": "56286fbe25399a62a322c24e815475cf6c69085a", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=29e0235415a42299e4a7467c5edb09a159ec680e", "patch": "@@ -31,7 +31,7 @@ mod addr;\n mod tcp;\n mod udp;\n mod parser;\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n+#[cfg(test)]\n mod test;\n \n /// Possible values which can be passed to the [`shutdown`] method of"}, {"sha": "3f2eacda7d60eb11a9902255b3158dae07a69da7", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=29e0235415a42299e4a7467c5edb09a159ec680e", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(dead_code)] // not used on emscripten\n+\n use env;\n use net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n use sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "e056a350815a79d6fa4b3af11e05fd03f6c37766", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=29e0235415a42299e4a7467c5edb09a159ec680e", "patch": "@@ -366,8 +366,8 @@ impl<'rx, T:Send+'rx> fmt::Debug for Handle<'rx, T> {\n     }\n }\n \n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n #[allow(unused_imports)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use thread;\n     use sync::mpsc::*;"}, {"sha": "0483725dd83bc22631aec0f0bc15a988e7ddd8f2", "filename": "src/libstd/sys/common/io.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs?ref=29e0235415a42299e4a7467c5edb09a159ec680e", "patch": "@@ -50,7 +50,8 @@ pub unsafe fn read_to_end_uninitialized(r: &mut Read, buf: &mut Vec<u8>) -> io::\n     }\n }\n \n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n+#[cfg(test)]\n+#[allow(dead_code)] // not used on emscripten\n pub mod test {\n     use path::{Path, PathBuf};\n     use env;"}, {"sha": "cabaee5d0600551ac1df0488456353b3ebc669b5", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=29e0235415a42299e4a7467c5edb09a159ec680e", "patch": "@@ -36,6 +36,7 @@ mod errors;\n mod features;\n mod cargo;\n mod cargo_lock;\n+mod pal;\n \n fn main() {\n     let path = env::args_os().skip(1).next().expect(\"need an argument\");\n@@ -48,6 +49,7 @@ fn main() {\n     cargo::check(&path, &mut bad);\n     features::check(&path, &mut bad);\n     cargo_lock::check(&path, &mut bad);\n+    pal::check(&path, &mut bad);\n \n     if bad {\n         panic!(\"some tidy checks failed\");"}, {"sha": "aac7c2666646a68f4d5c5c9cf4377221e88a6144", "filename": "src/tools/tidy/src/pal.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e0235415a42299e4a7467c5edb09a159ec680e/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=29e0235415a42299e4a7467c5edb09a159ec680e", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Tidy check to enforce rules about platform-specific code in std\n+//!\n+//! This is intended to maintain existing standards of code\n+//! organization in hopes that the standard library will continue to\n+//! be refactored to isolate platform-specific bits, making porting\n+//! easier; where \"standard library\" roughly means \"all the\n+//! dependencies of the std and test crates\".\n+//!\n+//! This generally means placing restrictions on where `cfg(unix)`,\n+//! `cfg(windows)`, `cfg(target_os)` and `cfg(target_env)` may appear,\n+//! the basic objective being to isolate platform-specific code to the\n+//! platform-specific `std::sys` modules, and to the allocation,\n+//! unwinding, and libc crates.\n+//!\n+//! Following are the basic rules, though there are currently\n+//! exceptions:\n+//!\n+//! - core may not have platform-specific code\n+//! - liballoc_system may have platform-specific code\n+//! - liballoc_jemalloc may have platform-specific code\n+//! - libpanic_abort may have platform-specific code\n+//! - libpanic_unwind may have platform-specific code\n+//! - libunwind may have platform-specific code\n+//! - other crates in the std facade may not\n+//! - std may have platform-specific code in the following places\n+//!   - sys/unix/\n+//!   - sys/windows/\n+//!   - os/\n+//!\n+//! `std/sys_common` should _not_ contain platform-specific code.\n+//! Finally, because std contains tests with platform-specific\n+//! `ignore` attributes, once the parser encounters `mod tests`,\n+//! platform-specific cfgs are allowed. Not sure yet how to deal with\n+//! this in the long term.\n+\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+use std::iter::Iterator;\n+\n+// Paths that may contain platform-specific code\n+const EXCEPTION_PATHS: &'static [&'static str] = &[\n+    // std crates\n+    \"src/liballoc_jemalloc\",\n+    \"src/liballoc_system\",\n+    \"src/liblibc\",\n+    \"src/libpanic_abort\",\n+    \"src/libpanic_unwind\",\n+    \"src/libunwind\",\n+    \"src/libstd/sys/unix\", // This is where platform-specific code for std should live\n+    \"src/libstd/sys/windows\", // Ditto\n+    \"src/libstd/os\", // Platform-specific public interfaces\n+    \"src/rtstartup\", // Not sure what to do about this. magic stuff for mingw\n+\n+    // temporary exceptions\n+    \"src/libstd/lib.rs\", // This could probably be done within the sys directory\n+    \"src/libstd/rtdeps.rs\", // Until rustbuild replaces make\n+    \"src/libstd/path.rs\",\n+    \"src/libstd/io/stdio.rs\",\n+    \"src/libstd/num/f32.rs\",\n+    \"src/libstd/num/f64.rs\",\n+    \"src/libstd/thread/local.rs\",\n+    \"src/libstd/sys/common/mod.rs\",\n+    \"src/libstd/sys/common/args.rs\",\n+    \"src/libstd/sys/common/net.rs\",\n+    \"src/libstd/sys/common/util.rs\",\n+    \"src/libterm\", // Not sure how to make this crate portable, but test needs it\n+    \"src/libtest\", // Probably should defer to unstable std::sys APIs\n+\n+    // std testing crates, ok for now at least\n+    \"src/libcoretest\",\n+\n+    // non-std crates\n+    \"src/test\",\n+    \"src/tools\",\n+    \"src/librustc\",\n+    \"src/librustdoc\",\n+    \"src/libsyntax\",\n+    \"src/bootstrap\",\n+];\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    let ref mut contents = String::new();\n+    // Sanity check that the complex parsing here works\n+    let ref mut saw_target_arch = false;\n+    let ref mut saw_cfg_bang = false;\n+    super::walk(path, &mut super::filter_dirs, &mut |file| {\n+        let filestr = file.to_string_lossy().replace(\"\\\\\", \"/\");\n+        if !filestr.ends_with(\".rs\") { return }\n+\n+        let is_exception_path = EXCEPTION_PATHS.iter().any(|s| filestr.contains(&**s));\n+        if is_exception_path { return }\n+\n+        check_cfgs(contents, &file, bad, saw_target_arch, saw_cfg_bang);\n+    });\n+\n+    assert!(*saw_target_arch);\n+    assert!(*saw_cfg_bang);\n+}\n+\n+fn check_cfgs(contents: &mut String, file: &Path,\n+              bad: &mut bool, saw_target_arch: &mut bool, saw_cfg_bang: &mut bool) {\n+    contents.truncate(0);\n+    t!(t!(File::open(file), file).read_to_string(contents));\n+\n+    // For now it's ok to have platform-specific code after 'mod tests'.\n+    let mod_tests_idx = find_test_mod(contents);\n+    let contents = &contents[..mod_tests_idx];\n+    // Pull out all \"cfg(...)\" and \"cfg!(...)\" strings\n+    let cfgs = parse_cfgs(contents);\n+\n+    let mut line_numbers: Option<Vec<usize>> = None;\n+    let mut err = |idx: usize, cfg: &str| {\n+        if line_numbers.is_none() {\n+            line_numbers = Some(contents.match_indices('\\n').map(|(i, _)| i).collect());\n+        }\n+        let line_numbers = line_numbers.as_ref().expect(\"\");\n+        let line = match line_numbers.binary_search(&idx) {\n+            Ok(_) => unreachable!(),\n+            Err(i) => i + 1\n+        };\n+        println!(\"{}:{}: platform-specific cfg: {}\", file.display(), line, cfg);\n+        *bad = true;\n+    };\n+\n+    for (idx, cfg) in cfgs.into_iter() {\n+        // Sanity check that the parsing here works\n+        if !*saw_target_arch && cfg.contains(\"target_arch\") { *saw_target_arch = true }\n+        if !*saw_cfg_bang && cfg.contains(\"cfg!\") { *saw_cfg_bang = true }\n+\n+        let contains_platform_specific_cfg =\n+            cfg.contains(\"target_os\")\n+            || cfg.contains(\"target_env\")\n+            || cfg.contains(\"target_vendor\")\n+            || cfg.contains(\"unix\")\n+            || cfg.contains(\"windows\");\n+\n+        if !contains_platform_specific_cfg { continue }\n+\n+        let preceeded_by_doc_comment = {\n+            let pre_contents = &contents[..idx];\n+            let pre_newline = pre_contents.rfind('\\n');\n+            let pre_doc_comment = pre_contents.rfind(\"///\");\n+            match (pre_newline, pre_doc_comment) {\n+                (Some(n), Some(c)) => n < c,\n+                (None, Some(_)) => true,\n+                (_, None) => false,\n+            }\n+        };\n+\n+        if preceeded_by_doc_comment { continue }\n+\n+        err(idx, cfg);\n+    }\n+}\n+\n+fn find_test_mod(contents: &str) -> usize {\n+    if let Some(mod_tests_idx) = contents.find(\"mod tests\") {\n+        // Also capture a previos line indicating \"mod tests\" in cfg-ed out\n+        let prev_newline_idx = contents[..mod_tests_idx].rfind('\\n').unwrap_or(mod_tests_idx);\n+        let prev_newline_idx = contents[..prev_newline_idx].rfind('\\n');\n+        if let Some(nl) = prev_newline_idx {\n+            let prev_line = &contents[nl + 1 .. mod_tests_idx];\n+            let emcc_cfg = \"cfg(all(test, not(target_os\";\n+            if prev_line.contains(emcc_cfg) {\n+                nl\n+            } else {\n+                mod_tests_idx\n+            }\n+        } else {\n+            mod_tests_idx\n+        }\n+    } else {\n+        contents.len()\n+    }\n+}\n+\n+fn parse_cfgs<'a>(contents: &'a str) -> Vec<(usize, &'a str)> {\n+    let candidate_cfgs = contents.match_indices(\"cfg\");\n+    let candidate_cfg_idxs = candidate_cfgs.map(|(i, _)| i);\n+    // This is puling out the indexes of all \"cfg\" strings\n+    // that appear to be tokens succeeded by a paren.\n+    let cfgs = candidate_cfg_idxs.filter(|i| {\n+        let pre_idx = i.saturating_sub(*i);\n+        let succeeds_non_ident = !contents.as_bytes().get(pre_idx)\n+            .cloned()\n+            .map(char::from)\n+            .map(char::is_alphanumeric)\n+            .unwrap_or(false);\n+        let contents_after = &contents[*i..];\n+        let first_paren = contents_after.find('(');\n+        let paren_idx = first_paren.map(|ip| i + ip);\n+        let preceeds_whitespace_and_paren = paren_idx.map(|ip| {\n+            let maybe_space = &contents[*i + \"cfg\".len() .. ip];\n+            maybe_space.chars().all(|c| char::is_whitespace(c) || c == '!')\n+        }).unwrap_or(false);\n+\n+        succeeds_non_ident && preceeds_whitespace_and_paren\n+    });\n+\n+    cfgs.map(|i| {\n+        let mut depth = 0;\n+        let contents_from = &contents[i..];\n+        for (j, byte) in contents_from.bytes().enumerate() {\n+            match byte {\n+                b'(' => {\n+                    depth += 1;\n+                }\n+                b')' => {\n+                    depth -= 1;\n+                    if depth == 0 {\n+                        return (i, &contents_from[.. j + 1]);\n+                    }\n+                }\n+                _ => { }\n+            }\n+        }\n+\n+        unreachable!()\n+    }).collect()\n+}"}]}