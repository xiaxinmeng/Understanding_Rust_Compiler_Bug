{"sha": "b1435ed593fb9adcde6358b5b4fb43efe2844192", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNDM1ZWQ1OTNmYjlhZGNkZTYzNThiNWI0ZmI0M2VmZTI4NDQxOTI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-06T19:38:15Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-07T19:21:57Z"}, "message": "Guide: tasks", "tree": {"sha": "bdd2bef7d913d6910c7e940c76ffbd57e5670e94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdd2bef7d913d6910c7e940c76ffbd57e5670e94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1435ed593fb9adcde6358b5b4fb43efe2844192", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1435ed593fb9adcde6358b5b4fb43efe2844192", "html_url": "https://github.com/rust-lang/rust/commit/b1435ed593fb9adcde6358b5b4fb43efe2844192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1435ed593fb9adcde6358b5b4fb43efe2844192/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5df5f56069de2778857597118a6e5f95d659736", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5df5f56069de2778857597118a6e5f95d659736", "html_url": "https://github.com/rust-lang/rust/commit/e5df5f56069de2778857597118a6e5f95d659736"}], "stats": {"total": 146, "additions": 146, "deletions": 0}, "files": [{"sha": "0f96b7f9ab89683983218b5760aa3414283cdb5d", "filename": "src/doc/guide.md", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/b1435ed593fb9adcde6358b5b4fb43efe2844192/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1435ed593fb9adcde6358b5b4fb43efe2844192/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=b1435ed593fb9adcde6358b5b4fb43efe2844192", "patch": "@@ -3626,6 +3626,152 @@ guide](http://doc.rust-lang.org/guide-pointers.html#rc-and-arc).\n \n # Tasks\n \n+Concurrency and parallelism are topics that are of increasing interest to a\n+broad subsection of software developers. Modern computers are often multi-core,\n+to the point that even embedded devices like cell phones have more than one\n+processor. Rust's semantics lend themselves very nicely to solving a number of\n+issues that programmers have with concurrency. Many concurrency errors that are\n+runtime errors in other languages are compile-time errors in Rust.\n+\n+Rust's concurrency primitive is called a **task**. Tasks are lightweight, and\n+do not share memory in an unsafe manner, preferring message passing to\n+communicate.  It's worth noting that tasks are implemented as a library, and\n+not part of the language.  This means that in the future, other concurrency\n+libraries can be written for Rust to help in specific scenarios.  Here's an\n+example of creating a task:\n+\n+```{rust}\n+spawn(proc() {\n+    println!(\"Hello from a task!\");\n+});\n+```\n+\n+The `spawn` function takes a proc as an argument, and runs that proc in a new\n+task. A proc takes ownership of its entire environment, and so any variables\n+that you use inside the proc will not be usable afterward:\n+\n+```{rust,ignore}\n+let mut x = vec![1i, 2i, 3i];\n+\n+spawn(proc() {\n+    println!(\"The value of x[0] is: {}\", x[0]);\n+});\n+\n+println!(\"The value of x[0] is: {}\", x[0]); // error: use of moved value: `x`\n+```\n+\n+`x` is now owned by the proc, and so we can't use it anymore. Many other\n+languages would let us do this, but it's not safe to do so. Rust's type system\n+catches the error.\n+\n+If tasks were only able to capture these values, they wouldn't be very useful.\n+Luckily, tasks can communicate with each other through **channel**s. Channels\n+work like this:\n+\n+```{rust}\n+let (tx, rx) = channel();\n+\n+spawn(proc() {\n+    tx.send(\"Hello from a task!\".to_string());\n+});\n+\n+let message = rx.recv();\n+println!(\"{}\", message);\n+```\n+\n+The `channel()` function returns two endpoints: a `Receiver<T>` and a\n+`Sender<T>`. You can use the `.send()` method on the `Sender<T>` end, and\n+receive the message on the `Receiver<T>` side with the `recv()` method.  This\n+method blocks until it gets a message. There's a similar method, `.try_recv()`,\n+which returns an `Option<T>` and does not block.\n+\n+If you want to send messages to the task as well, create two channels!\n+\n+```{rust}\n+let (tx1, rx1) = channel();\n+let (tx2, rx2) = channel();\n+\n+spawn(proc() {\n+    tx1.send(\"Hello from a task!\".to_string());\n+    let message = rx2.recv();\n+    println!(\"{}\", message);\n+});\n+\n+let message = rx1.recv();\n+println!(\"{}\", message);\n+\n+tx2.send(\"Goodbye from main!\".to_string());\n+```\n+\n+The proc has one sending end and one receiving end, and the main task has one\n+of each as well. Now they can talk back and forth in whatever way they wish.\n+\n+Notice as well that because `Sender` and `Receiver` are generic, while you can\n+pass any kind of information through the channel, the ends are strongly typed.\n+If you try to pass a string, and then an integer, Rust will complain.\n+\n+## Futures\n+\n+With these basic primitives, many different concurrency patterns can be\n+developed. Rust includes some of these types in its standard library. For\n+example, if you wish to compute some value in the background, `Future` is\n+a useful thing to use:\n+\n+```{rust}\n+use std::sync::Future;\n+\n+let mut delayed_value = Future::spawn(proc() {\n+    // just return anything for examples' sake\n+\n+    12345i\n+});\n+println!(\"value = {}\", delayed_value.get());\n+```\n+\n+Calling `Future::spawn` works just like `spawn()`: it takes a proc. In this\n+case, though, you don't need to mess with the channel: just have the proc\n+return the value.\n+\n+`Future::spawn` will return a value which we can bind with `let`. It needs\n+to be mutable, because once the value is computed, it saves a copy of the\n+value, and if it were immutable, it couldn't update itself.\n+\n+The proc will go on processing in the background, and when we need the final\n+value, we can call `get()` on it. This will block until the result is done,\n+but if it's finished computing in the background, we'll just get the value\n+immediately.\n+\n+## Success and failure\n+\n+Tasks don't always succeed, they can also fail. A task that wishes to fail\n+can call the `fail!` macro, passing a message:\n+\n+```{rust}\n+spawn(proc() {\n+    fail!(\"Nope.\");\n+});\n+```\n+\n+If a task fails, it is not possible for it to recover. However, it can\n+notify other tasks that it has failed. We can do this with `task::try`:\n+\n+```{rust}\n+use std::task;\n+use std::rand;\n+\n+let result = task::try(proc() {\n+    if rand::random() {\n+        println!(\"OK\");\n+    } else {\n+        fail!(\"oops!\");\n+    }\n+});\n+```\n+\n+This task will randomly fail or succeed. `task::try` returns a `Result`\n+type, so we can handle the response like any other computation that may\n+fail.\n+\n # Macros\n \n # Unsafe"}]}