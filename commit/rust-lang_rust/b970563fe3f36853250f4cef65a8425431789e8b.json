{"sha": "b970563fe3f36853250f4cef65a8425431789e8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NzA1NjNmZTNmMzY4NTMyNTBmNGNlZjY1YTg0MjU0MzE3ODllOGI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-30T00:22:07Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-30T00:22:13Z"}, "message": "Patchwork of attempted fixes to effect system and gc system; eventually give up and disable it entirely in the runtime. Will need extensive reworking.", "tree": {"sha": "c09d7d39a46419c24ea88164ee047c10ebd7da39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c09d7d39a46419c24ea88164ee047c10ebd7da39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b970563fe3f36853250f4cef65a8425431789e8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b970563fe3f36853250f4cef65a8425431789e8b", "html_url": "https://github.com/rust-lang/rust/commit/b970563fe3f36853250f4cef65a8425431789e8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b970563fe3f36853250f4cef65a8425431789e8b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e733bf2ee0c23be5a49fd81a419d3e69c38be27", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e733bf2ee0c23be5a49fd81a419d3e69c38be27", "html_url": "https://github.com/rust-lang/rust/commit/7e733bf2ee0c23be5a49fd81a419d3e69c38be27"}], "stats": {"total": 296, "additions": 185, "deletions": 111}, "files": [{"sha": "c16fec3608cc734aebe30efb7099efdf4e007f2d", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=b970563fe3f36853250f4cef65a8425431789e8b", "patch": "@@ -103,7 +103,7 @@ let iterator_args_elt_outer_frame_ptr = 1;;\n let indirect_args_elt_closure = 0;;\n \n (* Current worst case is by vec grow glue *)\n-let worst_case_glue_call_args = 7;;\n+let worst_case_glue_call_args = 8;;\n \n type abi =\n   {"}, {"sha": "fb5c2aec37ef04b4bd2aed9f1676120f9b33526d", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=b970563fe3f36853250f4cef65a8425431789e8b", "patch": "@@ -1893,34 +1893,38 @@ let trans_visitor\n       get_typed_mem_glue g fty inner\n \n   (*\n-   * Vector-growth glue takes four arguments:\n+   * Vector-growth glue takes the following arguments:\n    *\n    *   0. (Implicit) task ptr\n    *   1. Pointer to the typarams of the caller's frame (possibly required to\n    *      be passed to element's copy glue).\n-   *   2. Pointer to tydesc of the vec's stored element type, so that elements\n+   *   2. Pointer to the tydesc of the vec, so that we can tell if it's gc\n+   *      mem, and have a tydesc to pass to malloc if we're allocating anew.\n+   *   3. Pointer to tydesc of the vec's stored element type, so that elements\n    *      can be copied to a newly alloc'ed vec if one must be created.\n-   *   3. Alias to vec that needs to grow (i.e. ptr to ptr to rust_vec).\n-   *   4. Number of bytes of growth requested\n+   *   4. Alias to vec that needs to grow (i.e. ptr to ptr to rust_vec).\n+   *   5. Number of bytes of growth requested\n    *)\n   and emit_vec_grow_glue\n       (fix:fixup)\n       (g:glue)\n       : unit =\n     let arg_typarams_ptr = 0 in\n-    let arg_tydesc_ptr = 1 in\n-    let arg_vec_alias = 2 in\n-    let arg_nbytes = 3 in\n+    let arg_vec_tydesc_ptr = 1 in\n+    let arg_elt_tydesc_ptr = 2 in\n+    let arg_vec_alias = 3 in\n+    let arg_nbytes = 4 in\n \n     let name = glue_str cx g in\n       log cx \"emitting glue: %s\" name;\n \n       let fn_ty =\n         mk_simple_ty_fn\n           [| ty_params_covering Ast.TY_int;      (* an OK lie *)\n+             local_slot Ast.TY_type;\n              local_slot Ast.TY_type;\n              alias_slot (Ast.TY_vec Ast.TY_int); (* an OK lie *)\n-             local_slot Ast.TY_uint; |]\n+             local_slot Ast.TY_uint |]\n       in\n \n       let args_rty = call_args_referent_type cx 0 fn_ty None in\n@@ -1936,7 +1940,8 @@ let trans_visitor\n         let vec_alias_cell = get_element_ptr args_cell arg_vec_alias in\n         let vec_cell = deref vec_alias_cell in\n         let nbytes_cell = get_element_ptr args_cell arg_nbytes in\n-        let td_ptr_cell = get_element_ptr args_cell arg_tydesc_ptr in\n+        let vec_td_ptr_cell = get_element_ptr args_cell arg_vec_tydesc_ptr in\n+        let elt_td_ptr_cell = get_element_ptr args_cell arg_elt_tydesc_ptr in\n         let ty_params_cell =\n           deref (get_element_ptr args_cell arg_typarams_ptr)\n         in\n@@ -1951,7 +1956,8 @@ let trans_visitor\n                   new_vec_cell\n                   [| Il.Cell vec_cell;\n                      Il.Cell nbytes_cell;\n-                     Il.Cell need_copy_alias_cell |]\n+                     Il.Cell need_copy_alias_cell;\n+                     Il.Cell vec_td_ptr_cell; |]\n             end;\n \n           let no_copy_jmps =\n@@ -1965,7 +1971,7 @@ let trans_visitor\n               get_element_ptr_dyn ty_params_cell src_vec Abi.vec_elt_fill\n             in\n             let elt_sz =\n-              get_element_ptr (deref td_ptr_cell) Abi.tydesc_field_size\n+              get_element_ptr (deref elt_td_ptr_cell) Abi.tydesc_field_size\n             in\n \n             let dst_buf =\n@@ -1993,11 +1999,11 @@ let trans_visitor\n \n                 (* Copy *)\n                 let ty_params_ptr =\n-                  get_tydesc_params ty_params_cell td_ptr_cell\n+                  get_tydesc_params ty_params_cell elt_td_ptr_cell\n                 in\n                 let initflag = Il.Reg (force_to_reg one) in\n                   trans_call_dynamic_glue\n-                    td_ptr_cell\n+                    elt_td_ptr_cell\n                     Abi.tydesc_field_copy_glue\n                     (Some (deref dptr))\n                     [| ty_params_ptr; sptr; initflag |]\n@@ -2971,8 +2977,8 @@ let trans_visitor\n       (ty:Ast.ty)\n       : unit =\n \n-    let ty = strip_mutable_or_constrained_ty ty in\n     let mctrl = ty_mem_ctrl cx ty in\n+    let ty = strip_mutable_or_constrained_ty ty in\n \n       match ty with\n \n@@ -3173,7 +3179,7 @@ let trans_visitor\n     check_box_rty cell;\n     note_drop_step ty \"in free-ty\";\n     begin\n-    match simplified_ty ty with\n+    match strip_mutable_or_constrained_ty ty with\n         Ast.TY_port _ -> trans_del_port cell\n       | Ast.TY_chan _ -> trans_del_chan cell\n       | Ast.TY_task -> trans_kill_task cell\n@@ -3183,14 +3189,13 @@ let trans_visitor\n              (fun _ src ty -> drop_ty ty_params src ty);\n              trans_free cell is_gc\n \n-      | _ ->\n+      | Ast.TY_box body_ty ->\n           note_drop_step ty \"in free-ty, dropping structured body\";\n           let (body_mem, _) =\n             need_mem_cell\n               (get_element_ptr_dyn ty_params (deref cell)\n                  Abi.box_rc_field_body)\n           in\n-          let body_ty = simplified_ty ty in\n           let vr = next_vreg_cell Il.voidptr_t in\n             lea vr body_mem;\n             trace_word cx.ctxt_sess.Session.sess_trace_drop vr;\n@@ -3201,6 +3206,8 @@ let trans_visitor\n               None;\n             note_drop_step ty \"in free-ty, calling free\";\n             trans_free cell is_gc;\n+\n+      | t -> bug () \"freeing unexpected type: %a\" Ast.sprintf_ty t\n     end;\n     note_drop_step ty \"free-ty done\";\n \n@@ -3268,13 +3275,17 @@ let trans_visitor\n       (slot:Ast.slot)\n       : unit =\n       check_and_flush_chan cell slot;\n-      drop_slot (get_ty_params_of_current_frame()) cell slot\n+      drop_slot (get_ty_params_of_current_frame()) cell\n+        { slot with\n+            Ast.slot_ty = Some (strip_mutable_or_constrained_ty\n+                                  (slot_ty slot)) }\n \n   and drop_ty_in_current_frame\n       (cell:Il.cell)\n       (ty:Ast.ty)\n       : unit =\n-    drop_ty (get_ty_params_of_current_frame()) cell ty\n+    drop_ty (get_ty_params_of_current_frame()) cell\n+      (strip_mutable_or_constrained_ty ty)\n \n   (* Returns a mark for a jmp that must be patched to the continuation of\n    * the null case (i.e. fall-through means not null).\n@@ -4755,7 +4766,8 @@ let trans_visitor\n                     trans_call_simple_static_glue\n                       (get_vec_grow_glue ())\n                       (get_ty_params_of_current_frame ())\n-                      [| get_tydesc None elt_ty;\n+                      [| get_tydesc None dst_ty;\n+                         get_tydesc None elt_ty;\n                          dst_vec_alias;\n                          src_fill; |]\n                       None\n@@ -4827,7 +4839,8 @@ let trans_visitor\n                     trans_call_simple_static_glue\n                       (get_vec_grow_glue ())\n                       (get_ty_params_of_current_frame ())\n-                      [| get_tydesc None elt_ty;\n+                      [| get_tydesc None dst_ty;\n+                         get_tydesc None elt_ty;\n                          dst_vec_alias;\n                          elt_sz_cell; |]\n                       None"}, {"sha": "b9e4aef157362ef9facc3c904756a2050dc6f7bc", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=b970563fe3f36853250f4cef65a8425431789e8b", "patch": "@@ -4,7 +4,7 @@ import front.parser;\n import front.token;\n import middle.trans;\n \n-fn main(vec[str] args) {\n+io fn main(vec[str] args) {\n \n   log \"This is the rust 'self-hosted' compiler.\";\n   log \"The one written in rust.\";"}, {"sha": "f38f5024fe0a93d3124e0eb21a8b0cd6d350e99c", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=b970563fe3f36853250f4cef65a8425431789e8b", "patch": "@@ -9,8 +9,8 @@ state type reader = state obj {\n                           fn is_eof() -> bool;\n                           fn curr() -> char;\n                           fn next() -> char;\n-                          state fn bump();\n-                          state fn mark();\n+                          io fn bump();\n+                          fn mark();\n                           fn get_filename() -> str;\n                           fn get_mark_pos() -> common.pos;\n                           fn get_curr_pos() -> common.pos;\n@@ -55,7 +55,7 @@ fn new_reader(stdio_reader rdr, str filename) -> reader\n                 ret n;\n             }\n \n-            state fn bump() {\n+            io fn bump() {\n                 c = n;\n \n                 if (c == (-1) as char) {\n@@ -72,7 +72,7 @@ fn new_reader(stdio_reader rdr, str filename) -> reader\n                 n = rdr.getc() as char;\n             }\n \n-            state fn mark() {\n+            fn mark() {\n                 mark_line = line;\n                 mark_col = col;\n             }\n@@ -243,14 +243,14 @@ fn is_whitespace(char c) -> bool {\n     ret c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n-state fn consume_any_whitespace(reader rdr) {\n+io fn consume_any_whitespace(reader rdr) {\n     while (is_whitespace(rdr.curr())) {\n         rdr.bump();\n     }\n     be consume_any_line_comment(rdr);\n }\n \n-state fn consume_any_line_comment(reader rdr) {\n+io fn consume_any_line_comment(reader rdr) {\n     if (rdr.curr() == '/') {\n         alt (rdr.next()) {\n             case ('/') {\n@@ -273,7 +273,7 @@ state fn consume_any_line_comment(reader rdr) {\n }\n \n \n-state fn consume_block_comment(reader rdr) {\n+io fn consume_block_comment(reader rdr) {\n     let int level = 1;\n     while (level > 0) {\n         if (rdr.curr() == '/' && rdr.next() == '*') {\n@@ -294,7 +294,7 @@ state fn consume_block_comment(reader rdr) {\n     be consume_any_whitespace(rdr);\n }\n \n-state fn next_token(reader rdr) -> token.token {\n+io fn next_token(reader rdr) -> token.token {\n     auto accum_str = \"\";\n     auto accum_int = 0;\n \n@@ -355,7 +355,7 @@ state fn next_token(reader rdr) -> token.token {\n         ret token.LIT_INT(accum_int);\n     }\n \n-    state fn binop(reader rdr, token.binop op) -> token.token {\n+    io fn binop(reader rdr, token.binop op) -> token.token {\n         rdr.bump();\n         if (rdr.next() == '=') {\n             rdr.bump();"}, {"sha": "44bddf088737fda552a335978eb7255e8805f370", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=b970563fe3f36853250f4cef65a8425431789e8b", "patch": "@@ -14,26 +14,26 @@ tag option[T] {\n \n state type parser =\n     state obj {\n-          state fn peek() -> token.token;\n-          state fn bump();\n+          fn peek() -> token.token;\n+          io fn bump();\n           io fn err(str s);\n           fn get_session() -> session.session;\n           fn get_span() -> common.span;\n     };\n \n-state fn new_parser(session.session sess, str path) -> parser {\n+io fn new_parser(session.session sess, str path) -> parser {\n     state obj stdio_parser(session.session sess,\n                            mutable token.token tok,\n                            mutable common.pos lo,\n                            mutable common.pos hi,\n                            lexer.reader rdr)\n         {\n-            state fn peek() -> token.token {\n+            fn peek() -> token.token {\n                 log token.to_str(tok);\n                 ret tok;\n             }\n \n-            state fn bump() {\n+            io fn bump() {\n                 tok = lexer.next_token(rdr);\n                 lo = rdr.get_mark_pos();\n                 hi = rdr.get_curr_pos();\n@@ -60,7 +60,7 @@ state fn new_parser(session.session sess, str path) -> parser {\n     ret stdio_parser(sess, lexer.next_token(rdr), npos, npos, rdr);\n }\n \n-state fn expect(parser p, token.token t) {\n+io fn expect(parser p, token.token t) {\n     if (p.peek() == t) {\n         p.bump();\n     } else {\n@@ -72,7 +72,7 @@ state fn expect(parser p, token.token t) {\n     }\n }\n \n-state fn parse_ident(parser p) -> ast.ident {\n+io fn parse_ident(parser p) -> ast.ident {\n     alt (p.peek()) {\n         case (token.IDENT(?i)) { p.bump(); ret i; }\n         case (_) {\n@@ -82,7 +82,7 @@ state fn parse_ident(parser p) -> ast.ident {\n     }\n }\n \n-state fn parse_ty(parser p) -> ast.ty {\n+io fn parse_ty(parser p) -> ast.ty {\n     alt (p.peek()) {\n         case (token.INT) { p.bump(); ret ast.ty_int; }\n         case (token.UINT) { p.bump(); ret ast.ty_int; }\n@@ -94,7 +94,7 @@ state fn parse_ty(parser p) -> ast.ty {\n     fail;\n }\n \n-state fn parse_slot(parser p) -> ast.slot {\n+io fn parse_slot(parser p) -> ast.slot {\n     let ast.mode m = ast.val;\n     if (p.peek() == token.BINOP(token.AND)) {\n         m = ast.alias;\n@@ -104,10 +104,10 @@ state fn parse_slot(parser p) -> ast.slot {\n     ret rec(ty=t, mode=m);\n }\n \n-state fn parse_seq[T](token.token bra,\n+io fn parse_seq[T](token.token bra,\n                       token.token ket,\n                       option[token.token] sep,\n-                      (state fn(parser) -> T) f,\n+                      (io fn(parser) -> T) f,\n                       parser p) -> vec[T] {\n     let bool first = true;\n     expect(p, bra);\n@@ -132,7 +132,7 @@ state fn parse_seq[T](token.token bra,\n     ret v;\n }\n \n-state fn parse_lit(parser p) -> @ast.lit {\n+io fn parse_lit(parser p) -> @ast.lit {\n     alt (p.peek()) {\n         case (token.LIT_INT(?i)) {\n             p.bump();\n@@ -161,7 +161,7 @@ state fn parse_lit(parser p) -> @ast.lit {\n \n \n \n-state fn parse_bottom_expr(parser p) -> @ast.expr {\n+io fn parse_bottom_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n         case (token.LPAREN) {\n             p.bump();\n@@ -192,7 +192,7 @@ state fn parse_bottom_expr(parser p) -> @ast.expr {\n \n         case (token.REC) {\n             p.bump();\n-            state fn parse_entry(parser p) ->\n+            io fn parse_entry(parser p) ->\n                 tup(ast.ident, @ast.expr) {\n                 auto i = parse_ident(p);\n                 expect(p, token.EQ);\n@@ -219,7 +219,7 @@ state fn parse_bottom_expr(parser p) -> @ast.expr {\n     }\n }\n \n-state fn parse_path_expr(parser p) -> @ast.expr {\n+io fn parse_path_expr(parser p) -> @ast.expr {\n     auto e = parse_bottom_expr(p);\n     while (true) {\n         alt (p.peek()) {\n@@ -246,7 +246,7 @@ state fn parse_path_expr(parser p) -> @ast.expr {\n     ret e;\n }\n \n-state fn parse_prefix_expr(parser p) -> @ast.expr {\n+io fn parse_prefix_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n \n         case (token.NOT) {\n@@ -294,8 +294,8 @@ state fn parse_prefix_expr(parser p) -> @ast.expr {\n     }\n }\n \n-state fn parse_binops(parser p,\n-                      (state fn(parser) -> @ast.expr) sub,\n+io fn parse_binops(parser p,\n+                      (io fn(parser) -> @ast.expr) sub,\n                       vec[tup(token.binop, ast.binop)] ops)\n     -> @ast.expr {\n     auto e = sub(p);\n@@ -317,8 +317,8 @@ state fn parse_binops(parser p,\n     ret e;\n }\n \n-state fn parse_binary_exprs(parser p,\n-                            (state fn(parser) -> @ast.expr) sub,\n+io fn parse_binary_exprs(parser p,\n+                            (io fn(parser) -> @ast.expr) sub,\n                             vec[tup(token.token, ast.binop)] ops)\n     -> @ast.expr {\n     auto e = sub(p);\n@@ -336,42 +336,42 @@ state fn parse_binary_exprs(parser p,\n     ret e;\n }\n \n-state fn parse_factor_expr(parser p) -> @ast.expr {\n+io fn parse_factor_expr(parser p) -> @ast.expr {\n     auto sub = parse_prefix_expr;\n     ret parse_binops(p, sub, vec(tup(token.STAR, ast.mul),\n                                  tup(token.SLASH, ast.div),\n                                  tup(token.PERCENT, ast.rem)));\n }\n \n-state fn parse_term_expr(parser p) -> @ast.expr {\n+io fn parse_term_expr(parser p) -> @ast.expr {\n     auto sub = parse_factor_expr;\n     ret parse_binops(p, sub, vec(tup(token.PLUS, ast.add),\n                                  tup(token.MINUS, ast.sub)));\n }\n \n-state fn parse_shift_expr(parser p) -> @ast.expr {\n+io fn parse_shift_expr(parser p) -> @ast.expr {\n     auto sub = parse_term_expr;\n     ret parse_binops(p, sub, vec(tup(token.LSL, ast.lsl),\n                                  tup(token.LSR, ast.lsr),\n                                  tup(token.ASR, ast.asr)));\n }\n \n-state fn parse_bitand_expr(parser p) -> @ast.expr {\n+io fn parse_bitand_expr(parser p) -> @ast.expr {\n     auto sub = parse_shift_expr;\n     ret parse_binops(p, sub, vec(tup(token.AND, ast.bitand)));\n }\n \n-state fn parse_bitxor_expr(parser p) -> @ast.expr {\n+io fn parse_bitxor_expr(parser p) -> @ast.expr {\n     auto sub = parse_bitand_expr;\n     ret parse_binops(p, sub, vec(tup(token.CARET, ast.bitxor)));\n }\n \n-state fn parse_bitor_expr(parser p) -> @ast.expr {\n+io fn parse_bitor_expr(parser p) -> @ast.expr {\n     auto sub = parse_bitxor_expr;\n     ret parse_binops(p, sub, vec(tup(token.OR, ast.bitor)));\n }\n \n-state fn parse_cast_expr(parser p) -> @ast.expr {\n+io fn parse_cast_expr(parser p) -> @ast.expr {\n     auto e = parse_bitor_expr(p);\n     while (true) {\n         alt (p.peek()) {\n@@ -389,7 +389,7 @@ state fn parse_cast_expr(parser p) -> @ast.expr {\n     ret e;\n }\n \n-state fn parse_relational_expr(parser p) -> @ast.expr {\n+io fn parse_relational_expr(parser p) -> @ast.expr {\n     auto sub = parse_cast_expr;\n     ret parse_binary_exprs(p, sub, vec(tup(token.LT, ast.lt),\n                                        tup(token.LE, ast.le),\n@@ -398,27 +398,27 @@ state fn parse_relational_expr(parser p) -> @ast.expr {\n }\n \n \n-state fn parse_equality_expr(parser p) -> @ast.expr {\n+io fn parse_equality_expr(parser p) -> @ast.expr {\n     auto sub = parse_relational_expr;\n     ret parse_binary_exprs(p, sub, vec(tup(token.EQEQ, ast.eq),\n                                        tup(token.NE, ast.ne)));\n }\n \n-state fn parse_and_expr(parser p) -> @ast.expr {\n+io fn parse_and_expr(parser p) -> @ast.expr {\n     auto sub = parse_equality_expr;\n     ret parse_binary_exprs(p, sub, vec(tup(token.ANDAND, ast.and)));\n }\n \n-state fn parse_or_expr(parser p) -> @ast.expr {\n+io fn parse_or_expr(parser p) -> @ast.expr {\n     auto sub = parse_and_expr;\n     ret parse_binary_exprs(p, sub, vec(tup(token.OROR, ast.or)));\n }\n \n-state fn parse_expr(parser p) -> @ast.expr {\n+io fn parse_expr(parser p) -> @ast.expr {\n     ret parse_or_expr(p);\n }\n \n-state fn parse_stmt(parser p) -> @ast.stmt {\n+io fn parse_stmt(parser p) -> @ast.stmt {\n     alt (p.peek()) {\n         case (token.LOG) {\n             p.bump();\n@@ -431,7 +431,7 @@ state fn parse_stmt(parser p) -> @ast.stmt {\n     fail;\n }\n \n-state fn parse_block(parser p) -> ast.block {\n+io fn parse_block(parser p) -> ast.block {\n     auto f = parse_stmt;\n     // FIXME: passing parse_stmt as an lval doesn't work at the moment.\n     ret parse_seq[@ast.stmt](token.LBRACE,\n@@ -440,14 +440,14 @@ state fn parse_block(parser p) -> ast.block {\n                              f, p);\n }\n \n-state fn parse_slot_ident_pair(parser p) ->\n+io fn parse_slot_ident_pair(parser p) ->\n     rec(ast.slot slot, ast.ident ident) {\n     auto s = parse_slot(p);\n     auto i = parse_ident(p);\n     ret rec(slot=s, ident=i);\n }\n \n-state fn parse_fn(parser p) -> tup(ast.ident, ast.item) {\n+io fn parse_fn(parser p) -> tup(ast.ident, ast.item) {\n     expect(p, token.FN);\n     auto id = parse_ident(p);\n     auto pf = parse_slot_ident_pair;\n@@ -477,7 +477,7 @@ state fn parse_fn(parser p) -> tup(ast.ident, ast.item) {\n     ret tup(id, ast.item_fn(@f));\n }\n \n-state fn parse_mod(parser p) -> tup(ast.ident, ast.item) {\n+io fn parse_mod(parser p) -> tup(ast.ident, ast.item) {\n     expect(p, token.MOD);\n     auto id = parse_ident(p);\n     expect(p, token.LBRACE);\n@@ -490,7 +490,7 @@ state fn parse_mod(parser p) -> tup(ast.ident, ast.item) {\n     ret tup(id, ast.item_mod(@m));\n }\n \n-state fn parse_item(parser p) -> tup(ast.ident, ast.item) {\n+io fn parse_item(parser p) -> tup(ast.ident, ast.item) {\n     alt (p.peek()) {\n         case (token.FN) {\n             ret parse_fn(p);\n@@ -503,7 +503,7 @@ state fn parse_item(parser p) -> tup(ast.ident, ast.item) {\n     fail;\n }\n \n-state fn parse_crate(parser p) -> ast.crate {\n+io fn parse_crate(parser p) -> ast.crate {\n     let ast._mod m = new_str_hash[ast.item]();\n     while (p.peek() != token.EOF) {\n         auto i = parse_item(p);"}, {"sha": "1828271fd309fd3728a2b8d415f014dfd6534505", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 69, "deletions": 19, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b970563fe3f36853250f4cef65a8425431789e8b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b970563fe3f36853250f4cef65a8425431789e8b", "patch": "@@ -50,10 +50,28 @@ state type fn_ctxt = rec(ValueRef llfn,\n \n type terminator = fn(@fn_ctxt cx, builder build);\n \n-type block_ctxt = rec(BasicBlockRef llbb,\n-                      builder build,\n-                      terminator term,\n-                      @fn_ctxt fcx);\n+tag cleanup {\n+    clean(fn(@block_ctxt cx, ValueRef v), ValueRef);\n+}\n+\n+state type block_ctxt = rec(BasicBlockRef llbb,\n+                            builder build,\n+                            terminator term,\n+                            mutable vec[cleanup] cleanups,\n+                            @fn_ctxt fcx);\n+\n+\n+fn ty_str(TypeRef t) -> str {\n+    ret lib.llvm.type_to_str(t);\n+}\n+\n+fn val_ty(ValueRef v) -> TypeRef {\n+    ret llvm.LLVMTypeOf(v);\n+}\n+\n+fn val_str(ValueRef v) -> str {\n+    ret ty_str(val_ty(v));\n+}\n \n \n // LLVM type constructors.\n@@ -120,6 +138,12 @@ fn T_task() -> TypeRef {\n                      ));\n }\n \n+fn T_str() -> TypeRef {\n+    ret T_struct(vec(T_int(),      // Refcount\n+                     T_int()       // Lie about the remainder\n+                     ));\n+}\n+\n fn T_crate() -> TypeRef {\n     ret T_struct(vec(T_int(),      // ptrdiff_t image_base_off\n                      T_int(),      // uintptr_t self_addr\n@@ -134,7 +158,7 @@ fn T_crate() -> TypeRef {\n                      T_int(),      // size_t main_exit_task_glue_off\n                      T_int(),      // int n_rust_syms\n                      T_int(),      // int n_c_syms\n-                     T_int()       //int n_libs\n+                     T_int()       // int n_libs\n                      ));\n }\n \n@@ -146,7 +170,6 @@ fn T_taskptr() -> TypeRef {\n     ret T_ptr(T_task());\n }\n \n-\n // LLVM constant constructors.\n \n fn C_null(TypeRef t) -> ValueRef {\n@@ -177,7 +200,7 @@ fn C_int(int i) -> ValueRef {\n \n fn C_str(@trans_ctxt cx, str s) -> ValueRef {\n     auto sc = llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n-    auto g = llvm.LLVMAddGlobal(cx.llmod, llvm.LLVMTypeOf(sc),\n+    auto g = llvm.LLVMAddGlobal(cx.llmod, val_ty(sc),\n                                 _str.buf(cx.names.next(\"str\")));\n     llvm.LLVMSetInitializer(g, sc);\n     ret g;\n@@ -192,7 +215,7 @@ fn C_struct(vec[ValueRef] elts) -> ValueRef {\n fn decl_cdecl_fn(ModuleRef llmod, str name,\n                  vec[TypeRef] inputs, TypeRef output) -> ValueRef {\n     let TypeRef llty = T_fn(inputs, output);\n-    log \"declaring \" + name + \" with type \" + lib.llvm.type_to_str(llty);\n+    log \"declaring \" + name + \" with type \" + ty_str(llty);\n     let ValueRef llfn =\n         llvm.LLVMAddFunction(llmod, _str.buf(name), llty);\n     llvm.LLVMSetFunctionCallConv(llfn, lib.llvm.LLVMCCallConv);\n@@ -224,7 +247,7 @@ fn get_upcall(@trans_ctxt cx, str name, int n_args) -> ValueRef {\n     }\n     auto inputs = vec(T_taskptr());\n     inputs += _vec.init_elt[TypeRef](T_int(), n_args as uint);\n-    auto output = T_nil();\n+    auto output = T_int();\n     auto f = decl_cdecl_fn(cx.llmod, name, inputs, output);\n     cx.upcalls.insert(name, f);\n     ret f;\n@@ -240,15 +263,26 @@ fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> ValueRef {\n     for (ValueRef a in args) {\n         call_args += cx.build.ZExtOrBitCast(a, T_int());\n     }\n-    log \"emitting indirect-upcall via \" + abi.upcall_glue_name(n);\n-    for (ValueRef v in call_args) {\n-        log \"arg: \" + lib.llvm.type_to_str(llvm.LLVMTypeOf(v));\n-    }\n-    log \"emitting call to callee of type: \" +\n-        lib.llvm.type_to_str(llvm.LLVMTypeOf(llglue));\n+    /*\n+     log \"emitting indirect-upcall via \" + abi.upcall_glue_name(n);\n+     for (ValueRef v in call_args) {\n+       log \"arg: \" + val_str(v);\n+     }\n+     log \"emitting call to llglue of type: \" + val_str(llglue);\n+    */\n+\n     ret cx.build.Call(llglue, call_args);\n }\n \n+fn build_non_gc_free(@block_ctxt cx, ValueRef v) {\n+    trans_upcall(cx, \"upcall_free\", vec(cx.build.PtrToInt(v, T_int()),\n+                                        C_int(0)));\n+}\n+\n+fn drop_str(@block_ctxt cx, ValueRef v) {\n+    build_non_gc_free(cx, v);\n+}\n+\n fn trans_lit(@block_ctxt cx, &ast.lit lit) -> ValueRef {\n     alt (lit) {\n         case (ast.lit_int(?i)) {\n@@ -265,9 +299,13 @@ fn trans_lit(@block_ctxt cx, &ast.lit lit) -> ValueRef {\n         }\n         case (ast.lit_str(?s)) {\n             auto len = (_str.byte_len(s) as int) + 1;\n-            ret trans_upcall(cx, \"upcall_new_str\",\n-                             vec(p2i(C_str(cx.fcx.tcx, s)),\n-                                 C_int(len)));\n+            auto v = trans_upcall(cx, \"upcall_new_str\",\n+                                  vec(p2i(C_str(cx.fcx.tcx, s)),\n+                                      C_int(len)));\n+            v = cx.build.IntToPtr(v, T_ptr(T_str()));\n+            auto f = drop_str;\n+            cx.cleanups += vec(clean(f, v));\n+            ret v;\n         }\n     }\n }\n@@ -402,7 +440,8 @@ fn trans_log(@block_ctxt cx, &ast.expr e) {\n             alt (*lit) {\n                 case (ast.lit_str(_)) {\n                     auto v = trans_expr(cx, e);\n-                    trans_upcall(cx, \"upcall_log_str\", vec(v));\n+                    trans_upcall(cx, \"upcall_log_str\",\n+                                 vec(cx.build.PtrToInt(v, T_int())));\n                 }\n                 case (_) {\n                     auto v = trans_expr(cx, e);\n@@ -441,9 +480,11 @@ fn new_builder(BasicBlockRef llbb) -> builder {\n fn new_block_ctxt(@fn_ctxt cx, terminator term) -> @block_ctxt {\n     let BasicBlockRef llbb =\n         llvm.LLVMAppendBasicBlock(cx.llfn, _str.buf(\"\"));\n+    let vec[cleanup] cleanups = vec();\n     ret @rec(llbb=llbb,\n              build=new_builder(llbb),\n              term=term,\n+             mutable cleanups=cleanups,\n              fcx=cx);\n }\n \n@@ -452,6 +493,15 @@ fn trans_block(@fn_ctxt cx, &ast.block b, terminator term) {\n     for (@ast.stmt s in b) {\n         trans_stmt(bcx, *s);\n     }\n+\n+    for (cleanup c in bcx.cleanups) {\n+        alt (c) {\n+            case (clean(?cfn, ?v)) {\n+                cfn(bcx, v);\n+            }\n+        }\n+    }\n+\n     bcx.term(cx, bcx.build);\n }\n "}, {"sha": "cdc2d0254151d7e0ebfcd16d0cd4539c1721d6d9", "filename": "src/lib/map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b970563fe3f36853250f4cef65a8425431789e8b/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b970563fe3f36853250f4cef65a8425431789e8b/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=b970563fe3f36853250f4cef65a8425431789e8b", "patch": "@@ -12,15 +12,15 @@ import std._vec;\n type hashfn[K] = fn(&K) -> uint;\n type eqfn[K] = fn(&K, &K) -> bool;\n \n-type hashmap[K, V] = obj {\n-                     fn size() -> uint;\n-                     fn insert(&K key, &V val) -> bool;\n-                     fn contains_key(&K key) -> bool;\n-                     fn get(&K key) -> V;\n-                     fn find(&K key) -> util.option[V];\n-                     fn remove(&K key) -> util.option[V];\n-                     fn rehash();\n-                     iter items() -> tup(K,V);\n+state type hashmap[K, V] = state obj {\n+                                 fn size() -> uint;\n+                                 fn insert(&K key, &V val) -> bool;\n+                                 fn contains_key(&K key) -> bool;\n+                                 fn get(&K key) -> V;\n+                                 fn find(&K key) -> util.option[V];\n+                                 fn remove(&K key) -> util.option[V];\n+                                 fn rehash();\n+                                 iter items() -> tup(K,V);\n };\n \n fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n@@ -141,12 +141,12 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n             }\n         }\n \n-    obj hashmap[K, V](hashfn[K] hasher,\n-                      eqfn[K] eqer,\n-                      mutable vec[mutable bucket[K, V]] bkts,\n-                      mutable uint nbkts,\n-                      mutable uint nelts,\n-                      util.rational lf)\n+    state obj hashmap[K, V](hashfn[K] hasher,\n+                            eqfn[K] eqer,\n+                            mutable vec[mutable bucket[K, V]] bkts,\n+                            mutable uint nbkts,\n+                            mutable uint nelts,\n+                            util.rational lf)\n         {\n             fn size() -> uint { ret nelts; }\n "}, {"sha": "97eeb4bff5d9ed16fe128444733644d8ee218d35", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b970563fe3f36853250f4cef65a8425431789e8b/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b970563fe3f36853250f4cef65a8425431789e8b/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=b970563fe3f36853250f4cef65a8425431789e8b", "patch": "@@ -488,6 +488,10 @@ rust_task::unlink_gc(gc_alloc *gcm) {\n void *\n rust_task::malloc(size_t sz, type_desc *td)\n {\n+    // FIXME: GC is disabled for now.\n+    // Effects, GC-memory classification are all wrong.\n+    td = NULL;\n+\n     if (td) {\n         sz += sizeof(gc_alloc);\n     }\n@@ -512,6 +516,9 @@ rust_task::malloc(size_t sz, type_desc *td)\n void *\n rust_task::realloc(void *data, size_t sz, bool is_gc)\n {\n+    // FIXME: GC is disabled for now.\n+    // Effects, GC-memory classification are all wrong.\n+    is_gc = false;\n     if (is_gc) {\n         gc_alloc *gcm = (gc_alloc*)(((char *)data) - sizeof(gc_alloc));\n         unlink_gc(gcm);\n@@ -534,6 +541,9 @@ rust_task::realloc(void *data, size_t sz, bool is_gc)\n void\n rust_task::free(void *p, bool is_gc)\n {\n+    // FIXME: GC is disabled for now.\n+    // Effects, GC-memory classification are all wrong.\n+    is_gc = false;\n     if (is_gc) {\n         gc_alloc *gcm = (gc_alloc*)(((char *)p) - sizeof(gc_alloc));\n         unlink_gc(gcm);"}, {"sha": "9742b22af78c01268b2e15a6f0566a4587b1009f", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b970563fe3f36853250f4cef65a8425431789e8b/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b970563fe3f36853250f4cef65a8425431789e8b/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=b970563fe3f36853250f4cef65a8425431789e8b", "patch": "@@ -312,8 +312,8 @@ upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n     dom->log(rust_log::UPCALL|rust_log::MEM,\n-             \"upcall free(0x%\" PRIxPTR \")\",\n-             (uintptr_t)ptr);\n+             \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n+             (uintptr_t)ptr, is_gc);\n     task->free(ptr, (bool) is_gc);\n }\n \n@@ -338,7 +338,7 @@ upcall_new_str(rust_task *task, char const *s, size_t fill) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n     size_t alloc = next_power_of_two(sizeof(rust_str) + fill);\n-    void *mem = dom->malloc(alloc);\n+    void *mem = task->malloc(alloc);\n     if (!mem) {\n         task->fail(3);\n         return NULL;\n@@ -373,7 +373,8 @@ extern \"C\" CDECL rust_vec *\n upcall_vec_grow(rust_task *task,\n                 rust_vec *v,\n                 size_t n_bytes,\n-                uintptr_t *need_copy)\n+                uintptr_t *need_copy,\n+                type_desc *td)\n {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n@@ -396,7 +397,7 @@ upcall_vec_grow(rust_task *task,\n \n         // Second-fastest path: can at least realloc.\n         task->log(rust_log::UPCALL | rust_log::MEM, \"realloc path\");\n-        v = (rust_vec*) dom->realloc(v, alloc);\n+        v = (rust_vec*) task->realloc(v, alloc, td->is_stateful);\n         if (!v) {\n             task->fail(4);\n             return NULL;\n@@ -418,7 +419,7 @@ upcall_vec_grow(rust_task *task,\n          * that we need the copies performed for us.\n          */\n         task->log(rust_log::UPCALL | rust_log::MEM, \"new vec path\");\n-        void *mem = dom->malloc(alloc);\n+        void *mem = task->malloc(alloc, td);\n         if (!mem) {\n             task->fail(4);\n             return NULL;"}]}