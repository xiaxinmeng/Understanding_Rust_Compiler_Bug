{"sha": "829d94940ebb07a49f5d841d2adc66947678ed5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyOWQ5NDk0MGViYjA3YTQ5ZjVkODQxZDJhZGM2Njk0NzY3OGVkNWM=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-05T07:25:33Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-05T07:25:33Z"}, "message": "Factor out process_comment()", "tree": {"sha": "084e67ba3745cae7201458e5ce7dba735b1c4739", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/084e67ba3745cae7201458e5ce7dba735b1c4739"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/829d94940ebb07a49f5d841d2adc66947678ed5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/829d94940ebb07a49f5d841d2adc66947678ed5c", "html_url": "https://github.com/rust-lang/rust/commit/829d94940ebb07a49f5d841d2adc66947678ed5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/829d94940ebb07a49f5d841d2adc66947678ed5c/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d96a48c5174c2be11874e677d770b840bc424646", "url": "https://api.github.com/repos/rust-lang/rust/commits/d96a48c5174c2be11874e677d770b840bc424646", "html_url": "https://github.com/rust-lang/rust/commit/d96a48c5174c2be11874e677d770b840bc424646"}], "stats": {"total": 227, "additions": 134, "deletions": 93}, "files": [{"sha": "e71e08a00b30ab9ab37cc809388c1c680364b774", "filename": "src/missed_spans.rs", "status": "modified", "additions": 134, "deletions": 93, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/829d94940ebb07a49f5d841d2adc66947678ed5c/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829d94940ebb07a49f5d841d2adc66947678ed5c/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=829d94940ebb07a49f5d841d2adc66947678ed5c", "patch": "@@ -119,6 +119,85 @@ impl<'a> FmtVisitor<'a> {\n         self.write_snippet_inner(big_snippet, big_diff, &snippet, span, process_last_snippet);\n     }\n \n+    fn process_comment(\n+        &mut self,\n+        status: &mut SnippetStatus,\n+        snippet: &str,\n+        big_snippet: &str,\n+        offset: usize,\n+        big_diff: usize,\n+        subslice: &str,\n+        file_name: &str,\n+    ) -> bool {\n+        let last_char = big_snippet[..(offset + big_diff)]\n+            .chars()\n+            .rev()\n+            .skip_while(|rev_c| [' ', '\\t'].contains(rev_c))\n+            .next();\n+\n+        let fix_indent = last_char.map_or(true, |rev_c| ['{', '\\n'].contains(&rev_c));\n+\n+        let subslice_num_lines = count_newlines(subslice);\n+        let skip_this_range = !self.config.file_lines().intersects_range(\n+            file_name,\n+            status.cur_line,\n+            status.cur_line + subslice_num_lines,\n+        );\n+\n+        if status.rewrite_next_comment && skip_this_range {\n+            status.rewrite_next_comment = false;\n+        }\n+\n+        if status.rewrite_next_comment {\n+            if fix_indent {\n+                if let Some('{') = last_char {\n+                    self.buffer.push_str(\"\\n\");\n+                }\n+                self.buffer\n+                    .push_str(&self.block_indent.to_string(self.config));\n+            } else {\n+                self.buffer.push_str(\" \");\n+            }\n+\n+            let comment_width = ::std::cmp::min(\n+                self.config.comment_width(),\n+                self.config.max_width() - self.block_indent.width(),\n+            );\n+            let comment_indent = Indent::from_width(self.config, self.buffer.cur_offset());\n+            let comment_shape = Shape::legacy(comment_width, comment_indent);\n+            let comment_str = rewrite_comment(subslice, false, comment_shape, self.config)\n+                .unwrap_or_else(|| String::from(subslice));\n+            self.buffer.push_str(&comment_str);\n+\n+            status.last_wspace = None;\n+            status.line_start = offset + subslice.len();\n+\n+            if let Some('/') = subslice.chars().nth(1) {\n+                // check that there are no contained block comments\n+                if !subslice\n+                    .split('\\n')\n+                    .map(|s| s.trim_left())\n+                    .any(|s| s.len() >= 2 && &s[0..2] == \"/*\")\n+                {\n+                    // Add a newline after line comments\n+                    self.buffer.push_str(\"\\n\");\n+                }\n+            } else if status.line_start <= snippet.len() {\n+                // For other comments add a newline if there isn't one at the end already\n+                match snippet[status.line_start..].chars().next() {\n+                    Some('\\n') | Some('\\r') => (),\n+                    _ => self.buffer.push_str(\"\\n\"),\n+                }\n+            }\n+\n+            status.cur_line += subslice_num_lines;\n+            true\n+        } else {\n+            status.rewrite_next_comment = false;\n+            false\n+        }\n+    }\n+\n     fn write_snippet_inner<F>(\n         &mut self,\n         big_snippet: &str,\n@@ -132,13 +211,9 @@ impl<'a> FmtVisitor<'a> {\n         // Trim whitespace from the right hand side of each line.\n         // Annoyingly, the library functions for splitting by lines etc. are not\n         // quite right, so we must do it ourselves.\n-        let mut line_start = 0;\n-        let mut last_wspace = None;\n-        let mut rewrite_next_comment = true;\n-\n         let char_pos = self.codemap.lookup_char_pos(span.lo());\n         let file_name = &char_pos.file.name;\n-        let mut cur_line = char_pos.line;\n+        let mut status = SnippetStatus::new(char_pos.line);\n \n         fn replace_chars<'a>(string: &'a str) -> Cow<'a, str> {\n             if string.contains(char::is_whitespace) {\n@@ -162,121 +237,87 @@ impl<'a> FmtVisitor<'a> {\n             debug!(\"{:?}: {:?}\", kind, subslice);\n \n             if let CodeCharKind::Comment = kind {\n-                let last_char = big_snippet[..(offset + big_diff)]\n-                    .chars()\n-                    .rev()\n-                    .skip_while(|rev_c| [' ', '\\t'].contains(rev_c))\n-                    .next();\n-\n-                let fix_indent = last_char.map_or(true, |rev_c| ['{', '\\n'].contains(&rev_c));\n-\n-                let subslice_num_lines = count_newlines(subslice);\n-\n-                if rewrite_next_comment\n-                    && !self.config.file_lines().intersects_range(\n-                        file_name,\n-                        cur_line,\n-                        cur_line + subslice_num_lines,\n-                    ) {\n-                    rewrite_next_comment = false;\n-                }\n-\n-                if rewrite_next_comment {\n-                    if fix_indent {\n-                        if let Some('{') = last_char {\n-                            self.buffer.push_str(\"\\n\");\n-                        }\n-                        self.buffer\n-                            .push_str(&self.block_indent.to_string(self.config));\n-                    } else {\n-                        self.buffer.push_str(\" \");\n-                    }\n-\n-                    let comment_width = ::std::cmp::min(\n-                        self.config.comment_width(),\n-                        self.config.max_width() - self.block_indent.width(),\n-                    );\n-                    let comment_indent = Indent::from_width(self.config, self.buffer.cur_offset());\n-\n-                    self.buffer.push_str(&rewrite_comment(\n-                        subslice,\n-                        false,\n-                        Shape::legacy(comment_width, comment_indent),\n-                        self.config,\n-                    ).unwrap());\n-\n-                    last_wspace = None;\n-                    line_start = offset + subslice.len();\n-\n-                    if let Some('/') = subslice.chars().nth(1) {\n-                        // check that there are no contained block comments\n-                        if !subslice\n-                            .split('\\n')\n-                            .map(|s| s.trim_left())\n-                            .any(|s| s.len() >= 2 && &s[0..2] == \"/*\")\n-                        {\n-                            // Add a newline after line comments\n-                            self.buffer.push_str(\"\\n\");\n-                        }\n-                    } else if line_start <= snippet.len() {\n-                        // For other comments add a newline if there isn't one at the end already\n-                        match snippet[line_start..].chars().next() {\n-                            Some('\\n') | Some('\\r') => (),\n-                            _ => self.buffer.push_str(\"\\n\"),\n-                        }\n-                    }\n-\n-                    cur_line += subslice_num_lines;\n+                if self.process_comment(\n+                    &mut status,\n+                    snippet,\n+                    big_snippet,\n+                    offset,\n+                    big_diff,\n+                    subslice,\n+                    file_name,\n+                ) {\n                     continue;\n-                } else {\n-                    rewrite_next_comment = false;\n                 }\n             }\n \n+            // cur_line += newline_count;\n+            // rewirte_next_comment = true;\n+\n             for (mut i, c) in subslice.char_indices() {\n                 i += offset;\n \n                 if c == '\\n' {\n-                    if !self.config.file_lines().contains_line(file_name, cur_line) {\n-                        last_wspace = None;\n+                    if !self.config\n+                        .file_lines()\n+                        .contains_line(file_name, status.cur_line)\n+                    {\n+                        status.last_wspace = None;\n                     }\n \n-                    if let Some(lw) = last_wspace {\n-                        self.buffer.push_str(&snippet[line_start..lw]);\n+                    if let Some(lw) = status.last_wspace {\n+                        self.buffer.push_str(&snippet[status.line_start..lw]);\n                         self.buffer.push_str(\"\\n\");\n                     } else {\n-                        self.buffer.push_str(&snippet[line_start..i + 1]);\n+                        self.buffer.push_str(&snippet[status.line_start..i + 1]);\n                     }\n \n-                    cur_line += 1;\n-                    line_start = i + 1;\n-                    last_wspace = None;\n-                    rewrite_next_comment = rewrite_next_comment || kind == CodeCharKind::Normal;\n+                    status.cur_line += 1;\n+                    status.line_start = i + 1;\n+                    status.last_wspace = None;\n+                    status.rewrite_next_comment = true;\n                 } else if c.is_whitespace() {\n-                    if last_wspace.is_none() {\n-                        last_wspace = Some(i);\n+                    if status.last_wspace.is_none() {\n+                        status.last_wspace = Some(i);\n                     }\n                 } else if c == ';' {\n-                    if last_wspace.is_some() {\n-                        line_start = i;\n+                    if status.last_wspace.is_some() {\n+                        status.line_start = i;\n                     }\n \n-                    rewrite_next_comment = rewrite_next_comment || kind == CodeCharKind::Normal;\n-                    last_wspace = None;\n+                    status.rewrite_next_comment = true;\n+                    status.last_wspace = None;\n                 } else {\n-                    rewrite_next_comment = rewrite_next_comment || kind == CodeCharKind::Normal;\n-                    last_wspace = None;\n+                    status.rewrite_next_comment = true;\n+                    status.last_wspace = None;\n                 }\n             }\n \n-            let remaining = snippet[line_start..subslice.len() + offset].trim();\n+            let remaining = snippet[status.line_start..subslice.len() + offset].trim();\n             if !remaining.is_empty() {\n                 self.buffer.push_str(remaining);\n-                line_start = subslice.len() + offset;\n-                rewrite_next_comment = rewrite_next_comment || kind == CodeCharKind::Normal;\n+                status.line_start = subslice.len() + offset;\n+                status.rewrite_next_comment = true;\n             }\n         }\n \n-        process_last_snippet(self, &snippet[line_start..], snippet);\n+        process_last_snippet(self, &snippet[status.line_start..], snippet);\n+    }\n+}\n+\n+struct SnippetStatus {\n+    line_start: usize,\n+    last_wspace: Option<usize>,\n+    rewrite_next_comment: bool,\n+    cur_line: usize,\n+}\n+\n+impl SnippetStatus {\n+    fn new(cur_line: usize) -> Self {\n+        SnippetStatus {\n+            line_start: 0,\n+            last_wspace: None,\n+            rewrite_next_comment: true,\n+            cur_line,\n+        }\n     }\n }"}]}