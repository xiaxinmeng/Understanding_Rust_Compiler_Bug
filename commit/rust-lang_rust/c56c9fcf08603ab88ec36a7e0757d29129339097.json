{"sha": "c56c9fcf08603ab88ec36a7e0757d29129339097", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NmM5ZmNmMDg2MDNhYjg4ZWMzNmE3ZTA3NTdkMjkxMjkzMzkwOTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-10T15:49:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-13T18:50:47Z"}, "message": "rustc: Remove the dummy hack from check_match\n\nTurns out you can create &'static T quite easily in a constant, I just forgot\nabout this!", "tree": {"sha": "838ab1da16e692c3147003b67bd92f52d969c517", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/838ab1da16e692c3147003b67bd92f52d969c517"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c56c9fcf08603ab88ec36a7e0757d29129339097", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c56c9fcf08603ab88ec36a7e0757d29129339097", "html_url": "https://github.com/rust-lang/rust/commit/c56c9fcf08603ab88ec36a7e0757d29129339097", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c56c9fcf08603ab88ec36a7e0757d29129339097/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18e41299f9368c593be688792962a6d0c299c9bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/18e41299f9368c593be688792962a6d0c299c9bc", "html_url": "https://github.com/rust-lang/rust/commit/18e41299f9368c593be688792962a6d0c299c9bc"}], "stats": {"total": 67, "additions": 25, "deletions": 42}, "files": [{"sha": "1c06bc1cebaa1bdfacf8498801344cca72290aad", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c56c9fcf08603ab88ec36a7e0757d29129339097/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56c9fcf08603ab88ec36a7e0757d29129339097/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c56c9fcf08603ab88ec36a7e0757d29129339097", "patch": "@@ -32,7 +32,7 @@ use syntax::ptr::P;\n use syntax::visit::{mod, Visitor, FnKind};\n use util::ppaux::ty_to_string;\n \n-pub const DUMMY_WILD_PAT: Pat = Pat {\n+pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n     node: PatWild(PatWildSingle),\n     span: DUMMY_SP\n@@ -297,12 +297,11 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n }\n \n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n-    match is_useful(cx, matrix, &[&DUMMY_WILD_PAT], ConstructWitness) {\n+    match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let dummy = DUMMY_WILD_PAT.clone();\n             let witness = match pats.as_slice() {\n                 [ref witness] => &**witness,\n-                [] => &dummy,\n+                [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n             };\n             span_err!(cx.tcx.sess, sp, E0004,\n@@ -556,9 +555,8 @@ fn is_useful(cx: &MatchCheckCtxt,\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n                                 let pat_slice = pats.as_slice();\n-                                let dummy = DUMMY_WILD_PAT.clone();\n                                 let subpats = Vec::from_fn(arity, |i| {\n-                                    pat_slice.get(i).map_or(&dummy, |p| &**p)\n+                                    pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 });\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n@@ -580,9 +578,8 @@ fn is_useful(cx: &MatchCheckCtxt,\n                 }).collect();\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n-                        let dummy = DUMMY_WILD_PAT.clone();\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = Vec::from_elem(arity, &dummy);\n+                        let wild_pats = Vec::from_elem(arity, DUMMY_WILD_PAT);\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n                         new_pats.extend(pats.into_iter());\n@@ -603,11 +600,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          v: &[&Pat], ctor: Constructor, lty: ty::t,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n-    let dummy = DUMMY_WILD_PAT.clone();\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r.as_slice(), &dummy, &ctor, 0u, arity)\n+        specialize(cx, r.as_slice(), &ctor, 0u, arity)\n     }).collect());\n-    match specialize(cx, v, &dummy, &ctor, 0u, arity) {\n+    match specialize(cx, v, &ctor, 0u, arity) {\n         Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n         None => NotUseful\n     }\n@@ -729,15 +725,15 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n+pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                       constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<&'a Pat>> {\n     let &Pat {\n         id: pat_id, node: ref node, span: pat_span\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match node {\n \n         &PatWild(_) =>\n-            Some(Vec::from_elem(arity, dummy)),\n+            Some(Vec::from_elem(arity, DUMMY_WILD_PAT)),\n \n         &PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n@@ -750,7 +746,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                 } else {\n                     None\n                 },\n-                _ => Some(Vec::from_elem(arity, dummy))\n+                _ => Some(Vec::from_elem(arity, DUMMY_WILD_PAT))\n             }\n         }\n \n@@ -764,7 +760,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                 DefVariant(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => Vec::from_elem(arity, dummy)\n+                        &None => Vec::from_elem(arity, DUMMY_WILD_PAT)\n                     })\n                 }\n                 _ => None\n@@ -800,7 +796,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                 let args = struct_fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n                         Some(ref f) => &*f.pat,\n-                        _ => dummy\n+                        _ => DUMMY_WILD_PAT\n                     }\n                 }).collect();\n                 args\n@@ -843,13 +839,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                 // Fixed-length vectors.\n                 Single => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| dummy);\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| dummy);\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n@@ -919,7 +915,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n \n fn is_refutable<A>(cx: &MatchCheckCtxt, pat: &Pat, refutable: |&Pat| -> A) -> Option<A> {\n     let pats = Matrix(vec!(vec!(pat)));\n-    match is_useful(cx, &pats, [&DUMMY_WILD_PAT], ConstructWitness) {\n+    match is_useful(cx, &pats, [DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             assert_eq!(pats.len(), 1);\n             Some(refutable(&*pats[0]))"}, {"sha": "4f7d165d15944ce551fdeb863c0aa12d24a15bd5", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c56c9fcf08603ab88ec36a7e0757d29129339097/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56c9fcf08603ab88ec36a7e0757d29129339097/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c56c9fcf08603ab88ec36a7e0757d29129339097", "patch": "@@ -351,19 +351,6 @@ struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<&'p ast::Pat>,\n     data: &'a ArmData<'p, 'blk, 'tcx>,\n     bound_ptrs: Vec<(Ident, ValueRef)>,\n-\n-    // This is a pointer to an instance of check_match::DUMMY_WILD_PAT. The\n-    // check_match code requires that we pass this in (with the same lifetime as\n-    // the patterns passed in). Unfortunately this is required to be propagated\n-    // into this structure in order to get the lifetimes to work.\n-    //\n-    // Lots of the `check_match` code will deal with &DUMMY_WILD_PAT when\n-    // returning references, which used to have the `'static` lifetime before\n-    // const was added to the language. The DUMMY_WILD_PAT does not implement\n-    // Sync, however, so it must be a const, which longer has a static lifetime,\n-    // hence we're passing it in here. This certainly isn't crucial, and if it\n-    // can be removed, please do!\n-    dummy: &'p ast::Pat,\n }\n \n impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n@@ -416,7 +403,6 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         *pats.get_mut(col) = pat;\n         Match {\n             pats: pats,\n-            dummy: br.dummy,\n             data: &*br.data,\n             bound_ptrs: bound_ptrs\n         }\n@@ -464,7 +450,6 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n             Match {\n                 pats: pats,\n-                dummy: br.dummy,\n                 data: br.data,\n                 bound_ptrs: bound_ptrs\n             }\n@@ -559,8 +544,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n \n     let mcx = check_match::MatchCheckCtxt { tcx: bcx.tcx() };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats.as_slice(), m[0].dummy, &ctor, col,\n-                                variant_size)\n+        check_match::specialize(&mcx, pats.as_slice(), &ctor, col, variant_size)\n     )\n }\n \n@@ -1041,7 +1025,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     match adt_vals {\n         Some(field_vals) => {\n             let pats = enter_match(bcx, dm, m, col, val, |pats|\n-                check_match::specialize(&mcx, pats, m[0].dummy,\n+                check_match::specialize(&mcx, pats,\n                                         &check_match::Single, col,\n                                         field_vals.len())\n             );\n@@ -1365,7 +1349,6 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         bindings_map: create_bindings_map(bcx, &**arm.pats.get(0), discr_expr, &*arm.body)\n     }).collect();\n \n-    let dummy = check_match::DUMMY_WILD_PAT.clone();\n     let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n     let arm_pats: Vec<Vec<P<ast::Pat>>> = arm_datas.iter().map(|arm_data| {\n         arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n@@ -1374,7 +1357,6 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     for (arm_data, pats) in arm_datas.iter().zip(arm_pats.iter()) {\n         matches.extend(pats.iter().map(|p| Match {\n             pats: vec![&**p],\n-            dummy: &dummy,\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n         }));"}, {"sha": "0cfee6daf3f1921499dacc78001725a3e8e9abb8", "filename": "src/test/compile-fail/issue-17718-const-naming.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c56c9fcf08603ab88ec36a7e0757d29129339097/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56c9fcf08603ab88ec36a7e0757d29129339097/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs?ref=c56c9fcf08603ab88ec36a7e0757d29129339097", "patch": "@@ -12,5 +12,6 @@\n \n const foo: int = 3;\n //~^ ERROR: should have an uppercase name such as\n+//~^^ ERROR: constant item is never used\n \n fn main() {}"}, {"sha": "96d40c52657fe2f20aaeaa379c01c50c8c1dc86e", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c56c9fcf08603ab88ec36a7e0757d29129339097/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56c9fcf08603ab88ec36a7e0757d29129339097/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=c56c9fcf08603ab88ec36a7e0757d29129339097", "patch": "@@ -39,8 +39,8 @@ pub const pub_const: int = 0;\n const priv_const: int = 0; //~ ERROR: constant item is never used\n const used_const: int = 0;\n pub const used_const2: int = used_const;\n-const USED_CONST: int = 0;\n-const CONST_USED_IN_ENUM_DISCRIMINANT: int = 10;\n+const USED_CONST: int = 1;\n+const CONST_USED_IN_ENUM_DISCRIMINANT: int = 11;\n \n pub type typ = *const UsedStruct4;\n pub struct PubStruct;\n@@ -68,7 +68,10 @@ pub struct PubStruct2 {\n \n pub enum pub_enum { foo1, bar1 }\n pub enum pub_enum2 { a(*const StructUsedInEnum) }\n-pub enum pub_enum3 { Foo = STATIC_USED_IN_ENUM_DISCRIMINANT }\n+pub enum pub_enum3 {\n+    Foo = STATIC_USED_IN_ENUM_DISCRIMINANT,\n+    Bar = CONST_USED_IN_ENUM_DISCRIMINANT,\n+}\n \n enum priv_enum { foo2, bar2 } //~ ERROR: enum is never used\n enum used_enum {\n@@ -89,6 +92,7 @@ pub fn pub_fn() {\n     let i = 1i;\n     match i {\n         USED_STATIC => (),\n+        USED_CONST => (),\n         _ => ()\n     }\n     f::<StructUsedInGeneric>();"}]}