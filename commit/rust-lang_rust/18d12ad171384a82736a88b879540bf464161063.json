{"sha": "18d12ad171384a82736a88b879540bf464161063", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZDEyYWQxNzEzODRhODI3MzZhODhiODc5NTQwYmY0NjQxNjEwNjM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-01-21T08:51:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-01-21T09:41:22Z"}, "message": "directly expose copy and copy_nonoverlapping intrinsics", "tree": {"sha": "91e4c63e727def9bef5d90523cc358662ae9abde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91e4c63e727def9bef5d90523cc358662ae9abde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18d12ad171384a82736a88b879540bf464161063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18d12ad171384a82736a88b879540bf464161063", "html_url": "https://github.com/rust-lang/rust/commit/18d12ad171384a82736a88b879540bf464161063", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18d12ad171384a82736a88b879540bf464161063/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57a71ac0e17e4f7070b090ab7bdc5474d8e37ecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/57a71ac0e17e4f7070b090ab7bdc5474d8e37ecc", "html_url": "https://github.com/rust-lang/rust/commit/57a71ac0e17e4f7070b090ab7bdc5474d8e37ecc"}], "stats": {"total": 393, "additions": 175, "deletions": 218}, "files": [{"sha": "305e4d707a35f7ec731212a83c97df13693065c6", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 151, "deletions": 186, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/18d12ad171384a82736a88b879540bf464161063/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d12ad171384a82736a88b879540bf464161063/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=18d12ad171384a82736a88b879540bf464161063", "patch": "@@ -1730,6 +1730,157 @@ extern \"rust-intrinsic\" {\n     /// Allocate at compile time. Should not be called at runtime.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n     pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n+\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// and destination must *not* overlap.\n+    ///\n+    /// For regions of memory which might overlap, use [`copy`] instead.\n+    ///\n+    /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n+    /// with the argument order swapped.\n+    ///\n+    /// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n+    ///\n+    /// # Safety\n+    ///\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * Both `src` and `dst` must be properly aligned.\n+    ///\n+    /// * The region of memory beginning at `src` with a size of `count *\n+    ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n+    ///   beginning at `dst` with the same size.\n+    ///\n+    /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n+    /// in the region beginning at `*src` and the region beginning at `*dst` can\n+    /// [violate memory safety][read-ownership].\n+    ///\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointers must be non-NULL and properly aligned.\n+    ///\n+    /// [`read`]: crate::ptr::read\n+    /// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+    /// [valid]: crate::ptr#safety\n+    ///\n+    /// # Examples\n+    ///\n+    /// Manually implement [`Vec::append`]:\n+    ///\n+    /// ```\n+    /// use std::ptr;\n+    ///\n+    /// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n+    /// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n+    ///     let src_len = src.len();\n+    ///     let dst_len = dst.len();\n+    ///\n+    ///     // Ensure that `dst` has enough capacity to hold all of `src`.\n+    ///     dst.reserve(src_len);\n+    ///\n+    ///     unsafe {\n+    ///         // The call to offset is always safe because `Vec` will never\n+    ///         // allocate more than `isize::MAX` bytes.\n+    ///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n+    ///         let src_ptr = src.as_ptr();\n+    ///\n+    ///         // Truncate `src` without dropping its contents. We do this first,\n+    ///         // to avoid problems in case something further down panics.\n+    ///         src.set_len(0);\n+    ///\n+    ///         // The two regions cannot overlap because mutable references do\n+    ///         // not alias, and two different vectors cannot own the same\n+    ///         // memory.\n+    ///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n+    ///\n+    ///         // Notify `dst` that it now holds the contents of `src`.\n+    ///         dst.set_len(dst_len + src_len);\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut a = vec!['r'];\n+    /// let mut b = vec!['u', 's', 't'];\n+    ///\n+    /// append(&mut a, &mut b);\n+    ///\n+    /// assert_eq!(a, &['r', 'u', 's', 't']);\n+    /// assert!(b.is_empty());\n+    /// ```\n+    ///\n+    /// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n+    #[doc(alias = \"memcpy\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+    pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// and destination may overlap.\n+    ///\n+    /// If the source and destination will *never* overlap,\n+    /// [`copy_nonoverlapping`] can be used instead.\n+    ///\n+    /// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n+    /// order swapped. Copying takes place as if the bytes were copied from `src`\n+    /// to a temporary array and then copied from the array to `dst`.\n+    ///\n+    /// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n+    ///\n+    /// # Safety\n+    ///\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * Both `src` and `dst` must be properly aligned.\n+    ///\n+    /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n+    /// in the region beginning at `*src` and the region beginning at `*dst` can\n+    /// [violate memory safety][read-ownership].\n+    ///\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointers must be non-NULL and properly aligned.\n+    ///\n+    /// [`read`]: crate::ptr::read\n+    /// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+    /// [valid]: crate::ptr#safety\n+    ///\n+    /// # Examples\n+    ///\n+    /// Efficiently create a Rust vector from an unsafe buffer:\n+    ///\n+    /// ```\n+    /// use std::ptr;\n+    ///\n+    /// /// # Safety\n+    /// ///\n+    /// /// * `ptr` must be correctly aligned for its type and non-zero.\n+    /// /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n+    /// /// * Those elements must not be used after calling this function unless `T: Copy`.\n+    /// # #[allow(dead_code)]\n+    /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n+    ///     let mut dst = Vec::with_capacity(elts);\n+    ///\n+    ///     // SAFETY: Our precondition ensures the source is aligned and valid,\n+    ///     // and `Vec::with_capacity` ensures that we have usable space to write them.\n+    ///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n+    ///\n+    ///     // SAFETY: We created it with this much capacity earlier,\n+    ///     // and the previous `copy` has initialized these elements.\n+    ///     dst.set_len(elts);\n+    ///     dst\n+    /// }\n+    /// ```\n+    #[doc(alias = \"memmove\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+    pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n }\n \n // Some functions are defined here because they accidentally got made\n@@ -1755,192 +1906,6 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n     diff >= size\n }\n \n-/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-/// and destination must *not* overlap.\n-///\n-/// For regions of memory which might overlap, use [`copy`] instead.\n-///\n-/// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n-/// with the argument order swapped.\n-///\n-/// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n-///\n-/// # Safety\n-///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n-///\n-/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n-///\n-/// * Both `src` and `dst` must be properly aligned.\n-///\n-/// * The region of memory beginning at `src` with a size of `count *\n-///   size_of::<T>()` bytes must *not* overlap with the region of memory\n-///   beginning at `dst` with the same size.\n-///\n-/// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n-/// in the region beginning at `*src` and the region beginning at `*dst` can\n-/// [violate memory safety][read-ownership].\n-///\n-/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-/// `0`, the pointers must be non-NULL and properly aligned.\n-///\n-/// [`read`]: crate::ptr::read\n-/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n-/// [valid]: crate::ptr#safety\n-///\n-/// # Examples\n-///\n-/// Manually implement [`Vec::append`]:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n-/// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n-///     let src_len = src.len();\n-///     let dst_len = dst.len();\n-///\n-///     // Ensure that `dst` has enough capacity to hold all of `src`.\n-///     dst.reserve(src_len);\n-///\n-///     unsafe {\n-///         // The call to offset is always safe because `Vec` will never\n-///         // allocate more than `isize::MAX` bytes.\n-///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n-///         let src_ptr = src.as_ptr();\n-///\n-///         // Truncate `src` without dropping its contents. We do this first,\n-///         // to avoid problems in case something further down panics.\n-///         src.set_len(0);\n-///\n-///         // The two regions cannot overlap because mutable references do\n-///         // not alias, and two different vectors cannot own the same\n-///         // memory.\n-///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n-///\n-///         // Notify `dst` that it now holds the contents of `src`.\n-///         dst.set_len(dst_len + src_len);\n-///     }\n-/// }\n-///\n-/// let mut a = vec!['r'];\n-/// let mut b = vec!['u', 's', 't'];\n-///\n-/// append(&mut a, &mut b);\n-///\n-/// assert_eq!(a, &['r', 'u', 's', 't']);\n-/// assert!(b.is_empty());\n-/// ```\n-///\n-/// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n-#[doc(alias = \"memcpy\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-#[inline]\n-pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n-    extern \"rust-intrinsic\" {\n-        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-        fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n-\n-    // FIXME: Perform these checks only at run time\n-    /*if cfg!(debug_assertions)\n-        && !(is_aligned_and_not_null(src)\n-            && is_aligned_and_not_null(dst)\n-            && is_nonoverlapping(src, dst, count))\n-    {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }*/\n-\n-    // SAFETY: the safety contract for `copy_nonoverlapping` must be\n-    // upheld by the caller.\n-    unsafe { copy_nonoverlapping(src, dst, count) }\n-}\n-\n-/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-/// and destination may overlap.\n-///\n-/// If the source and destination will *never* overlap,\n-/// [`copy_nonoverlapping`] can be used instead.\n-///\n-/// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n-/// order swapped. Copying takes place as if the bytes were copied from `src`\n-/// to a temporary array and then copied from the array to `dst`.\n-///\n-/// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n-///\n-/// # Safety\n-///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n-///\n-/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n-///\n-/// * Both `src` and `dst` must be properly aligned.\n-///\n-/// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n-/// in the region beginning at `*src` and the region beginning at `*dst` can\n-/// [violate memory safety][read-ownership].\n-///\n-/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-/// `0`, the pointers must be non-NULL and properly aligned.\n-///\n-/// [`read`]: crate::ptr::read\n-/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n-/// [valid]: crate::ptr#safety\n-///\n-/// # Examples\n-///\n-/// Efficiently create a Rust vector from an unsafe buffer:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// /// # Safety\n-/// ///\n-/// /// * `ptr` must be correctly aligned for its type and non-zero.\n-/// /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n-/// /// * Those elements must not be used after calling this function unless `T: Copy`.\n-/// # #[allow(dead_code)]\n-/// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n-///     let mut dst = Vec::with_capacity(elts);\n-///\n-///     // SAFETY: Our precondition ensures the source is aligned and valid,\n-///     // and `Vec::with_capacity` ensures that we have usable space to write them.\n-///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n-///\n-///     // SAFETY: We created it with this much capacity earlier,\n-///     // and the previous `copy` has initialized these elements.\n-///     dst.set_len(elts);\n-///     dst\n-/// }\n-/// ```\n-#[doc(alias = \"memmove\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-#[inline]\n-pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n-    extern \"rust-intrinsic\" {\n-        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-        fn copy<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n-\n-    // FIXME: Perform these checks only at run time\n-    /*if cfg!(debug_assertions) && !(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)) {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }*/\n-\n-    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n-    unsafe { copy(src, dst, count) }\n-}\n-\n /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n /// `val`.\n ///"}, {"sha": "fd92ed6fe47f0cc2c6bcd235f5425d7f967324c4", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18d12ad171384a82736a88b879540bf464161063/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d12ad171384a82736a88b879540bf464161063/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=18d12ad171384a82736a88b879540bf464161063", "patch": "@@ -881,17 +881,12 @@ pub const unsafe fn read_unaligned<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n-    // We are calling the intrinsics directly to avoid function calls in the generated code\n-    // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n-    extern \"rust-intrinsic\" {\n-        fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n-\n     // SAFETY: the caller must guarantee that `dst` is valid for writes.\n     // `dst` cannot overlap `src` because the caller has mutable access\n     // to `dst` while `src` is owned by this function.\n     unsafe {\n         copy_nonoverlapping(&src as *const T, dst, 1);\n+        // We are calling the intrinsic directly to avoid function calls in the generated code.\n         intrinsics::forget(src);\n     }\n }"}, {"sha": "c208883c5a803ba3b45a9982fefd11e27db94bdf", "filename": "src/test/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/18d12ad171384a82736a88b879540bf464161063/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18d12ad171384a82736a88b879540bf464161063/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=18d12ad171384a82736a88b879540bf464161063", "patch": "@@ -1,13 +1,12 @@\n error: any use of this value will cause an error\n-  --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL |     unsafe { copy_nonoverlapping(src, dst, count) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |              |\n-   |              memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n-   |              inside `copy_nonoverlapping::<u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |              inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |              inside `_READ` at $DIR/out_of_bounds_read.rs:13:33\n+LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n+   |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |         inside `_READ` at $DIR/out_of_bounds_read.rs:13:33\n    | \n   ::: $DIR/out_of_bounds_read.rs:13:5\n    |\n@@ -17,33 +16,31 @@ LL |     const _READ: u32 = unsafe { ptr::read(PAST_END_PTR) };\n    = note: `#[deny(const_err)]` on by default\n \n error: any use of this value will cause an error\n-  --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL |     unsafe { copy_nonoverlapping(src, dst, count) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |              |\n-   |              memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n-   |              inside `copy_nonoverlapping::<u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |              inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |              inside `ptr::const_ptr::<impl *const u32>::read` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |              inside `_CONST_READ` at $DIR/out_of_bounds_read.rs:14:39\n+LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n+   |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |         inside `ptr::const_ptr::<impl *const u32>::read` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |         inside `_CONST_READ` at $DIR/out_of_bounds_read.rs:14:39\n    | \n   ::: $DIR/out_of_bounds_read.rs:14:5\n    |\n LL |     const _CONST_READ: u32 = unsafe { PAST_END_PTR.read() };\n    |     --------------------------------------------------------\n \n error: any use of this value will cause an error\n-  --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL |     unsafe { copy_nonoverlapping(src, dst, count) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |              |\n-   |              memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n-   |              inside `copy_nonoverlapping::<u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |              inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |              inside `ptr::mut_ptr::<impl *mut u32>::read` at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-   |              inside `_MUT_READ` at $DIR/out_of_bounds_read.rs:15:37\n+LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n+   |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |         inside `ptr::mut_ptr::<impl *mut u32>::read` at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+   |         inside `_MUT_READ` at $DIR/out_of_bounds_read.rs:15:37\n    | \n   ::: $DIR/out_of_bounds_read.rs:15:5\n    |"}]}