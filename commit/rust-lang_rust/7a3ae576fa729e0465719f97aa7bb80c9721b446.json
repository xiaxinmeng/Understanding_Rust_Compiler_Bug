{"sha": "7a3ae576fa729e0465719f97aa7bb80c9721b446", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhM2FlNTc2ZmE3MjllMDQ2NTcxOWY5N2FhN2JiODBjOTcyMWI0NDY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-01T07:01:45Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-05T04:53:33Z"}, "message": "Refactor `expand_invoc(.., fld)` -> `self.expand_invoc(..)`.", "tree": {"sha": "75cfae8d185e3269d93b2cbe7f6e0bdc1f16ef4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75cfae8d185e3269d93b2cbe7f6e0bdc1f16ef4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a3ae576fa729e0465719f97aa7bb80c9721b446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3ae576fa729e0465719f97aa7bb80c9721b446", "html_url": "https://github.com/rust-lang/rust/commit/7a3ae576fa729e0465719f97aa7bb80c9721b446", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a3ae576fa729e0465719f97aa7bb80c9721b446/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79fa9eb643cfbb807813afed6f825f6654ee7662", "url": "https://api.github.com/repos/rust-lang/rust/commits/79fa9eb643cfbb807813afed6f825f6654ee7662", "html_url": "https://github.com/rust-lang/rust/commit/79fa9eb643cfbb807813afed6f825f6654ee7662"}], "stats": {"total": 419, "additions": 212, "deletions": 207}, "files": [{"sha": "17b2b2d25b99039a3b44ec7883e162c7ea21d301", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 212, "deletions": 207, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/7a3ae576fa729e0465719f97aa7bb80c9721b446/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3ae576fa729e0465719f97aa7bb80c9721b446/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7a3ae576fa729e0465719f97aa7bb80c9721b446", "patch": "@@ -143,199 +143,6 @@ enum InvocationKind {\n     },\n }\n \n-fn expand_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n-    match invoc.kind {\n-        InvocationKind::Bang { .. } => expand_bang_invoc(invoc, fld),\n-        InvocationKind::Attr { .. } => expand_attr_invoc(invoc, fld),\n-    }\n-}\n-\n-fn expand_attr_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n-    let Invocation { expansion_kind: kind, .. } = invoc;\n-    let (attr, item) = match invoc.kind {\n-        InvocationKind::Attr { attr, item } => (attr, item),\n-        _ => unreachable!(),\n-    };\n-\n-    let extension = match fld.cx.syntax_env.find(intern(&attr.name())) {\n-        Some(extension) => extension,\n-        None => unreachable!(),\n-    };\n-\n-    attr::mark_used(&attr);\n-    fld.cx.bt_push(ExpnInfo {\n-        call_site: attr.span,\n-        callee: NameAndSpan {\n-            format: MacroAttribute(intern(&attr.name())),\n-            span: Some(attr.span),\n-            allow_internal_unstable: false,\n-        }\n-    });\n-\n-    let modified = match *extension {\n-        MultiModifier(ref mac) => {\n-            kind.expect_from_annotatables(mac.expand(fld.cx, attr.span, &attr.node.value, item))\n-        }\n-        MultiDecorator(ref mac) => {\n-            let mut items = Vec::new();\n-            mac.expand(fld.cx, attr.span, &attr.node.value, &item, &mut |item| items.push(item));\n-            items.push(item);\n-            kind.expect_from_annotatables(items)\n-        }\n-        _ => unreachable!(),\n-    };\n-\n-    fld.cx.bt_pop();\n-\n-    let configured = modified.fold_with(&mut fld.strip_unconfigured());\n-    configured.fold_with(fld)\n-}\n-\n-/// Expand a macro invocation. Returns the result of expansion.\n-fn expand_bang_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n-    let Invocation { mark, expansion_kind: kind, .. } = invoc;\n-    let (attrs, mac, ident, span) = match invoc.kind {\n-        InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n-        _ => unreachable!(),\n-    };\n-    let Mac_ { path, tts, .. } = mac.node;\n-\n-    // Detect use of feature-gated or invalid attributes on macro invoations\n-    // since they will not be detected after macro expansion.\n-    for attr in attrs.iter() {\n-        feature_gate::check_attribute(&attr, &fld.cx.parse_sess.span_diagnostic,\n-                                      &fld.cx.parse_sess.codemap(),\n-                                      &fld.cx.ecfg.features.unwrap());\n-    }\n-\n-    if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n-        fld.cx.span_err(path.span, \"expected macro name without module separators\");\n-        return kind.dummy(span);\n-    }\n-\n-    let extname = path.segments[0].identifier.name;\n-    let extension = if let Some(extension) = fld.cx.syntax_env.find(extname) {\n-        extension\n-    } else {\n-        let mut err =\n-            fld.cx.struct_span_err(path.span, &format!(\"macro undefined: '{}!'\", &extname));\n-        fld.cx.suggest_macro_name(&extname.as_str(), &mut err);\n-        err.emit();\n-        return kind.dummy(span);\n-    };\n-\n-    let ident = ident.unwrap_or(keywords::Invalid.ident());\n-    let marked_tts = mark_tts(&tts, mark);\n-    let opt_expanded = match *extension {\n-        NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n-            if ident.name != keywords::Invalid.name() {\n-                let msg =\n-                    format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n-                fld.cx.span_err(path.span, &msg);\n-                return kind.dummy(span);\n-            }\n-\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: span,\n-                callee: NameAndSpan {\n-                    format: MacroBang(extname),\n-                    span: exp_span,\n-                    allow_internal_unstable: allow_internal_unstable,\n-                },\n-            });\n-\n-            kind.make_from(expandfun.expand(fld.cx, span, &marked_tts))\n-        }\n-\n-        IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n-            if ident.name == keywords::Invalid.name() {\n-                fld.cx.span_err(path.span,\n-                                &format!(\"macro {}! expects an ident argument\", extname));\n-                return kind.dummy(span);\n-            };\n-\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: span,\n-                callee: NameAndSpan {\n-                    format: MacroBang(extname),\n-                    span: tt_span,\n-                    allow_internal_unstable: allow_internal_unstable,\n-                }\n-            });\n-\n-            kind.make_from(expander.expand(fld.cx, span, ident, marked_tts))\n-        }\n-\n-        MacroRulesTT => {\n-            if ident.name == keywords::Invalid.name() {\n-                fld.cx.span_err(path.span,\n-                                &format!(\"macro {}! expects an ident argument\", extname));\n-                return kind.dummy(span);\n-            };\n-\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: span,\n-                callee: NameAndSpan {\n-                    format: MacroBang(extname),\n-                    span: None,\n-                    // `macro_rules!` doesn't directly allow unstable\n-                    // (this is orthogonal to whether the macro it creates allows it)\n-                    allow_internal_unstable: false,\n-                }\n-            });\n-\n-            let def = ast::MacroDef {\n-                ident: ident,\n-                id: ast::DUMMY_NODE_ID,\n-                span: span,\n-                imported_from: None,\n-                use_locally: true,\n-                body: marked_tts,\n-                export: attr::contains_name(&attrs, \"macro_export\"),\n-                allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n-                attrs: attrs,\n-            };\n-\n-            fld.cx.insert_macro(def.clone());\n-\n-            // If keep_macs is true, expands to a MacEager::items instead.\n-            if fld.keep_macs {\n-                Some(reconstruct_macro_rules(&def, &path))\n-            } else {\n-                Some(macro_scope_placeholder())\n-            }\n-        }\n-\n-        MultiDecorator(..) | MultiModifier(..) => {\n-            fld.cx.span_err(path.span,\n-                            &format!(\"`{}` can only be used in attributes\", extname));\n-            return kind.dummy(span);\n-        }\n-    };\n-\n-    let expanded = if let Some(expanded) = opt_expanded {\n-        expanded\n-    } else {\n-        let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n-                          name = path.segments[0].identifier.name, kind = kind.name());\n-        fld.cx.span_err(path.span, &msg);\n-        return kind.dummy(span);\n-    };\n-\n-    let marked = expanded.fold_with(&mut Marker { mark: mark, expn_id: Some(fld.cx.backtrace()) });\n-    let configured = marked.fold_with(&mut fld.strip_unconfigured());\n-    fld.load_macros(&configured);\n-\n-    let fully_expanded = if fld.single_step {\n-        configured\n-    } else {\n-        configured.fold_with(fld)\n-    };\n-\n-    fld.cx.bt_pop();\n-    fully_expanded\n-}\n-\n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n@@ -467,14 +274,212 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n         false\n     }\n+\n+    fn expand_invoc(&mut self, invoc: Invocation) -> Expansion {\n+        match invoc.kind {\n+            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc),\n+            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc),\n+        }\n+    }\n+\n+    fn expand_attr_invoc(&mut self, invoc: Invocation) -> Expansion {\n+        let Invocation { expansion_kind: kind, .. } = invoc;\n+        let (attr, item) = match invoc.kind {\n+            InvocationKind::Attr { attr, item } => (attr, item),\n+            _ => unreachable!(),\n+        };\n+\n+        let extension = match self.cx.syntax_env.find(intern(&attr.name())) {\n+            Some(extension) => extension,\n+            None => unreachable!(),\n+        };\n+\n+        attr::mark_used(&attr);\n+        self.cx.bt_push(ExpnInfo {\n+            call_site: attr.span,\n+            callee: NameAndSpan {\n+                format: MacroAttribute(intern(&attr.name())),\n+                span: Some(attr.span),\n+                allow_internal_unstable: false,\n+            }\n+        });\n+\n+        let modified = match *extension {\n+            MultiModifier(ref mac) => {\n+                let item = mac.expand(self.cx, attr.span, &attr.node.value, item);\n+                kind.expect_from_annotatables(item)\n+            }\n+            MultiDecorator(ref mac) => {\n+                let mut items = Vec::new();\n+                mac.expand(self.cx, attr.span, &attr.node.value, &item,\n+                           &mut |item| items.push(item));\n+                items.push(item);\n+                kind.expect_from_annotatables(items)\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        self.cx.bt_pop();\n+\n+        let configured = modified.fold_with(&mut self.strip_unconfigured());\n+        configured.fold_with(self)\n+    }\n+\n+    /// Expand a macro invocation. Returns the result of expansion.\n+    fn expand_bang_invoc(&mut self, invoc: Invocation) -> Expansion {\n+        let Invocation { mark, expansion_kind: kind, .. } = invoc;\n+        let (attrs, mac, ident, span) = match invoc.kind {\n+            InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n+            _ => unreachable!(),\n+        };\n+        let Mac_ { path, tts, .. } = mac.node;\n+\n+        // Detect use of feature-gated or invalid attributes on macro invoations\n+        // since they will not be detected after macro expansion.\n+        for attr in attrs.iter() {\n+            feature_gate::check_attribute(&attr, &self.cx.parse_sess.span_diagnostic,\n+                                          &self.cx.parse_sess.codemap(),\n+                                          &self.cx.ecfg.features.unwrap());\n+        }\n+\n+        if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n+            self.cx.span_err(path.span, \"expected macro name without module separators\");\n+            return kind.dummy(span);\n+        }\n+\n+        let extname = path.segments[0].identifier.name;\n+        let extension = if let Some(extension) = self.cx.syntax_env.find(extname) {\n+            extension\n+        } else {\n+            let mut err =\n+                self.cx.struct_span_err(path.span, &format!(\"macro undefined: '{}!'\", &extname));\n+            self.cx.suggest_macro_name(&extname.as_str(), &mut err);\n+            err.emit();\n+            return kind.dummy(span);\n+        };\n+\n+        let ident = ident.unwrap_or(keywords::Invalid.ident());\n+        let marked_tts = mark_tts(&tts, mark);\n+        let opt_expanded = match *extension {\n+            NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n+                if ident.name != keywords::Invalid.name() {\n+                    let msg =\n+                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                    self.cx.span_err(path.span, &msg);\n+                    return kind.dummy(span);\n+                }\n+\n+                self.cx.bt_push(ExpnInfo {\n+                    call_site: span,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        span: exp_span,\n+                        allow_internal_unstable: allow_internal_unstable,\n+                    },\n+                });\n+\n+                kind.make_from(expandfun.expand(self.cx, span, &marked_tts))\n+            }\n+\n+            IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n+                if ident.name == keywords::Invalid.name() {\n+                    self.cx.span_err(path.span,\n+                                    &format!(\"macro {}! expects an ident argument\", extname));\n+                    return kind.dummy(span);\n+                };\n+\n+                self.cx.bt_push(ExpnInfo {\n+                    call_site: span,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        span: tt_span,\n+                        allow_internal_unstable: allow_internal_unstable,\n+                    }\n+                });\n+\n+                kind.make_from(expander.expand(self.cx, span, ident, marked_tts))\n+            }\n+\n+            MacroRulesTT => {\n+                if ident.name == keywords::Invalid.name() {\n+                    self.cx.span_err(path.span,\n+                                    &format!(\"macro {}! expects an ident argument\", extname));\n+                    return kind.dummy(span);\n+                };\n+\n+                self.cx.bt_push(ExpnInfo {\n+                    call_site: span,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        span: None,\n+                        // `macro_rules!` doesn't directly allow unstable\n+                        // (this is orthogonal to whether the macro it creates allows it)\n+                        allow_internal_unstable: false,\n+                    }\n+                });\n+\n+                let def = ast::MacroDef {\n+                    ident: ident,\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: span,\n+                    imported_from: None,\n+                    use_locally: true,\n+                    body: marked_tts,\n+                    export: attr::contains_name(&attrs, \"macro_export\"),\n+                    allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n+                    attrs: attrs,\n+                };\n+\n+                self.cx.insert_macro(def.clone());\n+\n+                // If keep_macs is true, expands to a MacEager::items instead.\n+                if self.keep_macs {\n+                    Some(reconstruct_macro_rules(&def, &path))\n+                } else {\n+                    Some(macro_scope_placeholder())\n+                }\n+            }\n+\n+            MultiDecorator(..) | MultiModifier(..) => {\n+                self.cx.span_err(path.span,\n+                                 &format!(\"`{}` can only be used in attributes\", extname));\n+                return kind.dummy(span);\n+            }\n+        };\n+\n+        let expanded = if let Some(expanded) = opt_expanded {\n+            expanded\n+        } else {\n+            let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n+                              name = path.segments[0].identifier.name, kind = kind.name());\n+            self.cx.span_err(path.span, &msg);\n+            return kind.dummy(span);\n+        };\n+\n+        let marked = expanded.fold_with(&mut Marker {\n+            mark: mark,\n+            expn_id: Some(self.cx.backtrace())\n+        });\n+        let configured = marked.fold_with(&mut self.strip_unconfigured());\n+        self.load_macros(&configured);\n+\n+        let fully_expanded = if self.single_step {\n+            configured\n+        } else {\n+            configured.fold_with(self)\n+        };\n+\n+        self.cx.bt_pop();\n+        fully_expanded\n+    }\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let expr = expr.unwrap();\n         if let ast::ExprKind::Mac(mac) = expr.node {\n             let invoc = self.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr);\n-            expand_invoc(invoc, self).make_expr()\n+            self.expand_invoc(invoc).make_expr()\n         } else {\n             P(noop_fold_expr(expr, self))\n         }\n@@ -485,7 +490,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         if let ast::ExprKind::Mac(mac) = expr.node {\n             let invoc =\n                 self.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr);\n-            expand_invoc(invoc, self).make_opt_expr()\n+            self.expand_invoc(invoc).make_opt_expr()\n         } else {\n             Some(P(noop_fold_expr(expr, self)))\n         }\n@@ -494,13 +499,13 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n         match pat.node {\n             PatKind::Mac(_) => {}\n-            _ => return noop_fold_pat(pat, self)\n+            _ => return noop_fold_pat(pat, self),\n         }\n \n         pat.and_then(|pat| match pat.node {\n             PatKind::Mac(mac) => {\n                 let invoc = self.new_bang_invoc(mac, Vec::new(), pat.span, ExpansionKind::Pat);\n-                expand_invoc(invoc, self).make_pat()\n+                self.expand_invoc(invoc).make_pat()\n             }\n             _ => unreachable!(),\n         })\n@@ -509,11 +514,11 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         let (mac, style, attrs) = match stmt.node {\n             StmtKind::Mac(mac) => mac.unwrap(),\n-            _ => return noop_fold_stmt(stmt, self)\n+            _ => return noop_fold_stmt(stmt, self),\n         };\n \n         let invoc = self.new_bang_invoc(mac, attrs.into(), stmt.span, ExpansionKind::Stmts);\n-        let mut fully_expanded = expand_invoc(invoc, self).make_stmts();\n+        let mut fully_expanded = self.expand_invoc(invoc).make_stmts();\n \n         // If this is a macro invocation with a semicolon, then apply that\n         // semicolon to the final statement produced by expansion.\n@@ -540,7 +545,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         let (item, attr) = self.classify_item(item);\n         if let Some(attr) = attr {\n             let invoc = self.new_attr_invoc(attr, Annotatable::Item(item), ExpansionKind::Items);\n-            return expand_invoc(invoc, self).make_items();\n+            return self.expand_invoc(invoc).make_items();\n         }\n \n         match item.node {\n@@ -560,7 +565,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n                             ident: Some(item.ident),\n                             span: item.span,\n                         });\n-                        expand_invoc(invoc, self).make_items()\n+                        self.expand_invoc(invoc).make_items()\n                     }\n                     _ => unreachable!(),\n                 })\n@@ -598,14 +603,14 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         if let Some(attr) = attr {\n             let item = Annotatable::TraitItem(P(item));\n             let invoc = self.new_attr_invoc(attr, item, ExpansionKind::TraitItems);\n-            return expand_invoc(invoc, self).make_trait_items();\n+            return self.expand_invoc(invoc).make_trait_items();\n         }\n \n         match item.node {\n             ast::TraitItemKind::Macro(mac) => {\n                 let ast::TraitItem { attrs, span, .. } = item;\n                 let invoc = self.new_bang_invoc(mac, attrs, span, ExpansionKind::TraitItems);\n-                expand_invoc(invoc, self).make_trait_items()\n+                self.expand_invoc(invoc).make_trait_items()\n             }\n             _ => fold::noop_fold_trait_item(item, self),\n         }\n@@ -616,16 +621,16 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         if let Some(attr) = attr {\n             let item = Annotatable::ImplItem(P(item));\n             let invoc = self.new_attr_invoc(attr, item, ExpansionKind::ImplItems);\n-            return expand_invoc(invoc, self).make_impl_items();\n+            return self.expand_invoc(invoc).make_impl_items();\n         }\n \n         match item.node {\n             ast::ImplItemKind::Macro(mac) => {\n                 let ast::ImplItem { attrs, span, .. } = item;\n                 let invoc = self.new_bang_invoc(mac, attrs, span, ExpansionKind::ImplItems);\n-                expand_invoc(invoc, self).make_impl_items()\n+                self.expand_invoc(invoc).make_impl_items()\n             }\n-            _ => fold::noop_fold_impl_item(item, self)\n+            _ => fold::noop_fold_impl_item(item, self),\n         }\n     }\n \n@@ -638,7 +643,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         match ty.node {\n             ast::TyKind::Mac(mac) => {\n                 let invoc = self.new_bang_invoc(mac, Vec::new(), ty.span, ExpansionKind::Ty);\n-                expand_invoc(invoc, self).make_ty()\n+                self.expand_invoc(invoc).make_ty()\n             }\n             _ => unreachable!(),\n         }"}]}