{"sha": "d635806ea5090426cd4a5a57601a7f823277e84c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MzU4MDZlYTUwOTA0MjZjZDRhNWE1NzYwMWE3ZjgyMzI3N2U4NGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-14T10:13:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-14T10:13:57Z"}, "message": "Merge #7257\n\n7257: vfs documentation r=matklad a=arnaudgolfouse\n\nThis documents every item in the `vfs` crate, except for a few private, windows-specific items.\n\nCo-authored-by: Arnaud <arnaud.golfouse@free.fr>", "tree": {"sha": "7e25377045dbabc6063756af9fae72a1af9107a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e25377045dbabc6063756af9fae72a1af9107a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d635806ea5090426cd4a5a57601a7f823277e84c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgABllCRBK7hj4Ov3rIwAAdHIIAECl098SUk6aA2KZRLvR7hBc\nRNTfdXUE4yefG8B6LkG3ZcltK5/ZOReTLNYSewiqxUfzNAvHsFrr2KnDeGJzc8mP\nJh8Y6K5bvp59JszY3SAcHaFArXdN0BOn7JFl4KDjylI/SftBemzHbBbVUNhvsJL9\n55YoOrt1sNl6zqCyHIt7Ed0rWcgFZQQ7pij7j0nasjkPfqCw2ddsQ4c5n3Obthxa\nsN61OrsTINxLAKnFh3felNkMCnDu2oLB9qqBcm9gU7NvzmcXYHu9uFE+xHuItNVz\nArHkYS8nBzS6bQJl8pfPMGhhjjHJem62clBEKTT3tEPt4XtgtWomqWD55ZIXwZc=\n=UGFk\n-----END PGP SIGNATURE-----\n", "payload": "tree 7e25377045dbabc6063756af9fae72a1af9107a6\nparent 184f4cbf5df909146b05aaa3b7f2f0b27ac36590\nparent 4b71c8332daf9ef461891d278f2cf3530baaa833\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610619237 +0000\ncommitter GitHub <noreply@github.com> 1610619237 +0000\n\nMerge #7257\n\n7257: vfs documentation r=matklad a=arnaudgolfouse\n\nThis documents every item in the `vfs` crate, except for a few private, windows-specific items.\n\nCo-authored-by: Arnaud <arnaud.golfouse@free.fr>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d635806ea5090426cd4a5a57601a7f823277e84c", "html_url": "https://github.com/rust-lang/rust/commit/d635806ea5090426cd4a5a57601a7f823277e84c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d635806ea5090426cd4a5a57601a7f823277e84c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "184f4cbf5df909146b05aaa3b7f2f0b27ac36590", "url": "https://api.github.com/repos/rust-lang/rust/commits/184f4cbf5df909146b05aaa3b7f2f0b27ac36590", "html_url": "https://github.com/rust-lang/rust/commit/184f4cbf5df909146b05aaa3b7f2f0b27ac36590"}, {"sha": "4b71c8332daf9ef461891d278f2cf3530baaa833", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b71c8332daf9ef461891d278f2cf3530baaa833", "html_url": "https://github.com/rust-lang/rust/commit/4b71c8332daf9ef461891d278f2cf3530baaa833"}], "stats": {"total": 325, "additions": 321, "deletions": 4}, "files": [{"sha": "db15a2a21cd6e99a20a64253425751a7eaa5b310", "filename": "crates/vfs/src/anchored_path.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Fanchored_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Fanchored_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fanchored_path.rs?ref=d635806ea5090426cd4a5a57601a7f823277e84c", "patch": "@@ -26,14 +26,24 @@\n //! from the anchor than.\n use crate::FileId;\n \n+/// Path relative to a file.\n+///\n+/// Owned version of [`AnchoredPath`].\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct AnchoredPathBuf {\n+    /// File that this path is relative to.\n     pub anchor: FileId,\n+    /// Path relative to `anchor`'s containing directory.\n     pub path: String,\n }\n \n+/// Path relative to a file.\n+///\n+/// Borrowed version of [`AnchoredPathBuf`].\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub struct AnchoredPath<'a> {\n+    /// File that this path is relative to.\n     pub anchor: FileId,\n+    /// Path relative to `anchor`'s containing directory.\n     pub path: &'a str,\n }"}, {"sha": "0a4590c8db1abc2d8690ebce6af2a061ee1664f1", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=d635806ea5090426cd4a5a57601a7f823277e84c", "patch": "@@ -9,36 +9,50 @@ use rustc_hash::FxHashMap;\n \n use crate::{AnchoredPath, FileId, Vfs, VfsPath};\n \n+/// A set of [`VfsPath`]s identified by [`FileId`]s.\n #[derive(Default, Clone, Eq, PartialEq)]\n pub struct FileSet {\n     files: FxHashMap<VfsPath, FileId>,\n     paths: FxHashMap<FileId, VfsPath>,\n }\n \n impl FileSet {\n+    /// Returns the number of stored paths.\n     pub fn len(&self) -> usize {\n         self.files.len()\n     }\n+\n+    /// Get the id of the file corresponding to `path`.\n+    ///\n+    /// If either `path`'s [`anchor`](AnchoredPath::anchor) or the resolved path is not in\n+    /// the set, returns [`None`].\n     pub fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         let mut base = self.paths[&path.anchor].clone();\n         base.pop();\n         let path = base.join(path.path)?;\n         self.files.get(&path).copied()\n     }\n \n+    /// Get the id corresponding to `path` if it exists in the set.\n     pub fn file_for_path(&self, path: &VfsPath) -> Option<&FileId> {\n         self.files.get(path)\n     }\n \n+    /// Get the path corresponding to `file` if it exists in the set.\n     pub fn path_for_file(&self, file: &FileId) -> Option<&VfsPath> {\n         self.paths.get(file)\n     }\n \n+    /// Insert the `file_id, path` pair into the set.\n+    ///\n+    /// # Note\n+    /// Multiple [`FileId`] can be mapped to the same [`VfsPath`], and vice-versa.\n     pub fn insert(&mut self, file_id: FileId, path: VfsPath) {\n         self.files.insert(path.clone(), file_id);\n         self.paths.insert(file_id, path);\n     }\n \n+    /// Iterate over this set's ids.\n     pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n         self.paths.keys().copied()\n     }\n@@ -50,9 +64,31 @@ impl fmt::Debug for FileSet {\n     }\n }\n \n+/// This contains path prefixes to partition a [`Vfs`] into [`FileSet`]s.\n+///\n+/// # Example\n+/// ```rust\n+/// # use vfs::{file_set::FileSetConfigBuilder, VfsPath, Vfs};\n+/// let mut builder = FileSetConfigBuilder::default();\n+/// builder.add_file_set(vec![VfsPath::new_virtual_path(\"/src\".to_string())]);\n+/// let config = builder.build();\n+/// let mut file_system = Vfs::default();\n+/// file_system.set_file_contents(VfsPath::new_virtual_path(\"/src/main.rs\".to_string()), Some(vec![]));\n+/// file_system.set_file_contents(VfsPath::new_virtual_path(\"/src/lib.rs\".to_string()), Some(vec![]));\n+/// file_system.set_file_contents(VfsPath::new_virtual_path(\"/build.rs\".to_string()), Some(vec![]));\n+/// // contains the sets :\n+/// // { \"/src/main.rs\", \"/src/lib.rs\" }\n+/// // { \"build.rs\" }\n+/// let sets = config.partition(&file_system);\n+/// ```\n #[derive(Debug)]\n pub struct FileSetConfig {\n+    /// Number of sets that `self` can partition a [`Vfs`] into.\n+    ///\n+    /// This should be the number of sets in `self.map` + 1 for files that don't fit in any\n+    /// defined set.\n     n_file_sets: usize,\n+    /// Map from encoded paths to the set they belong to.\n     map: fst::Map<Vec<u8>>,\n }\n \n@@ -63,9 +99,14 @@ impl Default for FileSetConfig {\n }\n \n impl FileSetConfig {\n+    /// Returns a builder for `FileSetConfig`.\n     pub fn builder() -> FileSetConfigBuilder {\n         FileSetConfigBuilder::default()\n     }\n+\n+    /// Partition `vfs` into `FileSet`s.\n+    ///\n+    /// Creates a new [`FileSet`] for every set of prefixes in `self`.\n     pub fn partition(&self, vfs: &Vfs) -> Vec<FileSet> {\n         let mut scratch_space = Vec::new();\n         let mut res = vec![FileSet::default(); self.len()];\n@@ -75,9 +116,15 @@ impl FileSetConfig {\n         }\n         res\n     }\n+\n+    /// Number of sets that `self` can partition a [`Vfs`] into.\n     fn len(&self) -> usize {\n         self.n_file_sets\n     }\n+\n+    /// Returns the set index for the given `path`.\n+    ///\n+    /// `scratch_space` is used as a buffer and will be entirely replaced.\n     fn classify(&self, path: &VfsPath, scratch_space: &mut Vec<u8>) -> usize {\n         scratch_space.clear();\n         path.encode(scratch_space);\n@@ -91,6 +138,7 @@ impl FileSetConfig {\n     }\n }\n \n+/// Builder for [`FileSetConfig`].\n pub struct FileSetConfigBuilder {\n     roots: Vec<Vec<VfsPath>>,\n }\n@@ -102,12 +150,17 @@ impl Default for FileSetConfigBuilder {\n }\n \n impl FileSetConfigBuilder {\n+    /// Returns the number of sets currently held.\n     pub fn len(&self) -> usize {\n         self.roots.len()\n     }\n+\n+    /// Add a new set of paths prefixes.\n     pub fn add_file_set(&mut self, roots: Vec<VfsPath>) {\n         self.roots.push(roots)\n     }\n+\n+    /// Build the `FileSetConfig`.\n     pub fn build(self) -> FileSetConfig {\n         let n_file_sets = self.roots.len() + 1;\n         let map = {\n@@ -127,11 +180,15 @@ impl FileSetConfigBuilder {\n     }\n }\n \n+/// Implements [`fst::Automaton`]\n+///\n+/// It will match if `prefix_of` is a prefix of the given data.\n struct PrefixOf<'a> {\n     prefix_of: &'a [u8],\n }\n \n impl<'a> PrefixOf<'a> {\n+    /// Creates a new `PrefixOf` from the given slice.\n     fn new(prefix_of: &'a [u8]) -> Self {\n         Self { prefix_of }\n     }"}, {"sha": "e075d752b7ff4a7ebe2b70a8a2ed9543488a17bb", "filename": "crates/vfs/src/lib.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Flib.rs?ref=d635806ea5090426cd4a5a57601a7f823277e84c", "patch": "@@ -53,50 +53,89 @@ pub use crate::{\n };\n pub use paths::{AbsPath, AbsPathBuf};\n \n+/// Handle to a file in [`Vfs`]\n+///\n+/// Most functions in rust-analyzer use this when they need to refer to a file.\n #[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]\n pub struct FileId(pub u32);\n \n+/// Storage for all files read by rust-analyzer.\n+///\n+/// For more informations see the [crate-level](crate) documentation.\n #[derive(Default)]\n pub struct Vfs {\n     interner: PathInterner,\n     data: Vec<Option<Vec<u8>>>,\n     changes: Vec<ChangedFile>,\n }\n \n+/// Changed file in the [`Vfs`].\n pub struct ChangedFile {\n+    /// Id of the changed file\n     pub file_id: FileId,\n+    /// Kind of change\n     pub change_kind: ChangeKind,\n }\n \n impl ChangedFile {\n+    /// Returns `true` if the change is not [`Delete`](ChangeKind::Delete).\n     pub fn exists(&self) -> bool {\n         self.change_kind != ChangeKind::Delete\n     }\n+\n+    /// Returns `true` if the change is [`Create`](ChangeKind::Create) or\n+    /// [`Delete`](ChangeKind::Delete).\n     pub fn is_created_or_deleted(&self) -> bool {\n         matches!(self.change_kind, ChangeKind::Create | ChangeKind::Delete)\n     }\n }\n \n+/// Kind of [file change](ChangedFile).\n #[derive(Eq, PartialEq, Copy, Clone, Debug)]\n pub enum ChangeKind {\n+    /// The file was (re-)created\n     Create,\n+    /// The file was modified\n     Modify,\n+    /// The file was deleted\n     Delete,\n }\n \n impl Vfs {\n+    /// Amount of files currently stored.\n+    ///\n+    /// Note that this includes deleted files.\n     pub fn len(&self) -> usize {\n         self.data.len()\n     }\n+\n+    /// Id of the given path if it exists in the `Vfs` and is not deleted.\n     pub fn file_id(&self, path: &VfsPath) -> Option<FileId> {\n         self.interner.get(path).filter(|&it| self.get(it).is_some())\n     }\n+\n+    /// File path corresponding to the given `file_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the id is not present in the `Vfs`.\n     pub fn file_path(&self, file_id: FileId) -> VfsPath {\n         self.interner.lookup(file_id).clone()\n     }\n+\n+    /// File content corresponding to the given `file_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the id is not present in the `Vfs`, or if the corresponding file is\n+    /// deleted.\n     pub fn file_contents(&self, file_id: FileId) -> &[u8] {\n         self.get(file_id).as_deref().unwrap()\n     }\n+\n+    /// Returns an iterator over the stored ids and their corresponding paths.\n+    ///\n+    /// This will skip deleted files.\n     pub fn iter(&self) -> impl Iterator<Item = (FileId, &VfsPath)> + '_ {\n         (0..self.data.len())\n             .map(|it| FileId(it as u32))\n@@ -106,6 +145,13 @@ impl Vfs {\n                 (file_id, path)\n             })\n     }\n+\n+    /// Update the `path` with the given `contents`. `None` means the file was deleted.\n+    ///\n+    /// Returns `true` if the file was modified, and saves the [change](ChangedFile).\n+    ///\n+    /// If the path does not currently exists in the `Vfs`, allocates a new\n+    /// [`FileId`] for it.\n     pub fn set_file_contents(&mut self, path: VfsPath, contents: Option<Vec<u8>>) -> bool {\n         let file_id = self.alloc_file_id(path);\n         let change_kind = match (&self.get(file_id), &contents) {\n@@ -120,22 +166,46 @@ impl Vfs {\n         self.changes.push(ChangedFile { file_id, change_kind });\n         true\n     }\n+\n+    /// Returns `true` if the `Vfs` contains [changes](ChangedFile).\n     pub fn has_changes(&self) -> bool {\n         !self.changes.is_empty()\n     }\n+\n+    /// Drain and returns all the changes in the `Vfs`.\n     pub fn take_changes(&mut self) -> Vec<ChangedFile> {\n         mem::take(&mut self.changes)\n     }\n+\n+    /// Returns the id associated with `path`\n+    ///\n+    /// - If `path` does not exists in the `Vfs`, allocate a new id for it, associated with a\n+    /// deleted file;\n+    /// - Else, returns `path`'s id.\n+    ///\n+    /// Does not record a change.\n     fn alloc_file_id(&mut self, path: VfsPath) -> FileId {\n         let file_id = self.interner.intern(path);\n         let idx = file_id.0 as usize;\n         let len = self.data.len().max(idx + 1);\n         self.data.resize_with(len, || None);\n         file_id\n     }\n+\n+    /// Returns the content associated with the given `file_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if no file is associated to that id.\n     fn get(&self, file_id: FileId) -> &Option<Vec<u8>> {\n         &self.data[file_id.0 as usize]\n     }\n+\n+    /// Mutably returns the content associated with the given `file_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if no file is associated to that id.\n     fn get_mut(&mut self, file_id: FileId) -> &mut Option<Vec<u8>> {\n         &mut self.data[file_id.0 as usize]\n     }"}, {"sha": "d3bdae562d49a32ab1192c03f58c47ca91f01643", "filename": "crates/vfs/src/loader.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Floader.rs?ref=d635806ea5090426cd4a5a57601a7f823277e84c", "patch": "@@ -3,9 +3,12 @@ use std::fmt;\n \n use paths::{AbsPath, AbsPathBuf};\n \n+/// A set of files on the file system.\n #[derive(Debug, Clone)]\n pub enum Entry {\n+    /// The `Entry` is represented by a raw set of files.\n     Files(Vec<AbsPathBuf>),\n+    /// The `Entry` is represented by `Directories`.\n     Directories(Directories),\n }\n \n@@ -17,52 +20,108 @@ pub enum Entry {\n ///   * it is not under `exclude` path\n ///\n /// If many include/exclude paths match, the longest one wins.\n+///\n+/// If a path is in both `include` and `exclude`, the `exclude` one wins.\n #[derive(Debug, Clone, Default)]\n pub struct Directories {\n     pub extensions: Vec<String>,\n     pub include: Vec<AbsPathBuf>,\n     pub exclude: Vec<AbsPathBuf>,\n }\n \n+/// [`Handle`]'s configuration.\n #[derive(Debug)]\n pub struct Config {\n+    /// Set of initially loaded files.\n     pub load: Vec<Entry>,\n+    /// Index of watched entries in `load`.\n+    ///\n+    /// If a path in a watched entry is modified,the [`Handle`] should notify it.\n     pub watch: Vec<usize>,\n }\n \n+/// Message about an action taken by a [`Handle`].\n pub enum Message {\n+    /// Indicate a gradual progress.\n+    ///\n+    /// This is supposed to be the number of loaded files.\n     Progress { n_total: usize, n_done: usize },\n+    /// The handle loaded the following files' content.\n     Loaded { files: Vec<(AbsPathBuf, Option<Vec<u8>>)> },\n }\n \n+/// Type that will receive [`Messages`](Message) from a [`Handle`].\n pub type Sender = Box<dyn Fn(Message) + Send>;\n \n+/// Interface for reading and watching files.\n pub trait Handle: fmt::Debug {\n+    /// Spawn a new handle with the given `sender`.\n     fn spawn(sender: Sender) -> Self\n     where\n         Self: Sized;\n+\n+    /// Set this handle's configuration.\n     fn set_config(&mut self, config: Config);\n+\n+    /// The file's content at `path` has been modified, and should be reloaded.\n     fn invalidate(&mut self, path: AbsPathBuf);\n+\n+    /// Load the content of the given file, returning [`None`] if it does not\n+    /// exists.\n     fn load_sync(&mut self, path: &AbsPath) -> Option<Vec<u8>>;\n }\n \n impl Entry {\n+    /// Returns:\n+    /// ```text\n+    /// Entry::Directories(Directories {\n+    ///     extensions: [\"rs\"],\n+    ///     include: [base],\n+    ///     exclude: [base/.git],\n+    /// })\n+    /// ```\n     pub fn rs_files_recursively(base: AbsPathBuf) -> Entry {\n         Entry::Directories(dirs(base, &[\".git\"]))\n     }\n+\n+    /// Returns:\n+    /// ```text\n+    /// Entry::Directories(Directories {\n+    ///     extensions: [\"rs\"],\n+    ///     include: [base],\n+    ///     exclude: [base/.git, base/target],\n+    /// })\n+    /// ```\n     pub fn local_cargo_package(base: AbsPathBuf) -> Entry {\n         Entry::Directories(dirs(base, &[\".git\", \"target\"]))\n     }\n+\n+    /// Returns:\n+    /// ```text\n+    /// Entry::Directories(Directories {\n+    ///     extensions: [\"rs\"],\n+    ///     include: [base],\n+    ///     exclude: [base/.git, /tests, /examples, /benches],\n+    /// })\n+    /// ```\n     pub fn cargo_package_dependency(base: AbsPathBuf) -> Entry {\n         Entry::Directories(dirs(base, &[\".git\", \"/tests\", \"/examples\", \"/benches\"]))\n     }\n \n+    /// Returns `true` if `path` is included in `self`.\n+    ///\n+    /// See [`Directories::contains_file`].\n     pub fn contains_file(&self, path: &AbsPath) -> bool {\n         match self {\n             Entry::Files(files) => files.iter().any(|it| it == path),\n             Entry::Directories(dirs) => dirs.contains_file(path),\n         }\n     }\n+\n+    /// Returns `true` if `path` is included in `self`.\n+    ///\n+    /// - If `self` is `Entry::Files`, returns `false`\n+    /// - Else, see [`Directories::contains_dir`].\n     pub fn contains_dir(&self, path: &AbsPath) -> bool {\n         match self {\n             Entry::Files(_) => false,\n@@ -72,16 +131,29 @@ impl Entry {\n }\n \n impl Directories {\n+    /// Returns `true` if `path` is included in `self`.\n     pub fn contains_file(&self, path: &AbsPath) -> bool {\n         let ext = path.extension().unwrap_or_default();\n         if self.extensions.iter().all(|it| it.as_str() != ext) {\n             return false;\n         }\n         self.includes_path(path)\n     }\n+\n+    /// Returns `true` if `path` is included in `self`.\n+    ///\n+    /// Since `path` is supposed to be a directory, this will not take extension\n+    /// into account.\n     pub fn contains_dir(&self, path: &AbsPath) -> bool {\n         self.includes_path(path)\n     }\n+\n+    /// Returns `true` if `path` is included in `self`.\n+    ///\n+    /// It is included if\n+    ///   - An element in `self.include` is a prefix of `path`.\n+    ///   - This path is longer than any element in `self.exclude` that is a prefix\n+    ///     of `path`. In case of equality, exclusion wins.\n     fn includes_path(&self, path: &AbsPath) -> bool {\n         let mut include: Option<&AbsPathBuf> = None;\n         for incl in &self.include {\n@@ -105,6 +177,14 @@ impl Directories {\n     }\n }\n \n+/// Returns :\n+/// ```text\n+/// Directories {\n+///     extensions: [\"rs\"],\n+///     include: [base],\n+///     exclude: [base/<exclude>],\n+/// }\n+/// ```\n fn dirs(base: AbsPathBuf, exclude: &[&str]) -> Directories {\n     let exclude = exclude.iter().map(|it| base.join(it)).collect::<Vec<_>>();\n     Directories { extensions: vec![\"rs\".to_string()], include: vec![base], exclude }"}, {"sha": "2189e5e258e62015bc4b1984c3c4c288359dcf9c", "filename": "crates/vfs/src/path_interner.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Fpath_interner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Fpath_interner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fpath_interner.rs?ref=d635806ea5090426cd4a5a57601a7f823277e84c", "patch": "@@ -5,16 +5,25 @@ use rustc_hash::FxHashMap;\n \n use crate::{FileId, VfsPath};\n \n+/// Structure to map between [`VfsPath`] and [`FileId`].\n #[derive(Default)]\n pub(crate) struct PathInterner {\n     map: FxHashMap<VfsPath, FileId>,\n     vec: Vec<VfsPath>,\n }\n \n impl PathInterner {\n+    /// Get the id corresponding to `path`.\n+    ///\n+    /// If `path` does not exists in `self`, returns [`None`].\n     pub(crate) fn get(&self, path: &VfsPath) -> Option<FileId> {\n         self.map.get(path).copied()\n     }\n+\n+    /// Insert `path` in `self`.\n+    ///\n+    /// - If `path` already exists in `self`, returns its associated id;\n+    /// - Else, returns a newly allocated id.\n     pub(crate) fn intern(&mut self, path: VfsPath) -> FileId {\n         if let Some(id) = self.get(&path) {\n             return id;\n@@ -25,6 +34,11 @@ impl PathInterner {\n         id\n     }\n \n+    /// Returns the path corresponding to `id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `id` does not exists in `self`.\n     pub(crate) fn lookup(&self, id: FileId) -> &VfsPath {\n         &self.vec[id.0 as usize]\n     }"}, {"sha": "2b3d7fd84f03c3584cb2be83bb3aac04ad3c1c3e", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 90, "deletions": 4, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d635806ea5090426cd4a5a57601a7f823277e84c/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=d635806ea5090426cd4a5a57601a7f823277e84c", "patch": "@@ -3,25 +3,37 @@ use std::fmt;\n \n use paths::{AbsPath, AbsPathBuf};\n \n+/// Path in [`Vfs`].\n+///\n /// Long-term, we want to support files which do not reside in the file-system,\n-/// so we treat VfsPaths as opaque identifiers.\n+/// so we treat `VfsPath`s as opaque identifiers.\n+///\n+/// [`Vfs`]: crate::Vfs\n #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n pub struct VfsPath(VfsPathRepr);\n \n impl VfsPath {\n-    /// Creates an \"in-memory\" path from `/`-separates string.\n+    /// Creates an \"in-memory\" path from `/`-separated string.\n+    ///\n     /// This is most useful for testing, to avoid windows/linux differences\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `path` does not start with `'/'`.\n     pub fn new_virtual_path(path: String) -> VfsPath {\n         assert!(path.starts_with('/'));\n         VfsPath(VfsPathRepr::VirtualPath(VirtualPath(path)))\n     }\n \n+    /// Returns the `AbsPath` representation of `self` if `self` is on the file system.\n     pub fn as_path(&self) -> Option<&AbsPath> {\n         match &self.0 {\n             VfsPathRepr::PathBuf(it) => Some(it.as_path()),\n             VfsPathRepr::VirtualPath(_) => None,\n         }\n     }\n+\n+    /// Creates a new `VfsPath` with `path` adjoined to `self`.\n     pub fn join(&self, path: &str) -> Option<VfsPath> {\n         match &self.0 {\n             VfsPathRepr::PathBuf(it) => {\n@@ -34,12 +46,30 @@ impl VfsPath {\n             }\n         }\n     }\n+\n+    /// Remove the last component of `self` if there is one.\n+    ///\n+    /// If `self` has no component, returns `false`; else returns `true`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use vfs::{AbsPathBuf, VfsPath};\n+    /// let mut path = VfsPath::from(AbsPathBuf::assert(\"/foo/bar\".into()));\n+    /// assert!(path.pop());\n+    /// assert_eq!(path, VfsPath::from(AbsPathBuf::assert(\"/foo\".into())));\n+    /// assert!(path.pop());\n+    /// assert_eq!(path, VfsPath::from(AbsPathBuf::assert(\"/\".into())));\n+    /// assert!(!path.pop());\n+    /// ```\n     pub fn pop(&mut self) -> bool {\n         match &mut self.0 {\n             VfsPathRepr::PathBuf(it) => it.pop(),\n             VfsPathRepr::VirtualPath(it) => it.pop(),\n         }\n     }\n+\n+    /// Returns `true` if `other` is a prefix of `self`.\n     pub fn starts_with(&self, other: &VfsPath) -> bool {\n         match (&self.0, &other.0) {\n             (VfsPathRepr::PathBuf(lhs), VfsPathRepr::PathBuf(rhs)) => lhs.starts_with(rhs),\n@@ -48,6 +78,10 @@ impl VfsPath {\n             (VfsPathRepr::VirtualPath(_), _) => false,\n         }\n     }\n+\n+    /// Returns the `VfsPath` without its final component, if there is one.\n+    ///\n+    /// Returns [`None`] if the path is a root or prefix.\n     pub fn parent(&self) -> Option<VfsPath> {\n         let mut parent = self.clone();\n         if parent.pop() {\n@@ -57,6 +91,7 @@ impl VfsPath {\n         }\n     }\n \n+    /// Returns `self`'s base name and file extension.\n     pub fn name_and_extension(&self) -> Option<(&str, Option<&str>)> {\n         match &self.0 {\n             VfsPathRepr::PathBuf(p) => Some((\n@@ -67,7 +102,14 @@ impl VfsPath {\n         }\n     }\n \n-    // Don't make this `pub`\n+    /// **Don't make this `pub`**\n+    ///\n+    /// Encode the path in the given buffer.\n+    ///\n+    /// The encoding will be `0` if [`AbsPathBuf`], `1` if [`VirtualPath`], followed\n+    /// by `self`'s representation.\n+    ///\n+    /// Note that this encoding is dependent on the operating system.\n     pub(crate) fn encode(&self, buf: &mut Vec<u8>) {\n         let tag = match &self.0 {\n             VfsPathRepr::PathBuf(_) => 0,\n@@ -224,6 +266,7 @@ mod windows_paths {\n     }\n }\n \n+/// Internal, private representation of [`VfsPath`].\n #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n enum VfsPathRepr {\n     PathBuf(AbsPathBuf),\n@@ -260,13 +303,34 @@ impl fmt::Debug for VfsPathRepr {\n     }\n }\n \n+/// `/`-separated virtual path.\n+///\n+/// This is used to describe files that do not reside on the file system.\n #[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n struct VirtualPath(String);\n \n impl VirtualPath {\n+    /// Returns `true` if `other` is a prefix of `self` (as strings).\n     fn starts_with(&self, other: &VirtualPath) -> bool {\n         self.0.starts_with(&other.0)\n     }\n+\n+    /// Remove the last component of `self`.\n+    ///\n+    /// This will find the last `'/'` in `self`, and remove everything after it,\n+    /// including the `'/'`.\n+    ///\n+    /// If `self` contains no `'/'`, returns `false`; else returns `true`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let mut path = VirtualPath(\"/foo/bar\".to_string());\n+    /// path.pop();\n+    /// assert_eq!(path.0, \"/foo\");\n+    /// path.pop();\n+    /// assert_eq!(path.0, \"\");\n+    /// ```\n     fn pop(&mut self) -> bool {\n         let pos = match self.0.rfind('/') {\n             Some(pos) => pos,\n@@ -275,6 +339,17 @@ impl VirtualPath {\n         self.0 = self.0[..pos].to_string();\n         true\n     }\n+\n+    /// Append the given *relative* path `path` to `self`.\n+    ///\n+    /// This will resolve any leading `\"../\"` in `path` before appending it.\n+    ///\n+    /// Returns [`None`] if `path` has more leading `\"../\"` than the number of\n+    /// components in `self`.\n+    ///\n+    /// # Notes\n+    ///\n+    /// In practice, appending here means `self/path` as strings.\n     fn join(&self, mut path: &str) -> Option<VirtualPath> {\n         let mut res = self.clone();\n         while path.starts_with(\"../\") {\n@@ -287,7 +362,18 @@ impl VirtualPath {\n         Some(res)\n     }\n \n-    pub(crate) fn name_and_extension(&self) -> Option<(&str, Option<&str>)> {\n+    /// Returns `self`'s base name and file extension.\n+    ///\n+    /// # Returns\n+    /// - `None` if `self` ends with `\"//\"`.\n+    /// - `Some((name, None))` if `self`'s base contains no `.`, or only one `.` at\n+    /// the start.\n+    /// - `Some((name, Some(extension))` else.\n+    ///\n+    /// # Note\n+    /// The extension will not contains `.`. This means `\"/foo/bar.baz.rs\"` will\n+    /// return `Some((\"bar.baz\", Some(\"rs\"))`.\n+    fn name_and_extension(&self) -> Option<(&str, Option<&str>)> {\n         let file_path = if self.0.ends_with('/') { &self.0[..&self.0.len() - 1] } else { &self.0 };\n         let file_name = match file_path.rfind('/') {\n             Some(position) => &file_path[position + 1..],"}]}