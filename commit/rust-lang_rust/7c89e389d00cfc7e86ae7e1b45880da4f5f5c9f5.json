{"sha": "7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjODllMzg5ZDAwY2ZjN2U4NmFlN2UxYjQ1ODgwZGE0ZjVmNWM5ZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-22T07:21:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-22T07:21:45Z"}, "message": "Auto merge of #87265 - Aaron1011:hir-wf-fn, r=estebank\n\nSupport HIR wf checking for function signatures\n\nDuring function type-checking, we normalize any associated types in\nthe function signature (argument types + return type), and then\ncreate WF obligations for each of the normalized types. The HIR wf code\ndoes not currently support this case, so any errors that we get have\nimprecise spans.\n\nThis commit extends `ObligationCauseCode::WellFormed` to support\nrecording a function parameter, allowing us to get the corresponding\nHIR type if an error occurs. Function typechecking is modified to\npass this information during signature normalization and WF checking.\nThe resulting code is fairly verbose, due to the fact that we can\nno longer normalize the entire signature with a single function call.\n\nAs part of the refactoring, we now perform HIR-based WF checking\nfor several other 'typed items' (statics, consts, and inherent impls).\n\nAs a result, WF and projection errors in a function signature now\nhave a precise span, which points directly at the responsible type.\nIf a function signature is constructed via a macro, this will allow\nthe error message to point at the code 'most responsible' for the error\n(e.g. a user-supplied macro argument).", "tree": {"sha": "69fef2ffb11540b48a6f63f21e82b8ec1a24beab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69fef2ffb11540b48a6f63f21e82b8ec1a24beab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "html_url": "https://github.com/rust-lang/rust/commit/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7db08eeb0057de86ea2bdbd4c3a085cb8516b653", "url": "https://api.github.com/repos/rust-lang/rust/commits/7db08eeb0057de86ea2bdbd4c3a085cb8516b653", "html_url": "https://github.com/rust-lang/rust/commit/7db08eeb0057de86ea2bdbd4c3a085cb8516b653"}, {"sha": "db0324ebb2961bbeb1a75641fd1ca38d6462b721", "url": "https://api.github.com/repos/rust-lang/rust/commits/db0324ebb2961bbeb1a75641fd1ca38d6462b721", "html_url": "https://github.com/rust-lang/rust/commit/db0324ebb2961bbeb1a75641fd1ca38d6462b721"}], "stats": {"total": 331, "additions": 240, "deletions": 91}, "files": [{"sha": "392372fad531ead1f3b8c7164264e56089658d86", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -29,7 +29,10 @@ fn fn_decl<'hir>(node: Node<'hir>) -> Option<&'hir FnDecl<'hir>> {\n         Node::Item(Item { kind: ItemKind::Fn(sig, _, _), .. })\n         | Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(sig, _), .. })\n         | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(sig, _), .. }) => Some(&sig.decl),\n-        Node::Expr(Expr { kind: ExprKind::Closure(_, fn_decl, ..), .. }) => Some(fn_decl),\n+        Node::Expr(Expr { kind: ExprKind::Closure(_, fn_decl, ..), .. })\n+        | Node::ForeignItem(ForeignItem { kind: ForeignItemKind::Fn(fn_decl, ..), .. }) => {\n+            Some(fn_decl)\n+        }\n         _ => None,\n     }\n }"}, {"sha": "0908b6a1763d50c32129019ce2e63435908dadd5", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1722,7 +1722,7 @@ rustc_queries! {\n     /// span) for an *existing* error. Therefore, it is best-effort, and may never handle\n     /// all of the cases that the normal `ty::Ty`-based wfcheck does. This is fine,\n     /// because the `ty::Ty`-based wfcheck is always run.\n-    query diagnostic_hir_wf_check(key: (ty::Predicate<'tcx>, hir::HirId)) -> Option<traits::ObligationCause<'tcx>> {\n+    query diagnostic_hir_wf_check(key: (ty::Predicate<'tcx>, traits::WellFormedLoc)) -> Option<traits::ObligationCause<'tcx>> {\n         eval_always\n         no_hash\n         desc { \"performing HIR wf-checking for predicate {:?} at item {:?}\", key.0, key.1 }"}, {"sha": "a4a2e824637570b96200cb42163fe7a60a764292", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -16,7 +16,7 @@ use crate::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Constness;\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n@@ -327,17 +327,39 @@ pub enum ObligationCauseCode<'tcx> {\n     /// If `X` is the concrete type of an opaque type `impl Y`, then `X` must implement `Y`\n     OpaqueType,\n \n-    /// Well-formed checking. If a `HirId` is provided,\n-    /// it is used to perform HIR-based wf checking if an error\n-    /// occurs, in order to generate a more precise error message.\n+    /// Well-formed checking. If a `WellFormedLoc` is provided,\n+    /// then it will be used to eprform HIR-based wf checking\n+    /// after an error occurs, in order to generate a more precise error span.\n     /// This is purely for diagnostic purposes - it is always\n-    /// correct to use `MiscObligation` instead\n-    WellFormed(Option<hir::HirId>),\n+    /// correct to use `MiscObligation` instead, or to specify\n+    /// `WellFormed(None)`\n+    WellFormed(Option<WellFormedLoc>),\n \n     /// From `match_impl`. The cause for us having to match an impl, and the DefId we are matching against.\n     MatchImpl(Lrc<ObligationCauseCode<'tcx>>, DefId),\n }\n \n+/// The 'location' at which we try to perform HIR-based wf checking.\n+/// This information is used to obtain an `hir::Ty`, which\n+/// we can walk in order to obtain precise spans for any\n+/// 'nested' types (e.g. `Foo` in `Option<Foo>`).\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n+pub enum WellFormedLoc {\n+    /// Use the type of the provided definition.\n+    Ty(LocalDefId),\n+    /// Use the type of the parameter of the provided function.\n+    /// We cannot use `hir::Param`, since the function may\n+    /// not have a body (e.g. a trait method definition)\n+    Param {\n+        /// The function to lookup the parameter in\n+        function: LocalDefId,\n+        /// The index of the parameter to use.\n+        /// Parameters are indexed from 0, with the return type\n+        /// being the last 'parameter'\n+        param_idx: u16,\n+    },\n+}\n+\n impl ObligationCauseCode<'_> {\n     // Return the base obligation, ignoring derived obligations.\n     pub fn peel_derives(&self) -> &Self {"}, {"sha": "4ce49032398bc7877cc2438953c63fec117cfcfc", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1682,7 +1682,7 @@ nop_list_lift! {bound_variable_kinds; ty::BoundVariableKind => ty::BoundVariable\n // This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n \n-CloneLiftImpls! { for<'tcx> { Constness, } }\n+CloneLiftImpls! { for<'tcx> { Constness, traits::WellFormedLoc, } }\n \n pub mod tls {\n     use super::{ptr_eq, GlobalCtxt, TyCtxt};"}, {"sha": "0ad360c7d89c37bdccc8997d24460b49f51f00e3", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,9 +1,9 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::HirId;\n use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::mir;\n+use rustc_middle::traits;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -397,7 +397,7 @@ impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n     }\n }\n \n-impl<'tcx> Key for (ty::Predicate<'tcx>, HirId) {\n+impl<'tcx> Key for (ty::Predicate<'tcx>, traits::WellFormedLoc) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true"}, {"sha": "13a6733fb478abebca8f623ed2c8ae4eb930fd69", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -242,11 +242,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             SelectionError::Unimplemented => {\n                 // If this obligation was generated as a result of well-formed checking, see if we\n                 // can get a better error message by performing HIR-based well formed checking.\n-                if let ObligationCauseCode::WellFormed(Some(wf_hir_id)) =\n+                if let ObligationCauseCode::WellFormed(Some(wf_loc)) =\n                     root_obligation.cause.code.peel_derives()\n                 {\n                     if let Some(cause) =\n-                        self.tcx.diagnostic_hir_wf_check((obligation.predicate, *wf_hir_id))\n+                        self.tcx.diagnostic_hir_wf_check((obligation.predicate, wf_loc.clone()))\n                     {\n                         obligation.cause = cause;\n                         span = obligation.cause.span;"}, {"sha": "865e4ccc0b63f506b7c7e237e76fc764ffa20b1c", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -40,6 +40,7 @@ use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n+    WellFormedLoc,\n };\n \n use std::collections::hash_map::Entry;\n@@ -419,13 +420,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         value: T,\n-        hir_id: hir::HirId,\n+        loc: WellFormedLoc,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         self.inh.normalize_associated_types_in_with_cause(\n-            ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(Some(hir_id))),\n+            ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(Some(loc))),\n             self.param_env,\n             value,\n         )"}, {"sha": "98980c65bc815dcd1831cb61139bc518d82b3ac8", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -22,8 +22,9 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_trait_selection::opaque_types::may_define_opaque_type;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n \n+use std::convert::TryInto;\n use std::iter;\n use std::ops::ControlFlow;\n \n@@ -386,7 +387,7 @@ fn check_associated_item(\n     span: Span,\n     sig_if_method: Option<&hir::FnSig<'_>>,\n ) {\n-    let code = ObligationCauseCode::WellFormed(Some(item_id));\n+    let code = ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(item_id.expect_owner())));\n     for_id(tcx, item_id, span).with_fcx(|fcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n@@ -400,7 +401,11 @@ fn check_associated_item(\n         match item.kind {\n             ty::AssocKind::Const => {\n                 let ty = fcx.tcx.type_of(item.def_id);\n-                let ty = fcx.normalize_associated_types_in_wf(span, ty, item_id);\n+                let ty = fcx.normalize_associated_types_in_wf(\n+                    span,\n+                    ty,\n+                    WellFormedLoc::Ty(item_id.expect_owner()),\n+                );\n                 fcx.register_wf_obligation(ty.into(), span, code.clone());\n             }\n             ty::AssocKind::Fn => {\n@@ -422,7 +427,11 @@ fn check_associated_item(\n                 }\n                 if item.defaultness.has_value() {\n                     let ty = fcx.tcx.type_of(item.def_id);\n-                    let ty = fcx.normalize_associated_types_in_wf(span, ty, item_id);\n+                    let ty = fcx.normalize_associated_types_in_wf(\n+                        span,\n+                        ty,\n+                        WellFormedLoc::Ty(item_id.expect_owner()),\n+                    );\n                     fcx.register_wf_obligation(ty.into(), span, code.clone());\n                 }\n             }\n@@ -621,7 +630,11 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n \n     for_id(tcx, item_id, ty_span).with_fcx(|fcx| {\n         let ty = tcx.type_of(tcx.hir().local_def_id(item_id));\n-        let item_ty = fcx.normalize_associated_types_in_wf(ty_span, ty, item_id);\n+        let item_ty = fcx.normalize_associated_types_in_wf(\n+            ty_span,\n+            ty,\n+            WellFormedLoc::Ty(item_id.expect_owner()),\n+        );\n \n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n@@ -634,7 +647,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n         fcx.register_wf_obligation(\n             item_ty.into(),\n             ty_span,\n-            ObligationCauseCode::WellFormed(Some(item_id)),\n+            ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(item_id.expect_owner()))),\n         );\n         if forbid_unsized {\n             fcx.register_bound(\n@@ -684,7 +697,9 @@ fn check_impl<'tcx>(\n                 fcx.register_wf_obligation(\n                     self_ty.into(),\n                     ast_self_ty.span,\n-                    ObligationCauseCode::WellFormed(Some(item.hir_id())),\n+                    ObligationCauseCode::WellFormed(Some(WellFormedLoc::Ty(\n+                        item.hir_id().expect_owner(),\n+                    ))),\n                 );\n             }\n         }\n@@ -901,11 +916,48 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     implied_bounds: &mut Vec<Ty<'tcx>>,\n ) {\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, sig);\n-    let sig = fcx.normalize_associated_types_in(span, sig);\n \n-    for (&input_ty, ty) in iter::zip(sig.inputs(), hir_decl.inputs) {\n-        fcx.register_wf_obligation(input_ty.into(), ty.span, ObligationCauseCode::WellFormed(None));\n+    // Normalize the input and output types one at a time, using a different\n+    // `WellFormedLoc` for each. We cannot call `normalize_associated_types`\n+    // on the entire `FnSig`, since this would use the same `WellFormedLoc`\n+    // for each type, preventing the HIR wf check from generating\n+    // a nice error message.\n+    let ty::FnSig { mut inputs_and_output, c_variadic, unsafety, abi } = sig;\n+    inputs_and_output =\n+        fcx.tcx.mk_type_list(inputs_and_output.iter().enumerate().map(|(i, ty)| {\n+            fcx.normalize_associated_types_in_wf(\n+                span,\n+                ty,\n+                WellFormedLoc::Param {\n+                    function: def_id.expect_local(),\n+                    // Note that the `param_idx` of the output type is\n+                    // one greater than the index of the last input type.\n+                    param_idx: i.try_into().unwrap(),\n+                },\n+            )\n+        }));\n+    // Manually call `normalize_assocaited_types_in` on the other types\n+    // in `FnSig`. This ensures that if the types of these fields\n+    // ever change to include projections, we will start normalizing\n+    // them automatically.\n+    let sig = ty::FnSig {\n+        inputs_and_output,\n+        c_variadic: fcx.normalize_associated_types_in(span, c_variadic),\n+        unsafety: fcx.normalize_associated_types_in(span, unsafety),\n+        abi: fcx.normalize_associated_types_in(span, abi),\n+    };\n+\n+    for (i, (&input_ty, ty)) in iter::zip(sig.inputs(), hir_decl.inputs).enumerate() {\n+        fcx.register_wf_obligation(\n+            input_ty.into(),\n+            ty.span,\n+            ObligationCauseCode::WellFormed(Some(WellFormedLoc::Param {\n+                function: def_id.expect_local(),\n+                param_idx: i.try_into().unwrap(),\n+            })),\n+        );\n     }\n+\n     implied_bounds.extend(sig.inputs());\n \n     fcx.register_wf_obligation("}, {"sha": "c1af10f5ce45125c5bab44482b19f9aa68ee111b", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 69, "deletions": 22, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -3,10 +3,10 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::HirId;\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::TraitEngine;\n+use rustc_infer::traits::{ObligationCause, WellFormedLoc};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, ToPredicate, TyCtxt};\n+use rustc_middle::ty::{self, Region, ToPredicate, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_trait_selection::traits;\n \n pub fn provide(providers: &mut Providers) {\n@@ -17,21 +17,20 @@ pub fn provide(providers: &mut Providers) {\n // need access to `ItemCtxt`\n fn diagnostic_hir_wf_check<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    (predicate, hir_id): (ty::Predicate<'tcx>, HirId),\n+    (predicate, loc): (ty::Predicate<'tcx>, WellFormedLoc),\n ) -> Option<ObligationCause<'tcx>> {\n     let hir = tcx.hir();\n-    // HIR wfcheck should only ever happen as part of improving an existing error\n-    tcx.sess.delay_span_bug(hir.span(hir_id), \"Performed HIR wfcheck without an existing error!\");\n \n-    // Currently, we only handle WF checking for items (e.g. associated items).\n-    // It would be nice to extend this to handle wf checks inside functions.\n-    let def_id = match tcx.hir().opt_local_def_id(hir_id) {\n-        Some(def_id) => def_id,\n-        None => return None,\n+    let def_id = match loc {\n+        WellFormedLoc::Ty(def_id) => def_id,\n+        WellFormedLoc::Param { function, param_idx: _ } => function,\n     };\n+    let hir_id = HirId::make_owner(def_id);\n+\n+    // HIR wfcheck should only ever happen as part of improving an existing error\n+    tcx.sess\n+        .delay_span_bug(tcx.def_span(def_id), \"Performed HIR wfcheck without an existing error!\");\n \n-    // FIXME - figure out how we want to handle wf-checking for\n-    // things inside a function body.\n     let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n \n     // To perform HIR-based WF checking, we iterate over all HIR types\n@@ -72,7 +71,8 @@ fn diagnostic_hir_wf_check<'tcx>(\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             self.tcx.infer_ctxt().enter(|infcx| {\n                 let mut fulfill = traits::FulfillmentContext::new();\n-                let tcx_ty = self.icx.to_ty(ty);\n+                let tcx_ty =\n+                    self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n                 let cause = traits::ObligationCause::new(\n                     ty.span,\n                     self.hir_id,\n@@ -119,19 +119,66 @@ fn diagnostic_hir_wf_check<'tcx>(\n         depth: 0,\n     };\n \n-    let ty = match tcx.hir().get(hir_id) {\n-        hir::Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::TyAlias(ty) => Some(ty),\n-            _ => None,\n-        },\n-        hir::Node::TraitItem(item) => match item.kind {\n-            hir::TraitItemKind::Type(_, ty) => ty,\n-            _ => None,\n+    // Get the starting `hir::Ty` using our `WellFormedLoc`.\n+    // We will walk 'into' this type to try to find\n+    // a more precise span for our predicate.\n+    let ty = match loc {\n+        WellFormedLoc::Ty(_) => match hir.get(hir_id) {\n+            hir::Node::ImplItem(item) => match item.kind {\n+                hir::ImplItemKind::TyAlias(ty) => Some(ty),\n+                ref item => bug!(\"Unexpected ImplItem {:?}\", item),\n+            },\n+            hir::Node::TraitItem(item) => match item.kind {\n+                hir::TraitItemKind::Type(_, ty) => ty,\n+                ref item => bug!(\"Unexpected TraitItem {:?}\", item),\n+            },\n+            hir::Node::Item(item) => match item.kind {\n+                hir::ItemKind::Static(ty, _, _) | hir::ItemKind::Const(ty, _) => Some(ty),\n+                hir::ItemKind::Impl(ref impl_) => {\n+                    assert!(impl_.of_trait.is_none(), \"Unexpected trait impl: {:?}\", impl_);\n+                    Some(impl_.self_ty)\n+                }\n+                ref item => bug!(\"Unexpected item {:?}\", item),\n+            },\n+            ref node => bug!(\"Unexpected node {:?}\", node),\n         },\n-        _ => None,\n+        WellFormedLoc::Param { function: _, param_idx } => {\n+            let fn_decl = hir.fn_decl_by_hir_id(hir_id).unwrap();\n+            // Get return type\n+            if param_idx as usize == fn_decl.inputs.len() {\n+                match fn_decl.output {\n+                    hir::FnRetTy::Return(ty) => Some(ty),\n+                    // The unit type `()` is always well-formed\n+                    hir::FnRetTy::DefaultReturn(_span) => None,\n+                }\n+            } else {\n+                Some(&fn_decl.inputs[param_idx as usize])\n+            }\n+        }\n     };\n     if let Some(ty) = ty {\n         visitor.visit_ty(ty);\n     }\n     visitor.cause\n }\n+\n+struct EraseAllBoundRegions<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+// Higher ranked regions are complicated.\n+// To make matters worse, the HIR WF check can instantiate them\n+// outside of a `Binder`, due to the way we (ab)use\n+// `ItemCtxt::to_ty`. To make things simpler, we just erase all\n+// of them, regardless of depth. At worse, this will give\n+// us an inaccurate span for an error message, but cannot\n+// lead to unsoundess (we call `delay_span_bug` at the start\n+// of `diagnostic_hir_wf_check`).\n+impl<'tcx> TypeFolder<'tcx> for EraseAllBoundRegions<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+        if let ty::ReLateBound(..) = r { &ty::ReErased } else { r }\n+    }\n+}"}, {"sha": "25e80159b0b180cf5e7080206c5a23bb56595df9", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,11 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-for-unimpl-trait.rs:10:8\n+  --> $DIR/associated-types-for-unimpl-trait.rs:10:40\n    |\n+LL | trait Get {\n+   | --------- required by this bound in `Get`\n+...\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |        ^^^^ the trait `Get` is not implemented for `Self`\n+   |                                        ^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "19500f58aa6883d721d6dbd02e94220635693b2f", "filename": "src/test/ui/associated-types/associated-types-no-suitable-bound.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,11 @@\n error[E0277]: the trait bound `T: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-bound.rs:11:8\n+  --> $DIR/associated-types-no-suitable-bound.rs:11:21\n    |\n+LL | trait Get {\n+   | --------- required by this bound in `Get`\n+...\n LL |     fn uhoh<T>(foo: <T as Get>::Value) {}\n-   |        ^^^^ the trait `Get` is not implemented for `T`\n+   |                     ^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |"}, {"sha": "0e978f20a6634237dc8ca2a383025ba0b44d3158", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait-2.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,11 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:8\n+  --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:40\n    |\n+LL | trait Get {\n+   | --------- required by this bound in `Get`\n+...\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |        ^^^^ the trait `Get` is not implemented for `Self`\n+   |                                        ^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "1ec3c05983aefdc193557b482cd82ba8f4945ebc", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,19 +1,25 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait.rs:17:8\n+  --> $DIR/associated-types-no-suitable-supertrait.rs:17:40\n    |\n+LL | trait Get {\n+   | --------- required by this bound in `Get`\n+...\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |        ^^^^ the trait `Get` is not implemented for `Self`\n+   |                                        ^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get {}\n    |                                                              ^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `(T, U): Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait.rs:22:8\n+  --> $DIR/associated-types-no-suitable-supertrait.rs:22:40\n    |\n+LL | trait Get {\n+   | --------- required by this bound in `Get`\n+...\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n-   |        ^^^^ the trait `Get` is not implemented for `(T, U)`\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `(T, U)`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b6ee1ed733c3e99cc0f82f280bc964083bd170bc", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,11 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:8\n+  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:40\n    |\n+LL | trait Get {\n+   | --------- required by this bound in `Get`\n+...\n LL |     fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value);\n-   |        ^^^^ the trait `Get` is not implemented for `Self`\n+   |                                        ^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "319e6c2c032a0e067bf9fd2009cfe3416fbc63f9", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-ret.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/object-safety-err-ret.rs:17:15\n+  --> $DIR/object-safety-err-ret.rs:17:16\n    |\n LL | fn use_dyn(v: &dyn Foo) {\n-   |               ^^^^^^^^ `Foo` cannot be made into an object\n+   |                ^^^^^^^ `Foo` cannot be made into an object\n    |\n    = help: consider moving `test` to another trait\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>"}, {"sha": "cead9776e4abb3a4a4d96319cbc747a6d84df428", "filename": "src/test/ui/error-codes/E0038.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Ferror-codes%2FE0038.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Ferror-codes%2FE0038.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0038.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Trait` cannot be made into an object\n-  --> $DIR/E0038.rs:5:16\n+  --> $DIR/E0038.rs:5:20\n    |\n LL | fn call_foo(x: Box<dyn Trait>) {\n-   |                ^^^^^^^^^^^^^^ `Trait` cannot be made into an object\n+   |                    ^^^^^^^^^ `Trait` cannot be made into an object\n    |\n    = help: consider moving `foo` to another trait\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>"}, {"sha": "c13c05f146a7e676f94dadf53f7ca31eb8b773a9", "filename": "src/test/ui/feature-gates/feature-gate-object_safe_for_dispatch.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `NonObjectSafe1` cannot be made into an object\n-  --> $DIR/feature-gate-object_safe_for_dispatch.rs:18:38\n+  --> $DIR/feature-gate-object_safe_for_dispatch.rs:18:39\n    |\n LL | fn takes_non_object_safe_ref<T>(obj: &dyn NonObjectSafe1) {\n-   |                                      ^^^^^^^^^^^^^^^^^^^ `NonObjectSafe1` cannot be made into an object\n+   |                                       ^^^^^^^^^^^^^^^^^^ `NonObjectSafe1` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/feature-gate-object_safe_for_dispatch.rs:4:23\n@@ -35,10 +35,10 @@ LL |     fn static_fn() where Self: Sized {}\n    |                    ^^^^^^^^^^^^^^^^^\n \n error[E0038]: the trait `NonObjectSafe3` cannot be made into an object\n-  --> $DIR/feature-gate-object_safe_for_dispatch.rs:27:35\n+  --> $DIR/feature-gate-object_safe_for_dispatch.rs:27:39\n    |\n LL | fn takes_non_object_safe_box(obj: Box<dyn NonObjectSafe3>) {\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^ `NonObjectSafe3` cannot be made into an object\n+   |                                       ^^^^^^^^^^^^^^^^^^ `NonObjectSafe3` cannot be made into an object\n    |\n    = help: consider moving `foo` to another trait\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>"}, {"sha": "8651789688eaa75d4f850b00e1a19382a6f23eb3", "filename": "src/test/ui/generic-associated-types/gat-in-trait-path.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-in-trait-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-in-trait-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-in-trait-path.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/gat-in-trait-path.rs:21:13\n+  --> $DIR/gat-in-trait-path.rs:21:17\n    |\n LL | fn f(_arg : Box<dyn for<'a> Foo<A<'a> = &'a ()>>) {}\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Foo` cannot be made into an object\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Foo` cannot be made into an object\n    |\n    = help: consider moving `A` to another trait\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>"}, {"sha": "b4b89ab047363ce28c2cf43558a2c455b4484b8a", "filename": "src/test/ui/generic-associated-types/issue-67510-pass.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67510-pass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67510-pass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67510-pass.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `X` cannot be made into an object\n-  --> $DIR/issue-67510-pass.rs:7:19\n+  --> $DIR/issue-67510-pass.rs:7:23\n    |\n LL | fn _func1<'a>(_x: Box<dyn X<Y<'a>=&'a ()>>) {}\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ `X` cannot be made into an object\n+   |                       ^^^^^^^^^^^^^^^^^^^ `X` cannot be made into an object\n    |\n    = help: consider moving `Y` to another trait\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>"}, {"sha": "6429bb8159e1f9899debc6bce4e7d442e6148a3e", "filename": "src/test/ui/generic-associated-types/trait-objects.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Ftrait-objects.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Ftrait-objects.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Ftrait-objects.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `StreamingIterator` cannot be made into an object\n-  --> $DIR/trait-objects.rs:10:16\n+  --> $DIR/trait-objects.rs:10:21\n    |\n LL | fn min_size(x: &mut dyn for<'a> StreamingIterator<Item<'a> = &'a i32>) -> usize {\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `StreamingIterator` cannot be made into an object\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `StreamingIterator` cannot be made into an object\n    |\n    = help: consider moving `Item` to another trait\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>"}, {"sha": "0e942e80e254436dca5792928e63162bcb2811ef", "filename": "src/test/ui/issues/issue-18611.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,11 @@\n error[E0277]: the trait bound `isize: HasState` is not satisfied\n-  --> $DIR/issue-18611.rs:1:4\n+  --> $DIR/issue-18611.rs:1:18\n    |\n LL | fn add_state(op: <isize as HasState>::State) {\n-   |    ^^^^^^^^^ the trait `HasState` is not implemented for `isize`\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HasState` is not implemented for `isize`\n+...\n+LL | trait HasState {\n+   | -------------- required by this bound in `HasState`\n \n error: aborting due to previous error\n "}, {"sha": "2a5416ce85ba65e78140c4a40aaa85dce68c7338", "filename": "src/test/ui/issues/issue-18959.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fissues%2Fissue-18959.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fissues%2Fissue-18959.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18959.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/issue-18959.rs:11:11\n+  --> $DIR/issue-18959.rs:11:12\n    |\n LL | fn foo(b: &dyn Bar) {\n-   |           ^^^^^^^^ `Bar` cannot be made into an object\n+   |            ^^^^^^^ `Bar` cannot be made into an object\n    |\n    = help: consider moving `foo` to another trait\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>"}, {"sha": "f332b7213d8bcc6e5b13b6721308bca4383af306", "filename": "src/test/ui/suggestions/object-unsafe-trait-references-self.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fsuggestions%2Fobject-unsafe-trait-references-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fsuggestions%2Fobject-unsafe-trait-references-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fobject-unsafe-trait-references-self.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Trait` cannot be made into an object\n-  --> $DIR/object-unsafe-trait-references-self.rs:6:11\n+  --> $DIR/object-unsafe-trait-references-self.rs:6:12\n    |\n LL | fn bar(x: &dyn Trait) {}\n-   |           ^^^^^^^^^^ `Trait` cannot be made into an object\n+   |            ^^^^^^^^^ `Trait` cannot be made into an object\n    |\n    = help: consider moving `baz` to another trait\n    = help: consider moving `bat` to another trait\n@@ -17,10 +17,10 @@ LL |     fn bat(&self) -> Self {}\n    |                      ^^^^ ...because method `bat` references the `Self` type in its return type\n \n error[E0038]: the trait `Other` cannot be made into an object\n-  --> $DIR/object-unsafe-trait-references-self.rs:10:11\n+  --> $DIR/object-unsafe-trait-references-self.rs:10:12\n    |\n LL | fn foo(x: &dyn Other) {}\n-   |           ^^^^^^^^^^ `Other` cannot be made into an object\n+   |            ^^^^^^^^^ `Other` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-unsafe-trait-references-self.rs:8:14"}, {"sha": "4c18f6d79d077d679f92d2b1911c2a84555a0c38", "filename": "src/test/ui/suggestions/object-unsafe-trait-should-use-where-sized.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fsuggestions%2Fobject-unsafe-trait-should-use-where-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fsuggestions%2Fobject-unsafe-trait-should-use-where-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fobject-unsafe-trait-should-use-where-sized.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Trait` cannot be made into an object\n-  --> $DIR/object-unsafe-trait-should-use-where-sized.rs:9:11\n+  --> $DIR/object-unsafe-trait-should-use-where-sized.rs:9:12\n    |\n LL | fn bar(x: &dyn Trait) {}\n-   |           ^^^^^^^^^^ `Trait` cannot be made into an object\n+   |            ^^^^^^^^^ `Trait` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-unsafe-trait-should-use-where-sized.rs:5:8"}, {"sha": "f6b48938f9b04437bf699c469ca51c284f135498", "filename": "src/test/ui/wf/wf-foreign-fn-decl-ret.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,8 +1,11 @@\n error[E0277]: the trait bound `(): Foo` is not satisfied\n-  --> $DIR/wf-foreign-fn-decl-ret.rs:11:12\n+  --> $DIR/wf-foreign-fn-decl-ret.rs:11:25\n    |\n+LL | pub trait Foo {\n+   | ------------- required by this bound in `Foo`\n+...\n LL |     pub fn lint_me() -> <() as Foo>::Assoc;\n-   |            ^^^^^^^ the trait `Foo` is not implemented for `()`\n+   |                         ^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `()`\n \n error[E0277]: the trait bound `u32: Unsatisfied` is not satisfied\n   --> $DIR/wf-foreign-fn-decl-ret.rs:14:32"}, {"sha": "ca90e9222dea9c9f29773f7a5153a9cd4ddbc47b", "filename": "src/test/ui/wf/wf-in-fn-arg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-arg.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `T: Copy` is not satisfied\n-  --> $DIR/wf-in-fn-arg.rs:10:14\n+  --> $DIR/wf-in-fn-arg.rs:10:15\n    |\n LL | struct MustBeCopy<T:Copy> {\n    |                     ---- required by this bound in `MustBeCopy`\n ...\n LL | fn bar<T>(_: &MustBeCopy<T>)\n-   |              ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+   |               ^^^^^^^^^^^^^ the trait `Copy` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |"}, {"sha": "2a129538f76333bbfb69cf8b829a255f8947227a", "filename": "src/test/ui/wf/wf-trait-default-fn-arg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-arg.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `Self: Eq` is not satisfied\n-  --> $DIR/wf-trait-default-fn-arg.rs:11:22\n+  --> $DIR/wf-trait-default-fn-arg.rs:11:23\n    |\n LL | struct Bar<T:Eq+?Sized> { value: Box<T> }\n    |              -- required by this bound in `Bar`\n ...\n LL |     fn bar(&self, x: &Bar<Self>) {\n-   |                      ^^^^^^^^^^ the trait `Eq` is not implemented for `Self`\n+   |                       ^^^^^^^^^ the trait `Eq` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "7693aa6d2d583ed64a597ddc705a1488cea19216", "filename": "src/test/ui/wf/wf-trait-fn-arg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-arg.stderr?ref=7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `Self: Eq` is not satisfied\n-  --> $DIR/wf-trait-fn-arg.rs:10:22\n+  --> $DIR/wf-trait-fn-arg.rs:10:23\n    |\n LL | struct Bar<T:Eq+?Sized> { value: Box<T> }\n    |              -- required by this bound in `Bar`\n ...\n LL |     fn bar(&self, x: &Bar<Self>);\n-   |                      ^^^^^^^^^^ the trait `Eq` is not implemented for `Self`\n+   |                       ^^^^^^^^^ the trait `Eq` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}]}