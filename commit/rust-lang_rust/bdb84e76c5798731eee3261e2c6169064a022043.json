{"sha": "bdb84e76c5798731eee3261e2c6169064a022043", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYjg0ZTc2YzU3OTg3MzFlZWUzMjYxZTJjNjE2OTA2NGEwMjIwNDM=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-04T23:17:13Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-04T23:17:13Z"}, "message": "Merge branch 'master' of github.com:graydon/rust", "tree": {"sha": "6f19db4fa5bb6b6f813f83d4f09ad61d27558161", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f19db4fa5bb6b6f813f83d4f09ad61d27558161"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdb84e76c5798731eee3261e2c6169064a022043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdb84e76c5798731eee3261e2c6169064a022043", "html_url": "https://github.com/rust-lang/rust/commit/bdb84e76c5798731eee3261e2c6169064a022043", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdb84e76c5798731eee3261e2c6169064a022043/comments", "author": null, "committer": null, "parents": [{"sha": "0e70332b295d72e9b70e5db59382e507a416b8e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e70332b295d72e9b70e5db59382e507a416b8e8", "html_url": "https://github.com/rust-lang/rust/commit/0e70332b295d72e9b70e5db59382e507a416b8e8"}, {"sha": "ae3312002a87d673ae97a9e75455060fcd111069", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae3312002a87d673ae97a9e75455060fcd111069", "html_url": "https://github.com/rust-lang/rust/commit/ae3312002a87d673ae97a9e75455060fcd111069"}], "stats": {"total": 234, "additions": 163, "deletions": 71}, "files": [{"sha": "6a53767491fce3ef4c0cc747ecf72a1ec92b6e21", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=bdb84e76c5798731eee3261e2c6169064a022043", "patch": "@@ -47,30 +47,21 @@ const vec_elt_pad: int = 3;\n const vec_elt_data: int = 4;\n \n const tydesc_field_first_param: int = 0;\n-\n const tydesc_field_size: int = 1;\n-\n const tydesc_field_align: int = 2;\n-\n const tydesc_field_copy_glue: int = 3;\n-\n const tydesc_field_drop_glue: int = 4;\n-\n const tydesc_field_free_glue: int = 5;\n-\n const tydesc_field_sever_glue: int = 6;\n-\n const tydesc_field_mark_glue: int = 7;\n-\n-\n // FIXME no longer used in rustc, drop when rustboot is gone\n const tydesc_field_obj_drop_glue: int = 8;\n-\n const tydesc_field_is_stateful: int = 9;\n-\n const tydesc_field_cmp_glue: int = 10;\n-\n-const n_tydesc_fields: int = 11;\n+const tydesc_field_shape: int = 11;\n+const tydesc_field_shape_tables: int = 12;\n+const tydesc_field_n_params: int = 13;\n+const n_tydesc_fields: int = 14;\n \n const cmp_glue_op_eq: uint = 0u;\n "}, {"sha": "0793d390d57d0a9bf8c94b361eab971c0f937237", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=bdb84e76c5798731eee3261e2c6169064a022043", "patch": "@@ -895,7 +895,8 @@ fn linearize_ty_params(cx: &@block_ctxt, t: &ty::t) ->\n \n fn trans_stack_local_derived_tydesc(cx: &@block_ctxt, llsz: ValueRef,\n                                     llalign: ValueRef, llroottydesc: ValueRef,\n-                                    llparamtydescs: ValueRef) -> ValueRef {\n+                                    llparamtydescs: ValueRef,\n+                                    n_params: uint) -> ValueRef {\n     let llmyroottydesc = alloca(cx, bcx_ccx(cx).tydesc_type);\n     // By convention, desc 0 is the root descriptor.\n \n@@ -904,11 +905,14 @@ fn trans_stack_local_derived_tydesc(cx: &@block_ctxt, llsz: ValueRef,\n     // Store a pointer to the rest of the descriptors.\n \n     let llfirstparam = cx.build.GEP(llparamtydescs, ~[C_int(0), C_int(0)]);\n-    cx.build.Store(llfirstparam,\n-                   cx.build.GEP(llmyroottydesc, ~[C_int(0), C_int(0)]));\n-    cx.build.Store(llsz, cx.build.GEP(llmyroottydesc, ~[C_int(0), C_int(1)]));\n-    cx.build.Store(llalign,\n-                   cx.build.GEP(llmyroottydesc, ~[C_int(0), C_int(2)]));\n+    store_inbounds(cx, llfirstparam, llmyroottydesc,\n+                   ~[C_int(0), C_int(abi::tydesc_field_first_param)]);\n+    store_inbounds(cx, C_uint(n_params), llmyroottydesc,\n+                   ~[C_int(0), C_int(abi::tydesc_field_n_params)]);\n+    store_inbounds(cx, llsz, llmyroottydesc,\n+                   ~[C_int(0), C_int(abi::tydesc_field_size)]);\n+    store_inbounds(cx, llalign, llmyroottydesc,\n+                   ~[C_int(0), C_int(abi::tydesc_field_align)]);\n     ret llmyroottydesc;\n }\n \n@@ -964,7 +968,8 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n         v = td_val;\n     } else {\n         let llparamtydescs =\n-            alloca(bcx, T_array(T_ptr(bcx_ccx(bcx).tydesc_type), n_params));\n+            alloca(bcx, T_array(T_ptr(bcx_ccx(bcx).tydesc_type),\n+                                n_params + 1u));\n         let i = 0;\n         for td: ValueRef  in tys.descs {\n             let tdp = bcx.build.GEP(llparamtydescs, ~[C_int(0), C_int(i)]);\n@@ -973,7 +978,7 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n         }\n         v =\n             trans_stack_local_derived_tydesc(bcx, sz.val, align.val, root,\n-                                             llparamtydescs);\n+                                             llparamtydescs, n_params);\n     }\n     bcx.fcx.derived_tydescs.insert(t, {lltydesc: v, escapes: escapes});\n     ret rslt(cx, v);\n@@ -1191,20 +1196,28 @@ fn emit_tydescs(ccx: &@crate_ctxt) {\n               none. { ccx.stats.n_null_glues += 1u; C_null(cmp_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n-        let  // copy_glue\n-             // drop_glue\n-             // free_glue\n-             // sever_glue\n-             // mark_glue\n-             // obj_drop_glue\n-             // is_stateful\n-            tydesc =\n+\n+        let shape = shape::shape_of(ccx, pair.key);\n+        let shape_tables =\n+            llvm::LLVMConstPointerCast(ccx.shape_cx.llshapetables,\n+                                       T_ptr(T_i8()));\n+\n+        let tydesc =\n             C_named_struct(ccx.tydesc_type,\n-                           ~[C_null(T_ptr(T_ptr(ccx.tydesc_type))), ti.size,\n-                             ti.align, copy_glue, drop_glue, free_glue,\n-                             C_null(glue_fn_ty), C_null(glue_fn_ty),\n-                             C_null(glue_fn_ty), C_null(glue_fn_ty),\n-                             cmp_glue]); // cmp_glue\n+                           ~[C_null(T_ptr(T_ptr(ccx.tydesc_type))),\n+                             ti.size,               // size\n+                             ti.align,              // align\n+                             copy_glue,             // copy_glue\n+                             drop_glue,             // drop_glue\n+                             free_glue,             // free_glue\n+                             C_null(glue_fn_ty),    // sever_glue\n+                             C_null(glue_fn_ty),    // mark_glue\n+                             C_null(glue_fn_ty),    // obj_drop_glue\n+                             C_null(glue_fn_ty),    // is_stateful\n+                             cmp_glue,              // cmp_glue\n+                             C_shape(ccx, shape),   // shape\n+                             shape_tables,          // shape_tables\n+                             C_int(0)]);            // n_params\n \n         let gvar = ti.tydesc;\n         llvm::LLVMSetInitializer(gvar, tydesc);\n@@ -2288,16 +2301,17 @@ fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: &ty::t,\n     let ti = none[@tydesc_info];\n     let r = get_tydesc(cx, t, false, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, ti);\n+    let lltydesc = r.val;\n     let lltydescs =\n-        r.bcx.build.GEP(r.val,\n+        r.bcx.build.GEP(lltydesc,\n                         ~[C_int(0), C_int(abi::tydesc_field_first_param)]);\n     lltydescs = r.bcx.build.Load(lltydescs);\n \n     let llfn;\n     alt ti {\n       none. {\n         let llfnptr =\n-            r.bcx.build.GEP(r.val,\n+            r.bcx.build.GEP(lltydesc,\n                             ~[C_int(0), C_int(abi::tydesc_field_cmp_glue)]);\n         llfn = r.bcx.build.Load(llfnptr);\n       }\n@@ -2306,7 +2320,7 @@ fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: &ty::t,\n \n     let llcmpresultptr = alloca(r.bcx, T_i1());\n     let llargs: ValueRef[] =\n-        ~[llcmpresultptr, r.bcx.fcx.lltaskptr, C_null(T_ptr(T_nil())),\n+        ~[llcmpresultptr, r.bcx.fcx.lltaskptr, lltydesc,\n           lltydescs, llrawlhsptr, llrawrhsptr, llop];\n     r.bcx.build.Call(llfn, llargs);\n     ret rslt(r.bcx, r.bcx.build.Load(llcmpresultptr));\n@@ -2366,7 +2380,7 @@ fn call_memmove(cx: &@block_ctxt, dst: ValueRef, src: ValueRef,\n     let src_ptr = cx.build.PointerCast(src, T_ptr(T_i8()));\n     let dst_ptr = cx.build.PointerCast(dst, T_ptr(T_i8()));\n     let size = cx.build.IntCast(n_bytes, T_i32());\n-    let align = C_int(0);\n+    let align = C_int(1);\n     let volatile = C_bool(false);\n     ret rslt(cx,\n              cx.build.Call(memmove,\n@@ -2397,7 +2411,12 @@ fn memmove_ty(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: &ty::t) ->\n     if ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n         let llsz = size_of(cx, t);\n         ret call_memmove(llsz.bcx, dst, src, llsz.val);\n-    } else { ret rslt(cx, cx.build.Store(cx.build.Load(src), dst)); }\n+    } else if ty::type_is_structural(bcx_tcx(cx), t) {\n+        let llsz = llsize_of(type_of(bcx_ccx(cx), cx.sp, t));\n+        ret call_memmove(cx, dst, src, llsz);\n+    } else {\n+        ret rslt(cx, cx.build.Store(cx.build.Load(src), dst));\n+    }\n }\n \n // Duplicates any heap-owned memory owned by a value of the given type.\n@@ -4696,7 +4715,7 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn trans_args(cx: &@block_ctxt, llenv: ValueRef, llobj: &option::t[ValueRef],\n+fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n               gen: &option::t[generic_info], lliterbody: &option::t[ValueRef],\n               es: &(@ast::expr)[], fn_ty: &ty::t) ->\n    {bcx: @block_ctxt, args: ValueRef[], retslot: ValueRef} {\n@@ -4815,8 +4834,7 @@ fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n \n     let ret_ty = ty::node_id_to_type(bcx_tcx(cx), id);\n     let args_res =\n-        trans_args(bcx, llenv, f_res.llobj, f_res.generic, lliterbody, args,\n-                   fn_ty);\n+        trans_args(bcx, llenv, f_res.generic, lliterbody, args, fn_ty);\n     bcx = args_res.bcx;\n     let llargs = args_res.args;\n     let llretslot = args_res.retslot;\n@@ -8000,8 +8018,9 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n     trans_mod(cx, crate.node.module);\n     create_crate_map(ccx);\n     emit_tydescs(ccx);\n-    // Translate the metadata:\n+    shape::gen_shape_tables(ccx);\n \n+    // Translate the metadata.\n     write_metadata(cx.ccx, crate);\n     if ccx.sess.get_opts().stats {\n         log_err \"--- trans stats ---\";"}, {"sha": "cdfff0ffe9a908d9603e10189f8a6bc2a485aa22", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=bdb84e76c5798731eee3261e2c6169064a022043", "patch": "@@ -433,7 +433,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &ast::arm[],\n             ret rslt(cx, cx.build.Unreachable());\n         }\n         else {\n-            ret rslt(cx, C_nil());\n+            ret er;\n         }\n     }\n "}, {"sha": "e0b26a97c9fcb63ece38be4abc0914ff024070bb", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=bdb84e76c5798731eee3261e2c6169064a022043", "patch": "@@ -597,22 +597,13 @@ fn T_tydesc(taskptr_type: TypeRef) -> TypeRef {\n         T_ptr(T_fn(~[T_ptr(T_nil()), taskptr_type, T_ptr(T_nil()), tydescpp,\n                      pvoid], T_void()));\n     let cmp_glue_fn_ty =\n-        T_ptr(T_fn(~[T_ptr(T_i1()), taskptr_type, T_ptr(T_nil()), tydescpp,\n+        T_ptr(T_fn(~[T_ptr(T_i1()), taskptr_type, T_ptr(tydesc), tydescpp,\n                      pvoid, pvoid, T_i8()], T_void()));\n \n-    let  // first_param\n-         // size\n-         // align\n-         // copy_glue\n-         // drop_glue\n-         // free_glue\n-         // sever_glue\n-         // mark_glue\n-         // obj_drop_glue\n-         // is_stateful\n-        elems =\n+    let elems =\n         ~[tydescpp, T_int(), T_int(), glue_fn_ty, glue_fn_ty, glue_fn_ty,\n-          glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty, cmp_glue_fn_ty];\n+          glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty, cmp_glue_fn_ty,\n+          T_ptr(T_i8()), T_ptr(T_i8()), T_int()];\n     set_struct_body(tydesc, elems);\n     ret tydesc;\n }\n@@ -874,3 +865,14 @@ fn C_bytes(bytes : &u8[]) -> ValueRef {\n                               ivec::len(bytes), False);\n }\n \n+fn C_shape(ccx : &@crate_ctxt, bytes : &u8[]) -> ValueRef {\n+    let llshape = C_bytes(bytes);\n+    let llglobal = llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape),\n+                                       str::buf(ccx.names.next(\"shape\")));\n+    llvm::LLVMSetInitializer(llglobal, llshape);\n+    llvm::LLVMSetGlobalConstant(llglobal, True);\n+    llvm::LLVMSetLinkage(llglobal,\n+                         lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n+    ret llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n+}\n+"}, {"sha": "00f2e6a1b86b2de32456ca8c622c1a856b2e15f8", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 66, "deletions": 10, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=bdb84e76c5798731eee3261e2c6169064a022043", "patch": "@@ -184,6 +184,7 @@ export type_param;\n export unify;\n export variant_info;\n export walk_ty;\n+export occurs_check_fails;\n \n // Data types\n tag mode { mo_val; mo_alias(bool); }\n@@ -655,6 +656,7 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n       ty_str. {/* no-op */ }\n       ty_istr. {/* no-op */ }\n       ty_type. {/* no-op */ }\n+      ty_task. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n       ty_box(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_vec(tm) { walk_ty(cx, walker, tm.ty); }\n@@ -686,6 +688,9 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n         walk_ty(cx, walker, sub);\n         for tp: t  in tps { walk_ty(cx, walker, tp); }\n       }\n+      ty_constr(sub, _) {\n+        walk_ty(cx, walker, sub);\n+      }\n       ty_var(_) {/* no-op */ }\n       ty_param(_,_) {/* no-op */ }\n     }\n@@ -1393,6 +1398,24 @@ fn type_param(cx: &ctxt, ty: &t) -> option::t[uint] {\n     ret none;\n }\n \n+// Returns an ivec of all the type variables\n+// occurring in t. It may contain duplicates.\n+fn vars_in_type(cx:&ctxt, ty: &t) -> int[] {\n+    fn collect_var(cx:&ctxt, vars: &@mutable int[], ty: t) {\n+        alt struct(cx, ty) {\n+          ty_var(v) {\n+            *vars += ~[v];\n+          }\n+          _ {}\n+        }\n+    }\n+    let rslt: @mutable int[] = @mutable (~[]);\n+    walk_ty(cx, bind collect_var(cx, rslt, _), ty);\n+    // Works because of a \"convenient\" bug that lets us\n+    // return a mutable ivec as if it's immutable\n+    ret *rslt;\n+}\n+\n fn type_autoderef(cx: &ctxt, t: &ty::t) -> ty::t {\n     let t1: ty::t = t;\n     while true {\n@@ -1990,6 +2013,32 @@ fn is_lval(expr: &@ast::expr) -> bool {\n     }\n }\n \n+fn occurs_check_fails(tcx: &ctxt, sp: &option::t[span], vid: int, rt: &t)\n+    -> bool {\n+    if (!type_contains_vars(tcx, rt)) {\n+        // Fast path\n+        ret false;\n+    }\n+    // Occurs check!\n+    if ivec::member(vid, vars_in_type(tcx, rt)) {\n+        alt sp {\n+          some (s) {\n+            // Maybe this should be span_err -- however, there's an\n+            // assertion later on that the type doesn't contain\n+            // variables, so in this case we have to be sure to die.\n+            tcx.sess.span_fatal(s,\n+                                \"Type inference failed because I \\\n+               could not find a type\\n that's both of the form \" +\n+               ty_to_str(tcx, ty::mk_var(tcx, (vid)))\n+              + \" and of the form \" + ty_to_str(tcx, rt)\n+              + \". Such a type would have to be infinitely \\\n+               large.\");\n+          }\n+          _ { ret true; }\n+        }\n+    }\n+    else { ret false; }\n+}\n \n // Type unification via Robinson's algorithm (Robinson 1965). Implemented as\n // described in Hoder and Voronkov:\n@@ -2318,9 +2367,6 @@ mod unify {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n-        // TODO: occurs check, to make sure we don't loop forever when\n-        // unifying e.g. 'a and option['a]\n-\n         // Fast path.\n \n         if eq_ty(expected, actual) { ret ures_ok(expected); }\n@@ -2694,9 +2740,15 @@ mod unify {\n     }\n \n     // Fixups and substitutions\n-    fn fixup_vars(tcx: ty_ctxt, vb: @var_bindings, typ: t) -> fixup_result {\n-        fn subst_vars(tcx: ty_ctxt, vb: @var_bindings,\n+    //    Takes an optional span - complain about occurs check violations\n+    //    iff the span is present (so that if we already know we're going\n+    //    to error anyway, we don't complain)\n+    fn fixup_vars(tcx: ty_ctxt, sp: &option::t[span],\n+                  vb: @var_bindings, typ: t) -> fixup_result {\n+        fn subst_vars(tcx: ty_ctxt, sp: &option::t[span], vb: @var_bindings,\n                       unresolved: @mutable option::t[int], vid: int) -> t {\n+            // Should really return a fixup_result instead of a t, but fold_ty\n+            // doesn't allow returning anything but a t.\n             if vid as uint >= ufindivec::set_count(vb.sets) {\n                 *unresolved = some(vid);\n                 ret ty::mk_var(tcx, vid);\n@@ -2705,29 +2757,33 @@ mod unify {\n             alt smallintmap::find[t](vb.types, root_id) {\n               none. { *unresolved = some(vid); ret ty::mk_var(tcx, vid); }\n               some(rt) {\n+                if occurs_check_fails(tcx, sp, vid, rt) {\n+      // Return the type unchanged, so we can error out downstream\n+                    ret rt;\n+                }\n                 ret fold_ty(tcx,\n-                            fm_var(bind subst_vars(tcx, vb, unresolved, _)),\n-                            rt);\n+                  fm_var(bind subst_vars(tcx, sp, vb, unresolved, _)), rt);\n               }\n             }\n         }\n         let unresolved = @mutable none[int];\n         let rty =\n-            fold_ty(tcx, fm_var(bind subst_vars(tcx, vb, unresolved, _)),\n+            fold_ty(tcx, fm_var(bind subst_vars(tcx, sp, vb, unresolved, _)),\n                     typ);\n         let ur = *unresolved;\n         alt ur {\n           none. { ret fix_ok(rty); }\n           some(var_id) { ret fix_err(var_id); }\n         }\n     }\n-    fn resolve_type_var(tcx: &ty_ctxt, vb: &@var_bindings, vid: int) ->\n+    fn resolve_type_var(tcx: &ty_ctxt, sp: &option::t[span],\n+                        vb: &@var_bindings, vid: int) ->\n        fixup_result {\n         if vid as uint >= ufindivec::set_count(vb.sets) { ret fix_err(vid); }\n         let root_id = ufindivec::find(vb.sets, vid as uint);\n         alt smallintmap::find[t](vb.types, root_id) {\n           none. { ret fix_err(vid); }\n-          some(rt) { ret fixup_vars(tcx, vb, rt); }\n+          some(rt) { ret fixup_vars(tcx, sp, vb, rt); }\n         }\n     }\n }"}, {"sha": "e5a8f7eba8a4333d4a1d5c1865707196a837a22e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb84e76c5798731eee3261e2c6169064a022043/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=bdb84e76c5798731eee3261e2c6169064a022043", "patch": "@@ -879,7 +879,18 @@ fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> ty::t {\n     let t1 = t;\n     while true {\n         alt structure_of(fcx, sp, t1) {\n-          ty::ty_box(inner) { t1 = inner.ty; }\n+          ty::ty_box(inner) {\n+            alt ty::struct(fcx.ccx.tcx, t1) {\n+              ty::ty_var(v1) {\n+                if ty::occurs_check_fails(fcx.ccx.tcx, some(sp), v1,\n+                                          ty::mk_box(fcx.ccx.tcx, inner)) {\n+                    break;\n+                }\n+              }\n+              _ {}\n+            }\n+            t1 = inner.ty;\n+          }\n           ty::ty_res(_, inner, tps) {\n             t1 = ty::substitute_type_params(fcx.ccx.tcx, tps, inner);\n           }\n@@ -942,7 +953,7 @@ fn do_fn_block_coerce(fcx: &@fn_ctxt, sp: &span, actual: &ty::t,\n \n \n fn resolve_type_vars_if_possible(fcx: &@fn_ctxt, typ: ty::t) -> ty::t {\n-    alt ty::unify::fixup_vars(fcx.ccx.tcx, fcx.var_bindings, typ) {\n+    alt ty::unify::fixup_vars(fcx.ccx.tcx, none, fcx.var_bindings, typ) {\n       fix_ok(new_type) { ret new_type; }\n       fix_err(_) { ret typ; }\n     }\n@@ -1073,7 +1084,8 @@ mod writeback {\n     fn resolve_type_vars_in_type(fcx: &@fn_ctxt, sp: &span, typ: ty::t) ->\n        option::t[ty::t] {\n         if !ty::type_contains_vars(fcx.ccx.tcx, typ) { ret some(typ); }\n-        alt ty::unify::fixup_vars(fcx.ccx.tcx, fcx.var_bindings, typ) {\n+        alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp),\n+                                  fcx.var_bindings, typ) {\n           fix_ok(new_type) { ret some(new_type); }\n           fix_err(vid) {\n             fcx.ccx.tcx.sess.span_err(sp,\n@@ -1139,7 +1151,7 @@ mod writeback {\n         if !wbcx.success { ret; }\n         let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n         let fix_rslt =\n-            ty::unify::resolve_type_var(wbcx.fcx.ccx.tcx,\n+            ty::unify::resolve_type_var(wbcx.fcx.ccx.tcx, some(l.span),\n                                         wbcx.fcx.var_bindings, var_id);\n         alt fix_rslt {\n           fix_ok(lty) { write::ty_only(wbcx.fcx.ccx.tcx, l.node.id, lty); }"}, {"sha": "9b5536e57c36e46450ebbdd849154a7abff15708", "filename": "src/test/compile-fail/occurs-check-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdb84e76c5798731eee3261e2c6169064a022043/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb84e76c5798731eee3261e2c6169064a022043/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs?ref=bdb84e76c5798731eee3261e2c6169064a022043", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern: Type inference failed because I could not find\n+fn main() {\n+    let f = @f;\n+    f();\n+}\n\\ No newline at end of file"}, {"sha": "a2bd12fcc354a80ae93935f445cd608f1d5f92ff", "filename": "src/test/compile-fail/occurs-check.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdb84e76c5798731eee3261e2c6169064a022043/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb84e76c5798731eee3261e2c6169064a022043/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=bdb84e76c5798731eee3261e2c6169064a022043", "patch": "@@ -0,0 +1,4 @@\n+// error-pattern: Type inference failed because I could not find\n+fn main() {\n+    let f = @f;\n+}"}, {"sha": "3183b580fc6e51bbe9ff4c276cd202facfc1570a", "filename": "src/test/run-pass/alt-bot-2.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdb84e76c5798731eee3261e2c6169064a022043/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb84e76c5798731eee3261e2c6169064a022043/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot-2.rs?ref=bdb84e76c5798731eee3261e2c6169064a022043", "patch": "@@ -0,0 +1,3 @@\n+// n.b. This was only ever failing with optimization disabled.\n+fn a() -> int { alt ret 1 { 2 { 3 } } }\n+fn main() { a(); }"}]}