{"sha": "732081829263fd02b6995ff815d4c001cce460cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMjA4MTgyOTI2M2ZkMDJiNjk5NWZmODE1ZDRjMDAxY2NlNDYwY2Y=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-10-19T20:00:21Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-11T22:06:54Z"}, "message": "Fix soundness issue with index bounds checks\n\nAn expression like `x[1][{ x = y; 2}]` would perform the bounds check\nfor the inner index operation before evaluating the outer index. This\nwould allow out of bounds memory accesses.", "tree": {"sha": "85bba20f06dc94d4b775a41613da6110acc7fa38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85bba20f06dc94d4b775a41613da6110acc7fa38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/732081829263fd02b6995ff815d4c001cce460cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/732081829263fd02b6995ff815d4c001cce460cf", "html_url": "https://github.com/rust-lang/rust/commit/732081829263fd02b6995ff815d4c001cce460cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/732081829263fd02b6995ff815d4c001cce460cf/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ff89c5614a381849ec4f4b2d06b5eb274850371", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff89c5614a381849ec4f4b2d06b5eb274850371", "html_url": "https://github.com/rust-lang/rust/commit/2ff89c5614a381849ec4f4b2d06b5eb274850371"}], "stats": {"total": 624, "additions": 500, "deletions": 124}, "files": [{"sha": "fd2063e2da984c329d62a71ba59a86af7e17f50a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/732081829263fd02b6995ff815d4c001cce460cf/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732081829263fd02b6995ff815d4c001cce460cf/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=732081829263fd02b6995ff815d4c001cce460cf", "patch": "@@ -1665,6 +1665,15 @@ pub enum FakeReadCause {\n     /// Therefore, we insert a \"fake read\" here to ensure that we get\n     /// appropriate errors.\n     ForLet,\n+\n+    /// If we have an index expression like\n+    ///\n+    /// (*x)[1][{ x = y; 4}]\n+    ///\n+    /// then the first bounds check is invalidated when we evaluate the second\n+    /// index expression. Thus we create a fake borrow of `x` across the second\n+    /// indexer, which will cause a borrow check error.\n+    ForIndex,\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n@@ -1764,9 +1773,8 @@ impl_stable_hash_for!(struct Static<'tcx> {\n     def_id\n });\n \n-#[derive(\n-    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n-)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),"}, {"sha": "ebc25138a06191d452469d24d13bf59e38eb3493", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 101, "deletions": 53, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/732081829263fd02b6995ff815d4c001cce460cf/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732081829263fd02b6995ff815d4c001cce460cf/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=732081829263fd02b6995ff815d4c001cce460cf", "patch": "@@ -2,9 +2,9 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc::mir::{\n-    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue,\n-    Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n+    FakeReadCause, Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef,\n+    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -380,42 +380,38 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let first_borrow_desc;\n         let mut err = match (\n             gen_borrow_kind,\n-            \"immutable\",\n-            \"mutable\",\n             issued_borrow.kind,\n-            \"immutable\",\n-            \"mutable\",\n         ) {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt) => {\n+            (BorrowKind::Shared, BorrowKind::Mut { .. }) => {\n                 first_borrow_desc = \"mutable \";\n                 self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n-                    lft,\n+                    \"immutable\",\n                     issued_span,\n                     \"it\",\n-                    rgt,\n+                    \"mutable\",\n                     &msg_borrow,\n                     None,\n                 )\n             }\n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n+            (BorrowKind::Mut { .. }, BorrowKind::Shared) => {\n                 first_borrow_desc = \"immutable \";\n                 self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n-                    lft,\n+                    \"mutable\",\n                     issued_span,\n                     \"it\",\n-                    rgt,\n+                    \"immutable\",\n                     &msg_borrow,\n                     None,\n                 )\n             }\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n+            (BorrowKind::Mut { .. }, BorrowKind::Mut { .. }) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_mutably_borrow_multiply(\n                     span,\n@@ -427,7 +423,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )\n             }\n \n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n+            (BorrowKind::Unique, BorrowKind::Unique) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_uniquely_borrow_by_two_closures(\n                     span,\n@@ -437,25 +433,45 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )\n             }\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Shallow, _, _)\n-            | (BorrowKind::Unique, _, _, BorrowKind::Shallow, _, _) => {\n-                let mut err = self.cannot_mutate_in_match_guard(\n-                    span,\n-                    issued_span,\n-                    &desc_place,\n-                    \"mutably borrow\",\n-                );\n-                borrow_spans.var_span_label(\n-                    &mut err,\n-                    format!(\n-                        \"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe()\n-                    ),\n-                );\n+            (BorrowKind::Mut { .. }, BorrowKind::Shallow)\n+            | (BorrowKind::Unique, BorrowKind::Shallow) => {\n+                if let Some(immutable_section_description) = self.classify_immutable_section(\n+                    &issued_borrow.assigned_place,\n+                ) {\n+                    let mut err = self.cannot_mutate_in_immutable_section(\n+                        span,\n+                        issued_span,\n+                        &desc_place,\n+                        immutable_section_description,\n+                        \"mutably borrow\",\n+                    );\n+                    borrow_spans.var_span_label(\n+                        &mut err,\n+                        format!(\n+                            \"borrow occurs due to use of `{}`{}\",\n+                            desc_place,\n+                            borrow_spans.describe(),\n+                        ),\n+                    );\n \n-                return err;\n+                    return err;\n+                } else {\n+                    first_borrow_desc = \"immutable \";\n+                    self.cannot_reborrow_already_borrowed(\n+                        span,\n+                        &desc_place,\n+                        &msg_place,\n+                        \"mutable\",\n+                        issued_span,\n+                        \"it\",\n+                        \"immutable\",\n+                        &msg_borrow,\n+                        None,\n+                    )\n+                }\n             }\n \n-            (BorrowKind::Unique, _, _, _, _, _) => {\n+            (BorrowKind::Unique, _) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_uniquely_borrow_by_one_closure(\n                     span,\n@@ -469,42 +485,42 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )\n             },\n \n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n+            (BorrowKind::Shared, BorrowKind::Unique) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     container_name,\n                     &desc_place,\n                     \"\",\n-                    lft,\n+                    \"immutable\",\n                     issued_span,\n                     \"\",\n                     None,\n                     second_borrow_desc,\n                 )\n             }\n \n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n+            (BorrowKind::Mut { .. }, BorrowKind::Unique) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     container_name,\n                     &desc_place,\n                     \"\",\n-                    lft,\n+                    \"mutable\",\n                     issued_span,\n                     \"\",\n                     None,\n                     second_borrow_desc,\n                 )\n             }\n \n-            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _)\n-            | (BorrowKind::Shared, _, _, BorrowKind::Shallow, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Shared, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Shallow, _, _) => unreachable!(),\n+            (BorrowKind::Shared, BorrowKind::Shared)\n+            | (BorrowKind::Shared, BorrowKind::Shallow)\n+            | (BorrowKind::Shallow, BorrowKind::Mut { .. })\n+            | (BorrowKind::Shallow, BorrowKind::Unique)\n+            | (BorrowKind::Shallow, BorrowKind::Shared)\n+            | (BorrowKind::Shallow, BorrowKind::Shallow) => unreachable!(),\n         };\n \n         if issued_spans == borrow_spans {\n@@ -1429,20 +1445,23 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let loan_span = loan_spans.args_or_use();\n \n         if loan.kind == BorrowKind::Shallow {\n-            let mut err = self.cannot_mutate_in_match_guard(\n-                span,\n-                loan_span,\n-                &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n-                \"assign\",\n-            );\n-            loan_spans.var_span_label(\n-                &mut err,\n-                format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-            );\n+            if let Some(section) = self.classify_immutable_section(&loan.assigned_place) {\n+                let mut err = self.cannot_mutate_in_immutable_section(\n+                    span,\n+                    loan_span,\n+                    &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n+                    section,\n+                    \"assign\",\n+                );\n+                loan_spans.var_span_label(\n+                    &mut err,\n+                    format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n+                );\n \n-            err.buffer(&mut self.errors_buffer);\n+                err.buffer(&mut self.errors_buffer);\n \n-            return;\n+                return;\n+            }\n         }\n \n         let mut err = self.cannot_assign_to_borrowed(\n@@ -1593,6 +1612,35 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    /// Describe the reason for the fake borrow that was assigned to `place`.\n+    fn classify_immutable_section(&self, place: &Place<'tcx>) -> Option<&'static str> {\n+        use rustc::mir::visit::Visitor;\n+        struct FakeReadCauseFinder<'a, 'tcx> {\n+            place: &'a Place<'tcx>,\n+            cause: Option<FakeReadCause>,\n+        }\n+        impl<'tcx> Visitor<'tcx> for FakeReadCauseFinder<'_, 'tcx> {\n+            fn visit_statement(&mut self, statement: &Statement<'tcx>, _: Location) {\n+                match statement {\n+                    Statement {\n+                        kind: StatementKind::FakeRead(cause, box ref place),\n+                        ..\n+                    } if *place == *self.place => {\n+                        self.cause = Some(*cause);\n+                    }\n+                    _ => (),\n+                }\n+            }\n+        }\n+        let mut visitor = FakeReadCauseFinder { place, cause: None };\n+        visitor.visit_body(&self.body);\n+        match visitor.cause {\n+            Some(FakeReadCause::ForMatchGuard) => Some(\"match guard\"),\n+            Some(FakeReadCause::ForIndex) => Some(\"indexing expression\"),\n+            _ => None,\n+        }\n+    }\n+\n     /// Annotate argument and return type of function and closure with (synthesized) lifetime for\n     /// borrow of local value that does not live long enough.\n     fn annotate_argument_and_return_for_borrow("}, {"sha": "d3e013acc9e3a8ed17fee81e8beb06aa97b0f4cc", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 252, "deletions": 51, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/732081829263fd02b6995ff815d4c001cce460cf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732081829263fd02b6995ff815d4c001cce460cf/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=732081829263fd02b6995ff815d4c001cce460cf", "patch": "@@ -4,9 +4,11 @@ use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n+use rustc::middle::region;\n use rustc::mir::interpret::{PanicInfo::BoundsCheck};\n use rustc::mir::*;\n-use rustc::ty::{CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n+use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n+use syntax_pos::Span;\n \n use rustc_index::vec::Idx;\n \n@@ -68,6 +70,17 @@ impl From<PlaceBase<'tcx>> for PlaceBuilder<'tcx> {\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a place that we can move from etc.\n+    ///\n+    /// WARNING: Any user code might:\n+    /// * Invalidate any slice bounds checks performed.\n+    /// * Change the address that this `Place` refers to.\n+    /// * Modify the memory that this place refers to.\n+    /// * Invalidate the memory that this place refers to, this will be caught\n+    ///   by borrow checking.\n+    ///\n+    /// Extra care is needed if any user code is allowed to run between calling\n+    /// this method and using it, as is the case for `match` and index\n+    /// expressions.\n     pub fn as_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n@@ -83,7 +96,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_place(block, expr, Mutability::Mut)\n+        self.expr_as_place(block, expr, Mutability::Mut, None)\n     }\n \n     /// Compile `expr`, yielding a place that we can move from etc.\n@@ -114,14 +127,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_place(block, expr, Mutability::Not)\n+        self.expr_as_place(block, expr, Mutability::Not, None)\n     }\n \n     fn expr_as_place(\n         &mut self,\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n         mutability: Mutability,\n+        fake_borrow_temps: Option<&mut Vec<Local>>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         debug!(\n             \"expr_as_place(block={:?}, expr={:?}, mutability={:?})\",\n@@ -137,63 +151,40 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 lint_level,\n                 value,\n             } => this.in_scope((region_scope, source_info), lint_level, |this| {\n-                if mutability == Mutability::Not {\n-                    this.as_read_only_place_builder(block, value)\n-                } else {\n-                    this.as_place_builder(block, value)\n-                }\n+                let value = this.hir.mirror(value);\n+                this.expr_as_place(block, value, mutability, fake_borrow_temps)\n             }),\n             ExprKind::Field { lhs, name } => {\n-                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n+                let lhs = this.hir.mirror(lhs);\n+                let place_builder = unpack!(block = this.expr_as_place(\n+                    block,\n+                    lhs,\n+                    mutability,\n+                    fake_borrow_temps,\n+                ));\n                 block.and(place_builder.field(name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n-                let place_builder = unpack!(block = this.as_place_builder(block, arg));\n+                let arg = this.hir.mirror(arg);\n+                let place_builder = unpack!(block = this.expr_as_place(\n+                    block,\n+                    arg,\n+                    mutability,\n+                    fake_borrow_temps,\n+                ));\n                 block.and(place_builder.deref())\n             }\n             ExprKind::Index { lhs, index } => {\n-                let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n-\n-                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n-                // Making this a *fresh* temporary also means we do not have to worry about\n-                // the index changing later: Nothing will ever change this temporary.\n-                // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n-                let idx = unpack!(block = this.as_temp(\n+                this.lower_index_expression(\n                     block,\n-                    expr.temp_lifetime,\n+                    lhs,\n                     index,\n-                    Mutability::Not,\n-                ));\n-\n-                let slice = place_builder.clone().into_place(this.hir.tcx());\n-                // bounds check:\n-                let (len, lt) = (\n-                    this.temp(usize_ty.clone(), expr_span),\n-                    this.temp(bool_ty, expr_span),\n-                );\n-                this.cfg.push_assign(\n-                    block,\n-                    source_info, // len = len(slice)\n-                    &len,\n-                    Rvalue::Len(slice),\n-                );\n-                this.cfg.push_assign(\n-                    block,\n-                    source_info, // lt = idx < len\n-                    &lt,\n-                    Rvalue::BinaryOp(\n-                        BinOp::Lt,\n-                        Operand::Copy(Place::from(idx)),\n-                        Operand::Copy(len.clone()),\n-                    ),\n-                );\n-\n-                let msg = BoundsCheck {\n-                    len: Operand::Move(len),\n-                    index: Operand::Copy(Place::from(idx)),\n-                };\n-                let success = this.assert(block, Operand::Move(lt), true, msg, expr_span);\n-                success.and(place_builder.index(idx))\n+                    mutability,\n+                    fake_borrow_temps,\n+                    expr.temp_lifetime,\n+                    expr_span,\n+                    source_info,\n+                )\n             }\n             ExprKind::SelfRef => block.and(PlaceBuilder::from(Local::new(1))),\n             ExprKind::VarRef { id } => {\n@@ -215,7 +206,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             )),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n-                let place_builder = unpack!(block = this.as_place_builder(block, source));\n+                let source = this.hir.mirror(source);\n+                let place_builder = unpack!(block = this.expr_as_place(\n+                    block,\n+                    source,\n+                    mutability,\n+                    fake_borrow_temps,\n+                ));\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index = this.canonical_user_type_annotations.push(\n                         CanonicalUserTypeAnnotation {\n@@ -309,4 +306,208 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    /// Lower an index expression\n+    ///\n+    /// This has two complications;\n+    ///\n+    /// * We need to do a bounds check.\n+    /// * We need to ensure that the bounds check can't be invalidated using an\n+    ///   expression like `x[1][{x = y; 2}]`. We use fake borrows here to ensure\n+    ///   that this is the case.\n+    fn lower_index_expression(\n+        &mut self,\n+        mut block: BasicBlock,\n+        base: ExprRef<'tcx>,\n+        index: ExprRef<'tcx>,\n+        mutability: Mutability,\n+        fake_borrow_temps: Option<&mut Vec<Local>>,\n+        temp_lifetime: Option<region::Scope>,\n+        expr_span: Span,\n+        source_info: SourceInfo\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n+        let lhs = self.hir.mirror(base);\n+\n+        let base_fake_borrow_temps = &mut Vec::new();\n+        let is_outermost_index = fake_borrow_temps.is_none();\n+        let fake_borrow_temps = fake_borrow_temps.unwrap_or(base_fake_borrow_temps);\n+\n+        let base_place = unpack!(block = self.expr_as_place(\n+            block,\n+            lhs,\n+            mutability,\n+            Some(fake_borrow_temps),\n+        ));\n+\n+        // Making this a *fresh* temporary means we do not have to worry about\n+        // the index changing later: Nothing will ever change this temporary.\n+        // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n+        let idx = unpack!(block = self.as_temp(\n+            block,\n+            temp_lifetime,\n+            index,\n+            Mutability::Not,\n+        ));\n+\n+        block = self.bounds_check(\n+            block,\n+            base_place.clone().into_place(self.hir.tcx()),\n+            idx,\n+            expr_span,\n+            source_info,\n+        );\n+\n+        if is_outermost_index {\n+            self.read_fake_borrows(block, fake_borrow_temps, source_info)\n+        } else {\n+            self.add_fake_borrows_of_base(\n+                &base_place,\n+                block,\n+                fake_borrow_temps,\n+                expr_span,\n+                source_info,\n+            );\n+        }\n+\n+        block.and(base_place.index(idx))\n+    }\n+\n+    fn bounds_check(\n+        &mut self,\n+        block: BasicBlock,\n+        slice: Place<'tcx>,\n+        index: Local,\n+        expr_span: Span,\n+        source_info: SourceInfo,\n+    ) -> BasicBlock {\n+        let usize_ty = self.hir.usize_ty();\n+        let bool_ty = self.hir.bool_ty();\n+        // bounds check:\n+        let len = self.temp(usize_ty, expr_span);\n+        let lt = self.temp(bool_ty, expr_span);\n+\n+        // len = len(slice)\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            &len,\n+            Rvalue::Len(slice),\n+        );\n+        // lt = idx < len\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            &lt,\n+            Rvalue::BinaryOp(\n+                BinOp::Lt,\n+                Operand::Copy(Place::from(index)),\n+                Operand::Copy(len.clone()),\n+            ),\n+        );\n+        let msg = BoundsCheck {\n+            len: Operand::Move(len),\n+            index: Operand::Copy(Place::from(index)),\n+        };\n+        // assert!(lt, \"...\")\n+        self.assert(block, Operand::Move(lt), true, msg, expr_span)\n+    }\n+\n+    fn add_fake_borrows_of_base(\n+        &mut self,\n+        base_place: &PlaceBuilder<'tcx>,\n+        block: BasicBlock,\n+        fake_borrow_temps: &mut Vec<Local>,\n+        expr_span: Span,\n+        source_info: SourceInfo,\n+    ) {\n+        let tcx = self.hir.tcx();\n+        let place_ty = Place::ty_from(\n+            &base_place.base,\n+            &base_place.projection,\n+            &self.local_decls,\n+            tcx,\n+        );\n+        if let ty::Slice(_) = place_ty.ty.kind {\n+            // We need to create fake borrows to ensure that the bounds\n+            // check that we just did stays valid. Since we can't assign to\n+            // unsized values, we only need to ensure that none of the\n+            // pointers in the base place are modified.\n+            for (idx, elem) in base_place.projection.iter().enumerate().rev() {\n+                match elem {\n+                    ProjectionElem::Deref => {\n+                        let fake_borrow_deref_ty = Place::ty_from(\n+                            &base_place.base,\n+                            &base_place.projection[..idx],\n+                            &self.local_decls,\n+                            tcx,\n+                        ).ty;\n+                        let fake_borrow_ty = tcx.mk_imm_ref(\n+                            tcx.lifetimes.re_erased,\n+                            fake_borrow_deref_ty,\n+                        );\n+                        let fake_borrow_temp = self.local_decls.push(\n+                            LocalDecl::new_temp(fake_borrow_ty, expr_span)\n+                        );\n+                        let projection = tcx.intern_place_elems(&base_place.projection[..idx]);\n+                        self.cfg.push_assign(\n+                            block,\n+                            source_info,\n+                            &fake_borrow_temp.into(),\n+                            Rvalue::Ref(\n+                                tcx.lifetimes.re_erased,\n+                                BorrowKind::Shallow,\n+                                Place {\n+                                    base: base_place.base.clone(),\n+                                    projection,\n+                                }\n+                            ),\n+                        );\n+                        fake_borrow_temps.push(fake_borrow_temp);\n+                    }\n+                    ProjectionElem::Index(_) => {\n+                        let index_ty = Place::ty_from(\n+                            &base_place.base,\n+                            &base_place.projection[..idx],\n+                            &self.local_decls,\n+                            tcx,\n+                        );\n+                        match index_ty.ty.kind {\n+                            // The previous index expression has already\n+                            // done any index expressions needed here.\n+                            ty::Slice(_) => break,\n+                            ty::Array(..) => (),\n+                            _ => bug!(\"unexpected index base\"),\n+                        }\n+                    }\n+                    ProjectionElem::Field(..)\n+                    | ProjectionElem::Downcast(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. } => (),\n+                }\n+            }\n+        }\n+    }\n+\n+    fn read_fake_borrows(\n+        &mut self,\n+        block: BasicBlock,\n+        fake_borrow_temps: &mut Vec<Local>,\n+        source_info: SourceInfo,\n+    ) {\n+        // All indexes have been evaluated now, read all of the\n+        // fake borrows so that they are live across those index\n+        // expressions.\n+        for temp in fake_borrow_temps {\n+            self.cfg.push(\n+                block,\n+                Statement {\n+                    source_info,\n+                    kind: StatementKind::FakeRead(\n+                        FakeReadCause::ForIndex,\n+                        Box::new(Place::from(*temp)),\n+                    )\n+                }\n+            );\n+        }\n+    }\n }"}, {"sha": "bf01ad1a0236f917ba9d04d96f9c3b3b8f5a4ec4", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/732081829263fd02b6995ff815d4c001cce460cf/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732081829263fd02b6995ff815d4c001cce460cf/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=732081829263fd02b6995ff815d4c001cce460cf", "patch": "@@ -395,23 +395,25 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    crate fn cannot_mutate_in_match_guard(\n+    crate fn cannot_mutate_in_immutable_section(\n         &self,\n         mutate_span: Span,\n-        match_span: Span,\n-        match_place: &str,\n+        immutable_span: Span,\n+        immutable_place: &str,\n+        immutable_section: &str,\n         action: &str,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             mutate_span,\n             E0510,\n-            \"cannot {} `{}` in match guard\",\n+            \"cannot {} `{}` in {}\",\n             action,\n-            match_place,\n+            immutable_place,\n+            immutable_section,\n         );\n         err.span_label(mutate_span, format!(\"cannot {}\", action));\n-        err.span_label(match_span, String::from(\"value is immutable in match guard\"));\n+        err.span_label(immutable_span, format!(\"value is immutable in {}\", immutable_section));\n         err\n     }\n "}, {"sha": "5dc15286bab50625cfab315cb5e3b696ae93878c", "filename": "src/test/mir-opt/storage_live_dead_in_statics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/732081829263fd02b6995ff815d4c001cce460cf/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732081829263fd02b6995ff815d4c001cce460cf/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs?ref=732081829263fd02b6995ff815d4c001cce460cf", "patch": "@@ -36,11 +36,11 @@ fn main() {\n // END RUST SOURCE\n // START rustc.XXX.mir_map.0.mir\n //    let mut _0: &'static Foo;\n-//    let mut _1: &'static Foo;\n+//    let _1: &'static Foo;\n //    let _2: Foo;\n //    let mut _3: &'static [(u32, u32)];\n //    let mut _4: &'static [(u32, u32); 42];\n-//    let mut _5: &'static [(u32, u32); 42];\n+//    let _5: &'static [(u32, u32); 42];\n //    let _6: [(u32, u32); 42];\n //    let mut _7: (u32, u32);\n //    let mut _8: (u32, u32);"}, {"sha": "aa56918a9b8c12c7c49d8bbac1c5c878e7b0e981", "filename": "src/test/mir-opt/uninhabited_enum_branching.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/732081829263fd02b6995ff815d4c001cce460cf/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732081829263fd02b6995ff815d4c001cce460cf/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.rs?ref=732081829263fd02b6995ff815d4c001cce460cf", "patch": "@@ -34,12 +34,12 @@ fn main() {\n // let _1: &str;\n // let mut _2: Test1;\n // let mut _3: isize;\n-// let mut _4: &str;\n-// let mut _5: &str;\n+// let _4: &str;\n+// let _5: &str;\n // let _6: &str;\n // let mut _7: Test2;\n // let mut _8: isize;\n-// let mut _9: &str;\n+// let _9: &str;\n // bb0: {\n //   StorageLive(_1);\n //   StorageLive(_2);\n@@ -103,12 +103,12 @@ fn main() {\n // let _1: &str;\n // let mut _2: Test1;\n // let mut _3: isize;\n-// let mut _4: &str;\n-// let mut _5: &str;\n+// let _4: &str;\n+// let _5: &str;\n // let _6: &str;\n // let mut _7: Test2;\n // let mut _8: isize;\n-// let mut _9: &str;\n+// let _9: &str;\n // bb0: {\n //   StorageLive(_1);\n //   StorageLive(_2);\n@@ -172,12 +172,12 @@ fn main() {\n // let _1: &str;\n // let mut _2: Test1;\n // let mut _3: isize;\n-// let mut _4: &str;\n-// let mut _5: &str;\n+// let _4: &str;\n+// let _5: &str;\n // let _6: &str;\n // let mut _7: Test2;\n // let mut _8: isize;\n-// let mut _9: &str;\n+// let _9: &str;\n // bb0: {\n //   StorageLive(_1);\n //   StorageLive(_2);"}, {"sha": "0e0e3cda6e2edbf6580ac7fc3a3a8a71a187660f", "filename": "src/test/ui/borrowck/slice-index-bounds-check-invalidation.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/732081829263fd02b6995ff815d4c001cce460cf/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732081829263fd02b6995ff815d4c001cce460cf/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.rs?ref=732081829263fd02b6995ff815d4c001cce460cf", "patch": "@@ -0,0 +1,82 @@\n+// Test that we error if a slice is modified after it has been bounds checked\n+// and before we actually index it.\n+\n+fn modify_before_assert_slice_slice(x: &[&[i32]]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32] = &[1, 2, 3];\n+    let y: &[&[i32]] = &[z];\n+    x[{ x = y; 0 }][2]              // OK we haven't checked any bounds before we index `x`.\n+}\n+\n+fn modify_before_assert_array_slice(x: &[&[i32]; 3]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32] = &[1, 2, 3];\n+    let y: &[&[i32]; 3] = &[z, z, z];\n+    x[{ x = y; 0 }][2]              // OK we haven't checked any bounds before we index `x`.\n+}\n+\n+fn modify_before_assert_slice_array(x: &[&[i32; 3]]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32; 3] = &[1, 2, 3];\n+    let y: &[&[i32; 3]] = &[z];\n+    x[{ x = y; 0 }][2]              // OK we haven't checked any bounds before we index `x`.\n+}\n+\n+fn modify_before_assert_array_array(x: &[&[i32; 3]; 3]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32; 3] = &[1, 2, 3];\n+    let y: &[&[i32; 3]; 3] = &[z, z, z];\n+    x[{ x = y; 0 }][2]              // OK we haven't checked any bounds before we index `x`.\n+}\n+\n+fn modify_after_assert_slice_slice(x: &[&[i32]]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32] = &[1, 2, 3];\n+    let y: &[&[i32]] = &[&z];\n+    x[1][{ x = y; 2}]               //~ ERROR cannot assign `x` in indexing expression\n+}\n+\n+fn modify_after_assert_array_slice(x: &[&[i32]; 1]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32] = &[1, 2, 3];\n+    let y: &[&[i32]; 1] = &[&z];\n+    x[0][{ x = y; 2}]               // OK cannot invalidate a fixed-size array bounds check\n+}\n+\n+fn modify_after_assert_slice_array(x: &[&[i32; 3]]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32; 3] = &[1, 2, 3];\n+    let y: &[&[i32; 3]] = &[&z];\n+    x[1][{ x = y; 2}]               //~ ERROR cannot assign `x` in indexing expression\n+}\n+\n+fn modify_after_assert_array_array(x: &[&[i32; 3]; 1]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32; 3] = &[1, 2, 3];\n+    let y: &[&[i32; 3]; 1] = &[&z];\n+    x[0][{ x = y; 2}]               // OK cannot invalidate a fixed-size array bounds check\n+}\n+\n+fn modify_after_assert_slice_slice_array(x: &[&[[i32; 1]]]) -> i32 {\n+    let mut x = x;\n+    let z: &[[i32; 1]] = &[[1], [2], [3]];\n+    let y: &[&[[i32; 1]]] = &[&z];\n+    x[1][{ x = y; 2}][0]            //~ ERROR cannot assign `x` in indexing expression\n+}\n+\n+fn modify_after_assert_slice_slice_slice(x: &[&[&[i32]]]) -> i32 {\n+    let mut x = x;\n+    let z: &[&[i32]] = &[&[1], &[2], &[3]];\n+    let y: &[&[&[i32]]] = &[z];\n+    x[1][{ x = y; 2}][0]            //~ ERROR cannot assign `x` in indexing expression\n+}\n+\n+\n+fn main() {\n+    println!(\"{}\", modify_after_assert_slice_array(&[&[4, 5, 6], &[9, 10, 11]]));\n+    println!(\"{}\", modify_after_assert_slice_slice(&[&[4, 5, 6], &[9, 10, 11]]));\n+    println!(\"{}\", modify_after_assert_slice_slice_array(&[&[[4], [5], [6]], &[[9], [10], [11]]]));\n+    println!(\"{}\", modify_after_assert_slice_slice_slice(\n+        &[&[&[4], &[5], &[6]], &[&[9], &[10], &[11]]]),\n+    );\n+}"}, {"sha": "f9ed16f19cd69f4723a36c373ab0df698d04cef6", "filename": "src/test/ui/borrowck/slice-index-bounds-check-invalidation.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/732081829263fd02b6995ff815d4c001cce460cf/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/732081829263fd02b6995ff815d4c001cce460cf/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.stderr?ref=732081829263fd02b6995ff815d4c001cce460cf", "patch": "@@ -0,0 +1,35 @@\n+error[E0510]: cannot assign `x` in indexing expression\n+  --> $DIR/slice-index-bounds-check-invalidation.rs:36:12\n+   |\n+LL |     x[1][{ x = y; 2}]\n+   |     ----   ^^^^^ cannot assign\n+   |     |\n+   |     value is immutable in indexing expression\n+\n+error[E0510]: cannot assign `x` in indexing expression\n+  --> $DIR/slice-index-bounds-check-invalidation.rs:50:12\n+   |\n+LL |     x[1][{ x = y; 2}]\n+   |     ----   ^^^^^ cannot assign\n+   |     |\n+   |     value is immutable in indexing expression\n+\n+error[E0510]: cannot assign `x` in indexing expression\n+  --> $DIR/slice-index-bounds-check-invalidation.rs:64:12\n+   |\n+LL |     x[1][{ x = y; 2}][0]\n+   |     ----   ^^^^^ cannot assign\n+   |     |\n+   |     value is immutable in indexing expression\n+\n+error[E0510]: cannot assign `x` in indexing expression\n+  --> $DIR/slice-index-bounds-check-invalidation.rs:71:12\n+   |\n+LL |     x[1][{ x = y; 2}][0]\n+   |     ----   ^^^^^ cannot assign\n+   |     |\n+   |     value is immutable in indexing expression\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0510`."}]}