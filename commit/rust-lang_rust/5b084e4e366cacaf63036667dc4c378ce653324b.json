{"sha": "5b084e4e366cacaf63036667dc4c378ce653324b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMDg0ZTRlMzY2Y2FjYWY2MzAzNjY2N2RjNGMzNzhjZTY1MzMyNGI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-10T22:44:33Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-10T22:47:11Z"}, "message": "Update docs to new let syntax.", "tree": {"sha": "c5043e61c10a9f7e9dc6fbb204dcd57f0400934c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5043e61c10a9f7e9dc6fbb204dcd57f0400934c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b084e4e366cacaf63036667dc4c378ce653324b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b084e4e366cacaf63036667dc4c378ce653324b", "html_url": "https://github.com/rust-lang/rust/commit/5b084e4e366cacaf63036667dc4c378ce653324b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b084e4e366cacaf63036667dc4c378ce653324b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "347230b00162fa393b782aa40d61c131a0e2b086", "url": "https://api.github.com/repos/rust-lang/rust/commits/347230b00162fa393b782aa40d61c131a0e2b086", "html_url": "https://github.com/rust-lang/rust/commit/347230b00162fa393b782aa40d61c131a0e2b086"}], "stats": {"total": 132, "additions": 65, "deletions": 67}, "files": [{"sha": "cc8911f94be6fb9b465bb54f55aa740c0f65c232", "filename": "doc/rust.texi", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/5b084e4e366cacaf63036667dc4c378ce653324b/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/5b084e4e366cacaf63036667dc4c378ce653324b/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=5b084e4e366cacaf63036667dc4c378ce653324b", "patch": "@@ -342,7 +342,7 @@ features of currying, in a smaller and simpler package.\n To save some quantity of programmer key-pressing, Rust supports local type\n inference: signatures of functions, objects and iterators always require type\n annotation, but within the body of a function or iterator many slots can be\n-declared @code{auto} and Rust will infer the slot's type from its uses.\n+declared without a type, and Rust will infer the slot's type from its uses.\n \n @sp 1\n @item Structural object system\n@@ -662,7 +662,6 @@ The keywords are:\n @tab @code{import}\n @tab @code{export}\n @tab @code{let}\n-@tab @code{auto}\n @item @code{state}\n @tab @code{gc}\n @tab @code{const}\n@@ -1222,9 +1221,9 @@ mod foo = \"foo.rs\";\n \n // In the source file \"foo.rs\", use the #re syntax extension and\n // the re module at run-time.\n-let str s = get_string();\n-let regex pattern = #re.pat@{ aa+b? @};\n-let bool matched = re.match(pattern, s);\n+let s: str = get_string();\n+let pattern: regex = #re.pat@{ aa+b? @};\n+let matched: bool = re.match(pattern, s);\n @end example\n \n @page\n@@ -1375,7 +1374,7 @@ Box types and values are constructed by the @emph{at} sigil @code{@@}.\n \n An example of constructing a box type and value:\n @example\n-let @@int x = @@10;\n+let x: @@int = @@10;\n @end example\n \n Some operations implicitly dereference boxes. Examples of such @dfn{implicit\n@@ -1387,8 +1386,8 @@ dereference} operations are:\n \n An example of an implicit-dereference operation performed on box values:\n @example\n-let @@int x = @@10;\n-let @@int y = @@12;\n+let x: @@int = @@10;\n+let y: @@int = @@12;\n assert (x + y == 22);\n @end example\n \n@@ -1412,7 +1411,7 @@ fn takes_unboxed(int b) @{\n @}\n \n fn main() @{\n-    let @@int x = @@10;\n+    let x: @@int = @@10;\n     takes_boxed(x);\n     takes_unboxed(*x);\n @}\n@@ -1896,14 +1895,14 @@ each} loop or as the argument in a @code{put each} expression.\n An example of an iterator:\n @example\n iter range(int lo, int hi) -> int @{\n-    let int i = lo;\n+    let i: int = lo;\n     while (i < hi) @{\n         put i;\n         i = i + 1;\n     @}\n @}\n \n-let int sum = 0;\n+let sum: int = 0;\n for each (int x in range(0,100)) @{\n     sum += x;\n @}\n@@ -1936,7 +1935,7 @@ obj counter(int state) @{\n     @}\n @}\n \n-let counter c = counter(1);\n+let c: counter = counter(1);\n \n c.incr();\n c.incr();\n@@ -1952,7 +1951,7 @@ obj my_obj() @{\n     ret 3;\n   @}\n   fn foo() @{\n-    auto c = get();  // Fails\n+    let c = get();  // Fails\n   @}\n @}\n @end example\n@@ -1976,7 +1975,7 @@ fn mk_my_obj() -> my_obj @{\n       ret get_helper();\n     @}\n     fn foo() @{\n-      auto c = get_helper();  // Works\n+      let c = get_helper();  // Works\n     @}\n   @}\n \n@@ -2040,7 +2039,7 @@ tag animal @{\n   cat;\n @}\n \n-let animal a = dog;\n+let a: animal = dog;\n a = cat;\n @end example\n \n@@ -2051,7 +2050,7 @@ tag list[T] @{\n   cons(T, @@list[T]);\n @}\n \n-let list[int] a = cons(7, cons(13, nil));\n+let a: list[int] = cons(7, cons(13, nil));\n @end example\n \n \n@@ -2266,8 +2265,8 @@ the record type.\n An example of a record type and its use:\n @example\n type point = @{x: int, y: int@};\n-let point p = @{x: 10, y: 11@};\n-let int px = p.x;\n+let p: point = @{x: 10, y: 11@};\n+let px: int = p.x;\n @end example\n \n @node       Ref.Type.Tup\n@@ -2284,7 +2283,7 @@ like a record, in order specified by the tuple type.\n An example of a tuple type and its use:\n @example\n type pair = tup(int,str);\n-let pair p = tup(10,\"hello\");\n+let p: pair = tup(10,\"hello\");\n assert (p._0 == 10);\n p._1 = \"world\";\n assert (p._1 == \"world\");\n@@ -2307,9 +2306,9 @@ interval -- out of the sliced vector.\n \n An example of a vector type and its use:\n @example\n-let [int] v = [7, 5, 3];\n-let int i = v.(2);\n-let [int] v2 = v.(0,1); // Form a slice.\n+let v: [int] = [7, 5, 3];\n+let i: int = v.(2);\n+let v2: [int] = v.(0,1); // Form a slice.\n @end example\n \n Vectors always @emph{allocate} a storage region sufficient to store the first\n@@ -2318,7 +2317,7 @@ vector. This behaviour supports idiomatic in-place ``growth'' of a mutable\n slot holding a vector:\n \n @example\n-let mutable vec[int] v = [1, 2, 3];\n+let v: mutable vec[int] = [1, 2, 3];\n v += [4, 5, 6];\n @end example\n \n@@ -2363,7 +2362,7 @@ fn add(int x, int y) -> int @{\n let int x = add(5,7);\n \n type binop = fn(int,int) -> int;\n-let binop bo = add;\n+let bo: binop = add;\n x = bo(5,7);\n @end example\n \n@@ -2411,8 +2410,8 @@ mutable values can pass over a port or channel.\n An example of a @code{port} type:\n @example\n type port[vec[str]] svp;\n-let svp p = get_port();\n-let vec[str] v;\n+let p: svp = get_port();\n+let v: vec[str];\n v <- p;\n @end example\n \n@@ -2450,8 +2449,8 @@ message is dropped.\n An example of a @code{chan} type:\n @example\n type chan[vec[str]] svc;\n-let svc c = get_chan();\n-let vec[str] v = [\"hello\", \"world\"];\n+let c: svc = get_chan();\n+let v: vec[str] = [\"hello\", \"world\"];\n c <| v;\n @end example\n \n@@ -2523,10 +2522,10 @@ fn give_ints(taker t) @{\n     t.take(3);\n @}\n \n-let port[int] p = port();\n+let p: port[int] = port();\n \n-let taker t1 = adder(0);\n-let taker t2 = sender(chan(p));\n+let t1: taker = adder(0);\n+let t2: taker = sender(chan(p));\n \n give_ints(t1);\n give_ints(t2);\n@@ -2554,10 +2553,10 @@ An example of a constrained type with two separate instantiations:\n @example\n type ordered_range = @{low: int, high: int@} : less_than(*.low, *.high);\n \n-let ordered_range rng1 = @{low: 5, high: 7@};\n+let rng1: ordered_range = @{low: 5, high: 7@};\n // implicit: 'check less_than(rng1.low, rng1.high);'\n \n-let ordered_range rng2 = @{low: 15, high: 17@};\n+let rng2: ordered_range = @{low: 15, high: 17@};\n // implicit: 'check less_than(rng2.low, rng2.high);'\n @end example\n \n@@ -2696,8 +2695,8 @@ pred is_less_than(int a, int b) -> bool @{\n @}\n \n fn test() @{\n-   let int x = 10;\n-   let int y = 20;\n+   let x: int = 10;\n+   let y: int = 20;\n    check is_less_than(x,y);\n @}\n @end example\n@@ -2890,27 +2889,27 @@ declaring a function-local item.\n @cindex Local slot\n @cindex Variable, see @i{Local slot}\n @cindex Type inference\n-@cindex Automatic slot\n \n A @code{slot declaration statement} has one one of two forms:\n \n @itemize\n-@item @code{let} @var{type} @var{slot} @var{optional-init};\n-@item @code{auto} @var{slot} @var{optional-init};\n+@item @code{let} @var{pattern} @var{optional-init};\n+@item @code{let} @var{pattern} : @var{type} @var{optional-init};\n @end itemize\n \n-Where @var{type} is a type expression, @var{slot} is the name of the slot\n-being declared, and @var{optional-init} is either the empty string or an\n-equals sign (@code{=}) followed by a primitive expression.\n+Where @var{type} is a type expression, @var{pattern} is an irrefutable pattern\n+(often just the name of a single slot), and @var{optional-init} is an optional\n+initializer. If present, the initializer consists of either an equals sign\n+(@code{=}) or move operator (@code{<-}), followed by an expression.\n \n Both forms introduce a new slot into the containing block scope. The new slot\n is visible across the entire scope, but is initialized only at the point\n following the declaration statement.\n \n-The latter (@code{auto}) form of slot declaration causes the compiler to infer\n-the static type of the slot through unification with the types of values\n-assigned to the slot in the remaining code in the block scope. Inference only\n-occurs on frame-local slots, not argument slots. Function, iterator and object\n+The former form, with no type annotation, causes the compiler to infer the\n+static type of the slot through unification with the types of values assigned\n+to the slot in the remaining code in the block scope. Inference only occurs on\n+frame-local slots, not argument slots. Function, iterator and object\n signatures must always declared types for all argument slots.\n @xref{Ref.Mem.Slot}.\n \n@@ -2953,8 +2952,7 @@ effects of the expression's evaluation.\n * Ref.Expr.Prove::              Expression for static assertion of typestate.\n * Ref.Expr.Check::              Expression for dynamic assertion of typestate.\n * Ref.Expr.Claim::              Expression for static (unsafe) or dynamic assertion of typestate.\n-* Ref.Expr.Assert::              Expression for halting the program if a\n-                                           boolean condition fails to hold.\n+* Ref.Expr.Assert::             Expression for halting the program if a boolean condition fails to hold.\n * Ref.Expr.IfCheck::            Expression for dynamic testing of typestate.\n @end menu\n \n@@ -3012,11 +3010,11 @@ fn helper(chan[u8] out) @{\n     out <| result;\n @}\n \n-let port[u8] out;\n-let task p = spawn helper(chan(out));\n-let task p2 = spawn \"my_helper\" helper(chan(out));\n+let out: port[u8];\n+let p: task = spawn helper(chan(out));\n+let p2: task = spawn \"my_helper\" helper(chan(out));\n // let task run, do other things.\n-auto result <- out;\n+let result <- out;\n \n @end example\n \n@@ -3070,7 +3068,7 @@ un-blocks the receiving task. @xref{Ref.Run.Comm}.\n An example of a @emph{receive}:\n @example\n port[str] p = @dots{};\n-let str s <- p;\n+let s: str <- p;\n @end example\n \n @node       Ref.Expr.Call\n@@ -3090,7 +3088,7 @@ typestates propagate through function boundaries. @xref{Ref.Typestate}.\n \n An example of a call expression:\n @example\n-let int x = add(1, 2);\n+let x: int = add(1, 2);\n @end example\n \n @node       Ref.Expr.Bind\n@@ -3121,9 +3119,9 @@ fn add(int x, int y) -> int @{\n @}\n type single_param_fn = fn(int) -> int;\n \n-let single_param_fn add4 = bind add(4, _);\n+let add4: single_param_fn = bind add(4, _);\n \n-let single_param_fn add5 = bind add(_, 5);\n+let add5: single_param_fn = bind add(_, 5);\n \n assert (add(4,5) == add4(5));\n assert (add(4,5) == add5(4));\n@@ -3368,7 +3366,7 @@ run the loop over the slice.\n \n Example of 4 for loops, all identical:\n @example\n-let vec[foo] v = [a, b, c];\n+let v: vec[foo] = [a, b, c];\n \n for (foo e in v.(0, _vec.len(v))) @{\n     bar(e);\n@@ -3400,8 +3398,8 @@ the iterator.  When the iterator returns or fails, the loop terminates.\n \n Example of a foreach loop:\n @example\n-let str txt;\n-let vec[str] lines;\n+let txt: str;\n+let lines: vec[str];\n for each (str s in _str.split(txt, \"\\n\")) @{\n     vec.push(lines, s);\n @}\n@@ -3472,10 +3470,10 @@ branches to the block of that arm.\n \n An example of a communication @code{alt} expression:\n @example\n-let chan c[int] = foo();\n-let port p[str] = bar();\n-let int x = 0;\n-let vec[str] strs;\n+let c: chan[int] = foo();\n+let p: port[str] = bar();\n+let x: int = 0;\n+let strs: vec[str];\n \n alt @{\n     case (str s <- p) @{\n@@ -3504,15 +3502,15 @@ To execute a pattern @code{alt} expression, first the head expression is\n evaluated, then its value is sequentially compared to the patterns in the arms\n until a match is found. The first arm with a matching @code{case} pattern is\n chosen as the branch target of the @code{alt}, any variables bound by the\n-pattern are assigned to local @emph{auto} slots in the arm's block, and\n-control enters the block.\n+pattern are assigned to local slots in the arm's block, and control enters the\n+block.\n \n An example of a pattern @code{alt} expression:\n \n @example\n type list[X] = tag(nil, cons(X, @@list[X]));\n \n-let list[int] x = cons(10, cons(11, nil));\n+let x: list[int] = cons(10, cons(11, nil));\n \n alt (x) @{\n     case (cons(a, cons(b, _))) @{\n@@ -3544,7 +3542,7 @@ the value in the @code{any}.\n An example of an @code{alt type} expression:\n \n @example\n-let any x = foo();\n+let x: any = foo();\n \n alt type (x) @{\n     case (int i) @{\n@@ -3606,7 +3604,7 @@ fn print_even(int x) : even(x) @{\n @}\n \n fn test() @{\n-    let int y = 8;\n+    let y: int = 8;\n \n     // Cannot call print_even(y) here.\n "}]}