{"sha": "e6387b6a75ce37cb5ef8582b8b011737337caf9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2Mzg3YjZhNzVjZTM3Y2I1ZWY4NTgyYjhiMDExNzM3MzM3Y2FmOWE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-03-04T21:39:52Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-03-04T21:39:52Z"}, "message": "Fix rebase and move suggestion to its own method", "tree": {"sha": "b2b6577ad75e9cc5bd7c11d545adac75a172be3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2b6577ad75e9cc5bd7c11d545adac75a172be3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6387b6a75ce37cb5ef8582b8b011737337caf9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6387b6a75ce37cb5ef8582b8b011737337caf9a", "html_url": "https://github.com/rust-lang/rust/commit/e6387b6a75ce37cb5ef8582b8b011737337caf9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6387b6a75ce37cb5ef8582b8b011737337caf9a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2718dc7263ae7355dd8ffdd7a788e0683b5aabf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2718dc7263ae7355dd8ffdd7a788e0683b5aabf", "html_url": "https://github.com/rust-lang/rust/commit/f2718dc7263ae7355dd8ffdd7a788e0683b5aabf"}], "stats": {"total": 75, "additions": 46, "deletions": 29}, "files": [{"sha": "502edb4ac6b2e14494e0bda26bdb7655e6f6db37", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 46, "deletions": 29, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e6387b6a75ce37cb5ef8582b8b011737337caf9a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6387b6a75ce37cb5ef8582b8b011737337caf9a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e6387b6a75ce37cb5ef8582b8b011737337caf9a", "patch": "@@ -648,28 +648,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                          trait_ref.to_predicate(), post_message)\n                             ));\n \n-                        let parent_node = self.tcx.hir().get_parent_node(obligation.cause.body_id);\n-                        let node = self.tcx.hir().find(parent_node);\n-                        if let Some(hir::Node::Item(hir::Item {\n-                            node: hir::ItemKind::Fn(decl, _, _, body_id),\n-                            ..\n-                        })) = node {\n-                            let body = self.tcx.hir().body(*body_id);\n-                            if let hir::ExprKind::Block(blk, _) = &body.value.node {\n-                                if decl.output.span().overlaps(span) && blk.expr.is_none() &&\n-                                    \"()\" == &trait_ref.self_ty().to_string()\n-                                {\n-                                    // FIXME(estebank): When encountering a method with a trait\n-                                    // bound not satisfied in the return type with a body that has\n-                                    // no return, suggest removal of semicolon on last statement.\n-                                    // Once that is added, close #54771.\n-                                    if let Some(ref stmt) = blk.stmts.last() {\n-                                        let sp = self.tcx.sess.source_map().end_point(stmt.span);\n-                                        err.span_label(sp, \"consider removing this semicolon\");\n-                                    }\n-                                }\n-                            }\n-                        }\n                         let explanation =\n                             if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n                                 \"consider using `()`, or a `Result`\".to_owned()\n@@ -695,6 +673,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n+                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n \n                         // Try to report a help message\n                         if !trait_ref.has_infer_types() &&\n@@ -923,9 +902,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n     /// suggestion to borrow the initializer in order to use have a slice instead.\n-    fn suggest_borrow_on_unsized_slice(&self,\n-                                       code: &ObligationCauseCode<'tcx>,\n-                                       err: &mut DiagnosticBuilder<'tcx>) {\n+    fn suggest_borrow_on_unsized_slice(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+    ) {\n         if let &ObligationCauseCode::VariableType(node_id) = code {\n             let parent_node = self.tcx.hir().get_parent_node(node_id);\n             if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n@@ -947,10 +928,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n     /// suggest removing these references until we reach a type that implements the trait.\n-    fn suggest_remove_reference(&self,\n-                                obligation: &PredicateObligation<'tcx>,\n-                                err: &mut DiagnosticBuilder<'tcx>,\n-                                trait_ref: &ty::Binder<ty::TraitRef<'tcx>>) {\n+    fn suggest_remove_reference(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n         let trait_ref = trait_ref.skip_binder();\n         let span = obligation.cause.span;\n \n@@ -992,6 +975,40 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn suggest_semicolon_removal(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(\n+            hir.hir_to_node_id(obligation.cause.body_id),\n+        );\n+        let node = hir.find(parent_node);\n+        if let Some(hir::Node::Item(hir::Item {\n+            node: hir::ItemKind::Fn(decl, _, _, body_id),\n+            ..\n+        })) = node {\n+            let body = hir.body(*body_id);\n+            if let hir::ExprKind::Block(blk, _) = &body.value.node {\n+                if decl.output.span().overlaps(span) && blk.expr.is_none() &&\n+                    \"()\" == &trait_ref.self_ty().to_string()\n+                {\n+                    // FIXME(estebank): When encountering a method with a trait\n+                    // bound not satisfied in the return type with a body that has\n+                    // no return, suggest removal of semicolon on last statement.\n+                    // Once that is added, close #54771.\n+                    if let Some(ref stmt) = blk.stmts.last() {\n+                        let sp = self.tcx.sess.source_map().end_point(stmt.span);\n+                        err.span_label(sp, \"consider removing this semicolon\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// Given some node representing a fn-like thing in the HIR map,\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to"}]}