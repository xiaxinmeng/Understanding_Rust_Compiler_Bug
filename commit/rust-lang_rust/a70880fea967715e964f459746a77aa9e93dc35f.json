{"sha": "a70880fea967715e964f459746a77aa9e93dc35f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3MDg4MGZlYTk2NzcxNWU5NjRmNDU5NzQ2YTc3YWE5ZTkzZGMzNWY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-27T04:26:47Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-27T04:26:47Z"}, "message": "Rollup merge of #33351 - birkenfeld:loop-label-spans, r=pnkfelix\n\n This makes the \\\"shadowing labels\\\" warning *not* print the entire loop as a span, but only the lifetime.\n\nAlso makes #31719 go away, but does not fix its root cause (the span of the expanded loop is still wonky, but not used anymore).", "tree": {"sha": "8c7dba2132a5612c19e8dd01a58b3b4f650fa5ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c7dba2132a5612c19e8dd01a58b3b4f650fa5ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a70880fea967715e964f459746a77aa9e93dc35f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a70880fea967715e964f459746a77aa9e93dc35f", "html_url": "https://github.com/rust-lang/rust/commit/a70880fea967715e964f459746a77aa9e93dc35f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a70880fea967715e964f459746a77aa9e93dc35f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97e3a2401e4b2f659d69ed0c0822cae04e3495b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/97e3a2401e4b2f659d69ed0c0822cae04e3495b7", "html_url": "https://github.com/rust-lang/rust/commit/97e3a2401e4b2f659d69ed0c0822cae04e3495b7"}, {"sha": "2e812e10f4ece10d90ae3315aba16b88c5e870eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e812e10f4ece10d90ae3315aba16b88c5e870eb", "html_url": "https://github.com/rust-lang/rust/commit/2e812e10f4ece10d90ae3315aba16b88c5e870eb"}], "stats": {"total": 182, "additions": 99, "deletions": 83}, "files": [{"sha": "58f1006f98e6bda4ea950d1bda91eff840ff48bc", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -1009,11 +1009,15 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             ExprWhile(cond, body, opt_name) => {\n                 ExprWhile(folder.fold_expr(cond),\n                           folder.fold_block(body),\n-                          opt_name.map(|i| folder.fold_name(i)))\n+                          opt_name.map(|label| {\n+                              respan(folder.new_span(label.span), folder.fold_name(label.node))\n+                          }))\n             }\n             ExprLoop(body, opt_name) => {\n                 ExprLoop(folder.fold_block(body),\n-                         opt_name.map(|i| folder.fold_name(i)))\n+                         opt_name.map(|label| {\n+                             respan(folder.new_span(label.span), folder.fold_name(label.node))\n+                         }))\n             }\n             ExprMatch(expr, arms, source) => {\n                 ExprMatch(folder.fold_expr(expr),"}, {"sha": "9c61271fbfbd2675a25c7bc24d0f792f14dbfe4c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -28,7 +28,7 @@\n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n use syntax::attr::ThinAttributesExt;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, Spanned};\n use hir::*;\n \n use std::cmp;\n@@ -203,11 +203,17 @@ pub trait Visitor<'v> : Sized {\n }\n \n pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n-    for name in opt_name {\n+    if let Some(name) = opt_name {\n         visitor.visit_name(span, name);\n     }\n }\n \n+pub fn walk_opt_sp_name<'v, V: Visitor<'v>>(visitor: &mut V, opt_sp_name: &Option<Spanned<Name>>) {\n+    if let Some(ref sp_name) = *opt_sp_name {\n+        visitor.visit_name(sp_name.span, sp_name.node);\n+    }\n+}\n+\n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n@@ -737,14 +743,14 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, opt_name) => {\n+        ExprWhile(ref subexpression, ref block, ref opt_sp_name) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_name(visitor, expression.span, opt_name)\n+            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n-        ExprLoop(ref block, opt_name) => {\n+        ExprLoop(ref block, ref opt_sp_name) => {\n             visitor.visit_block(block);\n-            walk_opt_name(visitor, expression.span, opt_name)\n+            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n         ExprMatch(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(subexpression);\n@@ -784,9 +790,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_path(path, expression.id)\n         }\n         ExprBreak(ref opt_sp_name) | ExprAgain(ref opt_sp_name) => {\n-            for sp_name in opt_sp_name {\n-                visitor.visit_name(sp_name.span, sp_name.node);\n-            }\n+            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "56777dc41d719302a94e9ecd551720634fbfa45f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -192,6 +192,10 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_opt_sp_ident(&mut self, o_id: Option<Spanned<Ident>>) -> Option<Spanned<Name>> {\n+        o_id.map(|sp_ident| respan(sp_ident.span, self.lower_ident(sp_ident.node)))\n+    }\n+\n     fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n         attrs.clone().into()\n     }\n@@ -1122,11 +1126,10 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::While(ref cond, ref body, opt_ident) => {\n                     hir::ExprWhile(self.lower_expr(cond), self.lower_block(body),\n-                                   opt_ident.map(|ident| self.lower_ident(ident)))\n+                                   self.lower_opt_sp_ident(opt_ident))\n                 }\n                 ExprKind::Loop(ref body, opt_ident) => {\n-                    hir::ExprLoop(self.lower_block(body),\n-                                  opt_ident.map(|ident| self.lower_ident(ident)))\n+                    hir::ExprLoop(self.lower_block(body), self.lower_opt_sp_ident(opt_ident))\n                 }\n                 ExprKind::Match(ref expr, ref arms) => {\n                     hir::ExprMatch(self.lower_expr(expr),\n@@ -1243,12 +1246,8 @@ impl<'a> LoweringContext<'a> {\n                     };\n                     hir::ExprPath(hir_qself, self.lower_path_full(path, rename))\n                 }\n-                ExprKind::Break(opt_ident) => hir::ExprBreak(opt_ident.map(|sp_ident| {\n-                    respan(sp_ident.span, self.lower_ident(sp_ident.node))\n-                })),\n-                ExprKind::Again(opt_ident) => hir::ExprAgain(opt_ident.map(|sp_ident| {\n-                    respan(sp_ident.span, self.lower_ident(sp_ident.node))\n-                })),\n+                ExprKind::Break(opt_ident) => hir::ExprBreak(self.lower_opt_sp_ident(opt_ident)),\n+                ExprKind::Again(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| self.lower_expr(x))),\n                 ExprKind::InlineAsm(InlineAsm {\n                         ref inputs,\n@@ -1422,8 +1421,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block,\n-                                                  opt_ident.map(|ident| self.lower_ident(ident)));\n+                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n                     // add attributes to the outer returned expr node\n                     let attrs = e.attrs.clone();\n                     return P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: attrs });\n@@ -1503,8 +1501,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block,\n-                                                  opt_ident.map(|ident| self.lower_ident(ident)));\n+                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n                     let loop_expr =\n                         P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: None });\n "}, {"sha": "b147782316fd97b10278496c4b234b9b4a578fc3", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -873,11 +873,11 @@ pub enum Expr_ {\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    ExprWhile(P<Expr>, P<Block>, Option<Name>),\n+    ExprWhile(P<Expr>, P<Block>, Option<Spanned<Name>>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Name>),\n+    ExprLoop(P<Block>, Option<Spanned<Name>>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),"}, {"sha": "74bc688d154818c085e7001e34acd477cf15fb2a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -1351,19 +1351,19 @@ impl<'a> State<'a> {\n             hir::ExprIf(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            hir::ExprWhile(ref test, ref blk, opt_name) => {\n-                if let Some(name) = opt_name {\n-                    self.print_name(name)?;\n+            hir::ExprWhile(ref test, ref blk, opt_sp_name) => {\n+                if let Some(sp_name) = opt_sp_name {\n+                    self.print_name(sp_name.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr(&test)?;\n                 space(&mut self.s)?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprLoop(ref blk, opt_name) => {\n-                if let Some(name) = opt_name {\n-                    self.print_name(name)?;\n+            hir::ExprLoop(ref blk, opt_sp_name) => {\n+                if let Some(sp_name) = opt_sp_name {\n+                    self.print_name(sp_name.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;"}, {"sha": "4cc9b0b4353a0b2da14878c789d888979c7df2c7", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -404,23 +404,23 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n             if let hir::ExprClosure(..) = ex.node {\n                 return\n             }\n-            if let Some(label) = expression_label(ex) {\n+            if let Some((label, label_span)) = expression_label(ex) {\n                 for &(prior, prior_span) in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n                     if label == prior {\n                         signal_shadowing_problem(self.sess,\n                                                  label,\n                                                  original_label(prior_span),\n-                                                 shadower_label(ex.span));\n+                                                 shadower_label(label_span));\n                     }\n                 }\n \n                 check_if_label_shadows_lifetime(self.sess,\n                                                 self.scope,\n                                                 label,\n-                                                ex.span);\n+                                                label_span);\n \n-                self.labels_in_fn.push((label, ex.span));\n+                self.labels_in_fn.push((label, label_span));\n             }\n             intravisit::walk_expr(self, ex)\n         }\n@@ -430,10 +430,11 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n         }\n     }\n \n-    fn expression_label(ex: &hir::Expr) -> Option<ast::Name> {\n+    fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n         match ex.node {\n             hir::ExprWhile(_, _, Some(label)) |\n-            hir::ExprLoop(_, Some(label)) => Some(label.unhygienize()),\n+            hir::ExprLoop(_, Some(label)) => Some((label.node.unhygienize(),\n+                                                   label.span)),\n             _ => None,\n         }\n     }"}, {"sha": "3dd1b6eb205d4f501585b1db83022dc0ff5702d4", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -251,7 +251,7 @@ mod svh_visitor {\n             ExprType(..)             => SawExprType,\n             ExprIf(..)               => SawExprIf,\n             ExprWhile(..)            => SawExprWhile,\n-            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.as_str())),\n+            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.node.as_str())),\n             ExprMatch(..)            => SawExprMatch,\n             ExprClosure(..)          => SawExprClosure,\n             ExprBlock(..)            => SawExprBlock,"}, {"sha": "597a29d1aac6e3c1f6d1b92872d6704b8a5798e2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -3128,7 +3128,7 @@ impl<'a> Resolver<'a> {\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        rib.bindings.insert(mtwt::resolve(label), def);\n+                        rib.bindings.insert(mtwt::resolve(label.node), def);\n                     }\n \n                     visit::walk_expr(this, expr);\n@@ -3173,7 +3173,7 @@ impl<'a> Resolver<'a> {\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n \n-                self.resolve_labeled_block(label, expr.id, block);\n+                self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n                 self.value_ribs.pop();\n             }\n@@ -3183,7 +3183,7 @@ impl<'a> Resolver<'a> {\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, LocalIrrefutableMode, &mut HashMap::new());\n \n-                self.resolve_labeled_block(label, expr.id, block);\n+                self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n                 self.value_ribs.pop();\n             }"}, {"sha": "4a94d8b01a3405de5f71709f04a7d2b825aca9fd", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -1007,23 +1007,23 @@ pub enum ExprKind {\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    While(P<Expr>, P<Block>, Option<Ident>),\n+    While(P<Expr>, P<Block>, Option<SpannedIdent>),\n     /// A while-let loop, with an optional label\n     ///\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n+    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<SpannedIdent>),\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n+    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<SpannedIdent>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    Loop(P<Block>, Option<Ident>),\n+    Loop(P<Block>, Option<SpannedIdent>),\n     /// A `match` block.\n     Match(P<Expr>, Vec<Arm>),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)"}, {"sha": "56374e935931bc8a200ba71f5a50a825c41c0dcd", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{Block, Crate, DeclKind, PatKind};\n-use ast::{Local, Ident, Mac_, Name};\n+use ast::{Local, Ident, Mac_, Name, SpannedIdent};\n use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast::TokenTree;\n use ast;\n@@ -334,20 +334,20 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n /// body is in a block enclosed by loop head so the renaming of loop label\n /// must be propagated to the enclosed context.\n fn expand_loop_block(loop_block: P<Block>,\n-                     opt_ident: Option<Ident>,\n-                     fld: &mut MacroExpander) -> (P<Block>, Option<Ident>) {\n+                     opt_ident: Option<SpannedIdent>,\n+                     fld: &mut MacroExpander) -> (P<Block>, Option<SpannedIdent>) {\n     match opt_ident {\n         Some(label) => {\n-            let new_label = fresh_name(label);\n-            let rename = (label, new_label);\n+            let new_label = fresh_name(label.node);\n+            let rename = (label.node, new_label);\n \n             // The rename *must not* be added to the pending list of current\n             // syntax context otherwise an unrelated `break` or `continue` in\n             // the same context will pick that up in the deferred renaming pass\n             // and be renamed incorrectly.\n             let mut rename_list = vec!(rename);\n             let mut rename_fld = IdentRenamer{renames: &mut rename_list};\n-            let renamed_ident = rename_fld.fold_ident(label);\n+            let renamed_ident = rename_fld.fold_ident(label.node);\n \n             // The rename *must* be added to the enclosed syntax context for\n             // `break` or `continue` to pick up because by definition they are\n@@ -357,7 +357,7 @@ fn expand_loop_block(loop_block: P<Block>,\n             let expanded_block = expand_block_elts(loop_block, fld);\n             fld.cx.syntax_env.pop_frame();\n \n-            (expanded_block, Some(renamed_ident))\n+            (expanded_block, Some(Spanned { node: renamed_ident, span: label.span }))\n         }\n         None => (fld.fold_block(loop_block), opt_ident)\n     }"}, {"sha": "f25be190537d8a9927b442464310136c22334356", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -1212,23 +1212,27 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::While(cond, body, opt_ident) => {\n                 ExprKind::While(folder.fold_expr(cond),\n                           folder.fold_block(body),\n-                          opt_ident.map(|i| folder.fold_ident(i)))\n+                          opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                       folder.fold_ident(label.node))))\n             }\n             ExprKind::WhileLet(pat, expr, body, opt_ident) => {\n                 ExprKind::WhileLet(folder.fold_pat(pat),\n                              folder.fold_expr(expr),\n                              folder.fold_block(body),\n-                             opt_ident.map(|i| folder.fold_ident(i)))\n+                             opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                          folder.fold_ident(label.node))))\n             }\n             ExprKind::ForLoop(pat, iter, body, opt_ident) => {\n                 ExprKind::ForLoop(folder.fold_pat(pat),\n                             folder.fold_expr(iter),\n                             folder.fold_block(body),\n-                            opt_ident.map(|i| folder.fold_ident(i)))\n+                            opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                         folder.fold_ident(label.node))))\n             }\n             ExprKind::Loop(body, opt_ident) => {\n                 ExprKind::Loop(folder.fold_block(body),\n-                        opt_ident.map(|i| folder.fold_ident(i)))\n+                               opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                            folder.fold_ident(label.node))))\n             }\n             ExprKind::Match(expr, arms) => {\n                 ExprKind::Match(folder.fold_expr(expr),"}, {"sha": "b616b9db9c3be8356a2ccdf6e7ba4664f8b65bb3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -2283,18 +2283,19 @@ impl<'a> Parser<'a> {\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if self.token.is_lifetime() {\n-                    let lifetime = self.get_lifetime();\n+                    let label = Spanned { node: self.get_lifetime(),\n+                                          span: self.span };\n                     let lo = self.span.lo;\n                     self.bump();\n                     self.expect(&token::Colon)?;\n                     if self.eat_keyword(keywords::While) {\n-                        return self.parse_while_expr(Some(lifetime), lo, attrs)\n+                        return self.parse_while_expr(Some(label), lo, attrs)\n                     }\n                     if self.eat_keyword(keywords::For) {\n-                        return self.parse_for_expr(Some(lifetime), lo, attrs)\n+                        return self.parse_for_expr(Some(label), lo, attrs)\n                     }\n                     if self.eat_keyword(keywords::Loop) {\n-                        return self.parse_loop_expr(Some(lifetime), lo, attrs)\n+                        return self.parse_loop_expr(Some(label), lo, attrs)\n                     }\n                     return Err(self.fatal(\"expected `while`, `for`, or `loop` after a label\"))\n                 }\n@@ -3264,7 +3265,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>,\n+    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                           span_lo: BytePos,\n                           attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n@@ -3283,7 +3284,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>,\n+    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                             span_lo: BytePos,\n                             attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n@@ -3298,7 +3299,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::Ident>,\n+    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                                 span_lo: BytePos,\n                                 attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n@@ -3312,7 +3313,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n-    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>,\n+    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                            span_lo: BytePos,\n                            attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;"}, {"sha": "fec84e912d49e46831de0f3fa4bae92c8dfc525f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -2021,7 +2021,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::While(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    self.print_ident(ident)?;\n+                    self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n@@ -2031,7 +2031,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    self.print_ident(ident)?;\n+                    self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while let\")?;\n@@ -2044,7 +2044,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    self.print_ident(ident)?;\n+                    self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"for\")?;\n@@ -2057,7 +2057,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Loop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    self.print_ident(ident)?;\n+                    self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;"}, {"sha": "3bd300a8e8c22e55a35a91e5d679f9649c90c070", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70880fea967715e964f459746a77aa9e93dc35f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a70880fea967715e964f459746a77aa9e93dc35f", "patch": "@@ -26,7 +26,7 @@\n use abi::Abi;\n use ast::*;\n use attr::ThinAttributesExt;\n-use codemap::Span;\n+use codemap::{Span, Spanned};\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n@@ -149,17 +149,24 @@ macro_rules! walk_list {\n }\n \n pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n-    for name in opt_name {\n+    if let Some(name) = opt_name {\n         visitor.visit_name(span, name);\n     }\n }\n \n pub fn walk_opt_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n-    for ident in opt_ident {\n+    if let Some(ident) = opt_ident {\n         visitor.visit_ident(span, ident);\n     }\n }\n \n+pub fn walk_opt_sp_ident<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             opt_sp_ident: &Option<Spanned<Ident>>) {\n+    if let Some(ref sp_ident) = *opt_sp_ident {\n+        visitor.visit_ident(sp_ident.span, sp_ident.node);\n+    }\n+}\n+\n pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident) {\n     visitor.visit_name(span, ident.name);\n }\n@@ -712,32 +719,32 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::While(ref subexpression, ref block, opt_ident) => {\n+        ExprKind::While(ref subexpression, ref block, ref opt_sp_ident) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, opt_ident) => {\n+        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, ref opt_sp_ident) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n-        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, opt_ident) => {\n+        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_sp_ident) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n-        ExprKind::Loop(ref block, opt_ident) => {\n+        ExprKind::Loop(ref block, ref opt_sp_ident) => {\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Match(ref subexpression, ref arms) => {\n             visitor.visit_expr(subexpression);\n@@ -781,9 +788,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_path(path, expression.id)\n         }\n         ExprKind::Break(ref opt_sp_ident) | ExprKind::Again(ref opt_sp_ident) => {\n-            for sp_ident in opt_sp_ident {\n-                visitor.visit_ident(sp_ident.span, sp_ident.node);\n-            }\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}]}