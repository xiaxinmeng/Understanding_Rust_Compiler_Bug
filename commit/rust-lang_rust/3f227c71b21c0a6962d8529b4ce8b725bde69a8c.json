{"sha": "3f227c71b21c0a6962d8529b4ce8b725bde69a8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMjI3YzcxYjIxYzBhNjk2MmQ4NTI5YjRjZThiNzI1YmRlNjlhOGM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-14T21:41:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-14T21:41:19Z"}, "message": "Some terminology updates to talk about layers.", "tree": {"sha": "9442eefdd1616a003617d471e8e3c4a5cafdab33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9442eefdd1616a003617d471e8e3c4a5cafdab33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f227c71b21c0a6962d8529b4ce8b725bde69a8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f227c71b21c0a6962d8529b4ce8b725bde69a8c", "html_url": "https://github.com/rust-lang/rust/commit/3f227c71b21c0a6962d8529b4ce8b725bde69a8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f227c71b21c0a6962d8529b4ce8b725bde69a8c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a1cba7883dfc2b0d84d5d5a694d7595b5f2d832", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a1cba7883dfc2b0d84d5d5a694d7595b5f2d832", "html_url": "https://github.com/rust-lang/rust/commit/5a1cba7883dfc2b0d84d5d5a694d7595b5f2d832"}], "stats": {"total": 150, "additions": 78, "deletions": 72}, "files": [{"sha": "5fc1a8b7b1d1534767cd64c025f3df6b6b78604e", "filename": "doc/rust.texi", "status": "modified", "additions": 78, "deletions": 72, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/3f227c71b21c0a6962d8529b4ce8b725bde69a8c/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/3f227c71b21c0a6962d8529b4ce8b725bde69a8c/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=3f227c71b21c0a6962d8529b4ce8b725bde69a8c", "patch": "@@ -250,9 +250,7 @@ Many values in Rust are allocated @emph{within} their containing stack-frame\n or parent structure. Numbers, records, tuples and tags are all allocated this\n way. To allocate such values in the heap, they must be explicitly\n @emph{boxed}. A @dfn{box} is a pointer to a heap allocation that holds another\n-value, its @emph{content}. If the content of a box is a @emph{state} value --\n-the sort that may contain mutable members -- then the heap allocation is also\n-subject to garbage collection.\n+value, its @emph{content}.\n \n Boxing and unboxing in Rust is explicit, though in many cases (arithmetic\n operations, name-component dereferencing) Rust will automatically ``reach\n@@ -275,35 +273,42 @@ still guaranteeing that every use of a slot occurs after it has been\n initialized.\n \n @sp 1\n-@item Static control over mutability.\n+@item Static control over mutability and garbage collection.\n \n-Types in Rust are classified as either immutable or mutable. By default,\n-all types are immutable.\n+Types in Rust are classified into @emph{layers}. There is a layer of immutable\n+values, a layer of state values, and a layer of GC values. By default, all\n+types are immutable.\n \n-If a type is declared as @code{mutable}, then the type is a @code{state} type\n-and must be declared as such. Any type directly marked as @code{mutable}\n-@emph{or indirectly containing} a state type is also a state type.\n+If a field within a type is declared as @code{mutable}, then the type is part\n+of the @code{state} layer and must be declared as such. Any type directly\n+marked as @code{state} @emph{or indirectly referring to} a state type is also\n+a state type.\n \n-This classification of data types in Rust interacts with the memory allocation\n-and transmission rules. In particular:\n+If a field within a type is potentially cyclic (this is a narrow, but\n+well-defined condition involving mutable recursive types) then it is part of\n+the @code{gc} layer and must be declared as such.\n+\n+This classification of data types in Rust interacts with the memory allocation,\n+transmission and destruction rules. In particular:\n \n @itemize\n-@item Only immutable (non-state) values can be sent over channels.\n-@item Only immutable (non-state) objects can have destructor functions.\n+@item Only immutable values can be sent over channels.\n+@item Only non-GC objects can have destructor functions.\n @end itemize\n \n-Boxed state values are subject to local (per-task) garbage-collection. Garbage\n-collection costs are therefore also task-local and do not interrupt or suspend\n-other tasks.\n+Garbage collection, when present, operates per-task and does not interrupt\n+other tasks while running. It is limited to types that need it and can be\n+statically avoided altogether by limiting the types in a program to the state\n+and immutable layers.\n \n-Boxed immutable values are reference-counted and have a deterministic\n-destruction order: top-down, immediately upon release of the last live\n-reference.\n+Non-GC values are reference-counted and have a deterministic destruction\n+order: top-down, immediately upon release of the last live reference.\n \n-State values can refer to non-state values, but not vice-versa. Rust\n-therefore encourages the programmer to write in a style that consists\n-primarily of immutable types, but also permits limited, local\n-(per-task) mutability.\n+State values can refer to non-state values, but not vice-versa; likewise GC\n+values can refer to non-GC values but not vice-versa. Rust therefore\n+encourages the programmer to write in a style that consists primarily of\n+immutable types, but also permits limited, local (per-task) mutability,\n+and provides local (per-task) GC only when required.\n \n @sp 1\n @item Stack-based iterators\n@@ -360,8 +365,7 @@ Rust has a lightweight object system based on structural object types: there\n is no ``class hierarchy'' nor any concept of inheritance. Method overriding\n and object restriction are performed explicitly on object values, which are\n little more than order-insensitive records of methods sharing a common private\n-value. Objects can be state or non-state, and only non-state objects can have\n-destructors.\n+value. Objects that reside outside the GC layer can have destructors.\n \n @sp 1\n @item Dynamic type\n@@ -407,29 +411,29 @@ organizing tasks into mutually-supervising or mutually-failing groups.\n @sp 1\n @item Deterministic destruction\n \n-Immutable objects can have destructor functions, which are executed\n+Non-GC objects can have destructor functions, which are executed\n deterministically in top-down ownership order, as control frames are exited\n and/or objects are otherwise freed from data structures holding them. The same\n destructors are run in the same order whether the object is deleted by\n unwinding during failure or normal execution.\n \n-Similarly, the rules for freeing immutable values are deterministic and\n+Similarly, the rules for freeing non-GC values are deterministic and\n predictable: on scope-exit or structure-release, local slots are released\n immediately. Referenced boxes have their reference count decreased and are\n released if the count drops to zero. Aliases are silently forgotten.\n \n-State values are local to a task, and are subject to per-task garbage\n-collection. As a result, unreferenced state boxes are not necessarily freed\n-immediately; if an unreferenced state box is part of an acyclic graph, it is\n+GC values are local to a task, and are subject to per-task garbage\n+collection. As a result, unreferenced GC-layer boxes are not necessarily freed\n+immediately; if an unreferenced GC box is part of an acyclic graph, it is\n freed when the last reference to it drops, but if it is part of a reference\n cycle it will be freed when the GC collects it (or when the owning task\n terminates, at the latest).\n \n-State values can point to immutable values but not vice-versa. Doing so merely\n+GC values can point to non-GC values but not vice-versa. Doing so merely\n delays (to an undefined future time) the moment when the deterministic,\n-top-down destruction sequence for the referenced immutable values\n-@emph{start}. In other words, the immutable ``leaves'' of a state value are\n-released in a locally-predictable order, even if the ``interior'' of the state\n+top-down destruction sequence for the referenced non-GC values\n+@emph{start}. In other words, the non-GC ``leaves'' of a GC value are released\n+in a locally-predictable order, even if the ``interior'' cyclic part of the GC\n value is released in an unpredictable order.\n \n @sp 1\n@@ -1265,15 +1269,16 @@ entry to each function as the task executes. A stack allocation is reclaimed\n when control leaves the frame containing it.\n \n The @dfn{heap} is a general term that describes two separate sets of boxes:\n-@emph{task-local} state boxes and the @emph{shared} non-state boxes.\n+@emph{task-local} state and GC boxes, and the @emph{shared} immutable boxes.\n \n-State boxes are @dfn{task-local}, owned by the task. Like any other state\n-value, they cannot pass over channels. State boxes do not outlive the task\n-that owns them. When unreferenced, they are collected using a general\n+State and GC boxes are @dfn{task-local}, owned by the task. Like any other\n+state or GC value, they cannot pass over channels. State and GC boxes do not\n+outlive the task that owns them. When unreferenced, they are either\n+immediately destructed (if acyclic) or else collected using a general\n (cycle-aware) garbage-collector local to each task. Garbage collection within\n a local heap does not interrupt execution of other tasks.\n \n-Non-state boxes are @dfn{shared}, and can be multiply-referenced by many\n+Immutable boxes are @dfn{shared}, and can be multiply-referenced by many\n different tasks. Like any other immutable type, they can pass over channels,\n and live as long as the last task referencing them within a given domain. When\n unreferenced, they are destroyed immediately (due to reference-counting) and\n@@ -1794,9 +1799,9 @@ statement. If a control path lacks a @code{ret} statement in source code, an\n implicit @code{ret} statement is appended to the end of the control path\n during compilation, returning the implicit @code{()} value.\n \n-A function may have an @emph{effect}, which may be either @code{io},\n-@code{state}, @code{unsafe}. If no effect is specified, the function is said\n-to be @dfn{pure}.\n+A function may have an @emph{effect}, which may be either @code{impure} or\n+@code{unsafe}. If no effect is specified, the function is said to be\n+@dfn{pure}.\n \n Any pure boolean function is also called a @emph{predicate}, and may be used\n as part of the static typestate system. @xref{Ref.Stmt.Stat.Constr}.\n@@ -1933,23 +1938,23 @@ variables to initial values.\n @c * Ref.Item.Type::          Items defining the types of values and slots.\n @cindex Types\n \n-A @dfn{type} defines an @emph{interpretation} of a value in\n-memory. @xref{Ref.Type}. Types are declared with the keyword @code{type}. A\n-type's interpretation is used for the values held in any slot with that\n-type. @xref{Ref.Mem.Slot}. The interpretation of a value includes:\n+A @dfn{type} defines a set of possible values in\n+memory. @xref{Ref.Type}. Types are declared with the keyword\n+@code{type}. Every value has a single, specific type; the type-specified\n+aspects of a value include:\n \n @itemize\n @item Whether the value is composed of sub-values or is indivisible.\n @item Whether the value represents textual or numerical information.\n @item Whether the value represents integral or floating-point information.\n @item The sequence of memory operations required to access the value.\n-@item Whether the value is mutable or immutable.\n+@item The storage layer the value resides in (immutable, state or gc).\n @end itemize\n \n-For example, the type @code{rec(u8 x, u8 y)} defines the interpretation of\n-values that are composite records, each containing two unsigned 8-bit\n-integers accessed through the components @code{x} and @code{y}, and laid\n-out in memory with the @code{x} component preceding the @code{y} component.\n+For example, the type @code{rec(u8 x, u8 y)} defines the set of immutable\n+values that are composite records, each containing two unsigned 8-bit integers\n+accessed through the components @code{x} and @code{y}, and laid out in memory\n+with the @code{x} component preceding the @code{y} component.\n \n @node       Ref.Item.Tag\n @subsection Ref.Item.Tag\n@@ -2238,9 +2243,9 @@ check (p._1 == \"world\");\n @cindex Array types, see @i{Vector types}\n \n The vector type-constructor @code{vec} represents a homogeneous array of\n-values of a given type. A vector has a fixed size. If the member-type of a\n-vector is a state type, then vector is a @emph{state} type, like any type\n-containing another type.\n+values of a given type. A vector has a fixed size. The layer of a vector type\n+is to the layer of its member type, like any type that contains a single\n+member type.\n \n Vectors can be sliced. A slice expression builds a new vector by copying a\n contiguous range -- given by a pair of indices representing a half-open\n@@ -2342,10 +2347,13 @@ communication facility. @xref{Ref.Task.Comm}. A @code{port} type takes a\n single type parameter, denoting the type of value that can be received from a\n @code{port} value of that type.\n \n-Ports are modeled as mutable native types with built-in meaning to the\n+Ports are modeled as stateful native types, with built-in meaning to the\n language. They cannot be transmitted over channels or otherwise replicated,\n and are always local to the task that creates them.\n \n+Ports (like channels) can only be carry types of the immutable layer. No\n+mutable values can pass over a port or channel.\n+\n An example of a @code{port} type:\n @example\n type port[vec[str]] svp;\n@@ -2369,6 +2377,9 @@ Channels are immutable, and can be transmitted over channels to other\n tasks. They are modeled as immutable native types with built-in meaning to the\n language.\n \n+Channels (like ports) can only be carry types of the immutable layer. No\n+mutable values can pass over a port or channel.\n+\n When a task sends a message into a channel, the task forms an outgoing queue\n associated with that channel. The per-task queue @emph{associated} with a\n channel can be indirectly manipulated by the task, but is @emph{not} otherwise\n@@ -2379,8 +2390,8 @@ associated with the channel.\n Channels are also @emph{weak}: a channel is directly coupled to a particular\n destination port on a particular task, but does not keep that port or task\n @emph{alive}. A channel may therefore fail to operate at any moment. If a task\n-sends to a channel that is connected to a nonexistent port, it receives a\n-signal.\n+sends a message to a channel that is connected to a nonexistent port, the\n+message is dropped.\n \n An example of a @code{chan} type:\n @example\n@@ -2407,8 +2418,8 @@ the language. They cannot be transmitted over channels or otherwise\n replicated, and are always local to the task that spawns them.\n \n If all references to a task are dropped (due to the release of any structure\n-holding those references), the released task immediately fails.\n-@xref{Ref.Task.Life}.\n+holding those references), the runtime signals the un-referenced task, which\n+then fails. @xref{Ref.Task.Life}.\n \n \n @node       Ref.Type.Obj\n@@ -2427,15 +2438,10 @@ declaration. Such a ``plain'' object type can be used to describe an interface\n that a variety of particular objects may conform to, by supporting a superset\n of the methods.\n \n-An object type that can contain a state must be declared as a @code{state obj}\n-like any other state type. And similarly a method type that performs I/O or\n-makes native calls must be declared @code{io} or @code{unsafe}, like any other\n-function.\n-\n-Moreover, @emph{all} methods of a state object are implicitly state functions -- as\n-they all bind the same mutable state field(s) -- so implicitly have an effect\n-lower than @code{io}. It is therefore unnecessary to declare methods within a\n-state object type (or state object item) as @code{io}.\n+An object type that can contain fields of a given layer must be declared as\n+residing in that layer (or lower), like any other type. And similarly a method\n+with a given effect must be declared as having that effect (or lower) in the\n+object type, like any other function.\n \n An example of an object type with two separate object items supporting it, and\n a client function using both items via the object type:\n@@ -2444,17 +2450,17 @@ a client function using both items via the object type:\n \n state type taker =\n     state obj @{\n-        fn take(int);\n+        impure fn take(int);\n     @};\n \n state obj adder(mutable int x) @{\n-    fn take(int y) @{\n+    impure fn take(int y) @{\n         x += y;\n     @}\n @}\n \n obj sender(chan[int] c) @{\n-    io fn take(int z) @{\n+    impure fn take(int z) @{\n         c <| z;\n     @}\n @}\n@@ -3113,7 +3119,7 @@ by the runtime or emitted to a system console. Log statements are enabled or\n disabled dynamically at run-time on a per-task and per-item\n basis. @xref{Ref.Run.Log}.\n \n-Executing a @code{log} statement is not considered an @code{io} effect in the\n+Executing a @code{log} statement is not considered an impure effect in the\n effect system. In other words, a pure function remains pure even if it\n contains a log statement.\n "}]}