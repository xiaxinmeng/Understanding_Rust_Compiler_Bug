{"sha": "2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNGExYjU1ZTY1YzlmNTEzY2Q3MWYwZjgyNGU5NGFhNmY1ODhkZjA=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-12-04T03:18:35Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-12-05T06:33:53Z"}, "message": "Rename extra::json::*::init() constructors to *::new()", "tree": {"sha": "ceb038945a170ba6ce21bcc8bae1ba231b556711", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ceb038945a170ba6ce21bcc8bae1ba231b556711"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "html_url": "https://github.com/rust-lang/rust/commit/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "408dc5ad1b657eb2261e7ac680b8d100469e5477", "url": "https://api.github.com/repos/rust-lang/rust/commits/408dc5ad1b657eb2261e7ac680b8d100469e5477", "html_url": "https://github.com/rust-lang/rust/commit/408dc5ad1b657eb2261e7ac680b8d100469e5477"}], "stats": {"total": 114, "additions": 57, "deletions": 57}, "files": [{"sha": "46a04abebe54f5cb2f7e07f50ba43d821a9df998", "filename": "src/libextra/json.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "patch": "@@ -91,7 +91,7 @@ pub struct Encoder<'self> {\n impl<'self> Encoder<'self> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n-    pub fn init<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n+    pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n         Encoder { wr: wr }\n     }\n }\n@@ -247,7 +247,7 @@ pub struct PrettyEncoder<'self> {\n \n impl<'self> PrettyEncoder<'self> {\n     /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn init<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+    pub fn new<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n         PrettyEncoder {\n             wr: wr,\n             indent: 0,\n@@ -449,14 +449,14 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n impl Json{\n     /// Encodes a json value into a io::writer.  Uses a single line.\n     pub fn to_writer(&self, wr: &mut io::Writer) {\n-        let mut encoder = Encoder::init(wr);\n+        let mut encoder = Encoder::new(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n     pub fn to_pretty_writer(&self, wr: &mut io::Writer) {\n-        let mut encoder = PrettyEncoder::init(wr);\n+        let mut encoder = PrettyEncoder::new(wr);\n         self.encode(&mut encoder)\n     }\n \n@@ -477,7 +477,7 @@ pub struct Parser<T> {\n \n impl<T: Iterator<char>> Parser<T> {\n     /// Decode a json value from an Iterator<char>\n-    pub fn init(rdr: T) -> Parser<T> {\n+    pub fn new(rdr: T) -> Parser<T> {\n         let mut p = Parser {\n             rdr: rdr,\n             ch: '\\x00',\n@@ -848,13 +848,13 @@ impl<T : Iterator<char>> Parser<T> {\n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n     let s = str::from_utf8_owned(rdr.read_to_end());\n-    let mut parser = Parser::init(s.chars());\n+    let mut parser = Parser::new(s.chars());\n     parser.parse()\n }\n \n /// Decodes a json value from a string\n pub fn from_str(s: &str) -> Result<Json, Error> {\n-    let mut parser = Parser::init(s.chars());\n+    let mut parser = Parser::new(s.chars());\n     parser.parse()\n }\n \n@@ -865,7 +865,7 @@ pub struct Decoder {\n \n impl Decoder {\n     /// Creates a new decoder instance for decoding the specified JSON value.\n-    pub fn init(json: Json) -> Decoder {\n+    pub fn new(json: Json) -> Decoder {\n         Decoder {\n             stack: ~[json]\n         }\n@@ -1522,14 +1522,14 @@ mod tests {\n         let animal = Dog;\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = Encoder::init(wr);\n+                let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::init(wr);\n+                let mut encoder = PrettyEncoder::new(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\"Dog\\\"\"\n@@ -1538,14 +1538,14 @@ mod tests {\n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = Encoder::init(wr);\n+                let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::init(wr);\n+                let mut encoder = PrettyEncoder::new(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\n@@ -1561,14 +1561,14 @@ mod tests {\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::init(wr);\n+            let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n-            let mut encoder = PrettyEncoder::init(wr);\n+            let mut encoder = PrettyEncoder::new(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n@@ -1578,13 +1578,13 @@ mod tests {\n     fn test_write_none() {\n         let value: Option<~str> = None;\n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::init(wr);\n+            let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"null\");\n \n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::init(wr);\n+            let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"null\");\n@@ -1633,15 +1633,15 @@ mod tests {\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let mut decoder = Decoder::init(from_str(\"null\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n         let v: () = Decodable::decode(&mut decoder);\n         assert_eq!(v, ());\n \n-        let mut decoder = Decoder::init(from_str(\"true\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"true\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, true);\n \n-        let mut decoder = Decoder::init(from_str(\"false\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"false\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, false);\n     }\n@@ -1676,31 +1676,31 @@ mod tests {\n \n     #[test]\n     fn test_decode_numbers() {\n-        let mut decoder = Decoder::init(from_str(\"3\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"3\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.0);\n \n-        let mut decoder = Decoder::init(from_str(\"3.1\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"3.1\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.1);\n \n-        let mut decoder = Decoder::init(from_str(\"-1.2\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"-1.2\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, -1.2);\n \n-        let mut decoder = Decoder::init(from_str(\"0.4\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"0.4\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4);\n \n-        let mut decoder = Decoder::init(from_str(\"0.4e5\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"0.4e5\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e5);\n \n-        let mut decoder = Decoder::init(from_str(\"0.4e15\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"0.4e15\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e15);\n \n-        let mut decoder = Decoder::init(from_str(\"0.4e-01\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"0.4e-01\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e-01);\n     }\n@@ -1728,39 +1728,39 @@ mod tests {\n \n     #[test]\n     fn test_decode_str() {\n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"foo\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"foo\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"foo\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\\"\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\b\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\b\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\x08\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\n\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\n\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\n\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\r\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\r\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\r\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\t\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\t\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\t\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\u12ab\");\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\uAB12\");\n     }\n@@ -1793,27 +1793,27 @@ mod tests {\n \n     #[test]\n     fn test_decode_list() {\n-        let mut decoder = Decoder::init(from_str(\"[]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[]);\n \n-        let mut decoder = Decoder::init(from_str(\"[null]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[null]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[()]);\n \n-        let mut decoder = Decoder::init(from_str(\"[true]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder::init(from_str(\"[true]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder::init(from_str(\"[3, 1]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[3, 1]\").unwrap());\n         let v: ~[int] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[3, 1]);\n \n-        let mut decoder = Decoder::init(from_str(\"[[3], [1, 2]]\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"[[3], [1, 2]]\").unwrap());\n         let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[~[3], ~[1, 2]]);\n     }\n@@ -1915,7 +1915,7 @@ mod tests {\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n         }\";\n-        let mut decoder = Decoder::init(from_str(s).unwrap());\n+        let mut decoder = Decoder::new(from_str(s).unwrap());\n         let v: Outer = Decodable::decode(&mut decoder);\n         assert_eq!(\n             v,\n@@ -1929,31 +1929,31 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let mut decoder = Decoder::init(from_str(\"null\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, None);\n \n-        let mut decoder = Decoder::init(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let mut decoder = Decoder::init(from_str(\"\\\"Dog\\\"\").unwrap());\n+        let mut decoder = Decoder::new(from_str(\"\\\"Dog\\\"\").unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Dog);\n \n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-        let mut decoder = Decoder::init(from_str(s).unwrap());\n+        let mut decoder = Decoder::new(from_str(s).unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut decoder = Decoder::init(from_str(s).unwrap());\n+        let mut decoder = Decoder::new(from_str(s).unwrap());\n         let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder);\n \n         assert_eq!(map.pop(&~\"a\"), Some(Dog));\n@@ -1990,7 +1990,7 @@ mod tests {\n             match from_str(to_parse) {\n                 Err(e) => Some(e.to_str()),\n                 Ok(json) => {\n-                    let _: T = Decodable::decode(&mut Decoder::init(json));\n+                    let _: T = Decodable::decode(&mut Decoder::new(json));\n                     None\n                 }\n             }"}, {"sha": "818cc49511fa3b6b3f91f2e309504e026e20f3d5", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "patch": "@@ -947,7 +947,7 @@ impl MetricMap {\n         assert!(p.exists());\n         let mut f = File::open(p);\n         let value = json::from_reader(&mut f as &mut io::Reader).unwrap();\n-        let mut decoder = json::Decoder::init(value);\n+        let mut decoder = json::Decoder::new(value);\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n "}, {"sha": "0afc8c08d4c400e341e9169ee85fb8b500013c23", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "patch": "@@ -191,7 +191,7 @@ impl Database {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n-                        let mut decoder = json::Decoder::init(r);\n+                        let mut decoder = json::Decoder::new(r);\n                         self.db_cache = Decodable::decode(&mut decoder);\n                     }\n             }\n@@ -258,7 +258,7 @@ enum Work<'self, T> {\n \n fn json_encode<'self, T:Encodable<json::Encoder<'self>>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n-    let mut encoder = json::Encoder::init(&mut writer as &mut io::Writer);\n+    let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     t.encode(&mut encoder);\n     str::from_utf8_owned(writer.inner())\n }\n@@ -267,7 +267,7 @@ fn json_encode<'self, T:Encodable<json::Encoder<'self>>>(t: &T) -> ~str {\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     debug!(\"json decoding: {}\", s);\n     let j = json::from_str(s).unwrap();\n-    let mut decoder = json::Decoder::init(j);\n+    let mut decoder = json::Decoder::new(j);\n     Decodable::decode(&mut decoder)\n }\n "}, {"sha": "8d6fd5cd9dc9be0f185e4c2b231cefe336716f84", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "patch": "@@ -283,7 +283,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n             }\n             let crate = match obj.pop(&~\"crate\") {\n                 Some(json) => {\n-                    let mut d = json::Decoder::init(json);\n+                    let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d)\n                 }\n                 None => return Err(~\"malformed json\"),\n@@ -314,7 +314,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     let crate_json_str = {\n         let mut w = MemWriter::new();\n         {\n-            let mut encoder = json::Encoder::init(&mut w as &mut io::Writer);\n+            let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             crate.encode(&mut encoder);\n         }\n         str::from_utf8_owned(w.inner())"}, {"sha": "612151f83e442cac5807639150915941fa458811", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "patch": "@@ -344,7 +344,7 @@ mod test {\n     #[cfg(test)]\n     fn to_json_str<'a, E: Encodable<extra::json::Encoder<'a>>>(val: &E) -> ~str {\n         let mut writer = MemWriter::new();\n-        let mut encoder = extra::json::Encoder::init(&mut writer as &mut io::Writer);\n+        let mut encoder = extra::json::Encoder::new(&mut writer as &mut io::Writer);\n         val.encode(&mut encoder);\n         str::from_utf8_owned(writer.inner())\n     }"}, {"sha": "c1f40d302c865d36aec519831010bf6cf0999b26", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "patch": "@@ -18,7 +18,7 @@ trait JD : Decodable<json::Decoder> { }\n \n fn exec<T: JD>() {\n     let doc = json::from_str(\"\").unwrap();\n-    let mut decoder = json::Decoder::init(doc);\n+    let mut decoder = json::Decoder::new(doc);\n     let _v: T = Decodable::decode(&mut decoder);\n     fail!()\n }"}, {"sha": "5665bff571e4cd50f6c9567a4fadcd9682e7da59", "filename": "src/test/run-pass/issue-4036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a1b55e65c9f513cd71f0f824e94aa6f588df0/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4036.rs?ref=2c4a1b55e65c9f513cd71f0f824e94aa6f588df0", "patch": "@@ -17,6 +17,6 @@ use self::extra::serialize;\n \n pub fn main() {\n     let json = json::from_str(\"[1]\").unwrap();\n-    let mut decoder = json::Decoder::init(json);\n+    let mut decoder = json::Decoder::new(json);\n     let _x: ~[int] = serialize::Decodable::decode(&mut decoder);\n }"}]}