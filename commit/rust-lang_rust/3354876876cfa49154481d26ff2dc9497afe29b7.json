{"sha": "3354876876cfa49154481d26ff2dc9497afe29b7", "node_id": "C_kwDOAAsO6NoAKDMzNTQ4NzY4NzZjZmE0OTE1NDQ4MWQyNmZmMmRjOTQ5N2FmZTI5Yjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-28T05:50:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-28T05:50:20Z"}, "message": "Auto merge of #8182 - rust-lang:cache-test-items, r=giraffate\n\ncache test item names\n\nThis avoids quadratic behavior (collecting all test item names for each `eq_op` instance within the module). However, it invests a good deal of memory to buy this speedup. If that becomes a problem, I may need to change the cache to only store the chain of last visited modules.\n\nThis hopefully fixes #8171.\n\n---\n\nchangelog: none", "tree": {"sha": "f6b1197ac617bb2ac01d672c1880ca66ecdc19e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6b1197ac617bb2ac01d672c1880ca66ecdc19e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3354876876cfa49154481d26ff2dc9497afe29b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3354876876cfa49154481d26ff2dc9497afe29b7", "html_url": "https://github.com/rust-lang/rust/commit/3354876876cfa49154481d26ff2dc9497afe29b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3354876876cfa49154481d26ff2dc9497afe29b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d194d1952bba0974cbe9ab249cc70e75f9cf8ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d194d1952bba0974cbe9ab249cc70e75f9cf8ae", "html_url": "https://github.com/rust-lang/rust/commit/5d194d1952bba0974cbe9ab249cc70e75f9cf8ae"}, {"sha": "8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2", "html_url": "https://github.com/rust-lang/rust/commit/8da9a823cbadfbb93b8a9e519ff3b5e03989dcb2"}], "stats": {"total": 70, "additions": 42, "deletions": 28}, "files": [{"sha": "51bb2681e74305ba291251da23efb77f0ec8ffec", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3354876876cfa49154481d26ff2dc9497afe29b7/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3354876876cfa49154481d26ff2dc9497afe29b7/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=3354876876cfa49154481d26ff2dc9497afe29b7", "patch": "@@ -1,8 +1,9 @@\n #![feature(box_patterns)]\n+#![feature(control_flow_enum)]\n #![feature(in_band_lifetimes)]\n #![feature(let_else)]\n+#![feature(once_cell)]\n #![feature(rustc_private)]\n-#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![allow(clippy::missing_errors_doc, clippy::missing_panics_doc, clippy::must_use_candidate)]\n@@ -60,9 +61,12 @@ pub use self::hir_utils::{both, count_eq, eq_expr_value, over, SpanlessEq, Spanl\n \n use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n+use std::lazy::SyncOnceCell;\n+use std::sync::{Mutex, MutexGuard};\n \n use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, LitKind};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -87,6 +91,7 @@ use rustc_middle::ty::binding::BindingMode;\n use rustc_middle::ty::{layout::IntegerExt, BorrowKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::sym;\n@@ -2139,26 +2144,25 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     false\n }\n \n-struct VisitConstTestStruct<'tcx> {\n+struct TestItemNamesVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     names: Vec<Symbol>,\n-    found: bool,\n }\n-impl<'hir> ItemLikeVisitor<'hir> for VisitConstTestStruct<'hir> {\n+\n+impl<'hir> ItemLikeVisitor<'hir> for TestItemNamesVisitor<'hir> {\n     fn visit_item(&mut self, item: &Item<'_>) {\n         if let ItemKind::Const(ty, _body) = item.kind {\n             if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n                 // We could also check for the type name `test::TestDescAndFn`\n-                // and the `#[rustc_test_marker]` attribute?\n                 if let Res::Def(DefKind::Struct, _) = path.res {\n                     let has_test_marker = self\n                         .tcx\n                         .hir()\n                         .attrs(item.hir_id())\n                         .iter()\n                         .any(|a| a.has_name(sym::rustc_test_marker));\n-                    if has_test_marker && self.names.contains(&item.ident.name) {\n-                        self.found = true;\n+                    if has_test_marker {\n+                        self.names.push(item.ident.name);\n                     }\n                 }\n             }\n@@ -2169,32 +2173,42 @@ impl<'hir> ItemLikeVisitor<'hir> for VisitConstTestStruct<'hir> {\n     fn visit_foreign_item(&mut self, _: &ForeignItem<'_>) {}\n }\n \n+static TEST_ITEM_NAMES_CACHE: SyncOnceCell<Mutex<FxHashMap<LocalDefId, Vec<Symbol>>>> = SyncOnceCell::new();\n+\n+fn with_test_item_names(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(&[Symbol]) -> bool) -> bool {\n+    let cache = TEST_ITEM_NAMES_CACHE.get_or_init(|| Mutex::new(FxHashMap::default()));\n+    let mut map: MutexGuard<'_, FxHashMap<LocalDefId, Vec<Symbol>>> = cache.lock().unwrap();\n+    match map.entry(module) {\n+        Entry::Occupied(entry) => f(entry.get()),\n+        Entry::Vacant(entry) => {\n+            let mut visitor = TestItemNamesVisitor { tcx, names: Vec::new() };\n+            tcx.hir().visit_item_likes_in_module(module, &mut visitor);\n+            visitor.names.sort_unstable();\n+            f(&*entry.insert(visitor.names))\n+        },\n+    }\n+}\n+\n /// Checks if the function containing the given `HirId` is a `#[test]` function\n ///\n /// Note: If you use this function, please add a `#[test]` case in `tests/ui_test`.\n pub fn is_in_test_function(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n-    let names: Vec<_> = tcx\n-        .hir()\n-        .parent_iter(id)\n-        // Since you can nest functions we need to collect all until we leave\n-        // function scope\n-        .filter_map(|(_id, node)| {\n-            if let Node::Item(item) = node {\n-                if let ItemKind::Fn(_, _, _) = item.kind {\n-                    return Some(item.ident.name);\n+    with_test_item_names(tcx, tcx.parent_module(id), |names| {\n+        tcx.hir()\n+            .parent_iter(id)\n+            // Since you can nest functions we need to collect all until we leave\n+            // function scope\n+            .any(|(_id, node)| {\n+                if let Node::Item(item) = node {\n+                    if let ItemKind::Fn(_, _, _) = item.kind {\n+                        // Note that we have sorted the item names in the visitor,\n+                        // so the binary_search gets the same as `contains`, but faster.\n+                        return names.binary_search(&item.ident.name).is_ok();\n+                    }\n                 }\n-            }\n-            None\n-        })\n-        .collect();\n-    let parent_mod = tcx.parent_module(id);\n-    let mut vis = VisitConstTestStruct {\n-        tcx,\n-        names,\n-        found: false,\n-    };\n-    tcx.hir().visit_item_likes_in_module(parent_mod, &mut vis);\n-    vis.found\n+                false\n+            })\n+    })\n }\n \n /// Checks whether item either has `test` attribute applied, or"}]}