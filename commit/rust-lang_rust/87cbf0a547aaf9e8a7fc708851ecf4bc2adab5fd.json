{"sha": "87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3Y2JmMGE1NDdhYWY5ZThhN2ZjNzA4ODUxZWNmNGJjMmFkYWI1ZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-01T18:23:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-01T18:23:04Z"}, "message": "Auto merge of #66021 - tmandry:rollup-y13l6n9, r=tmandry\n\nRollup of 16 pull requests\n\nSuccessful merges:\n\n - #65112 (Add lint and tests for unnecessary parens around types)\n - #65470 (Don't hide ICEs from previous incremental compiles)\n - #65471 (Add long error explanation for E0578)\n - #65857 (rustdoc: Resolve module-level doc references more locally)\n - #65902 (Make ItemContext available for better diagnositcs)\n - #65914 (Use structured suggestion for unnecessary bounds in type aliases)\n - #65946 (Make `promote_consts` emit the errors when required promotion fails)\n - #65960 (doc: reword iter module example and mention other methods)\n - #65963 (update submodules to rust-lang)\n - #65972 (Fix libunwind build: Define __LITTLE_ENDIAN__ for LE targets)\n - #65977 (Fix incorrect diagnostics for expected type in E0271 with an associated type)\n - #65995 (Add error code E0743 for \"C-variadic has been used on a non-foreign function\")\n - #65997 (Fix outdated rustdoc of Once::init_locking function)\n - #66002 (Stabilize float_to_from_bytes feature)\n - #66005 (vxWorks: remove code related unix socket)\n - #66018 (Revert PR 64324: dylibs export generics again (for now))\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f52aa9e4168a818b6c9cc208dda4db07baf91df7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f52aa9e4168a818b6c9cc208dda4db07baf91df7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "html_url": "https://github.com/rust-lang/rust/commit/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01e5d91482e3e8fb9f55efabab760db2d50ddaff", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e5d91482e3e8fb9f55efabab760db2d50ddaff", "html_url": "https://github.com/rust-lang/rust/commit/01e5d91482e3e8fb9f55efabab760db2d50ddaff"}, {"sha": "d6e35d1334bde4b425a4ed282afeb1fc7d58874d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e35d1334bde4b425a4ed282afeb1fc7d58874d", "html_url": "https://github.com/rust-lang/rust/commit/d6e35d1334bde4b425a4ed282afeb1fc7d58874d"}], "stats": {"total": 2901, "additions": 790, "deletions": 2111}, "files": [{"sha": "31db0772cfb6b3f789fde5073b823f3c74908998", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -3,13 +3,13 @@\n \turl = https://github.com/rust-lang/rust-installer.git\n [submodule \"src/doc/nomicon\"]\n \tpath = src/doc/nomicon\n-\turl = https://github.com/rust-lang-nursery/nomicon.git\n+\turl = https://github.com/rust-lang/nomicon.git\n [submodule \"src/tools/cargo\"]\n \tpath = src/tools/cargo\n \turl = https://github.com/rust-lang/cargo.git\n [submodule \"src/doc/reference\"]\n \tpath = src/doc/reference\n-\turl = https://github.com/rust-lang-nursery/reference.git\n+\turl = https://github.com/rust-lang/reference.git\n [submodule \"src/doc/book\"]\n \tpath = src/doc/book\n \turl = https://github.com/rust-lang/book.git\n@@ -36,7 +36,7 @@\n \turl = https://github.com/rust-lang/rustc-guide.git\n [submodule \"src/doc/edition-guide\"]\n \tpath = src/doc/edition-guide\n-\turl = https://github.com/rust-lang-nursery/edition-guide.git\n+\turl = https://github.com/rust-lang/edition-guide.git\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git"}, {"sha": "fac6ff0f06b6d86c750d2f680fa83e2fee29476a", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -118,26 +118,16 @@\n //!\n //! let mut counter = Counter::new();\n //!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n-//!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n-//!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n-//!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n-//!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n+//! assert_eq!(counter.next(), Some(1));\n+//! assert_eq!(counter.next(), Some(2));\n+//! assert_eq!(counter.next(), Some(3));\n+//! assert_eq!(counter.next(), Some(4));\n+//! assert_eq!(counter.next(), Some(5));\n+//! assert_eq!(counter.next(), None);\n //! ```\n //!\n-//! This will print `1` through `5`, each on their own line.\n-//!\n-//! Calling `next()` this way gets repetitive. Rust has a construct which can\n-//! call `next()` on your iterator, until it reaches `None`. Let's go over that\n+//! Calling [`next`] this way gets repetitive. Rust has a construct which can\n+//! call [`next`] on your iterator, until it reaches `None`. Let's go over that\n //! next.\n //!\n //! Also note that `Iterator` provides a default implementation of methods such as `nth` and `fold`\n@@ -253,20 +243,23 @@\n //! ```\n //!\n //! The idiomatic way to write a [`map`] for its side effects is to use a\n-//! `for` loop instead:\n+//! `for` loop or call the [`for_each`] method:\n //!\n //! ```\n //! let v = vec![1, 2, 3, 4, 5];\n //!\n+//! v.iter().for_each(|x| println!(\"{}\", x));\n+//! // or\n //! for x in &v {\n //!     println!(\"{}\", x);\n //! }\n //! ```\n //!\n //! [`map`]: trait.Iterator.html#method.map\n+//! [`for_each`]: trait.Iterator.html#method.for_each\n //!\n-//! The two most common ways to evaluate an iterator are to use a `for` loop\n-//! like this, or using the [`collect`] method to produce a new collection.\n+//! Another common way to evaluate an iterator is to use the [`collect`]\n+//! method to produce a new collection.\n //!\n //! [`collect`]: trait.Iterator.html#method.collect\n //!"}, {"sha": "5730088c4d9a95a9f21f48609074c677138385f6", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -466,11 +466,10 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f32.to_be_bytes();\n     /// assert_eq!(bytes, [0x41, 0x48, 0x00, 0x00]);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_be_bytes(self) -> [u8; 4] {\n         self.to_bits().to_be_bytes()\n@@ -482,11 +481,10 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f32.to_le_bytes();\n     /// assert_eq!(bytes, [0x00, 0x00, 0x48, 0x41]);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_le_bytes(self) -> [u8; 4] {\n         self.to_bits().to_le_bytes()\n@@ -504,7 +502,6 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f32.to_ne_bytes();\n     /// assert_eq!(\n     ///     bytes,\n@@ -515,7 +512,7 @@ impl f32 {\n     ///     }\n     /// );\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_ne_bytes(self) -> [u8; 4] {\n         self.to_bits().to_ne_bytes()\n@@ -526,11 +523,10 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f32::from_be_bytes([0x41, 0x48, 0x00, 0x00]);\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_be_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_be_bytes(bytes))\n@@ -541,11 +537,10 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f32::from_le_bytes([0x00, 0x00, 0x48, 0x41]);\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_le_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_le_bytes(bytes))\n@@ -563,15 +558,14 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f32::from_ne_bytes(if cfg!(target_endian = \"big\") {\n     ///     [0x41, 0x48, 0x00, 0x00]\n     /// } else {\n     ///     [0x00, 0x00, 0x48, 0x41]\n     /// });\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_ne_bytes(bytes))"}, {"sha": "2bdeda340dce01c19d7d60c2aaa08c1c5a6baaea", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -479,11 +479,10 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f64.to_be_bytes();\n     /// assert_eq!(bytes, [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_be_bytes(self) -> [u8; 8] {\n         self.to_bits().to_be_bytes()\n@@ -495,11 +494,10 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f64.to_le_bytes();\n     /// assert_eq!(bytes, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_le_bytes(self) -> [u8; 8] {\n         self.to_bits().to_le_bytes()\n@@ -517,7 +515,6 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f64.to_ne_bytes();\n     /// assert_eq!(\n     ///     bytes,\n@@ -528,7 +525,7 @@ impl f64 {\n     ///     }\n     /// );\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_ne_bytes(self) -> [u8; 8] {\n         self.to_bits().to_ne_bytes()\n@@ -539,11 +536,10 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f64::from_be_bytes([0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_be_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_be_bytes(bytes))\n@@ -554,11 +550,10 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f64::from_le_bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_le_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_le_bytes(bytes))\n@@ -576,15 +571,14 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f64::from_ne_bytes(if cfg!(target_endian = \"big\") {\n     ///     [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n     /// } else {\n     ///     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n     /// });\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_ne_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_ne_bytes(bytes))"}, {"sha": "e8f35f8cf245025925decf4771c869b8213923d6", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -5,7 +5,7 @@\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n-#[rustc_on_unimplemented(\n+#[cfg_attr(bootstrap, rustc_on_unimplemented(\n    on(all(\n        any(from_method=\"from_error\", from_method=\"from_ok\"),\n        from_desugaring=\"QuestionMark\"),\n@@ -17,7 +17,20 @@\n       message=\"the `?` operator can only be applied to values \\\n                that implement `{Try}`\",\n       label=\"the `?` operator cannot be applied to type `{Self}`\")\n-)]\n+))]\n+#[cfg_attr(not(bootstrap), rustc_on_unimplemented(\n+on(all(\n+any(from_method=\"from_error\", from_method=\"from_ok\"),\n+from_desugaring=\"QuestionMark\"),\n+message=\"the `?` operator can only be used in {ItemContext} \\\n+               that returns `Result` or `Option` \\\n+               (or another type that implements `{Try}`)\",\n+label=\"cannot use the `?` operator in {ItemContext} that returns `{Self}`\"),\n+on(all(from_method=\"into_result\", from_desugaring=\"QuestionMark\"),\n+message=\"the `?` operator can only be applied to values \\\n+               that implement `{Try}`\",\n+label=\"the `?` operator cannot be applied to type `{Self}`\")\n+))]\n #[doc(alias = \"?\")]\n pub trait Try {\n     /// The type of this value when viewed as successful."}, {"sha": "f4751e591bf3ce65984531014a7df239a0a133eb", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         &self,\n         arg: &'tcx hir::Ty,\n         br: &ty::BoundRegion,\n-    ) -> Option<(&'tcx hir::Ty)> {\n+    ) -> Option<&'tcx hir::Ty> {\n         let mut nested_visitor = FindNestedTypeVisitor {\n             tcx: self.tcx(),\n             bound_region: *br,"}, {"sha": "81f0853201c08b5f5afba7b9b6f5ad9e9115a4f6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -312,6 +312,9 @@ impl Session {\n     pub fn has_errors(&self) -> bool {\n         self.diagnostic().has_errors()\n     }\n+    pub fn has_errors_or_delayed_span_bugs(&self) -> bool {\n+        self.diagnostic().has_errors_or_delayed_span_bugs()\n+    }\n     pub fn abort_if_errors(&self) {\n         self.diagnostic().abort_if_errors();\n     }"}, {"sha": "1f7bce1c644c51ab5c0cfed709ed6aff3eda5480", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -226,13 +226,26 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     0,\n                     &mut obligations\n                 );\n+\n+                debug!(\"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n+                       obligation.cause, obligation.param_env);\n+\n+                debug!(\"report_projection_error normalized_ty={:?} data.ty={:?}\",\n+                       normalized_ty, data.ty);\n+\n+                let is_normalized_ty_expected = match &obligation.cause.code {\n+                    ObligationCauseCode::ItemObligation(_) |\n+                    ObligationCauseCode::BindingObligation(_, _) |\n+                    ObligationCauseCode::ObjectCastObligation(_) => false,\n+                    _ => true,\n+                };\n+\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env)\n-                    .eq(normalized_ty, data.ty)\n+                    .eq_exp(is_normalized_ty_expected, normalized_ty, data.ty)\n                 {\n-                    values = Some(infer::ValuePairs::Types(ExpectedFound {\n-                        expected: normalized_ty,\n-                        found: data.ty,\n-                    }));\n+                    values = Some(infer::ValuePairs::Types(\n+                        ExpectedFound::new(is_normalized_ty_expected, normalized_ty, data.ty)));\n+\n                     err_buf = error;\n                     err = &err_buf;\n                 }\n@@ -353,6 +366,52 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n+        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| {\n+            match gen_kind {\n+                hir::GeneratorKind::Gen => \"a generator\",\n+                hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n+                hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n+                hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n+            }\n+        })\n+    }\n+\n+    /// Used to set on_unimplemented's `ItemContext`\n+    /// to be the enclosing (async) block/function/closure\n+    fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str> {\n+        let hir = &self.tcx.hir();\n+        let node = hir.find(hir_id)?;\n+        if let hir::Node::Item(\n+            hir::Item{kind: hir::ItemKind::Fn(_ ,fn_header ,_ , body_id), .. }) = &node {\n+            self.describe_generator(*body_id).or_else(||\n+                Some(if let hir::FnHeader{ asyncness: hir::IsAsync::Async, .. } = fn_header {\n+                    \"an async function\"\n+                } else {\n+                    \"a function\"\n+                })\n+            )\n+        } else if let hir::Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::Closure(_is_move, _, body_id, _, gen_movability), .. }) = &node {\n+            self.describe_generator(*body_id).or_else(||\n+                Some(if gen_movability.is_some() {\n+                    \"an async closure\"\n+                } else {\n+                    \"a closure\"\n+                })\n+            )\n+        } else if let hir::Node::Expr(hir::Expr { .. }) = &node {\n+            let parent_hid = hir.get_parent_node(hir_id);\n+            if parent_hid != hir_id {\n+                return self.describe_enclosure(parent_hid);\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn on_unimplemented_note(\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -363,6 +422,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let trait_ref = *trait_ref.skip_binder();\n \n         let mut flags = vec![];\n+        flags.push((sym::item_context,\n+            self.describe_enclosure(obligation.cause.body_id).map(|s|s.to_owned())));\n+\n         match obligation.cause.code {\n             ObligationCauseCode::BuiltinDerivedObligation(..) |\n             ObligationCauseCode::ImplDerivedObligation(..) => {}"}, {"sha": "b39c00a56e349ad13c5933b9f6e55c9f69d1b176", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -248,6 +248,8 @@ impl<'tcx> OnUnimplementedFormatString {\n                     Position::ArgumentNamed(s) if s == sym::from_method => (),\n                     // `{from_desugaring}` is allowed\n                     Position::ArgumentNamed(s) if s == sym::from_desugaring => (),\n+                    // `{ItemContext}` is allowed\n+                    Position::ArgumentNamed(s) if s == sym::item_context => (),\n                     // So is `{A}` if A is a type parameter\n                     Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n                         param.name == s\n@@ -296,6 +298,7 @@ impl<'tcx> OnUnimplementedFormatString {\n \n         let s = self.0.as_str();\n         let parser = Parser::new(&s, None, vec![], false);\n+        let item_context = (options.get(&sym::item_context)).unwrap_or(&empty_string);\n         parser.map(|p|\n             match p {\n                 Piece::String(s) => s,\n@@ -311,6 +314,8 @@ impl<'tcx> OnUnimplementedFormatString {\n                             } else if s == sym::from_desugaring || s == sym::from_method {\n                                 // don't break messages using these two arguments incorrectly\n                                 &empty_string\n+                            } else if s == sym::item_context {\n+                                &item_context\n                             } else {\n                                 bug!(\"broken on_unimplemented {:?} for {:?}: \\\n                                       no argument matching {:?}\","}, {"sha": "3d28beefb3413f0dea2b38ed691f6ac822ca92d5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1514,8 +1514,14 @@ impl<'tcx> TyCtxt<'tcx> {\n                 CrateType::Executable |\n                 CrateType::Staticlib  |\n                 CrateType::ProcMacro  |\n-                CrateType::Dylib      |\n                 CrateType::Cdylib     => false,\n+\n+                // FIXME rust-lang/rust#64319, rust-lang/rust#64872:\n+                // We want to block export of generics from dylibs,\n+                // but we must fix rust-lang/rust#65890 before we can\n+                // do that robustly.\n+                CrateType::Dylib      => true,\n+\n                 CrateType::Rlib       => true,\n             }\n         })"}, {"sha": "999cc406585030253ae30ac0efde7e465d645667", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -14,7 +14,6 @@ use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, OptLevel, DebugInfo,\n                              LinkerPluginLto, Lto};\n-use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::ty::TyCtxt;\n use rustc_target::spec::{LinkerFlavor, LldFlavor};\n use rustc_serialize::{json, Encoder};\n@@ -1112,20 +1111,10 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n                     continue;\n                 }\n \n-                // Do not export generic symbols from upstream crates in linked\n-                // artifact (notably the `dylib` crate type). The main reason\n-                // for this is that `symbol_name` is actually wrong for generic\n-                // symbols because it guesses the name we'd give them locally\n-                // rather than the name it has upstream (depending on\n-                // `share_generics` settings and such).\n-                //\n-                // To fix that issue we just say that linked artifacts, aka\n-                // `dylib`s, never export generic symbols and they aren't\n-                // available to downstream crates. (the not available part is\n-                // handled elsewhere).\n-                if let ExportedSymbol::Generic(..) = symbol {\n-                    continue;\n-                }\n+                // FIXME rust-lang/rust#64319, rust-lang/rust#64872:\n+                // We want to block export of generics from dylibs,\n+                // but we must fix rust-lang/rust#65890 before we can\n+                // do that robustly.\n \n                 symbols.push(symbol.symbol_name(tcx).to_string());\n             }"}, {"sha": "0213eb4f2a2a4027f281f067ea6fbe8a601a1331", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1046,14 +1046,14 @@ unsafe impl<O, T: ?Sized> CloneStableAddress for OwningRef<O, T>\n     where O: CloneStableAddress {}\n \n unsafe impl<O, T: ?Sized> Send for OwningRef<O, T>\n-    where O: Send, for<'a> (&'a T): Send {}\n+    where O: Send, for<'a> &'a T: Send {}\n unsafe impl<O, T: ?Sized> Sync for OwningRef<O, T>\n-    where O: Sync, for<'a> (&'a T): Sync {}\n+    where O: Sync, for<'a> &'a T: Sync {}\n \n unsafe impl<O, T: ?Sized> Send for OwningRefMut<O, T>\n-    where O: Send, for<'a> (&'a mut T): Send {}\n+    where O: Send, for<'a> &'a mut T: Send {}\n unsafe impl<O, T: ?Sized> Sync for OwningRefMut<O, T>\n-    where O: Sync, for<'a> (&'a mut T): Sync {}\n+    where O: Sync, for<'a> &'a mut T: Sync {}\n \n impl Debug for dyn Erased {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "6a19f52897e5de97d976aaae88e5b954060b81f5", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -492,10 +492,10 @@ impl<T> Once<T> {\n         assert!(self.try_set(value).is_none());\n     }\n \n-    /// Tries to initialize the inner value by calling the closure while ensuring that no-one else\n-    /// can access the value in the mean time by holding a lock for the duration of the closure.\n-    /// If the value was already initialized the closure is not called and `false` is returned,\n-    /// otherwise if the value from the closure initializes the inner value, `true` is returned\n+    /// Initializes the inner value if it wasn't already done by calling the provided closure. It\n+    /// ensures that no-one else can access the value in the mean time by holding a lock for the\n+    /// duration of the closure.\n+    /// A reference to the inner value is returned.\n     #[inline]\n     pub fn init_locking<F: FnOnce() -> T>(&self, f: F) -> &T {\n         {"}, {"sha": "9743cf0d805a3eac513bc6568ad62c7997c0a996", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -704,6 +704,9 @@ impl Handler {\n     pub fn has_errors(&self) -> bool {\n         self.inner.borrow().has_errors()\n     }\n+    pub fn has_errors_or_delayed_span_bugs(&self) -> bool {\n+        self.inner.borrow().has_errors_or_delayed_span_bugs()\n+    }\n \n     pub fn print_error_count(&self, registry: &Registry) {\n         self.inner.borrow_mut().print_error_count(registry)\n@@ -862,6 +865,9 @@ impl HandlerInner {\n     fn has_errors(&self) -> bool {\n         self.err_count() > 0\n     }\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool {\n+        self.has_errors() || !self.delayed_span_bugs.is_empty()\n+    }\n \n     fn abort_if_errors_and_should_abort(&mut self) {\n         self.emit_stashed_diagnostics();"}, {"sha": "cbebdeb602cc0b1101a8ebf36c1f36a4abd90f96", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -307,7 +307,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n \n     let incr_comp_session_dir: PathBuf = sess.incr_comp_session_dir().clone();\n \n-    if sess.has_errors() {\n+    if sess.has_errors_or_delayed_span_bugs() {\n         // If there have been any errors during compilation, we don't want to\n         // publish this session directory. Rather, we'll just delete it.\n "}, {"sha": "ecc66e60175f0c4c091c015bdcbad650d3b4362c", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -22,6 +22,10 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n         if sess.opts.incremental.is_none() {\n             return;\n         }\n+        // This is going to be deleted in finalize_session_directory, so let's not create it\n+        if sess.has_errors_or_delayed_span_bugs() {\n+            return;\n+        }\n \n         let query_cache_path = query_cache_path(sess);\n         let dep_graph_path = dep_graph_path(sess);\n@@ -60,6 +64,10 @@ pub fn save_work_product_index(sess: &Session,\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n+    // This is going to be deleted in finalize_session_directory, so let's not create it\n+    if sess.has_errors_or_delayed_span_bugs() {\n+            return;\n+    }\n \n     debug!(\"save_work_product_index()\");\n     dep_graph.assert_ignored();"}, {"sha": "e3c3966c2f5e0e39e47ddf190904d9c632280b92", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1125,8 +1125,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n                 .map(|pred| pred.span()).collect();\n             let mut err = cx.struct_span_lint(TYPE_ALIAS_BOUNDS, spans,\n                 \"where clauses are not enforced in type aliases\");\n-            err.help(\"the clause will not be checked when the type alias is used, \\\n-                      and should be removed\");\n+            err.span_suggestion(\n+                type_alias_generics.where_clause.span_for_predicates_or_empty_place(),\n+                \"the clause will not be checked when the type alias is used, and should be removed\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n             if !suggested_changing_assoc_types {\n                 TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n                 suggested_changing_assoc_types = true;\n@@ -1136,14 +1140,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n         // The parameters must not have bounds\n         for param in type_alias_generics.params.iter() {\n             let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n+            let suggestion = spans.iter().map(|sp| {\n+                let start = param.span.between(*sp); // Include the `:` in `T: Bound`.\n+                (start.to(*sp), String::new())\n+            }).collect();\n             if !spans.is_empty() {\n                 let mut err = cx.struct_span_lint(\n                     TYPE_ALIAS_BOUNDS,\n                     spans,\n                     \"bounds on generic parameters are not enforced in type aliases\",\n                 );\n-                err.help(\"the bound will not be checked when the type alias is used, \\\n-                          and should be removed\");\n+                let msg = \"the bound will not be checked when the type alias is used, \\\n+                           and should be removed\";\n+                err.multipart_suggestion(&msg, suggestion, Applicability::MachineApplicable);\n                 if !suggested_changing_assoc_types {\n                     TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n                     suggested_changing_assoc_types = true;"}, {"sha": "af43030d0f2aecf9e5038f4385d0995aded2e424", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -598,6 +598,25 @@ impl EarlyLintPass for UnusedParens {\n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n         self.check_unused_parens_pat(cx, &arm.pat, false, false);\n     }\n+\n+    fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {\n+        if let &ast::TyKind::Paren(ref r) = &ty.kind {\n+            match &r.kind {\n+                &ast::TyKind::TraitObject(..) => {}\n+                &ast::TyKind::ImplTrait(_, ref bounds) if bounds.len() > 1 => {}\n+                _ => {\n+                    let pattern_text = if let Ok(snippet) = cx.sess().source_map()\n+                        .span_to_snippet(ty.span) {\n+                            snippet\n+                        } else {\n+                            pprust::ty_to_string(ty)\n+                        };\n+\n+                    Self::remove_outer_parens(cx, ty.span, &pattern_text, \"type\", (false, false));\n+                }\n+            }\n+        }\n+    }\n }\n \n declare_lint! {"}, {"sha": "de187a3f5e0dcbd9352b4f922df3a23bb468384b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -9,7 +9,6 @@ use rustc::ty::query::QueryConfig;\n use rustc::middle::cstore::{CrateSource, CrateStore, DepKind, EncodedMetadata, NativeLibraryKind};\n use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::middle::stability::DeprecationEntry;\n-use rustc::middle::dependency_format::Linkage;\n use rustc::hir::def;\n use rustc::hir;\n use rustc::session::{CrateDisambiguator, Session};\n@@ -235,26 +234,11 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     used_crate_source => { Lrc::new(cdata.source.clone()) }\n \n     exported_symbols => {\n-        let mut syms = cdata.exported_symbols(tcx);\n-\n-        // When linked into a dylib crates don't export their generic symbols,\n-        // so if that's happening then we can't load upstream monomorphizations\n-        // from this crate.\n-        let formats = tcx.dependency_formats(LOCAL_CRATE);\n-        let remove_generics = formats.iter().any(|(_ty, list)| {\n-            match list.get(def_id.krate.as_usize() - 1) {\n-                Some(Linkage::IncludedFromDylib) | Some(Linkage::Dynamic) => true,\n-                _ => false,\n-            }\n-        });\n-        if remove_generics {\n-            syms.retain(|(sym, _threshold)| {\n-                match sym {\n-                    ExportedSymbol::Generic(..) => false,\n-                    _ => return true,\n-                }\n-            });\n-        }\n+        let syms = cdata.exported_symbols(tcx);\n+\n+        // FIXME rust-lang/rust#64319, rust-lang/rust#64872: We want\n+        // to block export of generics from dylibs, but we must fix\n+        // rust-lang/rust#65890 before we can do that robustly.\n \n         Arc::new(syms)\n     }"}, {"sha": "1be1fcef61b6e4024ff2cf4af9780dca59cb02bd", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -29,7 +29,7 @@ pub(super) struct Prefixes<'cx, 'tcx> {\n     body: &'cx Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     kind: PrefixSet,\n-    next: Option<(PlaceRef<'cx, 'tcx>)>,\n+    next: Option<PlaceRef<'cx, 'tcx>>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "c119ca536fb524fee9de6768b63fa7d83e3c8786", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -2545,7 +2545,7 @@ There are some known bugs that trigger this message.\n //  E0471, // constant evaluation error (in pattern)\n //  E0385, // {} in an aliasable location\n     E0521, // borrowed data escapes outside of closure\n-    E0526, // shuffle indices are not constant\n+//  E0526, // shuffle indices are not constant\n     E0594, // cannot assign to {}\n //  E0598, // lifetime of {} is too short to guarantee its contents can be...\n     E0625, // thread-local statics cannot be accessed at compile-time"}, {"sha": "83f3aafc55cb10cc8547a0f5a1430db7c47c79bc", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -80,6 +80,17 @@ pub enum Candidate {\n     Argument { bb: BasicBlock, index: usize },\n }\n \n+impl Candidate {\n+    /// Returns `true` if we should use the \"explicit\" rules for promotability for this `Candidate`.\n+    fn forces_explicit_promotion(&self) -> bool {\n+        match self {\n+            Candidate::Ref(_) |\n+            Candidate::Repeat(_) => false,\n+            Candidate::Argument { .. } => true,\n+        }\n+    }\n+}\n+\n fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n     let attrs = tcx.get_attrs(def_id);\n     let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n@@ -727,16 +738,22 @@ pub fn validate_candidates(\n     };\n \n     candidates.iter().copied().filter(|&candidate| {\n-        validator.explicit = match candidate {\n-            Candidate::Ref(_) |\n-            Candidate::Repeat(_) => false,\n-            Candidate::Argument { .. } => true,\n-        };\n+        validator.explicit = candidate.forces_explicit_promotion();\n \n         // FIXME(eddyb) also emit the errors for shuffle indices\n         // and `#[rustc_args_required_const]` arguments here.\n \n-        validator.validate_candidate(candidate).is_ok()\n+        let is_promotable = validator.validate_candidate(candidate).is_ok();\n+        match candidate {\n+            Candidate::Argument { bb, index } if !is_promotable => {\n+                let span = body[bb].terminator().source_info.span;\n+                let msg = format!(\"argument {} is required to be a constant\", index + 1);\n+                tcx.sess.span_err(span, &msg);\n+            }\n+            _ => ()\n+        }\n+\n+        is_promotable\n     }).collect()\n }\n "}, {"sha": "f488b457334e5bc43ec3f5c8522dcfbb54c75edd", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1606,20 +1606,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     // This is not a problem, because the argument explicitly\n                     // requests constness, in contrast to regular promotion\n                     // which happens even without the user requesting it.\n-                    // We can error out with a hard error if the argument is not\n-                    // constant here.\n+                    //\n+                    // `promote_consts` is responsible for emitting the error if\n+                    // the argument is not promotable.\n                     if !IsNotPromotable::in_operand(self, arg) {\n                         debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n                         self.promotion_candidates.push(candidate);\n-                    } else {\n-                        if is_shuffle {\n-                            span_err!(self.tcx.sess, self.span, E0526,\n-                                      \"shuffle indices are not constant\");\n-                        } else {\n-                            self.tcx.sess.span_err(self.span,\n-                                &format!(\"argument {} is required to be a constant\",\n-                                         i + 1));\n-                        }\n                     }\n                 }\n             }"}, {"sha": "c59959ae4f4c541c2f7f2eafcb786d076afbba45", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1850,6 +1850,34 @@ fn main() {}\n ```\n \"##,\n \n+E0578: r##\"\n+A module cannot be found and therefore, the visibility cannot be determined.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0578,edition2018\n+foo!();\n+\n+pub (in ::Sea) struct Shark; // error!\n+\n+fn main() {}\n+```\n+\n+Because of the call to the `foo` macro, the compiler guesses that the missing\n+module could be inside it and fails because the macro definition cannot be\n+found.\n+\n+To fix this error, please be sure that the module is in scope:\n+\n+```edition2018\n+pub mod Sea {\n+    pub (in crate::Sea) struct Shark;\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n E0603: r##\"\n A private item was used outside its scope.\n \n@@ -2017,5 +2045,4 @@ fn main() {}\n //  E0427, merged into 530\n //  E0467, removed\n //  E0470, removed\n-    E0578,\n }"}, {"sha": "ab34f8daad7197bd1d64ba1573e8a3a68c76863f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -322,9 +322,26 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     continue;\n                 }\n \n+                // In order to correctly resolve intra-doc-links we need to\n+                // pick a base AST node to work from.  If the documentation for\n+                // this module came from an inner comment (//!) then we anchor\n+                // our name resolution *inside* the module.  If, on the other\n+                // hand it was an outer comment (///) then we anchor the name\n+                // resolution in the parent module on the basis that the names\n+                // used are more likely to be intended to be parent names.  For\n+                // this, we set base_node to None for inner comments since\n+                // we've already pushed this node onto the resolution stack but\n+                // for outer comments we explicitly try and resolve against the\n+                // parent_node first.\n+                let base_node = if item.is_mod() && item.attrs.inner_docs {\n+                    None\n+                } else {\n+                    parent_node\n+                };\n+\n                 match kind {\n                     Some(ns @ ValueNS) => {\n-                        if let Ok(res) = self.resolve(path_str, ns, &current_item, parent_node) {\n+                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node) {\n                             res\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -335,7 +352,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(ns @ TypeNS) => {\n-                        if let Ok(res) = self.resolve(path_str, ns, &current_item, parent_node) {\n+                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node) {\n                             res\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -348,10 +365,10 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         let candidates = PerNS {\n                             macro_ns: macro_resolve(cx, path_str).map(|res| (res, None)),\n                             type_ns: self\n-                                .resolve(path_str, TypeNS, &current_item, parent_node)\n+                                .resolve(path_str, TypeNS, &current_item, base_node)\n                                 .ok(),\n                             value_ns: self\n-                                .resolve(path_str, ValueNS, &current_item, parent_node)\n+                                .resolve(path_str, ValueNS, &current_item, base_node)\n                                 .ok()\n                                 .and_then(|(res, fragment)| {\n                                     // Constructors are picked up in the type namespace."}, {"sha": "de2f12c9f33efa83e6cf73e9a14581592bea1473", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1818,7 +1818,7 @@ impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     #[inline]\n-    fn next(&mut self) -> Option<(&'a K)> {\n+    fn next(&mut self) -> Option<&'a K> {\n         self.inner.next().map(|(k, _)| k)\n     }\n     #[inline]\n@@ -1841,7 +1841,7 @@ impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     #[inline]\n-    fn next(&mut self) -> Option<(&'a V)> {\n+    fn next(&mut self) -> Option<&'a V> {\n         self.inner.next().map(|(_, v)| v)\n     }\n     #[inline]\n@@ -1864,7 +1864,7 @@ impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n     type Item = &'a mut V;\n \n     #[inline]\n-    fn next(&mut self) -> Option<(&'a mut V)> {\n+    fn next(&mut self) -> Option<&'a mut V> {\n         self.inner.next().map(|(_, v)| v)\n     }\n     #[inline]"}, {"sha": "df6255a3e9e03306cedd55ff9d636e663b4d76e7", "filename": "src/libstd/sys/vxworks/ext/io.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -6,7 +6,8 @@ use crate::fs;\n use crate::os::raw;\n use crate::sys;\n use crate::io;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+use crate::net;\n \n /// Raw file descriptors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -110,3 +111,61 @@ impl<'a> AsRawFd for io::StdoutLock<'a> {\n impl<'a> AsRawFd for io::StderrLock<'a> {\n     fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::UdpSocket {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::UdpSocket {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}"}, {"sha": "d0f467b303ff93615a0dfecf78fd816093e7bb69", "filename": "src/libstd/sys/vxworks/ext/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1,4 +1,3 @@\n-// Uhhh\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n@@ -7,7 +6,6 @@ pub mod ffi;\n pub mod fs;\n pub mod raw;\n pub mod process;\n-pub mod net;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {"}, {"sha": "3f0a7e9e843199d9999bab826edce6e00a2da9a1", "filename": "src/libstd/sys/vxworks/ext/net.rs", "status": "removed", "additions": 0, "deletions": 1825, "changes": 1825, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -1,1825 +0,0 @@\n-#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-\n-//! Unix-specific networking functionality\n-\n-#[cfg(unix)]\n-use libc;\n-\n-use crate::ascii;\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n-use crate::mem;\n-use crate::net::{self, Shutdown};\n-use crate::os::unix::ffi::OsStrExt;\n-use crate::os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-use crate::path::Path;\n-use crate::time::Duration;\n-use crate::sys::{self, cvt};\n-use crate::sys::net::Socket;\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n-\n-const MSG_NOSIGNAL: libc::c_int = 0x0;\n-\n-fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n-    // Work with an actual instance of the type since using a null pointer is UB\n-    let base = addr as *const _ as usize;\n-    let path = &addr.sun_path as *const _ as usize;\n-    path - base\n-}\n-\n-unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n-    let mut addr: libc::sockaddr_un = mem::zeroed();\n-    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-\n-    let bytes = path.as_os_str().as_bytes();\n-\n-    if bytes.contains(&0) {\n-        return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                  \"paths may not contain interior null bytes\"));\n-    }\n-\n-    if bytes.len() >= addr.sun_path.len() {\n-        return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                  \"path must be shorter than SUN_LEN\"));\n-    }\n-    for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n-        *dst = *src as libc::c_char;\n-    }\n-    // null byte for pathname addresses is already there because we zeroed the\n-    // struct\n-\n-    let mut len = sun_path_offset(&addr) + bytes.len();\n-    match bytes.get(0) {\n-        Some(&0) | None => {}\n-        Some(_) => len += 1,\n-    }\n-    Ok((addr, len as libc::socklen_t))\n-}\n-\n-enum AddressKind<'a> {\n-    Unnamed,\n-    Pathname(&'a Path),\n-    Abstract(&'a [u8]),\n-}\n-\n-/// An address associated with a Unix socket.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::os::unix::net::UnixListener;\n-///\n-/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n-///     Ok(sock) => sock,\n-///     Err(e) => {\n-///         println!(\"Couldn't bind: {:?}\", e);\n-///         return\n-///     }\n-/// };\n-/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct SocketAddr {\n-    addr: libc::sockaddr_un,\n-    len: libc::socklen_t,\n-}\n-\n-impl SocketAddr {\n-    fn new<F>(f: F) -> io::Result<SocketAddr>\n-        where F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int\n-    {\n-        unsafe {\n-            let mut addr: libc::sockaddr_un = mem::zeroed();\n-            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n-            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n-            SocketAddr::from_parts(addr, len)\n-        }\n-    }\n-\n-    fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t) -> io::Result<SocketAddr> {\n-        if len == 0 {\n-            // When there is a datagram from unnamed unix socket\n-            // linux returns zero bytes of address\n-            len = sun_path_offset(&addr) as libc::socklen_t;  // i.e., zero-length address\n-        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"file descriptor did not correspond to a Unix socket\"));\n-        }\n-\n-        Ok(SocketAddr {\n-            addr,\n-            len,\n-        })\n-    }\n-\n-    /// Returns `true` if the address is unnamed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// A named address:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), false);\n-    /// ```\n-    ///\n-    /// An unnamed address:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), true);\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn is_unnamed(&self) -> bool {\n-        if let AddressKind::Unnamed = self.address() {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Returns the contents of this address if it is a `pathname` address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// With a pathname:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    /// use std::path::Path;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n-    /// ```\n-    ///\n-    /// Without a pathname:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), None);\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        if let AddressKind::Pathname(path) = self.address() {\n-            Some(path)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn address<'a>(&'a self) -> AddressKind<'a> {\n-        let len = self.len as usize - sun_path_offset(&self.addr);\n-        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n-\n-        if self.addr.sun_path[0] == 0 {\n-            AddressKind::Abstract(&path[1..len])\n-        } else {\n-            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.address() {\n-            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n-            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n-            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n-        }\n-    }\n-}\n-\n-struct AsciiEscaped<'a>(&'a [u8]);\n-\n-impl<'a> fmt::Display for AsciiEscaped<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"\\\"\")?;\n-        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n-            write!(fmt, \"{}\", byte as char)?;\n-        }\n-        write!(fmt, \"\\\"\")\n-    }\n-}\n-\n-/// A Unix stream socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixStream;\n-/// use std::io::prelude::*;\n-///\n-/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n-/// stream.write_all(b\"hello world\").unwrap();\n-/// let mut response = String::new();\n-/// stream.read_to_string(&mut response).unwrap();\n-/// println!(\"{}\", response);\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixStream(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixStream\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixStream {\n-    /// Connects to the socket named by `path`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-        fn inner(path: &Path) -> io::Result<UnixStream> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n-                Ok(UnixStream(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixStream`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let (sock1, sock2) = match UnixStream::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-        Ok((UnixStream(i1), UnixStream(i2)))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixStream` is a reference to the same stream that this\n-    /// object references. Both handles will read and write the same stream of\n-    /// data, and options set on one stream will be propagated to the other\n-    /// stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.duplicate().map(UnixStream)\n-    }\n-\n-    /// Returns the socket address of the local half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Returns the socket address of the remote half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n-    /// passed to this method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::net::UdpSocket;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n-    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// if let Ok(Some(err)) = socket.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shuts down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Read for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        io::Read::read(&mut &*self, buf)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        io::Read::read_vectored(&mut &*self, bufs)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Write for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        io::Write::write(&mut &*self, buf)\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        io::Write::write_vectored(&mut &*self, bufs)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        io::Write::flush(&mut &*self)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::UdpSocket {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::UdpSocket {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-\n-/// A structure representing a Unix domain socket server.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// // accept connections and process them, spawning a new thread for each one\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             /* connection succeeded */\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             /* connection failed */\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixListener(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixListener\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixListener {\n-    /// Creates a new `UnixListener` bound to the specified socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n-        fn inner(path: &Path) -> io::Result<UnixListener> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n-                cvt(libc::listen(*inner.as_inner(), 128))?;\n-\n-                Ok(UnixListener(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Accepts a new incoming connection to this listener.\n-    ///\n-    /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corresponding [`UnixStream`] and\n-    /// the remote peer's address will be returned.\n-    ///\n-    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// match listener.accept() {\n-    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n-    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n-        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n-        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n-        let addr = SocketAddr::from_parts(storage, len)?;\n-        Ok((UnixStream(sock), addr))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.duplicate().map(UnixListener)\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    ///\n-    /// if let Ok(Some(err)) = listener.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Returns an iterator over incoming connections.\n-    ///\n-    /// The iterator will never return [`None`] and will also not yield the\n-    /// peer's [`SocketAddr`] structure.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`SocketAddr`]: struct.SocketAddr.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::thread;\n-    /// use std::os::unix::net::{UnixStream, UnixListener};\n-    ///\n-    /// fn handle_client(stream: UnixStream) {\n-    ///     // ...\n-    /// }\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// for stream in listener.incoming() {\n-    ///     match stream {\n-    ///         Ok(stream) => {\n-    ///             thread::spawn(|| handle_client(stream));\n-    ///         }\n-    ///         Err(err) => {\n-    ///             break;\n-    ///         }\n-    ///     }\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n-        Incoming { listener: self }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> IntoIterator for &'a UnixListener {\n-    type Item = io::Result<UnixStream>;\n-    type IntoIter = Incoming<'a>;\n-\n-    fn into_iter(self) -> Incoming<'a> {\n-        self.incoming()\n-    }\n-}\n-\n-/// An iterator over incoming connections to a [`UnixListener`].\n-///\n-/// It will never return [`None`].\n-///\n-/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-/// [`UnixListener`]: struct.UnixListener.html\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct Incoming<'a> {\n-    listener: &'a UnixListener,\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> Iterator for Incoming<'a> {\n-    type Item = io::Result<UnixStream>;\n-\n-    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n-        Some(self.listener.accept().map(|s| s.0))\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::max_value(), None)\n-    }\n-}\n-\n-/// A Unix datagram socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixDatagram;\n-///\n-/// let socket = UnixDatagram::bind(\"/path/to/my/socket\").unwrap();\n-/// socket.send_to(b\"hello world\", \"/path/to/other/socket\").unwrap();\n-/// let mut buf = [0; 100];\n-/// let (count, address) = socket.recv_from(&mut buf).unwrap();\n-/// println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixDatagram(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixDatagram {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixDatagram\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixDatagram {\n-    /// Creates a Unix datagram socket bound to the given path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't bind: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n-        fn inner(path: &Path) -> io::Result<UnixDatagram> {\n-            unsafe {\n-                let socket = UnixDatagram::unbound()?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len as _))?;\n-\n-                Ok(socket)\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Creates a Unix Datagram socket which is not bound to any address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = match UnixDatagram::unbound() {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't unbound: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn unbound() -> io::Result<UnixDatagram> {\n-        let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n-        Ok(UnixDatagram(inner))\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixDatagrams`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let (sock1, sock2) = match UnixDatagram::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't unbound: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n-        Ok((UnixDatagram(i1), UnixDatagram(i2)))\n-    }\n-\n-    /// Connects the socket to the specified address.\n-    ///\n-    /// The [`send`] method may be used to send data to the specified address.\n-    /// [`recv`] and [`recv_from`] will only receive data from that address.\n-    ///\n-    /// [`send`]: #method.send\n-    /// [`recv`]: #method.recv\n-    /// [`recv_from`]: #method.recv_from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// match sock.connect(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n-        fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n-            unsafe {\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::connect(*d.0.as_inner(), &addr as *const _ as *const _, len))?;\n-\n-                Ok(())\n-            }\n-        }\n-        inner(self, path.as_ref())\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixDatagram` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one side will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n-        self.0.duplicate().map(UnixDatagram)\n-    }\n-\n-    /// Returns the address of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = sock.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Returns the address of this socket's peer.\n-    ///\n-    /// The [`connect`] method will connect the socket to a peer.\n-    ///\n-    /// [`connect`]: #method.connect\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.connect(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Receives data from the socket.\n-    ///\n-    /// On success, returns the number of bytes read and the address from\n-    /// whence the data came.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// let mut buf = vec![0; 10];\n-    /// match sock.recv_from(buf.as_mut_slice()) {\n-    ///     Ok((size, sender)) => println!(\"received {} bytes from {:?}\", size, sender),\n-    ///     Err(e) => println!(\"recv_from function failed: {:?}\", e),\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        let mut count = 0;\n-        let addr = SocketAddr::new(|addr, len| {\n-            unsafe {\n-                count = libc::recvfrom(*self.0.as_inner(),\n-                                       buf.as_mut_ptr() as *mut _,\n-                                       buf.len(),\n-                                       0,\n-                                       addr,\n-                                       len);\n-                if count > 0 {\n-                    1\n-                } else if count == 0 {\n-                    0\n-                } else {\n-                    -1\n-                }\n-            }\n-        })?;\n-\n-        Ok((count as usize, addr))\n-    }\n-\n-    /// Receives data from the socket.\n-    ///\n-    /// On success, returns the number of bytes read.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n-    /// let mut buf = vec![0; 10];\n-    /// sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    /// Sends data on the socket to the specified address.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n-        fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n-            unsafe {\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                let count = cvt(libc::sendto(*d.0.as_inner(),\n-                                             buf.as_ptr() as *const _,\n-                                             buf.len(),\n-                                             MSG_NOSIGNAL,\n-                                             &addr as *const _ as *const _,\n-                                             len))?;\n-                Ok(count as usize)\n-            }\n-        }\n-        inner(self, buf, path.as_ref())\n-    }\n-\n-    /// Sends data on the socket to the socket's peer.\n-    ///\n-    /// The peer address may be set by the `connect` method, and this method\n-    /// will return an error if the socket has not already been connected.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n-    /// sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will\n-    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]\n-    /// is passed to this method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`recv`]: #method.recv\n-    /// [`recv_from`]: #method.recv_from\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will\n-    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`send`]: #method.send\n-    /// [`send_to`]: #method.send_to\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///     .expect(\"set_write_timeout function failed\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n-    /// assert_eq!(sock.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///     .expect(\"set_write_timeout function failed\");\n-    /// assert_eq!(sock.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// if let Ok(Some(err)) = sock.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shut down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// let sock = UnixDatagram::unbound().unwrap();\n-    /// sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixDatagram {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixDatagram {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n-        UnixDatagram(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixDatagram {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod test {\n-    use crate::thread;\n-    use crate::io::{self, ErrorKind};\n-    use crate::io::prelude::*;\n-    use crate::time::Duration;\n-    use crate::sys_common::io::test::tmpdir;\n-\n-    use super::*;\n-\n-    macro_rules! or_panic {\n-        ($e:expr) => {\n-            match $e {\n-                Ok(e) => e,\n-                Err(e) => panic!(\"{}\", e),\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn basic() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-        let msg1 = b\"hello\";\n-        let msg2 = b\"world!\";\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-        let thread = thread::spawn(move || {\n-            let mut stream = or_panic!(listener.accept()).0;\n-            let mut buf = [0; 5];\n-            or_panic!(stream.read(&mut buf));\n-            assert_eq!(&msg1[..], &buf[..]);\n-            or_panic!(stream.write_all(msg2));\n-        });\n-\n-        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-        assert_eq!(Some(&*socket_path),\n-                   stream.peer_addr().unwrap().as_pathname());\n-        or_panic!(stream.write_all(msg1));\n-        let mut buf = vec![];\n-        or_panic!(stream.read_to_end(&mut buf));\n-        assert_eq!(&msg2[..], &buf[..]);\n-        drop(stream);\n-\n-        thread.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn vectored() {\n-        let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n-\n-        let len = or_panic!(s1.write_vectored(\n-            &[IoSlice::new(b\"hello\"), IoSlice::new(b\" \"), IoSlice::new(b\"world!\")],\n-        ));\n-        assert_eq!(len, 12);\n-\n-        let mut buf1 = [0; 6];\n-        let mut buf2 = [0; 7];\n-        let len = or_panic!(s2.read_vectored(\n-            &mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],\n-        ));\n-        assert_eq!(len, 12);\n-        assert_eq!(&buf1, b\"hello \");\n-        assert_eq!(&buf2, b\"world!\\0\");\n-    }\n-\n-    #[test]\n-    fn pair() {\n-        let msg1 = b\"hello\";\n-        let msg2 = b\"world!\";\n-\n-        let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n-        let thread = thread::spawn(move || {\n-            // s1 must be moved in or the test will hang!\n-            let mut buf = [0; 5];\n-            or_panic!(s1.read(&mut buf));\n-            assert_eq!(&msg1[..], &buf[..]);\n-            or_panic!(s1.write_all(msg2));\n-        });\n-\n-        or_panic!(s2.write_all(msg1));\n-        let mut buf = vec![];\n-        or_panic!(s2.read_to_end(&mut buf));\n-        assert_eq!(&msg2[..], &buf[..]);\n-        drop(s2);\n-\n-        thread.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn try_clone() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-        let msg1 = b\"hello\";\n-        let msg2 = b\"world\";\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-        let thread = thread::spawn(move || {\n-            let mut stream = or_panic!(listener.accept()).0;\n-            or_panic!(stream.write_all(msg1));\n-            or_panic!(stream.write_all(msg2));\n-        });\n-\n-        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-        let mut stream2 = or_panic!(stream.try_clone());\n-\n-        let mut buf = [0; 5];\n-        or_panic!(stream.read(&mut buf));\n-        assert_eq!(&msg1[..], &buf[..]);\n-        or_panic!(stream2.read(&mut buf));\n-        assert_eq!(&msg2[..], &buf[..]);\n-\n-        thread.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn iter() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-        let thread = thread::spawn(move || {\n-            for stream in listener.incoming().take(2) {\n-                let mut stream = or_panic!(stream);\n-                let mut buf = [0];\n-                or_panic!(stream.read(&mut buf));\n-            }\n-        });\n-\n-        for _ in 0..2 {\n-            let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-            or_panic!(stream.write_all(&[0]));\n-        }\n-\n-        thread.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn long_path() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path()\n-                             .join(\"asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfa\\\n-                                    sasdfasdfasdasdfasdfasdfadfasdfasdfasdfasdfasdf\");\n-        match UnixStream::connect(&socket_path) {\n-            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n-            Err(e) => panic!(\"unexpected error {}\", e),\n-            Ok(_) => panic!(\"unexpected success\"),\n-        }\n-\n-        match UnixListener::bind(&socket_path) {\n-            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n-            Err(e) => panic!(\"unexpected error {}\", e),\n-            Ok(_) => panic!(\"unexpected success\"),\n-        }\n-\n-        match UnixDatagram::bind(&socket_path) {\n-            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n-            Err(e) => panic!(\"unexpected error {}\", e),\n-            Ok(_) => panic!(\"unexpected success\"),\n-        }\n-    }\n-\n-    #[test]\n-    fn timeouts() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let _listener = or_panic!(UnixListener::bind(&socket_path));\n-\n-        let stream = or_panic!(UnixStream::connect(&socket_path));\n-        let dur = Duration::new(15410, 0);\n-\n-        assert_eq!(None, or_panic!(stream.read_timeout()));\n-\n-        or_panic!(stream.set_read_timeout(Some(dur)));\n-        assert_eq!(Some(dur), or_panic!(stream.read_timeout()));\n-\n-        assert_eq!(None, or_panic!(stream.write_timeout()));\n-\n-        or_panic!(stream.set_write_timeout(Some(dur)));\n-        assert_eq!(Some(dur), or_panic!(stream.write_timeout()));\n-\n-        or_panic!(stream.set_read_timeout(None));\n-        assert_eq!(None, or_panic!(stream.read_timeout()));\n-\n-        or_panic!(stream.set_write_timeout(None));\n-        assert_eq!(None, or_panic!(stream.write_timeout()));\n-    }\n-\n-    #[test]\n-    fn test_read_timeout() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let _listener = or_panic!(UnixListener::bind(&socket_path));\n-\n-        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-        or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-        let mut buf = [0; 10];\n-        let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                \"unexpected_error: {:?}\", kind);\n-    }\n-\n-    #[test]\n-    fn test_read_with_timeout() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-\n-        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-        or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-        let mut other_end = or_panic!(listener.accept()).0;\n-        or_panic!(other_end.write_all(b\"hello world\"));\n-\n-        let mut buf = [0; 11];\n-        or_panic!(stream.read(&mut buf));\n-        assert_eq!(b\"hello world\", &buf[..]);\n-\n-        let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                \"unexpected_error: {:?}\", kind);\n-    }\n-\n-    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n-    // when passed zero Durations\n-    #[test]\n-    fn test_unix_stream_timeout_zero_duration() {\n-        let dir = tmpdir();\n-        let socket_path = dir.path().join(\"sock\");\n-\n-        let listener = or_panic!(UnixListener::bind(&socket_path));\n-        let stream = or_panic!(UnixStream::connect(&socket_path));\n-\n-        let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-        let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-        drop(listener);\n-    }\n-\n-    #[test]\n-    fn test_unix_datagram() {\n-        let dir = tmpdir();\n-        let path1 = dir.path().join(\"sock1\");\n-        let path2 = dir.path().join(\"sock2\");\n-\n-        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-        let sock2 = or_panic!(UnixDatagram::bind(&path2));\n-\n-        let msg = b\"hello world\";\n-        or_panic!(sock1.send_to(msg, &path2));\n-        let mut buf = [0; 11];\n-        or_panic!(sock2.recv_from(&mut buf));\n-        assert_eq!(msg, &buf[..]);\n-    }\n-\n-    #[test]\n-    fn test_unnamed_unix_datagram() {\n-        let dir = tmpdir();\n-        let path1 = dir.path().join(\"sock1\");\n-\n-        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-        let sock2 = or_panic!(UnixDatagram::unbound());\n-\n-        let msg = b\"hello world\";\n-        or_panic!(sock2.send_to(msg, &path1));\n-        let mut buf = [0; 11];\n-        let (usize, addr) = or_panic!(sock1.recv_from(&mut buf));\n-        assert_eq!(usize, 11);\n-        assert!(addr.is_unnamed());\n-        assert_eq!(msg, &buf[..]);\n-    }\n-\n-    #[test]\n-    fn test_connect_unix_datagram() {\n-        let dir = tmpdir();\n-        let path1 = dir.path().join(\"sock1\");\n-        let path2 = dir.path().join(\"sock2\");\n-\n-        let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n-        let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n-        let sock = or_panic!(UnixDatagram::unbound());\n-        or_panic!(sock.connect(&path1));\n-\n-        // Check send()\n-        let msg = b\"hello there\";\n-        or_panic!(sock.send(msg));\n-        let mut buf = [0; 11];\n-        let (usize, addr) = or_panic!(bsock1.recv_from(&mut buf));\n-        assert_eq!(usize, 11);\n-        assert!(addr.is_unnamed());\n-        assert_eq!(msg, &buf[..]);\n-\n-        // Changing default socket works too\n-        or_panic!(sock.connect(&path2));\n-        or_panic!(sock.send(msg));\n-        or_panic!(bsock2.recv_from(&mut buf));\n-    }\n-\n-    #[test]\n-    fn test_unix_datagram_recv() {\n-        let dir = tmpdir();\n-        let path1 = dir.path().join(\"sock1\");\n-\n-        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-        let sock2 = or_panic!(UnixDatagram::unbound());\n-        or_panic!(sock2.connect(&path1));\n-\n-        let msg = b\"hello world\";\n-        or_panic!(sock2.send(msg));\n-        let mut buf = [0; 11];\n-        let size = or_panic!(sock1.recv(&mut buf));\n-        assert_eq!(size, 11);\n-        assert_eq!(msg, &buf[..]);\n-    }\n-\n-    #[test]\n-    fn datagram_pair() {\n-        let msg1 = b\"hello\";\n-        let msg2 = b\"world!\";\n-\n-        let (s1, s2) = or_panic!(UnixDatagram::pair());\n-        let thread = thread::spawn(move || {\n-            // s1 must be moved in or the test will hang!\n-            let mut buf = [0; 5];\n-            or_panic!(s1.recv(&mut buf));\n-            assert_eq!(&msg1[..], &buf[..]);\n-            or_panic!(s1.send(msg2));\n-        });\n-\n-        or_panic!(s2.send(msg1));\n-        let mut buf = [0; 6];\n-        or_panic!(s2.recv(&mut buf));\n-        assert_eq!(&msg2[..], &buf[..]);\n-        drop(s2);\n-\n-        thread.join().unwrap();\n-    }\n-\n-    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n-    // when passed zero Durations\n-    #[test]\n-    fn test_unix_datagram_timeout_zero_duration() {\n-        let dir = tmpdir();\n-        let path = dir.path().join(\"sock\");\n-\n-        let datagram = or_panic!(UnixDatagram::bind(&path));\n-\n-        let result = datagram.set_write_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-        let result = datagram.set_read_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-    }\n-\n-    #[test]\n-    fn abstract_namespace_not_allowed() {\n-        assert!(UnixStream::connect(\"\\0asdf\").is_err());\n-    }\n-}"}, {"sha": "941df5ea57087bd1e38e6af240cd0fa0e6ca2f2d", "filename": "src/libsyntax/error_codes.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibsyntax%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibsyntax%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferror_codes.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -487,7 +487,6 @@ Erroneous code example:\n                                // `test_2018_feature` is\n                                // included in the Rust 2018 edition\n ```\n-\n \"##,\n \n E0725: r##\"\n@@ -505,6 +504,20 @@ Delete the offending feature attribute, or add it to the list of allowed\n features in the `-Z allow_features` flag.\n \"##,\n \n+E0743: r##\"\n+C-variadic has been used on a non-foreign function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0743\n+fn foo2(x: u8, ...) {} // error!\n+```\n+\n+Only foreign functions can use C-variadic (`...`). It is used to give an\n+undefined number of parameters to a given function (like `printf` in C). The\n+equivalent in Rust would be to use macros directly.\n+\"##,\n+\n ;\n \n     E0539, // incorrect meta item"}, {"sha": "e8f718a24835c085a824e5960b5cb18f6499f860", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -197,8 +197,11 @@ impl<'a> Parser<'a> {\n                 self.eat(&token::DotDotDot);\n                 TyKind::CVarArgs\n             } else {\n-                return Err(self.fatal(\n-                    \"only foreign functions are allowed to be C-variadic\"\n+                return Err(struct_span_fatal!(\n+                    self.sess.span_diagnostic,\n+                    self.token.span,\n+                    E0743,\n+                    \"only foreign functions are allowed to be C-variadic\",\n                 ));\n             }\n         } else {"}, {"sha": "57131ffe18cb3a36238f2e84962d8e089c422f97", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -370,6 +370,7 @@ symbols! {\n         issue_5723_bootstrap,\n         issue_tracker_base_url,\n         item,\n+        item_context: \"ItemContext\",\n         item_like_imports,\n         iter,\n         Iterator,"}, {"sha": "b8db16f8f2ac8dcfac2afa518dda66457ca3e75e", "filename": "src/libunwind/build.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -56,12 +56,18 @@ mod llvm_libunwind {\n     pub fn compile() {\n         let target_env = env::var(\"CARGO_CFG_TARGET_ENV\").unwrap();\n         let target_vendor = env::var(\"CARGO_CFG_TARGET_VENDOR\").unwrap();\n+        let target_endian_little = env::var(\"CARGO_CFG_TARGET_ENDIAN\").unwrap() != \"big\";\n         let cfg = &mut cc::Build::new();\n \n         cfg.cpp(true);\n         cfg.cpp_set_stdlib(None);\n         cfg.warnings(false);\n \n+        // libunwind expects a __LITTLE_ENDIAN__ macro to be set for LE archs, cf. #65765\n+        if target_endian_little {\n+            cfg.define(\"__LITTLE_ENDIAN__\", Some(\"1\"));\n+        }\n+\n         if target_env == \"msvc\" {\n             // Don't pull in extra libraries on MSVC\n             cfg.flag(\"/Zl\");"}, {"sha": "b2c6b8b3cbbf2bf4d15e5fdc3b71681a799522ae", "filename": "src/test/run-make-fulldeps/issue-64319/Makefile", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2FMakefile?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -1,39 +0,0 @@\n--include ../tools.mk\n-\n-# Different optimization levels imply different values for `-Zshare-generics`,\n-# so try out a whole bunch of combinations to make sure everything is compatible\n-all:\n-\t# First up, try some defaults\n-\t$(RUSTC) --crate-type rlib foo.rs\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3\n-\n-\t# Next try mixing up some things explicitly\n-\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=no\n-\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n-\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=no\n-\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n-\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=yes\n-\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n-\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=yes\n-\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n-\n-\t# Now combine a whole bunch of options together\n-\t$(RUSTC) --crate-type rlib foo.rs\n-\t$(RUSTC) --crate-type dylib bar.rs\n-\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n-\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1 -Z share-generics=no\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1 -Z share-generics=yes\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2 -Z share-generics=no\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2 -Z share-generics=yes\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3 -Z share-generics=no\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3 -Z share-generics=yes\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s -Z share-generics=no\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s -Z share-generics=yes\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z -Z share-generics=no\n-\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z -Z share-generics=yes"}, {"sha": "3895c0b6cdbb3d760b7df23c8934eca5da0210e8", "filename": "src/test/run-make-fulldeps/issue-64319/bar.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Fbar.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -1,5 +0,0 @@\n-extern crate foo;\n-\n-pub fn bar() {\n-    foo::foo();\n-}"}, {"sha": "c54a238e9add7f8ae13a1602df43d48467bf2b57", "filename": "src/test/run-make-fulldeps/issue-64319/foo.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Ffoo.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -1,9 +0,0 @@\n-pub fn foo() {\n-    bar::<usize>();\n-}\n-\n-pub fn bar<T>() {\n-    baz();\n-}\n-\n-fn baz() {}"}, {"sha": "7901866015bf2ffa564a7a4b8e10ddb8961baeb4", "filename": "src/test/run-make-fulldeps/symbol-visibility/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -79,12 +79,12 @@ all:\n \t# Check that a Rust dylib exports its monomorphic functions, including generics this time\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rust_dylib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"1\" ]\n \n \t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"1\" ]\n \n \t# Check that an executable does not export any dynamic symbols\n \t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]"}, {"sha": "200a29fc7eea373727d6f6b1e1c3e45d224b621e", "filename": "src/test/rustdoc/issue-55364.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Frustdoc%2Fissue-55364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Frustdoc%2Fissue-55364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-55364.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,88 @@\n+// ignore-tidy-linelength\n+\n+// First a module with inner documentation\n+\n+// @has issue_55364/subone/index.html\n+// These foo/bar links in the module's documentation should refer inside `subone`\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.bar.html\"]' 'bar'\n+pub mod subone {\n+    //! See either [foo] or [bar].\n+\n+    // This should refer to subone's `bar`\n+    // @has issue_55364/subone/fn.foo.html\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.bar.html\"]' 'bar'\n+    /// See [bar]\n+    pub fn foo() {}\n+    // This should refer to subone's `foo`\n+    // @has issue_55364/subone/fn.bar.html\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.foo.html\"]' 'foo'\n+    /// See [foo]\n+    pub fn bar() {}\n+}\n+\n+// A module with outer documentation\n+\n+// @has issue_55364/subtwo/index.html\n+// These foo/bar links in the module's documentation should not reference inside `subtwo`\n+// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.foo.html\"]' 'foo'\n+// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.bar.html\"]' 'bar'\n+// Instead it should be referencing the top level functions\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.bar.html\"]' 'bar'\n+// Though there should be such links later\n+// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td/a[@class=\"fn\"][@href=\"fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td/a[@class=\"fn\"][@href=\"fn.bar.html\"]' 'bar'\n+/// See either [foo] or [bar].\n+pub mod subtwo {\n+\n+    // Despite the module's docs referring to the top level foo/bar,\n+    // this should refer to subtwo's `bar`\n+    // @has issue_55364/subtwo/fn.foo.html\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.bar.html\"]' 'bar'\n+    /// See [bar]\n+    pub fn foo() {}\n+    // Despite the module's docs referring to the top level foo/bar,\n+    // this should refer to subtwo's `foo`\n+    // @has issue_55364/subtwo/fn.bar.html\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.foo.html\"]' 'foo'\n+    /// See [foo]\n+    pub fn bar() {}\n+}\n+\n+// These are the function referred to by the module above with outer docs\n+\n+/// See [bar]\n+pub fn foo() {}\n+/// See [foo]\n+pub fn bar() {}\n+\n+// This module refers to the outer foo/bar by means of `super::`\n+\n+// @has issue_55364/subthree/index.html\n+// This module should also refer to the top level foo/bar\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.bar.html\"]' 'bar'\n+pub mod subthree {\n+    //! See either [foo][super::foo] or [bar][super::bar]\n+}\n+\n+// Next we go *deeper* - In order to ensure it's not just \"this or parent\"\n+// we test `crate::` and a `super::super::...` chain\n+// @has issue_55364/subfour/subfive/subsix/subseven/subeight/index.html\n+// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../../issue_55364/subone/fn.foo.html\"]' 'other foo'\n+// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../../issue_55364/subtwo/fn.bar.html\"]' 'other bar'\n+pub mod subfour {\n+    pub mod subfive {\n+        pub mod subsix {\n+            pub mod subseven {\n+                pub mod subeight {\n+                    /// See [other foo][crate::subone::foo]\n+                    pub fn foo() {}\n+                    /// See [other bar][super::super::super::super::super::subtwo::bar]\n+                    pub fn bar() {}\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "adbd05ed8c1757593995a802f856518ad7ae3d6e", "filename": "src/test/ui/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falignment-gep-tup-like-1.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -28,7 +28,7 @@ fn f<A:Clone + 'static>(a: A, b: u16) -> Box<dyn Invokable<A>+'static> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as (Box<dyn Invokable<A>+'static>)\n+    } as Box<dyn Invokable<A>+'static>\n }\n \n pub fn main() {"}, {"sha": "feb0cb30ccaccf49f057db73e9f492e52e538db7", "filename": "src/test/ui/as-precedence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fas-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fas-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fas-precedence.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n \n+#[allow(unused_parens)]\n fn main() {\n     assert_eq!(3 as usize * 3, 9);\n     assert_eq!(3 as (usize) * 3, 9);"}, {"sha": "7f58f7f73e38c8d77044065182ad55652135e028", "filename": "src/test/ui/associated-type-bounds/type-alias.stderr", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -5,93 +5,129 @@ LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(type_alias_bounds)]` on by default\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaWhere1<T>  = T;\n+   |                  --\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/type-alias.rs:6:25\n    |\n LL | type _TaWhere2<T> where T: Iterator<Item: 'static> = T;\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaWhere2<T>  = T;\n+   |                  --\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/type-alias.rs:7:25\n    |\n LL | type _TaWhere3<T> where T: Iterator<Item: 'static> = T;\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaWhere3<T>  = T;\n+   |                  --\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/type-alias.rs:8:25\n    |\n LL | type _TaWhere4<T> where T: Iterator<Item: 'static + Copy + Send> = T;\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaWhere4<T>  = T;\n+   |                  --\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/type-alias.rs:9:25\n    |\n LL | type _TaWhere5<T> where T: Iterator<Item: for<'a> Into<&'a u8>> = T;\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaWhere5<T>  = T;\n+   |                  --\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/type-alias.rs:10:25\n    |\n LL | type _TaWhere6<T> where T: Iterator<Item: Iterator<Item: Copy>> = T;\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaWhere6<T>  = T;\n+   |                  --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias.rs:12:20\n    |\n LL | type _TaInline1<T: Iterator<Item: Copy>> = T;\n    |                    ^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaInline1<T> = T;\n+   |                 --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias.rs:13:20\n    |\n LL | type _TaInline2<T: Iterator<Item: 'static>> = T;\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaInline2<T> = T;\n+   |                 --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias.rs:14:20\n    |\n LL | type _TaInline3<T: Iterator<Item: 'static>> = T;\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaInline3<T> = T;\n+   |                 --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias.rs:15:20\n    |\n LL | type _TaInline4<T: Iterator<Item: 'static + Copy + Send>> = T;\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaInline4<T> = T;\n+   |                 --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias.rs:16:20\n    |\n LL | type _TaInline5<T: Iterator<Item: for<'a> Into<&'a u8>>> = T;\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaInline5<T> = T;\n+   |                 --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias.rs:17:20\n    |\n LL | type _TaInline6<T: Iterator<Item: Iterator<Item: Copy>>> = T;\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type _TaInline6<T> = T;\n+   |                 --\n "}, {"sha": "800b762911a62e3bf3532317cd6a6bb3bacf04d1", "filename": "src/test/ui/associated-types/associated-types-binding-to-type-defined-in-supertrait.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -5,10 +5,10 @@ LL | fn blue_car<C:Car<Color=Blue>>(c: C) {\n    |    --------       ---------- required by this bound in `blue_car`\n ...\n LL | fn b() { blue_car(ModelT); }\n-   |          ^^^^^^^^ expected struct `Black`, found struct `Blue`\n+   |          ^^^^^^^^ expected struct `Blue`, found struct `Black`\n    |\n-   = note: expected type `Black`\n-              found type `Blue`\n+   = note: expected type `Blue`\n+              found type `Black`\n \n error[E0271]: type mismatch resolving `<ModelU as Vehicle>::Color == Black`\n   --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:32:10\n@@ -17,10 +17,10 @@ LL | fn black_car<C:Car<Color=Black>>(c: C) {\n    |    ---------       ----------- required by this bound in `black_car`\n ...\n LL | fn c() { black_car(ModelU); }\n-   |          ^^^^^^^^^ expected struct `Blue`, found struct `Black`\n+   |          ^^^^^^^^^ expected struct `Black`, found struct `Blue`\n    |\n-   = note: expected type `Blue`\n-              found type `Black`\n+   = note: expected type `Black`\n+              found type `Blue`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "22e04a8f15ca823f5d607b2eb7e207dbae63f96b", "filename": "src/test/ui/associated-types/associated-types-eq-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -37,8 +37,8 @@ pub fn main() {\n     let a = 42;\n     foo1(a);\n     //~^ ERROR type mismatch resolving\n-    //~| expected usize, found struct `Bar`\n+    //~| expected struct `Bar`, found usize\n     baz(&a);\n     //~^ ERROR type mismatch resolving\n-    //~| expected usize, found struct `Bar`\n+    //~| expected struct `Bar`, found usize\n }"}, {"sha": "0f2bc84aa1c592d5563d94bb4e293cc5552a9b97", "filename": "src/test/ui/associated-types/associated-types-eq-3.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -16,19 +16,19 @@ LL | fn foo1<I: Foo<A=Bar>>(x: I) {\n    |    ----        ----- required by this bound in `foo1`\n ...\n LL |     foo1(a);\n-   |     ^^^^ expected usize, found struct `Bar`\n+   |     ^^^^ expected struct `Bar`, found usize\n    |\n-   = note: expected type `usize`\n-              found type `Bar`\n+   = note: expected type `Bar`\n+              found type `usize`\n \n error[E0271]: type mismatch resolving `<isize as Foo>::A == Bar`\n   --> $DIR/associated-types-eq-3.rs:41:9\n    |\n LL |     baz(&a);\n-   |         ^^ expected usize, found struct `Bar`\n+   |         ^^ expected struct `Bar`, found usize\n    |\n-   = note: expected type `usize`\n-              found type `Bar`\n+   = note: expected type `Bar`\n+              found type `usize`\n    = note: required for the cast to the object type `dyn Foo<A = Bar>`\n \n error: aborting due to 3 previous errors"}, {"sha": "a8c239389e9776f8b2b8e8d10ead891a5fdd9839", "filename": "src/test/ui/associated-types/associated-types-eq-hr.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -7,10 +7,10 @@ LL |     where T : for<'x> TheTrait<&'x isize, A = &'x isize>\n    |                                           ------------- required by this bound in `foo`\n ...\n LL |     foo::<UintStruct>();\n-   |     ^^^^^^^^^^^^^^^^^ expected usize, found isize\n+   |     ^^^^^^^^^^^^^^^^^ expected isize, found usize\n    |\n-   = note: expected type `&usize`\n-              found type `&isize`\n+   = note: expected type `&isize`\n+              found type `&usize`\n \n error[E0271]: type mismatch resolving `for<'x> <IntStruct as TheTrait<&'x isize>>::A == &'x usize`\n   --> $DIR/associated-types-eq-hr.rs:86:5\n@@ -21,10 +21,10 @@ LL |     where T : for<'x> TheTrait<&'x isize, A = &'x usize>\n    |                                           ------------- required by this bound in `bar`\n ...\n LL |     bar::<IntStruct>();\n-   |     ^^^^^^^^^^^^^^^^ expected isize, found usize\n+   |     ^^^^^^^^^^^^^^^^ expected usize, found isize\n    |\n-   = note: expected type `&isize`\n-              found type `&usize`\n+   = note: expected type `&usize`\n+              found type `&isize`\n \n error[E0277]: the trait bound `for<'x, 'y> Tuple: TheTrait<(&'x isize, &'y isize)>` is not satisfied\n   --> $DIR/associated-types-eq-hr.rs:91:17"}, {"sha": "b763b82d540cce32fbf0b00c09c6ebc3ba809915", "filename": "src/test/ui/associated-types/associated-types-issue-20346.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-issue-20346.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-issue-20346.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-issue-20346.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -5,10 +5,10 @@ LL | fn is_iterator_of<A, I: Iterator<Item=A>>(_: &I) {}\n    |    --------------                ------ required by this bound in `is_iterator_of`\n ...\n LL |     is_iterator_of::<Option<T>, _>(&adapter);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter, found enum `std::option::Option`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::option::Option`, found type parameter\n    |\n-   = note: expected type `T`\n-              found type `std::option::Option<T>`\n+   = note: expected type `std::option::Option<T>`\n+              found type `T`\n    = help: type parameters must be constrained to match other types\n    = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n "}, {"sha": "e3a2b5edf3f1b6ee3b02a75a8aa1f0192ddf3c2e", "filename": "src/test/ui/associated-types/associated-types-multiple-types-one-trait.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-multiple-types-one-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-multiple-types-one-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-multiple-types-one-trait.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -2,28 +2,28 @@ error[E0271]: type mismatch resolving `<T as Foo>::Y == i32`\n   --> $DIR/associated-types-multiple-types-one-trait.rs:13:5\n    |\n LL |     want_y(t);\n-   |     ^^^^^^ expected associated type, found i32\n+   |     ^^^^^^ expected i32, found associated type\n ...\n LL | fn want_y<T:Foo<Y=i32>>(t: &T) { }\n    |    ------       ----- required by this bound in `want_y`\n    |\n-   = note: expected type `<T as Foo>::Y`\n-              found type `i32`\n-   = note: consider constraining the associated type `<T as Foo>::Y` to `i32` or calling a method that returns `<T as Foo>::Y`\n+   = note: expected type `i32`\n+              found type `<T as Foo>::Y`\n+   = note: consider constraining the associated type `<T as Foo>::Y` to `i32`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n \n error[E0271]: type mismatch resolving `<T as Foo>::X == u32`\n   --> $DIR/associated-types-multiple-types-one-trait.rs:18:5\n    |\n LL |     want_x(t);\n-   |     ^^^^^^ expected associated type, found u32\n+   |     ^^^^^^ expected u32, found associated type\n ...\n LL | fn want_x<T:Foo<X=u32>>(t: &T) { }\n    |    ------       ----- required by this bound in `want_x`\n    |\n-   = note: expected type `<T as Foo>::X`\n-              found type `u32`\n-   = note: consider constraining the associated type `<T as Foo>::X` to `u32` or calling a method that returns `<T as Foo>::X`\n+   = note: expected type `u32`\n+              found type `<T as Foo>::X`\n+   = note: consider constraining the associated type `<T as Foo>::X` to `u32`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n \n error: aborting due to 2 previous errors"}, {"sha": "02a6ac12dd927a8afca22e25237dfffefabc2c94", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -2,10 +2,10 @@ error[E0271]: type mismatch resolving `<std::vec::IntoIter<u32> as std::iter::It\n   --> $DIR/associated-types-overridden-binding-2.rs:6:43\n    |\n LL |     let _: &dyn I32Iterator<Item = u32> = &vec![42].into_iter();\n-   |                                           ^^^^^^^^^^^^^^^^^^^^^ expected u32, found i32\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^ expected i32, found u32\n    |\n-   = note: expected type `u32`\n-              found type `i32`\n+   = note: expected type `i32`\n+              found type `u32`\n    = note: required for the cast to the object type `dyn std::iter::Iterator<Item = u32, Item = i32>`\n \n error: aborting due to previous error"}, {"sha": "6bef9dca265e72cbfebed5123b1969fa46dfde92", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -33,10 +33,10 @@ error[E0271]: type mismatch resolving `<impl std::future::Future as std::future:\n   --> $DIR/async-block-control-flow-static-semantics.rs:18:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n-   |                                       ^^^^^^ expected u8, found ()\n+   |                                       ^^^^^^ expected (), found u8\n    |\n-   = note: expected type `u8`\n-              found type `()`\n+   = note: expected type `()`\n+              found type `u8`\n    = note: required for the cast to the object type `dyn std::future::Future<Output = ()>`\n \n error[E0308]: mismatched types\n@@ -59,10 +59,10 @@ error[E0271]: type mismatch resolving `<impl std::future::Future as std::future:\n   --> $DIR/async-block-control-flow-static-semantics.rs:27:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n-   |                                       ^^^^^^ expected u8, found ()\n+   |                                       ^^^^^^ expected (), found u8\n    |\n-   = note: expected type `u8`\n-              found type `()`\n+   = note: expected type `()`\n+              found type `u8`\n    = note: required for the cast to the object type `dyn std::future::Future<Output = ()>`\n \n error[E0308]: mismatched types"}, {"sha": "51ac522017cb3fe7b932c3e6b6f6bffd8246e840", "filename": "src/test/ui/async-await/try-on-option-in-async.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,27 @@\n+#![feature(try_trait, async_closure)]\n+// edition:2018\n+fn main() {}\n+\n+async fn an_async_block() -> u32 {\n+    async {\n+        let x: Option<u32> = None;\n+        x?; //~ ERROR the `?` operator\n+        22\n+    }.await\n+}\n+\n+async fn async_closure_containing_fn() -> u32 {\n+    let async_closure = async || {\n+        let x: Option<u32> = None;\n+        x?; //~ ERROR the `?` operator\n+        22_u32\n+    };\n+\n+    async_closure().await\n+}\n+\n+async fn an_async_function() -> u32 {\n+    let x: Option<u32> = None;\n+    x?; //~ ERROR the `?` operator\n+    22\n+}"}, {"sha": "7d31f60efdc6a0425a69f07dc989c116e2d9e690", "filename": "src/test/ui/async-await/try-on-option-in-async.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,30 @@\n+error[E0277]: the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n+  --> $DIR/try-on-option-in-async.rs:8:9\n+   |\n+LL |         x?;\n+   |         ^^ cannot use the `?` operator in an async block that returns `{integer}`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `{integer}`\n+   = note: required by `std::ops::Try::from_error`\n+\n+error[E0277]: the `?` operator can only be used in an async closure that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n+  --> $DIR/try-on-option-in-async.rs:16:9\n+   |\n+LL |         x?;\n+   |         ^^ cannot use the `?` operator in an async closure that returns `u32`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `u32`\n+   = note: required by `std::ops::Try::from_error`\n+\n+error[E0277]: the `?` operator can only be used in an async function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n+  --> $DIR/try-on-option-in-async.rs:25:5\n+   |\n+LL |     x?;\n+   |     ^^ cannot use the `?` operator in an async function that returns `u32`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `u32`\n+   = note: required by `std::ops::Try::from_error`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4d6edf4ecb0f330522ce374a08209a48c3a10210", "filename": "src/test/ui/close-over-big-then-small-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclose-over-big-then-small-data.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -30,7 +30,7 @@ fn f<A:Clone + 'static>(a: A, b: u16) -> Box<dyn Invokable<A>+'static> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as (Box<dyn Invokable<A>+'static>)\n+    } as Box<dyn Invokable<A>+'static>\n }\n \n pub fn main() {"}, {"sha": "82bb95f1ef2b3ca8e33d9a1f17b9ef4a7d04feb3", "filename": "src/test/ui/cross-crate/issue-64872/auxiliary/a_def_obj.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fa_def_obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fa_def_obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fa_def_obj.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -C debuginfo=2\n+\n+// no-prefer-dynamic\n+#![crate_type = \"rlib\"]\n+\n+pub trait Object { fn method(&self) { } }\n+\n+impl Object for u32 { }\n+impl Object for () { }\n+impl<T> Object for &T { }\n+\n+pub fn unused() {\n+    let ref u = 0_u32;\n+    let _d = &u as &dyn crate::Object;\n+    _d.method()\n+}"}, {"sha": "21c0274b991fce0f2b93923e1ee91a1684cfb25b", "filename": "src/test/ui/cross-crate/issue-64872/auxiliary/b_reexport_obj.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fb_reexport_obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fb_reexport_obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fb_reexport_obj.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: -C debuginfo=2 -C prefer-dynamic\n+\n+#![crate_type=\"dylib\"]\n+\n+extern crate a_def_obj;\n+\n+pub use a_def_obj::Object;"}, {"sha": "611238f56173ae9a0cf1b1e017601908492cb460", "filename": "src/test/ui/cross-crate/issue-64872/auxiliary/c_another_vtable_for_obj.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fc_another_vtable_for_obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fc_another_vtable_for_obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fc_another_vtable_for_obj.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,12 @@\n+// no-prefer-dynamic\n+// compile-flags: -C debuginfo=2\n+#![crate_type=\"rlib\"]\n+\n+extern crate b_reexport_obj;\n+use b_reexport_obj::Object;\n+\n+pub fn another_dyn_debug() {\n+    let ref u = 1_u32;\n+    let _d = &u as &dyn crate::Object;\n+    _d.method()\n+}"}, {"sha": "8d73f9b666f1e117273d00498134459a918c6749", "filename": "src/test/ui/cross-crate/issue-64872/auxiliary/d_chain_of_rlibs_and_dylibs.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fd_chain_of_rlibs_and_dylibs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fd_chain_of_rlibs_and_dylibs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fauxiliary%2Fd_chain_of_rlibs_and_dylibs.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: -C debuginfo=2 -C prefer-dynamic\n+\n+#![crate_type=\"rlib\"]\n+\n+extern crate c_another_vtable_for_obj;\n+\n+pub fn chain() {\n+    c_another_vtable_for_obj::another_dyn_debug();\n+}"}, {"sha": "20fe2053cc7c319efd075da973c674fc7c471f3e", "filename": "src/test/ui/cross-crate/issue-64872/issue-64872.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fissue-64872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fissue-64872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-crate%2Fissue-64872%2Fissue-64872.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+// note that these aux-build directives must be in this order: the\n+// later crates depend on the earlier ones. (The particular bug that\n+// is being exercised here used to exhibit itself during the build of\n+// `chain_of_rlibs_and_dylibs.dylib`)\n+\n+// aux-build:a_def_obj.rs\n+// aux-build:b_reexport_obj.rs\n+// aux-build:c_another_vtable_for_obj.rs\n+// aux-build:d_chain_of_rlibs_and_dylibs.rs\n+\n+extern crate d_chain_of_rlibs_and_dylibs;\n+\n+pub fn main() {\n+    d_chain_of_rlibs_and_dylibs::chain();\n+}"}, {"sha": "378e5e3630641bdb9a2b68699f30c253dafd8c20", "filename": "src/test/ui/error-codes/E0271.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ferror-codes%2FE0271.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ferror-codes%2FE0271.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0271.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -5,10 +5,10 @@ LL | fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n    |    ---                         ------------------ required by this bound in `foo`\n ...\n LL |     foo(3_i8);\n-   |     ^^^ expected reference, found u32\n+   |     ^^^ expected u32, found reference\n    |\n-   = note: expected type `&'static str`\n-              found type `u32`\n+   = note: expected type `u32`\n+              found type `&'static str`\n \n error: aborting due to previous error\n "}, {"sha": "87ba488b5aef2459f3df3d79e0456112cdf5ea3c", "filename": "src/test/ui/functions-closures/closure-to-fn-coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-to-fn-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-to-fn-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-to-fn-coercion.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -10,7 +10,7 @@ const BAR: [fn(&mut u32); 5] = [\n     |v: &mut u32| *v += 3,\n     |v: &mut u32| *v += 4,\n ];\n-fn func_specific() -> (fn() -> u32) {\n+fn func_specific() -> fn() -> u32 {\n     || return 42\n }\n "}, {"sha": "fd20bd84edc464d7adef9522cbcd279de56df0ec", "filename": "src/test/ui/invalid/invalid-variadic-function.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1,4 +1,4 @@\n-error: only foreign functions are allowed to be C-variadic\n+error[E0743]: only foreign functions are allowed to be C-variadic\n   --> $DIR/invalid-variadic-function.rs:1:26\n    |\n LL | extern \"C\" fn foo(x: u8, ...);\n@@ -12,3 +12,4 @@ LL | extern \"C\" fn foo(x: u8, ...);\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0743`."}, {"sha": "9c53c1b86ceafd1cadf50aeac223a3445084f277", "filename": "src/test/ui/issues/issue-24204.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -5,10 +5,10 @@ LL | trait Trait: Sized {\n    | ------------------ required by `Trait`\n ...\n LL | fn test<T: Trait<B=i32>>(b: i32) -> T where T::A: MultiDispatch<i32> { T::new(b) }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found type parameter\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter, found associated type\n    |\n-   = note: expected type `<<T as Trait>::A as MultiDispatch<i32>>::O`\n-              found type `T`\n+   = note: expected type `T`\n+              found type `<<T as Trait>::A as MultiDispatch<i32>>::O`\n    = note: you might be missing a type parameter or trait bound\n \n error: aborting due to previous error"}, {"sha": "9f42b855a870d7b4e44abb0e86f4e23c3a6ef5a7", "filename": "src/test/ui/lint/lint-unnecessary-parens.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -13,6 +13,18 @@ fn bar(y: bool) -> X {\n     return (X { y }); //~ ERROR unnecessary parentheses around `return` value\n }\n \n+fn unused_parens_around_return_type() -> (u32) { //~ ERROR unnecessary parentheses around type\n+    panic!()\n+}\n+\n+trait Trait {\n+    fn test(&self);\n+}\n+\n+fn passes_unused_parens_lint() -> &'static (dyn Trait) {\n+    panic!()\n+}\n+\n fn main() {\n     foo();\n     bar((true)); //~ ERROR unnecessary parentheses around function argument"}, {"sha": "adc1069b64d62b98d3144f40d9419ba94047af6a", "filename": "src/test/ui/lint/lint-unnecessary-parens.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -16,73 +16,79 @@ error: unnecessary parentheses around `return` value\n LL |     return (X { y });\n    |            ^^^^^^^^^ help: remove these parentheses\n \n+error: unnecessary parentheses around type\n+  --> $DIR/lint-unnecessary-parens.rs:16:42\n+   |\n+LL | fn unused_parens_around_return_type() -> (u32) {\n+   |                                          ^^^^^ help: remove these parentheses\n+\n error: unnecessary parentheses around function argument\n-  --> $DIR/lint-unnecessary-parens.rs:18:9\n+  --> $DIR/lint-unnecessary-parens.rs:30:9\n    |\n LL |     bar((true));\n    |         ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `if` condition\n-  --> $DIR/lint-unnecessary-parens.rs:20:8\n+  --> $DIR/lint-unnecessary-parens.rs:32:8\n    |\n LL |     if (true) {}\n    |        ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `while` condition\n-  --> $DIR/lint-unnecessary-parens.rs:21:11\n+  --> $DIR/lint-unnecessary-parens.rs:33:11\n    |\n LL |     while (true) {}\n    |           ^^^^^^ help: remove these parentheses\n \n warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/lint-unnecessary-parens.rs:21:5\n+  --> $DIR/lint-unnecessary-parens.rs:33:5\n    |\n LL |     while (true) {}\n    |     ^^^^^^^^^^^^ help: use `loop`\n    |\n    = note: `#[warn(while_true)]` on by default\n \n error: unnecessary parentheses around `match` head expression\n-  --> $DIR/lint-unnecessary-parens.rs:23:11\n+  --> $DIR/lint-unnecessary-parens.rs:35:11\n    |\n LL |     match (true) {\n    |           ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `let` head expression\n-  --> $DIR/lint-unnecessary-parens.rs:26:16\n+  --> $DIR/lint-unnecessary-parens.rs:38:16\n    |\n LL |     if let 1 = (1) {}\n    |                ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `let` head expression\n-  --> $DIR/lint-unnecessary-parens.rs:27:19\n+  --> $DIR/lint-unnecessary-parens.rs:39:19\n    |\n LL |     while let 1 = (2) {}\n    |                   ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around method argument\n-  --> $DIR/lint-unnecessary-parens.rs:41:24\n+  --> $DIR/lint-unnecessary-parens.rs:53:24\n    |\n LL |     X { y: false }.foo((true));\n    |                        ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:43:18\n+  --> $DIR/lint-unnecessary-parens.rs:55:18\n    |\n LL |     let mut _a = (0);\n    |                  ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:44:10\n+  --> $DIR/lint-unnecessary-parens.rs:56:10\n    |\n LL |     _a = (0);\n    |          ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:45:11\n+  --> $DIR/lint-unnecessary-parens.rs:57:11\n    |\n LL |     _a += (1);\n    |           ^^^ help: remove these parentheses\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "aeeebdb991483ddcb68249df2f32ee1317431b39", "filename": "src/test/ui/parser/variadic-ffi-3.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1,8 +1,9 @@\n-error: only foreign functions are allowed to be C-variadic\n+error[E0743]: only foreign functions are allowed to be C-variadic\n   --> $DIR/variadic-ffi-3.rs:1:18\n    |\n LL | fn foo(x: isize, ...) {\n    |                  ^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0743`."}, {"sha": "da83276c72dd109f682c5224a20a23e5e64754d9", "filename": "src/test/ui/parser/variadic-ffi-4.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -1,8 +1,9 @@\n-error: only foreign functions are allowed to be C-variadic\n+error[E0743]: only foreign functions are allowed to be C-variadic\n   --> $DIR/variadic-ffi-4.rs:1:29\n    |\n LL | extern \"C\" fn foo(x: isize, ...) {\n    |                             ^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0743`."}, {"sha": "40aa47a7246c40455dbf381cd4a6f4a898ba0a1e", "filename": "src/test/ui/privacy/private-in-public-warn.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -340,15 +340,21 @@ LL |     pub type Alias<T: PrivTr> = T;\n    |                       ^^^^^^\n    |\n    = note: `#[warn(type_alias_bounds)]` on by default\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL |     pub type Alias<T> = T;\n+   |                    --\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/private-in-public-warn.rs:75:29\n    |\n LL |     pub type Alias<T> where T: PrivTr = T;\n    |                             ^^^^^^^^^\n    |\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL |     pub type Alias<T>  = T;\n+   |                      --\n \n error: aborting due to 36 previous errors\n "}, {"sha": "84d82ce8522400f44740b1d49219f25c57e7fe7f", "filename": "src/test/ui/resolve/visibility-indeterminate.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -12,3 +12,4 @@ LL | foo!();\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0578`."}, {"sha": "0f26a975a370f30963a4078afc7f8e51433fbfcf", "filename": "src/test/ui/single-use-lifetime/zero-uses-in-fn.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fzero-uses-in-fn.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fzero-uses-in-fn.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fzero-uses-in-fn.fixed?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -15,7 +15,7 @@ fn october<'b, T>(s: &'b T) -> &'b T {\n     s\n }\n \n-fn november<'a>(s: &'a str) -> (&'a str) {\n+fn november<'a>(s: &'a str) -> &'a str {\n     //~^ ERROR lifetime parameter `'b` never used\n     //~| HELP elide the unused lifetime\n     s"}, {"sha": "7f9504fe5a90a5f3156c779a9caa141b5254f6df", "filename": "src/test/ui/single-use-lifetime/zero-uses-in-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fzero-uses-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fzero-uses-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fzero-uses-in-fn.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -15,7 +15,7 @@ fn october<'a, 'b, T>(s: &'b T) -> &'b T {\n     s\n }\n \n-fn november<'a, 'b>(s: &'a str) -> (&'a str) {\n+fn november<'a, 'b>(s: &'a str) -> &'a str {\n     //~^ ERROR lifetime parameter `'b` never used\n     //~| HELP elide the unused lifetime\n     s"}, {"sha": "b9c3bd89748fff17879ba018a07cb0bbd2b0e8a3", "filename": "src/test/ui/single-use-lifetime/zero-uses-in-fn.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fzero-uses-in-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fzero-uses-in-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fzero-uses-in-fn.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -21,7 +21,7 @@ LL | fn october<'a, 'b, T>(s: &'b T) -> &'b T {\n error: lifetime parameter `'b` never used\n   --> $DIR/zero-uses-in-fn.rs:18:17\n    |\n-LL | fn november<'a, 'b>(s: &'a str) -> (&'a str) {\n+LL | fn november<'a, 'b>(s: &'a str) -> &'a str {\n    |               --^^\n    |               |\n    |               help: elide the unused lifetime"}, {"sha": "cb8bad6d9e74dbf227319eb17fa748e64a45f9f6", "filename": "src/test/ui/trivial-bounds/trivial-bounds-inconsistent.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -31,7 +31,10 @@ LL | type Y where i32: Foo = ();\n    |              ^^^^^^^^\n    |\n    = note: `#[warn(type_alias_bounds)]` on by default\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type Y  = ();\n+   |       --\n \n warning: Trait bound i32: Foo does not depend on any type or lifetime parameters\n   --> $DIR/trivial-bounds-inconsistent.rs:22:19"}, {"sha": "65d5e29ec2f135c238938eb479a63ee465493692", "filename": "src/test/ui/try-on-option-diagnostics.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ftry-on-option-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ftry-on-option-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-on-option-diagnostics.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,18 @@\n+#![feature(try_trait)]\n+// edition:2018\n+fn main() {}\n+\n+fn a_function() -> u32 {\n+    let x: Option<u32> = None;\n+    x?; //~ ERROR the `?` operator\n+    22\n+}\n+\n+fn a_closure() -> u32 {\n+    let a_closure = || {\n+        let x: Option<u32> = None;\n+        x?; //~ ERROR the `?` operator\n+        22\n+    };\n+    a_closure()\n+}"}, {"sha": "4dd515e1b5a454b726706f3a3f0655ab64c9e22e", "filename": "src/test/ui/try-on-option-diagnostics.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ftry-on-option-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ftry-on-option-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-on-option-diagnostics.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n+  --> $DIR/try-on-option-diagnostics.rs:7:5\n+   |\n+LL |     x?;\n+   |     ^^ cannot use the `?` operator in a function that returns `u32`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `u32`\n+   = note: required by `std::ops::Try::from_error`\n+\n+error[E0277]: the `?` operator can only be used in a closure that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n+  --> $DIR/try-on-option-diagnostics.rs:14:9\n+   |\n+LL |         x?;\n+   |         ^^ cannot use the `?` operator in a closure that returns `{integer}`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `{integer}`\n+   = note: required by `std::ops::Try::from_error`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c381d30c64f14326462f178b445cd537fe85c5fa", "filename": "src/test/ui/type/type-alias-bounds.stderr", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -5,79 +5,106 @@ LL | type SVec<T: Send + Send> = Vec<T>;\n    |              ^^^^   ^^^^\n    |\n    = note: `#[warn(type_alias_bounds)]` on by default\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type SVec<T> = Vec<T>;\n+   |     --    --\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:10:21\n    |\n LL | type S2Vec<T> where T: Send = Vec<T>;\n    |                     ^^^^^^^\n    |\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type S2Vec<T>  = Vec<T>;\n+   |              --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:12:19\n    |\n LL | type VVec<'b, 'a: 'b + 'b> = (&'b u32, Vec<&'a i32>);\n    |                   ^^   ^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type VVec<'b, 'a> = (&'b u32, Vec<&'a i32>);\n+   |            --  --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:14:18\n    |\n LL | type WVec<'b, T: 'b + 'b> = (&'b u32, Vec<T>);\n    |                  ^^   ^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type WVec<'b, T> = (&'b u32, Vec<T>);\n+   |           --  --\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:16:25\n    |\n LL | type W2Vec<'b, T> where T: 'b, T: 'b = (&'b u32, Vec<T>);\n    |                         ^^^^^  ^^^^^\n    |\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type W2Vec<'b, T>  = (&'b u32, Vec<T>);\n+   |                  --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:47:12\n    |\n LL | type T1<U: Bound> = U::Assoc;\n    |            ^^^^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n help: use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n   --> $DIR/type-alias-bounds.rs:47:21\n    |\n LL | type T1<U: Bound> = U::Assoc;\n    |                     ^^^^^^^^\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type T1<U> = U::Assoc;\n+   |         --\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:48:18\n    |\n LL | type T2<U> where U: Bound = U::Assoc;\n    |                  ^^^^^^^^\n    |\n-   = help: the clause will not be checked when the type alias is used, and should be removed\n help: use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n   --> $DIR/type-alias-bounds.rs:48:29\n    |\n LL | type T2<U> where U: Bound = U::Assoc;\n    |                             ^^^^^^^^\n+help: the clause will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type T2<U>  = U::Assoc;\n+   |           --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:56:12\n    |\n LL | type T5<U: Bound> = <U as Bound>::Assoc;\n    |            ^^^^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type T5<U> = <U as Bound>::Assoc;\n+   |         --\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:57:12\n    |\n LL | type T6<U: Bound> = ::std::vec::Vec<U>;\n    |            ^^^^^\n    |\n-   = help: the bound will not be checked when the type alias is used, and should be removed\n+help: the bound will not be checked when the type alias is used, and should be removed\n+   |\n+LL | type T6<U> = ::std::vec::Vec<U>;\n+   |         --\n "}, {"sha": "bd58de81c778a0287402c77bda52a7248c2f9c8c", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=87cbf0a547aaf9e8a7fc708851ecf4bc2adab5fd", "patch": "@@ -40,7 +40,6 @@ const WHITELIST: &[&str] = &[\n     \"E0514\",\n     \"E0519\",\n     \"E0523\",\n-    \"E0526\",\n     \"E0554\",\n     \"E0570\",\n     \"E0629\","}]}