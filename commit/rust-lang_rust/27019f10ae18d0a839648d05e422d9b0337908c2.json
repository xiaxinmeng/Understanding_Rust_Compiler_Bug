{"sha": "27019f10ae18d0a839648d05e422d9b0337908c2", "node_id": "C_kwDOAAsO6NoAKDI3MDE5ZjEwYWUxOGQwYTgzOTY0OGQwNWU0MjJkOWIwMzM3OTA4YzI", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-11-18T10:38:51Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-11-18T10:39:50Z"}, "message": "Remove Vec/Rc storage reuse opt", "tree": {"sha": "a48c113371c3cae4cc2022b98b879f234571c23a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a48c113371c3cae4cc2022b98b879f234571c23a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27019f10ae18d0a839648d05e422d9b0337908c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27019f10ae18d0a839648d05e422d9b0337908c2", "html_url": "https://github.com/rust-lang/rust/commit/27019f10ae18d0a839648d05e422d9b0337908c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27019f10ae18d0a839648d05e422d9b0337908c2/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83356b78c4ff3e7d84e977aa6143793545967301", "url": "https://api.github.com/repos/rust-lang/rust/commits/83356b78c4ff3e7d84e977aa6143793545967301", "html_url": "https://github.com/rust-lang/rust/commit/83356b78c4ff3e7d84e977aa6143793545967301"}], "stats": {"total": 149, "additions": 12, "deletions": 137}, "files": [{"sha": "5f307069d8076d81778d6db3dadc6e9a3757370c", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 6, "deletions": 53, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/27019f10ae18d0a839648d05e422d9b0337908c2/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27019f10ae18d0a839648d05e422d9b0337908c2/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=27019f10ae18d0a839648d05e422d9b0337908c2", "patch": "@@ -1441,48 +1441,6 @@ impl<T> Rc<[T]> {\n         }\n     }\n \n-    /// Create an `Rc<[T]>` by reusing the underlying memory\n-    /// of a `Vec<T>`. This will return the vector if the existing allocation\n-    /// is not large enough.\n-    #[cfg(not(no_global_oom_handling))]\n-    fn try_from_vec_in_place(mut v: Vec<T>) -> Result<Rc<[T]>, Vec<T>> {\n-        let layout_elements = Layout::array::<T>(v.len()).unwrap();\n-        let layout_allocation = Layout::array::<T>(v.capacity()).unwrap();\n-        let layout_rcbox = rcbox_layout_for_value_layout(layout_elements);\n-        let mut ptr = NonNull::new(v.as_mut_ptr()).expect(\"`Vec<T>` stores `NonNull<T>`\");\n-        if layout_rcbox.size() > layout_allocation.size()\n-            || layout_rcbox.align() > layout_allocation.align()\n-        {\n-            // Can't fit - calling `grow` would involve `realloc`\n-            // (which copies the elements), followed by copying again.\n-            return Err(v);\n-        }\n-        if layout_rcbox.size() < layout_allocation.size()\n-            || layout_rcbox.align() < layout_allocation.align()\n-        {\n-            // We need to shrink the allocation so that it fits\n-            // https://doc.rust-lang.org/nightly/std/alloc/trait.Allocator.html#memory-fitting\n-            // SAFETY:\n-            // - Vec allocates by requesting `Layout::array::<T>(capacity)`, so this capacity matches\n-            // - `layout_rcbox` is smaller\n-            // If this fails, the ownership has not been transferred\n-            if let Ok(p) = unsafe { Global.shrink(ptr.cast(), layout_allocation, layout_rcbox) } {\n-                ptr = p.cast();\n-            } else {\n-                return Err(v);\n-            }\n-        }\n-        // Make sure the vec's memory isn't deallocated now\n-        let v = mem::ManuallyDrop::new(v);\n-        let ptr: *mut RcBox<[T]> = ptr::slice_from_raw_parts_mut(ptr.as_ptr(), v.len()) as _;\n-        unsafe {\n-            ptr::copy(ptr.cast::<T>(), &mut (*ptr).value as *mut [T] as *mut T, v.len());\n-            ptr::write(&mut (*ptr).strong, Cell::new(1));\n-            ptr::write(&mut (*ptr).weak, Cell::new(1));\n-            Ok(Self::from_ptr(ptr))\n-        }\n-    }\n-\n     /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n@@ -2008,17 +1966,12 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n     /// assert_eq!(vec![1, 2, 3], *shared);\n     /// ```\n     #[inline]\n-    fn from(v: Vec<T>) -> Rc<[T]> {\n-        match Rc::try_from_vec_in_place(v) {\n-            Ok(rc) => rc,\n-            Err(mut v) => {\n-                unsafe {\n-                    let rc = Rc::copy_from_slice(&v);\n-                    // Allow the Vec to free its memory, but not destroy its contents\n-                    v.set_len(0);\n-                    rc\n-                }\n-            }\n+    fn from(mut v: Vec<T>) -> Rc<[T]> {\n+        unsafe {\n+            let rc = Rc::copy_from_slice(&v);\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+            rc\n         }\n     }\n }"}, {"sha": "b69f6b0311234c37b9532d1fc6b128c24045d3cf", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 6, "deletions": 54, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/27019f10ae18d0a839648d05e422d9b0337908c2/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27019f10ae18d0a839648d05e422d9b0337908c2/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=27019f10ae18d0a839648d05e422d9b0337908c2", "patch": "@@ -1261,49 +1261,6 @@ impl<T> Arc<[T]> {\n         }\n     }\n \n-    /// Create an `Arc<[T]>` by reusing the underlying memory\n-    /// of a `Vec<T>`. This will return the vector if the existing allocation\n-    /// is not large enough.\n-    #[cfg(not(no_global_oom_handling))]\n-    fn try_from_vec_in_place(mut v: Vec<T>) -> Result<Arc<[T]>, Vec<T>> {\n-        let layout_elements = Layout::array::<T>(v.len()).unwrap();\n-        let layout_allocation = Layout::array::<T>(v.capacity()).unwrap();\n-        let layout_arcinner = arcinner_layout_for_value_layout(layout_elements);\n-        let mut ptr = NonNull::new(v.as_mut_ptr()).expect(\"`Vec<T>` stores `NonNull<T>`\");\n-        if layout_arcinner.size() > layout_allocation.size()\n-            || layout_arcinner.align() > layout_allocation.align()\n-        {\n-            // Can't fit - calling `grow` would involve `realloc`\n-            // (which copies the elements), followed by copying again.\n-            return Err(v);\n-        }\n-        if layout_arcinner.size() < layout_allocation.size()\n-            || layout_arcinner.align() < layout_allocation.align()\n-        {\n-            // We need to shrink the allocation so that it fits\n-            // https://doc.rust-lang.org/nightly/std/alloc/trait.Allocator.html#memory-fitting\n-            // SAFETY:\n-            // - Vec allocates by requesting `Layout::array::<T>(capacity)`, so this capacity matches\n-            // - `layout_arcinner` is smaller\n-            // If this fails, the ownership has not been transferred\n-            if let Ok(p) = unsafe { Global.shrink(ptr.cast(), layout_allocation, layout_arcinner) }\n-            {\n-                ptr = p.cast();\n-            } else {\n-                return Err(v);\n-            }\n-        }\n-        // Make sure the vec's memory isn't deallocated now\n-        let v = mem::ManuallyDrop::new(v);\n-        let ptr: *mut ArcInner<[T]> = ptr::slice_from_raw_parts_mut(ptr.as_ptr(), v.len()) as _;\n-        unsafe {\n-            ptr::copy(ptr.cast::<T>(), &mut (*ptr).data as *mut [T] as *mut T, v.len());\n-            ptr::write(&mut (*ptr).strong, atomic::AtomicUsize::new(1));\n-            ptr::write(&mut (*ptr).weak, atomic::AtomicUsize::new(1));\n-            Ok(Self::from_ptr(ptr))\n-        }\n-    }\n-\n     /// Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n@@ -2615,17 +2572,12 @@ impl<T> From<Vec<T>> for Arc<[T]> {\n     /// assert_eq!(&[1, 2, 3], &shared[..]);\n     /// ```\n     #[inline]\n-    fn from(v: Vec<T>) -> Arc<[T]> {\n-        match Arc::try_from_vec_in_place(v) {\n-            Ok(rc) => rc,\n-            Err(mut v) => {\n-                unsafe {\n-                    let rc = Arc::copy_from_slice(&v);\n-                    // Allow the Vec to free its memory, but not destroy its contents\n-                    v.set_len(0);\n-                    rc\n-                }\n-            }\n+    fn from(mut v: Vec<T>) -> Arc<[T]> {\n+        unsafe {\n+            let rc = Arc::copy_from_slice(&v);\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+            rc\n         }\n     }\n }"}, {"sha": "ce40b5c9b0a0d3a5948635c131dc1b353adbbcfb", "filename": "library/alloc/tests/arc.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/27019f10ae18d0a839648d05e422d9b0337908c2/library%2Falloc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27019f10ae18d0a839648d05e422d9b0337908c2/library%2Falloc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Farc.rs?ref=27019f10ae18d0a839648d05e422d9b0337908c2", "patch": "@@ -210,18 +210,3 @@ fn weak_may_dangle() {\n     // `val` dropped here while still borrowed\n     // borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::sync::Weak`\n }\n-\n-#[test]\n-fn arc_from_vec_opt() {\n-    let mut v = Vec::with_capacity(64);\n-    v.push(0usize);\n-    let addr = v.as_ptr().cast::<u8>();\n-    let arc: Arc<[_]> = v.into();\n-    unsafe {\n-        assert_eq!(\n-            arc.as_ptr().cast::<u8>().offset_from(addr),\n-            (std::mem::size_of::<usize>() * 2) as isize,\n-            \"Vector allocation not reused\"\n-        );\n-    }\n-}"}, {"sha": "efb39a609665b33ad2e6b9b43a75533a98f1feb5", "filename": "library/alloc/tests/rc.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/27019f10ae18d0a839648d05e422d9b0337908c2/library%2Falloc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27019f10ae18d0a839648d05e422d9b0337908c2/library%2Falloc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Frc.rs?ref=27019f10ae18d0a839648d05e422d9b0337908c2", "patch": "@@ -206,18 +206,3 @@ fn weak_may_dangle() {\n     // `val` dropped here while still borrowed\n     // borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::rc::Weak`\n }\n-\n-#[test]\n-fn rc_from_vec_opt() {\n-    let mut v = Vec::with_capacity(64);\n-    v.push(0usize);\n-    let addr = v.as_ptr().cast::<u8>();\n-    let rc: Rc<[_]> = v.into();\n-    unsafe {\n-        assert_eq!(\n-            rc.as_ptr().cast::<u8>().offset_from(addr),\n-            (std::mem::size_of::<usize>() * 2) as isize,\n-            \"Vector allocation not reused\"\n-        );\n-    }\n-}"}]}