{"sha": "48467c4faa757bba8439d9b52a6f8417d1b69aa2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NDY3YzRmYWE3NTdiYmE4NDM5ZDliNTJhNmY4NDE3ZDFiNjlhYTI=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-02T19:26:52Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-02T23:53:31Z"}, "message": "Comment tweaks and re-flows.", "tree": {"sha": "3bc706c1d65c13bd82e2f2d20078969299b87915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bc706c1d65c13bd82e2f2d20078969299b87915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48467c4faa757bba8439d9b52a6f8417d1b69aa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48467c4faa757bba8439d9b52a6f8417d1b69aa2", "html_url": "https://github.com/rust-lang/rust/commit/48467c4faa757bba8439d9b52a6f8417d1b69aa2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48467c4faa757bba8439d9b52a6f8417d1b69aa2/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f371482593ea9c7179c76b919ce5ed95aa6956b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f371482593ea9c7179c76b919ce5ed95aa6956b8", "html_url": "https://github.com/rust-lang/rust/commit/f371482593ea9c7179c76b919ce5ed95aa6956b8"}], "stats": {"total": 54, "additions": 24, "deletions": 30}, "files": [{"sha": "ca01236c235f9b9c30a158b1f5662021d4bdebd3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/48467c4faa757bba8439d9b52a6f8417d1b69aa2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48467c4faa757bba8439d9b52a6f8417d1b69aa2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=48467c4faa757bba8439d9b52a6f8417d1b69aa2", "patch": "@@ -1680,7 +1680,7 @@ fn make_cmp_glue(cx: &@block_ctxt, lhs0: ValueRef, rhs0: ValueRef, t: &ty::t,\n }\n \n \n-// Used only for creating scalar comparsion glue.\n+// Used only for creating scalar comparison glue.\n tag scalar_type { nil_type; signed_int; unsigned_int; floating_point; }\n \n \n@@ -5662,19 +5662,14 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     let vtbl;\n     alt anon_obj.inner_obj {\n       none. {\n-        // If there's no inner_obj -- that is, if we're just adding new\n-        // fields rather than extending an existing object -- then we just\n-        // pass the outer object to create_vtbl().  Our vtable won't need\n-        // to have any forwarding slots.\n-\n         // We need a dummy inner_obj_ty for setting up the object body\n         // later.\n         inner_obj_ty = ty::mk_type(ccx.tcx);\n \n-        // This seems a little strange, because it'll come into\n-        // create_vtbl() with no \"additional methods\".  What's happening\n-        // is that, since *all* of the methods are \"additional\", we can\n-        // get away with acting like none of them are.\n+        // If there's no inner_obj -- that is, if we're just adding new\n+        // fields rather than extending an existing object -- then we just\n+        // pass the outer object to create_vtbl().  Our vtable won't need\n+        // to have any forwarding slots.\n         vtbl =\n             create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[], none,\n                         additional_field_tys);\n@@ -6770,19 +6765,19 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n       some(inner_obj_ty) {\n         // Handle forwarding slots.\n \n-        // If this vtable is being created for an extended object, then\n-        // the vtable needs to contain 'forwarding slots' for methods that\n-        // were on the original object and are not being overloaded by the\n-        // extended one.  So, to find the set of methods that we need\n-        // forwarding slots for, we need to take the set difference of\n-        // inner_obj_methods (methods on the original object) and\n-        // ob.methods (methods on the object being added).\n+        // If this vtable is being created for an extended object, then the\n+        // vtable needs to contain 'forwarding slots' for methods that were on\n+        // the original object and are not being overloaded by the extended\n+        // one.  So, to find the set of methods that we need forwarding slots\n+        // for, we need to take the set difference of inner_obj_methods\n+        // (methods on the original object) and ob.methods (methods on the\n+        // object being added).\n \n-        // If we're here, then inner_obj_ty and llinner_obj_ty are the type\n-        // of the inner object, and \"ob\" is the wrapper object.  We need\n-        // to take apart inner_obj_ty (it had better have an object type\n-        // with methods!) and put those original methods onto the list of\n-        // methods we need forwarding methods for.\n+        // If we're here, then inner_obj_ty and llinner_obj_ty are the type of\n+        // the inner object, and \"ob\" is the wrapper object.  We need to take\n+        // apart inner_obj_ty (it had better have an object type with\n+        // methods!) and put those original methods onto the list of methods\n+        // we need forwarding methods for.\n \n         // Gather up methods on the original object in 'meths'.\n         alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n@@ -6806,12 +6801,11 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n \n             alt m {\n               fwding_mthd(fm) {\n-                // Since fm is a fwding_mthd, and we're checking to\n-                // see if it's in addtl_meths (which only contains\n-                // normal_mthds), we can't just check if fm is a\n-                // member of addtl_meths.  Instead, we have to go\n-                // through addtl_meths and see if there's some method\n-                // in it that has the same name as fm.\n+                // Since fm is a fwding_mthd, and we're checking to see if\n+                // it's in addtl_meths (which only contains normal_mthds), we\n+                // can't just check if fm is a member of addtl_meths.\n+                // Instead, we have to go through addtl_meths and see if\n+                // there's some method in it that has the same name as fm.\n                 for am: @ast::method  in addtl_meths {\n                     if str::eq(am.node.ident, fm.ident) { ret none; }\n                 }\n@@ -6828,8 +6822,8 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n         meths = std::ivec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n \n \n-        // And now add the additional ones (both replacements and entirely\n-        // new ones).  These'll just be normal methods.\n+        // And now add the additional ones (both replacements and entirely new\n+        // ones).  These'll just be normal methods.\n         for m: @ast::method  in ob.methods { meths += ~[normal_mthd(m)]; }\n       }\n     }"}]}