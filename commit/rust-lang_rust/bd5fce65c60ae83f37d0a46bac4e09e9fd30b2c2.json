{"sha": "bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "node_id": "C_kwDOAAsO6NoAKGJkNWZjZTY1YzYwYWU4M2YzN2QwYTQ2YmFjNGUwOWU5ZmQzMGIyYzI", "commit": {"author": {"name": "carbotaniuman", "email": "41451839+carbotaniuman@users.noreply.github.com", "date": "2022-05-13T17:30:25Z"}, "committer": {"name": "carbotaniuman", "email": "41451839+carbotaniuman@users.noreply.github.com", "date": "2022-05-13T17:30:25Z"}, "message": "Rustc changes for permissive provenance", "tree": {"sha": "e7a37ca5fc13b3efc60d94e1c979cae1dde08627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7a37ca5fc13b3efc60d94e1c979cae1dde08627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "html_url": "https://github.com/rust-lang/rust/commit/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/comments", "author": {"login": "carbotaniuman", "id": 41451839, "node_id": "MDQ6VXNlcjQxNDUxODM5", "avatar_url": "https://avatars.githubusercontent.com/u/41451839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carbotaniuman", "html_url": "https://github.com/carbotaniuman", "followers_url": "https://api.github.com/users/carbotaniuman/followers", "following_url": "https://api.github.com/users/carbotaniuman/following{/other_user}", "gists_url": "https://api.github.com/users/carbotaniuman/gists{/gist_id}", "starred_url": "https://api.github.com/users/carbotaniuman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carbotaniuman/subscriptions", "organizations_url": "https://api.github.com/users/carbotaniuman/orgs", "repos_url": "https://api.github.com/users/carbotaniuman/repos", "events_url": "https://api.github.com/users/carbotaniuman/events{/privacy}", "received_events_url": "https://api.github.com/users/carbotaniuman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "carbotaniuman", "id": 41451839, "node_id": "MDQ6VXNlcjQxNDUxODM5", "avatar_url": "https://avatars.githubusercontent.com/u/41451839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carbotaniuman", "html_url": "https://github.com/carbotaniuman", "followers_url": "https://api.github.com/users/carbotaniuman/followers", "following_url": "https://api.github.com/users/carbotaniuman/following{/other_user}", "gists_url": "https://api.github.com/users/carbotaniuman/gists{/gist_id}", "starred_url": "https://api.github.com/users/carbotaniuman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carbotaniuman/subscriptions", "organizations_url": "https://api.github.com/users/carbotaniuman/orgs", "repos_url": "https://api.github.com/users/carbotaniuman/repos", "events_url": "https://api.github.com/users/carbotaniuman/events{/privacy}", "received_events_url": "https://api.github.com/users/carbotaniuman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0034bbca260bfa00798d70150970924221688ede", "url": "https://api.github.com/repos/rust-lang/rust/commits/0034bbca260bfa00798d70150970924221688ede", "html_url": "https://github.com/rust-lang/rust/commit/0034bbca260bfa00798d70150970924221688ede"}], "stats": {"total": 187, "additions": 142, "deletions": 45}, "files": [{"sha": "c5a11aaceaf9a09f9f73fae9674888c4af16fa88", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -18,7 +18,7 @@ use rustc_target::spec::abi::Abi;\n \n use crate::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    OpTy, PlaceTy, Scalar, StackPopUnwind,\n+    OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n };\n \n use super::error::*;\n@@ -443,6 +443,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Ok(())\n     }\n \n+    #[inline(always)]\n+    fn expose_ptr(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _ptr: Pointer<AllocId>,\n+    ) -> InterpResult<'tcx> {\n+        Err(ConstEvalErrKind::NeedsRfc(\"exposing pointers\".to_string()).into())\n+    }\n+\n     #[inline(always)]\n     fn init_frame_extra(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "92eeafc5df098f9cd3ff6eb4880ac310c5095ca4", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -98,7 +98,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     pub fn misc_cast(\n-        &self,\n+        &mut self,\n         src: &ImmTy<'tcx, M::PointerTag>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n@@ -139,7 +139,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     assert!(src.layout.is_zst());\n                     let discr_layout = self.layout_of(discr.ty)?;\n-                    return Ok(self.cast_from_int_like(discr.val, discr_layout, cast_ty).into());\n+\n+                    let scalar = Scalar::from_uint(discr.val, discr_layout.layout.size());\n+                    return Ok(self.cast_from_int_like(scalar, discr_layout, cast_ty)?.into());\n                 }\n             }\n             Variants::Multiple { .. } => {}\n@@ -170,38 +172,65 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         // # The remaining source values are scalar and \"int-like\".\n+        let scalar = src.to_scalar()?;\n+\n+        // If we are casting from a pointer to something\n+        // that is not a pointer, mark the pointer as exposed\n+        if src.layout.ty.is_any_ptr() && !cast_ty.is_any_ptr() {\n+            let ptr = self.scalar_to_ptr(scalar)?;\n+\n+            match ptr.into_pointer_or_addr() {\n+                Ok(ptr) => {\n+                    M::expose_ptr(self, ptr)?;\n+                }\n+                Err(_) => {\n+                    // do nothing, exposing an invalid pointer\n+                    // has no meaning\n+                }\n+            };\n+        }\n \n-        // For all remaining casts, we either\n-        // (a) cast a raw ptr to usize, or\n-        // (b) cast from an integer-like (including bool, char, enums).\n-        // In both cases we want the bits.\n-        let bits = src.to_scalar()?.to_bits(src.layout.size)?;\n-        Ok(self.cast_from_int_like(bits, src.layout, cast_ty).into())\n+        Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n     }\n \n-    fn cast_from_int_like(\n+    pub fn cast_from_int_like(\n         &self,\n-        v: u128, // raw bits (there is no ScalarTy so we separate data+layout)\n+        scalar: Scalar<M::PointerTag>, // input value (there is no ScalarTy so we separate data+layout)\n         src_layout: TyAndLayout<'tcx>,\n         cast_ty: Ty<'tcx>,\n-    ) -> Scalar<M::PointerTag> {\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n         // Let's make sure v is sign-extended *if* it has a signed type.\n         let signed = src_layout.abi.is_signed(); // Also asserts that abi is `Scalar`.\n+\n+        let v = scalar.to_bits(src_layout.size)?;\n         let v = if signed { self.sign_extend(v, src_layout) } else { v };\n         trace!(\"cast_from_scalar: {}, {} -> {}\", v, src_layout.ty, cast_ty);\n         use rustc_middle::ty::TyKind::*;\n-        match *cast_ty.kind() {\n-            Int(_) | Uint(_) | RawPtr(_) => {\n+\n+        Ok(match *cast_ty.kind() {\n+            Int(_) | Uint(_) => {\n                 let size = match *cast_ty.kind() {\n                     Int(t) => Integer::from_int_ty(self, t).size(),\n                     Uint(t) => Integer::from_uint_ty(self, t).size(),\n-                    RawPtr(_) => self.pointer_size(),\n                     _ => bug!(),\n                 };\n                 let v = size.truncate(v);\n                 Scalar::from_uint(v, size)\n             }\n \n+            RawPtr(_) => {\n+                assert!(src_layout.ty.is_integral());\n+\n+                let size = self.pointer_size();\n+                let addr = u64::try_from(size.truncate(v)).unwrap();\n+\n+                let ptr = M::ptr_from_addr_cast(&self, addr);\n+                if addr == 0 {\n+                    assert!(ptr.provenance.is_none(), \"null pointer can never have an AllocId\");\n+                }\n+                Scalar::from_maybe_pointer(ptr, self)\n+            }\n+\n             Float(FloatTy::F32) if signed => Scalar::from_f32(Single::from_i128(v as i128).value),\n             Float(FloatTy::F64) if signed => Scalar::from_f64(Double::from_i128(v as i128).value),\n             Float(FloatTy::F32) => Scalar::from_f32(Single::from_u128(v).value),\n@@ -214,7 +243,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n             _ => span_bug!(self.cur_span(), \"invalid int to {:?} cast\", cast_ty),\n-        }\n+        })\n     }\n \n     fn cast_from_float<F>(&self, f: F, dest_ty: Ty<'tcx>) -> Scalar<M::PointerTag>"}, {"sha": "ec16685bcbeb292fa78c58ba91cb2141c48102d3", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -905,7 +905,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             trace!(\n                 \"deallocating local {:?}: {:?}\",\n                 local,\n-                self.dump_alloc(ptr.provenance.unwrap().get_alloc_id())\n+                // Locals always have a `alloc_id` (they are never the result of a int2ptr).\n+                self.dump_alloc(ptr.provenance.unwrap().get_alloc_id().unwrap())\n             );\n             self.deallocate_ptr(ptr, None, MemoryKind::Stack)?;\n         };\n@@ -1013,9 +1014,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                     }\n                 }\n \n-                write!(fmt, \": {:?}\", self.ecx.dump_allocs(allocs))\n+                write!(\n+                    fmt,\n+                    \": {:?}\",\n+                    self.ecx.dump_allocs(allocs.into_iter().filter_map(|x| x).collect())\n+                )\n             }\n-            Place::Ptr(mplace) => match mplace.ptr.provenance.map(Provenance::get_alloc_id) {\n+            Place::Ptr(mplace) => match mplace.ptr.provenance.and_then(Provenance::get_alloc_id) {\n                 Some(alloc_id) => write!(\n                     fmt,\n                     \"by align({}) ref {:?}: {:?}\","}, {"sha": "a79751ccb55b481af55bc6cd7bf1bfd038430d20", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -286,19 +286,36 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ) -> Pointer<Self::PointerTag>;\n \n     /// \"Int-to-pointer cast\"\n-    fn ptr_from_addr(\n+    fn ptr_from_addr_cast(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         addr: u64,\n     ) -> Pointer<Option<Self::PointerTag>>;\n \n+    // FIXME: Transmuting an integer to a pointer should just always return a `None`\n+    // provenance, but that causes problems with function pointers in Miri.\n+    /// Hook for returning a pointer from a transmute-like operation on an addr.\n+    fn ptr_from_addr_transmute(\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n+        addr: u64,\n+    ) -> Pointer<Option<Self::PointerTag>>;\n+\n+    /// Marks a pointer as exposed, allowing it's provenance\n+    /// to be recovered. \"Pointer-to-int cast\"\n+    fn expose_ptr(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+    ) -> InterpResult<'tcx>;\n+\n     /// Convert a pointer with provenance into an allocation-offset pair\n     /// and extra provenance info.\n     ///\n     /// The returned `AllocId` must be the same as `ptr.provenance.get_alloc_id()`.\n+    ///\n+    /// When this fails, that means the pointer does not point to a live allocation.\n     fn ptr_get_alloc(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer<Self::PointerTag>,\n-    ) -> (AllocId, Size, Self::TagExtra);\n+    ) -> Option<(AllocId, Size, Self::TagExtra)>;\n \n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n@@ -480,17 +497,28 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     }\n \n     #[inline(always)]\n-    fn ptr_from_addr(_ecx: &InterpCx<$mir, $tcx, Self>, addr: u64) -> Pointer<Option<AllocId>> {\n+    fn ptr_from_addr_transmute(\n+        _ecx: &InterpCx<$mir, $tcx, Self>,\n+        addr: u64,\n+    ) -> Pointer<Option<AllocId>> {\n+        Pointer::new(None, Size::from_bytes(addr))\n+    }\n+\n+    #[inline(always)]\n+    fn ptr_from_addr_cast(\n+        _ecx: &InterpCx<$mir, $tcx, Self>,\n+        addr: u64,\n+    ) -> Pointer<Option<AllocId>> {\n         Pointer::new(None, Size::from_bytes(addr))\n     }\n \n     #[inline(always)]\n     fn ptr_get_alloc(\n         _ecx: &InterpCx<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n-    ) -> (AllocId, Size, Self::TagExtra) {\n+    ) -> Option<(AllocId, Size, Self::TagExtra)> {\n         // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n-        (alloc_id, offset, ())\n+        Some((alloc_id, offset, ()))\n     }\n }"}, {"sha": "0479a8c4a45fc6fa08e6d74a1e5cdfd36c3e72e0", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -770,7 +770,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if reachable.insert(id) {\n                     // This is a new allocation, add its relocations to `todo`.\n                     if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n-                        todo.extend(alloc.relocations().values().map(|tag| tag.get_alloc_id()));\n+                        todo.extend(\n+                            alloc.relocations().values().filter_map(|tag| tag.get_alloc_id()),\n+                        );\n                     }\n                 }\n             }\n@@ -805,7 +807,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n             allocs_to_print: &mut VecDeque<AllocId>,\n             alloc: &Allocation<Tag, Extra>,\n         ) -> std::fmt::Result {\n-            for alloc_id in alloc.relocations().values().map(|tag| tag.get_alloc_id()) {\n+            for alloc_id in alloc.relocations().values().filter_map(|tag| tag.get_alloc_id()) {\n                 allocs_to_print.push_back(alloc_id);\n             }\n             write!(fmt, \"{}\", display_allocation(tcx, alloc))\n@@ -1125,7 +1127,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Err(ptr) => ptr.into(),\n                 Ok(bits) => {\n                     let addr = u64::try_from(bits).unwrap();\n-                    let ptr = M::ptr_from_addr(&self, addr);\n+                    let ptr = M::ptr_from_addr_transmute(&self, addr);\n                     if addr == 0 {\n                         assert!(ptr.provenance.is_none(), \"null pointer can never have an AllocId\");\n                     }\n@@ -1165,10 +1167,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> Result<(AllocId, Size, M::TagExtra), u64> {\n         match ptr.into_pointer_or_addr() {\n-            Ok(ptr) => {\n-                let (alloc_id, offset, extra) = M::ptr_get_alloc(self, ptr);\n-                Ok((alloc_id, offset, extra))\n-            }\n+            Ok(ptr) => match M::ptr_get_alloc(self, ptr) {\n+                Some((alloc_id, offset, extra)) => Ok((alloc_id, offset, extra)),\n+                None => {\n+                    assert!(M::PointerTag::OFFSET_IS_ADDR);\n+                    let (_, addr) = ptr.into_parts();\n+                    Err(addr.bytes())\n+                }\n+            },\n             Err(addr) => Err(addr.bytes()),\n         }\n     }"}, {"sha": "04514b4cf216d22f85be6a5ca5ca3c629f56cd7f", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -695,17 +695,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Figure out which discriminant and variant this corresponds to.\n         Ok(match *tag_encoding {\n             TagEncoding::Direct => {\n+                let scalar = tag_val.to_scalar()?;\n                 // Generate a specific error if `tag_val` is not an integer.\n                 // (`tag_bits` itself is only used for error messages below.)\n-                let tag_bits = tag_val\n-                    .to_scalar()?\n+                let tag_bits = scalar\n                     .try_to_int()\n                     .map_err(|dbg_val| err_ub!(InvalidTag(dbg_val)))?\n                     .assert_bits(tag_layout.size);\n                 // Cast bits from tag layout to discriminant layout.\n-                // After the checks we did above, this cannot fail.\n+                // After the checks we did above, this cannot fail, as\n+                // discriminants are int-like.\n                 let discr_val =\n-                    self.misc_cast(&tag_val, discr_layout.ty).unwrap().to_scalar().unwrap();\n+                    self.cast_from_int_like(scalar, tag_val.layout, discr_layout.ty).unwrap();\n                 let discr_bits = discr_val.assert_bits(discr_layout.size);\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match *op.layout.ty.kind() {"}, {"sha": "26da93b9dcebc90c45bf71a188037feec25477b4", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -120,9 +120,11 @@ pub trait Provenance: Copy + fmt::Debug {\n     where\n         Self: Sized;\n \n-    /// Provenance must always be able to identify the allocation this ptr points to.\n+    /// If `OFFSET_IS_ADDR == false`, provenance must always be able to\n+    /// identify the allocation this ptr points to (i.e., this must return `Some`).\n+    /// Otherwise this function is best-effort (but must agree with `Machine::ptr_get_alloc`).\n     /// (Identifying the offset in that allocation, however, is harder -- use `Memory::ptr_get_alloc` for that.)\n-    fn get_alloc_id(self) -> AllocId;\n+    fn get_alloc_id(self) -> Option<AllocId>;\n }\n \n impl Provenance for AllocId {\n@@ -147,8 +149,8 @@ impl Provenance for AllocId {\n         Ok(())\n     }\n \n-    fn get_alloc_id(self) -> AllocId {\n-        self\n+    fn get_alloc_id(self) -> Option<AllocId> {\n+        Some(self)\n     }\n }\n "}, {"sha": "eeee170f43f949d95d567581686923523189ac5c", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -344,7 +344,8 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n                 } else {\n                     // We know `offset` is relative, since `OFFSET_IS_ADDR == false`.\n                     let (tag, offset) = ptr.into_parts();\n-                    Err(Scalar::Ptr(Pointer::new(tag.get_alloc_id(), offset), sz))\n+                    // Because `OFFSET_IS_ADDR == false`, this unwrap can never fail.\n+                    Err(Scalar::Ptr(Pointer::new(tag.get_alloc_id().unwrap(), offset), sz))\n                 }\n             }\n         }"}, {"sha": "b1bc6986694cd5f621583c3a2f92aff6f4bc07a9", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -28,7 +28,8 @@ use crate::MirPass;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n     ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, MemoryKind, OpTy,\n-    Operand as InterpOperand, PlaceTy, Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n+    Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup,\n+    StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -285,6 +286,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         Ok(())\n     }\n \n+    #[inline(always)]\n+    fn expose_ptr(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _ptr: Pointer<AllocId>,\n+    ) -> InterpResult<'tcx> {\n+        throw_machine_stop_str!(\"exposing pointers isn't supported in ConstProp\")\n+    }\n+\n     #[inline(always)]\n     fn init_frame_extra(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "ec640fb72f5cbc9405ba26bb07f69d4ae38de018", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -30,8 +30,8 @@ use crate::MirLint;\n use rustc_const_eval::const_eval::ConstEvalErr;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalState, LocalValue, MemPlace, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Scalar,\n-    ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n+    LocalState, LocalValue, MemPlace, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n+    Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -280,6 +280,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         Ok(())\n     }\n \n+    #[inline(always)]\n+    fn expose_ptr(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _ptr: Pointer<AllocId>,\n+    ) -> InterpResult<'tcx> {\n+        throw_machine_stop_str!(\"exposing pointers isn't supported in ConstProp\")\n+    }\n+\n     #[inline(always)]\n     fn init_frame_extra(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "2beb531cc6890c5b4600f0391d187de7bec617aa", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -14,7 +14,7 @@ static CMP: () = {\n static PTR_INT_CAST: () = {\n     let x = &0 as *const _ as usize;\n     //~^ ERROR could not evaluate static initializer\n-    //~| unable to turn pointer into raw bytes\n+    //~| \"exposing pointers\" needs an rfc before being allowed inside constants\n     let _v = x == x;\n };\n "}, {"sha": "61d34e2e35df9d53269bc78977219405146654bd", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=bd5fce65c60ae83f37d0a46bac4e09e9fd30b2c2", "patch": "@@ -8,7 +8,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/ptr_arith.rs:15:13\n    |\n LL |     let x = &0 as *const _ as usize;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ \"exposing pointers\" needs an rfc before being allowed inside constants\n \n error[E0080]: could not evaluate static initializer\n   --> $DIR/ptr_arith.rs:23:14"}]}