{"sha": "8d2d2be6c61c17da8027a72da91f87a0e2487f74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMmQyYmU2YzYxYzE3ZGE4MDI3YTcyZGE5MWY4N2EwZTI0ODdmNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-26T01:09:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-26T01:09:28Z"}, "message": "Auto merge of #32293 - nikomatsakis:incr-comp-def-path-munging, r=alexcrichton\n\nRevamp symbol names for impls (and make them deterministic, etc)\n\nThis builds on @michaelwoerister's epic PR #31539 (note that his PR never landed, so I just incorporated it into this one). The main change here is that we remove the \"name\" from `DefPathData` for impls, since that name is synthetic and not sufficiently predictable for incr comp. However, just doing that would cause bad symbol names since those are based on the `DefPath`. Therefore, I introduce a new mechanism for getting symbol names (and also paths for user display) called `item_path`. This is kind of simplistic for now (based on strings) but I expect to expand it later to support richer types, hopefully generating C++-mangled names that gdb etc can understand. Along the way I cleaned up how we track the path that leads to an extern crate.\n\nThere is still some cleanup left undone here. Notably, I didn't remove the impl names altogether -- that would probably make sense. I also didn't try to remove the `item_symbols` vector. Mostly I want to unblock my other incr. comp. work. =)\n\nr? @eddyb\ncc @eddyb @alexcrichton @michaelwoerister", "tree": {"sha": "d48967badd66eabf6c53f32d0250ca1eba94ddf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d48967badd66eabf6c53f32d0250ca1eba94ddf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d2d2be6c61c17da8027a72da91f87a0e2487f74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2d2be6c61c17da8027a72da91f87a0e2487f74", "html_url": "https://github.com/rust-lang/rust/commit/8d2d2be6c61c17da8027a72da91f87a0e2487f74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d2d2be6c61c17da8027a72da91f87a0e2487f74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1e29daf1a9ca4e26719887b0c934de5d1695031", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e29daf1a9ca4e26719887b0c934de5d1695031", "html_url": "https://github.com/rust-lang/rust/commit/a1e29daf1a9ca4e26719887b0c934de5d1695031"}, {"sha": "1ea93c2a6388b7dcddf1ae89105a9f6f2e1da9f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea93c2a6388b7dcddf1ae89105a9f6f2e1da9f1", "html_url": "https://github.com/rust-lang/rust/commit/1ea93c2a6388b7dcddf1ae89105a9f6f2e1da9f1"}], "stats": {"total": 2492, "additions": 1833, "deletions": 659}, "files": [{"sha": "50c060c270a36420169d66c5d3da4e135c0cca0c", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -383,7 +383,7 @@ $(3)/stage$(1)/test/$(4)test-$(2)$$(X_$(2)): \\\n \t@$$(call E, rustc: $$@)\n \t$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(2)) \\\n \t    $$(subst @,,$$(STAGE$(1)_T_$(2)_H_$(3))) -o $$@ $$< --test \\\n-\t\t-L \"$$(RT_OUTPUT_DIR_$(2))\" \\\n+\t\t-Cmetadata=\"test-crate\" -L \"$$(RT_OUTPUT_DIR_$(2))\" \\\n \t\t$$(LLVM_LIBDIR_RUSTFLAGS_$(2)) \\\n \t\t$$(RUSTFLAGS_$(4))\n "}, {"sha": "bfcc1759b955d4aa6256ea5706bb3a17b4988537", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -69,10 +69,10 @@ impl fmt::Display for Mode {\n #[derive(Clone)]\n pub struct Config {\n     // The library paths required for running the compiler\n-    pub compile_lib_path: String,\n+    pub compile_lib_path: PathBuf,\n \n     // The library paths required for running compiled programs\n-    pub run_lib_path: String,\n+    pub run_lib_path: PathBuf,\n \n     // The rustc executable\n     pub rustc_path: PathBuf,"}, {"sha": "6c6a78a360b9eda4e65df952721e6a2e43832bbd", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -118,9 +118,17 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         }\n     }\n \n+    fn make_absolute(path: PathBuf) -> PathBuf {\n+        if path.is_relative() {\n+            env::current_dir().unwrap().join(path)\n+        } else {\n+            path\n+        }\n+    }\n+\n     Config {\n-        compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n-        run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n+        compile_lib_path: make_absolute(opt_path(matches, \"compile-lib-path\")),\n+        run_lib_path: make_absolute(opt_path(matches, \"run-lib-path\")),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n         rustdoc_path: opt_path(matches, \"rustdoc-path\"),\n         python: matches.opt_str(\"python\").unwrap(),"}, {"sha": "efad2038f82f793a3861220c1f98e58115dfdede", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -316,7 +316,7 @@ fn run_pretty_test_revision(config: &Config,\n                                      testpaths,\n                                      pretty_type.to_owned()),\n                         props.exec_env.clone(),\n-                        &config.compile_lib_path,\n+                        config.compile_lib_path.to_str().unwrap(),\n                         Some(aux_dir.to_str().unwrap()),\n                         Some(src))\n     }\n@@ -635,7 +635,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testpaths: &TestPa\n                                                   testpaths,\n                                                   proc_args,\n                                                   environment,\n-                                                  &config.run_lib_path,\n+                                                  config.run_lib_path.to_str().unwrap(),\n                                                   None,\n                                                   None);\n         }\n@@ -1315,7 +1315,7 @@ fn exec_compiled_test(config: &Config, props: &TestProps,\n                             testpaths,\n                             make_run_args(config, props, testpaths),\n                             env,\n-                            &config.run_lib_path,\n+                            config.run_lib_path.to_str().unwrap(),\n                             Some(aux_dir.to_str().unwrap()),\n                             None)\n         }\n@@ -1387,7 +1387,7 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n                                      &aux_testpaths,\n                                      aux_args,\n                                      Vec::new(),\n-                                     &config.compile_lib_path,\n+                                     config.compile_lib_path.to_str().unwrap(),\n                                      Some(aux_dir.to_str().unwrap()),\n                                      None);\n         if !auxres.status.success() {\n@@ -1410,7 +1410,7 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n                     testpaths,\n                     args,\n                     props.rustc_env.clone(),\n-                    &config.compile_lib_path,\n+                    config.compile_lib_path.to_str().unwrap(),\n                     Some(aux_dir.to_str().unwrap()),\n                     input)\n }"}, {"sha": "ef89b5d25b8875b04b443af9e220b01371524f76", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -166,15 +166,15 @@ impl<'doc> Doc<'doc> {\n         }\n     }\n \n-    pub fn get<'a>(&'a self, tag: usize) -> Doc<'a> {\n+    pub fn get(&self, tag: usize) -> Doc<'doc> {\n         reader::get_doc(*self, tag)\n     }\n \n     pub fn is_empty(&self) -> bool {\n         self.start == self.end\n     }\n \n-    pub fn as_str_slice<'a>(&'a self) -> &'a str {\n+    pub fn as_str_slice(&self) -> &'doc str {\n         str::from_utf8(&self.data[self.start..self.end]).unwrap()\n     }\n "}, {"sha": "4ae03b1b9d722d5ac8c62cad666e5afa90f2d95c", "filename": "src/librustc/front/map/collector.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -14,7 +14,7 @@ use super::MapEntry::*;\n use rustc_front::hir::*;\n use rustc_front::util;\n use rustc_front::intravisit::{self, Visitor};\n-use middle::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use middle::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n@@ -50,6 +50,7 @@ impl<'ast> NodeCollector<'ast> {\n                   parent: &'ast InlinedParent,\n                   parent_node: NodeId,\n                   parent_def_path: DefPath,\n+                  parent_def_id: DefId,\n                   map: Vec<MapEntry<'ast>>,\n                   definitions: Definitions)\n                   -> NodeCollector<'ast> {\n@@ -60,8 +61,14 @@ impl<'ast> NodeCollector<'ast> {\n             definitions: definitions,\n         };\n \n+        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n+        let root_path = Box::new(InlinedRootPath {\n+            data: parent_def_path.data,\n+            def_id: parent_def_id,\n+        });\n+\n         collector.insert_entry(parent_node, RootInlinedParent(parent));\n-        collector.create_def(parent_node, DefPathData::InlinedRoot(parent_def_path));\n+        collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n \n         collector\n     }\n@@ -126,11 +133,16 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         // Pick the def data. This need not be unique, but the more\n         // information we encapsulate into\n         let def_data = match i.node {\n-            ItemDefaultImpl(..) | ItemImpl(..) => DefPathData::Impl(i.name),\n-            ItemEnum(..) | ItemStruct(..) | ItemTrait(..) => DefPathData::Type(i.name),\n-            ItemExternCrate(..) | ItemMod(..) => DefPathData::Mod(i.name),\n-            ItemStatic(..) | ItemConst(..) | ItemFn(..) => DefPathData::Value(i.name),\n-            _ => DefPathData::Misc,\n+            ItemDefaultImpl(..) | ItemImpl(..) =>\n+                DefPathData::Impl,\n+            ItemEnum(..) | ItemStruct(..) | ItemTrait(..) |\n+            ItemExternCrate(..) | ItemMod(..) | ItemForeignMod(..) |\n+            ItemTy(..) =>\n+                DefPathData::TypeNs(i.name),\n+            ItemStatic(..) | ItemConst(..) | ItemFn(..) =>\n+                DefPathData::ValueNs(i.name),\n+            ItemUse(..) =>\n+                DefPathData::Misc,\n         };\n \n         self.insert_def(i.id, NodeItem(i), def_data);\n@@ -195,7 +207,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         self.insert_def(foreign_item.id,\n                         NodeForeignItem(foreign_item),\n-                        DefPathData::Value(foreign_item.name));\n+                        DefPathData::ValueNs(foreign_item.name));\n \n         let parent_node = self.parent_node;\n         self.parent_node = foreign_item.id;\n@@ -215,8 +227,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n         let def_data = match ti.node {\n-            MethodTraitItem(..) | ConstTraitItem(..) => DefPathData::Value(ti.name),\n-            TypeTraitItem(..) => DefPathData::Type(ti.name),\n+            MethodTraitItem(..) | ConstTraitItem(..) => DefPathData::ValueNs(ti.name),\n+            TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n         };\n \n         self.insert(ti.id, NodeTraitItem(ti));\n@@ -239,8 +251,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n         let def_data = match ii.node {\n-            ImplItemKind::Method(..) | ImplItemKind::Const(..) => DefPathData::Value(ii.name),\n-            ImplItemKind::Type(..) => DefPathData::Type(ii.name),\n+            ImplItemKind::Method(..) | ImplItemKind::Const(..) => DefPathData::ValueNs(ii.name),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n         };\n \n         self.insert_def(ii.id, NodeImplItem(ii), def_data);"}, {"sha": "82574b852297aba88db676c7186203bc0f1c0d07", "filename": "src/librustc/front/map/definitions.rs", "status": "modified", "additions": 84, "deletions": 42, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -59,23 +59,94 @@ pub struct DefData {\n     pub node_id: ast::NodeId,\n }\n \n-pub type DefPath = Vec<DisambiguatedDefPathData>;\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct DefPath {\n+    /// the path leading from the crate root to the item\n+    pub data: Vec<DisambiguatedDefPathData>,\n+\n+    /// what krate root is this path relative to?\n+    pub krate: ast::CrateNum,\n+}\n+\n+impl DefPath {\n+    pub fn is_local(&self) -> bool {\n+        self.krate == LOCAL_CRATE\n+    }\n+\n+    pub fn make<FN>(start_krate: ast::CrateNum,\n+                    start_index: DefIndex,\n+                    mut get_key: FN) -> DefPath\n+        where FN: FnMut(DefIndex) -> DefKey\n+    {\n+        let mut krate = start_krate;\n+        let mut data = vec![];\n+        let mut index = Some(start_index);\n+        loop {\n+            let p = index.unwrap();\n+            let key = get_key(p);\n+            match key.disambiguated_data.data {\n+                DefPathData::CrateRoot => {\n+                    assert!(key.parent.is_none());\n+                    break;\n+                }\n+                DefPathData::InlinedRoot(ref p) => {\n+                    assert!(key.parent.is_none());\n+                    assert!(!p.def_id.is_local());\n+                    data.extend(p.data.iter().cloned().rev());\n+                    krate = p.def_id.krate;\n+                    break;\n+                }\n+                _ => {\n+                    data.push(key.disambiguated_data);\n+                    index = key.parent;\n+                }\n+            }\n+        }\n+        data.reverse();\n+        DefPath { data: data, krate: krate }\n+    }\n+}\n+\n+/// Root of an inlined item. We track the `DefPath` of the item within\n+/// the original crate but also its def-id. This is kind of an\n+/// augmented version of a `DefPath` that includes a `DefId`. This is\n+/// all sort of ugly but the hope is that inlined items will be going\n+/// away soon anyway.\n+///\n+/// Some of the constraints that led to the current approach:\n+///\n+/// - I don't want to have a `DefId` in the main `DefPath` because\n+///   that gets serialized for incr. comp., and when reloaded the\n+///   `DefId` is no longer valid. I'd rather maintain the invariant\n+///   that every `DefId` is valid, and a potentially outdated `DefId` is\n+///   represented as a `DefPath`.\n+///   - (We don't serialize def-paths from inlined items, so it's ok to have one here.)\n+/// - We need to be able to extract the def-id from inline items to\n+///   make the symbol name. In theory we could retrace it from the\n+///   data, but the metadata doesn't have the required indices, and I\n+///   don't want to write the code to create one just for this.\n+/// - It may be that we don't actually need `data` at all. We'll have\n+///   to see about that.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct InlinedRootPath {\n+    pub data: Vec<DisambiguatedDefPathData>,\n+    pub def_id: DefId,\n+}\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n     CrateRoot,\n-    InlinedRoot(DefPath),\n+    InlinedRoot(Box<InlinedRootPath>),\n \n     // Catch-all for random DefId things like DUMMY_NODE_ID\n     Misc,\n \n     // Different kinds of items and item-like things:\n-    Impl(ast::Name),\n-    Type(ast::Name),\n-    Mod(ast::Name),\n-    Value(ast::Name),\n+    Impl,\n+    TypeNs(ast::Name), // something in the type NS\n+    ValueNs(ast::Name), // something in the value NS\n     MacroDef(ast::Name),\n     ClosureExpr,\n \n@@ -87,10 +158,6 @@ pub enum DefPathData {\n     StructCtor, // implicit ctor for a tuple-like struct\n     Initializer, // initializer for a const\n     Binding(ast::Name), // pattern binding\n-\n-    // An external crate that does not have an `extern crate` in this\n-    // crate.\n-    DetachedCrate(ast::Name),\n }\n \n impl Definitions {\n@@ -116,7 +183,7 @@ impl Definitions {\n     /// will be the path of the item in the external crate (but the\n     /// path will begin with the path to the external crate).\n     pub fn def_path(&self, index: DefIndex) -> DefPath {\n-        make_def_path(index, |p| self.def_key(p))\n+        DefPath::make(LOCAL_CRATE, index, |p| self.def_key(p))\n     }\n \n     pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n@@ -175,20 +242,21 @@ impl DefPathData {\n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n         match *self {\n-            Impl(name) |\n-            Type(name) |\n-            Mod(name) |\n-            Value(name) |\n+            TypeNs(name) |\n+            ValueNs(name) |\n             MacroDef(name) |\n             TypeParam(name) |\n             LifetimeDef(name) |\n             EnumVariant(name) |\n-            DetachedCrate(name) |\n             Binding(name) |\n             Field(name) => {\n                 name.as_str()\n             }\n \n+            Impl => {\n+                InternedString::new(\"{{impl}}\")\n+            }\n+\n             // note that this does not show up in user printouts\n             CrateRoot => {\n                 InternedString::new(\"{{root}}\")\n@@ -222,29 +290,3 @@ impl DefPathData {\n     }\n }\n \n-pub fn make_def_path<FN>(start_index: DefIndex, mut get_key: FN) -> DefPath\n-    where FN: FnMut(DefIndex) -> DefKey\n-{\n-    let mut result = vec![];\n-    let mut index = Some(start_index);\n-    while let Some(p) = index {\n-        let key = get_key(p);\n-        match key.disambiguated_data.data {\n-            DefPathData::CrateRoot => {\n-                assert!(key.parent.is_none());\n-                break;\n-            }\n-            DefPathData::InlinedRoot(ref p) => {\n-                assert!(key.parent.is_none());\n-                result.extend(p.iter().cloned().rev());\n-                break;\n-            }\n-            _ => {\n-                result.push(key.disambiguated_data);\n-                index = key.parent;\n-            }\n-        }\n-    }\n-    result.reverse();\n-    result\n-}"}, {"sha": "6d6f20c70ec4d28fdd6b21a1caf269bcc514feca", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -12,13 +12,14 @@ pub use self::Node::*;\n pub use self::PathElem::*;\n use self::MapEntry::*;\n use self::collector::NodeCollector;\n-pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData, DisambiguatedDefPathData};\n+pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n+                            DisambiguatedDefPathData, InlinedRootPath};\n \n use dep_graph::{DepGraph, DepNode};\n \n use middle::cstore::InlinedItem;\n use middle::cstore::InlinedItem as II;\n-use middle::def_id::DefId;\n+use middle::def_id::{CRATE_DEF_INDEX, DefId};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n@@ -322,7 +323,8 @@ impl<'ast> Map<'ast> {\n                     id = p,\n \n                 RootCrate |\n-                RootInlinedParent(_) => // FIXME(#2369) clarify story about cross-crate dep tracking\n+                RootInlinedParent(_) =>\n+                    // FIXME(#32015) clarify story about cross-crate dep tracking\n                     return DepNode::Krate,\n \n                 NotPresent =>\n@@ -386,6 +388,15 @@ impl<'ast> Map<'ast> {\n         self.forest.krate()\n     }\n \n+    /// Get the attributes on the krate. This is preferable to\n+    /// invoking `krate.attrs` because it registers a tighter\n+    /// dep-graph access.\n+    pub fn krate_attrs(&self) -> &'ast [ast::Attribute] {\n+        let crate_root_def_id = DefId::local(CRATE_DEF_INDEX);\n+        self.dep_graph.read(DepNode::Hir(crate_root_def_id));\n+        &self.forest.krate.attrs\n+    }\n+\n     /// Retrieve the Node corresponding to `id`, panicking if it cannot\n     /// be found.\n     pub fn get(&self, id: NodeId) -> Node<'ast> {\n@@ -958,6 +969,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           parent_path: Vec<PathElem>,\n                                           parent_def_path: DefPath,\n+                                          parent_def_id: DefId,\n                                           ii: InlinedItem,\n                                           fold_ops: F)\n                                           -> &'ast InlinedItem {\n@@ -987,6 +999,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             ii_parent,\n             ii_parent_id,\n             parent_def_path,\n+            parent_def_id,\n             mem::replace(&mut *map.map.borrow_mut(), vec![]),\n             mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n     ii_parent.ii.visit(&mut collector);"}, {"sha": "7cad9b10f85ec2a16d44f1c56646112de8d86707", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -42,6 +42,7 @@ use syntax::ast_util::{IdVisitingOperation};\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n+use syntax::parse::token::InternedString;\n use rustc_back::target::Target;\n use rustc_front::hir;\n use rustc_front::intravisit::Visitor;\n@@ -126,6 +127,27 @@ pub enum FoundAst<'ast> {\n     NotFound,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct ExternCrate {\n+    /// def_id of an `extern crate` in the current crate that caused\n+    /// this crate to be loaded; note that there could be multiple\n+    /// such ids\n+    pub def_id: DefId,\n+\n+    /// span of the extern crate that caused this to be loaded\n+    pub span: Span,\n+\n+    /// If true, then this crate is the crate named by the extern\n+    /// crate referenced above. If false, then this crate is a dep\n+    /// of the crate.\n+    pub direct: bool,\n+\n+    /// Number of links to reach the extern crate `def_id`\n+    /// declaration; used to select the extern crate with the shortest\n+    /// path\n+    pub path_len: usize,\n+}\n+\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n ///\n@@ -146,7 +168,7 @@ pub trait CrateStore<'tcx> : Any {\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                  -> ty::TypeScheme<'tcx>;\n-    fn item_path(&self, def: DefId) -> Vec<hir_map::PathElem>;\n+    fn relative_item_path(&self, def: DefId) -> Vec<hir_map::PathElem>;\n     fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem>;\n     fn item_name(&self, def: DefId) -> ast::Name;\n     fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n@@ -202,17 +224,24 @@ pub trait CrateStore<'tcx> : Any {\n     fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n     fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n     fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n+    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>;\n     fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>;\n-    fn crate_name(&self, cnum: ast::CrateNum) -> String;\n+    /// The name of the crate as it is referred to in source code of the current\n+    /// crate.\n+    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n+    /// The name of the crate as it is stored in the crate's metadata.\n+    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n     fn crate_hash(&self, cnum: ast::CrateNum) -> Svh;\n+    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> InternedString;\n     fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n                                 -> FnvHashMap<DefId, Vec<ast::Attribute>>;\n     fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>;\n     fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>;\n     fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n \n     // resolve\n-    fn def_path(&self, def: DefId) -> hir_map::DefPath;\n+    fn def_key(&self, def: DefId) -> hir_map::DefKey;\n+    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind>;\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n@@ -236,7 +265,11 @@ pub trait CrateStore<'tcx> : Any {\n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn encode_type(&self, tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> Vec<u8>;\n+    fn encode_type(&self,\n+                   tcx: &TyCtxt<'tcx>,\n+                   ty: Ty<'tcx>,\n+                   def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n+                   -> Vec<u8>;\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n     fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n@@ -313,7 +346,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { unimplemented!() }\n     fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                  -> ty::TypeScheme<'tcx> { unimplemented!() }\n-    fn item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { unimplemented!() }\n+    fn relative_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { unimplemented!() }\n     fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { unimplemented!() }\n     fn item_name(&self, def: DefId) -> ast::Name { unimplemented!() }\n     fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n@@ -376,10 +409,15 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n     fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n     fn is_allocator(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n+    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate> { unimplemented!() }\n     fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n         { unimplemented!() }\n-    fn crate_name(&self, cnum: ast::CrateNum) -> String { unimplemented!() }\n+    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString { unimplemented!() }\n+    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString {\n+        unimplemented!()\n+    }\n     fn crate_hash(&self, cnum: ast::CrateNum) -> Svh { unimplemented!() }\n+    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> InternedString { unimplemented!() }\n     fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n                                 -> FnvHashMap<DefId, Vec<ast::Attribute>>\n         { unimplemented!() }\n@@ -390,7 +428,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId> { unimplemented!() }\n \n     // resolve\n-    fn def_path(&self, def: DefId) -> hir_map::DefPath { unimplemented!() }\n+    fn def_key(&self, def: DefId) -> hir_map::DefKey { unimplemented!() }\n+    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath { unimplemented!() }\n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { unimplemented!() }\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n         { unimplemented!() }\n@@ -419,8 +458,13 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // utility functions\n     fn metadata_filename(&self) -> &str { unimplemented!() }\n     fn metadata_section_name(&self, target: &Target) -> &str { unimplemented!() }\n-    fn encode_type(&self, tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> Vec<u8>\n-        { unimplemented!() }\n+    fn encode_type(&self,\n+                   tcx: &TyCtxt<'tcx>,\n+                   ty: Ty<'tcx>,\n+                   def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n+                   -> Vec<u8> {\n+        unimplemented!()\n+    }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { unimplemented!() }"}, {"sha": "b2ba8a7a5f99fa98f288830ced05cd68acc5c48f", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -398,7 +398,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                          // purposes of the ancestor check, we retain\n                          // the invariant that all type variables are\n                          // fully refreshed.\n-                         if !(&mut is_ancestor)(&obligation.predicate) {\n+                         if !is_ancestor(&obligation.predicate) {\n                              return None;\n                          }\n                      }"}, {"sha": "6acd094c1f90d5be6fcbe941b5ea835eb8b647b7", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -15,7 +15,7 @@ use front::map as ast_map;\n use session::Session;\n use lint;\n use middle;\n-use middle::cstore::CrateStore;\n+use middle::cstore::{CrateStore, LOCAL_CRATE};\n use middle::def::DefMap;\n use middle::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n@@ -43,7 +43,7 @@ use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{self, special_idents};\n \n use rustc_front::hir;\n \n@@ -415,9 +415,29 @@ pub struct TyCtxt<'tcx> {\n     /// fragmented data to the set of unfragmented pieces that\n     /// constitute it.\n     pub fragment_infos: RefCell<DefIdMap<Vec<ty::FragmentInfo>>>,\n+\n+    /// The definite name of the current crate after taking into account\n+    /// attributes, commandline parameters, etc.\n+    pub crate_name: token::InternedString,\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n+    pub fn crate_name(&self, cnum: ast::CrateNum) -> token::InternedString {\n+        if cnum == LOCAL_CRATE {\n+            self.crate_name.clone()\n+        } else {\n+            self.sess.cstore.crate_name(cnum)\n+        }\n+    }\n+\n+    pub fn crate_disambiguator(&self, cnum: ast::CrateNum) -> token::InternedString {\n+        if cnum == LOCAL_CRATE {\n+            self.sess.crate_disambiguator.get().as_str()\n+        } else {\n+            self.sess.cstore.crate_name(cnum)\n+        }\n+    }\n+\n     pub fn type_parameter_def(&self,\n                               node_id: NodeId)\n                               -> ty::TypeParameterDef<'tcx>\n@@ -511,6 +531,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                  region_maps: RegionMaps,\n                                  lang_items: middle::lang_items::LanguageItems,\n                                  stability: stability::Index<'tcx>,\n+                                 crate_name: &str,\n                                  f: F) -> R\n                                  where F: FnOnce(&TyCtxt<'tcx>) -> R\n     {\n@@ -570,7 +591,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             const_qualif_map: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n-            fragment_infos: RefCell::new(DefIdMap())\n+            fragment_infos: RefCell::new(DefIdMap()),\n+            crate_name: token::intern_and_get_ident(crate_name),\n        }, f)\n     }\n }"}, {"sha": "147230f5bdcd0ac0bc0ee15086027c2504ed6af1", "filename": "src/librustc/middle/ty/item_path.rs", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fitem_path.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,317 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use front::map::DefPathData;\n+use middle::cstore::LOCAL_CRATE;\n+use middle::def_id::DefId;\n+use middle::ty::{self, Ty, TyCtxt};\n+use syntax::ast;\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// Returns a string identifying this def-id. This string is\n+    /// suitable for user output. It is relative to the current crate\n+    /// root.\n+    pub fn item_path_str(&self, def_id: DefId) -> String {\n+        let mut buffer = LocalPathBuffer::new(RootMode::Local);\n+        self.push_item_path(&mut buffer, def_id);\n+        buffer.into_string()\n+    }\n+\n+    /// Returns a string identifying this def-id. This string is\n+    /// suitable for user output. It always begins with a crate identifier.\n+    pub fn absolute_item_path_str(&self, def_id: DefId) -> String {\n+        let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n+        self.push_item_path(&mut buffer, def_id);\n+        buffer.into_string()\n+    }\n+\n+    /// Returns the \"path\" to a particular crate. This can proceed in\n+    /// various ways, depending on the `root_mode` of the `buffer`.\n+    /// (See `RootMode` enum for more details.)\n+    pub fn push_krate_path<T>(&self, buffer: &mut T, cnum: ast::CrateNum)\n+        where T: ItemPathBuffer\n+    {\n+        match *buffer.root_mode() {\n+            RootMode::Local => {\n+                // In local mode, when we encounter a crate other than\n+                // LOCAL_CRATE, execution proceeds in one of two ways:\n+                //\n+                // 1. for a direct dependency, where user added an\n+                //    `extern crate` manually, we put the `extern\n+                //    crate` as the parent. So you wind up with\n+                //    something relative to the current crate.\n+                // 2. for an indirect crate, where there is no extern\n+                //    crate, we just prepend the crate name.\n+                //\n+                // Returns `None` for the local crate.\n+                if cnum != LOCAL_CRATE {\n+                    let opt_extern_crate = self.sess.cstore.extern_crate(cnum);\n+                    let opt_extern_crate = opt_extern_crate.and_then(|extern_crate| {\n+                        if extern_crate.direct {\n+                            Some(extern_crate.def_id)\n+                        } else {\n+                            None\n+                        }\n+                    });\n+                    if let Some(extern_crate_def_id) = opt_extern_crate {\n+                        self.push_item_path(buffer, extern_crate_def_id);\n+                    } else {\n+                        buffer.push(&self.crate_name(cnum));\n+                    }\n+                }\n+            }\n+            RootMode::Absolute => {\n+                // In absolute mode, just write the crate name\n+                // unconditionally.\n+                buffer.push(&self.crate_name(cnum));\n+            }\n+        }\n+    }\n+\n+    pub fn push_item_path<T>(&self, buffer: &mut T, def_id: DefId)\n+        where T: ItemPathBuffer\n+    {\n+        let key = self.def_key(def_id);\n+        match key.disambiguated_data.data {\n+            DefPathData::CrateRoot => {\n+                assert!(key.parent.is_none());\n+                self.push_krate_path(buffer, def_id.krate);\n+            }\n+\n+            DefPathData::InlinedRoot(ref root_path) => {\n+                assert!(key.parent.is_none());\n+                self.push_item_path(buffer, root_path.def_id);\n+            }\n+\n+            DefPathData::Impl => {\n+                self.push_impl_path(buffer, def_id);\n+            }\n+\n+            // Unclear if there is any value in distinguishing these.\n+            // Probably eventually (and maybe we would even want\n+            // finer-grained distinctions, e.g. between enum/struct).\n+            data @ DefPathData::Misc |\n+            data @ DefPathData::TypeNs(..) |\n+            data @ DefPathData::ValueNs(..) |\n+            data @ DefPathData::TypeParam(..) |\n+            data @ DefPathData::LifetimeDef(..) |\n+            data @ DefPathData::EnumVariant(..) |\n+            data @ DefPathData::Field(..) |\n+            data @ DefPathData::StructCtor |\n+            data @ DefPathData::Initializer |\n+            data @ DefPathData::MacroDef(..) |\n+            data @ DefPathData::ClosureExpr |\n+            data @ DefPathData::Binding(..) => {\n+                let parent_def_id = self.parent_def_id(def_id).unwrap();\n+                self.push_item_path(buffer, parent_def_id);\n+                buffer.push(&data.as_interned_str());\n+            }\n+        }\n+    }\n+\n+    fn push_impl_path<T>(&self,\n+                         buffer: &mut T,\n+                         impl_def_id: DefId)\n+        where T: ItemPathBuffer\n+    {\n+        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n+\n+        let use_types = if !impl_def_id.is_local() {\n+            // always have full types available for extern crates\n+            true\n+        } else {\n+            // for local crates, check whether type info is\n+            // available; typeck might not have completed yet\n+            self.impl_trait_refs.borrow().contains_key(&impl_def_id)\n+        };\n+\n+        if !use_types {\n+            return self.push_impl_path_fallback(buffer, impl_def_id);\n+        }\n+\n+        // Decide whether to print the parent path for the impl.\n+        // Logically, since impls are global, it's never needed, but\n+        // users may find it useful. Currently, we omit the parent if\n+        // the impl is either in the same module as the self-type or\n+        // as the trait.\n+        let self_ty = self.lookup_item_type(impl_def_id).ty;\n+        let in_self_mod = match self.characteristic_def_id_of_type(self_ty) {\n+            None => false,\n+            Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),\n+        };\n+\n+        let impl_trait_ref = self.impl_trait_ref(impl_def_id);\n+        let in_trait_mod = match impl_trait_ref {\n+            None => false,\n+            Some(trait_ref) => self.parent_def_id(trait_ref.def_id) == Some(parent_def_id),\n+        };\n+\n+        if !in_self_mod && !in_trait_mod {\n+            // If the impl is not co-located with either self-type or\n+            // trait-type, then fallback to a format that identifies\n+            // the module more clearly.\n+            self.push_item_path(buffer, parent_def_id);\n+            if let Some(trait_ref) = impl_trait_ref {\n+                buffer.push(&format!(\"<impl {} for {}>\", trait_ref, self_ty));\n+            } else {\n+                buffer.push(&format!(\"<impl {}>\", self_ty));\n+            }\n+            return;\n+        }\n+\n+        // Otherwise, try to give a good form that would be valid language\n+        // syntax. Preferably using associated item notation.\n+\n+        if let Some(trait_ref) = impl_trait_ref {\n+            // Trait impls.\n+            buffer.push(&format!(\"<{} as {}>\",\n+                                 self_ty,\n+                                 trait_ref));\n+            return;\n+        }\n+\n+        // Inherent impls. Try to print `Foo::bar` for an inherent\n+        // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n+        // anything other than a simple path.\n+        match self_ty.sty {\n+            ty::TyStruct(adt_def, substs) |\n+            ty::TyEnum(adt_def, substs) => {\n+                if substs.types.is_empty() { // ignore regions\n+                    self.push_item_path(buffer, adt_def.did);\n+                } else {\n+                    buffer.push(&format!(\"<{}>\", self_ty));\n+                }\n+            }\n+\n+            ty::TyBool |\n+            ty::TyChar |\n+            ty::TyInt(_) |\n+            ty::TyUint(_) |\n+            ty::TyFloat(_) |\n+            ty::TyStr => {\n+                buffer.push(&format!(\"{}\", self_ty));\n+            }\n+\n+            _ => {\n+                buffer.push(&format!(\"<{}>\", self_ty));\n+            }\n+        }\n+    }\n+\n+    fn push_impl_path_fallback<T>(&self,\n+                                  buffer: &mut T,\n+                                  impl_def_id: DefId)\n+        where T: ItemPathBuffer\n+    {\n+        // If no type info is available, fall back to\n+        // pretty printing some span information. This should\n+        // only occur very early in the compiler pipeline.\n+        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n+        self.push_item_path(buffer, parent_def_id);\n+        let node_id = self.map.as_local_node_id(impl_def_id).unwrap();\n+        let item = self.map.expect_item(node_id);\n+        let span_str = self.sess.codemap().span_to_string(item.span);\n+        buffer.push(&format!(\"<impl at {}>\", span_str));\n+    }\n+\n+    /// As a heuristic, when we see an impl, if we see that the\n+    /// 'self-type' is a type defined in the same module as the impl,\n+    /// we can omit including the path to the impl itself. This\n+    /// function tries to find a \"characteristic def-id\" for a\n+    /// type. It's just a heuristic so it makes some questionable\n+    /// decisions and we may want to adjust it later.\n+    fn characteristic_def_id_of_type(&self, ty: Ty<'tcx>) -> Option<DefId> {\n+        match ty.sty {\n+            ty::TyStruct(adt_def, _) |\n+            ty::TyEnum(adt_def, _) =>\n+                Some(adt_def.did),\n+\n+            ty::TyTrait(ref data) =>\n+                Some(data.principal_def_id()),\n+\n+            ty::TyBox(subty) =>\n+                self.characteristic_def_id_of_type(subty),\n+\n+            ty::TyRawPtr(mt) |\n+            ty::TyRef(_, mt) =>\n+                self.characteristic_def_id_of_type(mt.ty),\n+\n+            ty::TyTuple(ref tys) =>\n+                tys.iter()\n+                   .filter_map(|ty| self.characteristic_def_id_of_type(ty))\n+                   .next(),\n+\n+            _ =>\n+                None\n+        }\n+    }\n+\n+    /// Returns the def-id of `def_id`'s parent in the def tree. If\n+    /// this returns `None`, then `def_id` represents a crate root or\n+    /// inlined root.\n+    fn parent_def_id(&self, def_id: DefId) -> Option<DefId> {\n+        let key = self.def_key(def_id);\n+        key.parent.map(|index| DefId { krate: def_id.krate, index: index })\n+    }\n+}\n+\n+/// Unifying Trait for different kinds of item paths we might\n+/// construct. The basic interface is that components get pushed: the\n+/// instance can also customize how we handle the root of a crate.\n+pub trait ItemPathBuffer {\n+    fn root_mode(&self) -> &RootMode;\n+    fn push(&mut self, text: &str);\n+}\n+\n+#[derive(Debug)]\n+pub enum RootMode {\n+    /// Try to make a path relative to the local crate.  In\n+    /// particular, local paths have no prefix, and if the path comes\n+    /// from an extern crate, start with the path to the `extern\n+    /// crate` declaration.\n+    Local,\n+\n+    /// Always prepend the crate name to the path, forming an absolute\n+    /// path from within a given set of crates.\n+    Absolute,\n+}\n+\n+#[derive(Debug)]\n+struct LocalPathBuffer {\n+    root_mode: RootMode,\n+    str: String,\n+}\n+\n+impl LocalPathBuffer {\n+    fn new(root_mode: RootMode) -> LocalPathBuffer {\n+        LocalPathBuffer {\n+            root_mode: root_mode,\n+            str: String::new()\n+        }\n+    }\n+\n+    fn into_string(self) -> String {\n+        self.str\n+    }\n+\n+}\n+\n+impl ItemPathBuffer for LocalPathBuffer {\n+    fn root_mode(&self) -> &RootMode {\n+        &self.root_mode\n+    }\n+\n+    fn push(&mut self, text: &str) {\n+        if !self.str.is_empty() {\n+            self.str.push_str(\"::\");\n+        }\n+        self.str.push_str(text);\n+    }\n+}"}, {"sha": "a4c3e82b6335db7472435cff21dda19edff0f1bd", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -86,6 +86,7 @@ pub mod cast;\n pub mod error;\n pub mod fast_reject;\n pub mod fold;\n+pub mod item_path;\n pub mod _match;\n pub mod maps;\n pub mod outlives;\n@@ -2218,15 +2219,22 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n     }\n \n-    pub fn item_path_str(&self, id: DefId) -> String {\n-        self.with_path(id, |path| ast_map::path_to_string(path))\n+    pub fn def_key(&self, id: DefId) -> ast_map::DefKey {\n+        if id.is_local() {\n+            self.map.def_key(id)\n+        } else {\n+            self.sess.cstore.def_key(id)\n+        }\n     }\n \n+    /// Returns the `DefPath` of an item. Note that if `id` is not\n+    /// local to this crate -- or is inlined into this crate -- the\n+    /// result will be a non-local `DefPath`.\n     pub fn def_path(&self, id: DefId) -> ast_map::DefPath {\n         if id.is_local() {\n             self.map.def_path(id)\n         } else {\n-            self.sess.cstore.def_path(id)\n+            self.sess.cstore.relative_def_path(id)\n         }\n     }\n \n@@ -2236,7 +2244,27 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.with_path(id, f)\n         } else {\n-            f(self.sess.cstore.item_path(id).iter().cloned().chain(LinkedPath::empty()))\n+            let mut path: Vec<_>;\n+            if let Some(extern_crate) = self.sess.cstore.extern_crate(id.krate) {\n+                if !extern_crate.direct {\n+                    // this comes from some crate that we don't have a direct\n+                    // path to; we'll settle for just prepending the name of\n+                    // the crate.\n+                    path = self.sess.cstore.extern_item_path(id)\n+                } else {\n+                    // start with the path to the extern crate, then\n+                    // add the relative path to the actual item\n+                    fn collector(elems: ast_map::PathElems) -> Vec<ast_map::PathElem> {\n+                        elems.collect()\n+                    }\n+                    path = self.with_path(extern_crate.def_id, collector);\n+                    path.extend(self.sess.cstore.relative_item_path(id));\n+                }\n+            } else {\n+                // if this was injected, just make a path with name of crate\n+                path = self.sess.cstore.extern_item_path(id);\n+            }\n+            f(path.iter().cloned().chain(LinkedPath::empty()))\n         }\n     }\n \n@@ -2680,9 +2708,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     {\n         dep_graph::visit_all_items_in_krate(self, dep_node_fn, visitor);\n     }\n+\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n-    pub fn span_of_impl(&self, impl_did: DefId) -> Result<Span, String> {\n+    pub fn span_of_impl(&self, impl_did: DefId) -> Result<Span, InternedString> {\n         if impl_did.is_local() {\n             let node_id = self.map.as_local_node_id(impl_did).unwrap();\n             Ok(self.map.span(node_id))"}, {"sha": "3e6878408681c7f46ab639f116e0ec847230c0fe", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -24,6 +24,7 @@ use syntax::diagnostics;\n use syntax::feature_gate;\n use syntax::parse;\n use syntax::parse::ParseSess;\n+use syntax::parse::token;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n \n@@ -64,7 +65,12 @@ pub struct Session {\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n-    pub crate_metadata: RefCell<Vec<String>>,\n+    // The crate_disambiguator is constructed out of all the `-C metadata`\n+    // arguments passed to the compiler. Its value together with the crate-name\n+    // forms a unique global identifier for the crate. It is used to allow\n+    // multiple crates with the same name to coexist. See the\n+    // trans::back::symbol_names module for more information.\n+    pub crate_disambiguator: Cell<ast::Name>,\n     pub features: RefCell<feature_gate::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n@@ -481,7 +487,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n-        crate_metadata: RefCell::new(Vec::new()),\n+        crate_disambiguator: Cell::new(token::intern(\"\")),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n         next_node_id: Cell::new(1),"}, {"sha": "ec607314f45c0f35e9edd146b6ea994a8486aea7", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -66,7 +66,7 @@ impl Svh {\n         &self.hash\n     }\n \n-    pub fn calculate(metadata: &Vec<String>, krate: &hir::Crate) -> Svh {\n+    pub fn calculate(crate_disambiguator: &str, krate: &hir::Crate) -> Svh {\n         // FIXME (#14132): This is better than it used to be, but it still not\n         // ideal. We now attempt to hash only the relevant portions of the\n         // Crate AST as well as the top-level crate attributes. (However,\n@@ -78,9 +78,9 @@ impl Svh {\n         //        avoid collisions.\n         let mut state = SipHasher::new();\n \n-        for data in metadata {\n-            data.hash(&mut state);\n-        }\n+        \"crate_disambiguator\".hash(&mut state);\n+        crate_disambiguator.len().hash(&mut state);\n+        crate_disambiguator.hash(&mut state);\n \n         {\n             let mut visit = svh_visitor::make(&mut state, krate);"}, {"sha": "96e819ea91feee86296af2dd5b98687f5939701b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::middle::ty::TyCtxt;\n use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n+use rustc_back::sha2::{Sha256, Digest};\n use rustc_borrowck as borrowck;\n use rustc_resolve as resolve;\n use rustc_metadata::macro_import;\n@@ -500,7 +501,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     })?;\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n-    *sess.crate_metadata.borrow_mut() = collect_crate_metadata(sess, &krate.attrs);\n+    sess.crate_disambiguator.set(token::intern(&compute_crate_disambiguator(sess)));\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -525,11 +526,15 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     let macros = time(time_passes,\n                       \"macro loading\",\n-                      || macro_import::read_macro_defs(sess, &cstore, &krate));\n+                      || macro_import::read_macro_defs(sess, &cstore, &krate, crate_name));\n \n     let mut addl_plugins = Some(addl_plugins);\n     let registrars = time(time_passes, \"plugin loading\", || {\n-        plugin::load::load_plugins(sess, &cstore, &krate, addl_plugins.take().unwrap())\n+        plugin::load::load_plugins(sess,\n+                                   &cstore,\n+                                   &krate,\n+                                   crate_name,\n+                                   addl_plugins.take().unwrap())\n     });\n \n     let mut registry = Registry::new(sess, &krate);\n@@ -754,7 +759,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n          \"external crate/lib resolution\",\n-         || LocalCrateReader::new(sess, cstore, &hir_map).read_crates());\n+         || LocalCrateReader::new(sess, cstore, &hir_map, name).read_crates());\n \n     let lang_items = time(time_passes, \"language item collection\", || {\n         sess.track_errors(|| {\n@@ -817,6 +822,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                region_map,\n                                lang_items,\n                                index,\n+                               name,\n                                |tcx| {\n         // passes are timed inside typeck\n         try_with_f!(typeck::check_crate(tcx, trait_map), (tcx, None, analysis));\n@@ -1121,8 +1127,34 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n         .collect()\n }\n \n-pub fn collect_crate_metadata(session: &Session, _attrs: &[ast::Attribute]) -> Vec<String> {\n-    session.opts.cg.metadata.clone()\n+pub fn compute_crate_disambiguator(session: &Session) -> String {\n+    let mut hasher = Sha256::new();\n+\n+    let mut metadata = session.opts.cg.metadata.clone();\n+    // We don't want the crate_disambiguator to dependent on the order\n+    // -C metadata arguments, so sort them:\n+    metadata.sort();\n+    // Every distinct -C metadata value is only incorporated once:\n+    metadata.dedup();\n+\n+    hasher.input_str(\"metadata\");\n+    for s in &metadata {\n+        // Also incorporate the length of a metadata string, so that we generate\n+        // different values for `-Cmetadata=ab -Cmetadata=c` and\n+        // `-Cmetadata=a -Cmetadata=bc`\n+        hasher.input_str(&format!(\"{}\", s.len())[..]);\n+        hasher.input_str(&s[..]);\n+    }\n+\n+    let mut hash = hasher.result_str();\n+\n+    // If this is an executable, add a special suffix, so that we don't get\n+    // symbol conflicts when linking against a library of the same name.\n+    if session.crate_types.borrow().contains(&config::CrateTypeExecutable) {\n+       hash.push_str(\"-exe\");\n+    }\n+\n+    hash\n }\n \n pub fn build_output_filenames(input: &Input,"}, {"sha": "9ba6abb962ead169131ec83098efe2681ad9795b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -568,8 +568,6 @@ impl RustcDefaultCalls {\n                         continue;\n                     }\n                     let crate_types = driver::collect_crate_types(sess, attrs);\n-                    let metadata = driver::collect_crate_metadata(sess, attrs);\n-                    *sess.crate_metadata.borrow_mut() = metadata;\n                     for &style in &crate_types {\n                         let fname = link::filename_for_input(sess, style, &id, &t_outputs);\n                         println!(\"{}\","}, {"sha": "111db3b1d38908726943ee77ad4b7f198d644196", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -146,6 +146,7 @@ fn test_env<F>(source_string: &str,\n                                region_map,\n                                lang_items,\n                                index,\n+                               \"test_crate\",\n                                |tcx| {\n                                    let infcx = infer::new_infer_ctxt(tcx,\n                                                                      &tcx.tables,"}, {"sha": "60f7110764699eeacbae0dfdd10ea8abb1291a5c", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -125,6 +125,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &TyCtxt<'tcx>,\n                                  parent_path: Vec<ast_map::PathElem>,\n                                  parent_def_path: ast_map::DefPath,\n+                                 parent_did: DefId,\n                                  ast_doc: rbml::Doc,\n                                  orig_did: DefId)\n                                  -> &'tcx InlinedItem {\n@@ -149,6 +150,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n     let ii = ast_map::map_decoded_item(&dcx.tcx.map,\n                                        parent_path,\n                                        parent_def_path,\n+                                       parent_did,\n                                        decode_ast(ast_doc),\n                                        dcx);\n     let name = match *ii {\n@@ -349,8 +351,8 @@ fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n     }\n }\n \n-fn decode_ast(par_doc: rbml::Doc) -> InlinedItem {\n-    let chi_doc = par_doc.get(c::tag_tree as usize);\n+fn decode_ast(item_doc: rbml::Doc) -> InlinedItem {\n+    let chi_doc = item_doc.get(c::tag_tree as usize);\n     let mut rbml_r = reader::Decoder::new(chi_doc);\n     rbml_r.read_opaque(|decoder, _| Decodable::decode(decoder)).unwrap()\n }\n@@ -1280,8 +1282,8 @@ fn encode_item_ast(rbml_w: &mut Encoder, item: &hir::Item) {\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: rbml::Doc) -> hir::Item {\n-    let chi_doc = par_doc.get(c::tag_tree as usize);\n+fn decode_item_ast(item_doc: rbml::Doc) -> hir::Item {\n+    let chi_doc = item_doc.get(c::tag_tree as usize);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n }"}, {"sha": "22a5289f02be88961ec8c77788ba6fcdd9e63613", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -73,6 +73,7 @@ pub const tag_crate_dep: usize = 0x35;\n \n pub const tag_crate_hash: usize = 0x103; // top-level only\n pub const tag_crate_crate_name: usize = 0x104; // top-level only\n+pub const tag_crate_disambiguator: usize = 0x113; // top-level only\n \n pub const tag_crate_dep_crate_name: usize = 0x36;\n pub const tag_crate_dep_hash: usize = 0x37;"}, {"sha": "d07179749d9ab2dd9cc2271cdfa167beac05cb8f", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 103, "deletions": 31, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -21,7 +21,7 @@ use rustc::back::svh::Svh;\n use rustc::dep_graph::DepNode;\n use rustc::session::{config, Session};\n use rustc::session::search_paths::PathKind;\n-use rustc::middle::cstore::{CrateStore, validate_crate_name};\n+use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n use rustc::util::nodemap::FnvHashMap;\n use rustc::front::map as hir_map;\n \n@@ -38,7 +38,6 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::errors::FatalError;\n use syntax::parse::token::InternedString;\n-use syntax::util::small_vector::SmallVector;\n use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n use log;\n@@ -55,6 +54,7 @@ pub struct CrateReader<'a> {\n     cstore: &'a CStore,\n     next_crate_num: ast::CrateNum,\n     foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n+    local_crate_name: String,\n }\n \n impl<'a, 'b, 'hir> Visitor<'hir> for LocalCrateReader<'a, 'b> {\n@@ -146,12 +146,15 @@ impl PMDSource {\n }\n \n impl<'a> CrateReader<'a> {\n-    pub fn new(sess: &'a Session, cstore: &'a CStore) -> CrateReader<'a> {\n+    pub fn new(sess: &'a Session,\n+               cstore: &'a CStore,\n+               local_crate_name: &str) -> CrateReader<'a> {\n         CrateReader {\n             sess: sess,\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n             foreign_item_map: FnvHashMap(),\n+            local_crate_name: local_crate_name.to_owned(),\n         }\n     }\n \n@@ -272,6 +275,38 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n+    fn verify_no_symbol_conflicts(&self,\n+                                  span: Span,\n+                                  metadata: &MetadataBlob) {\n+        let disambiguator = decoder::get_crate_disambiguator(metadata.as_slice());\n+        let crate_name = decoder::get_crate_name(metadata.as_slice());\n+\n+        // Check for (potential) conflicts with the local crate\n+        if self.local_crate_name == crate_name &&\n+           self.sess.crate_disambiguator.get().as_str() == disambiguator {\n+            span_fatal!(self.sess, span, E0519,\n+                        \"the current crate is indistinguishable from one of its \\\n+                         dependencies: it has the same crate-name `{}` and was \\\n+                         compiled with the same `-C metadata` arguments. This \\\n+                         will result in symbol conflicts between the two.\",\n+                        crate_name)\n+        }\n+\n+        let svh = decoder::get_crate_hash(metadata.as_slice());\n+        // Check for conflicts with any crate loaded so far\n+        self.cstore.iter_crate_data(|_, other| {\n+            if other.name() == crate_name && // same crate-name\n+               other.disambiguator() == disambiguator &&  // same crate-disambiguator\n+               other.hash() != svh { // but different SVH\n+                span_fatal!(self.sess, span, E0523,\n+                        \"found two different crates with name `{}` that are \\\n+                         not distinguished by differing `-C metadata`. This \\\n+                         will result in symbol conflicts between the two.\",\n+                        crate_name)\n+            }\n+        });\n+    }\n+\n     fn register_crate(&mut self,\n                       root: &Option<CratePaths>,\n                       ident: &str,\n@@ -282,6 +317,7 @@ impl<'a> CrateReader<'a> {\n                       -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n                           cstore::CrateSource) {\n         self.verify_rustc_version(name, span, &lib.metadata);\n+        self.verify_no_symbol_conflicts(span, &lib.metadata);\n \n         // Claim this crate number and cache it\n         let cnum = self.next_crate_num;\n@@ -307,15 +343,13 @@ impl<'a> CrateReader<'a> {\n \n         let cmeta = Rc::new(cstore::crate_metadata {\n             name: name.to_string(),\n-            local_path: RefCell::new(SmallVector::zero()),\n-            local_def_path: RefCell::new(vec![]),\n+            extern_crate: Cell::new(None),\n             index: decoder::load_index(metadata.as_slice()),\n             xref_index: decoder::load_xrefs(metadata.as_slice()),\n             data: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n-            span: span,\n             staged_api: staged_api,\n             explicitly_linked: Cell::new(explicitly_linked),\n         });\n@@ -349,8 +383,7 @@ impl<'a> CrateReader<'a> {\n                      span: Span,\n                      kind: PathKind,\n                      explicitly_linked: bool)\n-                         -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n-                             cstore::CrateSource) {\n+                     -> (ast::CrateNum, Rc<cstore::crate_metadata>, cstore::CrateSource) {\n         enum LookupResult {\n             Previous(ast::CrateNum),\n             Loaded(loader::Library),\n@@ -407,23 +440,54 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n+    fn update_extern_crate(&mut self,\n+                           cnum: ast::CrateNum,\n+                           mut extern_crate: ExternCrate)\n+    {\n+        let cmeta = self.cstore.get_crate_data(cnum);\n+        let old_extern_crate = cmeta.extern_crate.get();\n+\n+        // Prefer:\n+        // - something over nothing (tuple.0);\n+        // - direct extern crate to indirect (tuple.1);\n+        // - shorter paths to longer (tuple.2).\n+        let new_rank = (true, extern_crate.direct, !extern_crate.path_len);\n+        let old_rank = match old_extern_crate {\n+            None => (false, false, !0),\n+            Some(ref c) => (true, c.direct, !c.path_len),\n+        };\n+\n+        if old_rank >= new_rank {\n+            return; // no change needed\n+        }\n+\n+        cmeta.extern_crate.set(Some(extern_crate));\n+\n+        // Propagate the extern crate info to dependencies.\n+        extern_crate.direct = false;\n+        for &dep_cnum in cmeta.cnum_map.borrow().values() {\n+            self.update_extern_crate(dep_cnum, extern_crate);\n+        }\n+    }\n+\n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n-                          cdata: &[u8], span : Span)\n-                       -> cstore::cnum_map {\n+                          cdata: &[u8],\n+                          span : Span)\n+                          -> cstore::cnum_map {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n         decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n-                                                   &dep.name,\n-                                                   &dep.name,\n-                                                   Some(&dep.hash),\n-                                                   span,\n-                                                   PathKind::Dependency,\n-                                                   dep.explicitly_linked);\n+                                                        &dep.name,\n+                                                        &dep.name,\n+                                                        Some(&dep.hash),\n+                                                        span,\n+                                                        PathKind::Dependency,\n+                                                        dep.explicitly_linked);\n             (dep.cnum, local_cnum)\n         }).collect()\n     }\n@@ -713,12 +777,15 @@ impl<'a> CrateReader<'a> {\n }\n \n impl<'a, 'b> LocalCrateReader<'a, 'b> {\n-    pub fn new(sess: &'a Session, cstore: &'a CStore,\n-               map: &'a hir_map::Map<'b>) -> LocalCrateReader<'a, 'b> {\n+    pub fn new(sess: &'a Session,\n+               cstore: &'a CStore,\n+               map: &'a hir_map::Map<'b>,\n+               local_crate_name: &str)\n+               -> LocalCrateReader<'a, 'b> {\n         LocalCrateReader {\n             sess: sess,\n             cstore: cstore,\n-            creader: CrateReader::new(sess, cstore),\n+            creader: CrateReader::new(sess, cstore, local_crate_name),\n             ast_map: map,\n         }\n     }\n@@ -762,19 +829,24 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n \n                 match self.creader.extract_crate_info_hir(i) {\n                     Some(info) => {\n-                        let (cnum, cmeta, _) = self.creader.resolve_crate(&None,\n-                                                              &info.ident,\n-                                                              &info.name,\n-                                                              None,\n-                                                              i.span,\n-                                                              PathKind::Crate,\n-                                                              true);\n+                        let (cnum, _, _) = self.creader.resolve_crate(&None,\n+                                                                          &info.ident,\n+                                                                          &info.name,\n+                                                                          None,\n+                                                                          i.span,\n+                                                                          PathKind::Crate,\n+                                                                          true);\n                         let def_id = self.ast_map.local_def_id(i.id);\n-                        let def_path = self.ast_map.def_path(def_id);\n-                        cmeta.update_local_def_path(def_path);\n-                        self.ast_map.with_path(i.id, |path| {\n-                            cmeta.update_local_path(path)\n-                        });\n+\n+                        let len = self.ast_map.def_path(def_id).data.len();\n+\n+                        self.creader.update_extern_crate(cnum,\n+                                                         ExternCrate {\n+                                                             def_id: def_id,\n+                                                             span: i.span,\n+                                                             direct: true,\n+                                                             path_len: len,\n+                                                         });\n                         self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n                     }\n                     None => ()"}, {"sha": "25cc2f91753a3f407af74473ab1f65690c345a8f", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -13,7 +13,7 @@ use decoder;\n use encoder;\n use loader;\n \n-use middle::cstore::{CrateStore, CrateSource, ChildItem, FoundAst};\n+use middle::cstore::{CrateStore, CrateSource, ChildItem, ExternCrate, FoundAst};\n use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use middle::def;\n use middle::lang_items;\n@@ -128,16 +128,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_method_arg_names(&cdata, did.index)\n     }\n \n-    fn item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n+    fn relative_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n         let cdata = self.get_crate_data(def.krate);\n-        let path = decoder::get_item_path(&cdata, def.index);\n-\n-        cdata.with_local_path(|cpath| {\n-            let mut r = Vec::with_capacity(cpath.len() + path.len());\n-            r.extend_from_slice(cpath);\n-            r.extend_from_slice(&path);\n-            r\n-        })\n+        decoder::get_item_path(&cdata, def.index)\n     }\n \n     fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n@@ -334,9 +327,19 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_crate_attributes(self.get_crate_data(cnum).data())\n     }\n \n-    fn crate_name(&self, cnum: ast::CrateNum) -> String\n+    fn crate_name(&self, cnum: ast::CrateNum) -> token::InternedString\n+    {\n+        token::intern_and_get_ident(&self.get_crate_data(cnum).name[..])\n+    }\n+\n+    fn original_crate_name(&self, cnum: ast::CrateNum) -> token::InternedString\n+    {\n+        token::intern_and_get_ident(&self.get_crate_data(cnum).name())\n+    }\n+\n+    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>\n     {\n-        self.get_crate_data(cnum).name.clone()\n+        self.get_crate_data(cnum).extern_crate.get()\n     }\n \n     fn crate_hash(&self, cnum: ast::CrateNum) -> Svh\n@@ -345,6 +348,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_crate_hash(cdata.data())\n     }\n \n+    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> token::InternedString\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        token::intern_and_get_ident(decoder::get_crate_disambiguator(cdata.data()))\n+    }\n+\n     fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n                                 -> FnvHashMap<DefId, Vec<ast::Attribute>>\n     {\n@@ -372,12 +381,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_reachable_ids(&cdata)\n     }\n \n-    fn def_path(&self, def: DefId) -> hir_map::DefPath\n-    {\n+    /// Returns the `DefKey` for a given `DefId`. This indicates the\n+    /// parent `DefId` as well as some idea of what kind of data the\n+    /// `DefId` refers to.\n+    fn def_key(&self, def: DefId) -> hir_map::DefKey {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::def_key(&cdata, def.index)\n+    }\n+\n+    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath {\n         let cdata = self.get_crate_data(def.krate);\n-        let path = decoder::def_path(&cdata, def.index);\n-        let local_path = cdata.local_def_path();\n-        local_path.into_iter().chain(path).collect()\n+        decoder::def_path(&cdata, def.index)\n     }\n \n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> {\n@@ -478,9 +492,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         loader::meta_section_name(target)\n     }\n-    fn encode_type(&self, tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> Vec<u8>\n+    fn encode_type(&self,\n+                   tcx: &TyCtxt<'tcx>,\n+                   ty: Ty<'tcx>,\n+                   def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n+                   -> Vec<u8>\n     {\n-        encoder::encoded_ty(tcx, ty)\n+        encoder::encoded_ty(tcx, ty, def_id_to_string)\n     }\n \n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>"}, {"sha": "f092ee3919826a0b79eaf693f946e4304276a85a", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 11, "deletions": 51, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -21,7 +21,7 @@ use index;\n use loader;\n \n use rustc::back::svh::Svh;\n-use rustc::front::map as ast_map;\n+use rustc::middle::cstore::{ExternCrate};\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use std::cell::{RefCell, Ref, Cell};\n@@ -31,9 +31,7 @@ use flate::Bytes;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap;\n-use syntax::parse::token;\n use syntax::parse::token::IdentInterner;\n-use syntax::util::small_vector::SmallVector;\n \n pub use middle::cstore::{NativeLibraryKind, LinkagePreference};\n pub use middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n@@ -63,13 +61,16 @@ pub struct ImportedFileMap {\n \n pub struct crate_metadata {\n     pub name: String,\n-    pub local_path: RefCell<SmallVector<ast_map::PathElem>>,\n-    pub local_def_path: RefCell<ast_map::DefPath>,\n+\n+    /// Information about the extern crate that caused this crate to\n+    /// be loaded. If this is `None`, then the crate was injected\n+    /// (e.g., by the allocator)\n+    pub extern_crate: Cell<Option<ExternCrate>>,\n+\n     pub data: MetadataBlob,\n     pub cnum_map: RefCell<cnum_map>,\n     pub cnum: ast::CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n-    pub span: codemap::Span,\n     pub staged_api: bool,\n \n     pub index: index::Index,\n@@ -248,8 +249,11 @@ impl CStore {\n \n impl crate_metadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n-    pub fn name(&self) -> String { decoder::get_crate_name(self.data()) }\n+    pub fn name(&self) -> &str { decoder::get_crate_name(self.data()) }\n     pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n+    pub fn disambiguator(&self) -> &str {\n+        decoder::get_crate_disambiguator(self.data())\n+    }\n     pub fn imported_filemaps<'a>(&'a self, codemap: &codemap::CodeMap)\n                                  -> Ref<'a, Vec<ImportedFileMap>> {\n         let filemaps = self.codemap_import_info.borrow();\n@@ -265,50 +269,6 @@ impl crate_metadata {\n         }\n     }\n \n-    pub fn with_local_path<T, F>(&self, f: F) -> T\n-        where F: Fn(&[ast_map::PathElem]) -> T\n-    {\n-        let cpath = self.local_path.borrow();\n-        if cpath.is_empty() {\n-            let name = ast_map::PathMod(token::intern(&self.name));\n-            f(&[name])\n-        } else {\n-            f(cpath.as_slice())\n-        }\n-    }\n-\n-    pub fn update_local_path<'a, 'b>(&self, candidate: ast_map::PathElems<'a, 'b>) {\n-        let mut cpath = self.local_path.borrow_mut();\n-        let cap = cpath.len();\n-        match cap {\n-            0 => *cpath = candidate.collect(),\n-            1 => (),\n-            _ => {\n-                let candidate: SmallVector<_> = candidate.collect();\n-                if candidate.len() < cap {\n-                    *cpath = candidate;\n-                }\n-            },\n-        }\n-    }\n-\n-    pub fn local_def_path(&self) -> ast_map::DefPath {\n-        let local_def_path = self.local_def_path.borrow();\n-        if local_def_path.is_empty() {\n-            let name = ast_map::DefPathData::DetachedCrate(token::intern(&self.name));\n-            vec![ast_map::DisambiguatedDefPathData { data: name, disambiguator: 0 }]\n-        } else {\n-            local_def_path.clone()\n-        }\n-    }\n-\n-    pub fn update_local_def_path(&self, candidate: ast_map::DefPath) {\n-        let mut local_def_path = self.local_def_path.borrow_mut();\n-        if local_def_path.is_empty() || candidate.len() < local_def_path.len() {\n-            *local_def_path = candidate;\n-        }\n-    }\n-\n     pub fn is_allocator(&self) -> bool {\n         let attrs = decoder::get_crate_attributes(self.data());\n         attr::contains_name(&attrs, \"allocator\")"}, {"sha": "a4eeee44fb718a5a242fbae72531d8494aedcd58", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -803,25 +803,43 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &TyCtxt<'tcx>, id: DefIndex)\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n     let item_did = item_def_id(item_doc, cdata);\n+    let parent_def_id = DefId {\n+        krate: cdata.cnum,\n+        index: def_key(cdata, id).parent.unwrap()\n+    };\n     let mut parent_path = item_path(item_doc);\n     parent_path.pop();\n     let mut parent_def_path = def_path(cdata, id);\n-    parent_def_path.pop();\n+    parent_def_path.data.pop();\n     if let Some(ast_doc) = reader::maybe_get_doc(item_doc, tag_ast as usize) {\n-        let ii = decode_inlined_item(cdata, tcx, parent_path,\n+        let ii = decode_inlined_item(cdata,\n+                                     tcx,\n+                                     parent_path,\n                                      parent_def_path,\n-                                     ast_doc, item_did);\n+                                     parent_def_id,\n+                                     ast_doc,\n+                                     item_did);\n         return FoundAst::Found(ii);\n     } else if let Some(parent_did) = item_parent_item(cdata, item_doc) {\n         // Remove the last element from the paths, since we are now\n         // trying to inline the parent.\n-        parent_path.pop();\n-        parent_def_path.pop();\n+        let grandparent_def_id = DefId {\n+            krate: cdata.cnum,\n+            index: def_key(cdata, parent_def_id.index).parent.unwrap()\n+        };\n+        let mut grandparent_path = parent_path;\n+        grandparent_path.pop();\n+        let mut grandparent_def_path = parent_def_path;\n+        grandparent_def_path.data.pop();\n         let parent_doc = cdata.lookup_item(parent_did.index);\n         if let Some(ast_doc) = reader::maybe_get_doc(parent_doc, tag_ast as usize) {\n-            let ii = decode_inlined_item(cdata, tcx, parent_path,\n-                                         parent_def_path,\n-                                         ast_doc, parent_did);\n+            let ii = decode_inlined_item(cdata,\n+                                         tcx,\n+                                         grandparent_path,\n+                                         grandparent_def_path,\n+                                         grandparent_def_id,\n+                                         ast_doc,\n+                                         parent_did);\n             if let &InlinedItem::Item(ref i) = ii {\n                 return FoundAst::FoundParent(parent_did, i);\n             }\n@@ -1288,20 +1306,27 @@ pub fn get_crate_hash(data: &[u8]) -> Svh {\n     Svh::new(hashdoc.as_str_slice())\n }\n \n-pub fn maybe_get_crate_name(data: &[u8]) -> Option<String> {\n+pub fn maybe_get_crate_name(data: &[u8]) -> Option<&str> {\n     let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_crate_name).map(|doc| {\n-        doc.as_str_slice().to_string()\n+        doc.as_str_slice()\n     })\n }\n \n+pub fn get_crate_disambiguator<'a>(data: &'a [u8]) -> &'a str {\n+    let crate_doc = rbml::Doc::new(data);\n+    let disambiguator_doc = reader::get_doc(crate_doc, tag_crate_disambiguator);\n+    let slice: &'a str = disambiguator_doc.as_str_slice();\n+    slice\n+}\n+\n pub fn get_crate_triple(data: &[u8]) -> Option<String> {\n     let cratedoc = rbml::Doc::new(data);\n     let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n     triple_doc.map(|s| s.as_str().to_string())\n }\n \n-pub fn get_crate_name(data: &[u8]) -> String {\n+pub fn get_crate_name(data: &[u8]) -> &str {\n     maybe_get_crate_name(data).expect(\"no crate name in crate\")\n }\n \n@@ -1738,7 +1763,9 @@ pub fn closure_ty<'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: &TyCtxt<'tcx>)\n         .parse_closure_ty()\n }\n \n-fn def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n+pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n+    debug!(\"def_key: id={:?}\", id);\n+    let item_doc = cdata.lookup_item(id);\n     match reader::maybe_get_doc(item_doc, tag_def_key) {\n         Some(def_key_doc) => {\n             let mut decoder = reader::Decoder::new(def_key_doc);\n@@ -1754,9 +1781,5 @@ fn def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n \n pub fn def_path(cdata: Cmd, id: DefIndex) -> hir_map::DefPath {\n     debug!(\"def_path(id={:?})\", id);\n-    hir_map::definitions::make_def_path(id, |parent| {\n-        debug!(\"def_path: parent={:?}\", parent);\n-        let parent_doc = cdata.lookup_item(parent);\n-        def_key(parent_doc)\n-    })\n+    hir_map::DefPath::make(cdata.cnum, id, |parent| def_key(cdata, parent))\n }"}, {"sha": "8fa23de9a2d16ffc618ea2a865a6d50f9b7def8d", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -87,4 +87,6 @@ register_diagnostics! {\n     E0468, // an `extern crate` loading macros must be at the crate root\n     E0469, // imported macro not found\n     E0470, // reexported macro not found\n+    E0519, // local crate and dependency have same (crate-name, disambiguator)\n+    E0523, // two dependencies have same (crate-name, disambiguator) but different SVH\n }"}, {"sha": "73ac64adbb2a506615b67a2b0355bd94052bed3a", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -143,7 +143,7 @@ pub fn def_to_u64(did: DefId) -> u64 {\n     (did.krate as u64) << 32 | (did.index.as_usize() as u64)\n }\n \n-pub fn def_to_string(did: DefId) -> String {\n+pub fn def_to_string(_tcx: &TyCtxt, did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.index.as_usize())\n }\n \n@@ -1877,6 +1877,10 @@ fn encode_crate_name(rbml_w: &mut Encoder, crate_name: &str) {\n     rbml_w.wr_tagged_str(tag_crate_crate_name, crate_name);\n }\n \n+fn encode_crate_disambiguator(rbml_w: &mut Encoder, crate_disambiguator: &str) {\n+    rbml_w.wr_tagged_str(tag_crate_disambiguator, crate_disambiguator);\n+}\n+\n fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n     rbml_w.wr_tagged_str(tag_crate_triple, triple);\n }\n@@ -1987,6 +1991,7 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n     encode_crate_name(rbml_w, &ecx.link_meta.crate_name);\n     encode_crate_triple(rbml_w, &ecx.tcx.sess.opts.target_triple);\n     encode_hash(rbml_w, &ecx.link_meta.crate_hash);\n+    encode_crate_disambiguator(rbml_w, &ecx.tcx.sess.crate_disambiguator.get().as_str());\n     encode_dylib_dependency_formats(rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n@@ -2078,11 +2083,14 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty<'tcx>(tcx: &TyCtxt<'tcx>, t: Ty<'tcx>) -> Vec<u8> {\n+pub fn encoded_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n+                        t: Ty<'tcx>,\n+                        def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n+                        -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n-        ds: def_to_string,\n+        ds: def_id_to_string,\n         tcx: tcx,\n         abbrevs: &RefCell::new(FnvHashMap())\n     }, t);"}, {"sha": "911ca7e315c1f0147cc21110409495793d5a1dd1", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -32,11 +32,11 @@ struct MacroLoader<'a> {\n }\n \n impl<'a> MacroLoader<'a> {\n-    fn new(sess: &'a Session, cstore: &'a CStore) -> MacroLoader<'a> {\n+    fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> MacroLoader<'a> {\n         MacroLoader {\n             sess: sess,\n             span_whitelist: HashSet::new(),\n-            reader: CrateReader::new(sess, cstore),\n+            reader: CrateReader::new(sess, cstore, crate_name),\n             macros: vec![],\n         }\n     }\n@@ -47,10 +47,13 @@ pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n }\n \n /// Read exported macros.\n-pub fn read_macro_defs(sess: &Session, cstore: &CStore, krate: &ast::Crate)\n+pub fn read_macro_defs(sess: &Session,\n+                       cstore: &CStore,\n+                       krate: &ast::Crate,\n+                       crate_name: &str)\n                        -> Vec<ast::MacroDef>\n {\n-    let mut loader = MacroLoader::new(sess, cstore);\n+    let mut loader = MacroLoader::new(sess, cstore, crate_name);\n \n     // We need to error on `#[macro_use] extern crate` when it isn't at the\n     // crate root, because `$crate` won't work properly. Identify these by"}, {"sha": "67e77ba3315c953abd4c823fbf93666086e1fcb3", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -37,7 +37,7 @@ use encoder;\n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n     // Def -> str Callback:\n-    pub ds: fn(DefId) -> String,\n+    pub ds: fn(&TyCtxt<'tcx>, DefId) -> String,\n     // The type context.\n     pub tcx: &'a TyCtxt<'tcx>,\n     pub abbrevs: &'a abbrev_map<'tcx>\n@@ -99,7 +99,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             };\n         }\n         ty::TyEnum(def, substs) => {\n-            write!(w, \"t[{}|\", (cx.ds)(def.did));\n+            write!(w, \"t[{}|\", (cx.ds)(cx.tcx, def.did));\n             enc_substs(w, cx, substs);\n             write!(w, \"]\");\n         }\n@@ -137,7 +137,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n         }\n         ty::TyFnDef(def_id, substs, f) => {\n             write!(w, \"F\");\n-            write!(w, \"{}|\", (cx.ds)(def_id));\n+            write!(w, \"{}|\", (cx.ds)(cx.tcx, def_id));\n             enc_substs(w, cx, substs);\n             enc_bare_fn_ty(w, cx, f);\n         }\n@@ -152,12 +152,12 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             write!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name);\n         }\n         ty::TyStruct(def, substs) => {\n-            write!(w, \"a[{}|\", (cx.ds)(def.did));\n+            write!(w, \"a[{}|\", (cx.ds)(cx.tcx, def.did));\n             enc_substs(w, cx, substs);\n             write!(w, \"]\");\n         }\n         ty::TyClosure(def, ref substs) => {\n-            write!(w, \"k[{}|\", (cx.ds)(def));\n+            write!(w, \"k[{}|\", (cx.ds)(cx.tcx, def));\n             enc_substs(w, cx, &substs.func_substs);\n             for ty in &substs.upvar_tys {\n                 enc_ty(w, cx, ty);\n@@ -310,7 +310,7 @@ fn enc_bound_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, br: ty::BoundRegion) {\n         }\n         ty::BrNamed(d, name) => {\n             write!(w, \"[{}|{}]\",\n-                     (cx.ds)(d),\n+                     (cx.ds)(cx.tcx, d),\n                      name);\n         }\n         ty::BrFresh(id) => {\n@@ -324,7 +324,7 @@ fn enc_bound_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, br: ty::BoundRegion) {\n \n pub fn enc_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                                s: ty::TraitRef<'tcx>) {\n-    write!(w, \"{}|\", (cx.ds)(s.def_id));\n+    write!(w, \"{}|\", (cx.ds)(cx.tcx, s.def_id));\n     enc_substs(w, cx, s.substs);\n }\n \n@@ -408,16 +408,16 @@ pub fn enc_existential_bounds<'a,'tcx>(w: &mut Cursor<Vec<u8>>,\n pub fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n     write!(w, \"{}:{}|{}|{}|{}|\",\n-             v.name, (cx.ds)(v.def_id),\n-             v.space.to_uint(), v.index, (cx.ds)(v.default_def_id));\n+             v.name, (cx.ds)(cx.tcx, v.def_id),\n+             v.space.to_uint(), v.index, (cx.ds)(cx.tcx, v.default_def_id));\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n pub fn enc_region_param_def(w: &mut Cursor<Vec<u8>>, cx: &ctxt,\n                             v: &ty::RegionParameterDef) {\n     write!(w, \"{}:{}|{}|{}|\",\n-             v.name, (cx.ds)(v.def_id),\n+             v.name, (cx.ds)(cx.tcx, v.def_id),\n              v.space.to_uint(), v.index);\n     for &r in &v.bounds {\n         write!(w, \"R\");\n@@ -477,7 +477,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n             enc_ty(w, cx, data);\n         }\n         ty::Predicate::ObjectSafe(trait_def_id) => {\n-            write!(w, \"O{}|\", (cx.ds)(trait_def_id));\n+            write!(w, \"O{}|\", (cx.ds)(cx.tcx, trait_def_id));\n         }\n     }\n }"}, {"sha": "ac40215bbb1d0855ab60eaa855e634278f01a6c9", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -44,9 +44,12 @@ fn call_malformed_plugin_attribute(a: &Session, b: Span) {\n }\n \n /// Read plugin metadata and dynamically load registrar functions.\n-pub fn load_plugins(sess: &Session, cstore: &CStore, krate: &ast::Crate,\n+pub fn load_plugins(sess: &Session,\n+                    cstore: &CStore,\n+                    krate: &ast::Crate,\n+                    crate_name: &str,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n-    let mut loader = PluginLoader::new(sess, cstore);\n+    let mut loader = PluginLoader::new(sess, cstore, crate_name);\n \n     for attr in &krate.attrs {\n         if !attr.check_name(\"plugin\") {\n@@ -82,10 +85,10 @@ pub fn load_plugins(sess: &Session, cstore: &CStore, krate: &ast::Crate,\n }\n \n impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session, cstore: &'a CStore) -> PluginLoader<'a> {\n+    fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> PluginLoader<'a> {\n         PluginLoader {\n             sess: sess,\n-            reader: CrateReader::new(sess, cstore),\n+            reader: CrateReader::new(sess, cstore, crate_name),\n             plugins: vec![],\n         }\n     }"}, {"sha": "64d117100543f6e91298f4137e788a293916bfc7", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 235, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -23,11 +23,8 @@ use session::Session;\n use middle::cstore::{self, CrateStore, LinkMeta};\n use middle::cstore::{LinkagePreference, NativeLibraryKind};\n use middle::dependency_format::Linkage;\n-use middle::ty::{Ty, TyCtxt};\n-use rustc::front::map::DefPath;\n-use trans::{CrateContext, CrateTranslation, gensym_name};\n+use trans::CrateTranslation;\n use util::common::time;\n-use util::sha2::{Digest, Sha256};\n use util::fs::fix_windows_verbatim_for_gcc;\n use rustc_back::tempdir::TempDir;\n \n@@ -37,16 +34,13 @@ use std::env;\n use std::ffi::OsString;\n use std::fs;\n use std::io::{self, Read, Write};\n-use std::iter::once;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str;\n use flate;\n-use serialize::hex::ToHex;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token::{self, InternedString};\n use syntax::attr::AttrMetaMethods;\n \n use rustc_front::hir;\n@@ -81,58 +75,6 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n \n-/*\n- * Name mangling and its relationship to metadata. This is complex. Read\n- * carefully.\n- *\n- * The semantic model of Rust linkage is, broadly, that \"there's no global\n- * namespace\" between crates. Our aim is to preserve the illusion of this\n- * model despite the fact that it's not *quite* possible to implement on\n- * modern linkers. We initially didn't use system linkers at all, but have\n- * been convinced of their utility.\n- *\n- * There are a few issues to handle:\n- *\n- *  - Linkers operate on a flat namespace, so we have to flatten names.\n- *    We do this using the C++ namespace-mangling technique. Foo::bar\n- *    symbols and such.\n- *\n- *  - Symbols with the same name but different types need to get different\n- *    linkage-names. We do this by hashing a string-encoding of the type into\n- *    a fixed-size (currently 16-byte hex) cryptographic hash function (CHF:\n- *    we use SHA256) to \"prevent collisions\". This is not airtight but 16 hex\n- *    digits on uniform probability means you're going to need 2**32 same-name\n- *    symbols in the same process before you're even hitting birthday-paradox\n- *    collision probability.\n- *\n- *  - Symbols in different crates but with same names \"within\" the crate need\n- *    to get different linkage-names.\n- *\n- *  - The hash shown in the filename needs to be predictable and stable for\n- *    build tooling integration. It also needs to be using a hash function\n- *    which is easy to use from Python, make, etc.\n- *\n- * So here is what we do:\n- *\n- *  - Consider the package id; every crate has one (specified with crate_id\n- *    attribute).  If a package id isn't provided explicitly, we infer a\n- *    versionless one from the output name. The version will end up being 0.0\n- *    in this case. CNAME and CVERS are taken from this package id. For\n- *    example, github.com/mozilla/CNAME#CVERS.\n- *\n- *  - Define CMH as SHA256(crateid).\n- *\n- *  - Define CMH8 as the first 8 characters of CMH.\n- *\n- *  - Compile our crate to lib CNAME-CMH8-CVERS.so\n- *\n- *  - Define STH(sym) as SHA256(CMH, type_str(sym))\n- *\n- *  - Suffix a mangled sym with ::STH@CVERS, so that it is unique in the\n- *    name, non-name metadata, and type sense, and versioned in the way\n- *    system linkers understand.\n- */\n-\n pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n@@ -188,187 +130,12 @@ pub fn build_link_meta(sess: &Session,\n                        -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n-        crate_hash: Svh::calculate(&sess.opts.cg.metadata, krate),\n+        crate_hash: Svh::calculate(&sess.crate_disambiguator.get().as_str(), krate),\n     };\n     info!(\"{:?}\", r);\n     return r;\n }\n \n-fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n-    let output = symbol_hasher.result_bytes();\n-    // 64 bits should be enough to avoid collisions.\n-    output[.. 8].to_hex().to_string()\n-}\n-\n-\n-// This calculates STH for a symbol, as defined above\n-fn symbol_hash<'tcx>(tcx: &TyCtxt<'tcx>,\n-                     symbol_hasher: &mut Sha256,\n-                     t: Ty<'tcx>,\n-                     link_meta: &LinkMeta)\n-                     -> String {\n-    // NB: do *not* use abbrevs here as we want the symbol names\n-    // to be independent of one another in the crate.\n-\n-    symbol_hasher.reset();\n-    symbol_hasher.input_str(&link_meta.crate_name);\n-    symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(link_meta.crate_hash.as_str());\n-    for meta in tcx.sess.crate_metadata.borrow().iter() {\n-        symbol_hasher.input_str(&meta[..]);\n-    }\n-    symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input(&tcx.sess.cstore.encode_type(tcx, t));\n-    // Prefix with 'h' so that it never blends into adjacent digits\n-    let mut hash = String::from(\"h\");\n-    hash.push_str(&truncated_hash_result(symbol_hasher));\n-    hash\n-}\n-\n-fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> String {\n-    if let Some(h) = ccx.type_hashcodes().borrow().get(&t) {\n-        return h.to_string()\n-    }\n-\n-    let mut symbol_hasher = ccx.symbol_hasher().borrow_mut();\n-    let hash = symbol_hash(ccx.tcx(), &mut *symbol_hasher, t, ccx.link_meta());\n-    ccx.type_hashcodes().borrow_mut().insert(t, hash.clone());\n-    hash\n-}\n-\n-\n-// Name sanitation. LLVM will happily accept identifiers with weird names, but\n-// gas doesn't!\n-// gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-pub fn sanitize(s: &str) -> String {\n-    let mut result = String::new();\n-    for c in s.chars() {\n-        match c {\n-            // Escape these with $ sequences\n-            '@' => result.push_str(\"$SP$\"),\n-            '*' => result.push_str(\"$BP$\"),\n-            '&' => result.push_str(\"$RF$\"),\n-            '<' => result.push_str(\"$LT$\"),\n-            '>' => result.push_str(\"$GT$\"),\n-            '(' => result.push_str(\"$LP$\"),\n-            ')' => result.push_str(\"$RP$\"),\n-            ',' => result.push_str(\"$C$\"),\n-\n-            // '.' doesn't occur in types and functions, so reuse it\n-            // for ':' and '-'\n-            '-' | ':' => result.push('.'),\n-\n-            // These are legal symbols\n-            'a' ... 'z'\n-            | 'A' ... 'Z'\n-            | '0' ... '9'\n-            | '_' | '.' | '$' => result.push(c),\n-\n-            _ => {\n-                result.push('$');\n-                for c in c.escape_unicode().skip(1) {\n-                    match c {\n-                        '{' => {},\n-                        '}' => result.push('$'),\n-                        c => result.push(c),\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // Underscore-qualify anything that didn't start as an ident.\n-    if !result.is_empty() &&\n-        result.as_bytes()[0] != '_' as u8 &&\n-        ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", &result[..]);\n-    }\n-\n-    return result;\n-}\n-\n-pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -> String {\n-    // Follow C++ namespace-mangling style, see\n-    // http://en.wikipedia.org/wiki/Name_mangling for more info.\n-    //\n-    // It turns out that on OSX you can actually have arbitrary symbols in\n-    // function names (at least when given to LLVM), but this is not possible\n-    // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n-    // we won't need to do this name mangling. The problem with name mangling is\n-    // that it seriously limits the available characters. For example we can't\n-    // have things like &T in symbol names when one would theoretically\n-    // want them for things like impls of traits on that type.\n-    //\n-    // To be able to work on all platforms and get *some* reasonable output, we\n-    // use C++ name-mangling.\n-\n-    let mut n = String::from(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n-\n-    fn push(n: &mut String, s: &str) {\n-        let sani = sanitize(s);\n-        n.push_str(&format!(\"{}{}\", sani.len(), sani));\n-    }\n-\n-    // First, connect each component with <len, name> pairs.\n-    for data in path {\n-        push(&mut n, &data);\n-    }\n-\n-    if let Some(s) = hash {\n-        push(&mut n, s)\n-    }\n-\n-    n.push('E'); // End name-sequence.\n-    n\n-}\n-\n-pub fn exported_name(path: DefPath, hash: &str) -> String {\n-    let path = path.into_iter()\n-                   .map(|e| e.data.as_interned_str());\n-    mangle(path, Some(hash))\n-}\n-\n-pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: DefPath,\n-                                      t: Ty<'tcx>, id: ast::NodeId) -> String {\n-    let mut hash = get_symbol_hash(ccx, t);\n-\n-    // Paths can be completely identical for different nodes,\n-    // e.g. `fn foo() { { fn a() {} } { fn a() {} } }`, so we\n-    // generate unique characters from the node id. For now\n-    // hopefully 3 characters is enough to avoid collisions.\n-    const EXTRA_CHARS: &'static str =\n-        \"abcdefghijklmnopqrstuvwxyz\\\n-         ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-         0123456789\";\n-    let id = id as usize;\n-    let extra1 = id % EXTRA_CHARS.len();\n-    let id = id / EXTRA_CHARS.len();\n-    let extra2 = id % EXTRA_CHARS.len();\n-    let id = id / EXTRA_CHARS.len();\n-    let extra3 = id % EXTRA_CHARS.len();\n-    hash.push(EXTRA_CHARS.as_bytes()[extra1] as char);\n-    hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n-    hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n-\n-    exported_name(path, &hash[..])\n-}\n-\n-pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                      t: Ty<'tcx>,\n-                                                      name: &str) -> String {\n-    let path = [token::intern(&t.to_string()).as_str(), gensym_name(name).as_str()];\n-    let hash = get_symbol_hash(ccx, t);\n-    mangle(path.iter().cloned(), Some(&hash[..]))\n-}\n-\n-pub fn mangle_internal_name_by_path_and_seq(path: DefPath, flav: &str) -> String {\n-    let names =\n-        path.into_iter()\n-            .map(|e| e.data.as_interned_str())\n-            .chain(once(gensym_name(flav).as_str())); // append unique version of \"flav\"\n-    mangle(names, None)\n-}\n-\n pub fn get_linker(sess: &Session) -> (String, Command) {\n     if let Some(ref linker) = sess.opts.cg.linker {\n         (linker.clone(), Command::new(linker))"}, {"sha": "c6576b7fe0d9771101634474d1c89571a3172040", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -359,6 +359,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n             for symbol in symbols {\n                 writeln!(f, \"  {}\", symbol)?;\n             }\n+\n             Ok(())\n         })();\n         if let Err(e) = res {"}, {"sha": "5d578011da82b8b3a9388f30009cf5165037d533", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,378 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The Rust Linkage Model and Symbol Names\n+//! =======================================\n+//!\n+//! The semantic model of Rust linkage is, broadly, that \"there's no global\n+//! namespace\" between crates. Our aim is to preserve the illusion of this\n+//! model despite the fact that it's not *quite* possible to implement on\n+//! modern linkers. We initially didn't use system linkers at all, but have\n+//! been convinced of their utility.\n+//!\n+//! There are a few issues to handle:\n+//!\n+//!  - Linkers operate on a flat namespace, so we have to flatten names.\n+//!    We do this using the C++ namespace-mangling technique. Foo::bar\n+//!    symbols and such.\n+//!\n+//!  - Symbols for distinct items with the same *name* need to get different\n+//!    linkage-names. Examples of this are monomorphizations of functions or\n+//!    items within anonymous scopes that end up having the same path.\n+//!\n+//!  - Symbols in different crates but with same names \"within\" the crate need\n+//!    to get different linkage-names.\n+//!\n+//!  - Symbol names should be deterministic: Two consecutive runs of the\n+//!    compiler over the same code base should produce the same symbol names for\n+//!    the same items.\n+//!\n+//!  - Symbol names should not depend on any global properties of the code base,\n+//!    so that small modifications to the code base do not result in all symbols\n+//!    changing. In previous versions of the compiler, symbol names incorporated\n+//!    the SVH (Stable Version Hash) of the crate. This scheme turned out to be\n+//!    infeasible when used in conjunction with incremental compilation because\n+//!    small code changes would invalidate all symbols generated previously.\n+//!\n+//!  - Even symbols from different versions of the same crate should be able to\n+//!    live next to each other without conflict.\n+//!\n+//! In order to fulfill the above requirements the following scheme is used by\n+//! the compiler:\n+//!\n+//! The main tool for avoiding naming conflicts is the incorporation of a 64-bit\n+//! hash value into every exported symbol name. Anything that makes a difference\n+//! to the symbol being named, but does not show up in the regular path needs to\n+//! be fed into this hash:\n+//!\n+//! - Different monomorphizations of the same item have the same path but differ\n+//!   in their concrete type parameters, so these parameters are part of the\n+//!   data being digested for the symbol hash.\n+//!\n+//! - Rust allows items to be defined in anonymous scopes, such as in\n+//!   `fn foo() { { fn bar() {} } { fn bar() {} } }`. Both `bar` functions have\n+//!   the path `foo::bar`, since the anonymous scopes do not contribute to the\n+//!   path of an item. The compiler already handles this case via so-called\n+//!   disambiguating `DefPaths` which use indices to distinguish items with the\n+//!   same name. The DefPaths of the functions above are thus `foo[0]::bar[0]`\n+//!   and `foo[0]::bar[1]`. In order to incorporate this disambiguation\n+//!   information into the symbol name too, these indices are fed into the\n+//!   symbol hash, so that the above two symbols would end up with different\n+//!   hash values.\n+//!\n+//! The two measures described above suffice to avoid intra-crate conflicts. In\n+//! order to also avoid inter-crate conflicts two more measures are taken:\n+//!\n+//! - The name of the crate containing the symbol is prepended to the symbol\n+//!   name, i.e. symbols are \"crate qualified\". For example, a function `foo` in\n+//!   module `bar` in crate `baz` would get a symbol name like\n+//!   `baz::bar::foo::{hash}` instead of just `bar::foo::{hash}`. This avoids\n+//!   simple conflicts between functions from different crates.\n+//!\n+//! - In order to be able to also use symbols from two versions of the same\n+//!   crate (which naturally also have the same name), a stronger measure is\n+//!   required: The compiler accepts an arbitrary \"disambiguator\" value via the\n+//!   `-C metadata` commandline argument. This disambiguator is then fed into\n+//!   the symbol hash of every exported item. Consequently, the symbols in two\n+//!   identical crates but with different disambiguators are not in conflict\n+//!   with each other. This facility is mainly intended to be used by build\n+//!   tools like Cargo.\n+//!\n+//! A note on symbol name stability\n+//! -------------------------------\n+//! Previous versions of the compiler resorted to feeding NodeIds into the\n+//! symbol hash in order to disambiguate between items with the same path. The\n+//! current version of the name generation algorithm takes great care not to do\n+//! that, since NodeIds are notoriously unstable: A small change to the\n+//! code base will offset all NodeIds after the change and thus, much as using\n+//! the SVH in the hash, invalidate an unbounded number of symbol names. This\n+//! makes re-using previously compiled code for incremental compilation\n+//! virtually impossible. Thus, symbol hash generation exclusively relies on\n+//! DefPaths which are much more robust in the face of changes to the code base.\n+\n+use trans::{CrateContext, Instance, gensym_name};\n+use util::sha2::{Digest, Sha256};\n+\n+use rustc::middle::cstore;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::ty::{self, TypeFoldable};\n+use rustc::middle::ty::item_path::{ItemPathBuffer, RootMode};\n+use rustc::front::map::definitions::{DefPath, DefPathData};\n+\n+use std::fmt::Write;\n+use syntax::parse::token::{self, InternedString};\n+use serialize::hex::ToHex;\n+\n+pub fn def_id_to_string<'tcx>(tcx: &ty::TyCtxt<'tcx>, def_id: DefId) -> String {\n+    let def_path = tcx.def_path(def_id);\n+    def_path_to_string(tcx, &def_path)\n+}\n+\n+pub fn def_path_to_string<'tcx>(tcx: &ty::TyCtxt<'tcx>, def_path: &DefPath) -> String {\n+    let mut s = String::with_capacity(def_path.data.len() * 16);\n+\n+    s.push_str(&tcx.crate_name(def_path.krate));\n+    s.push_str(\"/\");\n+    s.push_str(&tcx.crate_disambiguator(def_path.krate));\n+\n+    for component in &def_path.data {\n+        write!(s,\n+               \"::{}[{}]\",\n+               component.data.as_interned_str(),\n+               component.disambiguator)\n+            .unwrap();\n+    }\n+\n+    s\n+}\n+\n+fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+\n+                             // path to the item this name is for\n+                             def_path: &DefPath,\n+\n+                             // type of the item, without any generic\n+                             // parameters substituted; this is\n+                             // included in the hash as a kind of\n+                             // safeguard.\n+                             item_type: ty::Ty<'tcx>,\n+\n+                             // values for generic type parameters,\n+                             // if any.\n+                             parameters: &[ty::Ty<'tcx>])\n+                             -> String {\n+    debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n+           def_path, parameters);\n+\n+    let tcx = ccx.tcx();\n+\n+    let mut hash_state = ccx.symbol_hasher().borrow_mut();\n+\n+    hash_state.reset();\n+\n+    // the main symbol name is not necessarily unique; hash in the\n+    // compiler's internal def-path, guaranteeing each symbol has a\n+    // truly unique path\n+    hash_state.input_str(&def_path_to_string(tcx, def_path));\n+\n+    // Include the main item-type. Note that, in this case, the\n+    // assertions about `needs_subst` may not hold, but this item-type\n+    // ought to be the same for every reference anyway.\n+    assert!(!item_type.has_erasable_regions());\n+    let encoded_item_type = tcx.sess.cstore.encode_type(tcx, item_type, def_id_to_string);\n+    hash_state.input(&encoded_item_type[..]);\n+\n+    // also include any type parameters (for generic items)\n+    for t in parameters {\n+       assert!(!t.has_erasable_regions());\n+       assert!(!t.needs_subst());\n+       let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n+       hash_state.input(&encoded_type[..]);\n+    }\n+\n+    return format!(\"h{}\", truncated_hash_result(&mut *hash_state));\n+\n+    fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n+        let output = symbol_hasher.result_bytes();\n+        // 64 bits should be enough to avoid collisions.\n+        output[.. 8].to_hex()\n+    }\n+}\n+\n+fn exported_name_with_opt_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                           instance: &Instance<'tcx>,\n+                                           suffix: Option<&str>)\n+                                           -> String {\n+    let &Instance { def: mut def_id, ref substs } = instance;\n+\n+    debug!(\"exported_name_with_opt_suffix(def_id={:?}, substs={:?}, suffix={:?})\",\n+           def_id, substs, suffix);\n+\n+    if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n+        if let Some(&src_def_id) = ccx.external_srcs().borrow().get(&node_id) {\n+            def_id = src_def_id;\n+        }\n+    }\n+\n+    let def_path = ccx.tcx().def_path(def_id);\n+    assert_eq!(def_path.krate, def_id.krate);\n+\n+    // We want to compute the \"type\" of this item. Unfortunately, some\n+    // kinds of items (e.g., closures) don't have an entry in the\n+    // item-type array. So walk back up the find the closest parent\n+    // that DOES have an entry.\n+    let mut ty_def_id = def_id;\n+    let instance_ty;\n+    loop {\n+        let key = ccx.tcx().def_key(ty_def_id);\n+        match key.disambiguated_data.data {\n+            DefPathData::TypeNs(_) |\n+            DefPathData::ValueNs(_) => {\n+                instance_ty = ccx.tcx().lookup_item_type(ty_def_id);\n+                break;\n+            }\n+            _ => {\n+                // if we're making a symbol for something, there ought\n+                // to be a value or type-def or something in there\n+                // *somewhere*\n+                ty_def_id.index = key.parent.unwrap_or_else(|| {\n+                    panic!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                            parent\", def_id, ty_def_id);\n+                });\n+            }\n+        }\n+    }\n+\n+    // Erase regions because they may not be deterministic when hashed\n+    // and should not matter anyhow.\n+    let instance_ty = ccx.tcx().erase_regions(&instance_ty.ty);\n+\n+    let hash = get_symbol_hash(ccx, &def_path, instance_ty, substs.types.as_slice());\n+\n+    let mut buffer = SymbolPathBuffer {\n+        names: Vec::with_capacity(def_path.data.len())\n+    };\n+    ccx.tcx().push_item_path(&mut buffer, def_id);\n+\n+    if let Some(suffix) = suffix {\n+        buffer.push(suffix);\n+    }\n+\n+    mangle(buffer.names.into_iter(), Some(&hash[..]))\n+}\n+\n+struct SymbolPathBuffer {\n+    names: Vec<InternedString>,\n+}\n+\n+impl ItemPathBuffer for SymbolPathBuffer {\n+    fn root_mode(&self) -> &RootMode {\n+        const ABSOLUTE: &'static RootMode = &RootMode::Absolute;\n+        ABSOLUTE\n+    }\n+\n+    fn push(&mut self, text: &str) {\n+        self.names.push(token::intern(text).as_str());\n+    }\n+}\n+\n+pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               instance: &Instance<'tcx>)\n+                               -> String {\n+    exported_name_with_opt_suffix(ccx, instance, None)\n+}\n+\n+pub fn exported_name_with_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                           instance: &Instance<'tcx>,\n+                                           suffix: &str)\n+                                           -> String {\n+   exported_name_with_opt_suffix(ccx, instance, Some(suffix))\n+}\n+\n+/// Only symbols that are invisible outside their compilation unit should use a\n+/// name generated by this function.\n+pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                    t: ty::Ty<'tcx>,\n+                                                    suffix: &str)\n+                                                    -> String {\n+    let path = [token::intern(&t.to_string()).as_str(),\n+                gensym_name(suffix).as_str()];\n+    let def_path = DefPath {\n+        data: vec![],\n+        krate: cstore::LOCAL_CRATE,\n+    };\n+    let hash = get_symbol_hash(ccx, &def_path, t, &[]);\n+    mangle(path.iter().cloned(), Some(&hash[..]))\n+}\n+\n+// Name sanitation. LLVM will happily accept identifiers with weird names, but\n+// gas doesn't!\n+// gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n+pub fn sanitize(s: &str) -> String {\n+    let mut result = String::new();\n+    for c in s.chars() {\n+        match c {\n+            // Escape these with $ sequences\n+            '@' => result.push_str(\"$SP$\"),\n+            '*' => result.push_str(\"$BP$\"),\n+            '&' => result.push_str(\"$RF$\"),\n+            '<' => result.push_str(\"$LT$\"),\n+            '>' => result.push_str(\"$GT$\"),\n+            '(' => result.push_str(\"$LP$\"),\n+            ')' => result.push_str(\"$RP$\"),\n+            ',' => result.push_str(\"$C$\"),\n+\n+            // '.' doesn't occur in types and functions, so reuse it\n+            // for ':' and '-'\n+            '-' | ':' => result.push('.'),\n+\n+            // These are legal symbols\n+            'a' ... 'z'\n+            | 'A' ... 'Z'\n+            | '0' ... '9'\n+            | '_' | '.' | '$' => result.push(c),\n+\n+            _ => {\n+                result.push('$');\n+                for c in c.escape_unicode().skip(1) {\n+                    match c {\n+                        '{' => {},\n+                        '}' => result.push('$'),\n+                        c => result.push(c),\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Underscore-qualify anything that didn't start as an ident.\n+    if !result.is_empty() &&\n+        result.as_bytes()[0] != '_' as u8 &&\n+        ! (result.as_bytes()[0] as char).is_xid_start() {\n+        return format!(\"_{}\", &result[..]);\n+    }\n+\n+    return result;\n+}\n+\n+pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -> String {\n+    // Follow C++ namespace-mangling style, see\n+    // http://en.wikipedia.org/wiki/Name_mangling for more info.\n+    //\n+    // It turns out that on OSX you can actually have arbitrary symbols in\n+    // function names (at least when given to LLVM), but this is not possible\n+    // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n+    // we won't need to do this name mangling. The problem with name mangling is\n+    // that it seriously limits the available characters. For example we can't\n+    // have things like &T in symbol names when one would theoretically\n+    // want them for things like impls of traits on that type.\n+    //\n+    // To be able to work on all platforms and get *some* reasonable output, we\n+    // use C++ name-mangling.\n+\n+    let mut n = String::from(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n+\n+    fn push(n: &mut String, s: &str) {\n+        let sani = sanitize(s);\n+        n.push_str(&format!(\"{}{}\", sani.len(), sani));\n+    }\n+\n+    // First, connect each component with <len, name> pairs.\n+    for data in path {\n+        push(&mut n, &data);\n+    }\n+\n+    if let Some(s) = hash {\n+        push(&mut n, s)\n+    }\n+\n+    n.push('E'); // End name-sequence.\n+    n\n+}"}, {"sha": "b9f92bcc4d961381b712c4c0c448e16ce9cb20d6", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -69,6 +69,7 @@ pub mod back {\n     pub mod linker;\n     pub mod link;\n     pub mod lto;\n+    pub mod symbol_names;\n     pub mod write;\n     pub mod msvc;\n }"}, {"sha": "4bbb762469373bdd0db246773f9786f46c943c7b", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -90,7 +90,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         for n in self.tcx.sess.cstore.crates() {\n             result.push(CrateData {\n-                name: self.tcx.sess.cstore.crate_name(n),\n+                name: (&self.tcx.sess.cstore.crate_name(n)[..]).to_owned(),\n                 number: n,\n             });\n         }"}, {"sha": "7231304ec4c4f43185bda4b27c4ba139f0082115", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n //! Translate the completed AST to the LLVM IR.\n //!\n //! Some functions here, such as trans_block and trans_expr, return a value --\n@@ -29,8 +30,7 @@ pub use self::ValueOrigin::*;\n use super::CrateTranslation;\n use super::ModuleTranslation;\n \n-use back::link::mangle_exported_name;\n-use back::link;\n+use back::{link, symbol_names};\n use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n@@ -84,6 +84,7 @@ use trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n use trans::meth;\n use trans::mir;\n use trans::monomorphize::{self, Instance};\n+use trans::symbol_names_test;\n use trans::tvec;\n use trans::type_::Type;\n use trans::type_of;\n@@ -2421,10 +2422,11 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n }\n \n pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               id: ast::NodeId,\n-                               ty: Ty<'tcx>,\n+                               instance: Instance<'tcx>,\n                                attrs: &[ast::Attribute])\n                                -> String {\n+    let id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n+\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = ccx.sess().cstore.item_symbol(did);\n@@ -2438,16 +2440,16 @@ pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Use provided name\n         Some(name) => name.to_string(),\n         _ => {\n-            let path = ccx.tcx().map.def_path_from_id(id);\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n-                path.last().unwrap().data.to_string()\n+                let path = ccx.tcx().map.def_path_from_id(id);\n+                path.data.last().unwrap().data.to_string()\n             } else {\n                 match weak_lang_items::link_name(attrs) {\n                     Some(name) => name.to_string(),\n                     None => {\n                         // Usual name mangling\n-                        mangle_exported_name(ccx, path, ty, id)\n+                        symbol_names::exported_name(ccx, &instance)\n                     }\n                 }\n             }\n@@ -2755,6 +2757,8 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n \n         collector::print_collection_results(&ccx);\n+\n+        symbol_names_test::report_symbol_names(&ccx);\n     }\n \n     for ccx in shared_ccx.iter() {"}, {"sha": "6fe4598c1ba3cc397514e08f4cf6e8e225705737", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -18,7 +18,7 @@ pub use self::CalleeData::*;\n pub use self::CallArgs::*;\n \n use arena::TypedArena;\n-use back::link;\n+use back::symbol_names;\n use llvm::{self, ValueRef, get_params};\n use middle::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n@@ -378,8 +378,10 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n-    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n-                                                                   \"fn_pointer_shim\");\n+    let function_name =\n+        symbol_names::internal_name_from_type_and_suffix(ccx,\n+                                                         bare_fn_ty,\n+                                                         \"fn_pointer_shim\");\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n \n     //\n@@ -513,7 +515,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         Some(hir_map::NodeImplItem(&hir::ImplItem {\n             ref attrs, id, span, node: hir::ImplItemKind::Method(..), ..\n         })) => {\n-            let sym = exported_name(ccx, id, ty, attrs);\n+            let sym = exported_name(ccx, instance, attrs);\n \n             if declare::get_defined_value(ccx, &sym).is_some() {\n                 ccx.sess().span_fatal(span,"}, {"sha": "ff3235385a9b09c573bc9c6b56d4f6d6c4515c89", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use arena::TypedArena;\n-use back::link::{self, mangle_internal_name_by_path_and_seq};\n+use back::symbol_names;\n use llvm::{ValueRef, get_param, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n@@ -152,8 +152,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let path = tcx.def_path(closure_id);\n-    let symbol = mangle_internal_name_by_path_and_seq(path, \"closure\");\n+    let symbol = symbol_names::exported_name(ccx, &instance);\n \n     // Compute the rust-call form of the closure call method.\n     let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n@@ -383,7 +382,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     });\n \n     // Create the by-value helper.\n-    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n+    let function_name =\n+        symbol_names::internal_name_from_type_and_suffix(ccx, llonce_fn_ty, \"once_shim\");\n     let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);"}, {"sha": "3f3da36be069588951d201243572d38889410597", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -1261,28 +1261,20 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n fn push_item_name(ccx: &CrateContext,\n                   def_id: DefId,\n                   output: &mut String) {\n-    if def_id.is_local() {\n-        let node_id = ccx.tcx().map.as_local_node_id(def_id).unwrap();\n-        let inlined_from = ccx.external_srcs()\n-                              .borrow()\n-                              .get(&node_id)\n-                              .map(|def_id| *def_id);\n-\n-        if let Some(extern_def_id) = inlined_from {\n-            push_item_name(ccx, extern_def_id, output);\n-            return;\n-        }\n+    let def_path = ccx.tcx().def_path(def_id);\n \n-        output.push_str(&ccx.link_meta().crate_name);\n-        output.push_str(\"::\");\n-    }\n+    // some_crate::\n+    output.push_str(&ccx.tcx().crate_name(def_path.krate));\n+    output.push_str(\"::\");\n \n-    for part in ccx.tcx().def_path(def_id) {\n+    // foo::bar::ItemName::\n+    for part in ccx.tcx().def_path(def_id).data {\n         output.push_str(&format!(\"{}[{}]::\",\n                         part.data.as_interned_str(),\n                         part.disambiguator));\n     }\n \n+    // remove final \"::\"\n     output.pop();\n     output.pop();\n }"}, {"sha": "4cdb64a9bfb718d46d702a3aa216ab24c6c5991e", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -1032,7 +1032,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                 // we need to get the symbol from metadata instead of\n                 // using the current crate's name/version\n                 // information in the hash of the symbol\n-                let sym = exported_name(ccx, id, ty, attrs);\n+                let sym = exported_name(ccx, instance, attrs);\n                 debug!(\"making {}\", sym);\n \n                 // Create the global before evaluating the initializer;"}, {"sha": "a3d387afa96f7642b2ecba4e7c3202698f7a9375", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -25,7 +25,8 @@ use trans::debuginfo;\n use trans::declare;\n use trans::glue::DropGlueKind;\n use trans::mir::CachedMir;\n-use trans::monomorphize::Instance;\n+use trans::Instance;\n+\n use trans::collector::{TransItem, TransItemState};\n use trans::type_::{Type, TypeNames};\n use middle::subst::{Substs, VecPerParamSpace};"}, {"sha": "7740f2775866cd27ce206f741a3b1fc76a02def2", "filename": "src/librustc_trans/trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -90,10 +90,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n \n pub fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&ccx.tcx()\n-                                .map\n-                                .krate()\n-                                .attrs,\n+        attr::contains_name(&ccx.tcx().map.krate_attrs(),\n                             \"omit_gdb_pretty_printer_section\");\n \n     !omit_gdb_pretty_printer_section &&"}, {"sha": "aa205898114d636cd6e489998b1277f560ae66b4", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -14,7 +14,7 @@\n \n use std;\n \n-use back::link;\n+use back::symbol_names;\n use llvm;\n use llvm::{ValueRef, get_param};\n use middle::lang_items::ExchangeFreeFnLangItem;\n@@ -259,7 +259,12 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     };\n \n-    let fn_nm = link::mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n+    let suffix = match g {\n+        DropGlueKind::Ty(_) => \"drop\",\n+        DropGlueKind::TyContents(_) => \"drop_contents\",\n+    };\n+\n+    let fn_nm = symbol_names::internal_name_from_type_and_suffix(ccx, t, suffix);\n     assert!(declare::get_defined_value(ccx, &fn_nm).is_none());\n     let llfn = declare::declare_cfn(ccx, &fn_nm, llfnty);\n     ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);"}, {"sha": "a9c94a4522ba94d9c7d5394e43780ed42b9aa127", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -97,6 +97,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                     for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n                         if ty_v.did == fn_id { my_id = ast_v.node.data.id(); }\n                         ccx.external().borrow_mut().insert(ty_v.did, Some(ast_v.node.data.id()));\n+                        ccx.external_srcs().borrow_mut().insert(ast_v.node.data.id(), ty_v.did);\n                     }\n                 }\n                 hir::ItemStruct(ref struct_def, _) => {\n@@ -105,6 +106,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                                                                  non-tuple struct\")\n                     } else {\n                         ccx.external().borrow_mut().insert(fn_id, Some(struct_def.id()));\n+                        ccx.external_srcs().borrow_mut().insert(struct_def.id(), fn_id);\n                         my_id = struct_def.id();\n                     }\n                 }"}, {"sha": "f45de10bca8538df673636405ea4029bb538ec90", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -11,7 +11,7 @@\n use std::rc::Rc;\n \n use arena::TypedArena;\n-use back::link;\n+use back::symbol_names;\n use llvm::{ValueRef, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n@@ -89,7 +89,8 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let sig = infer::normalize_associated_type(tcx, &sig);\n     let fn_ty = FnType::new(ccx, method_ty.fn_abi(), &sig, &[]);\n \n-    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, method_ty, \"object_shim\");\n+    let function_name =\n+        symbol_names::internal_name_from_type_and_suffix(ccx, method_ty, \"object_shim\");\n     let llfn = declare::define_internal_fn(ccx, &function_name, method_ty);\n \n     let empty_substs = tcx.mk_substs(Substs::empty());"}, {"sha": "930f37ce256345ca80b5728a61a2552ea6d343e3", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -15,6 +15,7 @@ pub use self::base::trans_crate;\n pub use self::context::CrateContext;\n pub use self::common::gensym_name;\n pub use self::disr::Disr;\n+pub use self::monomorphize::Instance;\n \n #[macro_use]\n mod macros;\n@@ -58,6 +59,7 @@ mod meth;\n mod mir;\n mod monomorphize;\n mod collector;\n+mod symbol_names_test;\n mod tvec;\n mod type_;\n mod type_of;"}, {"sha": "6dd8d651012e0b20926ef3a47beb66c28e042e23", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::link::exported_name;\n+use back::symbol_names;\n use llvm::ValueRef;\n use llvm;\n use middle::def_id::DefId;\n use middle::infer::normalize_associated_type;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n+use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use trans::attributes;\n use trans::base::{push_ctxt};\n use trans::base::trans_fn;\n use trans::base;\n use trans::common::*;\n use trans::declare;\n-use middle::ty::{self, Ty, TyCtxt};\n use trans::Disr;\n use rustc::front::map as hir_map;\n use rustc::util::ppaux;\n@@ -33,7 +33,6 @@ use syntax::attr;\n use syntax::errors;\n \n use std::fmt;\n-use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n@@ -90,22 +89,13 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         monomorphizing.insert(fn_id, depth + 1);\n     }\n \n-    let hash;\n-    let s = {\n-        let mut state = SipHasher::new();\n-        instance.hash(&mut state);\n-        mono_ty.hash(&mut state);\n-\n-        hash = format!(\"h{}\", state.finish());\n-        let path = ccx.tcx().map.def_path(fn_id);\n-        exported_name(path, &hash[..])\n-    };\n+    let symbol = symbol_names::exported_name(ccx, &instance);\n \n-    debug!(\"monomorphize_fn mangled to {}\", s);\n-    assert!(declare::get_defined_value(ccx, &s).is_none());\n+    debug!(\"monomorphize_fn mangled to {}\", symbol);\n+    assert!(declare::get_defined_value(ccx, &symbol).is_none());\n \n     // FIXME(nagisa): perhaps needs a more fine grained selection?\n-    let lldecl = declare::define_internal_fn(ccx, &s, mono_ty);\n+    let lldecl = declare::define_internal_fn(ccx, &symbol, mono_ty);\n     // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n     attributes::unwind(lldecl, true);\n \n@@ -137,9 +127,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n             attributes::from_fn_attrs(ccx, attrs, lldecl);\n \n-            let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n+            let is_first = !ccx.available_monomorphizations().borrow()\n+                                                             .contains(&symbol);\n             if is_first {\n-                ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n+                ccx.available_monomorphizations().borrow_mut().insert(symbol.clone());\n             }\n \n             let trans_everywhere = attr::requests_inline(attrs);"}, {"sha": "63abbfd53b6fa9e31c8ad9e5e2c8441d05625494", "filename": "src/librustc_trans/trans/symbol_names_test.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustc_trans%2Ftrans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fsymbol_names_test.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Walks the crate looking for items/impl-items/trait-items that have\n+//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n+//! generates an error giving, respectively, the symbol name or\n+//! item-path. This is used for unit testing the code that generates\n+//! paths etc in all kinds of annoying scenarios.\n+\n+use back::symbol_names;\n+use rustc::middle::ty::TyCtxt;\n+use rustc_front::hir;\n+use rustc_front::intravisit::{self, Visitor};\n+use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n+use trans::common::CrateContext;\n+use trans::monomorphize::Instance;\n+\n+const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n+const ITEM_PATH: &'static str = \"rustc_item_path\";\n+\n+pub fn report_symbol_names(ccx: &CrateContext) {\n+    // if the `rustc_attrs` feature is not enabled, then the\n+    // attributes we are interested in cannot be present anyway, so\n+    // skip the walk.\n+    let tcx = ccx.tcx();\n+    if !tcx.sess.features.borrow().rustc_attrs {\n+        return;\n+    }\n+\n+    let _ignore = tcx.dep_graph.in_ignore();\n+    let mut visitor = SymbolNamesTest { ccx: ccx, tcx: tcx };\n+    tcx.map.krate().visit_all_items(&mut visitor);\n+}\n+\n+struct SymbolNamesTest<'a, 'tcx:'a> {\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    tcx: &'a TyCtxt<'tcx>,\n+}\n+\n+impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n+    fn process_attrs(&mut self,\n+                     node_id: ast::NodeId) {\n+        let def_id = self.tcx.map.local_def_id(node_id);\n+        for attr in self.tcx.get_attrs(def_id).iter() {\n+            if attr.check_name(SYMBOL_NAME) {\n+                // for now, can only use on monomorphic names\n+                let instance = Instance::mono(self.tcx, def_id);\n+                let name = symbol_names::exported_name(self.ccx, &instance);\n+                self.tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n+            } else if attr.check_name(ITEM_PATH) {\n+                let path = self.tcx.item_path_str(def_id);\n+                self.tcx.sess.span_err(attr.span, &format!(\"item-path({})\", path));\n+            }\n+\n+            // (*) The formatting of `tag({})` is chosen so that tests can elect\n+            // to test the entirety of the string, if they choose, or else just\n+            // some subset.\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        self.process_attrs(item.id);\n+        intravisit::walk_item(self, item);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        self.process_attrs(ti.id);\n+        intravisit::walk_trait_item(self, ti)\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        self.process_attrs(ii.id);\n+        intravisit::walk_impl_item(self, ii)\n+    }\n+}\n+"}, {"sha": "aab5c960df3530898711f9ee5779dd32ee9f2668", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -241,7 +241,7 @@ impl Clean<ExternalCrate> for CrateNum {\n             }\n         });\n         ExternalCrate {\n-            name: cx.sess().cstore.crate_name(self.0),\n+            name: (&cx.sess().cstore.crate_name(self.0)[..]).to_owned(),\n             attrs: cx.sess().cstore.crate_attrs(self.0).clean(cx),\n             primitives: primitives,\n         }"}, {"sha": "80e1ae111a2d8f982f10d0bcf7d03e177996755f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -349,6 +349,10 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                        \"the `#[rustc_if_this_changed]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\")),\n+    (\"rustc_symbol_name\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"internal rustc attributes will never be stable\")),\n+    (\"rustc_item_path\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"internal rustc attributes will never be stable\")),\n     (\"rustc_move_fragments\", Normal, Gated(\"rustc_attrs\",\n                                            \"the `#[rustc_move_fragments]` attribute \\\n                                             is just used for rustc unit tests \\\n@@ -579,6 +583,7 @@ pub struct Features {\n     pub const_indexing: bool,\n     pub static_recursion: bool,\n     pub default_type_parameter_fallback: bool,\n+    pub rustc_attrs: bool,\n     pub type_macros: bool,\n     pub cfg_target_feature: bool,\n     pub cfg_target_vendor: bool,\n@@ -614,6 +619,7 @@ impl Features {\n             const_indexing: false,\n             static_recursion: false,\n             default_type_parameter_fallback: false,\n+            rustc_attrs: false,\n             type_macros: false,\n             cfg_target_feature: false,\n             cfg_target_vendor: false,\n@@ -1225,6 +1231,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n         const_indexing: cx.has_feature(\"const_indexing\"),\n         static_recursion: cx.has_feature(\"static_recursion\"),\n         default_type_parameter_fallback: cx.has_feature(\"default_type_parameter_fallback\"),\n+        rustc_attrs: cx.has_feature(\"rustc_attrs\"),\n         type_macros: cx.has_feature(\"type_macros\"),\n         cfg_target_feature: cx.has_feature(\"cfg_target_feature\"),\n         cfg_target_vendor: cx.has_feature(\"cfg_target_vendor\"),"}, {"sha": "e21e6ad204384978da2a27dab911a7af65d58309", "filename": "src/test/auxiliary/inline-default-methods.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Finline-default-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Finline-default-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finline-default-methods.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n pub trait Foo {\n     fn bar(&self);\n     fn foo(&mut self) {}"}, {"sha": "ecddfe99b3be7cbe04eb2d097f7e66f7fd59be9d", "filename": "src/test/auxiliary/issue-13698.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-13698.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-13698.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-13698.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n pub trait Foo {\n     #[doc(hidden)]\n     fn foo(&self) {}"}, {"sha": "145b4df6299956fcc453e159df0cad4b086436e7", "filename": "src/test/auxiliary/issue-15318.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-15318.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-15318.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-15318.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n #![doc(html_root_url = \"http://example.com/\")]\n \n /// dox"}, {"sha": "644d1634e9d9c40c8cf7a1087c89d8221d3c468c", "filename": "src/test/auxiliary/issue-17476.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-17476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-17476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17476.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n \n #![doc(html_root_url = \"http://example.com\")]\n "}, {"sha": "373fc04217540d3d3ec3665ba6cbcc8310758cce", "filename": "src/test/auxiliary/issue-17718-aux.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-17718-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-17718-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718-aux.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "previous_filename": "src/test/auxiliary/issue-17718.rs"}, {"sha": "2c9271202a650bd20edf2571afa33a7cb49247b8", "filename": "src/test/auxiliary/issue-19190-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-19190-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-19190-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-19190-3.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n use std::ops::Deref;\n \n pub struct Foo;"}, {"sha": "815b78a91d9af7ef7e10582d5d5a602097c3c06f", "filename": "src/test/auxiliary/issue-20646.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-20646.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-20646.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-20646.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n pub trait Trait {\n     type Output;\n }"}, {"sha": "2ec761fad96b5cb8df95e579e7bc272f18c748aa", "filename": "src/test/auxiliary/issue-20727.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-20727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-20727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-20727.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n pub trait Deref {\n     type Target: ?Sized;\n "}, {"sha": "e906311e3aeb42a75d5bd515435651ee80197ab3", "filename": "src/test/auxiliary/issue-21092.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-21092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-21092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-21092.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n pub trait Foo {\n     type Bar;\n     fn foo(&self) {}"}, {"sha": "f618edec5985e594d31ea342a3063d91a4c23129", "filename": "src/test/auxiliary/issue-21801.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-21801.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-21801.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-21801.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n pub struct Foo;\n \n impl Foo {"}, {"sha": "35a37e27d912fb17022777e94966c74899f9872c", "filename": "src/test/auxiliary/issue-22025.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-22025.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-22025.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-22025.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n pub mod foo {\n \n     pub trait Foo {}"}, {"sha": "25de698cad10e2308f0b1a5c9f2678d48b35159f", "filename": "src/test/auxiliary/issue-27362.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-27362.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-27362.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-27362.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n #![feature(const_fn)]\n \n pub const fn foo() {}"}, {"sha": "63c79f875efb2c73fb462e18e5f63b0d1f1d03cb", "filename": "src/test/auxiliary/issue-29584.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-29584.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Fissue-29584.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-29584.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Cmetadata=aux\n+\n pub struct Foo;\n \n #[doc(hidden)]"}, {"sha": "388d3238d4248960c37b2a317d249fca570f5a69", "filename": "src/test/auxiliary/typeid-intrinsic-aux1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "previous_filename": "src/test/auxiliary/typeid-intrinsic.rs"}, {"sha": "3ad307fd3b507b6b3cf199b4abb946227c881beb", "filename": "src/test/auxiliary/typeid-intrinsic-aux2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "previous_filename": "src/test/auxiliary/typeid-intrinsic2.rs"}, {"sha": "30f3ef12d07435cb059d8b14947705906bccabb5", "filename": "src/test/codegen-units/cross-crate-closures.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fcross-crate-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fcross-crate-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fcross-crate-closures.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -19,12 +19,12 @@ extern crate cgu_extern_closures;\n //~ TRANS_ITEM fn cross_crate_closures::main[0]\n fn main() {\n \n-    //~ TRANS_ITEM fn cgu_extern_closures[0]::inlined_fn[0]\n-    //~ TRANS_ITEM fn cgu_extern_closures[0]::inlined_fn[0]::{{closure}}[0]\n+    //~ TRANS_ITEM fn cgu_extern_closures::inlined_fn[0]\n+    //~ TRANS_ITEM fn cgu_extern_closures::inlined_fn[0]::{{closure}}[0]\n     let _ = cgu_extern_closures::inlined_fn(1, 2);\n \n-    //~ TRANS_ITEM fn cgu_extern_closures[0]::inlined_fn_generic[0]<i32>\n-    //~ TRANS_ITEM fn cgu_extern_closures[0]::inlined_fn_generic[0]::{{closure}}[0]<i32>\n+    //~ TRANS_ITEM fn cgu_extern_closures::inlined_fn_generic[0]<i32>\n+    //~ TRANS_ITEM fn cgu_extern_closures::inlined_fn_generic[0]::{{closure}}[0]<i32>\n     let _ = cgu_extern_closures::inlined_fn_generic(3, 4, 5i32);\n \n     // Nothing should be generated for this call, we just link to the instance instance"}, {"sha": "ada1234b852a1b1c943c1b9bd92de1182fcbacbc", "filename": "src/test/codegen-units/cross-crate-generic-functions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fcross-crate-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fcross-crate-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fcross-crate-generic-functions.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -19,12 +19,12 @@ extern crate cgu_generic_function;\n //~ TRANS_ITEM fn cross_crate_generic_functions::main[0]\n fn main()\n {\n-    //~ TRANS_ITEM fn cgu_generic_function[0]::bar[0]<u32>\n-    //~ TRANS_ITEM fn cgu_generic_function[0]::foo[0]<u32>\n+    //~ TRANS_ITEM fn cgu_generic_function::bar[0]<u32>\n+    //~ TRANS_ITEM fn cgu_generic_function::foo[0]<u32>\n     let _ = cgu_generic_function::foo(1u32);\n \n-    //~ TRANS_ITEM fn cgu_generic_function[0]::bar[0]<u64>\n-    //~ TRANS_ITEM fn cgu_generic_function[0]::foo[0]<u64>\n+    //~ TRANS_ITEM fn cgu_generic_function::bar[0]<u64>\n+    //~ TRANS_ITEM fn cgu_generic_function::foo[0]<u64>\n     let _ = cgu_generic_function::foo(2u64);\n \n     // This should not introduce a codegen item"}, {"sha": "9f29a90bffbf645932bfa08edf883b2b1f135a27", "filename": "src/test/codegen-units/cross-crate-trait-method.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fcross-crate-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fcross-crate-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fcross-crate-trait-method.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -29,31 +29,31 @@ fn main()\n     // Currently, no object code is generated for trait methods with default\n     // implemenations, unless they are actually called from somewhere. Therefore\n     // we cannot import the implementations and have to create our own inline.\n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl[0]<u32>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl[0]<u32>\n     let _ = Trait::with_default_impl(0u32);\n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl[0]<char>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl[0]<char>\n     let _ = Trait::with_default_impl('c');\n \n \n \n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl_generic[0]<u32, &str>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<u32, &str>\n     let _ = Trait::with_default_impl_generic(0u32, \"abc\");\n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl_generic[0]<u32, bool>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<u32, bool>\n     let _ = Trait::with_default_impl_generic(0u32, false);\n \n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl_generic[0]<char, i16>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<char, i16>\n     let _ = Trait::with_default_impl_generic('x', 1i16);\n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl_generic[0]<char, i32>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::Trait[0]::with_default_impl_generic[0]<char, i32>\n     let _ = Trait::with_default_impl_generic('y', 0i32);\n \n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::u32.Trait[0]::without_default_impl_generic[0]<char>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::{{impl}}[1]::without_default_impl_generic[0]<char>\n     let _: (u32, char) = Trait::without_default_impl_generic('c');\n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::u32.Trait[0]::without_default_impl_generic[0]<bool>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::{{impl}}[1]::without_default_impl_generic[0]<bool>\n     let _: (u32, bool) = Trait::without_default_impl_generic(false);\n \n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::char.Trait[0]::without_default_impl_generic[0]<char>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::{{impl}}[0]::without_default_impl_generic[0]<char>\n     let _: (char, char) = Trait::without_default_impl_generic('c');\n-    //~ TRANS_ITEM fn cgu_export_trait_method[0]::char.Trait[0]::without_default_impl_generic[0]<bool>\n+    //~ TRANS_ITEM fn cgu_export_trait_method::{{impl}}[0]::without_default_impl_generic[0]<bool>\n     let _: (char, bool) = Trait::without_default_impl_generic(false);\n }\n "}, {"sha": "476c84044e68656390521693be220ecbab4c461e", "filename": "src/test/codegen-units/generic-drop-glue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fgeneric-drop-glue.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -49,17 +49,17 @@ struct NonGenericWithDrop(i32);\n \n impl Drop for NonGenericWithDrop {\n     fn drop(&mut self) {}\n-//~ TRANS_ITEM fn generic_drop_glue::NonGenericWithDrop.Drop[0]::drop[0]\n+//~ TRANS_ITEM fn generic_drop_glue::{{impl}}[2]::drop[0]\n }\n \n //~ TRANS_ITEM fn generic_drop_glue::main[0]\n fn main() {\n     //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<i8, char>\n-    //~ TRANS_ITEM fn generic_drop_glue::StructWithDrop<T1, T2>.Drop[0]::drop[0]<i8, char>\n+    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<i8, char>\n     let _ = StructWithDrop { x: 0i8, y: 'a' }.x;\n \n     //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n-    //~ TRANS_ITEM fn generic_drop_glue::StructWithDrop<T1, T2>.Drop[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n+    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n     let _ = StructWithDrop { x: \"&str\", y: NonGenericNoDrop(0) }.y;\n \n     // Should produce no drop glue\n@@ -71,14 +71,14 @@ fn main() {\n     let _ = StructNoDrop { x: NonGenericWithDrop(0), y: 0f64 }.y;\n \n     //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<i32, i64>\n-    //~ TRANS_ITEM fn generic_drop_glue::EnumWithDrop<T1, T2>.Drop[0]::drop[0]<i32, i64>\n+    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<i32, i64>\n     let _ = match EnumWithDrop::A::<i32, i64>(0) {\n         EnumWithDrop::A(x) => x,\n         EnumWithDrop::B(x) => x as i32\n     };\n \n     //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<f64, f32>\n-    //~ TRANS_ITEM fn generic_drop_glue::EnumWithDrop<T1, T2>.Drop[0]::drop[0]<f64, f32>\n+    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<f64, f32>\n     let _ = match EnumWithDrop::B::<f64, f32>(1.0) {\n         EnumWithDrop::A(x) => x,\n         EnumWithDrop::B(x) => x as f64"}, {"sha": "a27515fd39b701dd99b8328f320c0a858bfdf26c", "filename": "src/test/codegen-units/generic-impl.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fgeneric-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fgeneric-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fgeneric-impl.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -40,11 +40,11 @@ pub struct LifeTimeOnly<'a> {\n \n impl<'a> LifeTimeOnly<'a> {\n \n-    //~ TRANS_ITEM fn generic_impl::LifeTimeOnly<'a>[0]::foo[0]\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[1]::foo[0]\n     pub fn foo(&self) {}\n-    //~ TRANS_ITEM fn generic_impl::LifeTimeOnly<'a>[0]::bar[0]\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[1]::bar[0]\n     pub fn bar(&'a self) {}\n-    //~ TRANS_ITEM fn generic_impl::LifeTimeOnly<'a>[0]::baz[0]\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[1]::baz[0]\n     pub fn baz<'b>(&'b self) {}\n \n     pub fn non_instantiated<T>(&self) {}\n@@ -53,27 +53,27 @@ impl<'a> LifeTimeOnly<'a> {\n \n //~ TRANS_ITEM fn generic_impl::main[0]\n fn main() {\n-    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<i32>\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<i32>\n     //~ TRANS_ITEM fn generic_impl::id[0]<i32>\n-    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::get[0]<i32, i16>\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::get[0]<i32, i16>\n     let _ = Struct::new(0i32).get(0i16);\n \n-    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<i64>\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<i64>\n     //~ TRANS_ITEM fn generic_impl::id[0]<i64>\n-    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::get[0]<i64, i16>\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::get[0]<i64, i16>\n     let _ = Struct::new(0i64).get(0i16);\n \n-    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<char>\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<char>\n     //~ TRANS_ITEM fn generic_impl::id[0]<char>\n-    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::get[0]<char, i16>\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::get[0]<char, i16>\n     let _ = Struct::new('c').get(0i16);\n \n-    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<&str>\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<&str>\n     //~ TRANS_ITEM fn generic_impl::id[0]<&str>\n-    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::get[0]<generic_impl::Struct[0]<&str>, i16>\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::get[0]<generic_impl::Struct[0]<&str>, i16>\n     let _ = Struct::new(Struct::new(\"str\")).get(0i16);\n \n-    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<generic_impl::Struct[0]<&str>>\n+    //~ TRANS_ITEM fn generic_impl::{{impl}}[0]::new[0]<generic_impl::Struct[0]<&str>>\n     //~ TRANS_ITEM fn generic_impl::id[0]<generic_impl::Struct[0]<&str>>\n     let _ = (Struct::new(Struct::new(\"str\")).f)(Struct::new(\"str\"));\n }"}, {"sha": "a3bfa67e1ae44eb2c05b7d23dba8547e1b0ad890", "filename": "src/test/codegen-units/impl-in-non-instantiated-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fimpl-in-non-instantiated-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fimpl-in-non-instantiated-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fimpl-in-non-instantiated-generic.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -21,7 +21,7 @@ trait SomeTrait {\n // discovered.\n pub fn generic_function<T>(x: T) -> (T, i32) {\n     impl SomeTrait for i64 {\n-        //~ TRANS_ITEM fn impl_in_non_instantiated_generic::generic_function[0]::i64.SomeTrait[0]::foo[0]\n+        //~ TRANS_ITEM fn impl_in_non_instantiated_generic::generic_function[0]::{{impl}}[0]::foo[0]\n         fn foo(&self) {}\n     }\n "}, {"sha": "b77252512200103aad028b238058dfe6c4934eec", "filename": "src/test/codegen-units/instantiation-through-vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Finstantiation-through-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Finstantiation-through-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Finstantiation-through-vtable.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -31,12 +31,12 @@ impl<T> Trait for Struct<T> {\n fn main() {\n     let s1 = Struct { _a: 0u32 };\n \n-    //~ TRANS_ITEM fn instantiation_through_vtable::Struct<T>.Trait[0]::foo[0]<u32>\n-    //~ TRANS_ITEM fn instantiation_through_vtable::Struct<T>.Trait[0]::bar[0]<u32>\n+    //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u32>\n+    //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u32>\n     let _ = &s1 as &Trait;\n \n     let s1 = Struct { _a: 0u64 };\n-    //~ TRANS_ITEM fn instantiation_through_vtable::Struct<T>.Trait[0]::foo[0]<u64>\n-    //~ TRANS_ITEM fn instantiation_through_vtable::Struct<T>.Trait[0]::bar[0]<u64>\n+    //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u64>\n+    //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u64>\n     let _ = &s1 as &Trait;\n }"}, {"sha": "bd8b0c605aecf8b96a48a468c35acb04a57de1ff", "filename": "src/test/codegen-units/non-generic-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fnon-generic-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fnon-generic-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fnon-generic-drop-glue.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -19,7 +19,7 @@ struct StructWithDrop {\n }\n \n impl Drop for StructWithDrop {\n-    //~ TRANS_ITEM fn non_generic_drop_glue::StructWithDrop.Drop[0]::drop[0]\n+    //~ TRANS_ITEM fn non_generic_drop_glue::{{impl}}[0]::drop[0]\n     fn drop(&mut self) {}\n }\n \n@@ -33,7 +33,7 @@ enum EnumWithDrop {\n }\n \n impl Drop for EnumWithDrop {\n-    //~ TRANS_ITEM fn non_generic_drop_glue::EnumWithDrop.Drop[0]::drop[0]\n+    //~ TRANS_ITEM fn non_generic_drop_glue::{{impl}}[1]::drop[0]\n     fn drop(&mut self) {}\n }\n "}, {"sha": "4e2a7c8508468f1ac82c1d8e58e722c8b53d2f50", "filename": "src/test/codegen-units/non-generic-functions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fnon-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Fnon-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fnon-generic-functions.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -38,31 +38,31 @@ fn bar() {\n struct Struct { _x: i32 }\n \n impl Struct {\n-    //~ TRANS_ITEM fn non_generic_functions::Struct[0]::foo[0]\n+    //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::foo[0]\n     fn foo() {\n         {\n-            //~ TRANS_ITEM fn non_generic_functions::Struct[0]::foo[0]::foo[0]\n+            //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::foo[0]::foo[0]\n             fn foo() {}\n             foo();\n         }\n \n         {\n-            //~ TRANS_ITEM fn non_generic_functions::Struct[0]::foo[0]::foo[1]\n+            //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::foo[0]::foo[1]\n             fn foo() {}\n             foo();\n         }\n     }\n \n-    //~ TRANS_ITEM fn non_generic_functions::Struct[0]::bar[0]\n+    //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::bar[0]\n     fn bar(&self) {\n         {\n-            //~ TRANS_ITEM fn non_generic_functions::Struct[0]::bar[0]::foo[0]\n+            //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::bar[0]::foo[0]\n             fn foo() {}\n             foo();\n         }\n \n         {\n-            //~ TRANS_ITEM fn non_generic_functions::Struct[0]::bar[0]::foo[1]\n+            //~ TRANS_ITEM fn non_generic_functions::{{impl}}[0]::bar[0]::foo[1]\n             fn foo() {}\n             foo();\n         }"}, {"sha": "c275eb954b094296d69496812ca8002d94600354", "filename": "src/test/codegen-units/overloaded-operators.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Foverloaded-operators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Foverloaded-operators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Foverloaded-operators.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -23,7 +23,7 @@ pub struct Indexable {\n impl Index<usize> for Indexable {\n     type Output = u8;\n \n-    //~ TRANS_ITEM fn overloaded_operators::Indexable.Index<usize>[0]::index[0]\n+    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[0]::index[0]\n     fn index(&self, index: usize) -> &Self::Output {\n         if index >= 3 {\n             &self.data[0]\n@@ -34,7 +34,7 @@ impl Index<usize> for Indexable {\n }\n \n impl IndexMut<usize> for Indexable {\n-    //~ TRANS_ITEM fn overloaded_operators::Indexable.IndexMut<usize>[0]::index_mut[0]\n+    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[1]::index_mut[0]\n     fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n         if index >= 3 {\n             &mut self.data[0]\n@@ -45,16 +45,16 @@ impl IndexMut<usize> for Indexable {\n }\n \n \n-//~ TRANS_ITEM fn overloaded_operators::Equatable.::std::cmp::PartialEq[0]::eq[0]\n-//~ TRANS_ITEM fn overloaded_operators::Equatable.::std::cmp::PartialEq[0]::ne[0]\n+//~ TRANS_ITEM fn overloaded_operators::{{impl}}[2]::eq[0]\n+//~ TRANS_ITEM fn overloaded_operators::{{impl}}[2]::ne[0]\n #[derive(PartialEq)]\n pub struct Equatable(u32);\n \n \n impl Add<u32> for Equatable {\n     type Output = u32;\n \n-    //~ TRANS_ITEM fn overloaded_operators::Equatable.Add<u32>[0]::add[0]\n+    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[3]::add[0]\n     fn add(self, rhs: u32) -> u32 {\n         self.0 + rhs\n     }\n@@ -63,7 +63,7 @@ impl Add<u32> for Equatable {\n impl Deref for Equatable {\n     type Target = u32;\n \n-    //~ TRANS_ITEM fn overloaded_operators::Equatable.Deref[0]::deref[0]\n+    //~ TRANS_ITEM fn overloaded_operators::{{impl}}[4]::deref[0]\n     fn deref(&self) -> &Self::Target {\n         &self.0\n     }"}, {"sha": "2eb2212f0cacd0f6f166d22032a2ac105149b6ff", "filename": "src/test/codegen-units/trait-implementations.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Ftrait-implementations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Ftrait-implementations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ftrait-implementations.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -20,15 +20,15 @@ pub trait SomeTrait {\n \n impl SomeTrait for i64 {\n \n-    //~ TRANS_ITEM fn trait_implementations::i64.SomeTrait[0]::foo[0]\n+    //~ TRANS_ITEM fn trait_implementations::{{impl}}[0]::foo[0]\n     fn foo(&self) {}\n \n     fn bar<T>(&self, _: T) {}\n }\n \n impl SomeTrait for i32 {\n \n-    //~ TRANS_ITEM fn trait_implementations::i32.SomeTrait[0]::foo[0]\n+    //~ TRANS_ITEM fn trait_implementations::{{impl}}[1]::foo[0]\n     fn foo(&self) {}\n \n     fn bar<T>(&self, _: T) {}\n@@ -42,7 +42,7 @@ pub trait SomeGenericTrait<T> {\n // Concrete impl of generic trait\n impl SomeGenericTrait<u32> for f64 {\n \n-    //~ TRANS_ITEM fn trait_implementations::f64.SomeGenericTrait<u32>[0]::foo[0]\n+    //~ TRANS_ITEM fn trait_implementations::{{impl}}[2]::foo[0]\n     fn foo(&self, _: u32) {}\n \n     fn bar<T2>(&self, _: u32, _: T2) {}\n@@ -57,25 +57,25 @@ impl<T> SomeGenericTrait<T> for f32 {\n \n //~ TRANS_ITEM fn trait_implementations::main[0]\n fn main() {\n-   //~ TRANS_ITEM fn trait_implementations::i32.SomeTrait[0]::bar[0]<char>\n+   //~ TRANS_ITEM fn trait_implementations::{{impl}}[1]::bar[0]<char>\n    0i32.bar('x');\n \n-   //~ TRANS_ITEM fn trait_implementations::f64.SomeGenericTrait<u32>[0]::bar[0]<&str>\n+   //~ TRANS_ITEM fn trait_implementations::{{impl}}[2]::bar[0]<&str>\n    0f64.bar(0u32, \"&str\");\n \n-   //~ TRANS_ITEM fn trait_implementations::f64.SomeGenericTrait<u32>[0]::bar[0]<()>\n+   //~ TRANS_ITEM fn trait_implementations::{{impl}}[2]::bar[0]<()>\n    0f64.bar(0u32, ());\n \n-   //~ TRANS_ITEM fn trait_implementations::f32.SomeGenericTrait<T>[0]::foo[0]<char>\n+   //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::foo[0]<char>\n    0f32.foo('x');\n \n-   //~ TRANS_ITEM fn trait_implementations::f32.SomeGenericTrait<T>[0]::foo[0]<i64>\n+   //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::foo[0]<i64>\n    0f32.foo(-1i64);\n \n-   //~ TRANS_ITEM fn trait_implementations::f32.SomeGenericTrait<T>[0]::bar[0]<u32, ()>\n+   //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::bar[0]<u32, ()>\n    0f32.bar(0u32, ());\n \n-   //~ TRANS_ITEM fn trait_implementations::f32.SomeGenericTrait<T>[0]::bar[0]<&str, &str>\n+   //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::bar[0]<&str, &str>\n    0f32.bar(\"&str\", \"&str\");\n }\n "}, {"sha": "e7006d73ef166c83c26c2d9ea5eebb1504712b7b", "filename": "src/test/codegen-units/trait-method-as-argument.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Ftrait-method-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Ftrait-method-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ftrait-method-as-argument.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -39,7 +39,7 @@ fn take_foo_mut<T, F: FnMut(T) -> T>(mut f: F, arg: T) -> T {\n //~ TRANS_ITEM fn trait_method_as_argument::main[0]\n fn main() {\n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<u32, fn(u32) -> u32>\n-    //~ TRANS_ITEM fn trait_method_as_argument::u32.Trait[0]::foo[0]\n+    //~ TRANS_ITEM fn trait_method_as_argument::{{impl}}[0]::foo[0]\n     take_foo_once(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<char, fn(char) -> char>"}, {"sha": "21bb29199a685715ba4832ed0b35e071c6610c78", "filename": "src/test/codegen-units/transitive-drop-glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Ftransitive-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Ftransitive-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ftransitive-drop-glue.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -21,7 +21,7 @@ struct Intermediate(Leaf);\n struct Leaf;\n \n impl Drop for Leaf {\n-    //~ TRANS_ITEM fn transitive_drop_glue::Leaf.Drop[0]::drop[0]\n+    //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[0]::drop[0]\n     fn drop(&mut self) {}\n }\n \n@@ -44,12 +44,12 @@ fn main() {\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<u32>\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<u32>\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<u32>\n-    //~ TRANS_ITEM fn transitive_drop_glue::LeafGen<T>.Drop[0]::drop[0]<u32>\n+    //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<u32>\n     let _ = RootGen(IntermediateGen(LeafGen(0u32)));\n \n     //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<i16>\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<i16>\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<i16>\n-    //~ TRANS_ITEM fn transitive_drop_glue::LeafGen<T>.Drop[0]::drop[0]<i16>\n+    //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<i16>\n     let _ = RootGen(IntermediateGen(LeafGen(0i16)));\n }"}, {"sha": "1bc235de88e1f603c33b3222ddb6b496b0d97081", "filename": "src/test/codegen-units/tuple-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Ftuple-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Ftuple-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ftuple-drop-glue.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -17,7 +17,7 @@\n struct Dropped;\n \n impl Drop for Dropped {\n-    //~ TRANS_ITEM fn tuple_drop_glue::Dropped.Drop[0]::drop[0]\n+    //~ TRANS_ITEM fn tuple_drop_glue::{{impl}}[0]::drop[0]\n     fn drop(&mut self) {}\n }\n "}, {"sha": "45ba441bc8ba6066bef2f85c6eed8fbd37de471c", "filename": "src/test/codegen-units/unsizing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Funsizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Funsizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Funsizing.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -57,11 +57,11 @@ fn main()\n {\n     // simple case\n     let bool_sized = &true;\n-    //~ TRANS_ITEM fn unsizing::bool.Trait[0]::foo[0]\n+    //~ TRANS_ITEM fn unsizing::{{impl}}[0]::foo[0]\n     let _bool_unsized = bool_sized as &Trait;\n \n     let char_sized = &true;\n-    //~ TRANS_ITEM fn unsizing::char.Trait[0]::foo[0]\n+    //~ TRANS_ITEM fn unsizing::{{impl}}[1]::foo[0]\n     let _char_unsized = char_sized as &Trait;\n \n     // struct field\n@@ -70,11 +70,11 @@ fn main()\n         _b: 2,\n         _c: 3.0f64\n     };\n-    //~ TRANS_ITEM fn unsizing::f64.Trait[0]::foo[0]\n+    //~ TRANS_ITEM fn unsizing::{{impl}}[2]::foo[0]\n     let _struct_unsized = struct_sized as &Struct<Trait>;\n \n     // custom coercion\n     let wrapper_sized = Wrapper(&0u32);\n-    //~ TRANS_ITEM fn unsizing::u32.Trait[0]::foo[0]\n+    //~ TRANS_ITEM fn unsizing::{{impl}}[3]::foo[0]\n     let _wrapper_sized = wrapper_sized as Wrapper<Trait>;\n }"}, {"sha": "8689beb3fb77e98e6df3cc05214d348615f01134", "filename": "src/test/codegen-units/unused-traits-and-generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Funused-traits-and-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcodegen-units%2Funused-traits-and-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Funused-traits-and-generics.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -85,5 +85,5 @@ impl NonGeneric {\n }\n \n // Only the non-generic methods should be instantiated:\n-//~ TRANS_ITEM fn unused_traits_and_generics::NonGeneric[0]::foo[0]\n+//~ TRANS_ITEM fn unused_traits_and_generics::{{impl}}[3]::foo[0]\n //~ TRANS_ITEM drop-glue i8"}, {"sha": "0095774fcb8d2addb751e781bf0a632f1dfacff2", "filename": "src/test/compile-fail/symbol-names/basic.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fbasic.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_symbol_name] //~ ERROR _ZN5basic4main\n+#[rustc_item_path] //~ ERROR item-path(main)\n+fn main() {\n+}"}, {"sha": "39bee26da20b8b1e0de20e4982903191f1edc645", "filename": "src/test/compile-fail/symbol-names/impl1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fimpl1.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod foo {\n+    pub struct Foo { x: u32 }\n+\n+    impl Foo {\n+        #[rustc_symbol_name] //~ ERROR _ZN5impl13foo3Foo3bar\n+        #[rustc_item_path] //~ ERROR item-path(foo::Foo::bar)\n+        fn bar() { }\n+    }\n+}\n+\n+mod bar {\n+    use foo::Foo;\n+\n+    impl Foo {\n+        #[rustc_symbol_name] //~ ERROR _ZN5impl13bar26_$LT$impl$u20$foo..Foo$GT$3baz\n+        #[rustc_item_path] //~ ERROR item-path(bar::<impl foo::Foo>::baz)\n+        fn baz() { }\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "fe4337eedc63d4dc516c1909063523b97ca8a933", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -41,37 +41,37 @@\n     ((::std::fmt::format as\n          fn(core::fmt::Arguments<'_>) -> collections::string::String {collections::fmt::format})(((::std::fmt::Arguments::new_v1\n                                                                                                       as\n-                                                                                                      fn(&[&str], &[core::fmt::ArgumentV1<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a><'_>::new_v1})(({\n-                                                                                                                                                                                                                         static __STATIC_FMTSTR:\n-                                                                                                                                                                                                                                &'static [&'static str]\n-                                                                                                                                                                                                                                =\n-                                                                                                                                                                                                                             (&([(\"test\"\n-                                                                                                                                                                                                                                     as\n-                                                                                                                                                                                                                                     &'static str)]\n-                                                                                                                                                                                                                                   as\n-                                                                                                                                                                                                                                   [&'static str; 1])\n+                                                                                                      fn(&[&str], &[core::fmt::ArgumentV1<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'_>::new_v1})(({\n+                                                                                                                                                                                                                     static __STATIC_FMTSTR:\n+                                                                                                                                                                                                                            &'static [&'static str]\n+                                                                                                                                                                                                                            =\n+                                                                                                                                                                                                                         (&([(\"test\"\n                                                                                                                                                                                                                                  as\n-                                                                                                                                                                                                                                 &'static [&'static str; 1]);\n-                                                                                                                                                                                                                         (__STATIC_FMTSTR\n-                                                                                                                                                                                                                             as\n-                                                                                                                                                                                                                             &'static [&'static str])\n-                                                                                                                                                                                                                     }\n-                                                                                                                                                                                                                        as\n-                                                                                                                                                                                                                        &[&str]),\n-                                                                                                                                                                                                                    (&(match (()\n-                                                                                                                                                                                                                                 as\n-                                                                                                                                                                                                                                 ())\n-                                                                                                                                                                                                                           {\n-                                                                                                                                                                                                                           ()\n-                                                                                                                                                                                                                           =>\n-                                                                                                                                                                                                                           ([]\n+                                                                                                                                                                                                                                 &'static str)]\n                                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                               [core::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                                                       }\n-                                                                                                                                                                                                                          as\n-                                                                                                                                                                                                                          [core::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                                        as\n-                                                                                                                                                                                                                        &[core::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                                                                                                                                               [&'static str; 1])\n+                                                                                                                                                                                                                             as\n+                                                                                                                                                                                                                             &'static [&'static str; 1]);\n+                                                                                                                                                                                                                     (__STATIC_FMTSTR\n+                                                                                                                                                                                                                         as\n+                                                                                                                                                                                                                         &'static [&'static str])\n+                                                                                                                                                                                                                 }\n+                                                                                                                                                                                                                    as\n+                                                                                                                                                                                                                    &[&str]),\n+                                                                                                                                                                                                                (&(match (()\n+                                                                                                                                                                                                                             as\n+                                                                                                                                                                                                                             ())\n+                                                                                                                                                                                                                       {\n+                                                                                                                                                                                                                       ()\n+                                                                                                                                                                                                                       =>\n+                                                                                                                                                                                                                       ([]\n+                                                                                                                                                                                                                           as\n+                                                                                                                                                                                                                           [core::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                                   }\n+                                                                                                                                                                                                                      as\n+                                                                                                                                                                                                                      [core::fmt::ArgumentV1<'_>; 0])\n+                                                                                                                                                                                                                    as\n+                                                                                                                                                                                                                    &[core::fmt::ArgumentV1<'_>; 0]))\n                                                                                                      as\n                                                                                                      core::fmt::Arguments<'_>))\n         as collections::string::String);"}, {"sha": "0962ebfbff546fa99ecf8206c4c46194e686272d", "filename": "src/test/run-make/a-b-a-linker-guard/Makefile", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fa-b-a-linker-guard%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fa-b-a-linker-guard%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fa-b-a-linker-guard%2FMakefile?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,12 @@\n+-include ../tools.mk\n+\n+# Test that if we build `b` against a version of `a` that has one set\n+# of types, it will not run with a dylib that has a different set of\n+# types.\n+\n+all:\n+\t$(RUSTC) a.rs --cfg x -C prefer-dynamic\n+\t$(RUSTC) b.rs -C prefer-dynamic\n+\t$(call RUN,b)\n+\t$(RUSTC) a.rs --cfg y -C prefer-dynamic\n+\t$(call FAIL,b)"}, {"sha": "e6cbe2e64d0e94201289c949bd702c72cb24b8c5", "filename": "src/test/run-make/a-b-a-linker-guard/a.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fa-b-a-linker-guard%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fa-b-a-linker-guard%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fa-b-a-linker-guard%2Fa.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"a\"]\n+#![crate_type = \"dylib\"]\n+\n+#[cfg(x)]\n+pub fn foo(x: u32) { }\n+\n+#[cfg(y)]\n+pub fn foo(x: i32) { }\n+\n+"}, {"sha": "89fd48de5bbf94736dee0f4f3b3096d27758f5db", "filename": "src/test/run-make/a-b-a-linker-guard/b.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fa-b-a-linker-guard%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fa-b-a-linker-guard%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fa-b-a-linker-guard%2Fb.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"b\"]\n+\n+extern crate a;\n+\n+fn main() {\n+    a::foo(22_u32);\n+}"}, {"sha": "7d063a4c83cba1cd929bfa4906570bd1f5f5cac9", "filename": "src/test/run-make/extern-overrides-distribution/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fextern-overrides-distribution%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fextern-overrides-distribution%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-overrides-distribution%2FMakefile?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -1,5 +1,5 @@\n -include ../tools.mk\n \n all:\n-\t$(RUSTC) libc.rs\n+\t$(RUSTC) libc.rs -Cmetadata=foo\n \t$(RUSTC) main.rs --extern libc=$(TMPDIR)/liblibc.rlib"}, {"sha": "66aa78d538637d0d9e8476b47557f2cf5fffa8af", "filename": "src/test/run-make/issue-26006/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fissue-26006%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Fissue-26006%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-26006%2FMakefile?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -12,7 +12,7 @@ time: libc\n \n libc:\n \tmkdir -p $(OUT)/libc\n-\t$(RUSTC) in/libc/lib.rs --crate-name=libc -o $(OUT)/libc/liblibc.rlib\n+\t$(RUSTC) in/libc/lib.rs --crate-name=libc -Cmetadata=foo -o $(OUT)/libc/liblibc.rlib\n else\n all:\n endif"}, {"sha": "485ecbb4b5a59a60b0cad78692d977374face91d", "filename": "src/test/run-make/relocation-model/Makefile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Frelocation-model%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Frelocation-model%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frelocation-model%2FMakefile?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -7,8 +7,7 @@ all: others\n \t$(RUSTC) -C relocation-model=default foo.rs\n \t$(call RUN,foo)\n \n-\t$(RUSTC) -C relocation-model=default --crate-type=dylib foo.rs\n-\t$(RUSTC) -C relocation-model=dynamic-no-pic --crate-type=dylib foo.rs\n+\t$(RUSTC) -C relocation-model=dynamic-no-pic --crate-type=dylib foo.rs --emit=link,obj\n \n ifdef IS_MSVC\n # FIXME(#28026)\n@@ -17,5 +16,4 @@ else\n others:\n \t$(RUSTC) -C relocation-model=static foo.rs\n \t$(call RUN,foo)\n-\t$(RUSTC) -C relocation-model=static --crate-type=dylib foo.rs\n endif"}, {"sha": "8e799ca1a430305f784326bbf454088f8f0540d8", "filename": "src/test/run-make/reproducible-build/Makefile", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Freproducible-build%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Freproducible-build%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Freproducible-build%2FMakefile?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,20 @@\n+-include ../tools.mk\n+all:\n+\t$(RUSTC) reproducible-build-aux.rs\n+\t$(RUSTC) reproducible-build.rs -o\"$(TMPDIR)/reproducible-build1\"\n+\t$(RUSTC) reproducible-build.rs -o\"$(TMPDIR)/reproducible-build2\"\n+\tnm \"$(TMPDIR)/reproducible-build1\" | sort > \"$(TMPDIR)/reproducible-build1.nm\"\n+\tnm \"$(TMPDIR)/reproducible-build2\" | sort > \"$(TMPDIR)/reproducible-build2.nm\"\n+\tcmp \"$(TMPDIR)/reproducible-build1.nm\" \"$(TMPDIR)/reproducible-build2.nm\" || exit 1\n+\t$(RUSTC) reproducible-build-aux.rs -g\n+\t$(RUSTC) reproducible-build.rs -g -o\"$(TMPDIR)/reproducible-build1-debug\"\n+\t$(RUSTC) reproducible-build.rs -g -o\"$(TMPDIR)/reproducible-build2-debug\"\n+\tnm \"$(TMPDIR)/reproducible-build1-debug\" | sort > \"$(TMPDIR)/reproducible-build1-debug.nm\"\n+\tnm \"$(TMPDIR)/reproducible-build2-debug\" | sort > \"$(TMPDIR)/reproducible-build2-debug.nm\"\n+\tcmp \"$(TMPDIR)/reproducible-build1-debug.nm\" \"$(TMPDIR)/reproducible-build2-debug.nm\" || exit 1\n+\t$(RUSTC) reproducible-build-aux.rs -O\n+\t$(RUSTC) reproducible-build.rs -O -o\"$(TMPDIR)/reproducible-build1-opt\"\n+\t$(RUSTC) reproducible-build.rs -O -o\"$(TMPDIR)/reproducible-build2-opt\"\n+\tnm \"$(TMPDIR)/reproducible-build1-opt\" | sort > \"$(TMPDIR)/reproducible-build1-opt.nm\"\n+\tnm \"$(TMPDIR)/reproducible-build2-opt\" | sort > \"$(TMPDIR)/reproducible-build2-opt.nm\"\n+\tcmp \"$(TMPDIR)/reproducible-build1-opt.nm\" \"$(TMPDIR)/reproducible-build2-opt.nm\" || exit 1"}, {"sha": "9ef853e79960b2d57771732bb5762e1b7029da9f", "filename": "src/test/run-make/reproducible-build/reproducible-build-aux.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Freproducible-build%2Freproducible-build-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Freproducible-build%2Freproducible-build-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Freproducible-build%2Freproducible-build-aux.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"lib\"]\n+\n+pub static STATIC: i32 = 1234;\n+\n+pub struct Struct<T1, T2> {\n+    _t1: std::marker::PhantomData<T1>,\n+    _t2: std::marker::PhantomData<T2>,\n+}\n+\n+pub fn regular_fn(_: i32) {}\n+\n+pub fn generic_fn<T1, T2>() {}\n+\n+impl<T1, T2> Drop for Struct<T1, T2> {\n+    fn drop(&mut self) {}\n+}\n+\n+pub enum Enum {\n+    Variant1,\n+    Variant2(u32),\n+    Variant3 { x: u32 }\n+}\n+\n+pub struct TupleStruct(pub i8, pub i16, pub i32, pub i64);\n+\n+pub trait Trait<T1, T2> {\n+    fn foo(&self);\n+}"}, {"sha": "dc7c702e5cc670e2befb493c9b5e8e44add131e1", "filename": "src/test/run-make/reproducible-build/reproducible-build.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Freproducible-build%2Freproducible-build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-make%2Freproducible-build%2Freproducible-build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Freproducible-build%2Freproducible-build.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test case makes sure that two identical invocations of the compiler\n+// (i.e. same code base, same compile-flags, same compiler-versions, etc.)\n+// produce the same output. In the past, symbol names of monomorphized functions\n+// were not deterministic (which we want to avoid).\n+//\n+// The test tries to exercise as many different paths into symbol name\n+// generation as possible:\n+//\n+// - regular functions\n+// - generic functions\n+// - methods\n+// - statics\n+// - closures\n+// - enum variant constructors\n+// - tuple struct constructors\n+// - drop glue\n+// - FnOnce adapters\n+// - Trait object shims\n+// - Fn Pointer shims\n+\n+#![allow(dead_code)]\n+\n+extern crate reproducible_build_aux;\n+\n+static STATIC: i32 = 1234;\n+\n+pub struct Struct<T1, T2> {\n+    x: T1,\n+    y: T2,\n+}\n+\n+fn regular_fn(_: i32) {}\n+\n+fn generic_fn<T1, T2>() {}\n+\n+impl<T1, T2> Drop for Struct<T1, T2> {\n+    fn drop(&mut self) {}\n+}\n+\n+pub enum Enum {\n+    Variant1,\n+    Variant2(u32),\n+    Variant3 { x: u32 }\n+}\n+\n+struct TupleStruct(i8, i16, i32, i64);\n+\n+impl TupleStruct {\n+    pub fn bar(&self) {}\n+}\n+\n+trait Trait<T1, T2> {\n+    fn foo(&self);\n+}\n+\n+impl Trait<i32, u64> for u64 {\n+    fn foo(&self) {}\n+}\n+\n+impl reproducible_build_aux::Trait<char, String> for TupleStruct {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    regular_fn(STATIC);\n+    generic_fn::<u32, char>();\n+    generic_fn::<char, Struct<u32, u64>>();\n+    generic_fn::<Struct<u64, u32>, reproducible_build_aux::Struct<u32, u64>>();\n+\n+    let dropped = Struct {\n+        x: \"\",\n+        y: 'a',\n+    };\n+\n+    let _ = Enum::Variant1;\n+    let _ = Enum::Variant2(0);\n+    let _ = Enum::Variant3 { x: 0 };\n+    let _ = TupleStruct(1, 2, 3, 4);\n+\n+    let closure  = |x| {\n+        x + 1i32\n+    };\n+\n+    fn inner<F: Fn(i32) -> i32>(f: F) -> i32 {\n+        f(STATIC)\n+    }\n+\n+    println!(\"{}\", inner(closure));\n+\n+    let object_shim: &Trait<i32, u64> = &0u64;\n+    object_shim.foo();\n+\n+    fn with_fn_once_adapter<F: FnOnce(i32)>(f: F) {\n+        f(0);\n+    }\n+\n+    with_fn_once_adapter(|_:i32| { });\n+\n+    reproducible_build_aux::regular_fn(STATIC);\n+    reproducible_build_aux::generic_fn::<u32, char>();\n+    reproducible_build_aux::generic_fn::<char, Struct<u32, u64>>();\n+    reproducible_build_aux::generic_fn::<Struct<u64, u32>,\n+                                         reproducible_build_aux::Struct<u32, u64>>();\n+\n+    let _ = reproducible_build_aux::Enum::Variant1;\n+    let _ = reproducible_build_aux::Enum::Variant2(0);\n+    let _ = reproducible_build_aux::Enum::Variant3 { x: 0 };\n+    let _ = reproducible_build_aux::TupleStruct(1, 2, 3, 4);\n+\n+    let object_shim: &reproducible_build_aux::Trait<char, String> = &TupleStruct(0, 1, 2, 3);\n+    object_shim.foo();\n+\n+    let pointer_shim: &Fn(i32) = &regular_fn;\n+\n+    TupleStruct(1, 2, 3, 4).bar();\n+}\n+\n+"}, {"sha": "36cac8f50a87c892627062ff9236bc6f3063410c", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -51,13 +51,29 @@ fn template(me: &str) -> Command {\n     return m;\n }\n \n+fn expected(fn_name: &str) -> String {\n+    // FIXME(#32481)\n+    //\n+    // On windows, we read the function name from debuginfo using some\n+    // system APIs. For whatever reason, these APIs seem to use the\n+    // \"name\" field, which is only the \"relative\" name, not the full\n+    // name with namespace info, so we just see `foo` and not\n+    // `backtrace::foo` as we see on linux (which uses the linkage\n+    // name).\n+    if cfg!(windows) && cfg!(target_env = \"msvc\") {\n+        format!(\" - {}\", fn_name)\n+    } else {\n+        format!(\" - backtrace::{}\", fn_name)\n+    }\n+}\n+\n fn runtest(me: &str) {\n     // Make sure that the stack trace is printed\n     let p = template(me).arg(\"fail\").env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(&out.stderr).unwrap();\n-    assert!(s.contains(\"stack backtrace\") && s.contains(\" - foo\"),\n+    assert!(s.contains(\"stack backtrace\") && s.contains(&expected(\"foo\")),\n             \"bad output: {}\", s);\n \n     // Make sure the stack trace is *not* printed\n@@ -67,7 +83,7 @@ fn runtest(me: &str) {\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(&out.stderr).unwrap();\n-    assert!(!s.contains(\"stack backtrace\") && !s.contains(\" - foo\"),\n+    assert!(!s.contains(\"stack backtrace\") && !s.contains(&expected(\"foo\")),\n             \"bad output2: {}\", s);\n \n     // Make sure a stack trace is printed\n@@ -77,7 +93,7 @@ fn runtest(me: &str) {\n     let s = str::from_utf8(&out.stderr).unwrap();\n     // loosened the following from double::h to double:: due to\n     // spurious failures on mac, 32bit, optimized\n-    assert!(s.contains(\"stack backtrace\") && s.contains(\" - double\"),\n+    assert!(s.contains(\"stack backtrace\") && s.contains(&expected(\"double\")),\n             \"bad output3: {}\", s);\n \n     // Make sure a stack trace isn't printed too many times"}, {"sha": "16560637b692667da1e96c0588ec638c1d1f29f7", "filename": "src/test/run-pass/command-before-exec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n // ignore-windows - this is a unix-specific test\n-// no-prefer-dynamic - this test breaks with dynamic linking as\n-// some LD_LIBRARY_PATH entries are relative and it cd's to /.\n \n #![feature(process_exec, libc)]\n "}, {"sha": "744e63f159b6566dc17ceb4187399bf043e2f495", "filename": "src/test/run-pass/issue-17718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:issue-17718.rs\n+// aux-build:issue-17718-aux.rs\n \n \n #![feature(core)]\n #![feature(const_fn)]\n \n-extern crate issue_17718 as other;\n+extern crate issue_17718_aux as other;\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n "}, {"sha": "4bd82baafeb100c32897ccf9584969dc98902d2d", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d2be6c61c17da8027a72da91f87a0e2487f74/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=8d2d2be6c61c17da8027a72da91f87a0e2487f74", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:typeid-intrinsic.rs\n-// aux-build:typeid-intrinsic2.rs\n+// aux-build:typeid-intrinsic-aux1.rs\n+// aux-build:typeid-intrinsic-aux2.rs\n \n #![feature(core_intrinsics)]\n \n-extern crate typeid_intrinsic as other1;\n-extern crate typeid_intrinsic2 as other2;\n+extern crate typeid_intrinsic_aux1 as other1;\n+extern crate typeid_intrinsic_aux2 as other2;\n \n use std::hash::{SipHasher, Hasher, Hash};\n use std::any::TypeId;"}]}