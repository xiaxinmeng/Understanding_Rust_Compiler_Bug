{"sha": "3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "node_id": "C_kwDOAAsO6NoAKDNkM2RhZmI3NzFmYjcxNGJhZWIzNjc5M2YyZDRjZDMzM2E4ZTljMzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-21T08:12:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-21T08:12:38Z"}, "message": "Auto merge of #95828 - vacuus:rustdoc-print-where-clause, r=notriddle\n\nrustdoc: Clean up `html::format::print_where_clause`\n\n(Arguably) closes https://github.com/rust-lang/rust/issues/95814", "tree": {"sha": "454d52f8f2cfc2ea0f29ed9262926e480f38d852", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/454d52f8f2cfc2ea0f29ed9262926e480f38d852"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "html_url": "https://github.com/rust-lang/rust/commit/3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d3dafb771fb714baeb36793f2d4cd333a8e9c34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5176945ad49005b82789be5700f5ae0e6efe5481", "url": "https://api.github.com/repos/rust-lang/rust/commits/5176945ad49005b82789be5700f5ae0e6efe5481", "html_url": "https://github.com/rust-lang/rust/commit/5176945ad49005b82789be5700f5ae0e6efe5481"}, {"sha": "5d59c16c2d2eda4089834061a2d6a21a733d9370", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d59c16c2d2eda4089834061a2d6a21a733d9370", "html_url": "https://github.com/rust-lang/rust/commit/5d59c16c2d2eda4089834061a2d6a21a733d9370"}], "stats": {"total": 132, "additions": 62, "deletions": 70}, "files": [{"sha": "d3545236e3dfe5a0d48cbc073e13b8d835a13f54", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 62, "deletions": 70, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/3d3dafb771fb714baeb36793f2d4cd333a8e9c34/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3dafb771fb714baeb36793f2d4cd333a8e9c34/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "patch": "@@ -267,6 +267,8 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n     indent: usize,\n     end_newline: bool,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    use fmt::Write;\n+\n     display_fn(move |f| {\n         let mut where_predicates = gens.where_predicates.iter().filter(|pred| {\n             !matches!(pred, clean::WherePredicate::BoundPredicate { bounds, .. } if bounds.is_empty())\n@@ -280,56 +282,44 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n \n                 match pred {\n                     clean::WherePredicate::BoundPredicate { ty, bounds, bound_params } => {\n-                        let bounds = bounds;\n-                        let for_prefix = if bound_params.is_empty() {\n-                            String::new()\n-                        } else if f.alternate() {\n-                            format!(\n-                                \"for&lt;{:#}&gt; \",\n-                                comma_sep(bound_params.iter().map(|lt| lt.print()), true)\n-                            )\n-                        } else {\n-                            format!(\n-                                \"for&lt;{}&gt; \",\n-                                comma_sep(bound_params.iter().map(|lt| lt.print()), true)\n-                            )\n-                        };\n+                        let ty_cx = ty.print(cx);\n+                        let generic_bounds = print_generic_bounds(bounds, cx);\n \n-                        if f.alternate() {\n-                            write!(\n-                                f,\n-                                \"{}{:#}: {:#}\",\n-                                for_prefix,\n-                                ty.print(cx),\n-                                print_generic_bounds(bounds, cx)\n-                            )\n+                        if bound_params.is_empty() {\n+                            if f.alternate() {\n+                                write!(f, \"{ty_cx:#}: {generic_bounds:#}\")\n+                            } else {\n+                                write!(f, \"{ty_cx}: {generic_bounds}\")\n+                            }\n                         } else {\n-                            write!(\n-                                f,\n-                                \"{}{}: {}\",\n-                                for_prefix,\n-                                ty.print(cx),\n-                                print_generic_bounds(bounds, cx)\n-                            )\n+                            if f.alternate() {\n+                                write!(\n+                                    f,\n+                                    \"for<{:#}> {ty_cx:#}: {generic_bounds:#}\",\n+                                    comma_sep(bound_params.iter().map(|lt| lt.print()), true)\n+                                )\n+                            } else {\n+                                write!(\n+                                    f,\n+                                    \"for&lt;{}&gt; {ty_cx}: {generic_bounds}\",\n+                                    comma_sep(bound_params.iter().map(|lt| lt.print()), true)\n+                                )\n+                            }\n                         }\n                     }\n                     clean::WherePredicate::RegionPredicate { lifetime, bounds } => {\n-                        write!(\n-                            f,\n-                            \"{}: {}\",\n-                            lifetime.print(),\n-                            bounds\n-                                .iter()\n-                                .map(|b| b.print(cx).to_string())\n-                                .collect::<Vec<_>>()\n-                                .join(\" + \")\n-                        )\n+                        let mut bounds_display = String::new();\n+                        for bound in bounds.iter().map(|b| b.print(cx)) {\n+                            write!(bounds_display, \"{bound} + \")?;\n+                        }\n+                        bounds_display.truncate(bounds_display.len() - \" + \".len());\n+                        write!(f, \"{}: {bounds_display}\", lifetime.print())\n                     }\n                     clean::WherePredicate::EqPredicate { lhs, rhs } => {\n                         if f.alternate() {\n-                            write!(f, \"{:#} == {:#}\", lhs.print(cx), rhs.print(cx),)\n+                            write!(f, \"{:#} == {:#}\", lhs.print(cx), rhs.print(cx))\n                         } else {\n-                            write!(f, \"{} == {}\", lhs.print(cx), rhs.print(cx),)\n+                            write!(f, \"{} == {}\", lhs.print(cx), rhs.print(cx))\n                         }\n                     }\n                 }\n@@ -340,41 +330,43 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n             return Ok(());\n         }\n \n-        let mut clause = String::new();\n-\n-        if f.alternate() {\n-            clause.push_str(\" where\");\n-        } else {\n+        let where_preds = comma_sep(where_predicates, false);\n+        let clause = if f.alternate() {\n             if end_newline {\n-                clause.push_str(\" <span class=\\\"where fmt-newline\\\">where\");\n+                // add a space so stripping <br> tags and breaking spaces still renders properly\n+                format!(\" where{where_preds}, \")\n             } else {\n-                clause.push_str(\" <span class=\\\"where\\\">where\");\n+                format!(\" where{where_preds}\")\n             }\n-        }\n-\n-        clause.push_str(&comma_sep(where_predicates, false).to_string());\n-\n-        if end_newline {\n-            clause.push(',');\n-            // add a space so stripping <br> tags and breaking spaces still renders properly\n-            if f.alternate() {\n-                clause.push(' ');\n-            } else {\n-                clause.push_str(\"&nbsp;\");\n+        } else {\n+            let mut br_with_padding = String::with_capacity(6 * indent + 28);\n+            br_with_padding.push_str(\"<br>\");\n+            for _ in 0..indent + 4 {\n+                br_with_padding.push_str(\"&nbsp;\");\n             }\n-        }\n+            let where_preds = where_preds.to_string().replace(\"<br>\", &br_with_padding);\n \n-        if !f.alternate() {\n-            clause.push_str(\"</span>\");\n-            let padding = \"&nbsp;\".repeat(indent + 4);\n-            clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n-            clause.insert_str(0, &\"&nbsp;\".repeat(indent.saturating_sub(1)));\n-            if !end_newline {\n-                // we insert the <br> after a single space but before multiple spaces at the start\n-                clause.insert_str(if indent == 0 { 1 } else { 0 }, \"<br>\");\n+            if end_newline {\n+                let mut clause = \"&nbsp;\".repeat(indent.saturating_sub(1));\n+                // add a space so stripping <br> tags and breaking spaces still renders properly\n+                write!(\n+                    clause,\n+                    \" <span class=\\\"where fmt-newline\\\">where{where_preds},&nbsp;</span>\"\n+                )?;\n+                clause\n+            } else {\n+                // insert a <br> tag after a single space but before multiple spaces at the start\n+                if indent == 0 {\n+                    format!(\" <br><span class=\\\"where\\\">where{where_preds}</span>\")\n+                } else {\n+                    let mut clause = br_with_padding;\n+                    clause.truncate(clause.len() - 5 * \"&nbsp;\".len());\n+                    write!(clause, \" <span class=\\\"where\\\">where{where_preds}</span>\")?;\n+                    clause\n+                }\n             }\n-        }\n-        write!(f, \"{}\", clause)\n+        };\n+        write!(f, \"{clause}\")\n     })\n }\n "}]}