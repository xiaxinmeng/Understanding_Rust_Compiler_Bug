{"sha": "729185338f1726f60ea2dc282fe6bbf0eb84cb17", "node_id": "C_kwDOAAsO6NoAKDcyOTE4NTMzOGYxNzI2ZjYwZWEyZGMyODJmZTZiYmYwZWI4NGNiMTc", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-01-05T19:17:30Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-03-14T13:16:52Z"}, "message": "Properly allow macro expanded `format_args` invocations to uses captures\n\nOriginally, this was kinda half-allowed. There were some primitive\nchecks in place that looked at the span to see whether the input was\nlikely a literal. These \"source literal\" checks are needed because the\nspans created during `format_args` parsing only make sense when it is\nindeed a literal that was written in the source code directly.\n\nThis is orthogonal to the restriction that the first argument must be a\n\"direct literal\", not being exanpanded from macros. This restriction was\nimposed by [RFC 2795] on the basis of being too confusing. But this was\nonly concerned with the argument of the invocation being a literal, not\nwhether it was a source literal (maybe in spirit it meant it being a\nsource literal, this is not clear to me).\n\nSince the original check only really cared about source literals (which\nis good enough to deny the `format_args!(concat!())` example), macros\nexpanding to `format_args` invocations were able to use implicit\ncaptures if they spanned the string in a way that lead back to a source\nstring.\n\nThe \"source literal\" checks were not strict enough and caused ICEs in\ncertain cases (see # 106191 (the space is intended to avoid spammy\nbackreferences)). So I tightened it up in # 106195 to really only work\nif it's a direct source literal.\n\nThis caused the `indoc` crate to break. `indoc` transformed the source\nliteral by removing whitespace, which made it not a \"source literal\"\nanymore (which is required to fix the ICE). But since `indoc` spanned\nthe literal in ways that made the old check think that it's a literal,\nit was able to use implicit captures (which is useful and nice for the\nusers of `indoc`).\n\nThis commit properly seperates the previously introduced concepts of\n\"source literal\" and \"direct literal\" and therefore allows `indoc`\ninvocations, which don't create \"source literals\" to use implicit\ncaptures again.\n\n[RFC 2795]: https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html#macro-hygiene", "tree": {"sha": "e84828d0610ea806f017a1ba76014199c180e8f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e84828d0610ea806f017a1ba76014199c180e8f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/729185338f1726f60ea2dc282fe6bbf0eb84cb17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/729185338f1726f60ea2dc282fe6bbf0eb84cb17", "html_url": "https://github.com/rust-lang/rust/commit/729185338f1726f60ea2dc282fe6bbf0eb84cb17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/729185338f1726f60ea2dc282fe6bbf0eb84cb17/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0058748944abb3282aba0e0a74823c6411703565", "url": "https://api.github.com/repos/rust-lang/rust/commits/0058748944abb3282aba0e0a74823c6411703565", "html_url": "https://github.com/rust-lang/rust/commit/0058748944abb3282aba0e0a74823c6411703565"}], "stats": {"total": 260, "additions": 198, "deletions": 62}, "files": [{"sha": "db2ef7fba4b8ea2baeec25f3d04103d4eeee14af", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -36,6 +36,21 @@ enum PositionUsedAs {\n }\n use PositionUsedAs::*;\n \n+struct MacroInput {\n+    fmtstr: P<Expr>,\n+    args: FormatArguments,\n+    /// Whether the first argument was a string literal or a result from eager macro expansion.\n+    /// If it's not a string literal, we disallow implicit arugment capturing.\n+    ///\n+    /// This does not correspond to whether we can treat spans to the literal normally, as the whole\n+    /// invocation might be the result of another macro expansion, in which case this flag may still be true.\n+    ///\n+    /// See [RFC 2795] for more information.\n+    ///\n+    /// [RFC 2795]: https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html#macro-hygiene\n+    is_direct_literal: bool,\n+}\n+\n /// Parses the arguments from the given list of tokens, returning the diagnostic\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n@@ -45,11 +60,7 @@ use PositionUsedAs::*;\n /// ```text\n /// Ok((fmtstr, parsed arguments))\n /// ```\n-fn parse_args<'a>(\n-    ecx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> PResult<'a, (P<Expr>, FormatArguments)> {\n+fn parse_args<'a>(ecx: &mut ExtCtxt<'a>, sp: Span, tts: TokenStream) -> PResult<'a, MacroInput> {\n     let mut args = FormatArguments::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -59,25 +70,21 @@ fn parse_args<'a>(\n     }\n \n     let first_token = &p.token;\n-    let fmtstr = match first_token.kind {\n-        token::TokenKind::Literal(token::Lit {\n-            kind: token::LitKind::Str | token::LitKind::StrRaw(_),\n-            ..\n-        }) => {\n-            // If the first token is a string literal, then a format expression\n-            // is constructed from it.\n-            //\n-            // This allows us to properly handle cases when the first comma\n-            // after the format string is mistakenly replaced with any operator,\n-            // which cause the expression parser to eat too much tokens.\n-            p.parse_literal_maybe_minus()?\n-        }\n-        _ => {\n-            // Otherwise, we fall back to the expression parser.\n-            p.parse_expr()?\n-        }\n+\n+    let fmtstr = if let token::Literal(lit) = first_token.kind && matches!(lit.kind, token::Str | token::StrRaw(_)) {\n+        // This allows us to properly handle cases when the first comma\n+        // after the format string is mistakenly replaced with any operator,\n+        // which cause the expression parser to eat too much tokens.\n+        p.parse_literal_maybe_minus()?\n+    } else {\n+        // Otherwise, we fall back to the expression parser.\n+        p.parse_expr()?\n     };\n \n+    // Only allow implicit captures to be used when the argument is a direct literal\n+    // instead of a macro expanding to one.\n+    let is_direct_literal = matches!(fmtstr.kind, ExprKind::Lit(_));\n+\n     let mut first = true;\n \n     while p.token != token::Eof {\n@@ -147,17 +154,19 @@ fn parse_args<'a>(\n             }\n         }\n     }\n-    Ok((fmtstr, args))\n+    Ok(MacroInput { fmtstr, args, is_direct_literal })\n }\n \n-pub fn make_format_args(\n+fn make_format_args(\n     ecx: &mut ExtCtxt<'_>,\n-    efmt: P<Expr>,\n-    mut args: FormatArguments,\n+    input: MacroInput,\n     append_newline: bool,\n ) -> Result<FormatArgs, ()> {\n     let msg = \"format argument must be a string literal\";\n-    let unexpanded_fmt_span = efmt.span;\n+    let unexpanded_fmt_span = input.fmtstr.span;\n+\n+    let MacroInput { fmtstr: efmt, mut args, is_direct_literal } = input;\n+\n     let (fmt_str, fmt_style, fmt_span) = match expr_to_spanned_string(ecx, efmt, msg) {\n         Ok(mut fmt) if append_newline => {\n             fmt.0 = Symbol::intern(&format!(\"{}\\n\", fmt.0));\n@@ -208,11 +217,11 @@ pub fn make_format_args(\n         }\n     }\n \n-    let is_literal = parser.is_literal;\n+    let is_source_literal = parser.is_source_literal;\n \n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n-        let sp = if is_literal {\n+        let sp = if is_source_literal {\n             fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end))\n         } else {\n             // The format string could be another macro invocation, e.g.:\n@@ -230,7 +239,7 @@ pub fn make_format_args(\n         if let Some(note) = err.note {\n             e.note(&note);\n         }\n-        if let Some((label, span)) = err.secondary_label && is_literal {\n+        if let Some((label, span)) = err.secondary_label && is_source_literal {\n             e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n         }\n         if err.should_be_replaced_with_positional_argument {\n@@ -256,7 +265,7 @@ pub fn make_format_args(\n     }\n \n     let to_span = |inner_span: rustc_parse_format::InnerSpan| {\n-        is_literal.then(|| {\n+        is_source_literal.then(|| {\n             fmt_span.from_inner(InnerSpan { start: inner_span.start, end: inner_span.end })\n         })\n     };\n@@ -304,7 +313,7 @@ pub fn make_format_args(\n                     // Name not found in `args`, so we add it as an implicitly captured argument.\n                     let span = span.unwrap_or(fmt_span);\n                     let ident = Ident::new(name, span);\n-                    let expr = if is_literal {\n+                    let expr = if is_direct_literal {\n                         ecx.expr_ident(span, ident)\n                     } else {\n                         // For the moment capturing variables from format strings expanded from macros is\n@@ -814,7 +823,7 @@ fn report_invalid_references(\n         // for `println!(\"{7:7$}\", 1);`\n         indexes.sort();\n         indexes.dedup();\n-        let span: MultiSpan = if !parser.is_literal || parser.arg_places.is_empty() {\n+        let span: MultiSpan = if !parser.is_source_literal || parser.arg_places.is_empty() {\n             MultiSpan::from_span(fmt_span)\n         } else {\n             MultiSpan::from_spans(invalid_refs.iter().filter_map(|&(_, span, _, _)| span).collect())\n@@ -855,8 +864,8 @@ fn expand_format_args_impl<'cx>(\n ) -> Box<dyn base::MacResult + 'cx> {\n     sp = ecx.with_def_site_ctxt(sp);\n     match parse_args(ecx, sp, tts) {\n-        Ok((efmt, args)) => {\n-            if let Ok(format_args) = make_format_args(ecx, efmt, args, nl) {\n+        Ok(input) => {\n+            if let Ok(format_args) = make_format_args(ecx, input, nl) {\n                 MacEager::expr(ecx.expr(sp, ExprKind::FormatArgs(P(format_args))))\n             } else {\n                 MacEager::expr(DummyResult::raw_expr(sp, true))"}, {"sha": "d67239efa80eb6486b097d66966f343de87592bf", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -234,8 +234,10 @@ pub struct Parser<'a> {\n     last_opening_brace: Option<InnerSpan>,\n     /// Whether the source string is comes from `println!` as opposed to `format!` or `print!`\n     append_newline: bool,\n-    /// Whether this formatting string is a literal or it comes from a macro.\n-    pub is_literal: bool,\n+    /// Whether this formatting string was written directly in the source. This controls whether we\n+    /// can use spans to refer into it and give better error messages.\n+    /// N.B: This does _not_ control whether implicit argument captures can be used.\n+    pub is_source_literal: bool,\n     /// Start position of the current line.\n     cur_line_start: usize,\n     /// Start and end byte offset of every line of the format string. Excludes\n@@ -262,7 +264,7 @@ impl<'a> Iterator for Parser<'a> {\n                     } else {\n                         let arg = self.argument(lbrace_end);\n                         if let Some(rbrace_pos) = self.must_consume('}') {\n-                            if self.is_literal {\n+                            if self.is_source_literal {\n                                 let lbrace_byte_pos = self.to_span_index(pos);\n                                 let rbrace_byte_pos = self.to_span_index(rbrace_pos);\n \n@@ -302,7 +304,7 @@ impl<'a> Iterator for Parser<'a> {\n                 _ => Some(String(self.string(pos))),\n             }\n         } else {\n-            if self.is_literal {\n+            if self.is_source_literal {\n                 let span = self.span(self.cur_line_start, self.input.len());\n                 if self.line_spans.last() != Some(&span) {\n                     self.line_spans.push(span);\n@@ -323,7 +325,7 @@ impl<'a> Parser<'a> {\n         mode: ParseMode,\n     ) -> Parser<'a> {\n         let input_string_kind = find_width_map_from_snippet(snippet, style);\n-        let (width_map, is_literal) = match input_string_kind {\n+        let (width_map, is_source_literal) = match input_string_kind {\n             InputStringKind::Literal { width_mappings } => (width_mappings, true),\n             InputStringKind::NotALiteral => (Vec::new(), false),\n         };\n@@ -339,7 +341,7 @@ impl<'a> Parser<'a> {\n             width_map,\n             last_opening_brace: None,\n             append_newline,\n-            is_literal,\n+            is_source_literal,\n             cur_line_start: 0,\n             line_spans: vec![],\n         }\n@@ -532,13 +534,13 @@ impl<'a> Parser<'a> {\n                 '{' | '}' => {\n                     return &self.input[start..pos];\n                 }\n-                '\\n' if self.is_literal => {\n+                '\\n' if self.is_source_literal => {\n                     self.line_spans.push(self.span(self.cur_line_start, pos));\n                     self.cur_line_start = pos + 1;\n                     self.cur.next();\n                 }\n                 _ => {\n-                    if self.is_literal && pos == self.cur_line_start && c.is_whitespace() {\n+                    if self.is_source_literal && pos == self.cur_line_start && c.is_whitespace() {\n                         self.cur_line_start = pos + c.len_utf8();\n                     }\n                     self.cur.next();"}, {"sha": "0c39ade721fac488bbb19f275ac153878c3b2441", "filename": "tests/ui/fmt/auxiliary/format-string-proc-macro.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fauxiliary%2Fformat-string-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fauxiliary%2Fformat-string-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fauxiliary%2Fformat-string-proc-macro.rs?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -28,25 +28,41 @@ pub fn err_with_input_span(input: TokenStream) -> TokenStream {\n     TokenStream::from(TokenTree::Literal(lit))\n }\n \n+fn build_format(args: impl Into<TokenStream>) -> TokenStream {\n+    TokenStream::from_iter([\n+        TokenTree::from(Ident::new(\"format\", Span::call_site())),\n+        TokenTree::from(Punct::new('!', Spacing::Alone)),\n+        TokenTree::from(Group::new(Delimiter::Parenthesis, args.into())),\n+    ])\n+}\n \n #[proc_macro]\n pub fn respan_to_invalid_format_literal(input: TokenStream) -> TokenStream {\n     let mut s = Literal::string(\"{\");\n     s.set_span(input.into_iter().next().unwrap().span());\n-    TokenStream::from_iter([\n-        TokenTree::from(Ident::new(\"format\", Span::call_site())),\n-        TokenTree::from(Punct::new('!', Spacing::Alone)),\n-        TokenTree::from(Group::new(Delimiter::Parenthesis, TokenTree::from(s).into())),\n-    ])\n+\n+    build_format(TokenTree::from(s))\n }\n \n #[proc_macro]\n pub fn capture_a_with_prepended_space_preserve_span(input: TokenStream) -> TokenStream {\n     let mut s = Literal::string(\" {a}\");\n     s.set_span(input.into_iter().next().unwrap().span());\n-    TokenStream::from_iter([\n-        TokenTree::from(Ident::new(\"format\", Span::call_site())),\n-        TokenTree::from(Punct::new('!', Spacing::Alone)),\n-        TokenTree::from(Group::new(Delimiter::Parenthesis, TokenTree::from(s).into())),\n-    ])\n+\n+    build_format(TokenTree::from(s))\n+}\n+\n+#[proc_macro]\n+pub fn format_args_captures(_: TokenStream) -> TokenStream {\n+    r#\"{ let x = 5; format!(\"{x}\") }\"#.parse().unwrap()\n+}\n+\n+#[proc_macro]\n+pub fn bad_format_args_captures(_: TokenStream) -> TokenStream {\n+    r#\"{ let x = 5; format!(concat!(\"{x}\")) }\"#.parse().unwrap()\n+}\n+\n+#[proc_macro]\n+pub fn identity_pm(input: TokenStream) -> TokenStream {\n+    input\n }"}, {"sha": "bf5c0dcb54d39b946e60957f77c3c16f30e08899", "filename": "tests/ui/fmt/format-args-capture-first-literal-is-macro.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-first-literal-is-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-first-literal-is-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fformat-args-capture-first-literal-is-macro.rs?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -0,0 +1,21 @@\n+// aux-build:format-string-proc-macro.rs\n+\n+#[macro_use]\n+extern crate format_string_proc_macro;\n+\n+macro_rules! identity_mbe {\n+    ($tt:tt) => {\n+        $tt\n+        //~^ ERROR there is no argument named `a`\n+    };\n+}\n+\n+fn main() {\n+    let a = 0;\n+\n+    format!(identity_pm!(\"{a}\"));\n+    //~^ ERROR there is no argument named `a`\n+    format!(identity_mbe!(\"{a}\"));\n+    format!(concat!(\"{a}\"));\n+    //~^ ERROR there is no argument named `a`\n+}"}, {"sha": "4cf3afad7b8f4b970efecfa356d0f9bb1754ea6d", "filename": "tests/ui/fmt/format-args-capture-first-literal-is-macro.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-first-literal-is-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-first-literal-is-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fformat-args-capture-first-literal-is-macro.stderr?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -0,0 +1,30 @@\n+error: there is no argument named `a`\n+  --> $DIR/format-args-capture-first-literal-is-macro.rs:16:26\n+   |\n+LL |     format!(identity_pm!(\"{a}\"));\n+   |                          ^^^^^\n+   |\n+   = note: did you intend to capture a variable `a` from the surrounding scope?\n+   = note: to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n+\n+error: there is no argument named `a`\n+  --> $DIR/format-args-capture-first-literal-is-macro.rs:8:9\n+   |\n+LL |         $tt\n+   |         ^^^\n+   |\n+   = note: did you intend to capture a variable `a` from the surrounding scope?\n+   = note: to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n+\n+error: there is no argument named `a`\n+  --> $DIR/format-args-capture-first-literal-is-macro.rs:19:13\n+   |\n+LL |     format!(concat!(\"{a}\"));\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = note: did you intend to capture a variable `a` from the surrounding scope?\n+   = note: to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n+   = note: this error originates in the macro `concat` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "f67edf5e1672175b13f3d2a1cda6804b01b6abab", "filename": "tests/ui/fmt/format-args-capture-from-pm-first-arg-macro.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-from-pm-first-arg-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-from-pm-first-arg-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fformat-args-capture-from-pm-first-arg-macro.rs?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -0,0 +1,8 @@\n+// aux-build:format-string-proc-macro.rs\n+\n+extern crate format_string_proc_macro;\n+\n+fn main() {\n+    format_string_proc_macro::bad_format_args_captures!();\n+    //~^ ERROR there is no argument named `x`\n+}"}, {"sha": "bb6a14d88b3d6ab52fa8fab01e49adb6cc86fb5e", "filename": "tests/ui/fmt/format-args-capture-from-pm-first-arg-macro.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-from-pm-first-arg-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-from-pm-first-arg-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fformat-args-capture-from-pm-first-arg-macro.stderr?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -0,0 +1,12 @@\n+error: there is no argument named `x`\n+  --> $DIR/format-args-capture-from-pm-first-arg-macro.rs:6:5\n+   |\n+LL |     format_string_proc_macro::bad_format_args_captures!();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: did you intend to capture a variable `x` from the surrounding scope?\n+   = note: to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n+   = note: this error originates in the macro `concat` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "0fd195416ee5b6949e542bc4824d9407258c4773", "filename": "tests/ui/fmt/format-args-capture-issue-106408.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-issue-106408.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-issue-106408.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fformat-args-capture-issue-106408.rs?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+// aux-build:format-string-proc-macro.rs\n+\n+extern crate format_string_proc_macro;\n+\n+fn main() {\n+    // While literal macros like `format_args!(concat!())` are not supposed to work with implicit\n+    // captures, it should work if the whole invocation comes from a macro expansion (#106408).\n+    format_string_proc_macro::format_args_captures!();\n+}"}, {"sha": "7553fcc4e01cb5563e40f56afb2208a5e36c0272", "filename": "tests/ui/fmt/format-args-capture-macro-hygiene-pass.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-macro-hygiene-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Fformat-args-capture-macro-hygiene-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fformat-args-capture-macro-hygiene-pass.rs?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+\n+macro_rules! format_mbe {\n+    ($tt:tt) => {\n+        {\n+            #[allow(unused_variables)]\n+            let a = 123;\n+            format!($tt)\n+        }\n+    };\n+}\n+\n+fn main() {\n+    let a = 0;\n+    assert_eq!(format_mbe!(\"{a}\"), \"0\");\n+}"}, {"sha": "44642a10fc076d3c0dfd2bbee21ad09942ebb5b7", "filename": "tests/ui/fmt/respanned-literal-issue-106191.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Frespanned-literal-issue-106191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Frespanned-literal-issue-106191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Frespanned-literal-issue-106191.rs?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -1,15 +1,10 @@\n // aux-build:format-string-proc-macro.rs\n-// check-fail\n-// known-bug: #106191\n-// unset-rustc-env:RUST_BACKTRACE\n-// had to be reverted\n-// error-pattern:unexpectedly panicked\n-// failure-status:101\n-// dont-check-compiler-stderr\n \n extern crate format_string_proc_macro;\n \n fn main() {\n     format_string_proc_macro::respan_to_invalid_format_literal!(\"\u00a1\");\n+    //~^ ERROR invalid format string: expected `'}'` but string was terminated\n     format_args!(r#concat!(\"\u00a1        {\"));\n+    //~^ ERROR invalid format string: expected `'}'` but string was terminated\n }"}, {"sha": "73a3af65a3849dbce8754f03987a89fc49bb0343", "filename": "tests/ui/fmt/respanned-literal-issue-106191.stderr", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Frespanned-literal-issue-106191.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/729185338f1726f60ea2dc282fe6bbf0eb84cb17/tests%2Fui%2Ffmt%2Frespanned-literal-issue-106191.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Frespanned-literal-issue-106191.stderr?ref=729185338f1726f60ea2dc282fe6bbf0eb84cb17", "patch": "@@ -1,2 +1,19 @@\n-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  query stack during panic:\n-end of query stack\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/respanned-literal-issue-106191.rs:6:65\n+   |\n+LL |     format_string_proc_macro::respan_to_invalid_format_literal!(\"\u00a1\");\n+   |                                                                 ^^^ expected `'}'` in format string\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/respanned-literal-issue-106191.rs:8:18\n+   |\n+LL |     format_args!(r#concat!(\"\u00a1        {\"));\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected `'}'` in format string\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+   = note: this error originates in the macro `concat` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+"}]}