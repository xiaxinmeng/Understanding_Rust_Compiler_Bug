{"sha": "4f83717cf768adb0b0dfe23b8eecf2b259eec354", "node_id": "C_kwDOAAsO6NoAKDRmODM3MTdjZjc2OGFkYjBiMGRmZTIzYjhlZWNmMmIyNTllZWMzNTQ", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-05-17T10:30:14Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-06-01T14:45:18Z"}, "message": "Use translatable diagnostics in `rustc_const_eval`", "tree": {"sha": "bac79441d2e21eda2a702697484bba96d7cacf7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bac79441d2e21eda2a702697484bba96d7cacf7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f83717cf768adb0b0dfe23b8eecf2b259eec354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f83717cf768adb0b0dfe23b8eecf2b259eec354", "html_url": "https://github.com/rust-lang/rust/commit/4f83717cf768adb0b0dfe23b8eecf2b259eec354", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f83717cf768adb0b0dfe23b8eecf2b259eec354/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "642c92e63008ffb49f6ad8344e07bfa7d5b0d9bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/642c92e63008ffb49f6ad8344e07bfa7d5b0d9bb", "html_url": "https://github.com/rust-lang/rust/commit/642c92e63008ffb49f6ad8344e07bfa7d5b0d9bb"}], "stats": {"total": 3488, "additions": 2370, "deletions": 1118}, "files": [{"sha": "2ee63c286ba5cc1c8a2a17254792cf0cdbcc75ae", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -209,7 +209,7 @@ pub enum TargetDataLayoutErrors<'a> {\n     InvalidAddressSpace { addr_space: &'a str, cause: &'a str, err: ParseIntError },\n     InvalidBits { kind: &'a str, bit: &'a str, cause: &'a str, err: ParseIntError },\n     MissingAlignment { cause: &'a str },\n-    InvalidAlignment { cause: &'a str, err: String },\n+    InvalidAlignment { cause: &'a str, err: AlignFromBytesError },\n     InconsistentTargetArchitecture { dl: &'a str, target: &'a str },\n     InconsistentTargetPointerWidth { pointer_size: u64, target: u32 },\n     InvalidBitsSize { err: String },\n@@ -640,30 +640,65 @@ impl fmt::Debug for Align {\n     }\n }\n \n+#[derive(Clone, Copy)]\n+pub enum AlignFromBytesError {\n+    NotPowerOfTwo(u64),\n+    TooLarge(u64),\n+}\n+\n+impl AlignFromBytesError {\n+    pub fn diag_ident(self) -> &'static str {\n+        match self {\n+            Self::NotPowerOfTwo(_) => \"not_power_of_two\",\n+            Self::TooLarge(_) => \"too_large\",\n+        }\n+    }\n+\n+    pub fn align(self) -> u64 {\n+        let (Self::NotPowerOfTwo(align) | Self::TooLarge(align)) = self;\n+        align\n+    }\n+}\n+\n+impl fmt::Debug for AlignFromBytesError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for AlignFromBytesError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AlignFromBytesError::NotPowerOfTwo(align) => write!(f, \"`{align}` is not a power of 2\"),\n+            AlignFromBytesError::TooLarge(align) => write!(f, \"`{align}` is too large\"),\n+        }\n+    }\n+}\n+\n impl Align {\n     pub const ONE: Align = Align { pow2: 0 };\n     pub const MAX: Align = Align { pow2: 29 };\n \n     #[inline]\n-    pub fn from_bits(bits: u64) -> Result<Align, String> {\n+    pub fn from_bits(bits: u64) -> Result<Align, AlignFromBytesError> {\n         Align::from_bytes(Size::from_bits(bits).bytes())\n     }\n \n     #[inline]\n-    pub fn from_bytes(align: u64) -> Result<Align, String> {\n+    pub fn from_bytes(align: u64) -> Result<Align, AlignFromBytesError> {\n         // Treat an alignment of 0 bytes like 1-byte alignment.\n         if align == 0 {\n             return Ok(Align::ONE);\n         }\n \n         #[cold]\n-        fn not_power_of_2(align: u64) -> String {\n-            format!(\"`{}` is not a power of 2\", align)\n+        fn not_power_of_2(align: u64) -> AlignFromBytesError {\n+            AlignFromBytesError::NotPowerOfTwo(align)\n         }\n \n         #[cold]\n-        fn too_large(align: u64) -> String {\n-            format!(\"`{}` is too large\", align)\n+        fn too_large(align: u64) -> AlignFromBytesError {\n+            AlignFromBytesError::TooLarge(align)\n         }\n \n         let tz = align.trailing_zeros();"}, {"sha": "7243cf6da232e3afe06fe45ae47fded5766c79a9", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -6,6 +6,7 @@ use rustc_index::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n };\n+use rustc_span::source_map::Spanned;\n use rustc_span::SourceFile;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n@@ -495,25 +496,16 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for RevealAllLayoutCx<'tcx> {\n         fn_abi_request: FnAbiRequest<'tcx>,\n     ) -> ! {\n         if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n-            self.0.sess.span_fatal(span, err.to_string())\n+            self.0.sess.emit_fatal(Spanned { span, node: err })\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {\n-                    span_bug!(\n-                        span,\n-                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n-                        sig,\n-                        extra_args,\n-                        err\n-                    );\n+                    span_bug!(span, \"`fn_abi_of_fn_ptr({sig}, {extra_args:?})` failed: {err:?}\");\n                 }\n                 FnAbiRequest::OfInstance { instance, extra_args } => {\n                     span_bug!(\n                         span,\n-                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n-                        instance,\n-                        extra_args,\n-                        err\n+                        \"`fn_abi_of_instance({instance}, {extra_args:?})` failed: {err:?}\"\n                     );\n                 }\n             }"}, {"sha": "33e3b0baa9236fedfaf3e4c141cab0e4b2bc4833", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -24,7 +24,7 @@ fn set_global_alignment<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, gv: LValue<'gcc>\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n-                cx.sess().emit_err(InvalidMinimumAlignment { err });\n+                cx.sess().emit_err(InvalidMinimumAlignment { err: err.to_string() });\n             }\n         }\n     }"}, {"sha": "08507e19652b40433d04e19aa9b1f4ad0f347538", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -477,7 +477,7 @@ impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().emit_fatal(respan(span, err))\n+            self.sess().emit_fatal(respan(span, err.into_diagnostic()))\n         } else {\n             span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n         }\n@@ -499,21 +499,12 @@ impl<'gcc, 'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {\n-                    span_bug!(\n-                        span,\n-                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n-                        sig,\n-                        extra_args,\n-                        err\n-                    );\n+                    span_bug!(span, \"`fn_abi_of_fn_ptr({sig}, {extra_args:?})` failed: {err:?}\");\n                 }\n                 FnAbiRequest::OfInstance { instance, extra_args } => {\n                     span_bug!(\n                         span,\n-                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n-                        instance,\n-                        extra_args,\n-                        err\n+                        \"`fn_abi_of_instance({instance}, {extra_args:?})` failed: {err:?}\"\n                     );\n                 }\n             }"}, {"sha": "de1622951fed41630fa207eec1de3946e1559b70", "filename": "compiler/rustc_codegen_llvm/messages.ftl", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fmessages.ftl?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -20,8 +20,12 @@ codegen_llvm_error_writing_def_file =\n codegen_llvm_from_llvm_diag = {$message}\n \n codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name} ({$kind}): {$message}\n-codegen_llvm_invalid_minimum_alignment =\n-    invalid minimum global alignment: {$err}\n+\n+codegen_llvm_invalid_minimum_alignment_not_power_of_two =\n+    invalid minimum global alignment: {$align} is not power of 2\n+\n+codegen_llvm_invalid_minimum_alignment_too_large =\n+    invalid minimum global alignment: {$align} is too large\n \n codegen_llvm_load_bitcode = failed to load bitcode of module \"{$name}\"\n codegen_llvm_load_bitcode_with_llvm_err = failed to load bitcode of module \"{$name}\": {$llvm_err}"}, {"sha": "df52f50f86f05f81950d8ad060ebad6faae55068", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,7 +1,9 @@\n use crate::base;\n use crate::common::{self, CodegenCx};\n use crate::debuginfo;\n-use crate::errors::{InvalidMinimumAlignment, SymbolAlreadyDefined};\n+use crate::errors::{\n+    InvalidMinimumAlignmentNotPowerOfTwo, InvalidMinimumAlignmentTooLarge, SymbolAlreadyDefined,\n+};\n use crate::llvm::{self, True};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n@@ -19,7 +21,9 @@ use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::Lto;\n-use rustc_target::abi::{Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange};\n+use rustc_target::abi::{\n+    Align, AlignFromBytesError, HasDataLayout, Primitive, Scalar, Size, WrappingRange,\n+};\n use std::ops::Range;\n \n pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n@@ -129,9 +133,14 @@ fn set_global_alignment<'ll>(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align:\n     if let Some(min) = cx.sess().target.min_global_align {\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n-            Err(err) => {\n-                cx.sess().emit_err(InvalidMinimumAlignment { err });\n-            }\n+            Err(err) => match err {\n+                AlignFromBytesError::NotPowerOfTwo(align) => {\n+                    cx.sess().emit_err(InvalidMinimumAlignmentNotPowerOfTwo { align });\n+                }\n+                AlignFromBytesError::TooLarge(align) => {\n+                    cx.sess().emit_err(InvalidMinimumAlignmentTooLarge { align });\n+                }\n+            },\n         }\n     }\n     unsafe {"}, {"sha": "ca0f771f5b9e46900a51205cf8f53a522d1a6276", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -969,9 +969,9 @@ impl<'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().emit_fatal(Spanned { span, node: err })\n+            self.sess().emit_fatal(Spanned { span, node: err.into_diagnostic() })\n         } else {\n-            span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n+            span_bug!(span, \"failed to get layout for `{ty}`: {err:?}\")\n         }\n     }\n }\n@@ -991,21 +991,12 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {\n-                    span_bug!(\n-                        span,\n-                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n-                        sig,\n-                        extra_args,\n-                        err\n-                    );\n+                    span_bug!(span, \"`fn_abi_of_fn_ptr({sig}, {extra_args:?})` failed: {err:?}\",);\n                 }\n                 FnAbiRequest::OfInstance { instance, extra_args } => {\n                     span_bug!(\n                         span,\n-                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n-                        instance,\n-                        extra_args,\n-                        err\n+                        \"`fn_abi_of_instance({instance}, {extra_args:?})` failed: {err:?}\",\n                     );\n                 }\n             }"}, {"sha": "44869ced1ae18e08243a248823d854a2a84a9f92", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -50,9 +50,15 @@ pub(crate) struct SymbolAlreadyDefined<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_llvm_invalid_minimum_alignment)]\n-pub(crate) struct InvalidMinimumAlignment {\n-    pub err: String,\n+#[diag(codegen_llvm_invalid_minimum_alignment_not_power_of_two)]\n+pub(crate) struct InvalidMinimumAlignmentNotPowerOfTwo {\n+    pub align: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_invalid_minimum_alignment_too_large)]\n+pub(crate) struct InvalidMinimumAlignmentTooLarge {\n+    pub align: u64,\n }\n \n #[derive(Diagnostic)]"}, {"sha": "e91f7b86e5ed6399b070dbcbb7803901dfe30432", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -93,8 +93,7 @@ fn push_debuginfo_type_name<'tcx>(\n                     Err(e) => {\n                         // Computing the layout can still fail here, e.g. if the target architecture\n                         // cannot represent the type. See https://github.com/rust-lang/rust/issues/94961.\n-                        // FIXME: migrate once `rustc_middle::mir::interpret::InterpError` is translatable.\n-                        tcx.sess.fatal(format!(\"{}\", e));\n+                        tcx.sess.emit_fatal(e.into_diagnostic());\n                     }\n                 }\n             } else {"}, {"sha": "bf660c59cabda8d27cc4a4ff927c852e35b9e1a9", "filename": "compiler/rustc_const_eval/messages.ftl", "status": "modified", "additions": 374, "deletions": 17, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fmessages.ftl?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,34 +1,306 @@\n+const_eval_address_space_full =\n+    there are no more free addresses in the address space\n+const_eval_align_check_failed = accessing memory with alignment {$has}, but alignment {$required} is required\n+const_eval_align_offset_invalid_align =\n+    `align_offset` called with non-power-of-two align: {$target_align}\n+\n+const_eval_alignment_check_failed =\n+    accessing memory with alignment {$has}, but alignment {$required} is required\n+const_eval_already_reported =\n+    an error has already been reported elsewhere (this should not usually be printed)\n+const_eval_assume_false =\n+    `assume` called with `false`\n+\n+const_eval_await_non_const =\n+    cannot convert `{$ty}` into a future in {const_eval_const_context}s\n+const_eval_bounds_check_failed =\n+    indexing out of bounds: the len is {$len} but the index is {$index}\n+const_eval_box_to_mut = {$front_matter}: encountered a box pointing to mutable memory in a constant\n+const_eval_box_to_static = {$front_matter}: encountered a box pointing to a static variable in a constant\n+const_eval_box_to_uninhabited = {$front_matter}: encountered a box pointing to uninhabited type {$ty}\n+const_eval_call_nonzero_intrinsic =\n+    `{$name}` called on 0\n+\n+const_eval_closure_call =\n+    closures need an RFC before allowed to be called in {const_eval_const_context}s\n+const_eval_closure_fndef_not_const =\n+    function defined here, but it is not `const`\n+const_eval_closure_non_const =\n+    cannot call non-const closure in {const_eval_const_context}s\n+const_eval_consider_dereferencing =\n+    consider dereferencing here\n+const_eval_const_accesses_static = constant accesses static\n+\n+const_eval_const_context = {$kind ->\n+    [const] constant\n+    [static] static\n+    [const_fn] constant function\n+    *[other] {\"\"}\n+}\n+\n+const_eval_copy_nonoverlapping_overlapping =\n+    `copy_nonoverlapping` called on overlapping ranges\n+\n+const_eval_dangling_box_no_provenance = {$front_matter}: encountered a dangling box ({$pointer} has no provenance)\n+const_eval_dangling_box_out_of_bounds = {$front_matter}: encountered a dangling box (going beyond the bounds of its allocation)\n+const_eval_dangling_box_use_after_free = {$front_matter}: encountered a dangling box (use-after-free)\n+const_eval_dangling_int_pointer =\n+    {$bad_pointer_message}: {$pointer} is a dangling pointer (it has no provenance)\n+const_eval_dangling_null_pointer =\n+    {$bad_pointer_message}: null pointer is a dangling pointer (it has no provenance)\n+const_eval_dangling_ptr_in_final = encountered dangling pointer in final constant\n+\n+const_eval_dangling_ref_no_provenance = {$front_matter}: encountered a dangling reference ({$pointer} has no provenance)\n+const_eval_dangling_ref_out_of_bounds = {$front_matter}: encountered a dangling reference (going beyond the bounds of its allocation)\n+const_eval_dangling_ref_use_after_free = {$front_matter}: encountered a dangling reference (use-after-free)\n+const_eval_dead_local =\n+    accessing a dead local variable\n+const_eval_dealloc_immutable =\n+    deallocating immutable allocation {$alloc}\n+\n+const_eval_dealloc_incorrect_layout =\n+    incorrect layout on deallocation: {$alloc} has size {$size} and alignment {$align}, but gave size {$size_found} and alignment {$align_found}\n+\n+const_eval_dealloc_kind_mismatch =\n+    deallocating {$alloc}, which is {$alloc_kind} memory, using {$kind} deallocation operation\n+\n+const_eval_deref_coercion_non_const =\n+    cannot perform deref coercion on `{$ty}` in {const_eval_const_context}s\n+    .note = attempting to deref into `{$target_ty}`\n+    .target_note = deref defined here\n+const_eval_deref_function_pointer =\n+    accessing {$allocation} which contains a function\n+const_eval_deref_test = dereferencing pointer failed\n+const_eval_deref_vtable_pointer =\n+    accessing {$allocation} which contains a vtable\n+const_eval_different_allocations =\n+    `{$name}` called on pointers into different allocations\n+\n+const_eval_division_by_zero =\n+    dividing by zero\n+const_eval_division_overflow =\n+    overflow in signed division (dividing MIN by -1)\n+const_eval_double_storage_live =\n+    StorageLive on a local that was already live\n+\n+const_eval_dyn_call_not_a_method =\n+    `dyn` call trying to call something that is not a method\n+\n+const_eval_dyn_call_vtable_mismatch =\n+    `dyn` call on a pointer whose vtable does not match its type\n+\n+const_eval_dyn_star_call_vtable_mismatch =\n+    `dyn*` call on a pointer whose vtable does not match its type\n+\n+const_eval_erroneous_constant =\n+    erroneous constant used\n+\n+const_eval_error = {$error_kind ->\n+    [static] could not evaluate static initializer\n+    [const] evaluation of constant value failed\n+    [const_with_path] evaluation of `{$instance}` failed\n+    *[other] {\"\"}\n+}\n+\n+const_eval_exact_div_has_remainder =\n+    exact_div: {$a} cannot be divided by {$b} without remainder\n+\n+const_eval_expected_non_ptr = {$front_matter}: encountered `{$value}`, but expected plain (non-pointer) bytes\n+const_eval_fn_ptr_call =\n+    function pointers need an RFC before allowed to be called in {const_eval_const_context}s\n+const_eval_for_loop_into_iter_non_const =\n+    cannot convert `{$ty}` into an iterator in {const_eval_const_context}s\n+\n+const_eval_frame_note = {$times ->\n+    [0] {const_eval_frame_note_inner}\n+    *[other] [... {$times} additional calls {const_eval_frame_note_inner} ...]\n+}\n+\n+const_eval_frame_note_inner = inside {$where_ ->\n+    [closure] closure\n+    [instance] `{$instance}`\n+    *[other] {\"\"}\n+}\n+\n+const_eval_in_bounds_test = out-of-bounds pointer use\n+const_eval_incompatible_calling_conventions =\n+    calling a function with calling convention {$callee_conv} using calling convention {$caller_conv}\n+\n+const_eval_incompatible_return_types =\n+    calling a function with return type {$callee_ty} passing return place of type {$caller_ty}\n+\n+const_eval_incompatible_types =\n+    calling a function with argument of type {$callee_ty} passing data of type {$caller_ty}\n+\n const_eval_interior_mutability_borrow =\n     cannot borrow here, since the borrowed element may contain interior mutability\n \n const_eval_interior_mutable_data_refer =\n-    {$kind}s cannot refer to interior mutable data\n+    {const_eval_const_context}s cannot refer to interior mutable data\n     .label = this borrow of an interior mutable value may end up in the final value\n     .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n     .teach_note =\n         A constant containing interior mutable data behind a reference can allow you to modify that data.\n         This would make multiple uses of a constant to be able to see different values and allow circumventing\n         the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n \n+const_eval_invalid_align =\n+    align has to be a power of 2\n+\n+const_eval_invalid_align_details =\n+    invalid align passed to `{$name}`: {$align} is {$err_kind ->\n+        [not_power_of_two] not a power of 2\n+        [too_large] too large\n+        *[other] {\"\"}\n+    }\n+\n+const_eval_invalid_bool =\n+    interpreting an invalid 8-bit value as a bool: 0x{$value}\n+const_eval_invalid_box_meta = {$front_matter}: encountered invalid box metadata: total size is bigger than largest supported object\n+const_eval_invalid_box_slice_meta = {$front_matter}: encountered invalid box metadata: slice is bigger than largest supported object\n+const_eval_invalid_char =\n+    interpreting an invalid 32-bit value as a char: 0x{$value}\n+const_eval_invalid_dealloc =\n+    deallocating {$alloc_id}, which is {$kind ->\n+        [fn] a function\n+        [vtable] a vtable\n+        [static_mem] static memory\n+        *[other] {\"\"}\n+    }\n+\n+const_eval_invalid_enum_tag = {$front_matter}: encountered {$value}, but expected a valid enum tag\n+const_eval_invalid_fn_ptr = {$front_matter}: encountered {$value}, but expected a function pointer\n+const_eval_invalid_function_pointer =\n+    using {$pointer} as function pointer but it does not point to a function\n+const_eval_invalid_meta =\n+    invalid metadata in wide pointer: total size is bigger than largest supported object\n+const_eval_invalid_meta_slice =\n+    invalid metadata in wide pointer: slice is bigger than largest supported object\n+const_eval_invalid_ref_meta = {$front_matter}: encountered invalid reference metadata: total size is bigger than largest supported object\n+const_eval_invalid_ref_slice_meta = {$front_matter}: encountered invalid reference metadata: slice is bigger than largest supported object\n+const_eval_invalid_str =\n+    this string is not valid UTF-8: {$err}\n+const_eval_invalid_tag =\n+    enum value has invalid tag: {$tag}\n+const_eval_invalid_transmute =\n+    transmuting from {$src_bytes}-byte type to {$dest_bytes}-byte type: `{$src}` -> `{$dest}`\n+\n+const_eval_invalid_uninit_bytes =\n+    reading memory at {$alloc}{$access}, but memory is uninitialized at {$uninit}, and this operation requires initialized memory\n+const_eval_invalid_uninit_bytes_unknown =\n+    using uninitialized data, but this operation requires initialized memory\n+const_eval_invalid_value = constructing invalid value\n+const_eval_invalid_value_with_path = constructing invalid value at {$path}\n+## The `front_matter`s here refer to either `middle_invalid_value` or `middle_invalid_value_with_path`.\n+\n+const_eval_invalid_vtable_pointer =\n+    using {$pointer} as vtable pointer but it does not point to a vtable\n+\n+const_eval_invalid_vtable_ptr = {$front_matter}: encountered {$value}, but expected a vtable pointer\n+\n+const_eval_live_drop =\n+    destructor of `{$dropped_ty}` cannot be evaluated at compile-time\n+    .label = the destructor for this type cannot be evaluated in {const_eval_const_context}s\n+    .dropped_at_label = value is dropped here\n+\n const_eval_long_running =\n     constant evaluation is taking a long time\n     .note = this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n         If your compilation actually takes a long time, you can safely allow the lint.\n     .label = the const evaluator is currently interpreting this expression\n     .help = the constant being evaluated\n+\n const_eval_max_num_nodes_in_const = maximum number of nodes exceeded in constant {$global_const_id}\n \n+const_eval_memory_access_test = memory access failed\n+const_eval_memory_exhausted =\n+    tried to allocate more memory than available to compiler\n+const_eval_modified_global =\n+    modifying a static's initial value from another static's initializer\n+\n const_eval_mut_deref =\n-    mutation through a reference is not allowed in {$kind}s\n+    mutation through a reference is not allowed in {const_eval_const_context}s\n \n+const_eval_mutable_ref_in_const = {$front_matter}: encountered mutable reference in a `const`\n+const_eval_never_val = {$front_matter}: encountered a value of the never type `!`\n const_eval_non_const_fmt_macro_call =\n-    cannot call non-const formatting macro in {$kind}s\n+    cannot call non-const formatting macro in {const_eval_const_context}s\n \n const_eval_non_const_fn_call =\n-    cannot call non-const fn `{$def_path_str}` in {$kind}s\n+    cannot call non-const fn `{$def_path_str}` in {const_eval_const_context}s\n+\n+const_eval_non_const_impl =\n+    impl defined here, but it is not `const`\n+\n+const_eval_noreturn_asm_returned =\n+    returned from noreturn inline assembly\n+\n+const_eval_not_enough_caller_args =\n+    calling a function with fewer arguments than it requires\n+\n+const_eval_null_box = {$front_matter}: encountered a null box\n+const_eval_null_fn_ptr = {$front_matter}: encountered a null function pointer\n+const_eval_null_ref = {$front_matter}: encountered a null reference\n+const_eval_nullable_ptr_out_of_range = {$front_matter}: encountered a potentially null pointer, but expected something that cannot possibly fail to be {$in_range}\n+const_eval_nullary_intrinsic_fail =\n+    could not evaluate nullary intrinsic\n+\n+const_eval_offset_from_overflow =\n+    `{$name}` called when first pointer is too far ahead of second\n+\n+const_eval_offset_from_test = out-of-bounds `offset_from`\n+const_eval_offset_from_underflow =\n+    `{$name}` called when first pointer is too far before second\n+\n+const_eval_operator_non_const =\n+    cannot call non-const operator in {const_eval_const_context}s\n+const_eval_out_of_range = {$front_matter}: encountered {$value}, but expected something {$in_range}\n+const_eval_overflow =\n+    overflow executing `{$name}`\n+\n+const_eval_overflow_shift =\n+    overflowing shift by {$val} in `{$name}`\n+\n+const_eval_panic =\n+    the evaluated program panicked at '{$msg}', {$file}:{$line}:{$col}\n \n const_eval_panic_non_str = argument to `panic!()` in a const context must have type `&str`\n \n+const_eval_partial_pointer_copy =\n+    unable to copy parts of a pointer from memory at {$ptr}\n+const_eval_partial_pointer_overwrite =\n+    unable to overwrite parts of a pointer in memory at {$ptr}\n+const_eval_pointer_arithmetic_overflow =\n+    overflowing in-bounds pointer arithmetic\n+const_eval_pointer_arithmetic_test = out-of-bounds pointer arithmetic\n+const_eval_pointer_out_of_bounds =\n+    {$bad_pointer_message}: {$alloc_id} has size {$alloc_size}, so pointer to {$ptr_size} {$ptr_size ->\n+        [1] byte\n+        *[many] bytes\n+    } starting at offset {$ptr_offset} is out-of-bounds\n+const_eval_pointer_use_after_free =\n+    pointer to {$allocation} was dereferenced after this allocation got freed\n+const_eval_ptr_as_bytes_1 =\n+    this code performed an operation that depends on the underlying bytes representing a pointer\n+const_eval_ptr_as_bytes_2 =\n+    the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+const_eval_ptr_out_of_range = {$front_matter}: encountered a pointer, but expected something that cannot possibly fail to be {$in_range}\n+const_eval_question_branch_non_const =\n+    `?` cannot determine the branch of `{$ty}` in {const_eval_const_context}s\n+\n+const_eval_question_from_residual_non_const =\n+    `?` cannot convert from residual of `{$ty}` in {const_eval_const_context}s\n+\n+const_eval_range = in the range {$lo}..={$hi}\n+const_eval_range_lower = greater or equal to {$lo}\n+const_eval_range_singular = equal to {$lo}\n+const_eval_range_upper = less or equal to {$hi}\n+const_eval_range_wrapping = less or equal to {$hi}, or greater or equal to {$lo}\n+const_eval_raw_bytes = the raw bytes of the constant (size: {$size}, align: {$align}) {\"{\"}{$bytes}{\"}\"}\n+\n+const_eval_raw_eq_with_provenance =\n+    `raw_eq` on bytes with provenance\n+\n const_eval_raw_ptr_comparison =\n     pointers cannot be reliably compared during const eval\n     .note = see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n@@ -38,44 +310,79 @@ const_eval_raw_ptr_to_int =\n     .note = at compile-time, pointers do not have an integer value\n     .note2 = avoiding this restriction via `transmute`, `union`, or raw pointers leads to compile-time undefined behavior\n \n+const_eval_read_extern_static =\n+    cannot read from extern static ({$did})\n+const_eval_read_pointer_as_bytes =\n+    unable to turn pointer into raw bytes\n+const_eval_realloc_or_alloc_with_offset =\n+    {$kind ->\n+        [dealloc] deallocating\n+        [realloc] reallocating\n+        *[other] {\"\"}\n+    } {$ptr} which does not point to the beginning of an object\n+\n+const_eval_ref_to_mut = {$front_matter}: encountered a reference pointing to mutable memory in a constant\n+const_eval_ref_to_static = {$front_matter}: encountered a reference pointing to a static variable in a constant\n+const_eval_ref_to_uninhabited = {$front_matter}: encountered a reference pointing to uninhabited type {$ty}\n+const_eval_remainder_by_zero =\n+    calculating the remainder with a divisor of zero\n+const_eval_remainder_overflow =\n+    overflow in signed remainder (dividing MIN by -1)\n+const_eval_scalar_size_mismatch =\n+    scalar size mismatch: expected {$target_size} bytes but got {$data_size} bytes instead\n+const_eval_size_of_unsized =\n+    size_of called on unsized type `{$ty}`\n+const_eval_size_overflow =\n+    overflow computing total size of `{$name}`\n+\n+const_eval_stack_frame_limit_reached =\n+    reached the configured maximum number of stack frames\n+\n const_eval_static_access =\n-    {$kind}s cannot refer to statics\n+    {const_eval_const_context}s cannot refer to statics\n     .help = consider extracting the value of the `static` to a `const`, and referring to that\n     .teach_note = `static` and `const` variables can refer to other `const` variables. A `const` variable, however, cannot refer to a `static` variable.\n     .teach_help = To fix this, the value can be extracted to a `const` and then used.\n \n const_eval_thread_local_access =\n     thread-local statics cannot be accessed at compile-time\n \n-const_eval_transient_mut_borrow = mutable references are not allowed in {$kind}s\n+const_eval_thread_local_static =\n+    cannot access thread local static ({$did})\n+const_eval_too_generic =\n+    encountered overly generic constant\n+const_eval_too_many_caller_args =\n+    calling a function with more arguments than it expected\n \n-const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {$kind}s\n+const_eval_transient_mut_borrow = mutable references are not allowed in {const_eval_const_context}s\n \n-const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {$kind}s\n+const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {const_eval_const_context}s\n+\n+const_eval_try_block_from_output_non_const =\n+    `try` block cannot convert `{$ty}` to the result in {const_eval_const_context}s\n+const_eval_unaligned_box = {$front_matter}: encountered an unaligned box (required {$required_bytes} byte alignment but found {$found_bytes})\n+const_eval_unaligned_ref = {$front_matter}: encountered an unaligned reference (required {$required_bytes} byte alignment but found {$found_bytes})\n+const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {const_eval_const_context}s\n \n const_eval_unallowed_heap_allocations =\n-    allocations are not allowed in {$kind}s\n-    .label = allocation not allowed in {$kind}s\n+    allocations are not allowed in {const_eval_const_context}s\n+    .label = allocation not allowed in {const_eval_const_context}s\n     .teach_note =\n         The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.\n \n const_eval_unallowed_inline_asm =\n-    inline assembly is not allowed in {$kind}s\n-\n+    inline assembly is not allowed in {const_eval_const_context}s\n const_eval_unallowed_mutable_refs =\n-    mutable references are not allowed in the final value of {$kind}s\n+    mutable references are not allowed in the final value of {const_eval_const_context}s\n     .teach_note =\n-        References in statics and constants may only refer to immutable values.\n-\n-\n         Statics are shared everywhere, and if they refer to mutable data one might violate memory\n         safety since holding multiple mutable references to shared data is not allowed.\n \n \n         If you really want global mutable state, try using static mut or a global UnsafeCell.\n \n const_eval_unallowed_mutable_refs_raw =\n-    raw mutable references are not allowed in the final value of {$kind}s\n+    raw mutable references are not allowed in the final value of {const_eval_const_context}s\n     .teach_note =\n         References in statics and constants may only refer to immutable values.\n \n@@ -89,9 +396,59 @@ const_eval_unallowed_mutable_refs_raw =\n const_eval_unallowed_op_in_const_context =\n     {$msg}\n \n+const_eval_undefined_behavior =\n+    it is undefined behavior to use this value\n+\n+const_eval_undefined_behavior_note =\n+    The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+const_eval_uninhabited_enum_variant_written =\n+    writing discriminant of an uninhabited enum\n+const_eval_uninhabited_val = {$front_matter}: encountered a value of uninhabited type `{$ty}`\n+const_eval_uninit = {$front_matter}: encountered uninitialized bytes\n+const_eval_uninit_bool = {$front_matter}: encountered uninitialized memory, but expected a boolean\n+const_eval_uninit_box = {$front_matter}: encountered uninitialized memory, but expected a box\n+const_eval_uninit_char = {$front_matter}: encountered uninitialized memory, but expected a unicode scalar value\n+const_eval_uninit_enum_tag = {$front_matter}: encountered uninitialized bytes, but expected a valid enum tag\n+const_eval_uninit_float = {$front_matter}: encountered uninitialized memory, but expected a floating point number\n+const_eval_uninit_fn_ptr = {$front_matter}: encountered uninitialized memory, but expected a function pointer\n+const_eval_uninit_init_scalar = {$front_matter}: encountered uninitialized memory, but expected initialized scalar value\n+const_eval_uninit_int = {$front_matter}: encountered uninitialized memory, but expected an integer\n+const_eval_uninit_raw_ptr = {$front_matter}: encountered uninitialized memory, but expected a raw pointer\n+const_eval_uninit_ref = {$front_matter}: encountered uninitialized memory, but expected a reference\n+const_eval_uninit_str = {$front_matter}: encountered uninitialized data in `str`\n+const_eval_uninit_unsized_local =\n+    unsized local is used while uninitialized\n+const_eval_unreachable = entering unreachable code\n+const_eval_unreachable_unwind =\n+    unwinding past a stack frame that does not allow unwinding\n+\n+const_eval_unsafe_cell = {$front_matter}: encountered `UnsafeCell` in a `const`\n+const_eval_unsigned_offset_from_overflow =\n+    `ptr_offset_from_unsigned` called when first pointer has smaller offset than second: {$a_offset} < {$b_offset}\n+\n const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n \n const_eval_unstable_in_stable =\n     const-stable function cannot use `#[feature({$gate})]`\n     .unstable_sugg = if it is not part of the public API, make this function unstably const\n     .bypass_sugg = otherwise `#[rustc_allow_const_fn_unstable]` can be used to bypass stability checks\n+\n+const_eval_unsupported_untyped_pointer = unsupported untyped pointer in constant\n+    .note = memory only reachable via raw pointers is not supported\n+\n+const_eval_unterminated_c_string =\n+    reading a null-terminated string starting at {$pointer} with no null found before end of allocation\n+\n+const_eval_unwind_past_top =\n+    unwinding past the topmost frame of the stack\n+\n+const_eval_upcast_mismatch =\n+    upcast on a pointer whose vtable does not match its type\n+\n+const_eval_validation_invalid_bool = {$front_matter}: encountered {$value}, but expected a boolean\n+const_eval_validation_invalid_char = {$front_matter}: encountered {$value}, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n+const_eval_write_to_read_only =\n+    writing to {$allocation} which is read-only\n+const_eval_zst_pointer_out_of_bounds =\n+    {$bad_pointer_message}: {$alloc_id} has size {$alloc_size}, so pointer at offset {$ptr_offset} is out-of-bounds"}, {"sha": "7890d878d08fe42743af43cd97e8c3b9fa3064cb", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 136, "deletions": 144, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,17 +1,15 @@\n-use std::error::Error;\n-use std::fmt;\n+use std::mem;\n \n-use rustc_errors::Diagnostic;\n+use rustc_errors::{DiagnosticArgValue, DiagnosticMessage, IntoDiagnostic, IntoDiagnosticArg};\n use rustc_middle::mir::AssertKind;\n-use rustc_middle::query::TyCtxtAt;\n+use rustc_middle::ty::TyCtxt;\n use rustc_middle::ty::{layout::LayoutError, ConstInt};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::{ErrorGuaranteed, Span, Symbol};\n \n use super::InterpCx;\n-use crate::interpret::{\n-    struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine, MachineStopType,\n-    UnsupportedOpInfo,\n-};\n+use crate::errors::{self, FrameNote, ReportErrorExt};\n+use crate::interpret::{ErrorHandled, InterpError, InterpErrorInfo, Machine, MachineStopType};\n \n /// The CTFE machine has some custom error kinds.\n #[derive(Clone, Debug)]\n@@ -23,7 +21,35 @@ pub enum ConstEvalErrKind {\n     Abort(String),\n }\n \n-impl MachineStopType for ConstEvalErrKind {}\n+impl MachineStopType for ConstEvalErrKind {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        use ConstEvalErrKind::*;\n+        match self {\n+            ConstAccessesStatic => const_eval_const_accesses_static,\n+            ModifiedGlobal => const_eval_modified_global,\n+            Panic { .. } => const_eval_panic,\n+            AssertFailure(x) => x.diagnostic_message(),\n+            Abort(msg) => msg.to_string().into(),\n+        }\n+    }\n+    fn add_args(\n+        self: Box<Self>,\n+        adder: &mut dyn FnMut(std::borrow::Cow<'static, str>, DiagnosticArgValue<'static>),\n+    ) {\n+        use ConstEvalErrKind::*;\n+        match *self {\n+            ConstAccessesStatic | ModifiedGlobal | Abort(_) => {}\n+            AssertFailure(kind) => kind.add_args(adder),\n+            Panic { msg, line, col, file } => {\n+                adder(\"msg\".into(), msg.into_diagnostic_arg());\n+                adder(\"file\".into(), file.into_diagnostic_arg());\n+                adder(\"line\".into(), line.into_diagnostic_arg());\n+                adder(\"col\".into(), col.into_diagnostic_arg());\n+            }\n+        }\n+    }\n+}\n \n // The errors become `MachineStop` with plain strings when being raised.\n // `ConstEvalErr` (in `librustc_middle/mir/interpret/error.rs`) knows to\n@@ -34,151 +60,117 @@ impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalErrKind {\n     }\n }\n \n-impl fmt::Display for ConstEvalErrKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use self::ConstEvalErrKind::*;\n-        match self {\n-            ConstAccessesStatic => write!(f, \"constant accesses static\"),\n-            ModifiedGlobal => {\n-                write!(f, \"modifying a static's initial value from another static's initializer\")\n-            }\n-            AssertFailure(msg) => write!(f, \"{:?}\", msg),\n-            Panic { msg, line, col, file } => {\n-                write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)\n-            }\n-            Abort(msg) => write!(f, \"{}\", msg),\n-        }\n-    }\n-}\n-\n-impl Error for ConstEvalErrKind {}\n+pub fn get_span_and_frames<'tcx, 'mir, M: Machine<'mir, 'tcx>>(\n+    ecx: &InterpCx<'mir, 'tcx, M>,\n+) -> (Span, Vec<errors::FrameNote>)\n+where\n+    'tcx: 'mir,\n+{\n+    let mut stacktrace = ecx.generate_stacktrace();\n+    // Filter out `requires_caller_location` frames.\n+    stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(*ecx.tcx));\n+    let span = stacktrace.first().map(|f| f.span).unwrap_or(ecx.tcx.span);\n \n-/// When const-evaluation errors, this type is constructed with the resulting information,\n-/// and then used to emit the error as a lint or hard error.\n-#[derive(Debug)]\n-pub(super) struct ConstEvalErr<'tcx> {\n-    pub span: Span,\n-    pub error: InterpError<'tcx>,\n-    pub stacktrace: Vec<FrameInfo<'tcx>>,\n-}\n+    let mut frames = Vec::new();\n \n-impl<'tcx> ConstEvalErr<'tcx> {\n-    /// Turn an interpreter error into something to report to the user.\n-    /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n-    /// Should be called only if the error is actually going to be reported!\n-    pub fn new<'mir, M: Machine<'mir, 'tcx>>(\n-        ecx: &InterpCx<'mir, 'tcx, M>,\n-        error: InterpErrorInfo<'tcx>,\n-        span: Option<Span>,\n-    ) -> ConstEvalErr<'tcx>\n-    where\n-        'tcx: 'mir,\n-    {\n-        error.print_backtrace();\n-        let mut stacktrace = ecx.generate_stacktrace();\n-        // Filter out `requires_caller_location` frames.\n-        stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(*ecx.tcx));\n-        // If `span` is missing, use topmost remaining frame, or else the \"root\" span from `ecx.tcx`.\n-        let span = span.or_else(|| stacktrace.first().map(|f| f.span)).unwrap_or(ecx.tcx.span);\n-        ConstEvalErr { error: error.into_kind(), stacktrace, span }\n-    }\n-\n-    pub(super) fn report(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n-        self.report_decorated(tcx, message, |_| {})\n-    }\n-\n-    #[instrument(level = \"trace\", skip(self, decorate))]\n-    pub(super) fn decorate(&self, err: &mut Diagnostic, decorate: impl FnOnce(&mut Diagnostic)) {\n-        trace!(\"reporting const eval failure at {:?}\", self.span);\n-        // Add some more context for select error types.\n-        match self.error {\n-            InterpError::Unsupported(\n-                UnsupportedOpInfo::ReadPointerAsBytes\n-                | UnsupportedOpInfo::PartialPointerOverwrite(_)\n-                | UnsupportedOpInfo::PartialPointerCopy(_),\n-            ) => {\n-                err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n-                err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n+    // Add notes to the backtrace. Don't print a single-line backtrace though.\n+    if stacktrace.len() > 1 {\n+        // Helper closure to print duplicated lines.\n+        let mut add_frame = |mut frame: errors::FrameNote| {\n+            frames.push(errors::FrameNote { times: 0, ..frame.clone() });\n+            // Don't print [... additional calls ...] if the number of lines is small\n+            if frame.times < 3 {\n+                let times = frame.times;\n+                frame.times = 0;\n+                frames.extend(std::iter::repeat(frame).take(times as usize));\n+            } else {\n+                frames.push(frame);\n             }\n-            _ => {}\n-        }\n-        // Add spans for the stacktrace. Don't print a single-line backtrace though.\n-        if self.stacktrace.len() > 1 {\n-            // Helper closure to print duplicated lines.\n-            let mut flush_last_line = |last_frame: Option<(String, _)>, times| {\n-                if let Some((line, span)) = last_frame {\n-                    err.span_note(span, line.clone());\n-                    // Don't print [... additional calls ...] if the number of lines is small\n-                    if times < 3 {\n-                        for _ in 0..times {\n-                            err.span_note(span, line.clone());\n-                        }\n-                    } else {\n-                        err.span_note(\n-                            span,\n-                            format!(\"[... {} additional calls {} ...]\", times, &line),\n-                        );\n-                    }\n-                }\n-            };\n+        };\n \n-            let mut last_frame = None;\n-            let mut times = 0;\n-            for frame_info in &self.stacktrace {\n-                let frame = (frame_info.to_string(), frame_info.span);\n-                if last_frame.as_ref() == Some(&frame) {\n-                    times += 1;\n-                } else {\n-                    flush_last_line(last_frame, times);\n+        let mut last_frame: Option<errors::FrameNote> = None;\n+        for frame_info in &stacktrace {\n+            let frame = frame_info.as_note(*ecx.tcx);\n+            match last_frame.as_mut() {\n+                Some(last_frame)\n+                    if last_frame.span == frame.span\n+                        && last_frame.where_ == frame.where_\n+                        && last_frame.instance == frame.instance =>\n+                {\n+                    last_frame.times += 1;\n+                }\n+                Some(last_frame) => {\n+                    add_frame(mem::replace(last_frame, frame));\n+                }\n+                None => {\n                     last_frame = Some(frame);\n-                    times = 0;\n                 }\n             }\n-            flush_last_line(last_frame, times);\n         }\n-        // Let the caller attach any additional information it wants.\n-        decorate(err);\n+        if let Some(frame) = last_frame {\n+            add_frame(frame);\n+        }\n     }\n \n-    /// Create a diagnostic for this const eval error.\n-    ///\n-    /// Sets the message passed in via `message` and adds span labels with detailed error\n-    /// information before handing control back to `decorate` to do any final annotations,\n-    /// after which the diagnostic is emitted.\n-    ///\n-    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n-    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n-    #[instrument(skip(self, tcx, decorate), level = \"debug\")]\n-    pub(super) fn report_decorated(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        decorate: impl FnOnce(&mut Diagnostic),\n-    ) -> ErrorHandled {\n-        debug!(\"self.error: {:?}\", self.error);\n-        // Special handling for certain errors\n-        match &self.error {\n-            // Don't emit a new diagnostic for these errors\n-            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n-                ErrorHandled::TooGeneric\n-            }\n-            err_inval!(AlreadyReported(error_reported)) => ErrorHandled::Reported(*error_reported),\n-            err_inval!(Layout(LayoutError::SizeOverflow(_))) => {\n-                // We must *always* hard error on these, even if the caller wants just a lint.\n-                // The `message` makes little sense here, this is a more serious error than the\n-                // caller thinks anyway.\n-                // See <https://github.com/rust-lang/rust/pull/63152>.\n-                let mut err = struct_error(tcx, &self.error.to_string());\n-                self.decorate(&mut err, decorate);\n-                ErrorHandled::Reported(err.emit().into())\n-            }\n-            _ => {\n-                // Report as hard error.\n-                let mut err = struct_error(tcx, message);\n-                err.span_label(self.span, self.error.to_string());\n-                self.decorate(&mut err, decorate);\n-                ErrorHandled::Reported(err.emit().into())\n+    (span, frames)\n+}\n+\n+/// Create a diagnostic for a const eval error.\n+///\n+/// This will use the `mk` function for creating the error which will get passed labels according to\n+/// the `InterpError` and the span and a stacktrace of current execution according to\n+/// `get_span_and_frames`.\n+pub(super) fn report<'tcx, C, F, E>(\n+    tcx: TyCtxt<'tcx>,\n+    error: InterpError<'tcx>,\n+    span: Option<Span>,\n+    get_span_and_frames: C,\n+    mk: F,\n+) -> ErrorHandled\n+where\n+    C: FnOnce() -> (Span, Vec<FrameNote>),\n+    F: FnOnce(Span, Vec<FrameNote>) -> E,\n+    E: IntoDiagnostic<'tcx, ErrorGuaranteed>,\n+{\n+    // Special handling for certain errors\n+    match error {\n+        // Don't emit a new diagnostic for these errors\n+        err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n+            ErrorHandled::TooGeneric\n+        }\n+        err_inval!(AlreadyReported(error_reported)) => ErrorHandled::Reported(error_reported),\n+        err_inval!(Layout(layout_error @ LayoutError::SizeOverflow(_))) => {\n+            // We must *always* hard error on these, even if the caller wants just a lint.\n+            // The `message` makes little sense here, this is a more serious error than the\n+            // caller thinks anyway.\n+            // See <https://github.com/rust-lang/rust/pull/63152>.\n+            let (our_span, frames) = get_span_and_frames();\n+            let span = span.unwrap_or(our_span);\n+            let mut err =\n+                tcx.sess.create_err(Spanned { span, node: layout_error.into_diagnostic() });\n+            err.code(rustc_errors::error_code!(E0080));\n+            let Some((mut err, handler)) = err.into_diagnostic() else {\n+                    panic!(\"did not emit diag\");\n+                };\n+            for frame in frames {\n+                err.eager_subdiagnostic(handler, frame);\n             }\n+\n+            ErrorHandled::Reported(handler.emit_diagnostic(&mut err).unwrap().into())\n+        }\n+        _ => {\n+            // Report as hard error.\n+            let (our_span, frames) = get_span_and_frames();\n+            let span = span.unwrap_or(our_span);\n+            let err = mk(span, frames);\n+            let mut err = tcx.sess.create_err(err);\n+\n+            let msg = error.diagnostic_message();\n+            error.add_args(&tcx.sess.parse_sess.span_diagnostic, &mut err);\n+\n+            // Use *our* span to label the interp error\n+            err.span_label(our_span, msg);\n+            ErrorHandled::Reported(err.emit().into())\n         }\n     }\n }"}, {"sha": "8b8e8ff58e9072015a220d5c38c7f9af6585c39c", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 63, "deletions": 34, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,31 +1,28 @@\n use crate::const_eval::CheckAlignment;\n-use std::borrow::Cow;\n+use crate::errors::ConstEvalError;\n \n use either::{Left, Right};\n \n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::mir::pretty::display_allocation;\n+use rustc_middle::mir::interpret::{ErrorHandled, InterpErrorInfo};\n+use rustc_middle::mir::pretty::write_allocation_bytes;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::source_map::Span;\n use rustc_target::abi::{self, Abi};\n \n-use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter};\n+use crate::errors;\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n     Immediate, InternKind, InterpCx, InterpError, InterpResult, MPlaceTy, MemoryKind, OpTy,\n     RefTracking, StackPopCleanup,\n };\n \n-const NOTE_ON_UNDEFINED_BEHAVIOR_ERROR: &str = \"The rules on what exactly is undefined behavior aren't clear, \\\n-     so this check might be overzealous. Please open an issue on the rustc \\\n-     repository if you believe it should not be considered undefined behavior.\";\n-\n // Returns a pointer to where the result lives\n fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n@@ -253,8 +250,14 @@ pub fn eval_to_const_value_raw_provider<'tcx>(\n         };\n         return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs).map_err(|error| {\n             let span = tcx.def_span(def_id);\n-            let error = ConstEvalErr { error: error.into_kind(), stacktrace: vec![], span };\n-            error.report(tcx.at(span), \"could not evaluate nullary intrinsic\")\n+\n+            super::report(\n+                tcx,\n+                error.into_kind(),\n+                Some(span),\n+                || (span, vec![]),\n+                |span, _| errors::NullaryIntrinsicError { span },\n+            )\n         });\n     }\n \n@@ -318,29 +321,41 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     match res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body)) {\n         Err(error) => {\n-            let err = ConstEvalErr::new(&ecx, error, None);\n-            let msg = if is_static {\n-                Cow::from(\"could not evaluate static initializer\")\n+            let (error, backtrace) = error.into_parts();\n+            backtrace.print_backtrace();\n+\n+            let (kind, instance) = if is_static {\n+                (\"static\", String::new())\n             } else {\n                 // If the current item has generics, we'd like to enrich the message with the\n                 // instance and its substs: to show the actual compile-time values, in addition to\n                 // the expression, leading to the const eval error.\n                 let instance = &key.value.instance;\n                 if !instance.substs.is_empty() {\n                     let instance = with_no_trimmed_paths!(instance.to_string());\n-                    let msg = format!(\"evaluation of `{}` failed\", instance);\n-                    Cow::from(msg)\n+                    (\"const_with_path\", instance)\n                 } else {\n-                    Cow::from(\"evaluation of constant value failed\")\n+                    (\"const\", String::new())\n                 }\n             };\n \n-            Err(err.report(ecx.tcx.at(err.span), &msg))\n+            Err(super::report(\n+                *ecx.tcx,\n+                error,\n+                None,\n+                || super::get_span_and_frames(&ecx),\n+                |span, frames| ConstEvalError {\n+                    span,\n+                    error_kind: kind,\n+                    instance,\n+                    frame_notes: frames,\n+                },\n+            ))\n         }\n         Ok(mplace) => {\n             // Since evaluation had no errors, validate the resulting constant.\n             // This is a separate `try` block to provide more targeted error reporting.\n-            let validation = try {\n+            let validation: Result<_, InterpErrorInfo<'_>> = try {\n                 let mut ref_tracking = RefTracking::new(mplace);\n                 let mut inner = false;\n                 while let Some((mplace, path)) = ref_tracking.todo.pop() {\n@@ -357,23 +372,37 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                 }\n             };\n             let alloc_id = mplace.ptr.provenance.unwrap();\n+\n+            // Validation failed, report an error. This is always a hard error.\n             if let Err(error) = validation {\n-                // Validation failed, report an error. This is always a hard error.\n-                let err = ConstEvalErr::new(&ecx, error, None);\n-                Err(err.report_decorated(\n-                    ecx.tcx,\n-                    \"it is undefined behavior to use this value\",\n-                    |diag| {\n-                        if matches!(err.error, InterpError::UndefinedBehavior(_)) {\n-                            diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n-                        }\n-                        diag.note(format!(\n-                            \"the raw bytes of the constant ({}\",\n-                            display_allocation(\n-                                *ecx.tcx,\n-                                ecx.tcx.global_alloc(alloc_id).unwrap_memory().inner()\n-                            )\n-                        ));\n+                let (error, backtrace) = error.into_parts();\n+                backtrace.print_backtrace();\n+\n+                let ub_note = matches!(error, InterpError::UndefinedBehavior(_)).then(|| {});\n+\n+                let alloc = ecx.tcx.global_alloc(alloc_id).unwrap_memory().inner();\n+                let mut bytes = String::new();\n+                if alloc.size() != abi::Size::ZERO {\n+                    bytes = \"\\n\".into();\n+                    // FIXME(translation) there might be pieces that are translatable.\n+                    write_allocation_bytes(*ecx.tcx, alloc, &mut bytes, \"    \").unwrap();\n+                }\n+                let raw_bytes = errors::RawBytesNote {\n+                    size: alloc.size().bytes(),\n+                    align: alloc.align.bytes(),\n+                    bytes,\n+                };\n+\n+                Err(super::report(\n+                    *ecx.tcx,\n+                    error,\n+                    None,\n+                    || super::get_span_and_frames(&ecx),\n+                    move |span, frames| errors::UndefinedBehavior {\n+                        span,\n+                        ub_note,\n+                        frames,\n+                        raw_bytes,\n                     },\n                 ))\n             } else {"}, {"sha": "7391f5670400aac056402fe59542f524b3681a99", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -25,6 +25,7 @@ use crate::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, FnVal, Frame, ImmTy, InterpCx,\n     InterpResult, OpTy, PlaceTy, Pointer, Scalar,\n };\n+use crate::{errors, fluent_generated as fluent};\n \n use super::error::*;\n \n@@ -254,7 +255,10 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n         let target_align = self.read_scalar(&args[1])?.to_target_usize(self)?;\n \n         if !target_align.is_power_of_two() {\n-            throw_ub_format!(\"`align_offset` called with non-power-of-two align: {}\", target_align);\n+            throw_ub_custom!(\n+                fluent::const_eval_align_offset_invalid_align,\n+                target_align = target_align,\n+            );\n         }\n \n         match self.ptr_try_get_alloc_id(ptr) {\n@@ -360,15 +364,18 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 \"`alignment_check_failed` called when no alignment check requested\"\n             ),\n             CheckAlignment::FutureIncompat => {\n-                let err = ConstEvalErr::new(ecx, err, None);\n-                ecx.tcx.struct_span_lint_hir(\n+                let (_, backtrace) = err.into_parts();\n+                backtrace.print_backtrace();\n+                let (span, frames) = super::get_span_and_frames(&ecx);\n+\n+                ecx.tcx.emit_spanned_lint(\n                     INVALID_ALIGNMENT,\n                     ecx.stack().iter().find_map(|frame| frame.lint_root()).unwrap_or(CRATE_HIR_ID),\n-                    err.span,\n-                    err.error.to_string(),\n-                    |db| {\n-                        err.decorate(db, |_| {});\n-                        db\n+                    span,\n+                    errors::AlignmentCheckFailed {\n+                        has: has.bytes(),\n+                        required: required.bytes(),\n+                        frames,\n                     },\n                 );\n                 Ok(())\n@@ -482,7 +489,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n                 let align = match Align::from_bytes(align) {\n                     Ok(a) => a,\n-                    Err(err) => throw_ub_format!(\"align has to be a power of 2, {}\", err),\n+                    Err(err) => throw_ub_custom!(\n+                        fluent::const_eval_invalid_align_details,\n+                        name = \"const_allocate\",\n+                        err_kind = err.diag_ident(),\n+                        align = err.align()\n+                    ),\n                 };\n \n                 let ptr = ecx.allocate_ptr(\n@@ -500,7 +512,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 let size = Size::from_bytes(size);\n                 let align = match Align::from_bytes(align) {\n                     Ok(a) => a,\n-                    Err(err) => throw_ub_format!(\"align has to be a power of 2, {}\", err),\n+                    Err(err) => throw_ub_custom!(\n+                        fluent::const_eval_invalid_align_details,\n+                        name = \"const_deallocate\",\n+                        err_kind = err.diag_ident(),\n+                        align = err.align()\n+                    ),\n                 };\n \n                 // If an allocation is created in an another const,"}, {"sha": "6e462d3a1e983418ed9a963689e6ff4693d5c98b", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -73,17 +73,8 @@ pub(crate) fn eval_to_valtree<'tcx>(\n             let global_const_id = cid.display(tcx);\n             match err {\n                 ValTreeCreationError::NodesOverflow => {\n-                    let msg = format!(\n-                        \"maximum number of nodes exceeded in constant {}\",\n-                        &global_const_id\n-                    );\n-                    let mut diag = match tcx.hir().span_if_local(did) {\n-                        Some(span) => {\n-                            tcx.sess.create_err(MaxNumNodesInConstErr { span, global_const_id })\n-                        }\n-                        None => tcx.sess.struct_err(msg),\n-                    };\n-                    diag.emit();\n+                    let span = tcx.hir().span_if_local(did);\n+                    tcx.sess.emit_err(MaxNumNodesInConstErr { span, global_const_id });\n \n                     Ok(None)\n                 }"}, {"sha": "8a71e3b3401f69697eb0f5f3e188bcb88b164fda", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 641, "deletions": 2, "changes": 643, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,6 +1,24 @@\n+use rustc_errors::{\n+    DiagnosticArgValue, DiagnosticBuilder, DiagnosticMessage, EmissionGuarantee, Handler,\n+    IntoDiagnostic,\n+};\n use rustc_hir::ConstContext;\n-use rustc_macros::{Diagnostic, LintDiagnostic};\n+use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::mir::interpret::{\n+    CheckInAllocMsg, ExpectedKind, InterpError, InvalidMetaKind, InvalidProgramInfo, PointerKind,\n+    ResourceExhaustionInfo, UndefinedBehaviorInfo, UnsupportedOpInfo, ValidationErrorInfo,\n+};\n+use rustc_middle::ty::Ty;\n use rustc_span::Span;\n+use rustc_target::abi::call::AdjustForForeignAbiError;\n+use rustc_target::abi::{Size, WrappingRange};\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_dangling_ptr_in_final)]\n+pub(crate) struct DanglingPtrInFinal {\n+    #[primary_span]\n+    pub span: Span,\n+}\n \n #[derive(Diagnostic)]\n #[diag(const_eval_unstable_in_stable)]\n@@ -92,7 +110,7 @@ pub(crate) struct TransientMutBorrowErrRaw {\n #[diag(const_eval_max_num_nodes_in_const)]\n pub(crate) struct MaxNumNodesInConstErr {\n     #[primary_span]\n-    pub span: Span,\n+    pub span: Option<Span>,\n     pub global_const_id: String,\n }\n \n@@ -175,6 +193,14 @@ pub(crate) struct UnallowedInlineAsm {\n     pub kind: ConstContext,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(const_eval_unsupported_untyped_pointer)]\n+#[note]\n+pub(crate) struct UnsupportedUntypedPointer {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(const_eval_interior_mutable_data_refer, code = \"E0492\")]\n pub(crate) struct InteriorMutableDataRefer {\n@@ -212,3 +238,616 @@ pub struct LongRunningWarn {\n     #[help]\n     pub item_span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_erroneous_constant)]\n+pub(crate) struct ErroneousConstUsed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(const_eval_non_const_impl)]\n+pub(crate) struct NonConstImplNote {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic, PartialEq, Eq, Clone)]\n+#[note(const_eval_frame_note)]\n+pub struct FrameNote {\n+    #[primary_span]\n+    pub span: Span,\n+    pub times: i32,\n+    pub where_: &'static str,\n+    pub instance: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(const_eval_raw_bytes)]\n+pub struct RawBytesNote {\n+    pub size: u64,\n+    pub align: u64,\n+    pub bytes: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_for_loop_into_iter_non_const, code = \"E0015\")]\n+pub struct NonConstForLoopIntoIter<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_question_branch_non_const, code = \"E0015\")]\n+pub struct NonConstQuestionBranch<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_question_from_residual_non_const, code = \"E0015\")]\n+pub struct NonConstQuestionFromResidual<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_try_block_from_output_non_const, code = \"E0015\")]\n+pub struct NonConstTryBlockFromOutput<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_await_non_const, code = \"E0015\")]\n+pub struct NonConstAwait<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_closure_non_const, code = \"E0015\")]\n+pub struct NonConstClosure {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[subdiagnostic]\n+    pub note: Option<NonConstClosureNote>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum NonConstClosureNote {\n+    #[note(const_eval_closure_fndef_not_const)]\n+    FnDef {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(const_eval_fn_ptr_call)]\n+    FnPtr,\n+    #[note(const_eval_closure_call)]\n+    Closure,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(const_eval_consider_dereferencing, applicability = \"machine-applicable\")]\n+pub struct ConsiderDereferencing {\n+    pub deref: String,\n+    #[suggestion_part(code = \"{deref}\")]\n+    pub span: Span,\n+    #[suggestion_part(code = \"{deref}\")]\n+    pub rhs_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_operator_non_const, code = \"E0015\")]\n+pub struct NonConstOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[subdiagnostic]\n+    pub sugg: Option<ConsiderDereferencing>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_deref_coercion_non_const, code = \"E0015\")]\n+#[note]\n+pub struct NonConstDerefCoercion<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+    pub target_ty: Ty<'tcx>,\n+    #[note(const_eval_target_note)]\n+    pub deref_target: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_live_drop, code = \"E0493\")]\n+pub struct LiveDrop<'tcx> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    pub dropped_ty: Ty<'tcx>,\n+    #[label(const_eval_dropped_at_label)]\n+    pub dropped_at: Option<Span>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(const_eval_align_check_failed)]\n+pub struct AlignmentCheckFailed {\n+    pub has: u64,\n+    pub required: u64,\n+    #[subdiagnostic]\n+    pub frames: Vec<FrameNote>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_error, code = \"E0080\")]\n+pub struct ConstEvalError {\n+    #[primary_span]\n+    pub span: Span,\n+    /// One of \"const\", \"const_with_path\", and \"static\"\n+    pub error_kind: &'static str,\n+    pub instance: String,\n+    #[subdiagnostic]\n+    pub frame_notes: Vec<FrameNote>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_nullary_intrinsic_fail)]\n+pub struct NullaryIntrinsicError {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_undefined_behavior, code = \"E0080\")]\n+pub struct UndefinedBehavior {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note(const_eval_undefined_behavior_note)]\n+    pub ub_note: Option<()>,\n+    #[subdiagnostic]\n+    pub frames: Vec<FrameNote>,\n+    #[subdiagnostic]\n+    pub raw_bytes: RawBytesNote,\n+}\n+\n+pub trait ReportErrorExt {\n+    /// Returns the diagnostic message for this error.\n+    fn diagnostic_message(&self) -> DiagnosticMessage;\n+    fn add_args<G: EmissionGuarantee>(\n+        self,\n+        handler: &Handler,\n+        builder: &mut DiagnosticBuilder<'_, G>,\n+    );\n+}\n+\n+fn bad_pointer_message(msg: CheckInAllocMsg, handler: &Handler) -> String {\n+    use crate::fluent_generated::*;\n+\n+    let msg = match msg {\n+        CheckInAllocMsg::DerefTest => const_eval_deref_test,\n+        CheckInAllocMsg::MemoryAccessTest => const_eval_memory_access_test,\n+        CheckInAllocMsg::PointerArithmeticTest => const_eval_pointer_arithmetic_test,\n+        CheckInAllocMsg::OffsetFromTest => const_eval_offset_from_test,\n+        CheckInAllocMsg::InboundsTest => const_eval_in_bounds_test,\n+    };\n+\n+    handler.eagerly_translate_to_string(msg, [].into_iter())\n+}\n+\n+impl<'a> ReportErrorExt for UndefinedBehaviorInfo<'a> {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        use UndefinedBehaviorInfo::*;\n+        match self {\n+            Ub(msg) => (&**msg).into(),\n+            Unreachable => const_eval_unreachable,\n+            BoundsCheckFailed { .. } => const_eval_bounds_check_failed,\n+            DivisionByZero => const_eval_division_by_zero,\n+            RemainderByZero => const_eval_remainder_by_zero,\n+            DivisionOverflow => const_eval_division_overflow,\n+            RemainderOverflow => const_eval_remainder_overflow,\n+            PointerArithOverflow => const_eval_pointer_arithmetic_overflow,\n+            InvalidMeta(InvalidMetaKind::SliceTooBig) => const_eval_invalid_meta_slice,\n+            InvalidMeta(InvalidMetaKind::TooBig) => const_eval_invalid_meta,\n+            UnterminatedCString(_) => const_eval_unterminated_c_string,\n+            PointerUseAfterFree(_) => const_eval_pointer_use_after_free,\n+            PointerOutOfBounds { ptr_size: Size::ZERO, .. } => const_eval_zst_pointer_out_of_bounds,\n+            PointerOutOfBounds { .. } => const_eval_pointer_out_of_bounds,\n+            DanglingIntPointer(0, _) => const_eval_dangling_null_pointer,\n+            DanglingIntPointer(_, _) => const_eval_dangling_int_pointer,\n+            AlignmentCheckFailed { .. } => const_eval_alignment_check_failed,\n+            WriteToReadOnly(_) => const_eval_write_to_read_only,\n+            DerefFunctionPointer(_) => const_eval_deref_function_pointer,\n+            DerefVTablePointer(_) => const_eval_deref_vtable_pointer,\n+            InvalidBool(_) => const_eval_invalid_bool,\n+            InvalidChar(_) => const_eval_invalid_char,\n+            InvalidTag(_) => const_eval_invalid_tag,\n+            InvalidFunctionPointer(_) => const_eval_invalid_function_pointer,\n+            InvalidVTablePointer(_) => const_eval_invalid_vtable_pointer,\n+            InvalidStr(_) => const_eval_invalid_str,\n+            InvalidUninitBytes(None) => const_eval_invalid_uninit_bytes_unknown,\n+            InvalidUninitBytes(Some(_)) => const_eval_invalid_uninit_bytes,\n+            DeadLocal => const_eval_dead_local,\n+            ScalarSizeMismatch(_) => const_eval_scalar_size_mismatch,\n+            UninhabitedEnumVariantWritten => const_eval_uninhabited_enum_variant_written,\n+            Validation(e) => e.diagnostic_message(),\n+            Custom(x) => (x.msg)(),\n+        }\n+    }\n+\n+    fn add_args<G: EmissionGuarantee>(\n+        self,\n+        handler: &Handler,\n+        builder: &mut DiagnosticBuilder<'_, G>,\n+    ) {\n+        use UndefinedBehaviorInfo::*;\n+        match self {\n+            Ub(_)\n+            | Unreachable\n+            | DivisionByZero\n+            | RemainderByZero\n+            | DivisionOverflow\n+            | RemainderOverflow\n+            | PointerArithOverflow\n+            | InvalidMeta(InvalidMetaKind::SliceTooBig)\n+            | InvalidMeta(InvalidMetaKind::TooBig)\n+            | InvalidUninitBytes(None)\n+            | DeadLocal\n+            | UninhabitedEnumVariantWritten => {}\n+            BoundsCheckFailed { len, index } => {\n+                builder.set_arg(\"len\", len);\n+                builder.set_arg(\"index\", index);\n+            }\n+            UnterminatedCString(ptr) | InvalidFunctionPointer(ptr) | InvalidVTablePointer(ptr) => {\n+                builder.set_arg(\"pointer\", ptr);\n+            }\n+            PointerUseAfterFree(allocation) => {\n+                builder.set_arg(\"allocation\", allocation);\n+            }\n+            PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size, msg } => {\n+                builder\n+                    .set_arg(\"alloc_id\", alloc_id)\n+                    .set_arg(\"alloc_size\", alloc_size.bytes())\n+                    .set_arg(\"ptr_offset\", ptr_offset)\n+                    .set_arg(\"ptr_size\", ptr_size.bytes())\n+                    .set_arg(\"bad_pointer_message\", bad_pointer_message(msg, handler));\n+            }\n+            DanglingIntPointer(ptr, msg) => {\n+                if ptr != 0 {\n+                    builder.set_arg(\"pointer\", format!(\"{ptr:#x}[noalloc]\"));\n+                }\n+\n+                builder.set_arg(\"bad_pointer_message\", bad_pointer_message(msg, handler));\n+            }\n+            AlignmentCheckFailed { required, has } => {\n+                builder.set_arg(\"required\", required.bytes());\n+                builder.set_arg(\"has\", has.bytes());\n+            }\n+            WriteToReadOnly(alloc) | DerefFunctionPointer(alloc) | DerefVTablePointer(alloc) => {\n+                builder.set_arg(\"allocation\", alloc);\n+            }\n+            InvalidBool(b) => {\n+                builder.set_arg(\"value\", format!(\"{b:02x}\"));\n+            }\n+            InvalidChar(c) => {\n+                builder.set_arg(\"value\", format!(\"{c:08x}\"));\n+            }\n+            InvalidTag(tag) => {\n+                builder.set_arg(\"tag\", format!(\"{tag:x}\"));\n+            }\n+            InvalidStr(err) => {\n+                builder.set_arg(\"err\", format!(\"{err}\"));\n+            }\n+            InvalidUninitBytes(Some((alloc, info))) => {\n+                builder.set_arg(\"alloc\", alloc);\n+                builder.set_arg(\"access\", info.access);\n+                builder.set_arg(\"uninit\", info.uninit);\n+            }\n+            ScalarSizeMismatch(info) => {\n+                builder.set_arg(\"target_size\", info.target_size);\n+                builder.set_arg(\"data_size\", info.data_size);\n+            }\n+            Validation(e) => e.add_args(handler, builder),\n+            Custom(custom) => {\n+                (custom.add_args)(&mut |name, value| {\n+                    builder.set_arg(name, value);\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> ReportErrorExt for ValidationErrorInfo<'tcx> {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        use rustc_middle::mir::interpret::ValidationErrorKind::*;\n+        match self.kind {\n+            PtrToUninhabited { ptr_kind: PointerKind::Box, .. } => const_eval_box_to_uninhabited,\n+            PtrToUninhabited { ptr_kind: PointerKind::Ref, .. } => const_eval_ref_to_uninhabited,\n+\n+            PtrToStatic { ptr_kind: PointerKind::Box } => const_eval_box_to_static,\n+            PtrToStatic { ptr_kind: PointerKind::Ref } => const_eval_ref_to_static,\n+\n+            PtrToMut { ptr_kind: PointerKind::Box } => const_eval_box_to_mut,\n+            PtrToMut { ptr_kind: PointerKind::Ref } => const_eval_ref_to_mut,\n+\n+            ExpectedNonPtr { .. } => const_eval_expected_non_ptr,\n+            MutableRefInConst => const_eval_mutable_ref_in_const,\n+            NullFnPtr => const_eval_null_fn_ptr,\n+            NeverVal => const_eval_never_val,\n+            NullablePtrOutOfRange { .. } => const_eval_nullable_ptr_out_of_range,\n+            PtrOutOfRange { .. } => const_eval_ptr_out_of_range,\n+            OutOfRange { .. } => const_eval_out_of_range,\n+            UnsafeCell => const_eval_unsafe_cell,\n+            UninhabitedVal { .. } => const_eval_uninhabited_val,\n+            InvalidEnumTag { .. } => const_eval_invalid_enum_tag,\n+            UninitEnumTag => const_eval_uninit_enum_tag,\n+            UninitStr => const_eval_uninit_str,\n+            Uninit { expected: ExpectedKind::Bool } => const_eval_uninit_bool,\n+            Uninit { expected: ExpectedKind::Reference } => const_eval_uninit_ref,\n+            Uninit { expected: ExpectedKind::Box } => const_eval_uninit_box,\n+            Uninit { expected: ExpectedKind::RawPtr } => const_eval_uninit_raw_ptr,\n+            Uninit { expected: ExpectedKind::InitScalar } => const_eval_uninit_init_scalar,\n+            Uninit { expected: ExpectedKind::Char } => const_eval_uninit_char,\n+            Uninit { expected: ExpectedKind::Float } => const_eval_uninit_float,\n+            Uninit { expected: ExpectedKind::Int } => const_eval_uninit_int,\n+            Uninit { expected: ExpectedKind::FnPtr } => const_eval_uninit_fn_ptr,\n+            UninitVal => const_eval_uninit,\n+            InvalidVTablePtr { .. } => const_eval_invalid_vtable_ptr,\n+            InvalidMetaSliceTooLarge { ptr_kind: PointerKind::Box } => {\n+                const_eval_invalid_box_slice_meta\n+            }\n+            InvalidMetaSliceTooLarge { ptr_kind: PointerKind::Ref } => {\n+                const_eval_invalid_ref_slice_meta\n+            }\n+\n+            InvalidMetaTooLarge { ptr_kind: PointerKind::Box } => const_eval_invalid_box_meta,\n+            InvalidMetaTooLarge { ptr_kind: PointerKind::Ref } => const_eval_invalid_ref_meta,\n+            UnalignedPtr { ptr_kind: PointerKind::Ref, .. } => const_eval_unaligned_ref,\n+            UnalignedPtr { ptr_kind: PointerKind::Box, .. } => const_eval_unaligned_box,\n+\n+            NullPtr { ptr_kind: PointerKind::Box } => const_eval_null_box,\n+            NullPtr { ptr_kind: PointerKind::Ref } => const_eval_null_ref,\n+            DanglingPtrNoProvenance { ptr_kind: PointerKind::Box, .. } => {\n+                const_eval_dangling_box_no_provenance\n+            }\n+            DanglingPtrNoProvenance { ptr_kind: PointerKind::Ref, .. } => {\n+                const_eval_dangling_ref_no_provenance\n+            }\n+            DanglingPtrOutOfBounds { ptr_kind: PointerKind::Box } => {\n+                const_eval_dangling_box_out_of_bounds\n+            }\n+            DanglingPtrOutOfBounds { ptr_kind: PointerKind::Ref } => {\n+                const_eval_dangling_ref_out_of_bounds\n+            }\n+            DanglingPtrUseAfterFree { ptr_kind: PointerKind::Box } => {\n+                const_eval_dangling_box_use_after_free\n+            }\n+            DanglingPtrUseAfterFree { ptr_kind: PointerKind::Ref } => {\n+                const_eval_dangling_ref_use_after_free\n+            }\n+            InvalidBool { .. } => const_eval_validation_invalid_bool,\n+            InvalidChar { .. } => const_eval_validation_invalid_char,\n+            InvalidFnPtr { .. } => const_eval_invalid_fn_ptr,\n+        }\n+    }\n+\n+    fn add_args<G: EmissionGuarantee>(self, handler: &Handler, err: &mut DiagnosticBuilder<'_, G>) {\n+        use crate::fluent_generated as fluent;\n+        use rustc_middle::mir::interpret::ValidationErrorKind::*;\n+\n+        let message = if let Some(path) = self.path {\n+            handler.eagerly_translate_to_string(\n+                fluent::const_eval_invalid_value_with_path,\n+                [(\"path\".into(), DiagnosticArgValue::Str(path.into()))].iter().map(|(a, b)| (a, b)),\n+            )\n+        } else {\n+            handler.eagerly_translate_to_string(fluent::const_eval_invalid_value, [].into_iter())\n+        };\n+\n+        err.set_arg(\"front_matter\", message);\n+\n+        fn add_range_arg<G: EmissionGuarantee>(\n+            r: WrappingRange,\n+            max_hi: u128,\n+            handler: &Handler,\n+            err: &mut DiagnosticBuilder<'_, G>,\n+        ) {\n+            let WrappingRange { start: lo, end: hi } = r;\n+            assert!(hi <= max_hi);\n+            let msg = if lo > hi {\n+                fluent::const_eval_range_wrapping\n+            } else if lo == hi {\n+                fluent::const_eval_range_singular\n+            } else if lo == 0 {\n+                assert!(hi < max_hi, \"should not be printing if the range covers everything\");\n+                fluent::const_eval_range_upper\n+            } else if hi == max_hi {\n+                assert!(lo > 0, \"should not be printing if the range covers everything\");\n+                fluent::const_eval_range_lower\n+            } else {\n+                fluent::const_eval_range\n+            };\n+\n+            let args = [\n+                (\"lo\".into(), DiagnosticArgValue::Str(lo.to_string().into())),\n+                (\"hi\".into(), DiagnosticArgValue::Str(hi.to_string().into())),\n+            ];\n+            let args = args.iter().map(|(a, b)| (a, b));\n+            let message = handler.eagerly_translate_to_string(msg, args);\n+            err.set_arg(\"in_range\", message);\n+        }\n+\n+        match self.kind {\n+            PtrToUninhabited { ty, .. } | UninhabitedVal { ty } => {\n+                err.set_arg(\"ty\", ty);\n+            }\n+            ExpectedNonPtr { value }\n+            | InvalidEnumTag { value }\n+            | InvalidVTablePtr { value }\n+            | InvalidBool { value }\n+            | InvalidChar { value }\n+            | InvalidFnPtr { value } => {\n+                err.set_arg(\"value\", value);\n+            }\n+            NullablePtrOutOfRange { range, max_value } | PtrOutOfRange { range, max_value } => {\n+                add_range_arg(range, max_value, handler, err)\n+            }\n+            OutOfRange { range, max_value, value } => {\n+                err.set_arg(\"value\", value);\n+                add_range_arg(range, max_value, handler, err);\n+            }\n+            UnalignedPtr { required_bytes, found_bytes, .. } => {\n+                err.set_arg(\"required_bytes\", required_bytes);\n+                err.set_arg(\"found_bytes\", found_bytes);\n+            }\n+            DanglingPtrNoProvenance { pointer, .. } => {\n+                err.set_arg(\"pointer\", pointer);\n+            }\n+            NullPtr { .. }\n+            | PtrToStatic { .. }\n+            | PtrToMut { .. }\n+            | MutableRefInConst\n+            | NullFnPtr\n+            | NeverVal\n+            | UnsafeCell\n+            | UninitEnumTag\n+            | UninitStr\n+            | Uninit { .. }\n+            | UninitVal\n+            | InvalidMetaSliceTooLarge { .. }\n+            | InvalidMetaTooLarge { .. }\n+            | DanglingPtrUseAfterFree { .. }\n+            | DanglingPtrOutOfBounds { .. } => {}\n+        }\n+    }\n+}\n+\n+impl ReportErrorExt for UnsupportedOpInfo {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        match self {\n+            UnsupportedOpInfo::Unsupported(s) => s.clone().into(),\n+            UnsupportedOpInfo::PartialPointerOverwrite(_) => const_eval_partial_pointer_overwrite,\n+            UnsupportedOpInfo::PartialPointerCopy(_) => const_eval_partial_pointer_copy,\n+            UnsupportedOpInfo::ReadPointerAsBytes => const_eval_read_pointer_as_bytes,\n+            UnsupportedOpInfo::ThreadLocalStatic(_) => const_eval_thread_local_static,\n+            UnsupportedOpInfo::ReadExternStatic(_) => const_eval_read_extern_static,\n+        }\n+    }\n+    fn add_args<G: EmissionGuarantee>(self, _: &Handler, builder: &mut DiagnosticBuilder<'_, G>) {\n+        use crate::fluent_generated::*;\n+\n+        use UnsupportedOpInfo::*;\n+        if let ReadPointerAsBytes | PartialPointerOverwrite(_) | PartialPointerCopy(_) = self {\n+            builder.help(const_eval_ptr_as_bytes_1);\n+            builder.help(const_eval_ptr_as_bytes_2);\n+        }\n+        match self {\n+            Unsupported(_) | ReadPointerAsBytes => {}\n+            PartialPointerOverwrite(ptr) | PartialPointerCopy(ptr) => {\n+                builder.set_arg(\"ptr\", ptr);\n+            }\n+            ThreadLocalStatic(did) | ReadExternStatic(did) => {\n+                builder.set_arg(\"did\", format!(\"{did:?}\"));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> ReportErrorExt for InterpError<'tcx> {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        match self {\n+            InterpError::UndefinedBehavior(ub) => ub.diagnostic_message(),\n+            InterpError::Unsupported(e) => e.diagnostic_message(),\n+            InterpError::InvalidProgram(e) => e.diagnostic_message(),\n+            InterpError::ResourceExhaustion(e) => e.diagnostic_message(),\n+            InterpError::MachineStop(e) => e.diagnostic_message(),\n+        }\n+    }\n+    fn add_args<G: EmissionGuarantee>(\n+        self,\n+        handler: &Handler,\n+        builder: &mut DiagnosticBuilder<'_, G>,\n+    ) {\n+        match self {\n+            InterpError::UndefinedBehavior(ub) => ub.add_args(handler, builder),\n+            InterpError::Unsupported(e) => e.add_args(handler, builder),\n+            InterpError::InvalidProgram(e) => e.add_args(handler, builder),\n+            InterpError::ResourceExhaustion(e) => e.add_args(handler, builder),\n+            InterpError::MachineStop(e) => e.add_args(&mut |name, value| {\n+                builder.set_arg(name, value);\n+            }),\n+        }\n+    }\n+}\n+\n+impl<'tcx> ReportErrorExt for InvalidProgramInfo<'tcx> {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        match self {\n+            InvalidProgramInfo::TooGeneric => const_eval_too_generic,\n+            InvalidProgramInfo::AlreadyReported(_) => const_eval_already_reported,\n+            InvalidProgramInfo::Layout(e) => e.diagnostic_message(),\n+            InvalidProgramInfo::FnAbiAdjustForForeignAbi(_) => {\n+                rustc_middle::error::middle_adjust_for_foreign_abi_error\n+            }\n+            InvalidProgramInfo::SizeOfUnsizedType(_) => const_eval_size_of_unsized,\n+            InvalidProgramInfo::UninitUnsizedLocal => const_eval_uninit_unsized_local,\n+        }\n+    }\n+    fn add_args<G: EmissionGuarantee>(\n+        self,\n+        handler: &Handler,\n+        builder: &mut DiagnosticBuilder<'_, G>,\n+    ) {\n+        match self {\n+            InvalidProgramInfo::TooGeneric\n+            | InvalidProgramInfo::AlreadyReported(_)\n+            | InvalidProgramInfo::UninitUnsizedLocal => {}\n+            InvalidProgramInfo::Layout(e) => {\n+                let diag: DiagnosticBuilder<'_, ()> = e.into_diagnostic().into_diagnostic(handler);\n+                for (name, val) in diag.args() {\n+                    builder.set_arg(name.clone(), val.clone());\n+                }\n+                diag.cancel();\n+            }\n+            InvalidProgramInfo::FnAbiAdjustForForeignAbi(\n+                AdjustForForeignAbiError::Unsupported { arch, abi },\n+            ) => {\n+                builder.set_arg(\"arch\", arch);\n+                builder.set_arg(\"abi\", abi.name());\n+            }\n+            InvalidProgramInfo::SizeOfUnsizedType(ty) => {\n+                builder.set_arg(\"ty\", ty);\n+            }\n+        }\n+    }\n+}\n+\n+impl ReportErrorExt for ResourceExhaustionInfo {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        match self {\n+            ResourceExhaustionInfo::StackFrameLimitReached => const_eval_stack_frame_limit_reached,\n+            ResourceExhaustionInfo::MemoryExhausted => const_eval_memory_exhausted,\n+            ResourceExhaustionInfo::AddressSpaceFull => const_eval_address_space_full,\n+        }\n+    }\n+    fn add_args<G: EmissionGuarantee>(self, _: &Handler, _: &mut DiagnosticBuilder<'_, G>) {}\n+}"}, {"sha": "b4db3dff3ffc2de8bb00a93b7494316a86e0f043", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -14,6 +14,8 @@ use super::{\n     util::ensure_monomorphic_enough, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy,\n };\n \n+use crate::fluent_generated as fluent;\n+\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n@@ -138,12 +140,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert!(src.layout.is_sized());\n                 assert!(dest.layout.is_sized());\n                 if src.layout.size != dest.layout.size {\n-                    throw_ub_format!(\n-                        \"transmuting from {}-byte type to {}-byte type: `{}` -> `{}`\",\n-                        src.layout.size.bytes(),\n-                        dest.layout.size.bytes(),\n-                        src.layout.ty,\n-                        dest.layout.ty,\n+                    let src_bytes = src.layout.size.bytes();\n+                    let dest_bytes = dest.layout.size.bytes();\n+                    let src_ty = format!(\"{}\", src.layout.ty);\n+                    let dest_ty = format!(\"{}\", dest.layout.ty);\n+                    throw_ub_custom!(\n+                        fluent::const_eval_invalid_transmute,\n+                        src_bytes = src_bytes,\n+                        dest_bytes = dest_bytes,\n+                        src = src_ty,\n+                        dest = dest_ty,\n                     );\n                 }\n \n@@ -363,7 +369,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let old_vptr = old_vptr.to_pointer(self)?;\n                 let (ty, old_trait) = self.get_ptr_vtable(old_vptr)?;\n                 if old_trait != data_a.principal() {\n-                    throw_ub_format!(\"upcast on a pointer whose vtable does not match its type\");\n+                    throw_ub_custom!(fluent::const_eval_upcast_mismatch);\n                 }\n                 let new_vptr = self.get_vtable_ptr(ty, data_b.principal())?;\n                 self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)"}, {"sha": "36606ff69a6ca7e4649cbd8716660ac26baaf20f", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,14 +1,13 @@\n use std::cell::Cell;\n-use std::fmt;\n-use std::mem;\n+use std::{fmt, mem};\n \n use either::{Either, Left, Right};\n \n use hir::CRATE_HIR_ID;\n use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n use rustc_index::IndexVec;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ErrorHandled, InterpError, ReportedErrorInfo};\n+use rustc_middle::mir::interpret::{ErrorHandled, InterpError, InvalidMetaKind, ReportedErrorInfo};\n use rustc_middle::query::TyCtxtAt;\n use rustc_middle::ty::layout::{\n     self, FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOf, LayoutOfHelpers,\n@@ -25,6 +24,8 @@ use super::{\n     MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n     Scalar, StackPopJump,\n };\n+use crate::errors::{self, ErroneousConstUsed};\n+use crate::fluent_generated as fluent;\n use crate::util;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -247,6 +248,7 @@ impl<'mir, 'tcx, Prov: Provenance, Extra> Frame<'mir, 'tcx, Prov, Extra> {\n     }\n }\n \n+// FIXME: only used by miri, should be removed once translatable.\n impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {\n@@ -264,6 +266,21 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n     }\n }\n \n+impl<'tcx> FrameInfo<'tcx> {\n+    pub fn as_note(&self, tcx: TyCtxt<'tcx>) -> errors::FrameNote {\n+        let span = self.span;\n+        if tcx.def_key(self.instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+            errors::FrameNote { where_: \"closure\", span, instance: String::new(), times: 0 }\n+        } else {\n+            let instance = format!(\"{}\", self.instance);\n+            // Note: this triggers a `good_path_bug` state, which means that if we ever get here\n+            // we must emit a diagnostic. We should never display a `FrameInfo` unless we\n+            // actually want to emit a warning or error to the user.\n+            errors::FrameNote { where_: \"instance\", span, instance, times: 0 }\n+        }\n+    }\n+}\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n@@ -620,7 +637,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Check if this brought us over the size limit.\n                 if size > self.max_size_of_val() {\n-                    throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n+                    throw_ub!(InvalidMeta(InvalidMetaKind::TooBig));\n                 }\n                 Ok(Some((size, align)))\n             }\n@@ -638,7 +655,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let size = elem.size.bytes().saturating_mul(len); // we rely on `max_size_of_val` being smaller than `u64::MAX`.\n                 let size = Size::from_bytes(size);\n                 if size > self.max_size_of_val() {\n-                    throw_ub!(InvalidMeta(\"slice is bigger than largest supported object\"));\n+                    throw_ub!(InvalidMeta(InvalidMetaKind::SliceTooBig));\n                 }\n                 Ok(Some((size, elem.align.abi)))\n             }\n@@ -746,7 +763,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             mir::UnwindAction::Cleanup(block) => Left(mir::Location { block, statement_index: 0 }),\n             mir::UnwindAction::Continue => Right(self.frame_mut().body.span),\n             mir::UnwindAction::Unreachable => {\n-                throw_ub_format!(\"unwinding past a stack frame that does not allow unwinding\")\n+                throw_ub_custom!(fluent::const_eval_unreachable_unwind);\n             }\n             mir::UnwindAction::Terminate => {\n                 self.frame_mut().loc = Right(self.frame_mut().body.span);\n@@ -785,7 +802,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         );\n         if unwinding && self.frame_idx() == 0 {\n-            throw_ub_format!(\"unwinding past the topmost frame of the stack\");\n+            throw_ub_custom!(fluent::const_eval_unwind_past_top);\n         }\n \n         // Copy return value. Must of course happen *before* we deallocate the locals.\n@@ -873,7 +890,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // StorageLive expects the local to be dead, and marks it live.\n         let old = mem::replace(&mut self.frame_mut().locals[local].value, local_val);\n         if !matches!(old, LocalValue::Dead) {\n-            throw_ub_format!(\"StorageLive on a local that was already live\");\n+            throw_ub_custom!(fluent::const_eval_double_storage_live);\n         }\n         Ok(())\n     }\n@@ -916,7 +933,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ErrorHandled::Reported(err) => {\n                     if !err.is_tainted_by_errors() && let Some(span) = span {\n                         // To make it easier to figure out where this error comes from, also add a note at the current location.\n-                        self.tcx.sess.span_note_without_error(span, \"erroneous constant used\");\n+                        self.tcx.sess.emit_note(ErroneousConstUsed { span });\n                     }\n                     err_inval!(AlreadyReported(err))\n                 }"}, {"sha": "7b11ad33091e4541ad6f94063d054970641cd584", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -28,6 +28,7 @@ use super::{\n     ValueVisitor,\n };\n use crate::const_eval;\n+use crate::errors::{DanglingPtrInFinal, UnsupportedUntypedPointer};\n \n pub trait CompileTimeMachine<'mir, 'tcx, T> = Machine<\n         'mir,\n@@ -320,10 +321,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n     }\n }\n \n+/// How a constant value should be interned.\n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n pub enum InternKind {\n     /// The `mutability` of the static, ignoring the type which may have interior mutability.\n     Static(hir::Mutability),\n+    /// A `const` item\n     Constant,\n     Promoted,\n }\n@@ -388,8 +391,7 @@ pub fn intern_const_alloc_recursive<\n                 ecx.tcx.sess.delay_span_bug(\n                     ecx.tcx.span,\n                     format!(\n-                        \"error during interning should later cause validation failure: {}\",\n-                        error\n+                        \"error during interning should later cause validation failure: {error:?}\"\n                     ),\n                 );\n             }\n@@ -425,14 +427,16 @@ pub fn intern_const_alloc_recursive<\n                     // immutability is so important.\n                     alloc.mutability = Mutability::Not;\n                 }\n+                // If it's a constant, we should not have any \"leftovers\" as everything\n+                // is tracked by const-checking.\n+                // FIXME: downgrade this to a warning? It rejects some legitimate consts,\n+                // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n+                //\n+                // NOTE: it looks likes this code path is only reachable when we try to intern\n+                // something that cannot be promoted, which in constants means values that have\n+                // drop glue, such as the example above.\n                 InternKind::Constant => {\n-                    // If it's a constant, we should not have any \"leftovers\" as everything\n-                    // is tracked by const-checking.\n-                    // FIXME: downgrade this to a warning? It rejects some legitimate consts,\n-                    // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n-                    ecx.tcx\n-                        .sess\n-                        .span_err(ecx.tcx.span, \"untyped pointers are not allowed in constant\");\n+                    ecx.tcx.sess.emit_err(UnsupportedUntypedPointer { span: ecx.tcx.span });\n                     // For better errors later, mark the allocation as immutable.\n                     alloc.mutability = Mutability::Not;\n                 }\n@@ -447,10 +451,7 @@ pub fn intern_const_alloc_recursive<\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // Codegen does not like dangling pointers, and generally `tcx` assumes that\n             // all allocations referenced anywhere actually exist. So, make sure we error here.\n-            let reported = ecx\n-                .tcx\n-                .sess\n-                .span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n+            let reported = ecx.tcx.sess.emit_err(DanglingPtrInFinal { span: ecx.tcx.span });\n             return Err(reported);\n         } else if ecx.tcx.try_get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't"}, {"sha": "fb24cf48a9a02a7e998ba9a821013a54e64f8fdc", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 43, "deletions": 32, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -22,6 +22,8 @@ use super::{\n     Pointer,\n };\n \n+use crate::fluent_generated as fluent;\n+\n mod caller_location;\n \n fn numeric_intrinsic<Prov>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<Prov> {\n@@ -198,15 +200,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         ty\n                     ),\n                 };\n-                let (nonzero, intrinsic_name) = match intrinsic_name {\n+                let (nonzero, actual_intrinsic_name) = match intrinsic_name {\n                     sym::cttz_nonzero => (true, sym::cttz),\n                     sym::ctlz_nonzero => (true, sym::ctlz),\n                     other => (false, other),\n                 };\n                 if nonzero && bits == 0 {\n-                    throw_ub_format!(\"`{}_nonzero` called on 0\", intrinsic_name);\n+                    throw_ub_custom!(\n+                        fluent::const_eval_call_nonzero_intrinsic,\n+                        name = intrinsic_name,\n+                    );\n                 }\n-                let out_val = numeric_intrinsic(intrinsic_name, bits, kind);\n+                let out_val = numeric_intrinsic(actual_intrinsic_name, bits, kind);\n                 self.write_scalar(out_val, dest)?;\n             }\n             sym::saturating_add | sym::saturating_sub => {\n@@ -253,9 +258,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val = r.to_scalar().to_bits(layout.size)?;\n                     if let sym::unchecked_shl | sym::unchecked_shr = intrinsic_name {\n-                        throw_ub_format!(\"overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n+                        throw_ub_custom!(\n+                            fluent::const_eval_overflow_shift,\n+                            val = r_val,\n+                            name = intrinsic_name\n+                        );\n                     } else {\n-                        throw_ub_format!(\"overflow executing `{}`\", intrinsic_name);\n+                        throw_ub_custom!(fluent::const_eval_overflow, name = intrinsic_name);\n                     }\n                 }\n                 self.write_scalar(val, dest)?;\n@@ -314,17 +323,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (Err(_), _) | (_, Err(_)) => {\n                             // We managed to find a valid allocation for one pointer, but not the other.\n                             // That means they are definitely not pointing to the same allocation.\n-                            throw_ub_format!(\n-                                \"`{}` called on pointers into different allocations\",\n-                                intrinsic_name\n+                            throw_ub_custom!(\n+                                fluent::const_eval_different_allocations,\n+                                name = intrinsic_name,\n                             );\n                         }\n                         (Ok((a_alloc_id, a_offset, _)), Ok((b_alloc_id, b_offset, _))) => {\n                             // Found allocation for both. They must be into the same allocation.\n                             if a_alloc_id != b_alloc_id {\n-                                throw_ub_format!(\n-                                    \"`{}` called on pointers into different allocations\",\n-                                    intrinsic_name\n+                                throw_ub_custom!(\n+                                    fluent::const_eval_different_allocations,\n+                                    name = intrinsic_name,\n                                 );\n                             }\n                             // Use these offsets for distance calculation.\n@@ -344,21 +353,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     if overflowed {\n                         // a < b\n                         if intrinsic_name == sym::ptr_offset_from_unsigned {\n-                            throw_ub_format!(\n-                                \"`{}` called when first pointer has smaller offset than second: {} < {}\",\n-                                intrinsic_name,\n-                                a_offset,\n-                                b_offset,\n+                            throw_ub_custom!(\n+                                fluent::const_eval_unsigned_offset_from_overflow,\n+                                a_offset = a_offset,\n+                                b_offset = b_offset,\n                             );\n                         }\n                         // The signed form of the intrinsic allows this. If we interpret the\n                         // difference as isize, we'll get the proper signed difference. If that\n                         // seems *positive*, they were more than isize::MAX apart.\n                         let dist = val.to_target_isize(self)?;\n                         if dist >= 0 {\n-                            throw_ub_format!(\n-                                \"`{}` called when first pointer is too far before second\",\n-                                intrinsic_name\n+                            throw_ub_custom!(\n+                                fluent::const_eval_offset_from_underflow,\n+                                name = intrinsic_name,\n                             );\n                         }\n                         dist\n@@ -368,9 +376,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // If converting to isize produced a *negative* result, we had an overflow\n                         // because they were more than isize::MAX apart.\n                         if dist < 0 {\n-                            throw_ub_format!(\n-                                \"`{}` called when first pointer is too far ahead of second\",\n-                                intrinsic_name\n+                            throw_ub_custom!(\n+                                fluent::const_eval_offset_from_overflow,\n+                                name = intrinsic_name,\n                             );\n                         }\n                         dist\n@@ -513,7 +521,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let op = self.eval_operand(op, None)?;\n                 let cond = self.read_scalar(&op)?.to_bool()?;\n                 if !cond {\n-                    throw_ub_format!(\"`assume` called with `false`\");\n+                    throw_ub_custom!(fluent::const_eval_assume_false);\n                 }\n                 Ok(())\n             }\n@@ -542,7 +550,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let (res, overflow, _ty) = self.overflowing_binary_op(BinOp::Rem, &a, &b)?;\n         assert!(!overflow); // All overflow is UB, so this should never return on overflow.\n         if res.assert_bits(a.layout.size) != 0 {\n-            throw_ub_format!(\"exact_div: {} cannot be divided by {} without remainder\", a, b)\n+            throw_ub_custom!(\n+                fluent::const_eval_exact_div_has_remainder,\n+                a = format!(\"{a}\"),\n+                b = format!(\"{b}\")\n+            )\n         }\n         // `Rem` says this is all right, so we can let `Div` do its job.\n         self.binop_ignore_overflow(BinOp::Div, &a, &b, dest)\n@@ -638,9 +650,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n         // but no actual allocation can be big enough for the difference to be noticeable.\n         let size = size.checked_mul(count, self).ok_or_else(|| {\n-            err_ub_format!(\n-                \"overflow computing total size of `{}`\",\n-                if nonoverlapping { \"copy_nonoverlapping\" } else { \"copy\" }\n+            err_ub_custom!(\n+                fluent::const_eval_size_overflow,\n+                name = if nonoverlapping { \"copy_nonoverlapping\" } else { \"copy\" }\n             )\n         })?;\n \n@@ -664,10 +676,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n         // but no actual allocation can be big enough for the difference to be noticeable.\n-        let len = layout\n-            .size\n-            .checked_mul(count, self)\n-            .ok_or_else(|| err_ub_format!(\"overflow computing total size of `write_bytes`\"))?;\n+        let len = layout.size.checked_mul(count, self).ok_or_else(|| {\n+            err_ub_custom!(fluent::const_eval_size_overflow, name = \"write_bytes\")\n+        })?;\n \n         let bytes = std::iter::repeat(byte).take(len.bytes_usize());\n         self.write_bytes_ptr(dst, bytes)\n@@ -691,7 +702,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok(&[]);\n             };\n             if alloc_ref.has_provenance() {\n-                throw_ub_format!(\"`raw_eq` on bytes with provenance\");\n+                throw_ub_custom!(fluent::const_eval_raw_eq_with_provenance);\n             }\n             alloc_ref.get_bytes_strip_provenance()\n         };"}, {"sha": "1125d8d1f0e08927f8868bb561c8ac6f05282412", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use crate::const_eval::CheckAlignment;\n+use crate::fluent_generated as fluent;\n \n use super::{\n     alloc_range, AllocBytes, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg,\n@@ -200,7 +201,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n-        let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n+        let alloc = if M::PANIC_ON_ALLOC_FAIL {\n+            Allocation::uninit(size, align)\n+        } else {\n+            Allocation::try_uninit(size, align)?\n+        };\n         self.allocate_raw_ptr(alloc, kind)\n     }\n \n@@ -242,9 +247,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let (alloc_id, offset, _prov) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n-            throw_ub_format!(\n-                \"reallocating {:?} which does not point to the beginning of an object\",\n-                ptr\n+            throw_ub_custom!(\n+                fluent::const_eval_realloc_or_alloc_with_offset,\n+                ptr = format!(\"{ptr:?}\"),\n+                kind = \"realloc\"\n             );\n         }\n \n@@ -280,45 +286,62 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"deallocating: {alloc_id:?}\");\n \n         if offset.bytes() != 0 {\n-            throw_ub_format!(\n-                \"deallocating {:?} which does not point to the beginning of an object\",\n-                ptr\n+            throw_ub_custom!(\n+                fluent::const_eval_realloc_or_alloc_with_offset,\n+                ptr = format!(\"{ptr:?}\"),\n+                kind = \"dealloc\",\n             );\n         }\n \n         let Some((alloc_kind, mut alloc)) = self.memory.alloc_map.remove(&alloc_id) else {\n             // Deallocating global memory -- always an error\n             return Err(match self.tcx.try_get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Function(..)) => {\n-                    err_ub_format!(\"deallocating {alloc_id:?}, which is a function\")\n+                    err_ub_custom!(\n+                        fluent::const_eval_invalid_dealloc,\n+                        alloc_id = alloc_id,\n+                        kind = \"fn\",\n+                    )\n                 }\n                 Some(GlobalAlloc::VTable(..)) => {\n-                    err_ub_format!(\"deallocating {alloc_id:?}, which is a vtable\")\n+                    err_ub_custom!(\n+                        fluent::const_eval_invalid_dealloc,\n+                        alloc_id = alloc_id,\n+                        kind = \"vtable\",\n+                    )\n                 }\n                 Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n-                    err_ub_format!(\"deallocating {alloc_id:?}, which is static memory\")\n+                    err_ub_custom!(\n+                        fluent::const_eval_invalid_dealloc,\n+                        alloc_id = alloc_id,\n+                        kind = \"static_mem\"\n+                    )\n                 }\n                 None => err_ub!(PointerUseAfterFree(alloc_id)),\n             }\n             .into());\n         };\n \n         if alloc.mutability.is_not() {\n-            throw_ub_format!(\"deallocating immutable allocation {alloc_id:?}\");\n+            throw_ub_custom!(fluent::const_eval_dealloc_immutable, alloc = alloc_id,);\n         }\n         if alloc_kind != kind {\n-            throw_ub_format!(\n-                \"deallocating {alloc_id:?}, which is {alloc_kind} memory, using {kind} deallocation operation\"\n+            throw_ub_custom!(\n+                fluent::const_eval_dealloc_kind_mismatch,\n+                alloc = alloc_id,\n+                alloc_kind = format!(\"{alloc_kind}\"),\n+                kind = format!(\"{kind}\"),\n             );\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size != alloc.size() || align != alloc.align {\n-                throw_ub_format!(\n-                    \"incorrect layout on deallocation: {alloc_id:?} has size {} and alignment {}, but gave size {} and alignment {}\",\n-                    alloc.size().bytes(),\n-                    alloc.align.bytes(),\n-                    size.bytes(),\n-                    align.bytes(),\n+                throw_ub_custom!(\n+                    fluent::const_eval_dealloc_incorrect_layout,\n+                    alloc = alloc_id,\n+                    size = alloc.size().bytes(),\n+                    align = alloc.align.bytes(),\n+                    size_found = size.bytes(),\n+                    align_found = align.bytes(),\n                 )\n             }\n         }\n@@ -1166,7 +1189,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     if (src_offset <= dest_offset && src_offset + size > dest_offset)\n                         || (dest_offset <= src_offset && dest_offset + size > src_offset)\n                     {\n-                        throw_ub_format!(\"copy_nonoverlapping called on overlapping ranges\")\n+                        throw_ub_custom!(fluent::const_eval_copy_nonoverlapping_overlapping);\n                     }\n                 }\n "}, {"sha": "7269ff8d53cdfb319b8248f134b141f91d7c28da", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -15,6 +15,7 @@ use super::{\n     FnVal, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine, MemoryKind, OpTy, Operand,\n     PlaceTy, Scalar, StackPopCleanup,\n };\n+use crate::fluent_generated as fluent;\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn eval_terminator(\n@@ -172,7 +173,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             InlineAsm { template, ref operands, options, destination, .. } => {\n                 M::eval_inline_asm(self, template, operands, options)?;\n                 if options.contains(InlineAsmOptions::NORETURN) {\n-                    throw_ub_format!(\"returned from noreturn inline assembly\");\n+                    throw_ub_custom!(fluent::const_eval_noreturn_asm_returned);\n                 }\n                 self.go_to_block(\n                     destination\n@@ -288,15 +289,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         }\n         // Find next caller arg.\n-        let (caller_arg, caller_abi) = caller_args.next().ok_or_else(|| {\n-            err_ub_format!(\"calling a function with fewer arguments than it requires\")\n-        })?;\n+        let Some((caller_arg, caller_abi)) = caller_args.next() else {\n+            throw_ub_custom!(fluent::const_eval_not_enough_caller_args);\n+        };\n         // Now, check\n         if !Self::check_argument_compat(caller_abi, callee_abi) {\n-            throw_ub_format!(\n-                \"calling a function with argument of type {:?} passing data of type {:?}\",\n-                callee_arg.layout.ty,\n-                caller_arg.layout.ty\n+            let callee_ty = format!(\"{}\", callee_arg.layout.ty);\n+            let caller_ty = format!(\"{}\", caller_arg.layout.ty);\n+            throw_ub_custom!(\n+                fluent::const_eval_incompatible_types,\n+                callee_ty = callee_ty,\n+                caller_ty = caller_ty,\n             )\n         }\n         // Special handling for unsized parameters.\n@@ -398,10 +401,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 if M::enforce_abi(self) {\n                     if caller_fn_abi.conv != callee_fn_abi.conv {\n-                        throw_ub_format!(\n-                            \"calling a function with calling convention {:?} using calling convention {:?}\",\n-                            callee_fn_abi.conv,\n-                            caller_fn_abi.conv\n+                        throw_ub_custom!(\n+                            fluent::const_eval_incompatible_calling_conventions,\n+                            callee_conv = format!(\"{:?}\", callee_fn_abi.conv),\n+                            caller_conv = format!(\"{:?}\", caller_fn_abi.conv),\n                         )\n                     }\n                 }\n@@ -508,15 +511,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         \"mismatch between callee ABI and callee body arguments\"\n                     );\n                     if caller_args.next().is_some() {\n-                        throw_ub_format!(\"calling a function with more arguments than it expected\")\n+                        throw_ub_custom!(fluent::const_eval_too_many_caller_args);\n                     }\n                     // Don't forget to check the return type!\n                     if !Self::check_argument_compat(&caller_fn_abi.ret, &callee_fn_abi.ret) {\n-                        throw_ub_format!(\n-                            \"calling a function with return type {:?} passing \\\n-                                    return place of type {:?}\",\n-                            callee_fn_abi.ret.layout.ty,\n-                            caller_fn_abi.ret.layout.ty,\n+                        let callee_ty = format!(\"{}\", callee_fn_abi.ret.layout.ty);\n+                        let caller_ty = format!(\"{}\", caller_fn_abi.ret.layout.ty);\n+                        throw_ub_custom!(\n+                            fluent::const_eval_incompatible_return_types,\n+                            callee_ty = callee_ty,\n+                            caller_ty = caller_ty,\n                         )\n                     }\n                 };\n@@ -587,9 +591,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let (recv, vptr) = self.unpack_dyn_star(&receiver_place.into())?;\n                     let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n                     if dyn_trait != data.principal() {\n-                        throw_ub_format!(\n-                            \"`dyn*` call on a pointer whose vtable does not match its type\"\n-                        );\n+                        throw_ub_custom!(fluent::const_eval_dyn_star_call_vtable_mismatch);\n                     }\n                     let recv = recv.assert_mem_place(); // we passed an MPlaceTy to `unpack_dyn_star` so we definitely still have one\n \n@@ -609,9 +611,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n                     let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n                     if dyn_trait != data.principal() {\n-                        throw_ub_format!(\n-                            \"`dyn` call on a pointer whose vtable does not match its type\"\n-                        );\n+                        throw_ub_custom!(fluent::const_eval_dyn_call_vtable_mismatch);\n                     }\n \n                     // It might be surprising that we use a pointer as the receiver even if this\n@@ -623,7 +623,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Now determine the actual method to call. We can do that in two different ways and\n                 // compare them to ensure everything fits.\n                 let Some(ty::VtblEntry::Method(fn_inst)) = self.get_vtable_entries(vptr)?.get(idx).copied() else {\n-                    throw_ub_format!(\"`dyn` call trying to call something that is not a method\")\n+                    // FIXME(fee1-dead) these could be variants of the UB info enum instead of this\n+                    throw_ub_custom!(fluent::const_eval_dyn_call_not_a_method);\n                 };\n                 trace!(\"Virtual call dispatches to {fn_inst:#?}\");\n                 if cfg!(debug_assertions) {"}, {"sha": "21c655988a0e183e6615c67db9a7c1b0f8d89d12", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 95, "deletions": 122, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -4,15 +4,18 @@\n //! That's useful because it means other passes (e.g. promotion) can rely on `const`s\n //! to be const-safe.\n \n-use std::fmt::{Display, Write};\n+use std::fmt::Write;\n use std::num::NonZeroUsize;\n \n use either::{Left, Right};\n \n use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_middle::mir::interpret::InterpError;\n+use rustc_middle::mir::interpret::{\n+    ExpectedKind, InterpError, InvalidMetaKind, PointerKind, ValidationErrorInfo,\n+    ValidationErrorKind, ValidationErrorKind::*,\n+};\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_span::symbol::{sym, Symbol};\n@@ -30,14 +33,7 @@ use super::{\n };\n \n macro_rules! throw_validation_failure {\n-    ($where:expr, { $( $what_fmt:tt )* } $( expected { $( $expected_fmt:tt )* } )?) => {{\n-        let mut msg = String::new();\n-        msg.push_str(\"encountered \");\n-        write!(&mut msg, $($what_fmt)*).unwrap();\n-        $(\n-            msg.push_str(\", but expected \");\n-            write!(&mut msg, $($expected_fmt)*).unwrap();\n-        )?\n+    ($where:expr, $kind: expr) => {{\n         let where_ = &$where;\n         let path = if !where_.is_empty() {\n             let mut path = String::new();\n@@ -46,7 +42,8 @@ macro_rules! throw_validation_failure {\n         } else {\n             None\n         };\n-        throw_ub!(ValidationFailure { path, msg })\n+\n+        throw_ub!(Validation(ValidationErrorInfo { path, kind: $kind }))\n     }};\n }\n \n@@ -82,22 +79,22 @@ macro_rules! throw_validation_failure {\n ///\n macro_rules! try_validation {\n     ($e:expr, $where:expr,\n-    $( $( $p:pat_param )|+ => { $( $what_fmt:tt )* } $( expected { $( $expected_fmt:tt )* } )? ),+ $(,)?\n+    $( $( $p:pat_param )|+ => $kind: expr ),+ $(,)?\n     ) => {{\n         match $e {\n             Ok(x) => x,\n             // We catch the error and turn it into a validation failure. We are okay with\n             // allocation here as this can only slow down builds that fail anyway.\n-            Err(e) => match e.kind() {\n+            Err(e) => match e.into_parts() {\n                 $(\n-                    InterpError::UndefinedBehavior($($p)|+) =>\n+                    (InterpError::UndefinedBehavior($($p)|+), _) =>\n                        throw_validation_failure!(\n                             $where,\n-                            { $( $what_fmt )* } $( expected { $( $expected_fmt )* } )?\n+                            $kind\n                         )\n                 ),+,\n                 #[allow(unreachable_patterns)]\n-                _ => Err::<!, _>(e)?,\n+                (e, rest) => Err::<!, _>($crate::interpret::InterpErrorInfo::from_parts(e, rest))?,\n             }\n         }\n     }};\n@@ -160,6 +157,7 @@ impl<T: Copy + Eq + Hash + std::fmt::Debug, PATH: Default> RefTracking<T, PATH>\n     }\n }\n \n+// FIXME make this translatable as well?\n /// Format a path\n fn write_path(out: &mut String, path: &[PathElem]) {\n     use self::PathElem::*;\n@@ -185,26 +183,6 @@ fn write_path(out: &mut String, path: &[PathElem]) {\n     }\n }\n \n-// Formats such that a sentence like \"expected something {}\" to mean\n-// \"expected something <in the given range>\" makes sense.\n-fn wrapping_range_format(r: WrappingRange, max_hi: u128) -> String {\n-    let WrappingRange { start: lo, end: hi } = r;\n-    assert!(hi <= max_hi);\n-    if lo > hi {\n-        format!(\"less or equal to {}, or greater or equal to {}\", hi, lo)\n-    } else if lo == hi {\n-        format!(\"equal to {}\", lo)\n-    } else if lo == 0 {\n-        assert!(hi < max_hi, \"should not be printing if the range covers everything\");\n-        format!(\"less or equal to {}\", hi)\n-    } else if hi == max_hi {\n-        assert!(lo > 0, \"should not be printing if the range covers everything\");\n-        format!(\"greater or equal to {}\", lo)\n-    } else {\n-        format!(\"in the range {:?}\", r)\n-    }\n-}\n-\n struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// The `path` may be pushed to, but the part that is present when a function\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n@@ -311,19 +289,19 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn read_immediate(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n-        expected: impl Display,\n+        expected: ExpectedKind,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n         Ok(try_validation!(\n             self.ecx.read_immediate(op),\n             self.path,\n-            InvalidUninitBytes(None) => { \"uninitialized memory\" } expected { \"{expected}\" }\n+            InvalidUninitBytes(None) => Uninit { expected }\n         ))\n     }\n \n     fn read_scalar(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n-        expected: impl Display,\n+        expected: ExpectedKind,\n     ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n         Ok(self.read_immediate(op, expected)?.to_scalar())\n     }\n@@ -342,8 +320,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     self.ecx.get_ptr_vtable(vtable),\n                     self.path,\n                     DanglingIntPointer(..) |\n-                    InvalidVTablePointer(..) =>\n-                        { \"{vtable}\" } expected { \"a vtable pointer\" },\n+                    InvalidVTablePointer(..) => InvalidVTablePtr { value: format!(\"{vtable}\") }\n                 );\n                 // FIXME: check if the type/trait match what ty::Dynamic says?\n             }\n@@ -366,10 +343,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn check_safe_pointer(\n         &mut self,\n         value: &OpTy<'tcx, M::Provenance>,\n-        kind: &str,\n+        ptr_kind: PointerKind,\n     ) -> InterpResult<'tcx> {\n-        let place =\n-            self.ecx.ref_to_mplace(&self.read_immediate(value, format_args!(\"a {kind}\"))?)?;\n+        let place = self.ecx.ref_to_mplace(&self.read_immediate(value, ptr_kind.into())?)?;\n         // Handle wide pointers.\n         // Check metadata early, for better diagnostics\n         if place.layout.is_unsized() {\n@@ -379,7 +355,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let size_and_align = try_validation!(\n             self.ecx.size_and_align_of_mplace(&place),\n             self.path,\n-            InvalidMeta(msg) => { \"invalid {} metadata: {}\", kind, msg },\n+            InvalidMeta(msg) => match msg {\n+                InvalidMetaKind::SliceTooBig => InvalidMetaSliceTooLarge { ptr_kind },\n+                InvalidMetaKind::TooBig => InvalidMetaTooLarge { ptr_kind },\n+            }\n         );\n         let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n@@ -395,31 +374,30 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n             ),\n             self.path,\n-            AlignmentCheckFailed { required, has } =>\n-                {\n-                    \"an unaligned {kind} (required {} byte alignment but found {})\",\n-                    required.bytes(),\n-                    has.bytes(),\n-                },\n-            DanglingIntPointer(0, _) =>\n-                { \"a null {kind}\" },\n-            DanglingIntPointer(i, _) =>\n-                {\n-                    \"a dangling {kind} ({pointer} has no provenance)\",\n-                    pointer = Pointer::<Option<AllocId>>::from_addr_invalid(*i),\n-                },\n-            PointerOutOfBounds { .. } =>\n-                { \"a dangling {kind} (going beyond the bounds of its allocation)\" },\n+            AlignmentCheckFailed { required, has } => UnalignedPtr {\n+                ptr_kind,\n+                required_bytes: required.bytes(),\n+                found_bytes: has.bytes()\n+            },\n+            DanglingIntPointer(0, _) => NullPtr { ptr_kind },\n+            DanglingIntPointer(i, _) => DanglingPtrNoProvenance {\n+                ptr_kind,\n+                // FIXME this says \"null pointer\" when null but we need translate\n+                pointer: format!(\"{}\", Pointer::<Option<AllocId>>::from_addr_invalid(i))\n+            },\n+            PointerOutOfBounds { .. } => DanglingPtrOutOfBounds {\n+                ptr_kind\n+            },\n             // This cannot happen during const-eval (because interning already detects\n             // dangling pointers), but it can happen in Miri.\n-            PointerUseAfterFree(..) =>\n-                { \"a dangling {kind} (use-after-free)\" },\n+            PointerUseAfterFree(..) => DanglingPtrUseAfterFree {\n+                ptr_kind,\n+            },\n         );\n         // Do not allow pointers to uninhabited types.\n         if place.layout.abi.is_uninhabited() {\n-            throw_validation_failure!(self.path,\n-                { \"a {kind} pointing to uninhabited type {}\", place.layout.ty }\n-            )\n+            let ty = place.layout.ty;\n+            throw_validation_failure!(self.path, PtrToUninhabited { ptr_kind, ty })\n         }\n         // Recursive checking\n         if let Some(ref_tracking) = self.ref_tracking.as_deref_mut() {\n@@ -441,9 +419,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             // this check is so important.\n                             // This check is reachable when the const just referenced the static,\n                             // but never read it (so we never entered `before_access_global`).\n-                            throw_validation_failure!(self.path,\n-                                { \"a {} pointing to a static variable in a constant\", kind }\n-                            );\n+                            throw_validation_failure!(self.path, PtrToStatic { ptr_kind });\n                         }\n                         // We skip recursively checking other statics. These statics must be sound by\n                         // themselves, and the only way to get broken statics here is by using\n@@ -464,9 +440,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             // This should be unreachable, but if someone manages to copy a pointer\n                             // out of a `static`, then that pointer might point to mutable memory,\n                             // and we would catch that here.\n-                            throw_validation_failure!(self.path,\n-                                { \"a {} pointing to mutable memory in a constant\", kind }\n-                            );\n+                            throw_validation_failure!(self.path, PtrToMut { ptr_kind });\n                         }\n                     }\n                     // Nothing to check for these.\n@@ -496,22 +470,24 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let ty = value.layout.ty;\n         match ty.kind() {\n             ty::Bool => {\n-                let value = self.read_scalar(value, \"a boolean\")?;\n+                let value = self.read_scalar(value, ExpectedKind::Bool)?;\n                 try_validation!(\n                     value.to_bool(),\n                     self.path,\n-                    InvalidBool(..) =>\n-                        { \"{:x}\", value } expected { \"a boolean\" },\n+                    InvalidBool(..) => ValidationErrorKind::InvalidBool {\n+                        value: format!(\"{value:x}\"),\n+                    }\n                 );\n                 Ok(true)\n             }\n             ty::Char => {\n-                let value = self.read_scalar(value, \"a unicode scalar value\")?;\n+                let value = self.read_scalar(value, ExpectedKind::Char)?;\n                 try_validation!(\n                     value.to_char(),\n                     self.path,\n-                    InvalidChar(..) =>\n-                        { \"{:x}\", value } expected { \"a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\" },\n+                    InvalidChar(..) => ValidationErrorKind::InvalidChar {\n+                        value: format!(\"{value:x}\"),\n+                    }\n                 );\n                 Ok(true)\n             }\n@@ -521,16 +497,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let value = self.read_scalar(\n                     value,\n                     if matches!(ty.kind(), ty::Float(..)) {\n-                        \"a floating point number\"\n+                        ExpectedKind::Float\n                     } else {\n-                        \"an integer\"\n+                        ExpectedKind::Int\n                     },\n                 )?;\n                 // As a special exception we *do* match on a `Scalar` here, since we truly want\n                 // to know its underlying representation (and *not* cast it to an integer).\n                 if matches!(value, Scalar::Ptr(..)) {\n-                    throw_validation_failure!(self.path,\n-                        { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n+                    throw_validation_failure!(\n+                        self.path,\n+                        ExpectedNonPtr { value: format!(\"{value:x}\") }\n                     )\n                 }\n                 Ok(true)\n@@ -540,7 +517,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n                 let place =\n-                    self.ecx.ref_to_mplace(&self.read_immediate(value, \"a raw pointer\")?)?;\n+                    self.ecx.ref_to_mplace(&self.read_immediate(value, ExpectedKind::RawPtr)?)?;\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n@@ -554,14 +531,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // a ZST).\n                     let layout = self.ecx.layout_of(*ty)?;\n                     if !layout.is_zst() {\n-                        throw_validation_failure!(self.path, { \"mutable reference in a `const`\" });\n+                        throw_validation_failure!(self.path, MutableRefInConst);\n                     }\n                 }\n-                self.check_safe_pointer(value, \"reference\")?;\n+                self.check_safe_pointer(value, PointerKind::Ref)?;\n                 Ok(true)\n             }\n             ty::FnPtr(_sig) => {\n-                let value = self.read_scalar(value, \"a function pointer\")?;\n+                let value = self.read_scalar(value, ExpectedKind::FnPtr)?;\n \n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n@@ -570,19 +547,20 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n                         DanglingIntPointer(..) |\n-                        InvalidFunctionPointer(..) =>\n-                            { \"{ptr}\" } expected { \"a function pointer\" },\n+                        InvalidFunctionPointer(..) => InvalidFnPtr {\n+                            value: format!(\"{ptr}\"),\n+                        },\n                     );\n                     // FIXME: Check if the signature matches\n                 } else {\n                     // Otherwise (for standalone Miri), we have to still check it to be non-null.\n                     if self.ecx.scalar_may_be_null(value)? {\n-                        throw_validation_failure!(self.path, { \"a null function pointer\" });\n+                        throw_validation_failure!(self.path, NullFnPtr);\n                     }\n                 }\n                 Ok(true)\n             }\n-            ty::Never => throw_validation_failure!(self.path, { \"a value of the never type `!`\" }),\n+            ty::Never => throw_validation_failure!(self.path, NeverVal),\n             ty::Foreign(..) | ty::FnDef(..) => {\n                 // Nothing to check.\n                 Ok(true)\n@@ -629,12 +607,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 if start == 1 && end == max_value {\n                     // Only null is the niche. So make sure the ptr is NOT null.\n                     if self.ecx.scalar_may_be_null(scalar)? {\n-                        throw_validation_failure!(self.path,\n-                            { \"a potentially null pointer\" }\n-                            expected {\n-                                \"something that cannot possibly fail to be {}\",\n-                                wrapping_range_format(valid_range, max_value)\n-                            }\n+                        throw_validation_failure!(\n+                            self.path,\n+                            NullablePtrOutOfRange { range: valid_range, max_value }\n                         )\n                     } else {\n                         return Ok(());\n@@ -645,12 +620,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n-                    throw_validation_failure!(self.path,\n-                        { \"a pointer\" }\n-                        expected {\n-                            \"something that cannot possibly fail to be {}\",\n-                            wrapping_range_format(valid_range, max_value)\n-                        }\n+                    throw_validation_failure!(\n+                        self.path,\n+                        PtrOutOfRange { range: valid_range, max_value }\n                     )\n                 }\n             }\n@@ -659,9 +631,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if valid_range.contains(bits) {\n             Ok(())\n         } else {\n-            throw_validation_failure!(self.path,\n-                { \"{}\", bits }\n-                expected { \"something {}\", wrapping_range_format(valid_range, max_value) }\n+            throw_validation_failure!(\n+                self.path,\n+                OutOfRange { value: format!(\"{bits}\"), range: valid_range, max_value }\n             )\n         }\n     }\n@@ -685,10 +657,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             Ok(try_validation!(\n                 this.ecx.read_discriminant(op),\n                 this.path,\n-                InvalidTag(val) =>\n-                    { \"{:x}\", val } expected { \"a valid enum tag\" },\n-                InvalidUninitBytes(None) =>\n-                    { \"uninitialized bytes\" } expected { \"a valid enum tag\" },\n+                InvalidTag(val) => InvalidEnumTag {\n+                    value: format!(\"{val:x}\"),\n+                },\n+\n+                InvalidUninitBytes(None) => UninitEnumTag,\n             )\n             .1)\n         })\n@@ -730,15 +703,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Special check preventing `UnsafeCell` inside unions in the inner part of constants.\n         if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. })) {\n             if !op.layout.ty.is_freeze(*self.ecx.tcx, self.ecx.param_env) {\n-                throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n+                throw_validation_failure!(self.path, UnsafeCell);\n             }\n         }\n         Ok(())\n     }\n \n     #[inline]\n     fn visit_box(&mut self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n-        self.check_safe_pointer(op, \"box\")?;\n+        self.check_safe_pointer(op, PointerKind::Box)?;\n         Ok(())\n     }\n \n@@ -756,7 +729,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. }))\n                 && def.is_unsafe_cell()\n             {\n-                throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n+                throw_validation_failure!(self.path, UnsafeCell);\n             }\n         }\n \n@@ -775,14 +748,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // MyNewtype and then the scalar in there).\n         match op.layout.abi {\n             Abi::Uninhabited => {\n-                throw_validation_failure!(self.path,\n-                    { \"a value of uninhabited type {:?}\", op.layout.ty }\n-                );\n+                let ty = op.layout.ty;\n+                throw_validation_failure!(self.path, UninhabitedVal { ty });\n             }\n             Abi::Scalar(scalar_layout) => {\n                 if !scalar_layout.is_uninit_valid() {\n                     // There is something to check here.\n-                    let scalar = self.read_scalar(op, \"initialized scalar value\")?;\n+                    let scalar = self.read_scalar(op, ExpectedKind::InitScalar)?;\n                     self.visit_scalar(scalar, scalar_layout)?;\n                 }\n             }\n@@ -792,7 +764,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // the other must be init.\n                 if !a_layout.is_uninit_valid() && !b_layout.is_uninit_valid() {\n                     let (a, b) =\n-                        self.read_immediate(op, \"initialized scalar value\")?.to_scalar_pair();\n+                        self.read_immediate(op, ExpectedKind::InitScalar)?.to_scalar_pair();\n                     self.visit_scalar(a, a_layout)?;\n                     self.visit_scalar(b, b_layout)?;\n                 }\n@@ -822,7 +794,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 try_validation!(\n                     self.ecx.read_bytes_ptr_strip_provenance(mplace.ptr, Size::from_bytes(len)),\n                     self.path,\n-                    InvalidUninitBytes(..) => { \"uninitialized data in `str`\" },\n+                    InvalidUninitBytes(..) => { UninitStr },\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n@@ -852,7 +824,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Left(mplace) => mplace,\n                     Right(imm) => match *imm {\n                         Immediate::Uninit =>\n-                            throw_validation_failure!(self.path, { \"uninitialized bytes\" }),\n+                            throw_validation_failure!(self.path, UninitVal),\n                         Immediate::Scalar(..) | Immediate::ScalarPair(..) =>\n                             bug!(\"arrays/slices can never have Scalar/ScalarPair layout\"),\n                     }\n@@ -888,7 +860,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                 .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));\n \n-                                throw_validation_failure!(self.path, { \"uninitialized bytes\" })\n+                                throw_validation_failure!(self.path, UninitVal)\n                             }\n \n                             // Propagate upwards (that will also check for unexpected errors).\n@@ -929,12 +901,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match visitor.visit_value(&op) {\n             Ok(()) => Ok(()),\n             // Pass through validation failures.\n-            Err(err) if matches!(err.kind(), err_ub!(ValidationFailure { .. })) => Err(err),\n+            Err(err) if matches!(err.kind(), err_ub!(Validation { .. })) => Err(err),\n             // Complain about any other kind of UB error -- those are bad because we'd like to\n             // report them in a way that shows *where* in the value the issue lies.\n             Err(err) if matches!(err.kind(), InterpError::UndefinedBehavior(_)) => {\n-                err.print_backtrace();\n-                bug!(\"Unexpected Undefined Behavior error during validation: {}\", err);\n+                let (err, backtrace) = err.into_parts();\n+                backtrace.print_backtrace();\n+                bug!(\"Unexpected Undefined Behavior error during validation: {err:?}\");\n             }\n             // Pass through everything else.\n             Err(err) => Err(err),"}, {"sha": "8314f53ba57bb5d49f3d941c1563fac38fa9de12", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -4,6 +4,7 @@ Rust MIR: a lowered representation of Rust.\n \n */\n \n+#![deny(rustc::untranslatable_diagnostic)]\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(decl_macro)]\n@@ -33,6 +34,8 @@ pub mod interpret;\n pub mod transform;\n pub mod util;\n \n+pub use errors::ReportErrorExt;\n+\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_fluent_macro::fluent_messages;\n use rustc_middle::query::Providers;"}, {"sha": "236e43bdfcc71bc12f558f7b7d6285bee2e9789d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 54, "deletions": 79, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -2,9 +2,7 @@\n \n use hir::def_id::LocalDefId;\n use hir::{ConstContext, LangItem};\n-use rustc_errors::{\n-    error_code, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed,\n-};\n+use rustc_errors::{error_code, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -152,7 +150,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n \n                     if let Ok(Some(ImplSource::UserDefined(data))) = implsrc {\n                         let span = tcx.def_span(data.impl_def_id);\n-                        err.span_note(span, \"impl defined here, but it is not `const`\");\n+                        err.subdiagnostic(errors::NonConstImplNote { span });\n                     }\n                 }\n                 _ => {}\n@@ -166,76 +164,62 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n         let mut err = match call_kind {\n             CallKind::Normal { desugaring: Some((kind, self_ty)), .. } => {\n                 macro_rules! error {\n-                    ($fmt:literal) => {\n-                        struct_span_err!(tcx.sess, span, E0015, $fmt, self_ty, ccx.const_kind())\n+                    ($err:ident) => {\n+                        tcx.sess.create_err(errors::$err {\n+                            span,\n+                            ty: self_ty,\n+                            kind: ccx.const_kind(),\n+                        })\n                     };\n                 }\n \n                 let mut err = match kind {\n                     CallDesugaringKind::ForLoopIntoIter => {\n-                        error!(\"cannot convert `{}` into an iterator in {}s\")\n+                        error!(NonConstForLoopIntoIter)\n                     }\n                     CallDesugaringKind::QuestionBranch => {\n-                        error!(\"`?` cannot determine the branch of `{}` in {}s\")\n+                        error!(NonConstQuestionBranch)\n                     }\n                     CallDesugaringKind::QuestionFromResidual => {\n-                        error!(\"`?` cannot convert from residual of `{}` in {}s\")\n+                        error!(NonConstQuestionFromResidual)\n                     }\n                     CallDesugaringKind::TryBlockFromOutput => {\n-                        error!(\"`try` block cannot convert `{}` to the result in {}s\")\n+                        error!(NonConstTryBlockFromOutput)\n                     }\n                     CallDesugaringKind::Await => {\n-                        error!(\"cannot convert `{}` into a future in {}s\")\n+                        error!(NonConstAwait)\n                     }\n                 };\n \n                 diag_trait(&mut err, self_ty, kind.trait_def_id(tcx));\n                 err\n             }\n             CallKind::FnCall { fn_trait_id, self_ty } => {\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot call non-const closure in {}s\",\n-                    ccx.const_kind(),\n-                );\n-\n-                match self_ty.kind() {\n+                let note = match self_ty.kind() {\n                     FnDef(def_id, ..) => {\n                         let span = tcx.def_span(*def_id);\n                         if ccx.tcx.is_const_fn_raw(*def_id) {\n                             span_bug!(span, \"calling const FnDef errored when it shouldn't\");\n                         }\n \n-                        err.span_note(span, \"function defined here, but it is not `const`\");\n-                    }\n-                    FnPtr(..) => {\n-                        err.note(format!(\n-                            \"function pointers need an RFC before allowed to be called in {}s\",\n-                            ccx.const_kind()\n-                        ));\n+                        Some(errors::NonConstClosureNote::FnDef { span })\n                     }\n-                    Closure(..) => {\n-                        err.note(format!(\n-                            \"closures need an RFC before allowed to be called in {}s\",\n-                            ccx.const_kind()\n-                        ));\n-                    }\n-                    _ => {}\n-                }\n+                    FnPtr(..) => Some(errors::NonConstClosureNote::FnPtr),\n+                    Closure(..) => Some(errors::NonConstClosureNote::Closure),\n+                    _ => None,\n+                };\n+\n+                let mut err = tcx.sess.create_err(errors::NonConstClosure {\n+                    span,\n+                    kind: ccx.const_kind(),\n+                    note,\n+                });\n \n                 diag_trait(&mut err, self_ty, fn_trait_id);\n                 err\n             }\n             CallKind::Operator { trait_id, self_ty, .. } => {\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot call non-const operator in {}s\",\n-                    ccx.const_kind()\n-                );\n+                let mut sugg = None;\n \n                 if Some(trait_id) == ccx.tcx.lang_items().eq_trait() {\n                     match (substs[0].unpack(), substs[1].unpack()) {\n@@ -260,41 +244,41 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                                         let rhs_pos =\n                                             span.lo() + BytePos::from_usize(eq_idx + 2 + rhs_idx);\n                                         let rhs_span = span.with_lo(rhs_pos).with_hi(rhs_pos);\n-                                        err.multipart_suggestion(\n-                                            \"consider dereferencing here\",\n-                                            vec![\n-                                                (span.shrink_to_lo(), deref.clone()),\n-                                                (rhs_span, deref),\n-                                            ],\n-                                            Applicability::MachineApplicable,\n-                                        );\n+                                        sugg = Some(errors::ConsiderDereferencing {\n+                                            deref,\n+                                            span: span.shrink_to_lo(),\n+                                            rhs_span,\n+                                        });\n                                     }\n                                 }\n                             }\n                         }\n                         _ => {}\n                     }\n                 }\n-\n+                let mut err = tcx.sess.create_err(errors::NonConstOperator {\n+                    span,\n+                    kind: ccx.const_kind(),\n+                    sugg,\n+                });\n                 diag_trait(&mut err, self_ty, trait_id);\n                 err\n             }\n             CallKind::DerefCoercion { deref_target, deref_target_ty, self_ty } => {\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot perform deref coercion on `{}` in {}s\",\n-                    self_ty,\n-                    ccx.const_kind()\n-                );\n-\n-                err.note(format!(\"attempting to deref into `{}`\", deref_target_ty));\n-\n                 // Check first whether the source is accessible (issue #87060)\n-                if tcx.sess.source_map().is_span_accessible(deref_target) {\n-                    err.span_note(deref_target, \"deref defined here\");\n-                }\n+                let target = if tcx.sess.source_map().is_span_accessible(deref_target) {\n+                    Some(deref_target)\n+                } else {\n+                    None\n+                };\n+\n+                let mut err = tcx.sess.create_err(errors::NonConstDerefCoercion {\n+                    span,\n+                    ty: self_ty,\n+                    kind: ccx.const_kind(),\n+                    target_ty: deref_target_ty,\n+                    deref_target: target,\n+                });\n \n                 diag_trait(&mut err, self_ty, tcx.require_lang_item(LangItem::Deref, Some(span)));\n                 err\n@@ -432,21 +416,12 @@ impl<'tcx> NonConstOp<'tcx> for LiveDrop<'tcx> {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0493,\n-            \"destructor of `{}` cannot be evaluated at compile-time\",\n-            self.dropped_ty,\n-        );\n-        err.span_label(\n+        ccx.tcx.sess.create_err(errors::LiveDrop {\n             span,\n-            format!(\"the destructor for this type cannot be evaluated in {}s\", ccx.const_kind()),\n-        );\n-        if let Some(span) = self.dropped_at {\n-            err.span_label(span, \"value is dropped here\");\n-        }\n-        err\n+            dropped_ty: self.dropped_ty,\n+            kind: ccx.const_kind(),\n+            dropped_at: self.dropped_at,\n+        })\n     }\n }\n "}, {"sha": "f3ee83fd4d218e4c38e6e8ae21a0f2ebe5470135", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -492,6 +492,10 @@ impl MultiSpan {\n         replacements_occurred\n     }\n \n+    pub fn pop_span_label(&mut self) -> Option<(Span, DiagnosticMessage)> {\n+        self.span_labels.pop()\n+    }\n+\n     /// Returns the strings to highlight. We always ensure that there\n     /// is an entry for each of the primary spans -- for each primary\n     /// span `P`, if there is at least one label with span `P`, we return"}, {"sha": "8e8223c3cf8aac8fd5f09f50bb440cd0761fc051", "filename": "compiler/rustc_errors/messages.ftl", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_errors%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_errors%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fmessages.ftl?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -8,7 +8,11 @@ errors_target_invalid_address_space =\n     invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n \n errors_target_invalid_alignment =\n-    invalid alignment for `{$cause}` in \"data-layout\": {$err}\n+    invalid alignment for `{$cause}` in \"data-layout\": `{$align}` is {$err_kind ->\n+        [not_power_of_two] not a power of 2\n+        [too_large] too large\n+        *[other] {\"\"}\n+    }\n \n errors_target_invalid_bits =\n     invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}"}, {"sha": "ed0d06ed0ff77997434f6980801543d8dd98bdcf", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -10,7 +10,7 @@ use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n-use std::fmt;\n+use std::fmt::{self, Debug};\n use std::hash::{Hash, Hasher};\n use std::panic::Location;\n \n@@ -33,7 +33,7 @@ pub type DiagnosticArgName<'source> = Cow<'source, str>;\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub enum DiagnosticArgValue<'source> {\n     Str(Cow<'source, str>),\n-    Number(usize),\n+    Number(i128),\n     StrListSepByAnd(Vec<Cow<'source, str>>),\n }\n "}, {"sha": "10fe7fc74a873be7a10dc88eefc6f02442ec2709", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -60,10 +60,8 @@ into_diagnostic_arg_using_display!(\n     u8,\n     i16,\n     u16,\n-    i32,\n     u32,\n     i64,\n-    u64,\n     i128,\n     u128,\n     std::io::Error,\n@@ -80,6 +78,18 @@ into_diagnostic_arg_using_display!(\n     ExitStatus,\n );\n \n+impl IntoDiagnosticArg for i32 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Number(self.into())\n+    }\n+}\n+\n+impl IntoDiagnosticArg for u64 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Number(self.into())\n+    }\n+}\n+\n impl IntoDiagnosticArg for bool {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         if self {\n@@ -134,7 +144,7 @@ impl IntoDiagnosticArg for PathBuf {\n \n impl IntoDiagnosticArg for usize {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Number(self)\n+        DiagnosticArgValue::Number(self as i128)\n     }\n }\n \n@@ -147,9 +157,9 @@ impl IntoDiagnosticArg for PanicStrategy {\n impl IntoDiagnosticArg for hir::ConstContext {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Borrowed(match self {\n-            hir::ConstContext::ConstFn => \"constant function\",\n+            hir::ConstContext::ConstFn => \"const_fn\",\n             hir::ConstContext::Static(_) => \"static\",\n-            hir::ConstContext::Const => \"constant\",\n+            hir::ConstContext::Const => \"const\",\n         }))\n     }\n }\n@@ -254,7 +264,8 @@ impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n             TargetDataLayoutErrors::InvalidAlignment { cause, err } => {\n                 diag = handler.struct_fatal(fluent::errors_target_invalid_alignment);\n                 diag.set_arg(\"cause\", cause);\n-                diag.set_arg(\"err\", err);\n+                diag.set_arg(\"err_kind\", err.diag_ident());\n+                diag.set_arg(\"align\", err.align());\n                 diag\n             }\n             TargetDataLayoutErrors::InconsistentTargetArchitecture { dl, target } => {"}, {"sha": "89f96695a2f6913609702a3529e282d006881d70", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -177,7 +177,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         }\n         // Generic statics are rejected, but we still reach this case.\n         Err(e) => {\n-            tcx.sess.delay_span_bug(span, e.to_string());\n+            tcx.sess.delay_span_bug(span, format!(\"{e:?}\"));\n             return;\n         }\n     };"}, {"sha": "2e6e84ad80eb458a7e7ded5a9f199be396e3fcdd", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -14,6 +14,8 @@ use syn::Token;\n use syn::{parse_quote, spanned::Spanned, Attribute, Meta, Path, Type};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n+use super::utils::SubdiagnosticVariant;\n+\n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n #[derive(Clone, PartialEq, Eq)]\n pub(crate) enum DiagnosticDeriveKind {\n@@ -150,19 +152,19 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n     fn parse_subdiag_attribute(\n         &self,\n         attr: &Attribute,\n-    ) -> Result<Option<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n-        let Some((subdiag, slug)) = SubdiagnosticKind::from_attr(attr, self)? else {\n+    ) -> Result<Option<(SubdiagnosticKind, Path, bool)>, DiagnosticDeriveError> {\n+        let Some(subdiag) = SubdiagnosticVariant::from_attr(attr, self)? else {\n             // Some attributes aren't errors - like documentation comments - but also aren't\n             // subdiagnostics.\n             return Ok(None);\n         };\n \n-        if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag {\n+        if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag.kind {\n             throw_invalid_attr!(attr, |diag| diag\n                 .help(\"consider creating a `Subdiagnostic` instead\"));\n         }\n \n-        let slug = slug.unwrap_or_else(|| match subdiag {\n+        let slug = subdiag.slug.unwrap_or_else(|| match subdiag.kind {\n             SubdiagnosticKind::Label => parse_quote! { _subdiag::label },\n             SubdiagnosticKind::Note => parse_quote! { _subdiag::note },\n             SubdiagnosticKind::Help => parse_quote! { _subdiag::help },\n@@ -171,7 +173,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n         });\n \n-        Ok(Some((subdiag, slug)))\n+        Ok(Some((subdiag.kind, slug, subdiag.no_span)))\n     }\n \n     /// Establishes state in the `DiagnosticDeriveBuilder` resulting from the struct\n@@ -229,7 +231,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             return Ok(tokens);\n         }\n \n-        let Some((subdiag, slug)) = self.parse_subdiag_attribute(attr)? else {\n+        let Some((subdiag, slug, _no_span)) = self.parse_subdiag_attribute(attr)? else {\n             // Some attributes aren't errors - like documentation comments - but also aren't\n             // subdiagnostics.\n             return Ok(quote! {});\n@@ -380,7 +382,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             _ => (),\n         }\n \n-        let Some((subdiag, slug)) = self.parse_subdiag_attribute(attr)? else {\n+        let Some((subdiag, slug, _no_span)) = self.parse_subdiag_attribute(attr)? else {\n             // Some attributes aren't errors - like documentation comments - but also aren't\n             // subdiagnostics.\n             return Ok(quote! {});"}, {"sha": "e3d9eb96574d10a3f2367612648e52e7e3a99143", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -14,6 +14,8 @@ use quote::{format_ident, quote};\n use syn::{spanned::Spanned, Attribute, Meta, MetaList, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n+use super::utils::SubdiagnosticVariant;\n+\n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n pub(crate) struct SubdiagnosticDeriveBuilder {\n     diag: syn::Ident,\n@@ -180,11 +182,13 @@ impl<'a> FromIterator<&'a SubdiagnosticKind> for KindsStatistics {\n }\n \n impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n-    fn identify_kind(&mut self) -> Result<Vec<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n+    fn identify_kind(\n+        &mut self,\n+    ) -> Result<Vec<(SubdiagnosticKind, Path, bool)>, DiagnosticDeriveError> {\n         let mut kind_slugs = vec![];\n \n         for attr in self.variant.ast().attrs {\n-            let Some((kind, slug)) = SubdiagnosticKind::from_attr(attr, self)? else {\n+            let Some(SubdiagnosticVariant { kind, slug, no_span }) = SubdiagnosticVariant::from_attr(attr, self)? else {\n                 // Some attributes aren't errors - like documentation comments - but also aren't\n                 // subdiagnostics.\n                 continue;\n@@ -202,7 +206,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 );\n             };\n \n-            kind_slugs.push((kind, slug));\n+            kind_slugs.push((kind, slug, no_span));\n         }\n \n         Ok(kind_slugs)\n@@ -487,7 +491,8 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             }\n         };\n \n-        let kind_stats: KindsStatistics = kind_slugs.iter().map(|(kind, _slug)| kind).collect();\n+        let kind_stats: KindsStatistics =\n+            kind_slugs.iter().map(|(kind, _slug, _no_span)| kind).collect();\n \n         let init = if kind_stats.has_multipart_suggestion {\n             quote! { let mut suggestions = Vec::new(); }\n@@ -508,13 +513,17 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         let diag = &self.parent.diag;\n         let f = &self.parent.f;\n         let mut calls = TokenStream::new();\n-        for (kind, slug) in kind_slugs {\n+        for (kind, slug, no_span) in kind_slugs {\n             let message = format_ident!(\"__message\");\n             calls.extend(\n                 quote! { let #message = #f(#diag, crate::fluent_generated::#slug.into()); },\n             );\n \n-            let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n+            let name = format_ident!(\n+                \"{}{}\",\n+                if span_field.is_some() && !no_span { \"span_\" } else { \"\" },\n+                kind\n+            );\n             let call = match kind {\n                 SubdiagnosticKind::Suggestion {\n                     suggestion_kind,\n@@ -566,7 +575,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     }\n                 }\n                 _ => {\n-                    if let Some(span) = span_field {\n+                    if let Some(span) = span_field && !no_span {\n                         quote! { #diag.#name(#span, #message); }\n                     } else {\n                         quote! { #diag.#name(#message); }"}, {"sha": "85dd9f6a3ce3670974da25e49f658c63ff68f85b", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -597,14 +597,20 @@ pub(super) enum SubdiagnosticKind {\n     },\n }\n \n-impl SubdiagnosticKind {\n-    /// Constructs a `SubdiagnosticKind` from a field or type attribute such as `#[note]`,\n-    /// `#[error(parser::add_paren)]` or `#[suggestion(code = \"...\")]`. Returns the\n+pub(super) struct SubdiagnosticVariant {\n+    pub(super) kind: SubdiagnosticKind,\n+    pub(super) slug: Option<Path>,\n+    pub(super) no_span: bool,\n+}\n+\n+impl SubdiagnosticVariant {\n+    /// Constructs a `SubdiagnosticVariant` from a field or type attribute such as `#[note]`,\n+    /// `#[error(parser::add_paren, no_span)]` or `#[suggestion(code = \"...\")]`. Returns the\n     /// `SubdiagnosticKind` and the diagnostic slug, if specified.\n     pub(super) fn from_attr(\n         attr: &Attribute,\n         fields: &impl HasFieldMap,\n-    ) -> Result<Option<(SubdiagnosticKind, Option<Path>)>, DiagnosticDeriveError> {\n+    ) -> Result<Option<SubdiagnosticVariant>, DiagnosticDeriveError> {\n         // Always allow documentation comments.\n         if is_doc_comment(attr) {\n             return Ok(None);\n@@ -679,7 +685,7 @@ impl SubdiagnosticKind {\n                     | SubdiagnosticKind::Help\n                     | SubdiagnosticKind::Warn\n                     | SubdiagnosticKind::MultipartSuggestion { .. } => {\n-                        return Ok(Some((kind, None)));\n+                        return Ok(Some(SubdiagnosticVariant { kind, slug: None, no_span: false }));\n                     }\n                     SubdiagnosticKind::Suggestion { .. } => {\n                         throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\")\n@@ -696,11 +702,14 @@ impl SubdiagnosticKind {\n \n         let mut first = true;\n         let mut slug = None;\n+        let mut no_span = false;\n \n         list.parse_nested_meta(|nested| {\n             if nested.input.is_empty() || nested.input.peek(Token![,]) {\n                 if first {\n                     slug = Some(nested.path);\n+                } else if nested.path.is_ident(\"no_span\") {\n+                    no_span = true;\n                 } else {\n                     span_err(nested.input.span().unwrap(), \"a diagnostic slug must be the first argument to the attribute\").emit();\n                 }\n@@ -775,19 +784,19 @@ impl SubdiagnosticKind {\n                 (_, SubdiagnosticKind::Suggestion { .. }) => {\n                     span_err(path_span, \"invalid nested attribute\")\n                         .help(\n-                            \"only `style`, `code` and `applicability` are valid nested attributes\",\n+                            \"only `no_span`, `style`, `code` and `applicability` are valid nested attributes\",\n                         )\n                         .emit();\n                     has_errors = true;\n                 }\n                 (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n                     span_err(path_span, \"invalid nested attribute\")\n-                        .help(\"only `style` and `applicability` are valid nested attributes\")\n+                        .help(\"only `no_span`, `style` and `applicability` are valid nested attributes\")\n                         .emit();\n                     has_errors = true;\n                 }\n                 _ => {\n-                    span_err(path_span, \"invalid nested attribute\").emit();\n+                    span_err(path_span, \"only `no_span` is a valid nested attribute\").emit();\n                     has_errors = true;\n                 }\n             }\n@@ -831,7 +840,7 @@ impl SubdiagnosticKind {\n             | SubdiagnosticKind::Warn => {}\n         }\n \n-        Ok(Some((kind, slug)))\n+        Ok(Some(SubdiagnosticVariant { kind, slug, no_span }))\n     }\n }\n "}, {"sha": "bb7147ac80fbe2e5a8f9df80e2ef183dd761e83c", "filename": "compiler/rustc_middle/messages.ftl", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fmessages.ftl?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,3 +1,38 @@\n+middle_adjust_for_foreign_abi_error =\n+    target architecture {$arch} does not support `extern {$abi}` ABI\n+\n+middle_assert_async_resume_after_panic = `async fn` resumed after panicking\n+\n+middle_assert_async_resume_after_return = `async fn` resumed after completion\n+\n+middle_assert_divide_by_zero =\n+    attempt to divide `{$val}` by zero\n+\n+middle_assert_generator_resume_after_panic = generator resumed after panicking\n+\n+middle_assert_generator_resume_after_return = generator resumed after completion\n+\n+middle_assert_misaligned_ptr_deref =\n+    misaligned pointer dereference: address must be a multiple of {$required} but is {$found}\n+\n+middle_assert_op_overflow =\n+    attempt to compute `{$left} {$op} {$right}`, which would overflow\n+\n+middle_assert_overflow_neg =\n+    attempt to negate `{$val}`, which would overflow\n+\n+middle_assert_remainder_by_zero =\n+    attempt to calculate the remainder of `{$val}` with a divisor of zero\n+\n+middle_assert_shl_overflow =\n+    attempt to shift left by `{$val}`, which would overflow\n+\n+middle_assert_shr_overflow =\n+    attempt to shift right by `{$val}`, which would overflow\n+\n+middle_bounds_check =\n+    index out of bounds: the length is {$len} but the index is {$index}\n+\n middle_cannot_be_normalized =\n     unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized\n "}, {"sha": "57b2de84b47f7cbf51ebdf0f5f814739166d9e2c", "filename": "compiler/rustc_middle/src/error.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ferror.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,3 +1,7 @@\n+use std::borrow::Cow;\n+use std::fmt;\n+\n+use rustc_errors::{DiagnosticArgValue, DiagnosticMessage};\n use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n \n@@ -88,3 +92,54 @@ pub(super) struct ConstNotUsedTraitAlias {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+pub struct CustomSubdiagnostic<'a> {\n+    pub msg: fn() -> DiagnosticMessage,\n+    pub add_args:\n+        Box<dyn FnOnce(&mut dyn FnMut(Cow<'static, str>, DiagnosticArgValue<'static>)) + 'a>,\n+}\n+\n+impl<'a> CustomSubdiagnostic<'a> {\n+    pub fn label(x: fn() -> DiagnosticMessage) -> Self {\n+        Self::label_and_then(x, |_| {})\n+    }\n+    pub fn label_and_then<\n+        F: FnOnce(&mut dyn FnMut(Cow<'static, str>, DiagnosticArgValue<'static>)) + 'a,\n+    >(\n+        msg: fn() -> DiagnosticMessage,\n+        f: F,\n+    ) -> Self {\n+        Self { msg, add_args: Box::new(move |x| f(x)) }\n+    }\n+}\n+\n+impl fmt::Debug for CustomSubdiagnostic<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"CustomSubdiagnostic\").finish_non_exhaustive()\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum LayoutError<'tcx> {\n+    #[diag(middle_unknown_layout)]\n+    Unknown { ty: Ty<'tcx> },\n+\n+    #[diag(middle_values_too_big)]\n+    Overflow { ty: Ty<'tcx> },\n+\n+    #[diag(middle_cannot_be_normalized)]\n+    NormalizationFailure { ty: Ty<'tcx>, failure_ty: String },\n+\n+    #[diag(middle_cycle)]\n+    Cycle,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(middle_adjust_for_foreign_abi_error)]\n+pub struct UnsupportedFnAbi {\n+    pub arch: Symbol,\n+    pub abi: &'static str,\n+}\n+\n+/// Used by `rustc_const_eval`\n+pub use crate::fluent_generated::middle_adjust_for_foreign_abi_error;"}, {"sha": "0d6c2eba06c89dff45beec224592fa4984d77f4c", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -48,6 +48,7 @@\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(control_flow_enum)]\n+#![feature(trait_upcasting)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![feature(try_reserve_kind)]\n@@ -86,7 +87,7 @@ mod macros;\n \n #[macro_use]\n pub mod arena;\n-pub(crate) mod error;\n+pub mod error;\n pub mod hir;\n pub mod infer;\n pub mod lint;"}, {"sha": "b8030d9db13c5588ac820b5f6fca124fe5b2fd03", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -296,25 +296,13 @@ impl<Prov: Provenance, Bytes: AllocBytes> Allocation<Prov, (), Bytes> {\n         Allocation::from_bytes(slice, Align::ONE, Mutability::Not)\n     }\n \n-    /// Try to create an Allocation of `size` bytes, failing if there is not enough memory\n-    /// available to the compiler to do so.\n-    ///\n-    /// If `panic_on_fail` is true, this will never return `Err`.\n-    pub fn uninit<'tcx>(size: Size, align: Align, panic_on_fail: bool) -> InterpResult<'tcx, Self> {\n-        let bytes = Bytes::zeroed(size, align).ok_or_else(|| {\n-            // This results in an error that can happen non-deterministically, since the memory\n-            // available to the compiler can change between runs. Normally queries are always\n-            // deterministic. However, we can be non-deterministic here because all uses of const\n-            // evaluation (including ConstProp!) will make compilation fail (via hard error\n-            // or ICE) upon encountering a `MemoryExhausted` error.\n-            if panic_on_fail {\n-                panic!(\"Allocation::uninit called with panic_on_fail had allocation failure\")\n-            }\n-            ty::tls::with(|tcx| {\n-                tcx.sess.delay_span_bug(DUMMY_SP, \"exhausted memory during interpretation\")\n-            });\n-            InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted)\n-        })?;\n+    fn uninit_inner<R>(size: Size, align: Align, fail: impl FnOnce() -> R) -> Result<Self, R> {\n+        // This results in an error that can happen non-deterministically, since the memory\n+        // available to the compiler can change between runs. Normally queries are always\n+        // deterministic. However, we can be non-deterministic here because all uses of const\n+        // evaluation (including ConstProp!) will make compilation fail (via hard error\n+        // or ICE) upon encountering a `MemoryExhausted` error.\n+        let bytes = Bytes::zeroed(size, align).ok_or_else(fail)?;\n \n         Ok(Allocation {\n             bytes,\n@@ -325,6 +313,28 @@ impl<Prov: Provenance, Bytes: AllocBytes> Allocation<Prov, (), Bytes> {\n             extra: (),\n         })\n     }\n+\n+    /// Try to create an Allocation of `size` bytes, failing if there is not enough memory\n+    /// available to the compiler to do so.\n+    pub fn try_uninit<'tcx>(size: Size, align: Align) -> InterpResult<'tcx, Self> {\n+        Self::uninit_inner(size, align, || {\n+            ty::tls::with(|tcx| {\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"exhausted memory during interpretation\")\n+            });\n+            InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted).into()\n+        })\n+    }\n+\n+    /// Try to create an Allocation of `size` bytes, panics if there is not enough memory\n+    /// available to the compiler to do so.\n+    pub fn uninit(size: Size, align: Align) -> Self {\n+        match Self::uninit_inner(size, align, || {\n+            panic!(\"Allocation::uninit called with panic_on_fail had allocation failure\");\n+        }) {\n+            Ok(x) => x,\n+            Err(x) => x,\n+        }\n+    }\n }\n \n impl<Bytes: AllocBytes> Allocation<AllocId, (), Bytes> {"}, {"sha": "ca6f58adbb18927b80883b4e07a2153715a59900", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 195, "deletions": 242, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -5,11 +5,15 @@ use crate::query::TyCtxtAt;\n use crate::ty::{layout, tls, Ty, ValTree};\n \n use rustc_data_structures::sync::Lock;\n-use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{\n+    struct_span_err, DiagnosticArgValue, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n+    IntoDiagnosticArg,\n+};\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::{call, Align, Size};\n+use rustc_target::abi::{call, Align, Size, WrappingRange};\n+use std::borrow::Cow;\n use std::{any::Any, backtrace::Backtrace, fmt};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n@@ -91,21 +95,54 @@ pub struct InterpErrorInfo<'tcx>(Box<InterpErrorInfoInner<'tcx>>);\n #[derive(Debug)]\n struct InterpErrorInfoInner<'tcx> {\n     kind: InterpError<'tcx>,\n+    backtrace: InterpErrorBacktrace,\n+}\n+\n+#[derive(Debug)]\n+pub struct InterpErrorBacktrace {\n     backtrace: Option<Box<Backtrace>>,\n }\n \n-impl fmt::Display for InterpErrorInfo<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.0.kind)\n+impl InterpErrorBacktrace {\n+    pub fn new() -> InterpErrorBacktrace {\n+        let capture_backtrace = tls::with_opt(|tcx| {\n+            if let Some(tcx) = tcx {\n+                *Lock::borrow(&tcx.sess.ctfe_backtrace)\n+            } else {\n+                CtfeBacktrace::Disabled\n+            }\n+        });\n+\n+        let backtrace = match capture_backtrace {\n+            CtfeBacktrace::Disabled => None,\n+            CtfeBacktrace::Capture => Some(Box::new(Backtrace::force_capture())),\n+            CtfeBacktrace::Immediate => {\n+                // Print it now.\n+                let backtrace = Backtrace::force_capture();\n+                print_backtrace(&backtrace);\n+                None\n+            }\n+        };\n+\n+        InterpErrorBacktrace { backtrace }\n     }\n-}\n \n-impl<'tcx> InterpErrorInfo<'tcx> {\n     pub fn print_backtrace(&self) {\n-        if let Some(backtrace) = self.0.backtrace.as_ref() {\n+        if let Some(backtrace) = self.backtrace.as_ref() {\n             print_backtrace(backtrace);\n         }\n     }\n+}\n+\n+impl<'tcx> InterpErrorInfo<'tcx> {\n+    pub fn from_parts(kind: InterpError<'tcx>, backtrace: InterpErrorBacktrace) -> Self {\n+        Self(Box::new(InterpErrorInfoInner { kind, backtrace }))\n+    }\n+\n+    pub fn into_parts(self) -> (InterpError<'tcx>, InterpErrorBacktrace) {\n+        let InterpErrorInfo(box InterpErrorInfoInner { kind, backtrace }) = self;\n+        (kind, backtrace)\n+    }\n \n     pub fn into_kind(self) -> InterpError<'tcx> {\n         let InterpErrorInfo(box InterpErrorInfoInner { kind, .. }) = self;\n@@ -130,32 +167,17 @@ impl From<ErrorGuaranteed> for InterpErrorInfo<'_> {\n \n impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx>) -> Self {\n-        let capture_backtrace = tls::with_opt(|tcx| {\n-            if let Some(tcx) = tcx {\n-                *Lock::borrow(&tcx.sess.ctfe_backtrace)\n-            } else {\n-                CtfeBacktrace::Disabled\n-            }\n-        });\n-\n-        let backtrace = match capture_backtrace {\n-            CtfeBacktrace::Disabled => None,\n-            CtfeBacktrace::Capture => Some(Box::new(Backtrace::force_capture())),\n-            CtfeBacktrace::Immediate => {\n-                // Print it now.\n-                let backtrace = Backtrace::force_capture();\n-                print_backtrace(&backtrace);\n-                None\n-            }\n-        };\n-\n-        InterpErrorInfo(Box::new(InterpErrorInfoInner { kind, backtrace }))\n+        InterpErrorInfo(Box::new(InterpErrorInfoInner {\n+            kind,\n+            backtrace: InterpErrorBacktrace::new(),\n+        }))\n     }\n }\n \n /// Error information for when the program we executed turned out not to actually be a valid\n /// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n /// where we work on generic code or execution does not have all information available.\n+#[derive(Debug)]\n pub enum InvalidProgramInfo<'tcx> {\n     /// Resolution can fail if we are in a too generic context.\n     TooGeneric,\n@@ -174,25 +196,6 @@ pub enum InvalidProgramInfo<'tcx> {\n     UninitUnsizedLocal,\n }\n \n-impl fmt::Display for InvalidProgramInfo<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use InvalidProgramInfo::*;\n-        match self {\n-            TooGeneric => write!(f, \"encountered overly generic constant\"),\n-            AlreadyReported(_) => {\n-                write!(\n-                    f,\n-                    \"an error has already been reported elsewhere (this should not usually be printed)\"\n-                )\n-            }\n-            Layout(ref err) => write!(f, \"{err}\"),\n-            FnAbiAdjustForForeignAbi(ref err) => write!(f, \"{err}\"),\n-            SizeOfUnsizedType(ty) => write!(f, \"size_of called on unsized type `{ty}`\"),\n-            UninitUnsizedLocal => write!(f, \"unsized local is used while uninitialized\"),\n-        }\n-    }\n-}\n-\n /// Details of why a pointer had to be in-bounds.\n #[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub enum CheckInAllocMsg {\n@@ -208,26 +211,25 @@ pub enum CheckInAllocMsg {\n     InboundsTest,\n }\n \n-impl fmt::Display for CheckInAllocMsg {\n-    /// When this is printed as an error the context looks like this:\n-    /// \"{msg}{pointer} is a dangling pointer\".\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"{}\",\n-            match *self {\n-                CheckInAllocMsg::DerefTest => \"dereferencing pointer failed: \",\n-                CheckInAllocMsg::MemoryAccessTest => \"memory access failed: \",\n-                CheckInAllocMsg::PointerArithmeticTest => \"out-of-bounds pointer arithmetic: \",\n-                CheckInAllocMsg::OffsetFromTest => \"out-of-bounds offset_from: \",\n-                CheckInAllocMsg::InboundsTest => \"out-of-bounds pointer use: \",\n-            }\n-        )\n+#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n+pub enum InvalidMetaKind {\n+    /// Size of a `[T]` is too big\n+    SliceTooBig,\n+    /// Size of a DST is too big\n+    TooBig,\n+}\n+\n+impl IntoDiagnosticArg for InvalidMetaKind {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(match self {\n+            InvalidMetaKind::SliceTooBig => \"slice_too_big\",\n+            InvalidMetaKind::TooBig => \"too_big\",\n+        }))\n     }\n }\n \n /// Details of an access to uninitialized bytes where it is not allowed.\n-#[derive(Debug)]\n+#[derive(Debug, Clone, Copy)]\n pub struct UninitBytesAccess {\n     /// Range of the original memory access.\n     pub access: AllocRange,\n@@ -242,17 +244,32 @@ pub struct ScalarSizeMismatch {\n     pub data_size: u64,\n }\n \n+macro_rules! impl_into_diagnostic_arg_through_debug {\n+    ($($ty:ty),*$(,)?) => {$(\n+        impl IntoDiagnosticArg for $ty {\n+            fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+                DiagnosticArgValue::Str(Cow::Owned(format!(\"{self:?}\")))\n+            }\n+        }\n+    )*}\n+}\n+\n+// These types have nice `Debug` output so we can just use them in diagnostics.\n+impl_into_diagnostic_arg_through_debug! {\n+    AllocId,\n+    Pointer,\n+    AllocRange,\n+}\n+\n /// Error information for when the program caused Undefined Behavior.\n-pub enum UndefinedBehaviorInfo {\n-    /// Free-form case. Only for errors that are never caught!\n+#[derive(Debug)]\n+pub enum UndefinedBehaviorInfo<'a> {\n+    /// Free-form case. Only for errors that are never caught! Used by miri\n     Ub(String),\n     /// Unreachable code was executed.\n     Unreachable,\n     /// A slice/array index projection went out-of-bounds.\n-    BoundsCheckFailed {\n-        len: u64,\n-        index: u64,\n-    },\n+    BoundsCheckFailed { len: u64, index: u64 },\n     /// Something was divided by 0 (x / 0).\n     DivisionByZero,\n     /// Something was \"remainded\" by 0 (x % 0).\n@@ -263,8 +280,8 @@ pub enum UndefinedBehaviorInfo {\n     RemainderOverflow,\n     /// Overflowing inbounds pointer arithmetic.\n     PointerArithOverflow,\n-    /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n-    InvalidMeta(&'static str),\n+    /// Invalid metadata in a wide pointer\n+    InvalidMeta(InvalidMetaKind),\n     /// Reading a C string that does not end within its allocation.\n     UnterminatedCString(Pointer),\n     /// Dereferencing a dangling pointer after it got freed.\n@@ -281,25 +298,13 @@ pub enum UndefinedBehaviorInfo {\n     /// Using an integer as a pointer in the wrong way.\n     DanglingIntPointer(u64, CheckInAllocMsg),\n     /// Used a pointer with bad alignment.\n-    AlignmentCheckFailed {\n-        required: Align,\n-        has: Align,\n-    },\n+    AlignmentCheckFailed { required: Align, has: Align },\n     /// Writing to read-only memory.\n     WriteToReadOnly(AllocId),\n-    // Trying to access the data behind a function pointer.\n+    /// Trying to access the data behind a function pointer.\n     DerefFunctionPointer(AllocId),\n-    // Trying to access the data behind a vtable pointer.\n+    /// Trying to access the data behind a vtable pointer.\n     DerefVTablePointer(AllocId),\n-    /// The value validity check found a problem.\n-    /// Should only be thrown by `validity.rs` and always point out which part of the value\n-    /// is the problem.\n-    ValidationFailure {\n-        /// The \"path\" to the value in question, e.g. `.0[5].field` for a struct\n-        /// field in the 6th element of an array that is the first element of a tuple.\n-        path: Option<String>,\n-        msg: String,\n-    },\n     /// Using a non-boolean `u8` as bool.\n     InvalidBool(u8),\n     /// Using a non-character `u32` as character.\n@@ -320,110 +325,100 @@ pub enum UndefinedBehaviorInfo {\n     ScalarSizeMismatch(ScalarSizeMismatch),\n     /// A discriminant of an uninhabited enum variant is written.\n     UninhabitedEnumVariantWritten,\n+    /// Validation error.\n+    Validation(ValidationErrorInfo<'a>),\n+    // FIXME(fee1-dead) these should all be actual variants of the enum instead of dynamically\n+    // dispatched\n+    /// A custom (free-form) error, created by `err_ub_custom!`.\n+    Custom(crate::error::CustomSubdiagnostic<'a>),\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub enum PointerKind {\n+    Ref,\n+    Box,\n+}\n+\n+impl IntoDiagnosticArg for PointerKind {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(\n+            match self {\n+                Self::Ref => \"ref\",\n+                Self::Box => \"box\",\n+            }\n+            .into(),\n+        )\n+    }\n }\n \n-impl fmt::Display for UndefinedBehaviorInfo {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use UndefinedBehaviorInfo::*;\n-        match self {\n-            Ub(msg) => write!(f, \"{msg}\"),\n-            Unreachable => write!(f, \"entering unreachable code\"),\n-            BoundsCheckFailed { ref len, ref index } => {\n-                write!(f, \"indexing out of bounds: the len is {len} but the index is {index}\")\n-            }\n-            DivisionByZero => write!(f, \"dividing by zero\"),\n-            RemainderByZero => write!(f, \"calculating the remainder with a divisor of zero\"),\n-            DivisionOverflow => write!(f, \"overflow in signed division (dividing MIN by -1)\"),\n-            RemainderOverflow => write!(f, \"overflow in signed remainder (dividing MIN by -1)\"),\n-            PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n-            InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {msg}\"),\n-            UnterminatedCString(p) => write!(\n-                f,\n-                \"reading a null-terminated string starting at {p:?} with no null found before end of allocation\",\n-            ),\n-            PointerUseAfterFree(a) => {\n-                write!(f, \"pointer to {a:?} was dereferenced after this allocation got freed\")\n-            }\n-            PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size: Size::ZERO, msg } => {\n-                write!(\n-                    f,\n-                    \"{msg}{alloc_id:?} has size {alloc_size}, so pointer at offset {ptr_offset} is out-of-bounds\",\n-                    alloc_size = alloc_size.bytes(),\n-                )\n-            }\n-            PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size, msg } => write!(\n-                f,\n-                \"{msg}{alloc_id:?} has size {alloc_size}, so pointer to {ptr_size} byte{ptr_size_p} starting at offset {ptr_offset} is out-of-bounds\",\n-                alloc_size = alloc_size.bytes(),\n-                ptr_size = ptr_size.bytes(),\n-                ptr_size_p = pluralize!(ptr_size.bytes()),\n-            ),\n-            DanglingIntPointer(i, msg) => {\n-                write!(\n-                    f,\n-                    \"{msg}{pointer} is a dangling pointer (it has no provenance)\",\n-                    pointer = Pointer::<Option<AllocId>>::from_addr_invalid(*i),\n-                )\n-            }\n-            AlignmentCheckFailed { required, has } => write!(\n-                f,\n-                \"accessing memory with alignment {has}, but alignment {required} is required\",\n-                has = has.bytes(),\n-                required = required.bytes()\n-            ),\n-            WriteToReadOnly(a) => write!(f, \"writing to {a:?} which is read-only\"),\n-            DerefFunctionPointer(a) => write!(f, \"accessing {a:?} which contains a function\"),\n-            DerefVTablePointer(a) => write!(f, \"accessing {a:?} which contains a vtable\"),\n-            ValidationFailure { path: None, msg } => {\n-                write!(f, \"constructing invalid value: {msg}\")\n-            }\n-            ValidationFailure { path: Some(path), msg } => {\n-                write!(f, \"constructing invalid value at {path}: {msg}\")\n-            }\n-            InvalidBool(b) => {\n-                write!(f, \"interpreting an invalid 8-bit value as a bool: 0x{b:02x}\")\n-            }\n-            InvalidChar(c) => {\n-                write!(f, \"interpreting an invalid 32-bit value as a char: 0x{c:08x}\")\n-            }\n-            InvalidTag(val) => write!(f, \"enum value has invalid tag: {val:x}\"),\n-            InvalidFunctionPointer(p) => {\n-                write!(f, \"using {p:?} as function pointer but it does not point to a function\")\n-            }\n-            InvalidVTablePointer(p) => {\n-                write!(f, \"using {p:?} as vtable pointer but it does not point to a vtable\")\n-            }\n-            InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {err}\"),\n-            InvalidUninitBytes(Some((alloc, info))) => write!(\n-                f,\n-                \"reading memory at {alloc:?}{access:?}, \\\n-                 but memory is uninitialized at {uninit:?}, \\\n-                 and this operation requires initialized memory\",\n-                access = info.access,\n-                uninit = info.uninit,\n-            ),\n-            InvalidUninitBytes(None) => write!(\n-                f,\n-                \"using uninitialized data, but this operation requires initialized memory\"\n-            ),\n-            DeadLocal => write!(f, \"accessing a dead local variable\"),\n-            ScalarSizeMismatch(self::ScalarSizeMismatch { target_size, data_size }) => write!(\n-                f,\n-                \"scalar size mismatch: expected {target_size} bytes but got {data_size} bytes instead\",\n-            ),\n-            UninhabitedEnumVariantWritten => {\n-                write!(f, \"writing discriminant of an uninhabited enum\")\n-            }\n+#[derive(Debug)]\n+pub struct ValidationErrorInfo<'tcx> {\n+    pub path: Option<String>,\n+    pub kind: ValidationErrorKind<'tcx>,\n+}\n+\n+#[derive(Debug)]\n+pub enum ExpectedKind {\n+    Reference,\n+    Box,\n+    RawPtr,\n+    InitScalar,\n+    Bool,\n+    Char,\n+    Float,\n+    Int,\n+    FnPtr,\n+}\n+\n+impl From<PointerKind> for ExpectedKind {\n+    fn from(x: PointerKind) -> ExpectedKind {\n+        match x {\n+            PointerKind::Box => ExpectedKind::Box,\n+            PointerKind::Ref => ExpectedKind::Reference,\n         }\n     }\n }\n \n+#[derive(Debug)]\n+pub enum ValidationErrorKind<'tcx> {\n+    PtrToUninhabited { ptr_kind: PointerKind, ty: Ty<'tcx> },\n+    PtrToStatic { ptr_kind: PointerKind },\n+    PtrToMut { ptr_kind: PointerKind },\n+    ExpectedNonPtr { value: String },\n+    MutableRefInConst,\n+    NullFnPtr,\n+    NeverVal,\n+    NullablePtrOutOfRange { range: WrappingRange, max_value: u128 },\n+    PtrOutOfRange { range: WrappingRange, max_value: u128 },\n+    OutOfRange { value: String, range: WrappingRange, max_value: u128 },\n+    UnsafeCell,\n+    UninhabitedVal { ty: Ty<'tcx> },\n+    InvalidEnumTag { value: String },\n+    UninitEnumTag,\n+    UninitStr,\n+    Uninit { expected: ExpectedKind },\n+    UninitVal,\n+    InvalidVTablePtr { value: String },\n+    InvalidMetaSliceTooLarge { ptr_kind: PointerKind },\n+    InvalidMetaTooLarge { ptr_kind: PointerKind },\n+    UnalignedPtr { ptr_kind: PointerKind, required_bytes: u64, found_bytes: u64 },\n+    NullPtr { ptr_kind: PointerKind },\n+    DanglingPtrNoProvenance { ptr_kind: PointerKind, pointer: String },\n+    DanglingPtrOutOfBounds { ptr_kind: PointerKind },\n+    DanglingPtrUseAfterFree { ptr_kind: PointerKind },\n+    InvalidBool { value: String },\n+    InvalidChar { value: String },\n+    InvalidFnPtr { value: String },\n+}\n+\n /// Error information for when the program did something that might (or might not) be correct\n /// to do according to the Rust spec, but due to limitations in the interpreter, the\n /// operation could not be carried out. These limitations can differ between CTFE and the\n /// Miri engine, e.g., CTFE does not support dereferencing pointers at integral addresses.\n+#[derive(Debug)]\n pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n+    // FIXME still use translatable diagnostics\n     Unsupported(String),\n     //\n     // The variants below are only reachable from CTFE/const prop, miri will never emit them.\n@@ -442,26 +437,9 @@ pub enum UnsupportedOpInfo {\n     ReadExternStatic(DefId),\n }\n \n-impl fmt::Display for UnsupportedOpInfo {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use UnsupportedOpInfo::*;\n-        match self {\n-            Unsupported(ref msg) => write!(f, \"{msg}\"),\n-            PartialPointerOverwrite(ptr) => {\n-                write!(f, \"unable to overwrite parts of a pointer in memory at {ptr:?}\")\n-            }\n-            PartialPointerCopy(ptr) => {\n-                write!(f, \"unable to copy parts of a pointer from memory at {ptr:?}\")\n-            }\n-            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\"),\n-            ThreadLocalStatic(did) => write!(f, \"cannot access thread local static ({did:?})\"),\n-            ReadExternStatic(did) => write!(f, \"cannot read from extern static ({did:?})\"),\n-        }\n-    }\n-}\n-\n /// Error information for when the program exhausted the resources granted to it\n /// by the interpreter.\n+#[derive(Debug)]\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big.\n     StackFrameLimitReached,\n@@ -471,47 +449,29 @@ pub enum ResourceExhaustionInfo {\n     AddressSpaceFull,\n }\n \n-impl fmt::Display for ResourceExhaustionInfo {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use ResourceExhaustionInfo::*;\n-        match self {\n-            StackFrameLimitReached => {\n-                write!(f, \"reached the configured maximum number of stack frames\")\n-            }\n-            MemoryExhausted => {\n-                write!(f, \"tried to allocate more memory than available to compiler\")\n-            }\n-            AddressSpaceFull => {\n-                write!(f, \"there are no more free addresses in the address space\")\n-            }\n-        }\n-    }\n-}\n-\n-/// A trait to work around not having trait object upcasting.\n-pub trait AsAny: Any {\n-    fn as_any(&self) -> &dyn Any;\n-}\n-impl<T: Any> AsAny for T {\n-    #[inline(always)]\n-    fn as_any(&self) -> &dyn Any {\n-        self\n-    }\n-}\n-\n /// A trait for machine-specific errors (or other \"machine stop\" conditions).\n-pub trait MachineStopType: AsAny + fmt::Display + Send {}\n+pub trait MachineStopType: Any + fmt::Debug + Send {\n+    /// The diagnostic message for this error\n+    fn diagnostic_message(&self) -> DiagnosticMessage;\n+    /// Add diagnostic arguments by passing name and value pairs to `adder`, which are passed to\n+    /// fluent for formatting the translated diagnostic message.\n+    fn add_args(\n+        self: Box<Self>,\n+        adder: &mut dyn FnMut(Cow<'static, str>, DiagnosticArgValue<'static>),\n+    );\n+}\n \n impl dyn MachineStopType {\n     #[inline(always)]\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n-        self.as_any().downcast_ref()\n+        let x: &dyn Any = self;\n+        x.downcast_ref()\n     }\n }\n \n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n-    UndefinedBehavior(UndefinedBehaviorInfo),\n+    UndefinedBehavior(UndefinedBehaviorInfo<'tcx>),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n     Unsupported(UnsupportedOpInfo),\n@@ -527,26 +487,19 @@ pub enum InterpError<'tcx> {\n \n pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n \n-impl fmt::Display for InterpError<'_> {\n+impl fmt::Debug for InterpError<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use InterpError::*;\n-        match *self {\n-            Unsupported(ref msg) => write!(f, \"{msg}\"),\n-            InvalidProgram(ref msg) => write!(f, \"{msg}\"),\n-            UndefinedBehavior(ref msg) => write!(f, \"{msg}\"),\n-            ResourceExhaustion(ref msg) => write!(f, \"{msg}\"),\n-            MachineStop(ref msg) => write!(f, \"{msg}\"),\n+        match self {\n+            Unsupported(msg) => msg.fmt(f),\n+            InvalidProgram(msg) => msg.fmt(f),\n+            UndefinedBehavior(msg) => msg.fmt(f),\n+            ResourceExhaustion(msg) => msg.fmt(f),\n+            MachineStop(msg) => msg.fmt(f),\n         }\n     }\n }\n \n-// Forward `Debug` to `Display`, so it does not look awful.\n-impl fmt::Debug for InterpError<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n impl InterpError<'_> {\n     /// Some errors do string formatting even if the error is never printed.\n     /// To avoid performance issues, there are places where we want to be sure to never raise these formatting errors,\n@@ -555,7 +508,7 @@ impl InterpError<'_> {\n         matches!(\n             self,\n             InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n-                | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ValidationFailure { .. })\n+                | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Validation { .. })\n                 | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n         )\n     }"}, {"sha": "2d2cfee1b213bb56659f31a4511167dacd4b63a5", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -89,6 +89,30 @@ macro_rules! throw_machine_stop {\n     ($($tt:tt)*) => { do yeet err_machine_stop!($($tt)*) };\n }\n \n+#[macro_export]\n+macro_rules! err_ub_custom {\n+    ($msg:expr $(, $($name:ident = $value:expr),* $(,)?)?) => {{\n+        $(\n+            let ($($name,)*) = ($($value,)*);\n+        )?\n+        err_ub!(Custom(\n+            rustc_middle::error::CustomSubdiagnostic {\n+                msg: || $msg,\n+                add_args: Box::new(move |mut set_arg| {\n+                    $($(\n+                        set_arg(stringify!($name).into(), rustc_errors::IntoDiagnosticArg::into_diagnostic_arg($name));\n+                    )*)?\n+                })\n+            }\n+        ))\n+    }};\n+}\n+\n+#[macro_export]\n+macro_rules! throw_ub_custom {\n+    ($($tt:tt)*) => { do yeet err_ub_custom!($($tt)*) };\n+}\n+\n mod allocation;\n mod error;\n mod pointer;\n@@ -119,9 +143,10 @@ use crate::ty::{self, Instance, Ty, TyCtxt};\n \n pub use self::error::{\n     struct_error, CheckInAllocMsg, ErrorHandled, EvalToAllocationRawResult, EvalToConstValueResult,\n-    EvalToValTreeResult, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo,\n-    MachineStopType, ReportedErrorInfo, ResourceExhaustionInfo, ScalarSizeMismatch,\n-    UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    EvalToValTreeResult, ExpectedKind, InterpError, InterpErrorInfo, InterpResult, InvalidMetaKind,\n+    InvalidProgramInfo, MachineStopType, PointerKind, ReportedErrorInfo, ResourceExhaustionInfo,\n+    ScalarSizeMismatch, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    ValidationErrorInfo, ValidationErrorKind,\n };\n \n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar};"}, {"sha": "91caf9db336cf04978c9b220c67bab13cda09b3f", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -375,7 +375,8 @@ impl<'tcx, Prov: Provenance> Scalar<Prov> {\n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_bits(self, target_size: Size) -> u128 {\n-        self.to_bits(target_size).unwrap()\n+        self.to_bits(target_size)\n+            .unwrap_or_else(|_| panic!(\"assertion failed: {self:?} fits {target_size:?}\"))\n     }\n \n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {"}, {"sha": "e929240bf3001f5494ed989a93ce1b372c0821a7", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -15,7 +15,7 @@ use crate::ty::{AdtDef, InstanceDef, ScalarInt, UserTypeAnnotationIndex};\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n \n use rustc_data_structures::captures::Captures;\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{DiagnosticArgValue, DiagnosticMessage, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_hir::def::{CtorKind, Namespace};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::{self, GeneratorKind, ImplicitSelfKind};\n@@ -1371,55 +1371,61 @@ impl<O> AssertKind<O> {\n             _ => write!(f, \"\\\"{}\\\"\", self.description()),\n         }\n     }\n-}\n \n-impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    pub fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n         use AssertKind::*;\n+\n         match self {\n-            BoundsCheck { ref len, ref index } => write!(\n-                f,\n-                \"index out of bounds: the length is {:?} but the index is {:?}\",\n-                len, index\n-            ),\n-            OverflowNeg(op) => write!(f, \"attempt to negate `{:#?}`, which would overflow\", op),\n-            DivisionByZero(op) => write!(f, \"attempt to divide `{:#?}` by zero\", op),\n-            RemainderByZero(op) => write!(\n-                f,\n-                \"attempt to calculate the remainder of `{:#?}` with a divisor of zero\",\n-                op\n-            ),\n-            Overflow(BinOp::Add, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} + {:#?}`, which would overflow\", l, r)\n-            }\n-            Overflow(BinOp::Sub, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} - {:#?}`, which would overflow\", l, r)\n-            }\n-            Overflow(BinOp::Mul, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} * {:#?}`, which would overflow\", l, r)\n-            }\n-            Overflow(BinOp::Div, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} / {:#?}`, which would overflow\", l, r)\n+            BoundsCheck { .. } => middle_bounds_check,\n+            Overflow(BinOp::Shl, _, _) => middle_assert_shl_overflow,\n+            Overflow(BinOp::Shr, _, _) => middle_assert_shr_overflow,\n+            Overflow(_, _, _) => middle_assert_op_overflow,\n+            OverflowNeg(_) => middle_assert_overflow_neg,\n+            DivisionByZero(_) => middle_assert_divide_by_zero,\n+            RemainderByZero(_) => middle_assert_remainder_by_zero,\n+            ResumedAfterReturn(GeneratorKind::Async(_)) => middle_assert_async_resume_after_return,\n+            ResumedAfterReturn(GeneratorKind::Gen) => middle_assert_generator_resume_after_return,\n+            ResumedAfterPanic(GeneratorKind::Async(_)) => middle_assert_async_resume_after_panic,\n+            ResumedAfterPanic(GeneratorKind::Gen) => middle_assert_generator_resume_after_panic,\n+\n+            MisalignedPointerDereference { .. } => middle_assert_misaligned_ptr_deref,\n+        }\n+    }\n+\n+    pub fn add_args(self, adder: &mut dyn FnMut(Cow<'static, str>, DiagnosticArgValue<'static>))\n+    where\n+        O: fmt::Debug,\n+    {\n+        use AssertKind::*;\n+\n+        macro_rules! add {\n+            ($name: expr, $value: expr) => {\n+                adder($name.into(), $value.into_diagnostic_arg());\n+            };\n+        }\n+\n+        match self {\n+            BoundsCheck { len, index } => {\n+                add!(\"len\", format!(\"{len:?}\"));\n+                add!(\"index\", format!(\"{index:?}\"));\n             }\n-            Overflow(BinOp::Rem, l, r) => write!(\n-                f,\n-                \"attempt to compute the remainder of `{:#?} % {:#?}`, which would overflow\",\n-                l, r\n-            ),\n-            Overflow(BinOp::Shr, _, r) => {\n-                write!(f, \"attempt to shift right by `{:#?}`, which would overflow\", r)\n+            Overflow(BinOp::Shl | BinOp::Shr, _, val)\n+            | DivisionByZero(val)\n+            | RemainderByZero(val)\n+            | OverflowNeg(val) => {\n+                add!(\"val\", format!(\"{val:#?}\"));\n             }\n-            Overflow(BinOp::Shl, _, r) => {\n-                write!(f, \"attempt to shift left by `{:#?}`, which would overflow\", r)\n+            Overflow(binop, left, right) => {\n+                add!(\"op\", binop.to_hir_binop().as_str());\n+                add!(\"left\", format!(\"{left:#?}\"));\n+                add!(\"right\", format!(\"{right:#?}\"));\n             }\n+            ResumedAfterReturn(_) | ResumedAfterPanic(_) => {}\n             MisalignedPointerDereference { required, found } => {\n-                write!(\n-                    f,\n-                    \"misaligned pointer dereference: address must be a multiple of {:?} but is {:?}\",\n-                    required, found\n-                )\n+                add!(\"required\", format!(\"{required:#?}\"));\n+                add!(\"found\", format!(\"{found:#?}\"));\n             }\n-            _ => write!(f, \"{}\", self.description()),\n         }\n     }\n }"}, {"sha": "8477722ea393cbc777ca5102aec0445a1da91688", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -846,7 +846,7 @@ fn write_allocation_newline(\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-fn write_allocation_bytes<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n+pub fn write_allocation_bytes<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &Allocation<Prov, Extra, Bytes>,\n     w: &mut dyn std::fmt::Write,"}, {"sha": "83f8f00d72ce24895738c84b50b1eade60dd87d6", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -801,7 +801,8 @@ pub enum UnwindAction {\n }\n \n /// Information about an assertion failure.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n+#[derive(Clone, Hash, HashStable, PartialEq, Debug)]\n+#[derive(TyEncodable, TyDecodable, TypeFoldable, TypeVisitable)]\n pub enum AssertKind<O> {\n     BoundsCheck { len: O, index: O },\n     Overflow(BinOp, O, O),"}, {"sha": "1e43fab457e563a210ff4686b9700d43efb11d24", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,5 +1,6 @@\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_target::abi::Size;\n use std::fmt;\n@@ -113,6 +114,14 @@ impl std::fmt::Debug for ConstInt {\n     }\n }\n \n+impl IntoDiagnosticArg for ConstInt {\n+    // FIXME this simply uses the Debug impl, but we could probably do better by converting both\n+    // to an inherent method that returns `Cow`.\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(format!(\"{self:?}\").into())\n+    }\n+}\n+\n /// The raw bytes of a simple value.\n ///\n /// This is a packed struct in order to allow this type to be optimally embedded in enums"}, {"sha": "c5a306fdf1f9a351a3373f2726f1e6ce7594d1c4", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,8 +1,9 @@\n-use crate::fluent_generated as fluent;\n+use crate::error::UnsupportedFnAbi;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::query::TyCtxtAt;\n use crate::ty::normalize_erasing_regions::NormalizationError;\n use crate::ty::{self, ReprOptions, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_error_messages::DiagnosticMessage;\n use rustc_errors::{DiagnosticBuilder, Handler, IntoDiagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -14,7 +15,7 @@ use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::*;\n use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy, Target};\n \n-use std::cmp::{self};\n+use std::cmp;\n use std::fmt;\n use std::num::NonZeroUsize;\n use std::ops::Bound;\n@@ -214,29 +215,29 @@ pub enum LayoutError<'tcx> {\n     Cycle,\n }\n \n-impl IntoDiagnostic<'_, !> for LayoutError<'_> {\n-    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n-        let mut diag = handler.struct_fatal(\"\");\n+impl<'tcx> LayoutError<'tcx> {\n+    pub fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        use LayoutError::*;\n+        match self {\n+            Unknown(_) => middle_unknown_layout,\n+            SizeOverflow(_) => middle_values_too_big,\n+            NormalizationFailure(_, _) => middle_cannot_be_normalized,\n+            Cycle => middle_cycle,\n+        }\n+    }\n \n+    pub fn into_diagnostic(self) -> crate::error::LayoutError<'tcx> {\n+        use crate::error::LayoutError as E;\n+        use LayoutError::*;\n         match self {\n-            LayoutError::Unknown(ty) => {\n-                diag.set_arg(\"ty\", ty);\n-                diag.set_primary_message(fluent::middle_unknown_layout);\n-            }\n-            LayoutError::SizeOverflow(ty) => {\n-                diag.set_arg(\"ty\", ty);\n-                diag.set_primary_message(fluent::middle_values_too_big);\n-            }\n-            LayoutError::NormalizationFailure(ty, e) => {\n-                diag.set_arg(\"ty\", ty);\n-                diag.set_arg(\"failure_ty\", e.get_type_for_failure());\n-                diag.set_primary_message(fluent::middle_cannot_be_normalized);\n-            }\n-            LayoutError::Cycle => {\n-                diag.set_primary_message(fluent::middle_cycle);\n+            Unknown(ty) => E::Unknown { ty },\n+            SizeOverflow(ty) => E::Overflow { ty },\n+            NormalizationFailure(ty, e) => {\n+                E::NormalizationFailure { ty, failure_ty: e.get_type_for_failure() }\n             }\n+            Cycle => E::Cycle,\n         }\n-        diag\n     }\n }\n \n@@ -330,11 +331,8 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }\n                     _ => bug!(\n-                        \"SizeSkeleton::compute({}): layout errored ({}), yet \\\n-                              tail `{}` is not a type parameter or a projection\",\n-                        ty,\n-                        err,\n-                        tail\n+                        \"SizeSkeleton::compute({ty}): layout errored ({err:?}), yet \\\n+                              tail `{tail}` is not a type parameter or a projection\",\n                     ),\n                 }\n             }\n@@ -940,12 +938,8 @@ where\n             TyMaybeWithLayout::Ty(field_ty) => {\n                 cx.tcx().layout_of(cx.param_env().and(field_ty)).unwrap_or_else(|e| {\n                     bug!(\n-                        \"failed to get layout for `{}`: {},\\n\\\n-                         despite it being a field (#{}) of an existing layout: {:#?}\",\n-                        field_ty,\n-                        e,\n-                        i,\n-                        this\n+                        \"failed to get layout for `{field_ty}`: {e:?},\\n\\\n+                         despite it being a field (#{i}) of an existing layout: {this:#?}\",\n                     )\n                 })\n             }\n@@ -1262,21 +1256,18 @@ impl From<call::AdjustForForeignAbiError> for FnAbiError<'_> {\n     }\n }\n \n-impl<'tcx> fmt::Display for FnAbiError<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+impl<'a, 'b> IntoDiagnostic<'a, !> for FnAbiError<'b> {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, !> {\n         match self {\n-            Self::Layout(err) => err.fmt(f),\n-            Self::AdjustForForeignAbi(err) => err.fmt(f),\n+            Self::Layout(e) => e.into_diagnostic().into_diagnostic(handler),\n+            Self::AdjustForForeignAbi(call::AdjustForForeignAbiError::Unsupported {\n+                arch,\n+                abi,\n+            }) => UnsupportedFnAbi { arch, abi: abi.name() }.into_diagnostic(handler),\n         }\n     }\n }\n \n-impl IntoDiagnostic<'_, !> for FnAbiError<'_> {\n-    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n-        handler.struct_fatal(self.to_string())\n-    }\n-}\n-\n // FIXME(eddyb) maybe use something like this for an unified `fn_abi_of`, not\n // just for error handling.\n #[derive(Debug)]"}, {"sha": "443791d0af4ba87da5586f4f9723d401522c12fc", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -73,7 +73,7 @@ pub(super) fn vtable_allocation_provider<'tcx>(\n     let ptr_align = tcx.data_layout.pointer_align.abi;\n \n     let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n-    let mut vtable = Allocation::uninit(vtable_size, ptr_align, /* panic_on_fail */ true).unwrap();\n+    let mut vtable = Allocation::uninit(vtable_size, ptr_align);\n \n     // No need to do any alignment checks on the memory accesses below, because we know the\n     // allocation is correctly aligned as we created it above. Also we're only offsetting by"}, {"sha": "2639bbee86fe6f7c25b45d1acfcb0aa2d9f47c1c", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -37,14 +37,25 @@ macro_rules! throw_machine_stop_str {\n     ($($tt:tt)*) => {{\n         // We make a new local type for it. The type itself does not carry any information,\n         // but its vtable (for the `MachineStopType` trait) does.\n+        #[derive(Debug)]\n         struct Zst;\n         // Printing this type shows the desired string.\n         impl std::fmt::Display for Zst {\n             fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                 write!(f, $($tt)*)\n             }\n         }\n-        impl rustc_middle::mir::interpret::MachineStopType for Zst {}\n+\n+        impl rustc_middle::mir::interpret::MachineStopType for Zst {\n+            fn diagnostic_message(&self) -> rustc_errors::DiagnosticMessage {\n+                self.to_string().into()\n+            }\n+\n+            fn add_args(\n+                self: Box<Self>,\n+                _: &mut dyn FnMut(std::borrow::Cow<'static, str>, rustc_errors::DiagnosticArgValue<'static>),\n+            ) {}\n+        }\n         throw_machine_stop!(Zst)\n     }};\n }\n@@ -367,7 +378,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 op\n             }\n             Err(e) => {\n-                trace!(\"get_const failed: {}\", e);\n+                trace!(\"get_const failed: {e:?}\");\n                 return None;\n             }\n         };"}, {"sha": "61cc76e66461375d1cfdb702d5d9204a7e8fece2", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -232,7 +232,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 op\n             }\n             Err(e) => {\n-                trace!(\"get_const failed: {}\", e);\n+                trace!(\"get_const failed: {e:?}\");\n                 return None;\n             }\n         };\n@@ -272,8 +272,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 // dedicated error variants should be introduced instead.\n                 assert!(\n                     !error.kind().formatted_string(),\n-                    \"const-prop encountered formatting error: {}\",\n-                    error\n+                    \"const-prop encountered formatting error: {error:?}\",\n                 );\n                 None\n             }"}, {"sha": "22f71bb08516c0a2b43a57e2e0565efbe1a05e44", "filename": "compiler/rustc_mir_transform/src/errors.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -163,7 +163,14 @@ impl<'a, P: std::fmt::Debug> DecorateLint<'a, ()> for AssertLint<P> {\n         self,\n         diag: &'b mut DiagnosticBuilder<'a, ()>,\n     ) -> &'b mut DiagnosticBuilder<'a, ()> {\n-        diag.span_label(self.span(), format!(\"{:?}\", self.panic()));\n+        let span = self.span();\n+        let assert_kind = self.panic();\n+        let message = assert_kind.diagnostic_message();\n+        assert_kind.add_args(&mut |name, value| {\n+            diag.set_arg(name, value);\n+        });\n+        diag.span_label(span, message);\n+\n         diag\n     }\n \n@@ -191,7 +198,7 @@ impl<P> AssertLint<P> {\n             AssertLint::ArithmeticOverflow(sp, _) | AssertLint::UnconditionalPanic(sp, _) => *sp,\n         }\n     }\n-    pub fn panic(&self) -> &AssertKind<P> {\n+    pub fn panic(self) -> AssertKind<P> {\n         match self {\n             AssertLint::ArithmeticOverflow(_, p) | AssertLint::UnconditionalPanic(_, p) => p,\n         }"}, {"sha": "9971bdf45bbf3325b8ceaf2f352f40b170294e83", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -93,7 +93,7 @@ fn dump_layout_of(tcx: TyCtxt<'_>, item_def_id: LocalDefId, attr: &Attribute) {\n \n         Err(layout_error) => {\n             tcx.sess.emit_fatal(Spanned {\n-                node: layout_error,\n+                node: layout_error.into_diagnostic(),\n                 span: tcx.def_span(item_def_id.to_def_id()),\n             });\n         }\n@@ -109,12 +109,7 @@ impl<'tcx> LayoutOfHelpers<'tcx> for UnwrapLayoutCx<'tcx> {\n     type LayoutOfResult = TyAndLayout<'tcx>;\n \n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n-        span_bug!(\n-            span,\n-            \"`#[rustc_layout(..)]` test resulted in `layout_of({}) = Err({})`\",\n-            ty,\n-            err\n-        );\n+        span_bug!(span, \"`#[rustc_layout(..)]` test resulted in `layout_of({ty}) = Err({err})`\",);\n     }\n }\n "}, {"sha": "a1cb317c50ea6996bfc3a371f08c0de19288e8a5", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -501,7 +501,15 @@ fn encode_ty<'tcx>(\n         ty::Array(ty0, len) => {\n             // A<array-length><element-type>\n             let mut s = String::from(\"A\");\n-            let _ = write!(s, \"{}\", &len.kind().try_to_scalar().unwrap().to_u64().unwrap());\n+            let _ = write!(\n+                s,\n+                \"{}\",\n+                &len.kind()\n+                    .try_to_scalar()\n+                    .unwrap()\n+                    .to_u64()\n+                    .unwrap_or_else(|_| panic!(\"failed to convert length to u64\"))\n+            );\n             s.push_str(&encode_ty(tcx, *ty0, dict, options));\n             compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n             typeid.push_str(&s);\n@@ -786,7 +794,12 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n         }\n \n         ty::Array(ty0, len) => {\n-            let len = len.kind().try_to_scalar().unwrap().to_u64().unwrap();\n+            let len = len\n+                .kind()\n+                .try_to_scalar()\n+                .unwrap()\n+                .to_u64()\n+                .unwrap_or_else(|_| panic!(\"failed to convert length to u64\"));\n             ty = tcx.mk_array(transform_ty(tcx, *ty0, options), len);\n         }\n "}, {"sha": "c4abf6f4b5e4941a38cd81ac116150a485cf26a5", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -2,7 +2,6 @@ use crate::abi::{self, Abi, Align, FieldsShape, Size};\n use crate::abi::{HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::{self, HasTargetSpec};\n use rustc_span::Symbol;\n-use std::fmt;\n use std::str::FromStr;\n \n mod aarch64;\n@@ -633,16 +632,6 @@ pub enum AdjustForForeignAbiError {\n     Unsupported { arch: Symbol, abi: spec::abi::Abi },\n }\n \n-impl fmt::Display for AdjustForForeignAbiError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::Unsupported { arch, abi } => {\n-                write!(f, \"target architecture {arch:?} does not support `extern {abi}` ABI\")\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, Ty> FnAbi<'a, Ty> {\n     pub fn adjust_for_foreign_abi<C>(\n         &mut self,"}, {"sha": "048302187cf9f656052292f70bfd23b6c300ed63", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -526,7 +526,7 @@ fn virtual_call_violation_for_method<'tcx>(\n                         // #78372\n                         tcx.sess.delay_span_bug(\n                             tcx.def_span(method.def_id),\n-                            format!(\"error: {}\\n while computing layout for type {:?}\", err, ty),\n+                            format!(\"error: {err}\\n while computing layout for type {ty:?}\"),\n                         );\n                         None\n                     }"}, {"sha": "83a76f81d4e78ff448f5acf958f984023b1dc703", "filename": "src/tools/clippy/tests/ui/modulo_one.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmodulo_one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmodulo_one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmodulo_one.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -2,21 +2,21 @@ error: this operation will panic at runtime\n   --> $DIR/modulo_one.rs:11:5\n    |\n LL |     i32::MIN % (-1); // also caught by rustc\n-   |     ^^^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |     ^^^^^^^^^^^^^^^ attempt to compute `i32::MIN % -1_i32`, which would overflow\n    |\n    = note: `#[deny(unconditional_panic)]` on by default\n \n error: this operation will panic at runtime\n   --> $DIR/modulo_one.rs:21:5\n    |\n LL |     INT_MIN % NEG_ONE; // also caught by rustc\n-   |     ^^^^^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |     ^^^^^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/modulo_one.rs:22:5\n    |\n LL |     INT_MIN % STATIC_NEG_ONE; // ONLY caught by rustc\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: any number modulo 1 will be 0\n   --> $DIR/modulo_one.rs:8:5"}, {"sha": "8c788c915febe18e484b8dc46d03bf58cb78292b", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -3,6 +3,8 @@ use std::num::NonZeroU64;\n \n use log::trace;\n \n+use rustc_const_eval::ReportErrorExt;\n+use rustc_errors::DiagnosticMessage;\n use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n use rustc_target::abi::{Align, Size};\n \n@@ -83,7 +85,21 @@ impl fmt::Display for TerminationInfo {\n     }\n }\n \n-impl MachineStopType for TerminationInfo {}\n+impl fmt::Debug for TerminationInfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{self}\")\n+    }\n+}\n+\n+impl MachineStopType for TerminationInfo {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        self.to_string().into()\n+    }\n+    fn add_args(\n+        self: Box<Self>,\n+        _: &mut dyn FnMut(std::borrow::Cow<'static, str>, rustc_errors::DiagnosticArgValue<'static>),\n+    ) {}\n+}\n \n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n@@ -302,8 +318,32 @@ pub fn report_error<'tcx, 'mir>(\n \n     let stacktrace = ecx.generate_stacktrace();\n     let (stacktrace, was_pruned) = prune_stacktrace(stacktrace, &ecx.machine);\n-    e.print_backtrace();\n-    msg.insert(0, e.to_string());\n+    let (e, backtrace) = e.into_parts();\n+    backtrace.print_backtrace();\n+\n+    // We want to dump the allocation if this is `InvalidUninitBytes`. Since `add_args` consumes\n+    // the `InterpError`, we extract the variables it before that.\n+    let extra = match e {\n+        UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) => {\n+            Some((alloc_id, access))\n+        }\n+        _ => None\n+    };\n+\n+    // FIXME(fee1-dead), HACK: we want to use the error as title therefore we can just extract the\n+    // label and arguments from the InterpError.\n+    let e = {\n+        let handler = &ecx.tcx.sess.parse_sess.span_diagnostic;\n+        let mut diag = ecx.tcx.sess.struct_allow(\"\");\n+        let msg = e.diagnostic_message();\n+        e.add_args(handler, &mut diag);\n+        let s = handler.eagerly_translate_to_string(msg, diag.args());\n+        diag.cancel();\n+        s\n+    };\n+\n+    msg.insert(0, e);\n+\n     report_msg(\n         DiagLevel::Error,\n         if let Some(title) = title { format!(\"{title}: {}\", msg[0]) } else { msg[0].clone() },\n@@ -332,15 +372,12 @@ pub fn report_error<'tcx, 'mir>(\n     }\n \n     // Extra output to help debug specific issues.\n-    match e.kind() {\n-        UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) => {\n-            eprintln!(\n-                \"Uninitialized memory occurred at {alloc_id:?}{range:?}, in this allocation:\",\n-                range = access.uninit,\n-            );\n-            eprintln!(\"{:?}\", ecx.dump_alloc(*alloc_id));\n-        }\n-        _ => {}\n+    if let Some((alloc_id, access)) = extra {\n+        eprintln!(\n+            \"Uninitialized memory occurred at {alloc_id:?}{range:?}, in this allocation:\",\n+            range = access.uninit,\n+        );\n+        eprintln!(\"{:?}\", ecx.dump_alloc(alloc_id));\n     }\n \n     None\n@@ -438,20 +475,23 @@ pub fn report_msg<'tcx>(\n         // Add visual separator before backtrace.\n         err.note(if extra_span { \"BACKTRACE (of the first span):\" } else { \"BACKTRACE:\" });\n     }\n+\n+    let (mut err, handler) = err.into_diagnostic().unwrap();\n+    \n     // Add backtrace\n     for (idx, frame_info) in stacktrace.iter().enumerate() {\n         let is_local = machine.is_local(frame_info);\n         // No span for non-local frames and the first frame (which is the error site).\n         if is_local && idx > 0 {\n-            err.span_note(frame_info.span, frame_info.to_string());\n+            err.eager_subdiagnostic(handler, frame_info.as_note(machine.tcx));\n         } else {\n             let sm = sess.source_map();\n             let span = sm.span_to_embeddable_string(frame_info.span);\n             err.note(format!(\"{frame_info} at {span}\"));\n         }\n     }\n \n-    err.emit();\n+    handler.emit_diagnostic(&mut err);\n }\n \n impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {"}, {"sha": "1e9d48be65ed972b42f3e6e06f72af514f8ace91", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -422,8 +422,9 @@ pub fn eval_entry<'tcx>(\n     let mut ecx = match create_ecx(tcx, entry_id, entry_type, &config) {\n         Ok(v) => v,\n         Err(err) => {\n-            err.print_backtrace();\n-            panic!(\"Miri initialization error: {}\", err.kind())\n+            let (kind, backtrace) = err.into_parts();\n+            backtrace.print_backtrace();\n+            panic!(\"Miri initialization error: {kind:?}\")\n         }\n     };\n "}, {"sha": "f11902652393a492871376883df57e348e2d83f7", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -164,9 +164,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // We don't give a span -- this isn't actually used directly by the program anyway.\n         let const_val = this\n             .eval_global(cid, None)\n-            .unwrap_or_else(|err| panic!(\"failed to evaluate required Rust item: {path:?}\\n{err}\"));\n+            .unwrap_or_else(|err| panic!(\"failed to evaluate required Rust item: {path:?}\\n{err:?}\"));\n         this.read_scalar(&const_val.into())\n-            .unwrap_or_else(|err| panic!(\"failed to read required Rust item: {path:?}\\n{err}\"))\n+            .unwrap_or_else(|err| panic!(\"failed to read required Rust item: {path:?}\\n{err:?}\"))\n     }\n \n     /// Helper function to get a `libc` constant as a `Scalar`."}, {"sha": "f711f01f3233c08f2a19cfc321f41f3cbbd39b4b", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -43,6 +43,7 @@\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;\n+extern crate rustc_errors;\n #[macro_use]\n extern crate rustc_middle;\n extern crate rustc_const_eval;"}, {"sha": "9c73bdc17bebc6afbf98b7d397864199dbd4440d", "filename": "src/tools/miri/tests/fail/intrinsics/copy_overlapping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -10,6 +10,6 @@ fn main() {\n     unsafe {\n         let a = data.as_mut_ptr();\n         let b = a.wrapping_offset(1) as *mut _;\n-        copy_nonoverlapping(a, b, 2); //~ ERROR: copy_nonoverlapping called on overlapping ranges\n+        copy_nonoverlapping(a, b, 2); //~ ERROR: `copy_nonoverlapping` called on overlapping ranges\n     }\n }"}, {"sha": "13a76aae730450c98c105ca423880a262fe2ec78", "filename": "src/tools/miri/tests/fail/intrinsics/copy_overlapping.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: copy_nonoverlapping called on overlapping ranges\n+error: Undefined Behavior: `copy_nonoverlapping` called on overlapping ranges\n   --> $DIR/copy_overlapping.rs:LL:CC\n    |\n LL |         copy_nonoverlapping(a, b, 2);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ copy_nonoverlapping called on overlapping ranges\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `copy_nonoverlapping` called on overlapping ranges\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "0b9cda62b33c2f1afc9a6a6fac62909d0dd8954e", "filename": "src/tools/miri/tests/fail/intrinsics/ptr_offset_from_oob.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fptr_offset_from_oob.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fptr_offset_from_oob.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fptr_offset_from_oob.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: out-of-bounds offset_from: ALLOC has size 4, so pointer at offset 10 is out-of-bounds\n+error: Undefined Behavior: out-of-bounds `offset_from`: ALLOC has size 4, so pointer at offset 10 is out-of-bounds\n   --> $DIR/ptr_offset_from_oob.rs:LL:CC\n    |\n LL |     unsafe { end_ptr.offset_from(end_ptr) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: ALLOC has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: ALLOC has size 4, so pointer at offset 10 is out-of-bounds\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "ffbefce48d3e50cbac94af6da0031c1725f9c6dc", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -538,15 +538,15 @@ struct LabelWithTrailingPath {\n #[diag(no_crate_example, code = \"E0123\")]\n struct LabelWithTrailingNameValue {\n     #[label(no_crate_label, foo = \"...\")]\n-    //~^ ERROR invalid nested attribute\n+    //~^ ERROR only `no_span` is a valid nested attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n #[diag(no_crate_example, code = \"E0123\")]\n struct LabelWithTrailingList {\n     #[label(no_crate_label, foo(\"...\"))]\n-    //~^ ERROR invalid nested attribute\n+    //~^ ERROR only `no_span` is a valid nested attribute\n     span: Span,\n }\n "}, {"sha": "1398f9c96bf2005d33b1cb560ee52678a67ec34c", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -243,7 +243,7 @@ error: invalid nested attribute\n LL |     #[suggestion(nonsense = \"bar\")]\n    |                  ^^^^^^^^\n    |\n-   = help: only `style`, `code` and `applicability` are valid nested attributes\n+   = help: only `no_span`, `style`, `code` and `applicability` are valid nested attributes\n \n error: suggestion without `code = \"...\"`\n   --> $DIR/diagnostic-derive.rs:234:5\n@@ -257,7 +257,7 @@ error: invalid nested attribute\n LL |     #[suggestion(msg = \"bar\")]\n    |                  ^^^\n    |\n-   = help: only `style`, `code` and `applicability` are valid nested attributes\n+   = help: only `no_span`, `style`, `code` and `applicability` are valid nested attributes\n \n error: suggestion without `code = \"...\"`\n   --> $DIR/diagnostic-derive.rs:243:5\n@@ -335,13 +335,13 @@ error: a diagnostic slug must be the first argument to the attribute\n LL |     #[label(no_crate_label, foo)]\n    |                                ^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/diagnostic-derive.rs:540:29\n    |\n LL |     #[label(no_crate_label, foo = \"...\")]\n    |                             ^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/diagnostic-derive.rs:548:29\n    |\n LL |     #[label(no_crate_label, foo(\"...\"))]"}, {"sha": "38af5b0f9fb1690f2f1421c31188c9e8459ffafe", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -85,7 +85,7 @@ struct F {\n \n #[derive(Subdiagnostic)]\n #[label(bug = \"...\")]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n //~| ERROR diagnostic slug must be first argument\n struct G {\n     #[primary_span]\n@@ -104,7 +104,7 @@ struct H {\n \n #[derive(Subdiagnostic)]\n #[label(slug = 4)]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n //~| ERROR diagnostic slug must be first argument\n struct J {\n     #[primary_span]\n@@ -114,7 +114,7 @@ struct J {\n \n #[derive(Subdiagnostic)]\n #[label(slug(\"...\"))]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n //~| ERROR diagnostic slug must be first argument\n struct K {\n     #[primary_span]\n@@ -143,7 +143,7 @@ struct M {\n \n #[derive(Subdiagnostic)]\n #[label(no_crate_example, code = \"...\")]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n struct N {\n     #[primary_span]\n     span: Span,\n@@ -152,7 +152,7 @@ struct N {\n \n #[derive(Subdiagnostic)]\n #[label(no_crate_example, applicability = \"machine-applicable\")]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n struct O {\n     #[primary_span]\n     span: Span,\n@@ -224,7 +224,7 @@ enum T {\n enum U {\n     #[label(code = \"...\")]\n     //~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n-    //~| ERROR invalid nested attribute\n+    //~| ERROR only `no_span` is a valid nested attribute\n     A {\n         #[primary_span]\n         span: Span,"}, {"sha": "5ddc8edd745dbbd42e90f0b6e8e9dab3b95781bd", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -26,7 +26,7 @@ error: `#[label = ...]` is not a valid attribute\n LL | #[label = \"...\"]\n    | ^^^^^^^^^^^^^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:87:9\n    |\n LL | #[label(bug = \"...\")]\n@@ -44,7 +44,7 @@ error: unexpected literal in nested attribute, expected ident\n LL | #[label(\"...\")]\n    |         ^^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:106:9\n    |\n LL | #[label(slug = 4)]\n@@ -56,7 +56,7 @@ error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n LL | #[label(slug = 4)]\n    | ^^^^^^^^^^^^^^^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:116:9\n    |\n LL | #[label(slug(\"...\"))]\n@@ -74,13 +74,13 @@ error: unexpected end of input, unexpected token in nested attribute, expected i\n LL | #[label()]\n    |         ^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:145:27\n    |\n LL | #[label(no_crate_example, code = \"...\")]\n    |                           ^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:154:27\n    |\n LL | #[label(no_crate_example, applicability = \"machine-applicable\")]\n@@ -116,7 +116,7 @@ error: `#[bar(...)]` is not a valid attribute\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:225:13\n    |\n LL |     #[label(code = \"...\")]\n@@ -312,7 +312,7 @@ error: invalid nested attribute\n LL | #[multipart_suggestion(no_crate_example, code = \"...\", applicability = \"machine-applicable\")]\n    |                                          ^^^^\n    |\n-   = help: only `style` and `applicability` are valid nested attributes\n+   = help: only `no_span`, `style` and `applicability` are valid nested attributes\n \n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n   --> $DIR/subdiagnostic-derive.rs:540:1"}, {"sha": "dc3a400cbaa83098d0a7c2ccd8a40c95dcc20175", "filename": "tests/ui/const-generics/generic_const_exprs/issue-80742.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,4 +1,4 @@\n-error[E0080]: evaluation of `Inline::<dyn std::fmt::Debug>::{constant#0}` failed\n+error[E0080]: evaluation of `Inline::<dyn Debug>::{constant#0}` failed\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n    = note: size_of called on unsized type `dyn Debug`\n@@ -35,7 +35,7 @@ help: consider relaxing the type parameter's implicit `Sized` bound\n LL | impl<T: ?Sized> Inline<T>\n    |       ++++++++\n \n-error[E0080]: evaluation of `Inline::<dyn std::fmt::Debug>::{constant#0}` failed\n+error[E0080]: evaluation of `Inline::<dyn Debug>::{constant#0}` failed\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n    = note: size_of called on unsized type `dyn Debug`"}, {"sha": "22c3dfa64febcbf5f45f9e754209600464accdc5", "filename": "tests/ui/const-ptr/forbidden_slices.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -54,11 +54,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n                HEX_DUMP\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:30:1\n@@ -98,7 +98,7 @@ LL |     from_raw_parts(ptr, 1)\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds `offset_from`: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -156,11 +156,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static R5: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n                HEX_DUMP\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:63:1"}, {"sha": "23ba2c2f535165a36b9472454d7981e8c34462a8", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_errors.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_errors.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -2,7 +2,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/alloc_intrinsic_errors.rs:9:17\n    |\n LL |         let _ = intrinsics::const_allocate(4, 3) as *mut i32;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ align has to be a power of 2, `3` is not a power of 2\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid align passed to `const_allocate`: 3 is not a power of 2\n    |\n note: inside `foo`\n   --> $DIR/alloc_intrinsic_errors.rs:9:17"}, {"sha": "9ae906bbb73971d1a96ee48411cd931a8ffbdca7", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_nontransient_fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -4,11 +4,11 @@\n use std::intrinsics;\n \n const FOO: *const i32 = foo();\n-//~^ ERROR untyped pointers are not allowed in constant\n+//~^ ERROR unsupported untyped pointer in constant\n \n const fn foo() -> &'static i32 {\n     let t = unsafe {\n-        let i = intrinsics::const_allocate(4, 4) as * mut i32;\n+        let i = intrinsics::const_allocate(4, 4) as *mut i32;\n         *i = 20;\n         i\n     };"}, {"sha": "2103f842bd58eb1467d35fb260059e01f4d15ccf", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_nontransient_fail.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,8 +1,10 @@\n-error: untyped pointers are not allowed in constant\n+error: unsupported untyped pointer in constant\n   --> $DIR/alloc_intrinsic_nontransient_fail.rs:6:1\n    |\n LL | const FOO: *const i32 = foo();\n    | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: memory only reachable via raw pointers is not supported\n \n error: aborting due to previous error\n "}, {"sha": "1354b3c33b31d8565d7df3df0ebff38ec68c879b", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_untyped.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -3,7 +3,7 @@\n #![feature(const_mut_refs)]\n use std::intrinsics;\n \n-const BAR: *mut i32 = unsafe { intrinsics::const_allocate(4, 4) as *mut i32};\n-//~^ error: untyped pointers are not allowed in constant\n+const BAR: *mut i32 = unsafe { intrinsics::const_allocate(4, 4) as *mut i32 };\n+//~^ error: unsupported untyped pointer in constant\n \n fn main() {}"}, {"sha": "b6276647350be08b7ecad2f4c082f40e77346afd", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_untyped.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,8 +1,10 @@\n-error: untyped pointers are not allowed in constant\n+error: unsupported untyped pointer in constant\n   --> $DIR/alloc_intrinsic_untyped.rs:6:1\n    |\n-LL | const BAR: *mut i32 = unsafe { intrinsics::const_allocate(4, 4) as *mut i32};\n+LL | const BAR: *mut i32 = unsafe { intrinsics::const_allocate(4, 4) as *mut i32 };\n    | ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: memory only reachable via raw pointers is not supported\n \n error: aborting due to previous error\n "}, {"sha": "4c23957a1f80bc1d84559dbce74bb22285bf26c2", "filename": "tests/ui/consts/const-eval/heap/dealloc_intrinsic_incorrect_layout.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Fdealloc_intrinsic_incorrect_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Fdealloc_intrinsic_incorrect_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Fdealloc_intrinsic_incorrect_layout.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -20,7 +20,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/dealloc_intrinsic_incorrect_layout.rs:25:5\n    |\n LL |     intrinsics::const_deallocate(ptr, 4, 3);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ align has to be a power of 2, `3` is not a power of 2\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid align passed to `const_deallocate`: 3 is not a power of 2\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c0ddaceea4ce3f6f1d1b93546e882ccd9499e174", "filename": "tests/ui/consts/const-eval/raw-bytes.32bit.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -35,7 +35,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:44:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type `Never`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 1, align: 1) {\n@@ -290,11 +290,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:152:1\n@@ -529,11 +529,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:221:1\n@@ -574,11 +574,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static R5: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:242:1"}, {"sha": "20c905878e07c07c19e6e12697e7f10649ff8a98", "filename": "tests/ui/consts/const-eval/raw-bytes.64bit.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -35,7 +35,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:44:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type `Never`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 1, align: 1) {\n@@ -290,11 +290,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:152:1\n@@ -529,11 +529,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:221:1\n@@ -574,11 +574,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static R5: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:242:1"}, {"sha": "1810600b7851492ada96392551904286c04dbccb", "filename": "tests/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -86,7 +86,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type `Never`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n@@ -108,7 +108,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n-   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type Never\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type `Never`\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:98:77"}, {"sha": "fb40babb0b9c3ac248c5ac12f5f960c7c02ce309", "filename": "tests/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -86,7 +86,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type `Never`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n@@ -108,7 +108,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n-   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type Never\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type `Never`\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:98:77"}, {"sha": "f1ad0f04d3dbe00bf4623cdaed2868bbf2b625a7", "filename": "tests/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -2,7 +2,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-uninhabit.rs:16:35\n    |\n LL | const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type `Bar`\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:19:1\n@@ -19,7 +19,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-uninhabit.rs:22:42\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type `Bar`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "b423edbdcec8df30781b2ed7df19579e9f6888f9", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -28,7 +28,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/validate_uninhabited_zsts.rs:21:42\n    |\n LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type empty::Void\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type `Void`\n \n warning: the type `empty::Empty` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:21:42"}, {"sha": "b423edbdcec8df30781b2ed7df19579e9f6888f9", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -28,7 +28,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/validate_uninhabited_zsts.rs:21:42\n    |\n LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type empty::Void\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type `Void`\n \n warning: the type `empty::Empty` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:21:42"}, {"sha": "2fe84245b3ef80bf1355a2b2db834f96e7ae0c84", "filename": "tests/ui/consts/issue-64506.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fissue-64506.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fissue-64506.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-64506.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -2,7 +2,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-64506.rs:16:22\n    |\n LL |     let x = unsafe { Foo { b: () }.a };\n-   |                      ^^^^^^^^^^^^^^^ constructing invalid value at .inner: encountered a value of uninhabited type AnonPipe\n+   |                      ^^^^^^^^^^^^^^^ constructing invalid value at .inner: encountered a value of uninhabited type `AnonPipe`\n \n error: aborting due to previous error\n "}, {"sha": "ca4e0f7aa02397b2eddf053780cd778b26e152d1", "filename": "tests/ui/consts/issue-83182.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fissue-83182.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fissue-83182.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-83182.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -4,11 +4,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n                HEX_DUMP\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to previous error\n "}, {"sha": "67797e6fb5a85331d398fb8b39a510864b00884b", "filename": "tests/ui/consts/issue-miri-1910.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -3,8 +3,6 @@ error[E0080]: evaluation of constant value failed\n    |\n    = note: unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n note: inside `std::ptr::read::<u8>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n note: inside `ptr::const_ptr::<impl *const u8>::read`\n@@ -14,6 +12,8 @@ note: inside `C`\n    |\n LL |     (&foo as *const _ as *const u8).add(one_and_a_half_pointers).read();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to previous error\n "}, {"sha": "d97097d352a6430122c8dec09f2f3501eb1e46c3", "filename": "tests/ui/consts/miri_unleashed/assoc_const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,4 +1,4 @@\n-error[E0080]: evaluation of `<std::string::String as Bar<std::vec::Vec<u32>, std::string::String>>::F` failed\n+error[E0080]: evaluation of `<String as Bar<Vec<u32>, String>>::F` failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n    = note: calling non-const function `<Vec<u32> as Drop>::drop`"}, {"sha": "adb1f8bf3ec55d1703a26823f14c12a247a8d82a", "filename": "tests/ui/consts/miri_unleashed/raw_mutable_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -3,6 +3,6 @@\n use std::cell::UnsafeCell;\n \n const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-//~^ ERROR: untyped pointers are not allowed in constant\n+//~^ ERROR: unsupported untyped pointer in constant\n \n fn main() {}"}, {"sha": "5acdcdd95e8e35e52a455a48971f9d39a61633b0", "filename": "tests/ui/consts/miri_unleashed/raw_mutable_const.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,8 +1,10 @@\n-error: untyped pointers are not allowed in constant\n+error: unsupported untyped pointer in constant\n   --> $DIR/raw_mutable_const.rs:5:1\n    |\n LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: memory only reachable via raw pointers is not supported\n \n warning: skipping const checks\n    |"}, {"sha": "fcfb9fbb3f8c0fb4ebd45293aa02e4058406d6a9", "filename": "tests/ui/consts/missing_span_in_backtrace.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fmissing_span_in_backtrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fmissing_span_in_backtrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmissing_span_in_backtrace.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -3,8 +3,6 @@ error[E0080]: evaluation of constant value failed\n    |\n    = note: unable to copy parts of a pointer from memory at ALLOC_ID\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n note: inside `std::ptr::read::<MaybeUninit<MaybeUninit<u8>>>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n note: inside `mem::swap_simple::<MaybeUninit<MaybeUninit<u8>>>`\n@@ -22,6 +20,8 @@ note: inside `X`\n 20 | |             mem::size_of::<&i32>(),\n 21 | |         );\n    | |_________^\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to previous error\n "}, {"sha": "97ff6efdd791c4eb9e3cb4af5b2cfc97ccaaeb98", "filename": "tests/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -27,31 +27,31 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:37:14\n    |\n LL |     unsafe { ptr_offset_from(ptr, ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:44:14\n    |\n LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: 0x8[noalloc] is a dangling pointer (it has no provenance)\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: 0x8[noalloc] is a dangling pointer (it has no provenance)\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:53:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc17 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: alloc17 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:62:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:70:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: alloc23 has size 4, so pointer at offset 10 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:79:14\n@@ -86,7 +86,7 @@ LL |     unsafe { ptr_offset_from_unsigned(ptr2, ptr1) }\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds `offset_from`: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset_from`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -99,7 +99,7 @@ LL |     unsafe { ptr2.offset_from(ptr1) }\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds `offset_from`: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset_from`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL"}, {"sha": "fc774be54dff3814b3a09083cf900a4237f26331", "filename": "tests/ui/consts/raw-ptr-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fraw-ptr-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fraw-ptr-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fraw-ptr-const.rs?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -3,6 +3,6 @@\n // could also be allowed.\n \n const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;\n-//~^ ERROR untyped pointers are not allowed in constant\n+//~^ ERROR unsupported untyped pointer in constant\n \n fn main() {}"}, {"sha": "82f782fab7f548bb68c2fd7e070ecd65562d461e", "filename": "tests/ui/consts/raw-ptr-const.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fraw-ptr-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fconsts%2Fraw-ptr-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fraw-ptr-const.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -1,8 +1,10 @@\n-error: untyped pointers are not allowed in constant\n+error: unsupported untyped pointer in constant\n   --> $DIR/raw-ptr-const.rs:5:1\n    |\n LL | const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: memory only reachable via raw pointers is not supported\n \n error: aborting due to previous error\n "}, {"sha": "2fba94d07401c5994b4db8e82f964e68f94247f6", "filename": "tests/ui/numbers-arithmetic/issue-8460-const.noopt.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.noopt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.noopt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.noopt.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -76,37 +76,37 @@ error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:35:36\n    |\n LL |     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^^ attempt to compute the remainder of `isize::MIN % -1_isize`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^^ attempt to compute `isize::MIN % -1_isize`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:37:36\n    |\n LL |     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^ attempt to compute the remainder of `i8::MIN % -1_i8`, which would overflow\n+   |                                    ^^^^^^^^^^^^ attempt to compute `i8::MIN % -1_i8`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:39:36\n    |\n LL |     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i16::MIN % -1_i16`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i16::MIN % -1_i16`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:41:36\n    |\n LL |     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i32::MIN % -1_i32`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:43:36\n    |\n LL |     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:45:36\n    |\n LL |     assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^ attempt to compute the remainder of `i128::MIN % -1_i128`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^ attempt to compute `i128::MIN % -1_i128`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:47:36"}, {"sha": "2fba94d07401c5994b4db8e82f964e68f94247f6", "filename": "tests/ui/numbers-arithmetic/issue-8460-const.opt.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -76,37 +76,37 @@ error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:35:36\n    |\n LL |     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^^ attempt to compute the remainder of `isize::MIN % -1_isize`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^^ attempt to compute `isize::MIN % -1_isize`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:37:36\n    |\n LL |     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^ attempt to compute the remainder of `i8::MIN % -1_i8`, which would overflow\n+   |                                    ^^^^^^^^^^^^ attempt to compute `i8::MIN % -1_i8`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:39:36\n    |\n LL |     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i16::MIN % -1_i16`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i16::MIN % -1_i16`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:41:36\n    |\n LL |     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i32::MIN % -1_i32`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:43:36\n    |\n LL |     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:45:36\n    |\n LL |     assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^ attempt to compute the remainder of `i128::MIN % -1_i128`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^ attempt to compute `i128::MIN % -1_i128`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:47:36"}, {"sha": "2fba94d07401c5994b4db8e82f964e68f94247f6", "filename": "tests/ui/numbers-arithmetic/issue-8460-const.opt_with_overflow_checks.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt_with_overflow_checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt_with_overflow_checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt_with_overflow_checks.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -76,37 +76,37 @@ error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:35:36\n    |\n LL |     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^^ attempt to compute the remainder of `isize::MIN % -1_isize`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^^ attempt to compute `isize::MIN % -1_isize`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:37:36\n    |\n LL |     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^ attempt to compute the remainder of `i8::MIN % -1_i8`, which would overflow\n+   |                                    ^^^^^^^^^^^^ attempt to compute `i8::MIN % -1_i8`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:39:36\n    |\n LL |     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i16::MIN % -1_i16`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i16::MIN % -1_i16`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:41:36\n    |\n LL |     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i32::MIN % -1_i32`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:43:36\n    |\n LL |     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:45:36\n    |\n LL |     assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^ attempt to compute the remainder of `i128::MIN % -1_i128`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^ attempt to compute `i128::MIN % -1_i128`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:47:36"}, {"sha": "9260930473fa83a80029ff47826dce436e6a0bbb", "filename": "tests/ui/statics/uninhabited-static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fstatics%2Funinhabited-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f83717cf768adb0b0dfe23b8eecf2b259eec354/tests%2Fui%2Fstatics%2Funinhabited-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstatics%2Funinhabited-static.stderr?ref=4f83717cf768adb0b0dfe23b8eecf2b259eec354", "patch": "@@ -47,7 +47,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/uninhabited-static.rs:12:31\n    |\n LL | static VOID2: Void = unsafe { std::mem::transmute(()) };\n-   |                               ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Void\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type `Void`\n \n warning: the type `Void` does not permit zero-initialization\n   --> $DIR/uninhabited-static.rs:12:31\n@@ -66,7 +66,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/uninhabited-static.rs:16:32\n    |\n LL | static NEVER2: Void = unsafe { std::mem::transmute(()) };\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Void\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type `Void`\n \n warning: the type `Void` does not permit zero-initialization\n   --> $DIR/uninhabited-static.rs:16:32"}]}