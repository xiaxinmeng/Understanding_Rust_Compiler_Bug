{"sha": "3694f42b8c6e930054986061cac5d486a303bc9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2OTRmNDJiOGM2ZTkzMDA1NDk4NjA2MWNhYzVkNDg2YTMwM2JjOWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-23T00:12:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-25T11:09:13Z"}, "message": "Move checking of whether fields are Sized or not into wf / trait code.", "tree": {"sha": "1bdd7d86e2c8525585a46967753aaaf16b9f553f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bdd7d86e2c8525585a46967753aaaf16b9f553f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3694f42b8c6e930054986061cac5d486a303bc9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3694f42b8c6e930054986061cac5d486a303bc9d", "html_url": "https://github.com/rust-lang/rust/commit/3694f42b8c6e930054986061cac5d486a303bc9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3694f42b8c6e930054986061cac5d486a303bc9d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9243575543e24777fbad230de921eeffc1f210f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9243575543e24777fbad230de921eeffc1f210f", "html_url": "https://github.com/rust-lang/rust/commit/e9243575543e24777fbad230de921eeffc1f210f"}], "stats": {"total": 225, "additions": 100, "deletions": 125}, "files": [{"sha": "ed3fce775f31e7aa8d4a652d2299df608a2e37c0", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3694f42b8c6e930054986061cac5d486a303bc9d/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3694f42b8c6e930054986061cac5d486a303bc9d/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=3694f42b8c6e930054986061cac5d486a303bc9d", "patch": "@@ -59,6 +59,7 @@ CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n DEPS_core :=\n+DEPS_libc := core\n DEPS_rlibc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc"}, {"sha": "893038cd509ec1332ec7b0612ac8d1a0b667a916", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=3694f42b8c6e930054986061cac5d486a303bc9d", "patch": "@@ -79,6 +79,8 @@\n #![allow(missing_doc)]\n #![allow(non_snake_case)]\n \n+extern crate core;\n+\n #[cfg(test)] extern crate std;\n #[cfg(test)] extern crate test;\n #[cfg(test)] extern crate native;"}, {"sha": "36ba28dfc2a806456c6aaea1a83f0f07dcf15557", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=3694f42b8c6e930054986061cac5d486a303bc9d", "patch": "@@ -58,8 +58,6 @@ register_diagnostics!(\n     E0039,\n     E0040,\n     E0041,\n-    E0042,\n-    E0043,\n     E0044,\n     E0045,\n     E0046,\n@@ -92,7 +90,6 @@ register_diagnostics!(\n     E0075,\n     E0076,\n     E0077,\n-    E0078,\n     E0079,\n     E0080,\n     E0081,"}, {"sha": "9d66108cfc99051f2073cba36fb46a36f41afa75", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=3694f42b8c6e930054986061cac5d486a303bc9d", "patch": "@@ -80,7 +80,10 @@ pub enum ObligationCauseCode {\n \n     // Captures of variable the given id by a closure (span is the\n     // span of the closure)\n-    ClosureCapture(ast::NodeId, Span)\n+    ClosureCapture(ast::NodeId, Span),\n+\n+    // Types of fields (other than the last) in a struct must be sized.\n+    FieldSized,\n }\n \n pub type Obligations = subst::VecPerParamSpace<Obligation>;"}, {"sha": "c7be2430cc98da5e1d4cffb36881bf5e6ee579e6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3694f42b8c6e930054986061cac5d486a303bc9d", "patch": "@@ -381,17 +381,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-struct CheckItemSizedTypesVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemSizedTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n-        check_item_sized(self.ccx, i);\n-        visit::walk_item(self, i);\n-    }\n-}\n-\n pub fn check_item_types(ccx: &CrateCtxt) {\n     let krate = ccx.tcx.map.krate();\n     let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n@@ -405,9 +394,6 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n     visit::walk_crate(&mut visit, krate);\n \n     ccx.tcx.sess.abort_if_errors();\n-\n-    let mut visit = CheckItemSizedTypesVisitor { ccx: ccx };\n-    visit::walk_crate(&mut visit, krate);\n }\n \n fn check_bare_fn(ccx: &CrateCtxt,\n@@ -670,33 +656,6 @@ fn check_for_field_shadowing(tcx: &ty::ctxt,\n     }\n }\n \n-fn check_fields_sized(tcx: &ty::ctxt,\n-                      struct_def: &ast::StructDef) {\n-    let len = struct_def.fields.len();\n-    if len == 0 {\n-        return;\n-    }\n-    for f in struct_def.fields.slice_to(len - 1).iter() {\n-        let t = ty::node_id_to_type(tcx, f.node.id);\n-        if !ty::type_is_sized(tcx, t) {\n-            match f.node.kind {\n-                ast::NamedField(ident, _) => {\n-                    span_err!(tcx.sess, f.span, E0042,\n-                        \"type `{}` is dynamically sized. \\\n-                         dynamically sized types may only \\\n-                         appear as the type of the final \\\n-                         field in a struct\",\n-                        token::get_ident(ident));\n-                }\n-                ast::UnnamedField(_) => {\n-                    span_err!(tcx.sess, f.span, E0043,\n-                        \"dynamically sized type in field\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n@@ -711,24 +670,6 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item_sized(ccx: &CrateCtxt, it: &ast::Item) {\n-    debug!(\"check_item(it.id={}, it.ident={})\",\n-           it.id,\n-           ty::item_path_str(ccx.tcx, local_def(it.id)));\n-    let _indenter = indenter();\n-\n-    match it.node {\n-        ast::ItemEnum(ref enum_definition, _) => {\n-            check_enum_variants_sized(ccx,\n-                                      enum_definition.variants.as_slice());\n-        }\n-        ast::ItemStruct(..) => {\n-            check_fields_sized(ccx.tcx, &*ccx.tcx.map.expect_struct(it.id));\n-        }\n-        _ => {}\n-    }\n-}\n-\n pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n@@ -4946,39 +4887,6 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n-\n-pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n-                                 vs: &[P<ast::Variant>]) {\n-    for v in vs.iter() {\n-        match v.node.kind {\n-            ast::TupleVariantKind(ref args) if args.len() > 0 => {\n-                let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n-                let arg_tys: Vec<ty::t> = ty::ty_fn_args(ctor_ty).iter().map(|a| *a).collect();\n-                let len = arg_tys.len();\n-                if len == 0 {\n-                    return;\n-                }\n-                for (i, t) in arg_tys.slice_to(len - 1).iter().enumerate() {\n-                    // Allow the last field in an enum to be unsized.\n-                    // We want to do this so that we can support smart pointers.\n-                    // A struct value with an unsized final field is itself\n-                    // unsized and we must track this in the type system.\n-                    if !ty::type_is_sized(ccx.tcx, *t) {\n-                        span_err!(ccx.tcx.sess, args.get(i).ty.span, E0078,\n-                            \"type `{}` is dynamically sized. dynamically sized types may only \\\n-                             appear as the final type in a variant\",\n-                             ppaux::ty_to_string(ccx.tcx, *t));\n-                    }\n-                }\n-            },\n-            ast::StructVariantKind(ref struct_def) => {\n-                check_fields_sized(ccx.tcx, &**struct_def)\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n pub fn check_enum_variants(ccx: &CrateCtxt,\n                            sp: Span,\n                            vs: &[P<ast::Variant>],"}, {"sha": "bcbcebc3f59279afd67f52bcbaf1dbc342f4bc6b", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=3694f42b8c6e930054986061cac5d486a303bc9d", "patch": "@@ -406,5 +406,10 @@ fn note_obligation_cause(fcx: &FnCtxt,\n                        name,\n                        trait_name);\n         }\n+        traits::FieldSized => {\n+            span_note!(tcx.sess, obligation.cause.span,\n+                       \"only the last field of a struct or enum variant \\\n+                       may have a dynamically sized type\")\n+        }\n     }\n }"}, {"sha": "67f93feae41971affeb060707fe4b8af60f1d19a", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 82, "deletions": 22, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=3694f42b8c6e930054986061cac5d486a303bc9d", "patch": "@@ -59,7 +59,6 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                item.id,\n                ty::item_path_str(ccx.tcx, local_def(item.id)));\n \n-        let ccx = self.ccx;\n         match item.node {\n             ast::ItemImpl(..) => {\n                 self.check_impl(item);\n@@ -70,26 +69,14 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemStatic(..) => {\n                 self.check_item_type(item);\n             }\n-            ast::ItemStruct(..) => {\n+            ast::ItemStruct(ref struct_def, _) => {\n                 self.check_type_defn(item, |fcx| {\n-                    ty::struct_fields(ccx.tcx, local_def(item.id),\n-                                      &fcx.inh.param_env.free_substs)\n-                        .iter()\n-                        .map(|f| f.mt.ty)\n-                        .collect()\n+                    vec![struct_variant(fcx, &**struct_def)]\n                 });\n             }\n-            ast::ItemEnum(..) => {\n+            ast::ItemEnum(ref enum_def, _) => {\n                 self.check_type_defn(item, |fcx| {\n-                    ty::substd_enum_variants(ccx.tcx, local_def(item.id),\n-                                             &fcx.inh.param_env.free_substs)\n-                        .iter()\n-                        .flat_map(|variant| {\n-                            variant.args\n-                                .iter()\n-                                .map(|&arg_ty| arg_ty)\n-                        })\n-                        .collect()\n+                    enum_variants(fcx, enum_def)\n                 });\n             }\n             _ => {}\n@@ -116,22 +103,39 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn check_type_defn(&mut self,\n                        item: &ast::Item,\n-                       lookup_fields: |&FnCtxt| -> Vec<ty::t>)\n+                       lookup_fields: |&FnCtxt| -> Vec<AdtVariant>)\n     {\n         /*!\n          * In a type definition, we check that to ensure that the types of the fields are\n          * well-formed.\n          */\n \n         self.with_fcx(self.ccx, item, |this, fcx| {\n-            let field_tys = lookup_fields(fcx);\n+            let variants = lookup_fields(fcx);\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n-            for &ty in field_tys.iter() {\n-                // Regions are checked below.\n-                bounds_checker.check_traits_in_ty(ty);\n+            for variant in variants.iter() {\n+                for field in variant.fields.iter() {\n+                    // Regions are checked below.\n+                    bounds_checker.check_traits_in_ty(field.ty);\n+                }\n+\n+                // For DST, all intermediate types must be sized.\n+                if variant.fields.len() > 0 {\n+                    for field in variant.fields.init().iter() {\n+                        let cause = traits::ObligationCause::new(field.span, traits::FieldSized);\n+                        fcx.register_obligation(\n+                            traits::obligation_for_builtin_bound(fcx.tcx(),\n+                                                                 cause,\n+                                                                 field.ty,\n+                                                                 ty::BoundSized));\n+                    }\n+                }\n             }\n \n+            let field_tys: Vec<ty::t> =\n+                variants.iter().flat_map(|v| v.fields.iter().map(|f| f.ty)).collect();\n+\n             regionck::regionck_ensure_component_tys_wf(\n                 fcx, item.span, field_tys.as_slice());\n         });\n@@ -381,6 +385,62 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// ADT\n+\n+struct AdtVariant {\n+    fields: Vec<AdtField>,\n+}\n+\n+struct AdtField {\n+    ty: ty::t,\n+    span: Span,\n+}\n+\n+fn struct_variant(fcx: &FnCtxt, struct_def: &ast::StructDef) -> AdtVariant {\n+    let fields =\n+        struct_def.fields\n+        .iter()\n+        .map(|field| {\n+            let field_ty = ty::node_id_to_type(fcx.tcx(), field.node.id);\n+            let field_ty = field_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            AdtField { ty: field_ty, span: field.span }\n+        })\n+        .collect();\n+    AdtVariant { fields: fields }\n+}\n+\n+fn enum_variants(fcx: &FnCtxt, enum_def: &ast::EnumDef) -> Vec<AdtVariant> {\n+    enum_def.variants.iter()\n+        .map(|variant| {\n+            match variant.node.kind {\n+                ast::TupleVariantKind(ref args) if args.len() > 0 => {\n+                    let ctor_ty = ty::node_id_to_type(fcx.tcx(), variant.node.id);\n+                    let arg_tys = ty::ty_fn_args(ctor_ty);\n+                    AdtVariant {\n+                        fields: args.iter().enumerate().map(|(index, arg)| {\n+                            let arg_ty = arg_tys[index];\n+                            let arg_ty = arg_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+                            AdtField {\n+                                ty: arg_ty,\n+                                span: arg.ty.span\n+                            }\n+                        }).collect()\n+                    }\n+                }\n+                ast::TupleVariantKind(_) => {\n+                    AdtVariant {\n+                        fields: Vec::new()\n+                    }\n+                }\n+                ast::StructVariantKind(ref struct_def) => {\n+                    struct_variant(fcx, &**struct_def)\n+                }\n+            }\n+        })\n+        .collect()\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Special drop trait checking\n "}, {"sha": "0691ad0de732315ecae9bfe702a8f9476c5fc203", "filename": "src/test/compile-fail/regions-enum-not-wf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs?ref=3694f42b8c6e930054986061cac5d486a303bc9d", "patch": "@@ -10,7 +10,6 @@\n \n // Various examples of structs whose fields are not well-formed.\n \n-#![no_std]\n #![allow(dead_code)]\n \n enum Ref1<'a, T> { //~ ERROR the parameter type `T` may not live long enough"}, {"sha": "41196b60c8eba261273d0517708fc01401324a44", "filename": "src/test/compile-fail/unsized5.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3694f42b8c6e930054986061cac5d486a303bc9d/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized5.rs?ref=3694f42b8c6e930054986061cac5d486a303bc9d", "patch": "@@ -12,25 +12,25 @@\n // Test `Sized?` types not allowed in fields (except the last one).\n \n struct S1<Sized? X> {\n-    f1: X, //~ ERROR type `f1` is dynamically sized. dynamically sized types may only appear as the\n+    f1: X, //~ ERROR `core::kinds::Sized` is not implemented\n     f2: int,\n }\n struct S2<Sized? X> {\n     f: int,\n-    g: X, //~ ERROR type `g` is dynamically sized. dynamically sized types may only appear as the ty\n+    g: X, //~ ERROR `core::kinds::Sized` is not implemented\n     h: int,\n }\n struct S3 {\n-    f: str, //~ ERROR type `f` is dynamically sized. dynamically sized types may only appear\n+    f: str, //~ ERROR `core::kinds::Sized` is not implemented\n     g: [uint]\n }\n struct S4 {\n-    f: str, //~ ERROR type `f` is dynamically sized. dynamically sized types may only appear\n+    f: str, //~ ERROR `core::kinds::Sized` is not implemented\n     g: uint\n }\n enum E<Sized? X> {\n-    V1(X, int), //~ERROR type `X` is dynamically sized. dynamically sized types may only appear as t\n-    V2{f1: X, f: int}, //~ERROR type `f1` is dynamically sized. dynamically sized types may only app\n+    V1(X, int), //~ERROR `core::kinds::Sized` is not implemented\n+    V2{f1: X, f: int}, //~ERROR `core::kinds::Sized` is not implemented\n }\n \n pub fn main() {"}]}