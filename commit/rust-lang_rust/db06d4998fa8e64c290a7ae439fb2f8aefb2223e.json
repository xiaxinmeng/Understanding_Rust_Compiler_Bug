{"sha": "db06d4998fa8e64c290a7ae439fb2f8aefb2223e", "node_id": "C_kwDOAAsO6NoAKGRiMDZkNDk5OGZhOGU2NGMyOTBhN2FlNDM5ZmIyZjhhZWZiMjIyM2U", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-06T18:58:41Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-07T14:40:23Z"}, "message": "implement simd_cast, simd_as", "tree": {"sha": "125e7e4497b413e392259db459eaff091fae60c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/125e7e4497b413e392259db459eaff091fae60c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db06d4998fa8e64c290a7ae439fb2f8aefb2223e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db06d4998fa8e64c290a7ae439fb2f8aefb2223e", "html_url": "https://github.com/rust-lang/rust/commit/db06d4998fa8e64c290a7ae439fb2f8aefb2223e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db06d4998fa8e64c290a7ae439fb2f8aefb2223e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "594a70a28901efa14c8119242c5692027dbd8eb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/594a70a28901efa14c8119242c5692027dbd8eb9", "html_url": "https://github.com/rust-lang/rust/commit/594a70a28901efa14c8119242c5692027dbd8eb9"}], "stats": {"total": 187, "additions": 161, "deletions": 26}, "files": [{"sha": "2f29ec4553d48cdf8de1b01ecaa0ffadf440707e", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/db06d4998fa8e64c290a7ae439fb2f8aefb2223e/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db06d4998fa8e64c290a7ae439fb2f8aefb2223e/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=db06d4998fa8e64c290a7ae439fb2f8aefb2223e", "patch": "@@ -515,6 +515,45 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.write_immediate(*val, &dest.into())?;\n                 }\n             }\n+            #[rustfmt::skip]\n+            \"simd_cast\" | \"simd_as\" => {\n+                let &[ref op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, op_len);\n+\n+                let safe_cast = intrinsic_name == \"simd_as\";\n+\n+                for i in 0..dest_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = match (op.layout.ty.kind(), dest.layout.ty.kind()) {\n+                        // Int-to-(int|float): always safe\n+                        (ty::Int(_) | ty::Uint(_), ty::Int(_) | ty::Uint(_) | ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-float: always safe\n+                        (ty::Float(_), ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in safe mode\n+                        (ty::Float(_), ty::Int(_) | ty::Uint(_)) if safe_cast =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in unchecked mode\n+                        (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar()?.to_f32()?, dest.layout.ty)?.into(),\n+                        (ty::Float(FloatTy::F64), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar()?.to_f64()?, dest.layout.ty)?.into(),\n+                        _ =>\n+                            throw_unsup_format!(\n+                                \"Unsupported SIMD cast from element type {} to {}\",\n+                                op.layout.ty,\n+                                dest.layout.ty\n+                            ),\n+                    };\n+                    this.write_immediate(val, &dest.into())?;\n+                }\n+            }\n \n             // Atomic operations\n             \"atomic_load\" => this.atomic_load(args, dest, AtomicReadOp::SeqCst)?,"}, {"sha": "88d5a7a466f026cdccece98809f13ccc7695ee96", "filename": "tests/compile-fail/intrinsics/simd-float-to-int.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db06d4998fa8e64c290a7ae439fb2f8aefb2223e/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-float-to-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db06d4998fa8e64c290a7ae439fb2f8aefb2223e/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-float-to-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-float-to-int.rs?ref=db06d4998fa8e64c290a7ae439fb2f8aefb2223e", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern: cannot be represented in target type `i32`\n+#![feature(portable_simd)]\n+use std::simd::*;\n+\n+fn main() { unsafe {\n+    let _x : i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked();\n+} }"}, {"sha": "022e8c91f970dee08f2d824cdbbce49b991eb6a4", "filename": "tests/run-pass/portable-simd.rs", "status": "modified", "additions": 115, "deletions": 26, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/db06d4998fa8e64c290a7ae439fb2f8aefb2223e/tests%2Frun-pass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db06d4998fa8e64c290a7ae439fb2f8aefb2223e/tests%2Frun-pass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fportable-simd.rs?ref=db06d4998fa8e64c290a7ae439fb2f8aefb2223e", "patch": "@@ -13,17 +13,16 @@ fn simd_ops_f32() {\n     assert_eq!(a % b, f32x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f32x4::from_array([1.0, 2.0, 3.0, 4.0]));\n \n-    // FIXME use Mask::from_array once simd_cast is implemented.\n-    assert_eq!(a.lanes_eq(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([0, -1, 0, 0])));\n-    assert_eq!(a.lanes_ne(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([-1, 0, -1, -1])));\n-    assert_eq!(a.lanes_le(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([0, -1, -1, 0])));\n-    assert_eq!(a.lanes_lt(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([0, 0, -1, 0])));\n-    assert_eq!(a.lanes_ge(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([-1, -1, 0, -1])));\n-    assert_eq!(a.lanes_gt(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([-1, 0, 0, -1])));\n+    assert_eq!(a.lanes_eq(f32x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n+    assert_eq!(a.lanes_ne(f32x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n+    assert_eq!(a.lanes_le(f32x4::splat(5.0) * b), Mask::from_array([false, true, true, false]));\n+    assert_eq!(a.lanes_lt(f32x4::splat(5.0) * b), Mask::from_array([false, false, true, false]));\n+    assert_eq!(a.lanes_ge(f32x4::splat(5.0) * b), Mask::from_array([true, true, false, true]));\n+    assert_eq!(a.lanes_gt(f32x4::splat(5.0) * b), Mask::from_array([true, false, false, true]));\n \n     assert_eq!(a.horizontal_sum(), 40.0);\n     assert_eq!(b.horizontal_sum(), 2.0);\n-    assert_eq!(a.horizontal_product(), 100.0*100.0);\n+    assert_eq!(a.horizontal_product(), 100.0 * 100.0);\n     assert_eq!(b.horizontal_product(), -24.0);\n }\n \n@@ -39,17 +38,16 @@ fn simd_ops_f64() {\n     assert_eq!(a % b, f64x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f64x4::from_array([1.0, 2.0, 3.0, 4.0]));\n \n-    // FIXME use Mask::from_array once simd_cast is implemented.\n-    assert_eq!(a.lanes_eq(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([0, -1, 0, 0])));\n-    assert_eq!(a.lanes_ne(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([-1, 0, -1, -1])));\n-    assert_eq!(a.lanes_le(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([0, -1, -1, 0])));\n-    assert_eq!(a.lanes_lt(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([0, 0, -1, 0])));\n-    assert_eq!(a.lanes_ge(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([-1, -1, 0, -1])));\n-    assert_eq!(a.lanes_gt(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([-1, 0, 0, -1])));\n+    assert_eq!(a.lanes_eq(f64x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n+    assert_eq!(a.lanes_ne(f64x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n+    assert_eq!(a.lanes_le(f64x4::splat(5.0) * b), Mask::from_array([false, true, true, false]));\n+    assert_eq!(a.lanes_lt(f64x4::splat(5.0) * b), Mask::from_array([false, false, true, false]));\n+    assert_eq!(a.lanes_ge(f64x4::splat(5.0) * b), Mask::from_array([true, true, false, true]));\n+    assert_eq!(a.lanes_gt(f64x4::splat(5.0) * b), Mask::from_array([true, false, false, true]));\n \n     assert_eq!(a.horizontal_sum(), 40.0);\n     assert_eq!(b.horizontal_sum(), 2.0);\n-    assert_eq!(a.horizontal_product(), 100.0*100.0);\n+    assert_eq!(a.horizontal_product(), 100.0 * 100.0);\n     assert_eq!(b.horizontal_product(), -24.0);\n }\n \n@@ -71,13 +69,12 @@ fn simd_ops_i32() {\n     assert_eq!(b | i32x4::splat(2), i32x4::from_array([3, 2, 3, -2]));\n     assert_eq!(b ^ i32x4::splat(2), i32x4::from_array([3, 0, 1, -2]));\n \n-    // FIXME use Mask::from_array once simd_cast is implemented.\n-    assert_eq!(a.lanes_eq(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([0, -1, 0, 0])));\n-    assert_eq!(a.lanes_ne(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([-1, 0, -1, -1])));\n-    assert_eq!(a.lanes_le(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([0, -1, -1, 0])));\n-    assert_eq!(a.lanes_lt(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([0, 0, -1, 0])));\n-    assert_eq!(a.lanes_ge(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([-1, -1, 0, -1])));\n-    assert_eq!(a.lanes_gt(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([-1, 0, 0, -1])));\n+    assert_eq!(a.lanes_eq(i32x4::splat(5) * b), Mask::from_array([false, true, false, false]));\n+    assert_eq!(a.lanes_ne(i32x4::splat(5) * b), Mask::from_array([true, false, true, true]));\n+    assert_eq!(a.lanes_le(i32x4::splat(5) * b), Mask::from_array([false, true, true, false]));\n+    assert_eq!(a.lanes_lt(i32x4::splat(5) * b), Mask::from_array([false, false, true, false]));\n+    assert_eq!(a.lanes_ge(i32x4::splat(5) * b), Mask::from_array([true, true, false, true]));\n+    assert_eq!(a.lanes_gt(i32x4::splat(5) * b), Mask::from_array([true, false, false, true]));\n \n     assert_eq!(a.horizontal_and(), 10);\n     assert_eq!(b.horizontal_and(), 0);\n@@ -87,10 +84,94 @@ fn simd_ops_i32() {\n     assert_eq!(b.horizontal_xor(), -4);\n     assert_eq!(a.horizontal_sum(), 40);\n     assert_eq!(b.horizontal_sum(), 2);\n-    assert_eq!(a.horizontal_product(), 100*100);\n+    assert_eq!(a.horizontal_product(), 100 * 100);\n     assert_eq!(b.horizontal_product(), -24);\n }\n \n+fn simd_mask() {\n+    let intmask = Mask::from_int(i32x4::from_array([0, -1, 0, 0]));\n+    assert_eq!(intmask, Mask::from_array([false, true, false, false]));\n+    assert_eq!(intmask.to_array(), [false, true, false, false]);\n+}\n+\n+fn simd_cast() {\n+    // between integer types\n+    assert_eq!(i32x4::from_array([1, 2, 3, -4]), i16x4::from_array([1, 2, 3, -4]).cast());\n+    assert_eq!(i16x4::from_array([1, 2, 3, -4]), i32x4::from_array([1, 2, 3, -4]).cast());\n+    assert_eq!(i32x4::from_array([1, -1, 3, 4]), u64x4::from_array([1, u64::MAX, 3, 4]).cast());\n+\n+    // float -> int\n+    assert_eq!(\n+        i8x4::from_array([127, -128, 127, -128]),\n+        f32x4::from_array([127.99, -128.99, 999.0, -999.0]).cast()\n+    );\n+    assert_eq!(\n+        i32x4::from_array([0, 1, -1, 2147483520]),\n+        f32x4::from_array([\n+            -0.0,\n+            /*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd),\n+            /*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd),\n+            2147483520.0\n+        ])\n+        .cast()\n+    );\n+    assert_eq!(\n+        i32x8::from_array([i32::MAX, i32::MIN, i32::MAX, i32::MIN, i32::MAX, i32::MIN, 0, 0]),\n+        f32x8::from_array([\n+            2147483648.0f32,\n+            -2147483904.0f32,\n+            f32::MAX,\n+            f32::MIN,\n+            f32::INFINITY,\n+            f32::NEG_INFINITY,\n+            f32::NAN,\n+            -f32::NAN,\n+        ])\n+        .cast()\n+    );\n+\n+    // int -> float\n+    assert_eq!(\n+        f32x4::from_array([\n+            -2147483648.0,\n+            /*0x1.26580cp+30*/ f32::from_bits(0x4e932c06),\n+            16777220.0,\n+            -16777220.0,\n+        ]),\n+        i32x4::from_array([-2147483647i32, 1234567890i32, 16777219i32, -16777219i32]).cast()\n+    );\n+\n+    // float -> float\n+    assert_eq!(\n+        f32x4::from_array([f32::INFINITY, f32::INFINITY, f32::NEG_INFINITY, f32::NEG_INFINITY]),\n+        f64x4::from_array([f64::MAX, f64::INFINITY, f64::MIN, f64::NEG_INFINITY]).cast()\n+    );\n+\n+    // unchecked casts\n+    unsafe {\n+        assert_eq!(\n+            i32x4::from_array([0, 1, -1, 2147483520]),\n+            f32x4::from_array([\n+                -0.0,\n+                /*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd),\n+                /*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd),\n+                2147483520.0\n+            ])\n+            .to_int_unchecked()\n+        );\n+        assert_eq!(\n+            u64x4::from_array([0, 10000000000000000, u64::MAX - 2047, 9223372036854775808]),\n+            f64x4::from_array([\n+                -0.99999999999,\n+                1e16,\n+                (u64::MAX - 1024) as f64,\n+                9223372036854775808.0\n+            ])\n+            .to_int_unchecked()\n+        );\n+    }\n+}\n+\n fn simd_intrinsics() {\n     extern \"platform-intrinsic\" {\n         fn simd_eq<T, U>(x: T, y: T) -> U;\n@@ -112,14 +193,22 @@ fn simd_intrinsics() {\n         assert!(simd_reduce_all(i32x4::splat(-1)));\n         assert!(!simd_reduce_all(i32x2::from_array([0, -1])));\n \n-        assert_eq!(simd_select(i8x4::from_array([0, -1, -1, 0]), a, b), i32x4::from_array([1, 10, 10, 4]));\n-        assert_eq!(simd_select(i8x4::from_array([0, -1, -1, 0]), b, a), i32x4::from_array([10, 2, 10, 10]));\n+        assert_eq!(\n+            simd_select(i8x4::from_array([0, -1, -1, 0]), a, b),\n+            i32x4::from_array([1, 10, 10, 4])\n+        );\n+        assert_eq!(\n+            simd_select(i8x4::from_array([0, -1, -1, 0]), b, a),\n+            i32x4::from_array([10, 2, 10, 10])\n+        );\n     }\n }\n \n fn main() {\n+    simd_mask();\n     simd_ops_f32();\n     simd_ops_f64();\n     simd_ops_i32();\n+    simd_cast();\n     simd_intrinsics();\n }"}]}