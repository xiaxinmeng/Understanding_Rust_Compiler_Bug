{"sha": "b7820b28937ba875521a2525cf75223c80faf9f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ODIwYjI4OTM3YmE4NzU1MjFhMjUyNWNmNzUyMjNjODBmYWY5ZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-25T01:49:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-25T01:49:46Z"}, "message": "Auto merge of #64754 - Centril:rollup-iwtb5xd, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #64324 (rustc: Fix mixing crates with different `share_generics`)\n - #64428 (Error explanation e0524)\n - #64481 (A more explanatory thread local storage panic message)\n - #64599 (Rustdoc render async function re-export)\n - #64743 (Update cargo)\n - #64746 (Remove blanket silencing of \"type annotation needed\" errors)\n - #64753 (Don't emit explain with json short messages.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c22d390654ed86c407d5c5ed67489da0f2a5934d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c22d390654ed86c407d5c5ed67489da0f2a5934d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7820b28937ba875521a2525cf75223c80faf9f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7820b28937ba875521a2525cf75223c80faf9f2", "html_url": "https://github.com/rust-lang/rust/commit/b7820b28937ba875521a2525cf75223c80faf9f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7820b28937ba875521a2525cf75223c80faf9f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd473d7b554a82013913244da8aba1e22a002a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd473d7b554a82013913244da8aba1e22a002a9", "html_url": "https://github.com/rust-lang/rust/commit/dcd473d7b554a82013913244da8aba1e22a002a9"}, {"sha": "fa6dfc995e2b0719d874d0f29352657814ef0873", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa6dfc995e2b0719d874d0f29352657814ef0873", "html_url": "https://github.com/rust-lang/rust/commit/fa6dfc995e2b0719d874d0f29352657814ef0873"}], "stats": {"total": 1698, "additions": 1038, "deletions": 660}, "files": [{"sha": "73ebc8b4616f90a34071eced47c456f9cecb22cb", "filename": "Cargo.lock", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -269,6 +269,7 @@ version = \"0.40.0\"\n dependencies = [\n  \"atty\",\n  \"bytesize\",\n+ \"cargo-platform\",\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"clap\",\n@@ -278,7 +279,7 @@ dependencies = [\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n- \"env_logger\",\n+ \"env_logger 0.7.0\",\n  \"failure\",\n  \"filetime\",\n  \"flate2\",\n@@ -325,6 +326,13 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"cargo-platform\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"cargo-test-macro\"\n version = \"0.1.0\"\n@@ -526,7 +534,7 @@ name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n  \"diff\",\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"getopts\",\n  \"lazy_static 1.3.0\",\n  \"libc\",\n@@ -938,6 +946,19 @@ dependencies = [\n  \"termcolor\",\n ]\n \n+[[package]]\n+name = \"env_logger\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"39ecdb7dd54465526f0a56d666e3b2dd5f3a218665a030b6e4ad9e70fa95d8fa\"\n+dependencies = [\n+ \"atty\",\n+ \"humantime\",\n+ \"log\",\n+ \"regex\",\n+ \"termcolor\",\n+]\n+\n [[package]]\n name = \"error-chain\"\n version = \"0.12.0\"\n@@ -1339,9 +1360,9 @@ checksum = \"cd179ae861f0c2e53da70d892f5f3029f9594be0c41dc5269cd371691b1dc2f9\"\n \n [[package]]\n name = \"humantime\"\n-version = \"1.2.0\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ca7e5f2e110db35f93b837c81797f3714500b81d517bf20c431b16d3ca4f114\"\n+checksum = \"df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f\"\n dependencies = [\n  \"quick-error\",\n ]\n@@ -1866,7 +1887,7 @@ dependencies = [\n  \"chrono\",\n  \"clap\",\n  \"elasticlunr-rs\",\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"error-chain\",\n  \"handlebars\",\n  \"itertools 0.8.0\",\n@@ -1891,7 +1912,7 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"77d1f0ba4d1e6b86fa18e8853d026d7d76a97eb7eb5eb052ed80901e43b7fc10\"\n dependencies = [\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"failure\",\n  \"log\",\n  \"mdbook\",\n@@ -2084,7 +2105,7 @@ dependencies = [\n  \"colored\",\n  \"compiletest_rs\",\n  \"directories\",\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"getrandom\",\n  \"hex 0.3.2\",\n  \"log\",\n@@ -2493,7 +2514,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61\"\n dependencies = [\n  \"chrono\",\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"log\",\n ]\n \n@@ -2620,7 +2641,7 @@ dependencies = [\n  \"bitflags\",\n  \"clap\",\n  \"derive_more\",\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"humantime\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n@@ -2914,7 +2935,7 @@ dependencies = [\n  \"clippy_lints\",\n  \"crossbeam-channel\",\n  \"difference\",\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"failure\",\n  \"futures\",\n  \"heck\",\n@@ -2998,7 +3019,7 @@ name = \"rls-rustc\"\n version = \"0.6.0\"\n dependencies = [\n  \"clippy_lints\",\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"failure\",\n  \"futures\",\n  \"log\",\n@@ -3399,7 +3420,7 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"graphviz\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n@@ -3781,7 +3802,7 @@ dependencies = [\n  \"derive-new\",\n  \"diff\",\n  \"dirs\",\n- \"env_logger\",\n+ \"env_logger 0.6.2\",\n  \"failure\",\n  \"getopts\",\n  \"ignore\","}, {"sha": "1e05018007a8dd577271a24831fdd79fb1561168", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -2184,9 +2184,7 @@ impl<'a> LoweringContext<'a> {\n             match decl.output {\n                 FunctionRetTy::Ty(ref ty) => match in_band_ty_params {\n                     Some((def_id, _)) if impl_trait_return_allow => {\n-                        hir::Return(self.lower_ty(ty,\n-                            ImplTraitContext::OpaqueTy(Some(def_id))\n-                        ))\n+                        hir::Return(self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(def_id))))\n                     }\n                     _ => {\n                         hir::Return(self.lower_ty(ty, ImplTraitContext::disallowed()))"}, {"sha": "129cfc8bcb23f76d7b4b82608d30f3fc0914e487", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -988,7 +988,9 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         value.fold_with(&mut BottomUpFolder {\n             tcx,\n             ty_op: |ty| {\n-                if let ty::Opaque(def_id, substs) = ty.sty {\n+                if ty.references_error() {\n+                    return tcx.types.err;\n+                } else if let ty::Opaque(def_id, substs) = ty.sty {\n                     // Check that this is `impl Trait` type is\n                     // declared by `parent_def_id` -- i.e., one whose\n                     // value we are inferring.  At present, this is\n@@ -1155,6 +1157,15 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         );\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n+        for predicate in &bounds.predicates {\n+            if let ty::Predicate::Projection(projection) = &predicate {\n+                if projection.skip_binder().ty.references_error() {\n+                    // No point on adding these obligations since there's a type error involved.\n+                    return ty_var;\n+                }\n+            }\n+        }\n+\n         self.obligations.reserve(bounds.predicates.len());\n         for predicate in bounds.predicates {\n             // Change the predicate to refer to the type variable,"}, {"sha": "8b2bf55ccc1208f7bdf358ce8e508603b9e05a40", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 372, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,64 +1,10 @@\n-//! Resolution of mixing rlibs and dylibs\n+//! Type definitions for learning about the dependency formats of all upstream\n+//! crates (rlibs/dylibs/oh my).\n //!\n-//! When producing a final artifact, such as a dynamic library, the compiler has\n-//! a choice between linking an rlib or linking a dylib of all upstream\n-//! dependencies. The linking phase must guarantee, however, that a library only\n-//! show up once in the object file. For example, it is illegal for library A to\n-//! be statically linked to B and C in separate dylibs, and then link B and C\n-//! into a crate D (because library A appears twice).\n-//!\n-//! The job of this module is to calculate what format each upstream crate\n-//! should be used when linking each output type requested in this session. This\n-//! generally follows this set of rules:\n-//!\n-//!     1. Each library must appear exactly once in the output.\n-//!     2. Each rlib contains only one library (it's just an object file)\n-//!     3. Each dylib can contain more than one library (due to static linking),\n-//!        and can also bring in many dynamic dependencies.\n-//!\n-//! With these constraints in mind, it's generally a very difficult problem to\n-//! find a solution that's not \"all rlibs\" or \"all dylibs\". I have suspicions\n-//! that NP-ness may come into the picture here...\n-//!\n-//! The current selection algorithm below looks mostly similar to:\n-//!\n-//!     1. If static linking is required, then require all upstream dependencies\n-//!        to be available as rlibs. If not, generate an error.\n-//!     2. If static linking is requested (generating an executable), then\n-//!        attempt to use all upstream dependencies as rlibs. If any are not\n-//!        found, bail out and continue to step 3.\n-//!     3. Static linking has failed, at least one library must be dynamically\n-//!        linked. Apply a heuristic by greedily maximizing the number of\n-//!        dynamically linked libraries.\n-//!     4. Each upstream dependency available as a dynamic library is\n-//!        registered. The dependencies all propagate, adding to a map. It is\n-//!        possible for a dylib to add a static library as a dependency, but it\n-//!        is illegal for two dylibs to add the same static library as a\n-//!        dependency. The same dylib can be added twice. Additionally, it is\n-//!        illegal to add a static dependency when it was previously found as a\n-//!        dylib (and vice versa)\n-//!     5. After all dynamic dependencies have been traversed, re-traverse the\n-//!        remaining dependencies and add them statically (if they haven't been\n-//!        added already).\n-//!\n-//! While not perfect, this algorithm should help support use-cases such as leaf\n-//! dependencies being static while the larger tree of inner dependencies are\n-//! all dynamic. This isn't currently very well battle tested, so it will likely\n-//! fall short in some use cases.\n-//!\n-//! Currently, there is no way to specify the preference of linkage with a\n-//! particular library (other than a global dynamic/static switch).\n-//! Additionally, the algorithm is geared towards finding *any* solution rather\n-//! than finding a number of solutions (there are normally quite a few).\n-\n-use crate::hir::def_id::CrateNum;\n+//! For all the gory details, see the provider of the `dependency_formats`\n+//! query.\n \n use crate::session::config;\n-use crate::ty::TyCtxt;\n-use crate::middle::cstore::{self, DepKind};\n-use crate::middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n-use crate::util::nodemap::FxHashMap;\n-use rustc_target::spec::PanicStrategy;\n \n /// A list of dependencies for a certain crate type.\n ///\n@@ -71,324 +17,12 @@ pub type DependencyList = Vec<Linkage>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = FxHashMap<config::CrateType, DependencyList>;\n+pub type Dependencies = Vec<(config::CrateType, DependencyList)>;\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable)]\n pub enum Linkage {\n     NotLinked,\n     IncludedFromDylib,\n     Static,\n     Dynamic,\n }\n-\n-pub fn calculate(tcx: TyCtxt<'_>) {\n-    let sess = &tcx.sess;\n-    let fmts = sess.crate_types.borrow().iter().map(|&ty| {\n-        let linkage = calculate_type(tcx, ty);\n-        verify_ok(tcx, &linkage);\n-        (ty, linkage)\n-    }).collect::<FxHashMap<_, _>>();\n-    sess.abort_if_errors();\n-    sess.dependency_formats.set(fmts);\n-}\n-\n-fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n-    let sess = &tcx.sess;\n-\n-    if !sess.opts.output_types.should_codegen() {\n-        return Vec::new();\n-    }\n-\n-    let preferred_linkage = match ty {\n-        // cdylibs must have all static dependencies.\n-        config::CrateType::Cdylib => Linkage::Static,\n-\n-        // Generating a dylib without `-C prefer-dynamic` means that we're going\n-        // to try to eagerly statically link all dependencies. This is normally\n-        // done for end-product dylibs, not intermediate products.\n-        config::CrateType::Dylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n-        config::CrateType::Dylib => Linkage::Dynamic,\n-\n-        // If the global prefer_dynamic switch is turned off, or the final\n-        // executable will be statically linked, prefer static crate linkage.\n-        config::CrateType::Executable if !sess.opts.cg.prefer_dynamic ||\n-            sess.crt_static() => Linkage::Static,\n-        config::CrateType::Executable => Linkage::Dynamic,\n-\n-        // proc-macro crates are mostly cdylibs, but we also need metadata.\n-        config::CrateType::ProcMacro => Linkage::Static,\n-\n-        // No linkage happens with rlibs, we just needed the metadata (which we\n-        // got long ago), so don't bother with anything.\n-        config::CrateType::Rlib => Linkage::NotLinked,\n-\n-        // staticlibs must have all static dependencies.\n-        config::CrateType::Staticlib => Linkage::Static,\n-    };\n-\n-    if preferred_linkage == Linkage::NotLinked {\n-        // If the crate is not linked, there are no link-time dependencies.\n-        return Vec::new();\n-    }\n-\n-    if preferred_linkage == Linkage::Static {\n-        // Attempt static linkage first. For dylibs and executables, we may be\n-        // able to retry below with dynamic linkage.\n-        if let Some(v) = attempt_static(tcx) {\n-            return v;\n-        }\n-\n-        // Staticlibs, cdylibs, and static executables must have all static\n-        // dependencies. If any are not found, generate some nice pretty errors.\n-        if ty == config::CrateType::Cdylib || ty == config::CrateType::Staticlib ||\n-                (ty == config::CrateType::Executable && sess.crt_static() &&\n-                !sess.target.target.options.crt_static_allows_dylibs) {\n-            for &cnum in tcx.crates().iter() {\n-                if tcx.dep_kind(cnum).macros_only() { continue }\n-                let src = tcx.used_crate_source(cnum);\n-                if src.rlib.is_some() { continue }\n-                sess.err(&format!(\"crate `{}` required to be available in rlib format, \\\n-                                   but was not found in this form\",\n-                                  tcx.crate_name(cnum)));\n-            }\n-            return Vec::new();\n-        }\n-    }\n-\n-    let mut formats = FxHashMap::default();\n-\n-    // Sweep all crates for found dylibs. Add all dylibs, as well as their\n-    // dependencies, ensuring there are no conflicts. The only valid case for a\n-    // dependency to be relied upon twice is for both cases to rely on a dylib.\n-    for &cnum in tcx.crates().iter() {\n-        if tcx.dep_kind(cnum).macros_only() { continue }\n-        let name = tcx.crate_name(cnum);\n-        let src = tcx.used_crate_source(cnum);\n-        if src.dylib.is_some() {\n-            info!(\"adding dylib: {}\", name);\n-            add_library(tcx, cnum, RequireDynamic, &mut formats);\n-            let deps = tcx.dylib_dependency_formats(cnum);\n-            for &(depnum, style) in deps.iter() {\n-                info!(\"adding {:?}: {}\", style, tcx.crate_name(depnum));\n-                add_library(tcx, depnum, style, &mut formats);\n-            }\n-        }\n-    }\n-\n-    // Collect what we've got so far in the return vector.\n-    let last_crate = tcx.crates().len();\n-    let mut ret = (1..last_crate+1).map(|cnum| {\n-        match formats.get(&CrateNum::new(cnum)) {\n-            Some(&RequireDynamic) => Linkage::Dynamic,\n-            Some(&RequireStatic) => Linkage::IncludedFromDylib,\n-            None => Linkage::NotLinked,\n-        }\n-    }).collect::<Vec<_>>();\n-\n-    // Run through the dependency list again, and add any missing libraries as\n-    // static libraries.\n-    //\n-    // If the crate hasn't been included yet and it's not actually required\n-    // (e.g., it's an allocator) then we skip it here as well.\n-    for &cnum in tcx.crates().iter() {\n-        let src = tcx.used_crate_source(cnum);\n-        if src.dylib.is_none() &&\n-           !formats.contains_key(&cnum) &&\n-           tcx.dep_kind(cnum) == DepKind::Explicit {\n-            assert!(src.rlib.is_some() || src.rmeta.is_some());\n-            info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n-            add_library(tcx, cnum, RequireStatic, &mut formats);\n-            ret[cnum.as_usize() - 1] = Linkage::Static;\n-        }\n-    }\n-\n-    // We've gotten this far because we're emitting some form of a final\n-    // artifact which means that we may need to inject dependencies of some\n-    // form.\n-    //\n-    // Things like allocators and panic runtimes may not have been activated\n-    // quite yet, so do so here.\n-    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum));\n-\n-    // When dylib B links to dylib A, then when using B we must also link to A.\n-    // It could be the case, however, that the rlib for A is present (hence we\n-    // found metadata), but the dylib for A has since been removed.\n-    //\n-    // For situations like this, we perform one last pass over the dependencies,\n-    // making sure that everything is available in the requested format.\n-    for (cnum, kind) in ret.iter().enumerate() {\n-        let cnum = CrateNum::new(cnum + 1);\n-        let src = tcx.used_crate_source(cnum);\n-        match *kind {\n-            Linkage::NotLinked |\n-            Linkage::IncludedFromDylib => {}\n-            Linkage::Static if src.rlib.is_some() => continue,\n-            Linkage::Dynamic if src.dylib.is_some() => continue,\n-            kind => {\n-                let kind = match kind {\n-                    Linkage::Static => \"rlib\",\n-                    _ => \"dylib\",\n-                };\n-                sess.err(&format!(\"crate `{}` required to be available in {} format, \\\n-                                   but was not found in this form\",\n-                                  tcx.crate_name(cnum), kind));\n-            }\n-        }\n-    }\n-\n-    ret\n-}\n-\n-fn add_library(\n-    tcx: TyCtxt<'_>,\n-    cnum: CrateNum,\n-    link: LinkagePreference,\n-    m: &mut FxHashMap<CrateNum, LinkagePreference>,\n-) {\n-    match m.get(&cnum) {\n-        Some(&link2) => {\n-            // If the linkages differ, then we'd have two copies of the library\n-            // if we continued linking. If the linkages are both static, then we\n-            // would also have two copies of the library (static from two\n-            // different locations).\n-            //\n-            // This error is probably a little obscure, but I imagine that it\n-            // can be refined over time.\n-            if link2 != link || link == RequireStatic {\n-                tcx.sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                              shows up once\", tcx.crate_name(cnum)))\n-                    .help(\"having upstream crates all available in one format \\\n-                           will likely make this go away\")\n-                    .emit();\n-            }\n-        }\n-        None => { m.insert(cnum, link); }\n-    }\n-}\n-\n-fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n-    let sess = &tcx.sess;\n-    let crates = cstore::used_crates(tcx, RequireStatic);\n-    if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n-        return None\n-    }\n-\n-    // All crates are available in an rlib format, so we're just going to link\n-    // everything in explicitly so long as it's actually required.\n-    let last_crate = tcx.crates().len();\n-    let mut ret = (1..last_crate+1).map(|cnum| {\n-        if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n-            Linkage::Static\n-        } else {\n-            Linkage::NotLinked\n-        }\n-    }).collect::<Vec<_>>();\n-\n-    // Our allocator/panic runtime may not have been linked above if it wasn't\n-    // explicitly linked, which is the case for any injected dependency. Handle\n-    // that here and activate them.\n-    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum));\n-\n-    Some(ret)\n-}\n-\n-// Given a list of how to link upstream dependencies so far, ensure that an\n-// injected dependency is activated. This will not do anything if one was\n-// transitively included already (e.g., via a dylib or explicitly so).\n-//\n-// If an injected dependency was not found then we're guaranteed the\n-// metadata::creader module has injected that dependency (not listed as\n-// a required dependency) in one of the session's field. If this field is not\n-// set then this compilation doesn't actually need the dependency and we can\n-// also skip this step entirely.\n-fn activate_injected_dep(injected: Option<CrateNum>,\n-                         list: &mut DependencyList,\n-                         replaces_injected: &dyn Fn(CrateNum) -> bool) {\n-    for (i, slot) in list.iter().enumerate() {\n-        let cnum = CrateNum::new(i + 1);\n-        if !replaces_injected(cnum) {\n-            continue\n-        }\n-        if *slot != Linkage::NotLinked {\n-            return\n-        }\n-    }\n-    if let Some(injected) = injected {\n-        let idx = injected.as_usize() - 1;\n-        assert_eq!(list[idx], Linkage::NotLinked);\n-        list[idx] = Linkage::Static;\n-    }\n-}\n-\n-// After the linkage for a crate has been determined we need to verify that\n-// there's only going to be one allocator in the output.\n-fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n-    let sess = &tcx.sess;\n-    if list.len() == 0 {\n-        return\n-    }\n-    let mut panic_runtime = None;\n-    for (i, linkage) in list.iter().enumerate() {\n-        if let Linkage::NotLinked = *linkage {\n-            continue\n-        }\n-        let cnum = CrateNum::new(i + 1);\n-\n-        if tcx.is_panic_runtime(cnum) {\n-            if let Some((prev, _)) = panic_runtime {\n-                let prev_name = tcx.crate_name(prev);\n-                let cur_name = tcx.crate_name(cnum);\n-                sess.err(&format!(\"cannot link together two \\\n-                                   panic runtimes: {} and {}\",\n-                                  prev_name, cur_name));\n-            }\n-            panic_runtime = Some((cnum, tcx.panic_strategy(cnum)));\n-        }\n-    }\n-\n-    // If we found a panic runtime, then we know by this point that it's the\n-    // only one, but we perform validation here that all the panic strategy\n-    // compilation modes for the whole DAG are valid.\n-    if let Some((cnum, found_strategy)) = panic_runtime {\n-        let desired_strategy = sess.panic_strategy();\n-\n-        // First up, validate that our selected panic runtime is indeed exactly\n-        // our same strategy.\n-        if found_strategy != desired_strategy {\n-            sess.err(&format!(\"the linked panic runtime `{}` is \\\n-                               not compiled with this crate's \\\n-                               panic strategy `{}`\",\n-                              tcx.crate_name(cnum),\n-                              desired_strategy.desc()));\n-        }\n-\n-        // Next up, verify that all other crates are compatible with this panic\n-        // strategy. If the dep isn't linked, we ignore it, and if our strategy\n-        // is abort then it's compatible with everything. Otherwise all crates'\n-        // panic strategy must match our own.\n-        for (i, linkage) in list.iter().enumerate() {\n-            if let Linkage::NotLinked = *linkage {\n-                continue\n-            }\n-            if desired_strategy == PanicStrategy::Abort {\n-                continue\n-            }\n-            let cnum = CrateNum::new(i + 1);\n-            let found_strategy = tcx.panic_strategy(cnum);\n-            let is_compiler_builtins = tcx.is_compiler_builtins(cnum);\n-            if is_compiler_builtins || desired_strategy == found_strategy {\n-                continue\n-            }\n-\n-            sess.err(&format!(\"the crate `{}` is compiled with the \\\n-                               panic strategy `{}` which is \\\n-                               incompatible with this crate's \\\n-                               strategy of `{}`\",\n-                              tcx.crate_name(cnum),\n-                              found_strategy.desc(),\n-                              desired_strategy.desc()));\n-        }\n-    }\n-}"}, {"sha": "6cd1be460d7c6d0556d5204c18e76474281ed755", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -244,6 +244,10 @@ rustc_queries! {\n             desc { |tcx| \"checking if item is const fn: `{}`\", tcx.def_path_str(key) }\n         }\n \n+        query asyncness(key: DefId) -> hir::IsAsync {\n+            desc { |tcx| \"checking if the function is async: `{}`\", tcx.def_path_str(key) }\n+        }\n+\n         /// Returns `true` if calls to the function may be promoted.\n         ///\n         /// This is either because the function is e.g., a tuple-struct or tuple-variant\n@@ -630,6 +634,12 @@ rustc_queries! {\n                                         -> &'tcx [(CrateNum, LinkagePreference)] {\n             desc { \"dylib dependency formats of crate\" }\n         }\n+\n+        query dependency_formats(_: CrateNum)\n+            -> Lrc<crate::middle::dependency_format::Dependencies>\n+        {\n+            desc { \"get the linkage format of all dependencies\" }\n+        }\n     }\n \n     Codegen {"}, {"sha": "a9a20a924347ca4bbd07fdc0b1b408a78fede58e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -687,7 +687,7 @@ pub enum EntryFnType {\n \n impl_stable_hash_via_hash!(EntryFnType);\n \n-#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug)]\n+#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug, HashStable)]\n pub enum CrateType {\n     Executable,\n     Dylib,"}, {"sha": "8e9c2735c39134138d2b39dea1a518dd3e3357d6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::fingerprint::Fingerprint;\n \n use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::middle::dependency_format;\n use crate::session::config::{OutputType, PrintRequest, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n@@ -91,7 +90,6 @@ pub struct Session {\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n     pub plugin_attributes: Lock<Vec<(Symbol, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n-    pub dependency_formats: Once<dependency_format::Dependencies>,\n     /// The `crate_disambiguator` is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n@@ -1248,7 +1246,6 @@ fn build_session_(\n         plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),\n         plugin_attributes: Lock::new(Vec::new()),\n         crate_types: Once::new(),\n-        dependency_formats: Once::new(),\n         crate_disambiguator: Once::new(),\n         features: Once::new(),\n         recursion_limit: Once::new(),"}, {"sha": "08fea757399787c06f62cedb731cf0d6e02b1a54", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1432,8 +1432,11 @@ impl<'tcx> TyCtxt<'tcx> {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>,\n-                              body_id: Option<hir::BodyId>) {\n+    fn maybe_report_ambiguity(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+    ) {\n         // Unable to successfully determine, probably means\n         // insufficient type information, but could mean\n         // ambiguous impls. The latter *ought* to be a\n@@ -1442,9 +1445,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n         let span = obligation.cause.span;\n \n-        debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n-               predicate,\n-               obligation);\n+        debug!(\n+            \"maybe_report_ambiguity(predicate={:?}, obligation={:?} body_id={:?}, code={:?})\",\n+            predicate,\n+            obligation,\n+            body_id,\n+            obligation.cause.code,\n+        );\n \n         // Ambiguity errors are often caused as fallout from earlier\n         // errors. So just ignore them if this infcx is tainted.\n@@ -1456,6 +1463,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ty::Predicate::Trait(ref data) => {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n+                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.sty, trait_ref);\n+\n                 if predicate.references_error() {\n                     return;\n                 }\n@@ -1480,24 +1489,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // be ignoring the fact that we don't KNOW the type works\n                 // out. Though even that would probably be harmless, given that\n                 // we're only talking about builtin traits, which are known to be\n-                // inhabited. But in any case I just threw in this check for\n-                // has_errors() to be sure that compilation isn't happening\n-                // anyway. In that case, why inundate the user.\n-                if !self.tcx.sess.has_errors() {\n-                    if\n-                        self.tcx.lang_items().sized_trait()\n-                        .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n-                    {\n-                        self.need_type_info_err(body_id, span, self_ty).emit();\n-                    } else {\n-                        let mut err = struct_span_err!(self.tcx.sess,\n-                                                       span, E0283,\n-                                                       \"type annotations required: \\\n-                                                        cannot resolve `{}`\",\n-                                                       predicate);\n-                        self.note_obligation_cause(&mut err, obligation);\n-                        err.emit();\n-                    }\n+                // inhabited. We used to check for `self.tcx.sess.has_errors()` to\n+                // avoid inundating the user with unnecessary errors, but we now\n+                // check upstream for type errors and dont add the obligations to\n+                // begin with in those cases.\n+                if\n+                    self.tcx.lang_items().sized_trait()\n+                    .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                {\n+                    self.need_type_info_err(body_id, span, self_ty).emit();\n+                } else {\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0283,\n+                        \"type annotations needed: cannot resolve `{}`\",\n+                        predicate,\n+                    );\n+                    self.note_obligation_cause(&mut err, obligation);\n+                    err.emit();\n                 }\n             }\n \n@@ -1524,11 +1534,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             _ => {\n                 if !self.tcx.sess.has_errors() {\n-                    let mut err = struct_span_err!(self.tcx.sess,\n-                                                   obligation.cause.span, E0284,\n-                                                   \"type annotations required: \\\n-                                                    cannot resolve `{}`\",\n-                                                   predicate);\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        obligation.cause.span,\n+                        E0284,\n+                        \"type annotations needed: cannot resolve `{}`\",\n+                        predicate,\n+                    );\n                     self.note_obligation_cause(&mut err, obligation);\n                     err.emit();\n                 }\n@@ -1766,7 +1778,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                               but not on the corresponding trait method\",\n                              predicate));\n             }\n-            ObligationCauseCode::ReturnType(_) |\n+            ObligationCauseCode::ReturnType |\n+            ObligationCauseCode::ReturnValue(_) |\n             ObligationCauseCode::BlockTailExpression(_) => (),\n             ObligationCauseCode::TrivialBound => {\n                 err.help(\"see issue #48214\");"}, {"sha": "accbbe3643ea188102cca472eea76535bab70741", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -212,14 +212,14 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Constant expressions must be sized.\n     ConstSized,\n \n-    /// static items must have `Sync` type\n+    /// Static items must have `Sync` type\n     SharedStatic,\n \n     BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n \n     ImplDerivedObligation(DerivedObligationCause<'tcx>),\n \n-    /// error derived when matching traits/impls; see ObligationCause for more details\n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n     CompareImplMethodObligation {\n         item_name: ast::Name,\n         impl_item_def_id: DefId,\n@@ -248,17 +248,20 @@ pub enum ObligationCauseCode<'tcx> {\n     /// `start` has wrong type\n     StartFunctionType,\n \n-    /// intrinsic has wrong type\n+    /// Intrinsic has wrong type\n     IntrinsicType,\n \n-    /// method receiver\n+    /// Method receiver\n     MethodReceiver,\n \n     /// `return` with no expression\n     ReturnNoExpression,\n \n     /// `return` with an expression\n-    ReturnType(hir::HirId),\n+    ReturnValue(hir::HirId),\n+\n+    /// Return type of this function\n+    ReturnType,\n \n     /// Block implicit return\n     BlockTailExpression(hir::HirId),"}, {"sha": "386a5677f5f177edbb6cceb8bc8856a760723aba", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -214,7 +214,7 @@ pub struct SelectionCache<'tcx> {\n /// of type variables - it just means the obligation isn't sufficiently\n /// elaborated. In that case we report an ambiguity, and the caller can\n /// try again after more type information has been gathered or report a\n-/// \"type annotations required\" error.\n+/// \"type annotations needed\" error.\n ///\n /// However, with type parameters, this can be a real problem - type\n /// parameters don't unify with regular types, but they *can* unify"}, {"sha": "c0d8230999dd8d8a52481506f22857dde8d57d98", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -485,7 +485,8 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::TupleInitializerSized => Some(super::TupleInitializerSized),\n             super::StructInitializerSized => Some(super::StructInitializerSized),\n             super::VariableType(id) => Some(super::VariableType(id)),\n-            super::ReturnType(id) => Some(super::ReturnType(id)),\n+            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n+            super::ReturnType => Some(super::ReturnType),\n             super::SizedArgumentType => Some(super::SizedArgumentType),\n             super::SizedReturnType => Some(super::SizedReturnType),\n             super::SizedYieldType => Some(super::SizedYieldType),"}, {"sha": "c03dbb2b1ed0e6899439522c642a6bbe3ffc1d36", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1510,9 +1510,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 CrateType::Executable |\n                 CrateType::Staticlib  |\n                 CrateType::ProcMacro  |\n+                CrateType::Dylib      |\n                 CrateType::Cdylib     => false,\n-                CrateType::Rlib       |\n-                CrateType::Dylib      => true,\n+                CrateType::Rlib       => true,\n             }\n         })\n     }"}, {"sha": "ef8bdfb583edf66a38337b648fcbd06a8a04fc75", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -438,19 +438,19 @@ bitflags! {\n \n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES    = 1 << 9;\n+        const HAS_FREE_LOCAL_NAMES = 1 << 9;\n \n         /// Present if the type belongs in a local type context.\n         /// Only set for Infer other than Fresh.\n         const KEEP_IN_LOCAL_TCX  = 1 << 10;\n \n         /// Does this have any `ReLateBound` regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND = 1 << 11;\n+        const HAS_RE_LATE_BOUND  = 1 << 11;\n \n         const HAS_TY_PLACEHOLDER = 1 << 12;\n \n-        const HAS_CT_INFER = 1 << 13;\n+        const HAS_CT_INFER       = 1 << 13;\n         const HAS_CT_PLACEHOLDER = 1 << 14;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n@@ -3353,13 +3353,30 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n     }\n }\n \n+/// Check if a function is async.\n+fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap_or_else(|| {\n+        bug!(\"asyncness: expected local `DefId`, got `{:?}`\", def_id)\n+    });\n+\n+    let node = tcx.hir().get(hir_id);\n+\n+    let fn_like = hir::map::blocks::FnLikeNode::from_node(node).unwrap_or_else(|| {\n+        bug!(\"asyncness: expected fn-like node but got `{:?}`\", def_id);\n+    });\n+\n+    fn_like.asyncness()\n+}\n+\n+\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n     layout::provide(providers);\n     util::provide(providers);\n     constness::provide(providers);\n     *providers = ty::query::Providers {\n+        asyncness,\n         associated_item,\n         associated_item_def_ids,\n         adt_sized_constraint,"}, {"sha": "3b7ae5e33d5e716e7d869d790617fa83a1ac969c", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -219,15 +219,24 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n     (linker.to_path_buf(), cmd)\n }\n \n-pub fn each_linked_rlib(sess: &Session,\n-                               info: &CrateInfo,\n-                               f: &mut dyn FnMut(CrateNum, &Path)) -> Result<(), String> {\n+pub fn each_linked_rlib(\n+    info: &CrateInfo,\n+    f: &mut dyn FnMut(CrateNum, &Path),\n+) -> Result<(), String> {\n     let crates = info.used_crates_static.iter();\n-    let fmts = sess.dependency_formats.borrow();\n-    let fmts = fmts.get(&config::CrateType::Executable)\n-                   .or_else(|| fmts.get(&config::CrateType::Staticlib))\n-                   .or_else(|| fmts.get(&config::CrateType::Cdylib))\n-                   .or_else(|| fmts.get(&config::CrateType::ProcMacro));\n+    let mut fmts = None;\n+    for (ty, list) in info.dependency_formats.iter() {\n+        match ty {\n+            config::CrateType::Executable |\n+            config::CrateType::Staticlib |\n+            config::CrateType::Cdylib |\n+            config::CrateType::ProcMacro => {\n+                fmts = Some(list);\n+                break;\n+            }\n+            _ => {}\n+        }\n+    }\n     let fmts = match fmts {\n         Some(f) => f,\n         None => return Err(\"could not find formats for rlibs\".to_string())\n@@ -406,7 +415,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                            tempdir);\n     let mut all_native_libs = vec![];\n \n-    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n+    let res = each_linked_rlib(&codegen_results.crate_info, &mut |cnum, path| {\n         let name = &codegen_results.crate_info.crate_name[&cnum];\n         let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n \n@@ -1294,11 +1303,13 @@ pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n-                            sess: &'a Session,\n-                            codegen_results: &CodegenResults,\n-                            crate_type: config::CrateType,\n-                            tmpdir: &Path) {\n+fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    codegen_results: &CodegenResults,\n+    crate_type: config::CrateType,\n+    tmpdir: &Path,\n+) {\n     // All of the heavy lifting has previously been accomplished by the\n     // dependency_format module of the compiler. This is just crawling the\n     // output of that module, adding crates as necessary.\n@@ -1307,8 +1318,10 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n     // will slurp up the object files inside), and linking to a dynamic library\n     // involves just passing the right -l flag.\n \n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n+    let (_, data) = codegen_results.crate_info.dependency_formats\n+        .iter()\n+        .find(|(ty, _)| *ty == crate_type)\n+        .expect(\"failed to find crate type in dependency format list\");\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n@@ -1620,10 +1633,12 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n-                                 sess: &Session,\n-                                 codegen_results: &CodegenResults,\n-                                 crate_type: config::CrateType) {\n+pub fn add_upstream_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    codegen_results: &CodegenResults,\n+    crate_type: config::CrateType,\n+) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n@@ -1633,8 +1648,10 @@ pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n     // This passes RequireStatic, but the actual requirement doesn't matter,\n     // we're just getting an ordering of crate numbers, we're not worried about\n     // the paths.\n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n+    let (_, data) = codegen_results.crate_info.dependency_formats\n+        .iter()\n+        .find(|(ty, _)| *ty == crate_type)\n+        .expect(\"failed to find crate type in dependency format list\");\n \n     let crates = &codegen_results.crate_info.used_crates_static;\n     for &(cnum, _) in crates {"}, {"sha": "ff87f0b1547cec36a61cb67a2780bc0adf8057dc", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -14,6 +14,7 @@ use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, OptLevel, DebugInfo,\n                              LinkerPluginLto, Lto};\n+use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::ty::TyCtxt;\n use rustc_target::spec::{LinkerFlavor, LldFlavor};\n use rustc_serialize::{json, Encoder};\n@@ -1092,18 +1093,41 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n         }\n     }\n \n-    let formats = tcx.sess.dependency_formats.borrow();\n-    let deps = formats[&crate_type].iter();\n+    let formats = tcx.dependency_formats(LOCAL_CRATE);\n+    let deps = formats.iter().filter_map(|(t, list)| {\n+        if *t == crate_type {\n+            Some(list)\n+        } else {\n+            None\n+        }\n+    }).next().unwrap();\n \n-    for (index, dep_format) in deps.enumerate() {\n+    for (index, dep_format) in deps.iter().enumerate() {\n         let cnum = CrateNum::new(index + 1);\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {\n             // ... we add its symbol list to our export list.\n             for &(symbol, level) in tcx.exported_symbols(cnum).iter() {\n-                if level.is_below_threshold(export_threshold) {\n-                    symbols.push(symbol.symbol_name(tcx).to_string());\n+                if !level.is_below_threshold(export_threshold) {\n+                    continue;\n                 }\n+\n+                // Do not export generic symbols from upstream crates in linked\n+                // artifact (notably the `dylib` crate type). The main reason\n+                // for this is that `symbol_name` is actually wrong for generic\n+                // symbols because it guesses the name we'd give them locally\n+                // rather than the name it has upstream (depending on\n+                // `share_generics` settings and such).\n+                //\n+                // To fix that issue we just say that linked artifacts, aka\n+                // `dylib`s, never export generic symbols and they aren't\n+                // available to downstream crates. (the not available part is\n+                // handled elsewhere).\n+                if let ExportedSymbol::Generic(..) = symbol {\n+                    continue;\n+                }\n+\n+                symbols.push(symbol.symbol_name(tcx).to_string());\n             }\n         }\n     }"}, {"sha": "3e4b7695447c8d5a132d822b47dc768295fdc52c", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -298,7 +298,7 @@ fn upstream_monomorphizations_provider(\n     };\n \n     for &cnum in cnums.iter() {\n-        for &(ref exported_symbol, _) in tcx.exported_symbols(cnum).iter() {\n+        for (exported_symbol, _) in tcx.exported_symbols(cnum).iter() {\n             if let &ExportedSymbol::Generic(def_id, substs) = exported_symbol {\n                 let substs_map = instances.entry(def_id).or_default();\n "}, {"sha": "1a2c23ae0d4f7415b84ae980f59ae60524227d75", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1048,7 +1048,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     }).expect(\"failed to spawn helper thread\");\n \n     let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n+    drop(link::each_linked_rlib(crate_info, &mut |cnum, path| {\n         if link::ignored_for_lto(sess, crate_info, cnum) {\n             return\n         }"}, {"sha": "98d3022a4185d4a826494ceeeec4df38bfecec0c", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -539,7 +539,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // linkage, then it's already got an allocator shim and we'll be using that\n     // one instead. If nothing exists then it's our job to generate the\n     // allocator!\n-    let any_dynamic_crate = tcx.sess.dependency_formats.borrow()\n+    let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE)\n         .iter()\n         .any(|(_, list)| {\n             use rustc::middle::dependency_format::Linkage;\n@@ -731,6 +731,7 @@ impl CrateInfo {\n             used_crate_source: Default::default(),\n             lang_item_to_crate: Default::default(),\n             missing_lang_items: Default::default(),\n+            dependency_formats: tcx.dependency_formats(LOCAL_CRATE),\n         };\n         let lang_items = tcx.lang_items();\n "}, {"sha": "161d3ce61f0a6f083f988b5730f331ffebb215ca", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -33,6 +33,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::svh::Svh;\n use rustc::middle::cstore::{LibSource, CrateSource, NativeLibrary};\n+use rustc::middle::dependency_format::Dependencies;\n use syntax_pos::symbol::Symbol;\n \n mod error_codes;\n@@ -142,6 +143,7 @@ pub struct CrateInfo {\n     pub used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n     pub lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n     pub missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n+    pub dependency_formats: Lrc<Dependencies>,\n }\n \n "}, {"sha": "56db695f254117b8590ae17f0606b0a748ce16dc", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1075,10 +1075,6 @@ pub fn start_codegen<'tcx>(\n         tcx.print_debug_stats();\n     }\n \n-    time(tcx.sess, \"resolving dependency formats\", || {\n-        middle::dependency_format::calculate(tcx)\n-    });\n-\n     let (metadata, need_metadata_module) = time(tcx.sess, \"metadata encoding and writing\", || {\n         encode_and_write_metadata(tcx, outputs)\n     });"}, {"sha": "11121ee875ddab9cf0f3c065fe58b5c11640f339", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -10,6 +10,7 @@ use rustc::middle::cstore::{CrateStore, DepKind,\n                             EncodedMetadata, NativeLibraryKind};\n use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::middle::stability::DeprecationEntry;\n+use rustc::middle::dependency_format::Linkage;\n use rustc::hir::def;\n use rustc::hir;\n use rustc::session::{CrateDisambiguator, Session};\n@@ -133,6 +134,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }\n+    asyncness => { cdata.asyncness(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     static_mutability => { cdata.static_mutability(def_id.index) }\n     def_kind => { cdata.def_kind(def_id.index) }\n@@ -239,7 +241,30 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     used_crate_source => { Lrc::new(cdata.source.clone()) }\n \n-    exported_symbols => { Arc::new(cdata.exported_symbols(tcx)) }\n+    exported_symbols => {\n+        let mut syms = cdata.exported_symbols(tcx);\n+\n+        // When linked into a dylib crates don't export their generic symbols,\n+        // so if that's happening then we can't load upstream monomorphizations\n+        // from this crate.\n+        let formats = tcx.dependency_formats(LOCAL_CRATE);\n+        let remove_generics = formats.iter().any(|(_ty, list)| {\n+            match list.get(def_id.krate.as_usize() - 1) {\n+                Some(Linkage::IncludedFromDylib) | Some(Linkage::Dynamic) => true,\n+                _ => false,\n+            }\n+        });\n+        if remove_generics {\n+            syms.retain(|(sym, _threshold)| {\n+                match sym {\n+                    ExportedSymbol::Generic(..) => false,\n+                    _ => return true,\n+                }\n+            });\n+        }\n+\n+        Arc::new(syms)\n+    }\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -370,6 +395,11 @@ pub fn provide(providers: &mut Providers<'_>) {\n             tcx.arena.alloc(visible_parent_map)\n         },\n \n+        dependency_formats: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Lrc::new(crate::dependency_format::calculate(tcx))\n+        },\n+\n         ..*providers\n     };\n }"}, {"sha": "247748eb3eba5285b57b3aad29c70207b018f27b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1212,6 +1212,15 @@ impl<'a, 'tcx> CrateMetadata {\n         constness == hir::Constness::Const\n     }\n \n+    pub fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n+         match self.entry(id).kind {\n+            EntryKind::Fn(data) => data.decode(self).asyncness,\n+            EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n+            EntryKind::ForeignFn(data) => data.decode(self).asyncness,\n+            _ => bug!(\"asyncness: expect functions entry.\"),\n+        }\n+    }\n+\n     pub fn is_foreign_item(&self, id: DefIndex) -> bool {\n         match self.entry(id).kind {\n             EntryKind::ForeignImmStatic |"}, {"sha": "9a30623b33d626a6f8c70f081d31888ef46baa2f", "filename": "src/librustc_metadata/dependency_format.rs", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -0,0 +1,370 @@\n+//! Resolution of mixing rlibs and dylibs\n+//!\n+//! When producing a final artifact, such as a dynamic library, the compiler has\n+//! a choice between linking an rlib or linking a dylib of all upstream\n+//! dependencies. The linking phase must guarantee, however, that a library only\n+//! show up once in the object file. For example, it is illegal for library A to\n+//! be statically linked to B and C in separate dylibs, and then link B and C\n+//! into a crate D (because library A appears twice).\n+//!\n+//! The job of this module is to calculate what format each upstream crate\n+//! should be used when linking each output type requested in this session. This\n+//! generally follows this set of rules:\n+//!\n+//!     1. Each library must appear exactly once in the output.\n+//!     2. Each rlib contains only one library (it's just an object file)\n+//!     3. Each dylib can contain more than one library (due to static linking),\n+//!        and can also bring in many dynamic dependencies.\n+//!\n+//! With these constraints in mind, it's generally a very difficult problem to\n+//! find a solution that's not \"all rlibs\" or \"all dylibs\". I have suspicions\n+//! that NP-ness may come into the picture here...\n+//!\n+//! The current selection algorithm below looks mostly similar to:\n+//!\n+//!     1. If static linking is required, then require all upstream dependencies\n+//!        to be available as rlibs. If not, generate an error.\n+//!     2. If static linking is requested (generating an executable), then\n+//!        attempt to use all upstream dependencies as rlibs. If any are not\n+//!        found, bail out and continue to step 3.\n+//!     3. Static linking has failed, at least one library must be dynamically\n+//!        linked. Apply a heuristic by greedily maximizing the number of\n+//!        dynamically linked libraries.\n+//!     4. Each upstream dependency available as a dynamic library is\n+//!        registered. The dependencies all propagate, adding to a map. It is\n+//!        possible for a dylib to add a static library as a dependency, but it\n+//!        is illegal for two dylibs to add the same static library as a\n+//!        dependency. The same dylib can be added twice. Additionally, it is\n+//!        illegal to add a static dependency when it was previously found as a\n+//!        dylib (and vice versa)\n+//!     5. After all dynamic dependencies have been traversed, re-traverse the\n+//!        remaining dependencies and add them statically (if they haven't been\n+//!        added already).\n+//!\n+//! While not perfect, this algorithm should help support use-cases such as leaf\n+//! dependencies being static while the larger tree of inner dependencies are\n+//! all dynamic. This isn't currently very well battle tested, so it will likely\n+//! fall short in some use cases.\n+//!\n+//! Currently, there is no way to specify the preference of linkage with a\n+//! particular library (other than a global dynamic/static switch).\n+//! Additionally, the algorithm is geared towards finding *any* solution rather\n+//! than finding a number of solutions (there are normally quite a few).\n+\n+use rustc::hir::def_id::CrateNum;\n+use rustc::middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n+use rustc::middle::cstore::{self, DepKind};\n+use rustc::middle::dependency_format::{DependencyList, Dependencies, Linkage};\n+use rustc::session::config;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_target::spec::PanicStrategy;\n+\n+pub fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n+    tcx.sess.crate_types.borrow().iter().map(|&ty| {\n+        let linkage = calculate_type(tcx, ty);\n+        verify_ok(tcx, &linkage);\n+        (ty, linkage)\n+    }).collect::<Vec<_>>()\n+}\n+\n+fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n+    let sess = &tcx.sess;\n+\n+    if !sess.opts.output_types.should_codegen() {\n+        return Vec::new();\n+    }\n+\n+    let preferred_linkage = match ty {\n+        // cdylibs must have all static dependencies.\n+        config::CrateType::Cdylib => Linkage::Static,\n+\n+        // Generating a dylib without `-C prefer-dynamic` means that we're going\n+        // to try to eagerly statically link all dependencies. This is normally\n+        // done for end-product dylibs, not intermediate products.\n+        config::CrateType::Dylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n+        config::CrateType::Dylib => Linkage::Dynamic,\n+\n+        // If the global prefer_dynamic switch is turned off, or the final\n+        // executable will be statically linked, prefer static crate linkage.\n+        config::CrateType::Executable if !sess.opts.cg.prefer_dynamic ||\n+            sess.crt_static() => Linkage::Static,\n+        config::CrateType::Executable => Linkage::Dynamic,\n+\n+        // proc-macro crates are mostly cdylibs, but we also need metadata.\n+        config::CrateType::ProcMacro => Linkage::Static,\n+\n+        // No linkage happens with rlibs, we just needed the metadata (which we\n+        // got long ago), so don't bother with anything.\n+        config::CrateType::Rlib => Linkage::NotLinked,\n+\n+        // staticlibs must have all static dependencies.\n+        config::CrateType::Staticlib => Linkage::Static,\n+    };\n+\n+    if preferred_linkage == Linkage::NotLinked {\n+        // If the crate is not linked, there are no link-time dependencies.\n+        return Vec::new();\n+    }\n+\n+    if preferred_linkage == Linkage::Static {\n+        // Attempt static linkage first. For dylibs and executables, we may be\n+        // able to retry below with dynamic linkage.\n+        if let Some(v) = attempt_static(tcx) {\n+            return v;\n+        }\n+\n+        // Staticlibs, cdylibs, and static executables must have all static\n+        // dependencies. If any are not found, generate some nice pretty errors.\n+        if ty == config::CrateType::Cdylib || ty == config::CrateType::Staticlib ||\n+                (ty == config::CrateType::Executable && sess.crt_static() &&\n+                !sess.target.target.options.crt_static_allows_dylibs) {\n+            for &cnum in tcx.crates().iter() {\n+                if tcx.dep_kind(cnum).macros_only() { continue }\n+                let src = tcx.used_crate_source(cnum);\n+                if src.rlib.is_some() { continue }\n+                sess.err(&format!(\"crate `{}` required to be available in rlib format, \\\n+                                   but was not found in this form\",\n+                                  tcx.crate_name(cnum)));\n+            }\n+            return Vec::new();\n+        }\n+    }\n+\n+    let mut formats = FxHashMap::default();\n+\n+    // Sweep all crates for found dylibs. Add all dylibs, as well as their\n+    // dependencies, ensuring there are no conflicts. The only valid case for a\n+    // dependency to be relied upon twice is for both cases to rely on a dylib.\n+    for &cnum in tcx.crates().iter() {\n+        if tcx.dep_kind(cnum).macros_only() { continue }\n+        let name = tcx.crate_name(cnum);\n+        let src = tcx.used_crate_source(cnum);\n+        if src.dylib.is_some() {\n+            log::info!(\"adding dylib: {}\", name);\n+            add_library(tcx, cnum, RequireDynamic, &mut formats);\n+            let deps = tcx.dylib_dependency_formats(cnum);\n+            for &(depnum, style) in deps.iter() {\n+                log::info!(\"adding {:?}: {}\", style, tcx.crate_name(depnum));\n+                add_library(tcx, depnum, style, &mut formats);\n+            }\n+        }\n+    }\n+\n+    // Collect what we've got so far in the return vector.\n+    let last_crate = tcx.crates().len();\n+    let mut ret = (1..last_crate+1).map(|cnum| {\n+        match formats.get(&CrateNum::new(cnum)) {\n+            Some(&RequireDynamic) => Linkage::Dynamic,\n+            Some(&RequireStatic) => Linkage::IncludedFromDylib,\n+            None => Linkage::NotLinked,\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    // Run through the dependency list again, and add any missing libraries as\n+    // static libraries.\n+    //\n+    // If the crate hasn't been included yet and it's not actually required\n+    // (e.g., it's an allocator) then we skip it here as well.\n+    for &cnum in tcx.crates().iter() {\n+        let src = tcx.used_crate_source(cnum);\n+        if src.dylib.is_none() &&\n+           !formats.contains_key(&cnum) &&\n+           tcx.dep_kind(cnum) == DepKind::Explicit {\n+            assert!(src.rlib.is_some() || src.rmeta.is_some());\n+            log::info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n+            add_library(tcx, cnum, RequireStatic, &mut formats);\n+            ret[cnum.as_usize() - 1] = Linkage::Static;\n+        }\n+    }\n+\n+    // We've gotten this far because we're emitting some form of a final\n+    // artifact which means that we may need to inject dependencies of some\n+    // form.\n+    //\n+    // Things like allocators and panic runtimes may not have been activated\n+    // quite yet, so do so here.\n+    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n+\n+    // When dylib B links to dylib A, then when using B we must also link to A.\n+    // It could be the case, however, that the rlib for A is present (hence we\n+    // found metadata), but the dylib for A has since been removed.\n+    //\n+    // For situations like this, we perform one last pass over the dependencies,\n+    // making sure that everything is available in the requested format.\n+    for (cnum, kind) in ret.iter().enumerate() {\n+        let cnum = CrateNum::new(cnum + 1);\n+        let src = tcx.used_crate_source(cnum);\n+        match *kind {\n+            Linkage::NotLinked |\n+            Linkage::IncludedFromDylib => {}\n+            Linkage::Static if src.rlib.is_some() => continue,\n+            Linkage::Dynamic if src.dylib.is_some() => continue,\n+            kind => {\n+                let kind = match kind {\n+                    Linkage::Static => \"rlib\",\n+                    _ => \"dylib\",\n+                };\n+                sess.err(&format!(\"crate `{}` required to be available in {} format, \\\n+                                   but was not found in this form\",\n+                                  tcx.crate_name(cnum), kind));\n+            }\n+        }\n+    }\n+\n+    ret\n+}\n+\n+fn add_library(\n+    tcx: TyCtxt<'_>,\n+    cnum: CrateNum,\n+    link: LinkagePreference,\n+    m: &mut FxHashMap<CrateNum, LinkagePreference>,\n+) {\n+    match m.get(&cnum) {\n+        Some(&link2) => {\n+            // If the linkages differ, then we'd have two copies of the library\n+            // if we continued linking. If the linkages are both static, then we\n+            // would also have two copies of the library (static from two\n+            // different locations).\n+            //\n+            // This error is probably a little obscure, but I imagine that it\n+            // can be refined over time.\n+            if link2 != link || link == RequireStatic {\n+                tcx.sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n+                                              shows up once\", tcx.crate_name(cnum)))\n+                    .help(\"having upstream crates all available in one format \\\n+                           will likely make this go away\")\n+                    .emit();\n+            }\n+        }\n+        None => { m.insert(cnum, link); }\n+    }\n+}\n+\n+fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n+    let sess = &tcx.sess;\n+    let crates = cstore::used_crates(tcx, RequireStatic);\n+    if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n+        return None\n+    }\n+\n+    // All crates are available in an rlib format, so we're just going to link\n+    // everything in explicitly so long as it's actually required.\n+    let last_crate = tcx.crates().len();\n+    let mut ret = (1..last_crate+1).map(|cnum| {\n+        if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n+            Linkage::Static\n+        } else {\n+            Linkage::NotLinked\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    // Our allocator/panic runtime may not have been linked above if it wasn't\n+    // explicitly linked, which is the case for any injected dependency. Handle\n+    // that here and activate them.\n+    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n+\n+    Some(ret)\n+}\n+\n+// Given a list of how to link upstream dependencies so far, ensure that an\n+// injected dependency is activated. This will not do anything if one was\n+// transitively included already (e.g., via a dylib or explicitly so).\n+//\n+// If an injected dependency was not found then we're guaranteed the\n+// metadata::creader module has injected that dependency (not listed as\n+// a required dependency) in one of the session's field. If this field is not\n+// set then this compilation doesn't actually need the dependency and we can\n+// also skip this step entirely.\n+fn activate_injected_dep(injected: Option<CrateNum>,\n+                         list: &mut DependencyList,\n+                         replaces_injected: &dyn Fn(CrateNum) -> bool) {\n+    for (i, slot) in list.iter().enumerate() {\n+        let cnum = CrateNum::new(i + 1);\n+        if !replaces_injected(cnum) {\n+            continue\n+        }\n+        if *slot != Linkage::NotLinked {\n+            return\n+        }\n+    }\n+    if let Some(injected) = injected {\n+        let idx = injected.as_usize() - 1;\n+        assert_eq!(list[idx], Linkage::NotLinked);\n+        list[idx] = Linkage::Static;\n+    }\n+}\n+\n+// After the linkage for a crate has been determined we need to verify that\n+// there's only going to be one allocator in the output.\n+fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n+    let sess = &tcx.sess;\n+    if list.len() == 0 {\n+        return\n+    }\n+    let mut panic_runtime = None;\n+    for (i, linkage) in list.iter().enumerate() {\n+        if let Linkage::NotLinked = *linkage {\n+            continue\n+        }\n+        let cnum = CrateNum::new(i + 1);\n+\n+        if tcx.is_panic_runtime(cnum) {\n+            if let Some((prev, _)) = panic_runtime {\n+                let prev_name = tcx.crate_name(prev);\n+                let cur_name = tcx.crate_name(cnum);\n+                sess.err(&format!(\"cannot link together two \\\n+                                   panic runtimes: {} and {}\",\n+                                  prev_name, cur_name));\n+            }\n+            panic_runtime = Some((cnum, tcx.panic_strategy(cnum)));\n+        }\n+    }\n+\n+    // If we found a panic runtime, then we know by this point that it's the\n+    // only one, but we perform validation here that all the panic strategy\n+    // compilation modes for the whole DAG are valid.\n+    if let Some((cnum, found_strategy)) = panic_runtime {\n+        let desired_strategy = sess.panic_strategy();\n+\n+        // First up, validate that our selected panic runtime is indeed exactly\n+        // our same strategy.\n+        if found_strategy != desired_strategy {\n+            sess.err(&format!(\"the linked panic runtime `{}` is \\\n+                               not compiled with this crate's \\\n+                               panic strategy `{}`\",\n+                              tcx.crate_name(cnum),\n+                              desired_strategy.desc()));\n+        }\n+\n+        // Next up, verify that all other crates are compatible with this panic\n+        // strategy. If the dep isn't linked, we ignore it, and if our strategy\n+        // is abort then it's compatible with everything. Otherwise all crates'\n+        // panic strategy must match our own.\n+        for (i, linkage) in list.iter().enumerate() {\n+            if let Linkage::NotLinked = *linkage {\n+                continue\n+            }\n+            if desired_strategy == PanicStrategy::Abort {\n+                continue\n+            }\n+            let cnum = CrateNum::new(i + 1);\n+            let found_strategy = tcx.panic_strategy(cnum);\n+            let is_compiler_builtins = tcx.is_compiler_builtins(cnum);\n+            if is_compiler_builtins || desired_strategy == found_strategy {\n+                continue\n+            }\n+\n+            sess.err(&format!(\"the crate `{}` is compiled with the \\\n+                               panic strategy `{}` which is \\\n+                               incompatible with this crate's \\\n+                               strategy of `{}`\",\n+                              tcx.crate_name(cnum),\n+                              found_strategy.desc(),\n+                              desired_strategy.desc()));\n+        }\n+    }\n+}"}, {"sha": "965a8658c9592edf225ac250b2ff7d9794fd613a", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -875,7 +875,7 @@ impl EncodeContext<'tcx> {\n                 EntryKind::AssocConst(container, const_qualif, rendered_const)\n             }\n             ty::AssocKind::Method => {\n-                let fn_data = if let hir::TraitItemKind::Method(_, ref m) = ast_item.node {\n+                let fn_data = if let hir::TraitItemKind::Method(method_sig, m) = &ast_item.node {\n                     let param_names = match *m {\n                         hir::TraitMethod::Required(ref names) => {\n                             self.encode_fn_param_names(names)\n@@ -885,6 +885,7 @@ impl EncodeContext<'tcx> {\n                         }\n                     };\n                     FnData {\n+                        asyncness: method_sig.header.asyncness,\n                         constness: hir::Constness::NotConst,\n                         param_names,\n                         sig: self.lazy(&tcx.fn_sig(def_id)),\n@@ -982,6 +983,7 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n                     FnData {\n+                        asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n                         param_names: self.encode_fn_param_names_for_body(body),\n                         sig: self.lazy(&tcx.fn_sig(def_id)),\n@@ -1128,6 +1130,7 @@ impl EncodeContext<'tcx> {\n             }\n             hir::ItemKind::Fn(_, header, .., body) => {\n                 let data = FnData {\n+                    asyncness: header.asyncness,\n                     constness: header.constness,\n                     param_names: self.encode_fn_param_names_for_body(body),\n                     sig: self.lazy(tcx.fn_sig(def_id)),\n@@ -1649,20 +1652,22 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n-        match self.tcx.sess.dependency_formats.borrow().get(&config::CrateType::Dylib) {\n-            Some(arr) => {\n-                self.lazy(arr.iter().map(|slot| {\n-                    match *slot {\n-                        Linkage::NotLinked |\n-                        Linkage::IncludedFromDylib => None,\n-\n-                        Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n-                        Linkage::Static => Some(LinkagePreference::RequireStatic),\n-                    }\n-                }))\n+        let formats = self.tcx.dependency_formats(LOCAL_CRATE);\n+        for (ty, arr) in formats.iter() {\n+            if *ty != config::CrateType::Dylib {\n+                continue;\n             }\n-            None => Lazy::empty(),\n+            return self.lazy(arr.iter().map(|slot| {\n+                match *slot {\n+                    Linkage::NotLinked |\n+                    Linkage::IncludedFromDylib => None,\n+\n+                    Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n+                    Linkage::Static => Some(LinkagePreference::RequireStatic),\n+                }\n+            }));\n         }\n+        Lazy::empty()\n     }\n \n     fn encode_info_for_foreign_item(&mut self,\n@@ -1675,6 +1680,7 @@ impl EncodeContext<'tcx> {\n         let kind = match nitem.node {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n+                    asyncness: hir::IsAsync::NotAsync,\n                     constness: hir::Constness::NotConst,\n                     param_names: self.encode_fn_param_names(names),\n                     sig: self.lazy(tcx.fn_sig(def_id)),"}, {"sha": "9273b064ba9ceecc08821cc5adada0c484d699d7", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -32,6 +32,7 @@ mod schema;\n mod native_libs;\n mod link_args;\n mod foreign_modules;\n+mod dependency_format;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "92534ab056a8bc141ec02405fc7cd25da2c7f5bf", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -295,6 +295,7 @@ pub struct MacroDef {\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData<'tcx> {\n+    pub asyncness: hir::IsAsync,\n     pub constness: hir::Constness,\n     pub param_names: Lazy<[ast::Name]>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,"}, {"sha": "196bcf147f8f81ad2abc6b489a539b22598768f4", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1993,6 +1993,69 @@ fn get_owned_iterator() -> IntoIter<i32> {\n ```\n \"##,\n \n+E0524: r##\"\n+A variable which requires unique access is being used in more than one closure\n+at the same time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0524\n+fn set(x: &mut isize) {\n+    *x += 4;\n+}\n+\n+fn dragoooon(x: &mut isize) {\n+    let mut c1 = || set(x);\n+    let mut c2 = || set(x); // error!\n+\n+    c2();\n+    c1();\n+}\n+```\n+\n+To solve this issue, multiple solutions are available. First, is it required\n+for this variable to be used in more than one closure at a time? If it is the\n+case, use reference counted types such as `Rc` (or `Arc` if it runs\n+concurrently):\n+\n+```\n+use std::rc::Rc;\n+use std::cell::RefCell;\n+\n+fn set(x: &mut isize) {\n+    *x += 4;\n+}\n+\n+fn dragoooon(x: &mut isize) {\n+    let x = Rc::new(RefCell::new(x));\n+    let y = Rc::clone(&x);\n+    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&mut x2); };\n+    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&mut x2); }; // ok!\n+\n+    c2();\n+    c1();\n+}\n+```\n+\n+If not, just run closures one at a time:\n+\n+```\n+fn set(x: &mut isize) {\n+    *x += 4;\n+}\n+\n+fn dragoooon(x: &mut isize) {\n+    { // This block isn't necessary since non-lexical lifetimes, it's just to\n+      // make it more clear.\n+        let mut c1 = || set(&mut *x);\n+        c1();\n+    } // `c1` has been dropped here so we're free to use `x` again!\n+    let mut c2 = || set(&mut *x);\n+    c2();\n+}\n+```\n+\"##,\n+\n E0595: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -2393,7 +2456,6 @@ There are some known bugs that trigger this message.\n //  E0385, // {} in an aliasable location\n     E0493, // destructors cannot be evaluated at compile-time\n     E0521, // borrowed data escapes outside of closure\n-    E0524, // two closures require unique access to `..` at the same time\n     E0526, // shuffle indices are not constant\n     E0594, // cannot assign to {}\n //  E0598, // lifetime of {} is too short to guarantee its contents can be..."}, {"sha": "dc536329251ca0371872a6cbc17c42d2cb953261", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1253,7 +1253,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             expression.map(|expr| (expr, blk_id)),\n                         );\n                     }\n-                    ObligationCauseCode::ReturnType(id) => {\n+                    ObligationCauseCode::ReturnValue(id) => {\n                         db = self.report_return_mismatched_types(\n                             cause, expected, found, err, fcx, id, None);\n                     }"}, {"sha": "6b694bfc8da25eaa78970dc94fec2c8407231035", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -664,12 +664,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ret_ty = ret_coercion.borrow().expected_ty();\n         let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty.clone());\n-        ret_coercion.borrow_mut()\n-                    .coerce(self,\n-                            &self.cause(return_expr.span,\n-                                        ObligationCauseCode::ReturnType(return_expr.hir_id)),\n-                            return_expr,\n-                            return_expr_ty);\n+        ret_coercion.borrow_mut().coerce(\n+            self,\n+            &self.cause(return_expr.span, ObligationCauseCode::ReturnValue(return_expr.hir_id)),\n+            return_expr,\n+            return_expr_ty,\n+        );\n     }\n \n     /// Type check assignment expression `expr` of form `lhs = rhs`."}, {"sha": "02f4f2a3744c6666ceddc7e7377c625fc4eeac5d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -2698,30 +2698,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             traits::ObligationCause::new(span, self.body_id, code));\n     }\n \n-    pub fn require_type_is_sized(&self,\n-                                 ty: Ty<'tcx>,\n-                                 span: Span,\n-                                 code: traits::ObligationCauseCode<'tcx>)\n-    {\n-        let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n-        self.require_type_meets(ty, span, code, lang_item);\n+    pub fn require_type_is_sized(\n+        &self,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+        code: traits::ObligationCauseCode<'tcx>,\n+    ) {\n+        if !ty.references_error() {\n+            let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n+            self.require_type_meets(ty, span, code, lang_item);\n+        }\n     }\n \n-    pub fn require_type_is_sized_deferred(&self,\n-                                          ty: Ty<'tcx>,\n-                                          span: Span,\n-                                          code: traits::ObligationCauseCode<'tcx>)\n-    {\n-        self.deferred_sized_obligations.borrow_mut().push((ty, span, code));\n+    pub fn require_type_is_sized_deferred(\n+        &self,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+        code: traits::ObligationCauseCode<'tcx>,\n+    ) {\n+        if !ty.references_error() {\n+            self.deferred_sized_obligations.borrow_mut().push((ty, span, code));\n+        }\n     }\n \n-    pub fn register_bound(&self,\n-                          ty: Ty<'tcx>,\n-                          def_id: DefId,\n-                          cause: traits::ObligationCause<'tcx>)\n-    {\n-        self.fulfillment_cx.borrow_mut()\n-                           .register_bound(self, self.param_env, ty, def_id, cause);\n+    pub fn register_bound(\n+        &self,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+        cause: traits::ObligationCause<'tcx>,\n+    ) {\n+        if !ty.references_error() {\n+            self.fulfillment_cx.borrow_mut()\n+                .register_bound(self, self.param_env, ty, def_id, cause);\n+        }\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n@@ -2780,22 +2789,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Registers an obligation for checking later, during regionck, that the type `ty` must\n     /// outlive the region `r`.\n-    pub fn register_wf_obligation(&self,\n-                                  ty: Ty<'tcx>,\n-                                  span: Span,\n-                                  code: traits::ObligationCauseCode<'tcx>)\n-    {\n+    pub fn register_wf_obligation(\n+        &self,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+        code: traits::ObligationCauseCode<'tcx>,\n+    ) {\n         // WF obligations never themselves fail, so no real need to give a detailed cause:\n         let cause = traits::ObligationCause::new(span, self.body_id, code);\n-        self.register_predicate(traits::Obligation::new(cause,\n-                                                        self.param_env,\n-                                                        ty::Predicate::WellFormed(ty)));\n+        self.register_predicate(\n+            traits::Obligation::new(cause, self.param_env, ty::Predicate::WellFormed(ty)),\n+        );\n     }\n \n     /// Registers obligations that all types appearing in `substs` are well-formed.\n     pub fn add_wf_bounds(&self, substs: SubstsRef<'tcx>, expr: &hir::Expr) {\n         for ty in substs.types() {\n-            self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n+            if !ty.references_error() {\n+                self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n+            }\n         }\n     }\n \n@@ -2834,12 +2846,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // FIXME(arielb1): use this instead of field.ty everywhere\n     // Only for fields! Returns <none> for methods>\n     // Indifferent to privacy flags\n-    pub fn field_ty(&self,\n-                    span: Span,\n-                    field: &'tcx ty::FieldDef,\n-                    substs: SubstsRef<'tcx>)\n-                    -> Ty<'tcx>\n-    {\n+    pub fn field_ty(\n+        &self,\n+        span: Span,\n+        field: &'tcx ty::FieldDef,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Ty<'tcx> {\n         self.normalize_associated_types_in(span, &field.ty(self.tcx, substs))\n     }\n "}, {"sha": "265d0676fa8d1690a43b3db2a7a1c204ec46b6fc", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -596,7 +596,7 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     }\n     implied_bounds.extend(sig.inputs());\n \n-    fcx.register_wf_obligation(sig.output(), span, ObligationCauseCode::MiscObligation);\n+    fcx.register_wf_obligation(sig.output(), span, ObligationCauseCode::ReturnType);\n \n     // FIXME(#25759) return types should not be implied bounds\n     implied_bounds.push(sig.output());"}, {"sha": "479c8c37283052538e70cc8905146475652dd369", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -217,7 +217,7 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     } else {\n         hir::Constness::NotConst\n     };\n-\n+    let asyncness =  cx.tcx.asyncness(did);\n     let predicates = cx.tcx.predicates_of(did);\n     let (generics, decl) = clean::enter_impl_trait(cx, || {\n         ((cx.tcx.generics_of(did), &predicates).clean(cx), (did, sig).clean(cx))\n@@ -230,7 +230,7 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n             unsafety: sig.unsafety(),\n             abi: sig.abi(),\n             constness,\n-            asyncness: hir::IsAsync::NotAsync,\n+            asyncness,\n         },\n         all_types,\n         ret_types,"}, {"sha": "d1a9b740d62ab9bee36f5fa14d140d126df122be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -2403,6 +2403,7 @@ impl Clean<Item> for ty::AssocItem {\n                     } else {\n                         hir::Constness::NotConst\n                     };\n+                    let asyncness = cx.tcx.asyncness(self.def_id);\n                     let defaultness = match self.container {\n                         ty::ImplContainer(_) => Some(self.defaultness),\n                         ty::TraitContainer(_) => None,\n@@ -2414,7 +2415,7 @@ impl Clean<Item> for ty::AssocItem {\n                             unsafety: sig.unsafety(),\n                             abi: sig.abi(),\n                             constness,\n-                            asyncness: hir::IsAsync::NotAsync,\n+                            asyncness,\n                         },\n                         defaultness,\n                         all_types,"}, {"sha": "e92c0d1c58e411bd860dab52b71d1370f68ccf5f", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -236,8 +236,8 @@ impl<T: 'static> LocalKey<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with<F, R>(&'static self, f: F) -> R\n                       where F: FnOnce(&T) -> R {\n-        self.try_with(f).expect(\"cannot access a TLS value during or \\\n-                                 after it is destroyed\")\n+        self.try_with(f).expect(\"cannot access a Thread Local Storage value \\\n+                                 during or after destruction\")\n     }\n \n     /// Acquires a reference to the value in this TLS key."}, {"sha": "2423e1070fc3eb432cd5abf684df8f2365154375", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -112,6 +112,13 @@ impl Emitter for JsonEmitter {\n             panic!(\"failed to print notification: {:?}\", e);\n         }\n     }\n+\n+    fn should_show_explain(&self) -> bool {\n+        match self.json_rendered {\n+            HumanReadableErrorType::Short(_) => false,\n+            _ => true,\n+        }\n+    }\n }\n \n // The following data types are provided just for serialisation."}, {"sha": "9050e8f1671d9c790321dc72ee35a993db80f438", "filename": "src/test/codegen-units/partitioning/auxiliary/shared_generics_aux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,5 @@\n // compile-flags:-Zshare-generics=yes\n+// no-prefer-dynamic\n \n #![crate_type=\"rlib\"]\n "}, {"sha": "58e485be0032124577b629366771629fae44d438", "filename": "src/test/codegen-units/partitioning/shared-generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,5 @@\n // ignore-tidy-linelength\n+// no-prefer-dynamic\n // compile-flags:-Zprint-mono-items=eager -Zshare-generics=yes -Zincremental=tmp/partitioning-tests/shared-generics-exe\n \n #![crate_type=\"rlib\"]"}, {"sha": "671d44564e66fd3f64ea412c3852319a9a3363d5", "filename": "src/test/compile-fail/two-panic-runtimes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fcompile-fail%2Ftwo-panic-runtimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fcompile-fail%2Ftwo-panic-runtimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftwo-panic-runtimes.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -5,6 +5,7 @@\n // aux-build:panic-runtime-lang-items.rs\n \n #![no_std]\n+#![no_main]\n \n extern crate panic_runtime_unwind;\n extern crate panic_runtime_unwind2;"}, {"sha": "b2c6b8b3cbbf2bf4d15e5fdc3b71681a799522ae", "filename": "src/test/run-make-fulldeps/issue-64319/Makefile", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2FMakefile?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -0,0 +1,39 @@\n+-include ../tools.mk\n+\n+# Different optimization levels imply different values for `-Zshare-generics`,\n+# so try out a whole bunch of combinations to make sure everything is compatible\n+all:\n+\t# First up, try some defaults\n+\t$(RUSTC) --crate-type rlib foo.rs\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3\n+\n+\t# Next try mixing up some things explicitly\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n+\n+\t# Now combine a whole bunch of options together\n+\t$(RUSTC) --crate-type rlib foo.rs\n+\t$(RUSTC) --crate-type dylib bar.rs\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1 -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1 -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2 -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2 -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3 -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3 -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z -Z share-generics=yes"}, {"sha": "3895c0b6cdbb3d760b7df23c8934eca5da0210e8", "filename": "src/test/run-make-fulldeps/issue-64319/bar.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Fbar.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -0,0 +1,5 @@\n+extern crate foo;\n+\n+pub fn bar() {\n+    foo::foo();\n+}"}, {"sha": "c54a238e9add7f8ae13a1602df43d48467bf2b57", "filename": "src/test/run-make-fulldeps/issue-64319/foo.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Ffoo.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -0,0 +1,9 @@\n+pub fn foo() {\n+    bar::<usize>();\n+}\n+\n+pub fn bar<T>() {\n+    baz();\n+}\n+\n+fn baz() {}"}, {"sha": "840fe801a953c9ed4e7e35f8fd91ef5304b5ebb8", "filename": "src/test/run-make-fulldeps/symbol-visibility/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -79,12 +79,12 @@ all:\n \t# Check that a Rust dylib exports its monomorphic functions, including generics this time\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rust_dylib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"0\" ]\n \n \t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"0\" ]\n \n \t# Check that an executable does not export any dynamic symbols\n \t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]"}, {"sha": "913ba8f2a164921cbe434dae973c6a5bdee9066f", "filename": "src/test/rustdoc/inline_cross/auxiliary/impl_trait_aux.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fimpl_trait_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fimpl_trait_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fimpl_trait_aux.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,3 +1,5 @@\n+// edition:2018\n+\n use std::ops::Deref;\n \n pub fn func<'a>(_x: impl Clone + Into<Vec<u8>> + 'a) {}\n@@ -11,8 +13,16 @@ pub fn func3(_x: impl Iterator<Item = impl Iterator<Item = u8>> + Clone) {}\n \n pub fn func4<T: Iterator<Item = impl Clone>>(_x: T) {}\n \n+pub async fn async_fn() {}\n+\n pub struct Foo;\n \n impl Foo {\n     pub fn method<'a>(_x: impl Clone + Into<Vec<u8>> + 'a) {}\n }\n+\n+pub struct Bar;\n+\n+impl Bar {\n+    pub async fn async_foo(&self) {}\n+}"}, {"sha": "6f4a48c83c05ba3108f1b038e5f9b12197794631", "filename": "src/test/rustdoc/inline_cross/impl_trait.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,5 @@\n // aux-build:impl_trait_aux.rs\n+// edition:2018\n \n extern crate impl_trait_aux;\n \n@@ -20,13 +21,20 @@ pub use impl_trait_aux::func2;\n // @!has - '//pre[@class=\"rust fn\"]' 'where'\n pub use impl_trait_aux::func3;\n \n-\n // @has impl_trait/fn.func4.html\n // @has - '//pre[@class=\"rust fn\"]' \"func4<T>(\"\n // @has - '//pre[@class=\"rust fn\"]' \"T: Iterator<Item = impl Clone>,\"\n pub use impl_trait_aux::func4;\n \n+// @has impl_trait/fn.async_fn.html\n+// @has - '//pre[@class=\"rust fn\"]' \"pub async fn async_fn()\"\n+pub use impl_trait_aux::async_fn;\n+\n // @has impl_trait/struct.Foo.html\n // @has - '//code[@id=\"method.v\"]' \"pub fn method<'a>(_x: impl Clone + Into<Vec<u8>> + 'a)\"\n // @!has - '//code[@id=\"method.v\"]' 'where'\n pub use impl_trait_aux::Foo;\n+\n+// @has impl_trait/struct.Bar.html\n+// @has - '//*[@id=\"method.async_foo\"]' \"pub async fn async_foo(\"\n+pub use impl_trait_aux::Bar;"}, {"sha": "9a64a06c31badaefaf7408e686f9754d063ea68a", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,10 +1,10 @@\n #![feature(trait_alias)]\n \n trait Foo: Iterator<Item = i32> {}\n-trait Bar: Foo<Item = u32> {} //~ ERROR type annotations required\n+trait Bar: Foo<Item = u32> {} //~ ERROR type annotations needed\n \n trait I32Iterator = Iterator<Item = i32>;\n-trait U32Iterator = I32Iterator<Item = u32>;\n+trait U32Iterator = I32Iterator<Item = u32>; //~ ERROR type annotations needed\n \n fn main() {\n     let _: &dyn I32Iterator<Item = u32>;"}, {"sha": "5ef1b23cbcd213b94e036e3328a5f5d6bdccacef", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,11 +1,18 @@\n-error[E0284]: type annotations required: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n+error[E0284]: type annotations needed: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n   --> $DIR/associated-types-overridden-binding.rs:4:1\n    |\n LL | trait Foo: Iterator<Item = i32> {}\n    | ------------------------------- required by `Foo`\n LL | trait Bar: Foo<Item = u32> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0282]: type annotations needed\n+  --> $DIR/associated-types-overridden-binding.rs:7:1\n+   |\n+LL | trait U32Iterator = I32Iterator<Item = u32>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0284`.\n+Some errors have detailed explanations: E0282, E0284.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "b97d4af184f92f5c48887d3a19a9c01538e18637", "filename": "src/test/ui/associated-types/associated-types-unconstrained.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -12,5 +12,5 @@ impl Foo for isize {\n \n pub fn main() {\n     let x: isize = Foo::bar();\n-    //~^ ERROR type annotations required\n+    //~^ ERROR type annotations needed\n }"}, {"sha": "4e9e54d36880596e36abd9b91f090c4ac1821f4d", "filename": "src/test/ui/associated-types/associated-types-unconstrained.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0284]: type annotations required: cannot resolve `<_ as Foo>::A == _`\n+error[E0284]: type annotations needed: cannot resolve `<_ as Foo>::A == _`\n   --> $DIR/associated-types-unconstrained.rs:14:20\n    |\n LL |     let x: isize = Foo::bar();"}, {"sha": "d7e187a2b39580ba2927e5deb330d1473d57b2da", "filename": "src/test/ui/borrowck/borrowck-closures-mut-of-imm.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-mut-of-imm.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,10 +1,6 @@\n // Tests that two closures cannot simultaneously have mutable\n // and immutable access to the variable. Issue #6801.\n \n-fn get(x: &isize) -> isize {\n-    *x\n-}\n-\n fn set(x: &mut isize) {\n     *x = 4;\n }"}, {"sha": "784b903a5896acd1eb37d8ee87ecbfe50714fe37", "filename": "src/test/ui/borrowck/borrowck-closures-mut-of-imm.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-mut-of-imm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-mut-of-imm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-mut-of-imm.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,17 +1,17 @@\n error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n-  --> $DIR/borrowck-closures-mut-of-imm.rs:13:25\n+  --> $DIR/borrowck-closures-mut-of-imm.rs:9:25\n    |\n LL |     let mut c1 = || set(&mut *x);\n    |                         ^^^^^^^ cannot borrow as mutable\n \n error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n-  --> $DIR/borrowck-closures-mut-of-imm.rs:15:25\n+  --> $DIR/borrowck-closures-mut-of-imm.rs:11:25\n    |\n LL |     let mut c2 = || set(&mut *x);\n    |                         ^^^^^^^ cannot borrow as mutable\n \n error[E0524]: two closures require unique access to `x` at the same time\n-  --> $DIR/borrowck-closures-mut-of-imm.rs:15:18\n+  --> $DIR/borrowck-closures-mut-of-imm.rs:11:18\n    |\n LL |     let mut c1 = || set(&mut *x);\n    |                  --           - first borrow occurs due to use of `x` in closure\n@@ -28,4 +28,5 @@ LL |     c2(); c1();\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0596`.\n+Some errors have detailed explanations: E0524, E0596.\n+For more information about an error, try `rustc --explain E0524`."}, {"sha": "471173e595f4793cf3eec4844783c114a18d600f", "filename": "src/test/ui/borrowck/borrowck-closures-mut-of-mut.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-mut-of-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-mut-of-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-mut-of-mut.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -15,3 +15,4 @@ LL |     c2(); c1();\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0524`."}, {"sha": "2ed08b83c58b98a4d552a94ac47cf54c95853da2", "filename": "src/test/ui/borrowck/borrowck-closures-unique.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-unique.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-unique.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-unique.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -50,4 +50,5 @@ LL |     let c1 = |y: &'static mut isize| x = y;\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0500`.\n+Some errors have detailed explanations: E0500, E0524.\n+For more information about an error, try `rustc --explain E0500`."}, {"sha": "aba649d83ec0175ea908837e54f7003d9fd38ad6", "filename": "src/test/ui/error-codes/E0283.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations required: cannot resolve `_: Generator`\n+error[E0283]: type annotations needed: cannot resolve `_: Generator`\n   --> $DIR/E0283.rs:18:21\n    |\n LL |     fn create() -> u32;"}, {"sha": "c30e5f47188715df6f6d9d083e4f552ce5095205", "filename": "src/test/ui/error-codes/E0401.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -8,7 +8,7 @@ fn foo<T>(x: T) {\n            W: Fn()>\n            (y: T) { //~ ERROR E0401\n     }\n-    bfnr(x);\n+    bfnr(x); //~ ERROR type annotations needed\n }\n \n "}, {"sha": "485b76a09a3c43729c4b32f4bc9f6b31f9b68700", "filename": "src/test/ui/error-codes/E0401.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -32,6 +32,13 @@ LL |         fn helper(sel: &Self) -> u8 {\n    |                         use of generic parameter from outer function\n    |                         use a type here instead\n \n-error: aborting due to 3 previous errors\n+error[E0282]: type annotations needed\n+  --> $DIR/E0401.rs:11:5\n+   |\n+LL |     bfnr(x);\n+   |     ^^^^ cannot infer type for `U`\n+\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0401`.\n+Some errors have detailed explanations: E0282, E0401.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "5ac0c415ae1b27e5265ec35f3298d5a9072a9384", "filename": "src/test/ui/error-codes/E0661.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0661.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0661.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0661.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -3,7 +3,7 @@\n #![feature(asm)]\n \n fn main() {\n-    let a;\n+    let a; //~ ERROR type annotations needed\n     asm!(\"nop\" : \"r\"(a));\n     //~^ ERROR E0661\n }"}, {"sha": "3537e0bc3a4c61515a93f71b9613ec83dd72c65d", "filename": "src/test/ui/error-codes/E0661.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0661.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ferror-codes%2FE0661.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0661.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -4,5 +4,12 @@ error[E0661]: output operand constraint lacks '=' or '+'\n LL |     asm!(\"nop\" : \"r\"(a));\n    |                  ^^^\n \n-error: aborting due to previous error\n+error[E0282]: type annotations needed\n+  --> $DIR/E0661.rs:6:9\n+   |\n+LL |     let a;\n+   |         ^ consider giving `a` a type\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "65c4b78bf6a400f34a16dfdfb6924f13018eb977", "filename": "src/test/ui/impl-trait/where-allowed.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -11,8 +11,9 @@ fn in_return() -> impl Debug { panic!() }\n // Allowed\n fn in_adt_in_parameters(_: Vec<impl Debug>) { panic!() }\n \n-// Allowed\n+// Disallowed\n fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n+//~^ ERROR type annotations needed\n \n // Disallowed\n fn in_fn_parameter_in_parameters(_: fn(impl Debug)) { panic!() }\n@@ -58,7 +59,8 @@ fn in_impl_Fn_return_in_parameters(_: &impl Fn() -> impl Debug) { panic!() }\n // Disallowed\n fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-//~^^ ERROR nested `impl Trait` is not allowed\n+//~| ERROR nested `impl Trait` is not allowed\n+//~| ERROR type annotations needed\n \n // Disallowed\n fn in_impl_Fn_return_in_return() -> &'static impl Fn() -> impl Debug { panic!() }"}, {"sha": "dfb6e6524d9a5844c0ac6631729b0a619c1d2d9b", "filename": "src/test/ui/impl-trait/where-allowed.stderr", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,5 +1,5 @@\n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/where-allowed.rs:50:51\n+  --> $DIR/where-allowed.rs:51:51\n    |\n LL | fn in_impl_Fn_parameter_in_parameters(_: &impl Fn(impl Debug)) { panic!() }\n    |                                           --------^^^^^^^^^^-\n@@ -8,7 +8,7 @@ LL | fn in_impl_Fn_parameter_in_parameters(_: &impl Fn(impl Debug)) { panic!() }\n    |                                           outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/where-allowed.rs:59:57\n+  --> $DIR/where-allowed.rs:60:57\n    |\n LL | fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n    |                                                 --------^^^^^^^^^^-\n@@ -17,7 +17,7 @@ LL | fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic\n    |                                                 outer `impl Trait`\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/where-allowed.rs:122:5\n+  --> $DIR/where-allowed.rs:124:5\n    |\n LL |     type Out = impl Debug;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |     type Out = impl Debug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/where-allowed.rs:158:1\n+  --> $DIR/where-allowed.rs:160:1\n    |\n LL | type InTypeAlias<R> = impl Debug;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -35,230 +35,242 @@ LL | type InTypeAlias<R> = impl Debug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:18:40\n+  --> $DIR/where-allowed.rs:19:40\n    |\n LL | fn in_fn_parameter_in_parameters(_: fn(impl Debug)) { panic!() }\n    |                                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:22:42\n+  --> $DIR/where-allowed.rs:23:42\n    |\n LL | fn in_fn_return_in_parameters(_: fn() -> impl Debug) { panic!() }\n    |                                          ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:26:38\n+  --> $DIR/where-allowed.rs:27:38\n    |\n LL | fn in_fn_parameter_in_return() -> fn(impl Debug) { panic!() }\n    |                                      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:30:40\n+  --> $DIR/where-allowed.rs:31:40\n    |\n LL | fn in_fn_return_in_return() -> fn() -> impl Debug { panic!() }\n    |                                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:34:49\n+  --> $DIR/where-allowed.rs:35:49\n    |\n LL | fn in_dyn_Fn_parameter_in_parameters(_: &dyn Fn(impl Debug)) { panic!() }\n    |                                                 ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:38:51\n+  --> $DIR/where-allowed.rs:39:51\n    |\n LL | fn in_dyn_Fn_return_in_parameters(_: &dyn Fn() -> impl Debug) { panic!() }\n    |                                                   ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:42:55\n+  --> $DIR/where-allowed.rs:43:55\n    |\n LL | fn in_dyn_Fn_parameter_in_return() -> &'static dyn Fn(impl Debug) { panic!() }\n    |                                                       ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:46:57\n+  --> $DIR/where-allowed.rs:47:57\n    |\n LL | fn in_dyn_Fn_return_in_return() -> &'static dyn Fn() -> impl Debug { panic!() }\n    |                                                         ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:50:51\n+  --> $DIR/where-allowed.rs:51:51\n    |\n LL | fn in_impl_Fn_parameter_in_parameters(_: &impl Fn(impl Debug)) { panic!() }\n    |                                                   ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:55:53\n+  --> $DIR/where-allowed.rs:56:53\n    |\n LL | fn in_impl_Fn_return_in_parameters(_: &impl Fn() -> impl Debug) { panic!() }\n    |                                                     ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:59:57\n+  --> $DIR/where-allowed.rs:60:57\n    |\n LL | fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n    |                                                         ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:64:59\n+  --> $DIR/where-allowed.rs:66:59\n    |\n LL | fn in_impl_Fn_return_in_return() -> &'static impl Fn() -> impl Debug { panic!() }\n    |                                                           ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:68:38\n+  --> $DIR/where-allowed.rs:70:38\n    |\n LL | fn in_Fn_parameter_in_generics<F: Fn(impl Debug)> (_: F) { panic!() }\n    |                                      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:72:40\n+  --> $DIR/where-allowed.rs:74:40\n    |\n LL | fn in_Fn_return_in_generics<F: Fn() -> impl Debug> (_: F) { panic!() }\n    |                                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:85:32\n+  --> $DIR/where-allowed.rs:87:32\n    |\n LL | struct InBraceStructField { x: impl Debug }\n    |                                ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:89:41\n+  --> $DIR/where-allowed.rs:91:41\n    |\n LL | struct InAdtInBraceStructField { x: Vec<impl Debug> }\n    |                                         ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:93:27\n+  --> $DIR/where-allowed.rs:95:27\n    |\n LL | struct InTupleStructField(impl Debug);\n    |                           ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:98:25\n+  --> $DIR/where-allowed.rs:100:25\n    |\n LL |     InBraceVariant { x: impl Debug },\n    |                         ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:100:20\n+  --> $DIR/where-allowed.rs:102:20\n    |\n LL |     InTupleVariant(impl Debug),\n    |                    ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:111:23\n+  --> $DIR/where-allowed.rs:113:23\n    |\n LL |     fn in_return() -> impl Debug;\n    |                       ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:129:34\n+  --> $DIR/where-allowed.rs:131:34\n    |\n LL |     fn in_trait_impl_return() -> impl Debug { () }\n    |                                  ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:142:33\n+  --> $DIR/where-allowed.rs:144:33\n    |\n LL |     fn in_foreign_parameters(_: impl Debug);\n    |                                 ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:145:31\n+  --> $DIR/where-allowed.rs:147:31\n    |\n LL |     fn in_foreign_return() -> impl Debug;\n    |                               ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:162:39\n+  --> $DIR/where-allowed.rs:164:39\n    |\n LL | type InReturnInTypeAlias<R> = fn() -> impl Debug;\n    |                                       ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:166:16\n+  --> $DIR/where-allowed.rs:168:16\n    |\n LL | impl PartialEq<impl Debug> for () {\n    |                ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:171:24\n+  --> $DIR/where-allowed.rs:173:24\n    |\n LL | impl PartialEq<()> for impl Debug {\n    |                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:176:6\n+  --> $DIR/where-allowed.rs:178:6\n    |\n LL | impl impl Debug {\n    |      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:182:24\n+  --> $DIR/where-allowed.rs:184:24\n    |\n LL | impl InInherentImplAdt<impl Debug> {\n    |                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:188:11\n+  --> $DIR/where-allowed.rs:190:11\n    |\n LL |     where impl Debug: Debug\n    |           ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:195:15\n+  --> $DIR/where-allowed.rs:197:15\n    |\n LL |     where Vec<impl Debug>: Debug\n    |               ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:202:24\n+  --> $DIR/where-allowed.rs:204:24\n    |\n LL |     where T: PartialEq<impl Debug>\n    |                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:209:17\n+  --> $DIR/where-allowed.rs:211:17\n    |\n LL |     where T: Fn(impl Debug)\n    |                 ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:216:22\n+  --> $DIR/where-allowed.rs:218:22\n    |\n LL |     where T: Fn() -> impl Debug\n    |                      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:222:29\n+  --> $DIR/where-allowed.rs:224:29\n    |\n LL |     let _in_local_variable: impl Fn() = || {};\n    |                             ^^^^^^^^^\n    |\n    = help: add `#![feature(impl_trait_in_bindings)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:224:46\n+  --> $DIR/where-allowed.rs:226:46\n    |\n LL |     let _in_return_in_local_variable = || -> impl Fn() { || {} };\n    |                                              ^^^^^^^^^\n \n+error[E0282]: type annotations needed\n+  --> $DIR/where-allowed.rs:15:30\n+   |\n+LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n+   |                              ^^^^^^^^^^ cannot infer type\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/where-allowed.rs:60:49\n+   |\n+LL | fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n+   |                                                 ^^^^^^^^^^^^^^^^^^^ cannot infer type\n+\n error: could not find defining uses\n-  --> $DIR/where-allowed.rs:158:1\n+  --> $DIR/where-allowed.rs:160:1\n    |\n LL | type InTypeAlias<R> = impl Debug;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/where-allowed.rs:122:5\n+  --> $DIR/where-allowed.rs:124:5\n    |\n LL |     type Out = impl Debug;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 41 previous errors\n+error: aborting due to 43 previous errors\n \n-Some errors have detailed explanations: E0562, E0658.\n-For more information about an error, try `rustc --explain E0562`.\n+Some errors have detailed explanations: E0282, E0562, E0658.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "7503766ff2084c78e66864ac2f24dbf990d1a00e", "filename": "src/test/ui/issues/issue-12028.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-12028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-12028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -24,7 +24,7 @@ trait StreamHash<H: StreamHasher>: Hash<H> {\n impl<H: StreamHasher> Hash<H> for u8 {\n     fn hash2(&self, hasher: &H) -> u64 {\n         let mut stream = hasher.stream();\n-        self.input_stream(&mut stream); //~ ERROR type annotations required\n+        self.input_stream(&mut stream); //~ ERROR type annotations needed\n         Stream::result(&stream)\n     }\n }"}, {"sha": "ff92d01a69ed2aef9abc045ff2e7742c778430a5", "filename": "src/test/ui/issues/issue-12028.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0284]: type annotations required: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n+error[E0284]: type annotations needed: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n   --> $DIR/issue-12028.rs:27:14\n    |\n LL |         self.input_stream(&mut stream);"}, {"sha": "0cbe38d6ec0b6b4b4d18a65a4b19c5fb990943e0", "filename": "src/test/ui/issues/issue-21974.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-21974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-21974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21974.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -7,7 +7,7 @@ trait Foo {\n     fn foo(self);\n }\n \n-fn foo<'a,'b,T>(x: &'a T, y: &'b T) //~ ERROR type annotations required\n+fn foo<'a,'b,T>(x: &'a T, y: &'b T) //~ ERROR type annotations needed\n     where &'a T : Foo,\n           &'b T : Foo\n {"}, {"sha": "7ceb2bd23f6cd5799fafd8d87fdb8d11e5bd453e", "filename": "src/test/ui/issues/issue-21974.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations required: cannot resolve `&'a T: Foo`\n+error[E0283]: type annotations needed: cannot resolve `&'a T: Foo`\n   --> $DIR/issue-21974.rs:10:1\n    |\n LL |   trait Foo {"}, {"sha": "9b74cd1230e8a9a500790a0ae67162cf6156f820", "filename": "src/test/ui/issues/issue-24424.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-24424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-24424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24424.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -2,6 +2,6 @@ trait Trait1<'l0, T0> {}\n trait Trait0<'l0>  {}\n \n impl <'l0, 'l1, T0> Trait1<'l0, T0> for bool where T0 : Trait0<'l0>, T0 : Trait0<'l1> {}\n-//~^ ERROR type annotations required: cannot resolve `T0: Trait0<'l0>`\n+//~^ ERROR type annotations needed: cannot resolve `T0: Trait0<'l0>`\n \n fn main() {}"}, {"sha": "8c539f7cedd19e555151ac774f3c2fc1fb645373", "filename": "src/test/ui/issues/issue-24424.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations required: cannot resolve `T0: Trait0<'l0>`\n+error[E0283]: type annotations needed: cannot resolve `T0: Trait0<'l0>`\n   --> $DIR/issue-24424.rs:4:1\n    |\n LL | trait Trait0<'l0>  {}"}, {"sha": "c9dd92fca7dc8cf59745bb2eea3f9d2111c31909", "filename": "src/test/ui/issues/issue-29147.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-29147.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-29147.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29147.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations required: cannot resolve `S5<_>: Foo`\n+error[E0283]: type annotations needed: cannot resolve `S5<_>: Foo`\n   --> $DIR/issue-29147.rs:21:13\n    |\n LL | trait Foo { fn xxx(&self); }"}, {"sha": "9e9f92ed9ace5c970589bf4ddada78efdd975a26", "filename": "src/test/ui/issues/issue-54954.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-54954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-54954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54954.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,7 +1,7 @@\n #![feature(const_fn)]\n \n const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n-//~^ ERROR constant contains unimplemented expression type\n+//~^ ERROR type annotations needed\n \n trait Tt {\n     const fn const_val<T: Sized>() -> usize {\n@@ -11,6 +11,8 @@ trait Tt {\n }\n \n fn f(z: [f32; ARR_LEN]) -> [f32; ARR_LEN] {\n+    //~^ ERROR evaluation of constant value failed\n+    //~| ERROR evaluation of constant value failed\n     z\n }\n "}, {"sha": "56ccdaf7aac4064b2e0131228bfe8c245b5e9589", "filename": "src/test/ui/issues/issue-54954.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -4,13 +4,28 @@ error[E0379]: trait fns cannot be declared const\n LL |     const fn const_val<T: Sized>() -> usize {\n    |     ^^^^^ trait fns cannot be const\n \n-error[E0019]: constant contains unimplemented expression type\n+error[E0283]: type annotations needed: cannot resolve `_: Tt`\n   --> $DIR/issue-54954.rs:3:24\n    |\n LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     const fn const_val<T: Sized>() -> usize {\n+   |              --------- - required by this bound in `Tt::const_val`\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-54954.rs:13:15\n+   |\n+LL | fn f(z: [f32; ARR_LEN]) -> [f32; ARR_LEN] {\n+   |               ^^^^^^^ referenced constant has errors\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-54954.rs:13:34\n+   |\n+LL | fn f(z: [f32; ARR_LEN]) -> [f32; ARR_LEN] {\n+   |                                  ^^^^^^^ referenced constant has errors\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0019, E0379.\n-For more information about an error, try `rustc --explain E0019`.\n+Some errors have detailed explanations: E0080, E0283, E0379.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "d9f68023ce76d60c91f1a330e8d196050cc3e1b6", "filename": "src/test/ui/json-short.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fjson-short.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fjson-short.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-short.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -15,5 +15,3 @@ started: https://doc.rust-lang.org/book/\n \"}\n {\"message\":\"aborting due to previous error\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to previous error\n \"}\n-{\"message\":\"For more information about this error, try `rustc --explain E0601`.\",\"code\":null,\"level\":\"failure-note\",\"spans\":[],\"children\":[],\"rendered\":\"For more information about this error, try `rustc --explain E0601`.\n-\"}"}, {"sha": "49fe7d1324ca8ea9433fc95caacc767d953dd82d", "filename": "src/test/ui/methods/method-ambig-one-trait-unknown-int-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -15,7 +15,7 @@ impl Foo for Vec<isize> {\n }\n \n // This is very hokey: we have heuristics to suppress messages about\n-// type annotations required. But placing these two bits of code into\n+// type annotations needed. But placing these two bits of code into\n // distinct functions, in this order, causes us to print out both\n // errors I'd like to see.\n "}, {"sha": "0b15d9bcfe68c0d169e0b925d9bae179b185b582", "filename": "src/test/ui/nll/closures-in-loops.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -27,5 +27,5 @@ LL |         v.push(|| *x = String::new());\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0382, E0499.\n+Some errors have detailed explanations: E0382, E0499, E0524.\n For more information about an error, try `rustc --explain E0382`."}, {"sha": "5d72771c2dcff1bdff532ec1214b0acb67daa901", "filename": "src/test/ui/panic-runtime/transitive-link-a-bunch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpanic-runtime%2Ftransitive-link-a-bunch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpanic-runtime%2Ftransitive-link-a-bunch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Ftransitive-link-a-bunch.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -7,9 +7,8 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![no_std]\n+#![no_main]\n \n extern crate wants_panic_runtime_unwind;\n extern crate wants_panic_runtime_abort;\n extern crate panic_runtime_lang_items;\n-\n-fn main() {}"}, {"sha": "4c25c09d6438f3146ca04a355be849481707add5", "filename": "src/test/ui/panic-runtime/want-unwind-got-abort.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -4,8 +4,7 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![no_std]\n+#![no_main]\n \n extern crate panic_runtime_abort;\n extern crate panic_runtime_lang_items;\n-\n-fn main() {}"}, {"sha": "478af451e7f657bbd73ecceb3ca5b180027019ca", "filename": "src/test/ui/panic-runtime/want-unwind-got-abort2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort2.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -5,8 +5,7 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![no_std]\n+#![no_main]\n \n extern crate wants_panic_runtime_abort;\n extern crate panic_runtime_lang_items;\n-\n-fn main() {}"}, {"sha": "a0c9e24c235d6598495527da0354df3244a11d09", "filename": "src/test/ui/parser/raw/raw-literal-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let r#self;\n+    let r#self: ();\n     //~^ ERROR `self` cannot be a raw identifier\n }"}, {"sha": "2a40dfe200cde937ab0bd941735dc7a26b6fc531", "filename": "src/test/ui/parser/raw/raw-literal-self.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,7 +1,7 @@\n error: `self` cannot be a raw identifier\n   --> $DIR/raw-literal-self.rs:2:9\n    |\n-LL |     let r#self;\n+LL |     let r#self: ();\n    |         ^^^^^^\n \n error: aborting due to previous error"}, {"sha": "a9d9e13a9d9ec9d8d4d3b99a551145bc625bdbab", "filename": "src/test/ui/parser/raw/raw-literal-underscore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let r#_;\n+    let r#_: ();\n     //~^ ERROR `_` cannot be a raw identifier\n }"}, {"sha": "d7a364d8579efa17e0891a8feee9edd75d5a0720", "filename": "src/test/ui/parser/raw/raw-literal-underscore.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,7 +1,7 @@\n error: `_` cannot be a raw identifier\n   --> $DIR/raw-literal-underscore.rs:2:9\n    |\n-LL |     let r#_;\n+LL |     let r#_: ();\n    |         ^^^\n \n error: aborting due to previous error"}, {"sha": "31620216e82e1f19973da1169569adb0a6d6690c", "filename": "src/test/ui/pattern/rest-pat-semantic-disallowed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -31,6 +31,7 @@ fn rest_patterns() {\n \n     // Ident patterns:\n     let x @ ..; //~ ERROR `..` patterns are not allowed here\n+    //~^ ERROR type annotations needed\n     let ref x @ ..; //~ ERROR `..` patterns are not allowed here\n     let ref mut x @ ..; //~ ERROR `..` patterns are not allowed here\n "}, {"sha": "be484e3a4d417694e15c7ef798e7b0cee9bfdc37", "filename": "src/test/ui/pattern/rest-pat-semantic-disallowed.stderr", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -58,31 +58,31 @@ LL |     let x @ ..;\n    = note: only allowed in tuple, tuple struct, and slice patterns\n \n error: `..` patterns are not allowed here\n-  --> $DIR/rest-pat-semantic-disallowed.rs:34:17\n+  --> $DIR/rest-pat-semantic-disallowed.rs:35:17\n    |\n LL |     let ref x @ ..;\n    |                 ^^\n    |\n    = note: only allowed in tuple, tuple struct, and slice patterns\n \n error: `..` patterns are not allowed here\n-  --> $DIR/rest-pat-semantic-disallowed.rs:35:21\n+  --> $DIR/rest-pat-semantic-disallowed.rs:36:21\n    |\n LL |     let ref mut x @ ..;\n    |                     ^^\n    |\n    = note: only allowed in tuple, tuple struct, and slice patterns\n \n error: `..` can only be used once per tuple pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:42:9\n+  --> $DIR/rest-pat-semantic-disallowed.rs:43:9\n    |\n LL |         ..,\n    |         -- previously used here\n LL |         ..,\n    |         ^^ can only be used once per tuple pattern\n \n error: `..` can only be used once per tuple pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:43:9\n+  --> $DIR/rest-pat-semantic-disallowed.rs:44:9\n    |\n LL |         ..,\n    |         -- previously used here\n@@ -91,7 +91,7 @@ LL |         ..\n    |         ^^ can only be used once per tuple pattern\n \n error: `..` can only be used once per tuple pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:48:9\n+  --> $DIR/rest-pat-semantic-disallowed.rs:49:9\n    |\n LL |         ..,\n    |         -- previously used here\n@@ -100,15 +100,15 @@ LL |         ..\n    |         ^^ can only be used once per tuple pattern\n \n error: `..` can only be used once per tuple struct pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:58:9\n+  --> $DIR/rest-pat-semantic-disallowed.rs:59:9\n    |\n LL |         ..,\n    |         -- previously used here\n LL |         ..,\n    |         ^^ can only be used once per tuple struct pattern\n \n error: `..` can only be used once per tuple struct pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:59:9\n+  --> $DIR/rest-pat-semantic-disallowed.rs:60:9\n    |\n LL |         ..,\n    |         -- previously used here\n@@ -117,7 +117,7 @@ LL |         ..\n    |         ^^ can only be used once per tuple struct pattern\n \n error: `..` can only be used once per tuple struct pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:64:9\n+  --> $DIR/rest-pat-semantic-disallowed.rs:65:9\n    |\n LL |         ..,\n    |         -- previously used here\n@@ -126,15 +126,15 @@ LL |         ..\n    |         ^^ can only be used once per tuple struct pattern\n \n error: `..` can only be used once per slice pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:72:9\n+  --> $DIR/rest-pat-semantic-disallowed.rs:73:9\n    |\n LL |         ..,\n    |         -- previously used here\n LL |         ..,\n    |         ^^ can only be used once per slice pattern\n \n error: `..` can only be used once per slice pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:73:9\n+  --> $DIR/rest-pat-semantic-disallowed.rs:74:9\n    |\n LL |         ..,\n    |         -- previously used here\n@@ -143,15 +143,15 @@ LL |         ..\n    |         ^^ can only be used once per slice pattern\n \n error: `..` can only be used once per slice pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:77:17\n+  --> $DIR/rest-pat-semantic-disallowed.rs:78:17\n    |\n LL |         ..,\n    |         -- previously used here\n LL |         ref x @ ..,\n    |                 ^^ can only be used once per slice pattern\n \n error: `..` can only be used once per slice pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:78:21\n+  --> $DIR/rest-pat-semantic-disallowed.rs:79:21\n    |\n LL |         ..,\n    |         -- previously used here\n@@ -160,15 +160,15 @@ LL |         ref mut y @ ..,\n    |                     ^^ can only be used once per slice pattern\n \n error: `..` patterns are not allowed here\n-  --> $DIR/rest-pat-semantic-disallowed.rs:79:18\n+  --> $DIR/rest-pat-semantic-disallowed.rs:80:18\n    |\n LL |         (ref z @ ..),\n    |                  ^^\n    |\n    = note: only allowed in tuple, tuple struct, and slice patterns\n \n error: `..` can only be used once per slice pattern\n-  --> $DIR/rest-pat-semantic-disallowed.rs:80:9\n+  --> $DIR/rest-pat-semantic-disallowed.rs:81:9\n    |\n LL |         ..,\n    |         -- previously used here\n@@ -184,5 +184,12 @@ LL |     fn foo(..: u8) {}\n    |\n    = note: only allowed in tuple, tuple struct, and slice patterns\n \n-error: aborting due to 22 previous errors\n+error[E0282]: type annotations needed\n+  --> $DIR/rest-pat-semantic-disallowed.rs:33:9\n+   |\n+LL |     let x @ ..;\n+   |         ^^^^^^ consider giving this pattern a type\n+\n+error: aborting due to 23 previous errors\n \n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "95ee01a70ceadddf48da9af731211c3c53f5d0e0", "filename": "src/test/ui/question-mark-type-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fquestion-mark-type-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fquestion-mark-type-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquestion-mark-type-infer.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -9,7 +9,7 @@ fn f(x: &i32) -> Result<i32, ()> {\n \n fn g() -> Result<Vec<i32>, ()> {\n     let l = [1, 2, 3, 4];\n-    l.iter().map(f).collect()? //~ ERROR type annotations required: cannot resolve\n+    l.iter().map(f).collect()? //~ ERROR type annotations needed: cannot resolve\n }\n \n fn main() {"}, {"sha": "53a170e7d431ce40e7653787e467337db320c212", "filename": "src/test/ui/question-mark-type-infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0284]: type annotations required: cannot resolve `<_ as std::ops::Try>::Ok == _`\n+error[E0284]: type annotations needed: cannot resolve `<_ as std::ops::Try>::Ok == _`\n   --> $DIR/question-mark-type-infer.rs:12:5\n    |\n LL |     l.iter().map(f).collect()?"}, {"sha": "e2680446f851a891664e1b3631864707372f67c8", "filename": "src/test/ui/rfc-2565-param-attrs/proc-macro-cannot-be-used.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -20,7 +20,7 @@ type Alias = extern \"C\" fn(#[id] u8, #[id] ...);\n \n fn free(#[id] arg1: u8) {\n     //~^ ERROR expected an inert attribute, found an attribute macro\n-    let lam = |#[id] W(x), #[id] y| ();\n+    let lam = |#[id] W(x), #[id] y: usize| ();\n     //~^ ERROR expected an inert attribute, found an attribute macro\n     //~| ERROR expected an inert attribute, found an attribute macro\n }"}, {"sha": "4654dc1b496f2c8801bc3196eb111174001e72fc", "filename": "src/test/ui/rfc-2565-param-attrs/proc-macro-cannot-be-used.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -37,13 +37,13 @@ LL | fn free(#[id] arg1: u8) {\n error: expected an inert attribute, found an attribute macro\n   --> $DIR/proc-macro-cannot-be-used.rs:23:16\n    |\n-LL |     let lam = |#[id] W(x), #[id] y| ();\n+LL |     let lam = |#[id] W(x), #[id] y: usize| ();\n    |                ^^^^^\n \n error: expected an inert attribute, found an attribute macro\n   --> $DIR/proc-macro-cannot-be-used.rs:23:28\n    |\n-LL |     let lam = |#[id] W(x), #[id] y| ();\n+LL |     let lam = |#[id] W(x), #[id] y: usize| ();\n    |                            ^^^^^\n \n error: expected an inert attribute, found an attribute macro"}, {"sha": "759416d1901db95207023c70b06f1c871ef2da64", "filename": "src/test/ui/traits/trait-static-method-generic-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftraits%2Ftrait-static-method-generic-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftraits%2Ftrait-static-method-generic-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-static-method-generic-inference.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -22,7 +22,7 @@ mod base {\n \n pub fn foo() {\n     let _f: base::Foo = base::HasNew::new();\n-    //~^ ERROR type annotations required\n+    //~^ ERROR type annotations needed\n }\n \n fn main() { }"}, {"sha": "22931c5ba32e9bcb34d4540c34a7fc362e399407", "filename": "src/test/ui/traits/trait-static-method-generic-inference.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftraits%2Ftrait-static-method-generic-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftraits%2Ftrait-static-method-generic-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-static-method-generic-inference.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations required: cannot resolve `_: base::HasNew<base::Foo>`\n+error[E0283]: type annotations needed: cannot resolve `_: base::HasNew<base::Foo>`\n   --> $DIR/trait-static-method-generic-inference.rs:24:25\n    |\n LL |         fn new() -> T;"}, {"sha": "3b1521d5c028b387f4cd4aff36de98863206d82e", "filename": "src/test/ui/type/type-annotation-needed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -4,5 +4,5 @@ fn foo<T: Into<String>>(x: i32) {}\n \n fn main() {\n     foo(42);\n-    //~^ ERROR type annotations required\n+    //~^ ERROR type annotations needed\n }"}, {"sha": "460bbe9dbc4f95f0af5494c339c685480a7fc0dd", "filename": "src/test/ui/type/type-annotation-needed.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations required: cannot resolve `_: std::convert::Into<std::string::String>`\n+error[E0283]: type annotations needed: cannot resolve `_: std::convert::Into<std::string::String>`\n   --> $DIR/type-annotation-needed.rs:6:5\n    |\n LL | fn foo<T: Into<String>>(x: i32) {}"}, {"sha": "7e6429ccfbe30fccfbab2826b38f267869e4f454", "filename": "src/test/ui/type/type-check/issue-40294.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -2,7 +2,7 @@ trait Foo: Sized {\n     fn foo(self);\n }\n \n-fn foo<'a,'b,T>(x: &'a T, y: &'b T) //~ ERROR type annotations required\n+fn foo<'a,'b,T>(x: &'a T, y: &'b T) //~ ERROR type annotations needed\n     where &'a T : Foo,\n           &'b T : Foo\n {"}, {"sha": "508783aaf2b0ebf87364f02f6c4e053a9ccda39f", "filename": "src/test/ui/type/type-check/issue-40294.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations required: cannot resolve `&'a T: Foo`\n+error[E0283]: type annotations needed: cannot resolve `&'a T: Foo`\n   --> $DIR/issue-40294.rs:5:1\n    |\n LL |   trait Foo: Sized {"}, {"sha": "15adfebb334006d4b3c94670e3160691d4954dc4", "filename": "src/test/ui/type/type-path-err-node-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.rs?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -20,7 +20,7 @@ fn method() {\n }\n \n fn closure() {\n-    let _ = |a, b: _| -> _ { 0 }; // OK\n+    let _ = |a, b: _| -> _ { 0 }; //~ ERROR type annotations needed\n }\n \n fn main() {}"}, {"sha": "cd93525c762192e970bdd929589b62de428a5f57", "filename": "src/test/ui/type/type-path-err-node-types.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7820b28937ba875521a2525cf75223c80faf9f2/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -22,7 +22,13 @@ error[E0425]: cannot find value `nonexistent` in this scope\n LL |     nonexistent.nonexistent::<u8>();\n    |     ^^^^^^^^^^^ not found in this scope\n \n-error: aborting due to 4 previous errors\n+error[E0282]: type annotations needed\n+  --> $DIR/type-path-err-node-types.rs:23:14\n+   |\n+LL |     let _ = |a, b: _| -> _ { 0 };\n+   |              ^ consider giving this closure parameter a type\n+\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0412, E0425, E0433.\n-For more information about an error, try `rustc --explain E0412`.\n+Some errors have detailed explanations: E0282, E0412, E0425, E0433.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "aa6b7e01abce30091cc594cb23a15c46cead6e24", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=b7820b28937ba875521a2525cf75223c80faf9f2", "patch": "@@ -1 +1 @@\n-Subproject commit b6c6f685b38d523580813b0031677c2298f458ea\n+Subproject commit aa6b7e01abce30091cc594cb23a15c46cead6e24"}]}