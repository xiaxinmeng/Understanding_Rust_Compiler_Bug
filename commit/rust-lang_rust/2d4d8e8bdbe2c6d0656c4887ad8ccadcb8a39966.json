{"sha": "2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNGQ4ZThiZGJlMmM2ZDA2NTZjNDg4N2FkOGNjYWRjYjhhMzk5NjY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-25T15:44:51Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-25T19:47:11Z"}, "message": "Implement implicit self type parameters for ifaces\n\nCloses #1661", "tree": {"sha": "80aa0c77bcad42213b2db6d2f3c301f97f52e110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80aa0c77bcad42213b2db6d2f3c301f97f52e110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "html_url": "https://github.com/rust-lang/rust/commit/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76aabbe99d598dc42e8e3723d98516422bd26d33", "url": "https://api.github.com/repos/rust-lang/rust/commits/76aabbe99d598dc42e8e3723d98516422bd26d33", "html_url": "https://github.com/rust-lang/rust/commit/76aabbe99d598dc42e8e3723d98516422bd26d33"}], "stats": {"total": 174, "additions": 102, "deletions": 72}, "files": [{"sha": "ffea622d022a35e5db6e81ae1601a1035edff60e", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "patch": "@@ -128,14 +128,15 @@ fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     result\n }\n \n-fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n-    -> @[ty::param_bounds] {\n-    let bounds = [];\n+fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd,\n+                        skip: bool) -> @[ty::param_bounds] {\n+    let bounds = [], skip = skip;\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, {|did|\n             translate_def_id(cdata, did)\n         });\n-        bounds += [bd];\n+        if skip { skip = false; }\n+        else { bounds += [bd]; }\n     }\n     @bounds\n }\n@@ -218,8 +219,9 @@ fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n     let item = lookup_item(id, cdata.data);\n     let t = item_type(item, tcx, cdata);\n-    let tp_bounds = if family_has_type_params(item_family(item)) {\n-        item_ty_param_bounds(item, tcx, cdata)\n+    let family = item_family(item);\n+    let tp_bounds = if family_has_type_params(family) {\n+        item_ty_param_bounds(item, tcx, cdata, family == ('I' as u8))\n     } else { @[] };\n     ret {bounds: tp_bounds, ty: t};\n }\n@@ -302,7 +304,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let data = cdata.data;\n     let item = lookup_item(id, data), result = [];\n     ebml::tagged_docs(item, tag_item_method) {|mth|\n-        let bounds = item_ty_param_bounds(mth, tcx, cdata);\n+        let bounds = item_ty_param_bounds(mth, tcx, cdata, false);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n         let fty = alt ty::struct(tcx, ty) { ty::ty_fn(f) { f } };"}, {"sha": "ce799e5e0bb42377441bfb55ad459f9f43117992", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "patch": "@@ -1014,7 +1014,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n         } { ret some(ast::def_ty_param(local_def(tp.id), n)); }\n         n += 1u;\n     }\n-    ret none::<def>;\n+    ret none;\n }\n \n fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option::t<def_id> {"}, {"sha": "0004f81cb4e3a732a261e09456675c1dbfdd2ab2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "patch": "@@ -892,7 +892,7 @@ fn linearize_ty_params(cx: @block_ctxt, t: ty::t) ->\n     }\n     let x = @{cx: cx, mutable vals: param_vals, mutable defs: param_defs};\n     let f = bind linearizer(x, _);\n-    ty::walk_ty(bcx_tcx(cx), f, t);\n+    ty::walk_ty(bcx_tcx(cx), t, f);\n     ret {params: x.defs, descs: x.vals};\n }\n "}, {"sha": "77c35cf0f203591cb98edc192ef5c93022b6efa5", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "patch": "@@ -673,41 +673,37 @@ pure fn ty_name(cx: ctxt, typ: t) -> option::t<@str> {\n     }\n }\n \n-\n-// Type folds\n-type ty_walk = fn@(t);\n-\n-fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n+fn walk_ty(cx: ctxt, ty: t, walker: fn(t)) {\n     alt struct(cx, ty) {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_send_type | ty_type | ty_native(_) |\n       ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n-      ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n+      ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, tm.ty, walker); }\n       ty_enum(_, subtys) | ty_iface(_, subtys) {\n-        for subty: t in subtys { walk_ty(cx, walker, subty); }\n+        for subty: t in subtys { walk_ty(cx, subty, walker); }\n       }\n       ty_rec(fields) {\n-        for fl: field in fields { walk_ty(cx, walker, fl.mt.ty); }\n+        for fl: field in fields { walk_ty(cx, fl.mt.ty, walker); }\n       }\n-      ty_tup(ts) { for tt in ts { walk_ty(cx, walker, tt); } }\n+      ty_tup(ts) { for tt in ts { walk_ty(cx, tt, walker); } }\n       ty_fn(f) {\n-        for a: arg in f.inputs { walk_ty(cx, walker, a.ty); }\n-        walk_ty(cx, walker, f.output);\n+        for a: arg in f.inputs { walk_ty(cx, a.ty, walker); }\n+        walk_ty(cx, f.output, walker);\n       }\n       ty_native_fn(args, ret_ty) {\n-        for a: arg in args { walk_ty(cx, walker, a.ty); }\n-        walk_ty(cx, walker, ret_ty);\n+        for a: arg in args { walk_ty(cx, a.ty, walker); }\n+        walk_ty(cx, ret_ty, walker);\n       }\n       ty_res(_, sub, tps) {\n-        walk_ty(cx, walker, sub);\n-        for tp: t in tps { walk_ty(cx, walker, tp); }\n+        walk_ty(cx, sub, walker);\n+        for tp: t in tps { walk_ty(cx, tp, walker); }\n       }\n-      ty_constr(sub, _) { walk_ty(cx, walker, sub); }\n+      ty_constr(sub, _) { walk_ty(cx, sub, walker); }\n       ty_var(_) {/* no-op */ }\n       ty_param(_, _) {/* no-op */ }\n-      ty_uniq(tm) { walk_ty(cx, walker, tm.ty); }\n+      ty_uniq(tm) { walk_ty(cx, tm.ty, walker); }\n     }\n     walker(ty);\n }\n@@ -1273,7 +1269,7 @@ fn vars_in_type(cx: ctxt, ty: t) -> [int] {\n         alt struct(cx, ty) { ty_var(v) { *vars += [v]; } _ { } }\n     }\n     let rslt: @mutable [int] = @mutable [];\n-    walk_ty(cx, bind collect_var(cx, rslt, _), ty);\n+    walk_ty(cx, ty) {|t| collect_var(cx, rslt, t)}\n     // Works because of a \"convenient\" bug that lets us\n     // return a mutable vec as if it's immutable\n     ret *rslt;\n@@ -1529,7 +1525,7 @@ fn count_ty_params(cx: ctxt, ty: t) -> uint {\n     }\n     let param_indices: @mutable [uint] = @mutable [];\n     let f = bind counter(cx, param_indices, _);\n-    walk_ty(cx, f, ty);\n+    walk_ty(cx, ty, f);\n     ret vec::len::<uint>(*param_indices);\n }\n \n@@ -2695,7 +2691,6 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     if did.crate == ast::local_crate {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already; we simply return it.\n-\n         ret cx.tcache.get(did);\n     }\n     alt cx.tcache.find(did) {"}, {"sha": "63de1e4e76166bd085e18bbebde3f090a798f9a4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 69, "deletions": 40, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "patch": "@@ -415,16 +415,15 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         ret tpt;\n       }\n       ast::item_iface(tps, ms) {\n-        let {bounds, params} = mk_ty_params(tcx, tps);\n-        let t = ty::mk_named(tcx, ty::mk_iface(tcx, local_def(it.id),\n-                                               params),\n+        let s_tp = vec::len(tps) - 1u;\n+        tcx.ty_param_bounds.insert(tps[s_tp].id, @[]);\n+        let {bounds, params} = mk_ty_params(tcx, vec::slice(tps, 0u, s_tp));\n+        let t = ty::mk_named(tcx, ty::mk_iface(tcx, local_def(it.id), params),\n                              @it.ident);\n         let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_impl(_, _, _, _) | ast::item_mod(_) |\n-      ast::item_native_mod(_) { fail; }\n     }\n }\n fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n@@ -604,12 +603,20 @@ fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n }\n \n fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n-                       impl_tps: uint, if_m: ty::method, substs: [ty::t]) {\n+                       impl_tps: uint, if_m: ty::method, substs: [ty::t])\n+    -> ty::t {\n     if impl_m.tps != if_m.tps {\n         tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                           \"` has an incompatible set of type parameters\");\n+        ty::mk_fn(tcx, impl_m.fty)\n     } else {\n-        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n+        let auto_modes = vec::map2(impl_m.fty.inputs, if_m.fty.inputs, {|i, f|\n+            alt ty::struct(tcx, f.ty) {\n+              ty::ty_param(0u, _) { {mode: ast::by_ref with i} }\n+              _ { i }\n+            }\n+        });\n+        let impl_fty = ty::mk_fn(tcx, {inputs: auto_modes with impl_m.fty});\n         // Add dummy substs for the parameters of the impl method\n         let substs = substs + vec::init_fn(vec::len(*if_m.tps), {|i|\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n@@ -621,8 +628,9 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n             tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                               \"` has an incompatible type: \" +\n                               ty::type_err_to_str(err));\n+            impl_fty\n           }\n-          _ {}\n+          ty::unify::ures_ok(tp) { tp }\n         }\n     }\n }\n@@ -690,15 +698,15 @@ mod collect {\n             for m in ms {\n                 let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n                 let mty = ty_of_method(cx.tcx, m_collect, m);\n-                my_methods += [mty];\n+                my_methods += [{mty: mty, id: m.id}];\n                 let fty = ty::mk_fn(cx.tcx, mty.fty);\n                 cx.tcx.tcache.insert(local_def(m.id),\n                                      {bounds: @(*i_bounds + *bounds),\n                                       ty: fty});\n                 write::ty_only(cx.tcx, m.id, fty);\n             }\n-            write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n-                                                       selfty));\n+            let selfty = ast_ty_to_ty(cx.tcx, m_collect, selfty);\n+            write::ty_only(cx.tcx, it.id, selfty);\n             alt ifce {\n               some(t) {\n                 let iface_ty = ast_ty_to_ty(cx.tcx, m_collect, t);\n@@ -708,10 +716,18 @@ mod collect {\n                   ty::ty_iface(did, tys) {\n                     for if_m in *ty::iface_methods(cx.tcx, did) {\n                         alt vec::find(my_methods,\n-                                      {|m| if_m.ident == m.ident}) {\n-                          some(m) {\n-                            compare_impl_method(cx.tcx, t.span, m,\n-                                                vec::len(tps), if_m, tys);\n+                                      {|m| if_m.ident == m.mty.ident}) {\n+                          some({mty: m, id}) {\n+                            let mt = compare_impl_method(\n+                                cx.tcx, t.span, m, vec::len(tps), if_m,\n+                                tys + [selfty]);\n+                            let old = cx.tcx.tcache.get(local_def(id));\n+                            if old.ty != mt {\n+                                cx.tcx.tcache.insert(local_def(id),\n+                                                     {bounds: old.bounds,\n+                                                      ty: mt});\n+                                write::ty_only(cx.tcx, id, mt);\n+                            }\n                           }\n                           none {\n                             cx.tcx.sess.span_err(t.span, \"missing method `\" +\n@@ -1501,7 +1517,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                     let m = ifce_methods[pos];\n                     ret some({method_ty: ty::mk_fn(tcx, m.fty),\n                               n_tps: vec::len(*m.tps),\n-                              substs: tps,\n+                              substs: tps + [ty],\n                               origin: method_param(iid, pos, n, bound_n)});\n                   }\n                   _ {}\n@@ -1519,7 +1535,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n             if m.ident == name {\n                 ret some({method_ty: ty::mk_fn(tcx, m.fty),\n                           n_tps: vec::len(*m.tps),\n-                          substs: tps,\n+                          substs: tps + [ty::mk_int(tcx)],\n                           origin: method_iface(i)});\n             }\n             i += 1u;\n@@ -1528,17 +1544,6 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n       _ {}\n     }\n \n-    fn ty_from_did(tcx: ty::ctxt, did: ast::def_id) -> ty::t {\n-        if did.crate == ast::local_crate {\n-            alt tcx.items.get(did.node) {\n-              ast_map::node_method(m) {\n-                let mt = ty_of_method(tcx, m_check, m);\n-                ty::mk_fn(tcx, mt.fty)\n-              }\n-            }\n-        } else { csearch::get_type(tcx, did).ty }\n-    }\n-\n     let result = none;\n     std::list::iter(isc) {|impls|\n         if option::is_some(result) { ret; }\n@@ -1557,7 +1562,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                             sp, \"multiple applicable methods in scope\");\n                     } else {\n                         result = some({\n-                            method_ty: ty_from_did(tcx, m.did),\n+                            method_ty: ty::lookup_item_type(tcx, m.did).ty,\n                             n_tps: m.n_tps,\n                             substs: vars,\n                             origin: method_static(m.did)\n@@ -1812,16 +1817,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         check_binop_type_compat(fcx, expr.span, lhs_t, binop);\n \n-        let t =\n-            alt binop {\n-              ast::eq { ty::mk_bool(tcx) }\n-              ast::lt { ty::mk_bool(tcx) }\n-              ast::le { ty::mk_bool(tcx) }\n-              ast::ne { ty::mk_bool(tcx) }\n-              ast::ge { ty::mk_bool(tcx) }\n-              ast::gt { ty::mk_bool(tcx) }\n-              _ { lhs_t }\n-            };\n+        let t = alt binop {\n+          ast::eq | ast::lt | ast::le | ast::ne | ast::ge |\n+          ast::gt { ty::mk_bool(tcx) }\n+          _ { lhs_t }\n+        };\n         write::ty_only_fixup(fcx, id, t);\n       }\n       ast::expr_unary(unop, oper) {\n@@ -2915,9 +2915,38 @@ mod dict {\n             }\n           }\n           ast::expr_cast(src, _) {\n+            // Ifaces that refer to a self type can not be cast to -- callers\n+            // wouldn't know what self refers to.\n+            fn type_refers_to_self(tcx: ty::ctxt, t: ty::t, s_param: uint)\n+                -> bool {\n+                let found = false;\n+                if ty::type_contains_params(tcx, t) {\n+                    ty::walk_ty(tcx, t) {|t|\n+                        alt ty::struct(tcx, t) {\n+                          ty::ty_param(n, _) if n == s_param { found = true; }\n+                          _ {}\n+                        }\n+                    }\n+                }\n+                found\n+            }\n+            fn method_refers_to_self(tcx: ty::ctxt, m: ty::method,\n+                                     s_param: uint) -> bool {\n+                vec::any(m.fty.inputs, {|in|\n+                    type_refers_to_self(tcx, in.ty, s_param)\n+                }) || type_refers_to_self(tcx, m.fty.output, s_param)\n+            }\n             let target_ty = expr_ty(cx.tcx, ex);\n             alt ty::struct(cx.tcx, target_ty) {\n-              ty::ty_iface(_, _) {\n+              ty::ty_iface(id, tps) {\n+                for m in *ty::iface_methods(cx.tcx, id) {\n+                    if method_refers_to_self(cx.tcx, m, vec::len(tps)) {\n+                        cx.tcx.sess.span_err(\n+                            ex.span, \"can not cast to an iface type that \\\n+                                      refers to `self` \" + m.ident);\n+                        break;\n+                    }\n+                }\n                 let impls = cx.impl_map.get(ex.id);\n                 let dict = lookup_dict(fcx, impls, ex.span,\n                                        expr_ty(cx.tcx, src), target_ty);"}, {"sha": "eca22f38adffebf00bee5a9d6b17cab442341be2", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "patch": "@@ -1831,9 +1831,10 @@ fn parse_method(p: parser) -> @ast::method {\n \n fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo, ident = parse_ident(p),\n-        tps = parse_ty_params(p), meths = parse_ty_methods(p);\n+        tps = parse_ty_params(p), meths = parse_ty_methods(p),\n+        self_tp = {ident: \"self\", id: p.get_id(), bounds: @[]};\n     ret mk_item(p, lo, p.last_span.hi, ident,\n-                ast::item_iface(tps, meths), attrs);\n+                ast::item_iface(tps + [self_tp], meths), attrs);\n }\n \n // Parses three variants (with the initial params always optional):"}, {"sha": "bdfc06b403b6e47c33a5cb8237f1d04d7fa75d1a", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "patch": "@@ -488,7 +488,8 @@ fn print_item(s: ps, &&item: @ast::item) {\n       ast::item_iface(tps, methods) {\n         head(s, \"iface\");\n         word(s.s, item.ident);\n-        print_type_params(s, tps);\n+        print_type_params(s, vec::slice(tps, 0u, vec::len(tps) - 1u));\n+        nbsp(s);\n         bopen(s);\n         for meth in methods { print_ty_method(s, meth); }\n         bclose(s, item.span);"}, {"sha": "f95f5c85eed95852c3d46745d4a549ad58e585a1", "filename": "src/test/run-pass/iface-generic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-generic.rs?ref=2d4d8e8bdbe2c6d0656c4887ad8ccadcb8a39966", "patch": "@@ -12,9 +12,11 @@ impl of to_str for () {\n }\n \n iface map<T> {\n+    fn iter(fn(T));\n     fn map<U>(f: fn(T) -> U) -> [U];\n }\n impl <T> of map<T> for [T] {\n+    fn iter(_f: fn(T)) {}\n     fn map<U>(f: fn(T) -> U) -> [U] {\n         let r = [];\n         for x in self { r += [f(x)]; }"}]}