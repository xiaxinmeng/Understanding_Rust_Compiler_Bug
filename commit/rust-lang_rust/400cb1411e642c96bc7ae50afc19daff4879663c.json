{"sha": "400cb1411e642c96bc7ae50afc19daff4879663c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMGNiMTQxMWU2NDJjOTZiYzdhZTUwYWZjMTlkYWZmNDg3OTY2M2M=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-13T15:01:13Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:09:05Z"}, "message": "Add a summary of the algorithm to the file", "tree": {"sha": "7e026c1238f505bb143cf2fc0f25cb6f8c9326b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e026c1238f505bb143cf2fc0f25cb6f8c9326b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/400cb1411e642c96bc7ae50afc19daff4879663c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/400cb1411e642c96bc7ae50afc19daff4879663c", "html_url": "https://github.com/rust-lang/rust/commit/400cb1411e642c96bc7ae50afc19daff4879663c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/400cb1411e642c96bc7ae50afc19daff4879663c/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99754adbbb423a325b03ce99d9d7f89128842ba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/99754adbbb423a325b03ce99d9d7f89128842ba9", "html_url": "https://github.com/rust-lang/rust/commit/99754adbbb423a325b03ce99d9d7f89128842ba9"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "87afa82b6bd23343de567d737ad7b5588d4dc655", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/400cb1411e642c96bc7ae50afc19daff4879663c/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb1411e642c96bc7ae50afc19daff4879663c/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=400cb1411e642c96bc7ae50afc19daff4879663c", "patch": "@@ -8,6 +8,121 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/// This file includes the logic for exhaustiveness and usefulness checking for\n+/// pattern-matching. Specifically, given a list of patterns for a type, we can\n+/// tell whether:\n+/// (a) the patterns cover every possible constructor for the type [exhaustiveness]\n+/// (b) each pattern is necessary [usefulness]\n+///\n+/// The algorithm implemented here is a modified version of the one described in:\n+/// http://moscova.inria.fr/~maranget/papers/warn/index.html\n+/// However, to save future implementors from reading the original paper, I'm going\n+/// to summarise the algorithm here to hopefully save time and be a little clearer\n+/// (without being so rigorous).\n+///\n+/// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n+/// are trying to compute a predicate `U(P, p_{m + 1})` where `P` is a list of patterns\n+/// of length `m` for a compound (product) type with `n` components (we refer to this as\n+/// a matrix). `U(P, p_{m + 1})` represents whether, given an existing list of patterns\n+/// `p_1 ..= p_m`, adding a new pattern will be \"useful\" (that is, cover previously-\n+/// uncovered values of the type).\n+///\n+/// If we have this predicate, then we can easily compute both exhaustiveness of an\n+/// entire set of patterns and the individual usefulness of each one.\n+/// (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e. adding a wildcard\n+/// match doesn't increase the number of values we're matching)\n+/// (b) a pattern `p_i` is not useful if `U(P[0..=(i-1), p_i)` is false (i.e. adding a\n+/// pattern to those that have come before it doesn't increase the number of values\n+/// we're matching).\n+///\n+/// For example, say we have the following:\n+/// ```\n+///     // x: (Option<bool>, Result<()>)\n+///     match x {\n+///         (Some(true), _) => {}\n+///         (None, Err(())) => {}\n+///         (None, Err(_)) => {}\n+///     }\n+/// ```\n+/// Here, the matrix `P` is 3 x 2 (rows x columns).\n+/// [\n+///     [Some(true), _],\n+///     [None, Err(())],\n+///     [None, Err(_)],\n+/// ]\n+/// We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n+/// `[Some(false), _]`, for instance). In addition, row 3 is not useful, because\n+/// all the values it covers are already covered by row 2.\n+///\n+/// To compute `U`, we must have two other concepts.\n+///     1. `S(c, P)` is a \"specialised matrix\", where `c` is a constructor (like `Some` or\n+///        `None`). You can think of it as filtering `P` to just the rows whose *first* pattern\n+///        can cover `c` (and expanding OR-patterns into distinct patterns), and then expanding\n+///        the constructor into all of its components.\n+///\n+///        It is computed as follows. For each row `p_i` of P, we have four cases:\n+///             1.1. `p_(i,1)= c(r_1, .., r_a)`. Then `S(c, P)` has a corresponding row:\n+///                     r_1, .., r_a, p_(i,2), .., p_(i,n)\n+///             1.2. `p_(i,1) = c'(r_1, .., r_a')` where `c \u2260 c'`. Then `S(c, P)` has no\n+///                  corresponding row.\n+///             1.3. `p_(i,1) = _`. Then `S(c, P)` has a corresponding row:\n+///                     _, .., _, p_(i,2), .., p_(i,n)\n+///             1.4. `p_(i,1) = r_1 | r_2`. Then `S(c, P)` has corresponding rows inlined from:\n+///                     S(c, (r_1, p_(i,2), .., p_(i,n)))\n+///                     S(c, (r_2, p_(i,2), .., p_(i,n)))\n+///\n+///     2. `D(P)` is a \"default matrix\". This is used when we know there are missing\n+///        constructor cases, but there might be existing wildcard patterns, so to check the\n+///        usefulness of the matrix, we have to check all its *other* components.\n+///\n+///         It is computed as follows. For each row `p_i` of P, we have three cases:\n+///             1.1. `p_(i,1)= c(r_1, .., r_a)`. Then `D(P)` has no corresponding row.\n+///             1.2. `p_(i,1) = _`. Then `D(P)` has a corresponding row:\n+///                     p_(i,2), .., p_(i,n)\n+///             1.3. `p_(i,1) = r_1 | r_2`. Then `D(P)` has corresponding rows inlined from:\n+///                     D((r_1, p_(i,2), .., p_(i,n)))\n+///                     D((r_2, p_(i,2), .., p_(i,n)))\n+///\n+/// The algorithm for computing `U`\n+/// -------------------------------\n+/// The algorithm is inductive (on the number of columns: i.e. components of tuple patterns).\n+/// That means we're going to check the components from left-to-right, so the algorithm\n+/// operates principally on the first component of the matrix and new pattern `p_{m + 1}`.\n+///\n+/// Base case. (`n = 0`, i.e. an empty tuple pattern)\n+///     - If `P` already contains an empty pattern (i.e. if the number of patterns `m > 0`),\n+///       then `U(P, p_{m + 1})` is false.\n+///     - Otherwise, `P` must be empty, so `U(P, p_{m + 1})` is true.\n+///\n+/// Inductive step. (`n > 0`, i.e. 1 or more tuple pattern components)\n+///     We're going to match on the new pattern, `p_{m + 1}`.\n+///         - If `p_{m + 1} == c(r_1, .., r_a)`, then we have a constructor pattern.\n+///           Thus, the usefulness of `p_{m + 1}` can be reduced to whether it is useful when\n+///           we ignore all the patterns in `P` that involve other constructors. This is where\n+///           `S(c, P)` comes in:\n+///           `U(P, p_{m + 1}) := U(S(c, P), S(c, p_{m + 1}))`\n+///         - If `p_{m + 1} == _`, then we have two more cases:\n+///             + All the constructors of the first component of the type exist within\n+///               all the rows (after having expanded OR-patterns). In this case:\n+///               `U(P, p_{m + 1}) := \u2228(k \u03f5 constructors) U(S(k, P), S(k, p_{m + 1}))`\n+///               I.e. the pattern `p_{m + 1}` is only useful when all the constructors are\n+///               present *if* its later components are useful for the respective constructors\n+///               covered by `p_{m + 1}` (usually a single constructor, but all in the case of `_`).\n+///             + Some constructors are not present in the existing rows (after having expanded\n+///               OR-patterns). However, there might be wildcard patterns (`_`) present. Thus, we\n+///               are only really concerned with the other patterns leading with wildcards. This is\n+///               where `D` comes in:\n+///               `U(P, p_{m + 1}) := U(D(P), p_({m + 1},2), ..,  p_({m + 1},n))`\n+///         - If `p_{m + 1} == r_1 | r_2`, then the usefulness depends on each separately:\n+///           `U(P, p_{m + 1}) := U(P, (r_1, p_({m + 1},2), .., p_({m + 1},n)))\n+///                            || U(P, (r_2, p_({m + 1},2), .., p_({m + 1},n)))`\n+///\n+/// Modifications to the algorithm\n+/// ------------------------------\n+/// The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n+/// example uninhabited types and variable-length slice patterns. These are drawn attention to\n+/// throughout the code below.\n+\n use self::Constructor::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;"}]}