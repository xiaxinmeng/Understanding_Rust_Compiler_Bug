{"sha": "fc7bf8498bc8f664fb4837d610204cb88c6103c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjN2JmODQ5OGJjOGY2NjRmYjQ4MzdkNjEwMjA0Y2I4OGM2MTAzYzA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-20T14:30:42Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-20T16:17:53Z"}, "message": "Enable linkchecker on books\n\nPreviously, mdBook used JavaScript to add header links, so we\nskipped checking the book. As of\nhttps://github.com/rust-lang/rust/pull/39966, it no longer does,\nso we can start checking again.\n\nThere is a twist, though: it uses name instead of id, so let's test\nfor both. They're both valid links anyway, so it's good to have the\nchecker check anyway.", "tree": {"sha": "8312d361e16b940c8e1761fc5cbf04ac1ef6a83b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8312d361e16b940c8e1761fc5cbf04ac1ef6a83b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc7bf8498bc8f664fb4837d610204cb88c6103c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc7bf8498bc8f664fb4837d610204cb88c6103c0", "html_url": "https://github.com/rust-lang/rust/commit/fc7bf8498bc8f664fb4837d610204cb88c6103c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc7bf8498bc8f664fb4837d610204cb88c6103c0/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4cd3d92061de90f58669d620867d42466a563ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4cd3d92061de90f58669d620867d42466a563ab", "html_url": "https://github.com/rust-lang/rust/commit/b4cd3d92061de90f58669d620867d42466a563ab"}], "stats": {"total": 24, "additions": 16, "deletions": 8}, "files": [{"sha": "ba5ca44526b86340be3209a2233d7dbd5324a58f", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc7bf8498bc8f664fb4837d610204cb88c6103c0/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7bf8498bc8f664fb4837d610204cb88c6103c0/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=fc7bf8498bc8f664fb4837d610204cb88c6103c0", "patch": "@@ -65,6 +65,7 @@ enum Redirect {\n struct FileEntry {\n     source: String,\n     ids: HashSet<String>,\n+    names: HashSet<String>,\n }\n \n type Cache = HashMap<PathBuf, FileEntry>;\n@@ -81,6 +82,15 @@ impl FileEntry {\n             });\n         }\n     }\n+\n+    fn parse_names(&mut self, contents: &str) {\n+        if self.names.is_empty() {\n+            with_attrs_in_source(contents, \" name\", |fragment, _| {\n+                let frag = fragment.trim_left_matches(\"#\").to_owned();\n+                self.names.insert(frag);\n+            });\n+        }\n+    }\n }\n \n fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n@@ -139,6 +149,9 @@ fn check(cache: &mut Cache,\n         cache.get_mut(&pretty_file)\n              .unwrap()\n              .parse_ids(&pretty_file, &contents, errors);\n+        cache.get_mut(&pretty_file)\n+             .unwrap()\n+             .parse_names(&contents);\n     }\n \n     // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n@@ -209,13 +222,6 @@ fn check(cache: &mut Cache,\n                 Err(LoadError::IsRedirect) => unreachable!(),\n             };\n \n-            // we don't check the book for fragments because they're added via JS\n-            for book in [\"book/\", \"nomicon/\"].iter() {\n-                if !pretty_path.to_str().unwrap().starts_with(book) {\n-                    return;\n-                }\n-            }\n-\n             if let Some(ref fragment) = fragment {\n                 // Fragments like `#1-6` are most likely line numbers to be\n                 // interpreted by javascript, so we're ignoring these\n@@ -226,8 +232,9 @@ fn check(cache: &mut Cache,\n \n                 let entry = &mut cache.get_mut(&pretty_path).unwrap();\n                 entry.parse_ids(&pretty_path, &contents, errors);\n+                entry.parse_names(&contents);\n \n-                if !entry.ids.contains(*fragment) {\n+                if !(entry.ids.contains(*fragment) || entry.names.contains(*fragment)) {\n                     *errors = true;\n                     print!(\"{}:{}: broken link fragment  \",\n                            pretty_file.display(),\n@@ -277,6 +284,7 @@ fn load_file(cache: &mut Cache,\n                 entry.insert(FileEntry {\n                     source: contents.clone(),\n                     ids: HashSet::new(),\n+                    names: HashSet::new(),\n                 });\n             }\n             maybe"}]}