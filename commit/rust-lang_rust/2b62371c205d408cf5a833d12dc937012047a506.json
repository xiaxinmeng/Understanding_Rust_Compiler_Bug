{"sha": "2b62371c205d408cf5a833d12dc937012047a506", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNjIzNzFjMjA1ZDQwOGNmNWE4MzNkMTJkYzkzNzAxMjA0N2E1MDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-24T01:31:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-24T01:31:44Z"}, "message": "auto merge of #11478 : klutzy/rust/rustpkg-crate-id, r=cmr\n\nThis patchset consists of three parts:\r\n\r\n- rustpkg doesn't guess crate version if it is not given by user.\r\n- `rustpkg::version::Version` is replaced by `Option<~str>`.\r\n  It removes some semantic versioning portions which is not currently used.\r\n  (cc #8405 and #11396)\r\n  `rustpkg::crate_id::CrateId` is also replaced by `syntax::crateid::CrateId`.\r\n- rustpkg now computes hash to find crate, instead of manual filename parse.\r\n\r\ncc @metajack", "tree": {"sha": "4dc804d1124aafa066e7b353e768fdd4982d1e12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dc804d1124aafa066e7b353e768fdd4982d1e12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b62371c205d408cf5a833d12dc937012047a506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b62371c205d408cf5a833d12dc937012047a506", "html_url": "https://github.com/rust-lang/rust/commit/2b62371c205d408cf5a833d12dc937012047a506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b62371c205d408cf5a833d12dc937012047a506/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f4e5b6f3182da3a5dacd9edec2e73b7cd792f25", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f4e5b6f3182da3a5dacd9edec2e73b7cd792f25", "html_url": "https://github.com/rust-lang/rust/commit/9f4e5b6f3182da3a5dacd9edec2e73b7cd792f25"}, {"sha": "a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "html_url": "https://github.com/rust-lang/rust/commit/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116"}], "stats": {"total": 1414, "additions": 503, "deletions": 911}, "files": [{"sha": "13d5a1177049b720a68c881ce92022366096f2ef", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -11,11 +11,9 @@\n use CtxMethods;\n use context::*;\n use crate::*;\n-use crate_id::*;\n use package_source::*;\n use path_util::{platform_library_name, target_build_dir};\n use target::*;\n-use version::Version;\n use workspace::pkg_parent_workspaces;\n use workcache_support::*;\n pub use path_util::default_workspace;\n@@ -27,6 +25,7 @@ use extra::arc::{Arc,RWArc};\n use extra::workcache;\n use extra::workcache::{Database, FreshnessMap};\n use extra::treemap::TreeMap;\n+use syntax::crateid::CrateId;\n \n // A little sad -- duplicated from rustc::back::*\n #[cfg(target_arch = \"arm\")]\n@@ -79,20 +78,19 @@ pub fn new_workcache_context(p: &Path) -> workcache::Context {\n     workcache::Context::new_with_freshness(db, cfg, Arc::new(freshness))\n }\n \n-pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n-                 lib: Path) {\n-    build_lib_with_cfgs(sysroot, root, name, version, lib, ~[])\n+pub fn build_lib(sysroot: Path, root: Path, name: ~str, lib: Path) {\n+    build_lib_with_cfgs(sysroot, root, name, lib, ~[])\n }\n \n-pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str,\n-                           version: Version, lib: Path, cfgs: ~[~str]) {\n+pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str, lib: Path, cfgs: ~[~str]) {\n     let cx = default_context(sysroot, root.clone());\n+    let crate_id: CrateId = from_str(name).expect(\"valid crate id\");\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n         start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: CrateId{ version: version, ..CrateId::new(name)},\n+        id: crate_id,\n         // n.b. This assumes the package only has one crate\n         libs: ~[mk_crate(lib)],\n         mains: ~[],\n@@ -102,20 +100,19 @@ pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str,\n     pkg_src.build(&cx, cfgs, []);\n }\n \n-pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n-                 main: Path) {\n-    build_exe_with_cfgs(sysroot, root, name, version, main, ~[])\n+pub fn build_exe(sysroot: Path, root: Path, name: ~str, main: Path) {\n+    build_exe_with_cfgs(sysroot, root, name, main, ~[])\n }\n \n-pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str,\n-                           version: Version, main: Path, cfgs: ~[~str]) {\n+pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str, main: Path, cfgs: ~[~str]) {\n     let cx = default_context(sysroot, root.clone());\n+    let crate_id: CrateId = from_str(name).expect(\"valid crate id\");\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n         start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: CrateId{ version: version, ..CrateId::new(name)},\n+        id: crate_id,\n         libs: ~[],\n         // n.b. This assumes the package only has one crate\n         mains: ~[mk_crate(main)],\n@@ -129,11 +126,10 @@ pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str,\n pub fn install_pkg(cx: &BuildContext,\n                    workspace: Path,\n                    name: ~str,\n-                   version: Version,\n                    // For now, these inputs are assumed to be inputs to each of the crates\n                    more_inputs: ~[(~str, Path)]) { // pairs of Kind and Path\n-    let crateid = CrateId{ version: version, ..CrateId::new(name)};\n-    cx.install(PkgSrc::new(workspace.clone(), workspace, false, crateid),\n+    let crate_id: CrateId = from_str(name).expect(\"valid crate id\");\n+    cx.install(PkgSrc::new(workspace.clone(), workspace, false, crate_id),\n                &WhatToBuild{ build_type: Inferred,\n                              inputs_to_discover: more_inputs,\n                              sources: Everything });\n@@ -157,10 +153,10 @@ pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n     let out_name = workspace_build_dir.join_many([package_name.to_str(),\n                                                   platform_library_name(output)]);\n     // make paths absolute\n-    let crateid = CrateId::new(package_name);\n+    let crateid: CrateId = from_str(package_name).expect(\"valid crate id\");\n     let absolute_paths = paths.map(|s| {\n             let whatever = workspace.join_many([~\"src\",\n-                                crateid.to_str(),\n+                                crateid.short_name_with_version(),\n                                 s.to_owned()]);\n             whatever.as_str().unwrap().to_owned()\n         });\n@@ -190,7 +186,7 @@ pub fn my_workspace(context: &Context, package_name: &str) -> Path {\n     use bad_pkg_id     = conditions::bad_pkg_id::cond;\n \n     // (this assumes no particular version is requested)\n-    let crateid = CrateId::new(package_name);\n+    let crateid = from_str(package_name).expect(\"valid crate id\");\n     let workspaces = pkg_parent_workspaces(context, &crateid);\n     if workspaces.is_empty() {\n         bad_pkg_id.raise((Path::new(package_name), package_name.to_owned()));"}, {"sha": "d18161d7c4a370b1c46bf40b0e70ec8317974722", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -10,7 +10,7 @@\n \n // Useful conditions\n \n-pub use crate_id::CrateId;\n+pub use syntax::crateid::CrateId;\n pub use std::io::FileStat;\n pub use std::io::process::ProcessExit;\n pub use std::path::Path;"}, {"sha": "239abbe546ff0ddfecd1bfe00fb3ae8c196ebfde", "filename": "src/librustpkg/crate_id.rs", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9f4e5b6f3182da3a5dacd9edec2e73b7cd792f25/src%2Flibrustpkg%2Fcrate_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4e5b6f3182da3a5dacd9edec2e73b7cd792f25/src%2Flibrustpkg%2Fcrate_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate_id.rs?ref=9f4e5b6f3182da3a5dacd9edec2e73b7cd792f25", "patch": "@@ -1,150 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use version::{try_getting_version, try_getting_local_version,\n-              Version, NoVersion, ExactRevision};\n-use std::hash::Streaming;\n-use std::hash;\n-use syntax::crateid;\n-\n-/// Path-fragment identifier of a package such as\n-/// 'github.com/graydon/test'; path must be a relative\n-/// path with >=1 component.\n-#[deriving(Clone)]\n-pub struct CrateId {\n-    /// This is a path, on the local filesystem, referring to where the\n-    /// files for this package live. For example:\n-    /// github.com/mozilla/quux-whatever (it's assumed that if we're\n-    /// working with a package ID of this form, rustpkg has already cloned\n-    /// the sources into a local directory in the RUST_PATH).\n-    path: Path,\n-    /// Short name. This is the path's filestem, but we store it\n-    /// redundantly so as to not call get() everywhere (filestem() returns an\n-    /// option)\n-    /// The short name does not need to be a valid Rust identifier.\n-    /// Users can write: `extern mod foo = \"...\";` to get around the issue\n-    /// of package IDs whose short names aren't valid Rust identifiers.\n-    short_name: ~str,\n-    /// The requested package version.\n-    version: Version\n-}\n-\n-impl Eq for CrateId {\n-    fn eq(&self, other: &CrateId) -> bool {\n-        self.path == other.path && self.version == other.version\n-    }\n-}\n-\n-impl CrateId {\n-    pub fn new(s: &str) -> CrateId {\n-        use conditions::bad_pkg_id::cond;\n-\n-        let raw_crateid: Option<crateid::CrateId> = from_str(s);\n-        if raw_crateid.is_none() {\n-            return cond.raise((Path::new(s), ~\"bad crateid\"))\n-        }\n-        let raw_crateid = raw_crateid.unwrap();\n-        let crateid::CrateId { path, name, version } = raw_crateid;\n-        let path = Path::new(path);\n-        let given_version = version.map(|v| ExactRevision(v));\n-\n-        let version = match given_version {\n-            Some(v) => v,\n-            None => match try_getting_local_version(&path) {\n-                Some(v) => v,\n-                None => match try_getting_version(&path) {\n-                    Some(v) => v,\n-                    None => NoVersion\n-                }\n-            }\n-        };\n-\n-        CrateId {\n-            path: path,\n-            short_name: name,\n-            version: version\n-        }\n-    }\n-\n-    pub fn hash(&self) -> ~str {\n-        // FIXME (#9639): hash should take a &[u8] so we can hash the real path\n-        self.path.display().with_str(|s| {\n-            let vers = self.version.to_str();\n-            format!(\"{}-{}-{}\", s, hash(s + vers), vers)\n-        })\n-    }\n-\n-    pub fn short_name_with_version(&self) -> ~str {\n-        format!(\"{}{}\", self.short_name, self.version.to_str())\n-    }\n-\n-    /// True if the ID has multiple components\n-    pub fn is_complex(&self) -> bool {\n-        self.short_name.as_bytes() != self.path.as_vec()\n-    }\n-\n-    pub fn prefixes(&self) -> Prefixes {\n-        prefixes(&self.path)\n-    }\n-\n-    // This is the workcache function name for the *installed*\n-    // binaries for this package (as opposed to the built ones,\n-    // which are per-crate).\n-    pub fn install_tag(&self) -> ~str {\n-        format!(\"install({})\", self.to_str())\n-    }\n-}\n-\n-pub fn prefixes(p: &Path) -> Prefixes {\n-    Prefixes {\n-        components: p.str_components().map(|x|x.unwrap().to_owned()).to_owned_vec(),\n-        remaining: ~[]\n-    }\n-}\n-\n-struct Prefixes {\n-    priv components: ~[~str],\n-    priv remaining: ~[~str]\n-}\n-\n-impl Iterator<(Path, Path)> for Prefixes {\n-    #[inline]\n-    fn next(&mut self) -> Option<(Path, Path)> {\n-        if self.components.len() <= 1 {\n-            None\n-        }\n-        else {\n-            let last = self.components.pop().unwrap();\n-            self.remaining.unshift(last);\n-            // converting to str and then back is a little unfortunate\n-            Some((Path::new(self.components.connect(\"/\")),\n-                  Path::new(self.remaining.connect(\"/\"))))\n-        }\n-    }\n-}\n-\n-impl ToStr for CrateId {\n-    fn to_str(&self) -> ~str {\n-        // should probably use the filestem and not the whole path\n-        format!(\"{}-{}\", self.path.as_str().unwrap(), self.version.to_str())\n-    }\n-}\n-\n-\n-pub fn write<W: Writer>(writer: &mut W, string: &str) {\n-    writer.write(string.as_bytes());\n-}\n-\n-pub fn hash(data: ~str) -> ~str {\n-    let hasher = &mut hash::default_state();\n-    write(hasher, data);\n-    hasher.result_str()\n-}\n-"}, {"sha": "c7900181a77d15220d585a308269755d1c0de52b", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -11,10 +11,10 @@\n // Listing installed packages\n \n use rustc::metadata::filesearch::rust_path;\n-use path_util::*;\n use std::os;\n use std::io;\n use std::io::fs;\n+use syntax::crateid::CrateId;\n \n pub fn list_installed_packages(f: |&CrateId| -> bool) -> bool  {\n     let workspaces = rust_path();\n@@ -28,7 +28,8 @@ pub fn list_installed_packages(f: |&CrateId| -> bool) -> bool  {\n             match exec.filestem_str() {\n                 None => (),\n                 Some(exec_path) => {\n-                    if !f(&CrateId::new(exec_path)) {\n+                    let crate_id = from_str(exec_path).expect(\"valid crate id\");\n+                    if !f(&crate_id) {\n                         return false;\n                     }\n                 }\n@@ -50,7 +51,8 @@ pub fn list_installed_packages(f: |&CrateId| -> bool) -> bool  {\n                     let rel_path = rel_p.join(basename);\n                     rel_path.display().with_str(|s| {\n                         debug!(\"Rel name: {}\", s);\n-                        f(&CrateId::new(s));\n+                        let crate_id = from_str(s).expect(\"valid crate id\");\n+                        f(&crate_id);\n                     });\n                 }\n                 None => ()"}, {"sha": "e5e494e9b5f0c115c84bae81a0cca088a3bee052", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -33,6 +33,7 @@ use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n use rustc::util::sha2;\n use syntax::{ast, diagnostic};\n+use syntax::crateid::CrateId;\n use messages::{error, warn, note};\n use parse_args::{ParseResult, parse_args};\n use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n@@ -46,7 +47,6 @@ use context::{BuildContext, Trans, Nothing, Pretty, Analysis,\n               LLVMAssemble, LLVMCompileBitcode};\n use context::{Command, BuildCmd, CleanCmd, DoCmd, HelpCmd, InfoCmd, InstallCmd, ListCmd,\n     PreferCmd, TestCmd, InitCmd, UninstallCmd, UnpreferCmd};\n-use crate_id::CrateId;\n use package_source::PkgSrc;\n use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n use target::{Main, Tests, MaybeCustom, Inferred, JustOne};\n@@ -60,7 +60,6 @@ mod crate;\n pub mod exit_codes;\n mod installed_packages;\n mod messages;\n-pub mod crate_id;\n pub mod package_source;\n mod parse_args;\n mod path_util;\n@@ -103,7 +102,7 @@ impl<'a> PkgScript<'a> {\n                  workspace: &Path,\n                  id: &'a CrateId) -> PkgScript<'a> {\n         // Get the executable name that was invoked\n-        let binary = os::args()[0].to_owned();\n+        let binary = os::args()[0];\n         // Build the rustc session data structures to pass\n         // to the compiler\n         debug!(\"pkgscript parse: {}\", sysroot.display());\n@@ -163,7 +162,6 @@ impl<'a> PkgScript<'a> {\n         exe.as_str().unwrap().to_owned()\n     }\n \n-\n     /// Run the contents of this package script, where <what>\n     /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n     /// Returns a pair of an exit code and list of configs (obtained by\n@@ -243,9 +241,9 @@ impl CtxMethods for BuildContext {\n \n         if args.len() < 1 {\n             match cwd_to_workspace() {\n-                None  if dir_has_crate_file(&cwd) => {\n+                None if dir_has_crate_file(&cwd) => {\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n-                    let crateid = CrateId::new(cwd.filename_str().unwrap());\n+                    let crateid = from_str(cwd.filename_str().unwrap()).expect(\"valid crate id\");\n                     let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, crateid);\n                     self.build(&mut pkg_src, what);\n                     match pkg_src {\n@@ -270,7 +268,7 @@ impl CtxMethods for BuildContext {\n         } else {\n             // The package id is presumed to be the first command-line\n             // argument\n-            let crateid = CrateId::new(args[0].clone());\n+            let crateid = from_str(args[0]).expect(\"valid crate id\");\n             let mut dest_ws = default_workspace();\n             each_pkg_parent_workspace(&self.context, &crateid, |workspace| {\n                 debug!(\"found pkg {} in workspace {}, trying to build\",\n@@ -289,6 +287,7 @@ impl CtxMethods for BuildContext {\n             Some((crateid, dest_ws))\n         }\n     }\n+\n     fn run(&self, cmd: Command, args: ~[~str]) {\n         let cwd = os::getcwd();\n         match cmd {\n@@ -308,7 +307,7 @@ impl CtxMethods for BuildContext {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let crateid = CrateId::new(args[0].clone());\n+                    let crateid = from_str(args[0]).expect(\"valid crate id\");\n                     self.clean(&cwd, &crateid); // tjc: should use workspace, not cwd\n                 }\n             }\n@@ -341,7 +340,7 @@ impl CtxMethods for BuildContext {\n                             // FIXME (#9639): This needs to handle non-utf8 paths\n \n                             let inferred_crateid =\n-                                CrateId::new(cwd.filename_str().unwrap());\n+                                from_str(cwd.filename_str().unwrap()).expect(\"valid crate id\");\n                             self.install(PkgSrc::new(cwd, default_workspace(),\n                                                      true, inferred_crateid),\n                                          &WhatToBuild::new(MaybeCustom, Everything));\n@@ -357,7 +356,7 @@ impl CtxMethods for BuildContext {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let crateid = CrateId::new(args[0]);\n+                    let crateid = from_str(args[0]).expect(\"valid crate id\");\n                     let workspaces = pkg_parent_workspaces(&self.context, &crateid);\n                     debug!(\"package ID = {}, found it in {:?} workspaces\",\n                            crateid.to_str(), workspaces.len());\n@@ -383,7 +382,7 @@ impl CtxMethods for BuildContext {\n             ListCmd => {\n                 println!(\"Installed packages:\");\n                 installed_packages::list_installed_packages(|pkg_id| {\n-                    pkg_id.path.display().with_str(|s| println!(\"{}\", s));\n+                    println!(\"{}\", pkg_id.path);\n                     true\n                 });\n             }\n@@ -420,7 +419,7 @@ impl CtxMethods for BuildContext {\n                     return usage::uninstall();\n                 }\n \n-                let crateid = CrateId::new(args[0]);\n+                let crateid = from_str(args[0]).expect(\"valid crate id\");\n                 if !installed_packages::package_is_installed(&crateid) {\n                     warn(format!(\"Package {} doesn't seem to be installed! \\\n                                   Doing nothing.\", args[0]));\n@@ -458,24 +457,24 @@ impl CtxMethods for BuildContext {\n         let workspace = pkg_src.source_workspace.clone();\n         let crateid = pkg_src.id.clone();\n \n+        let path = crateid.path.as_slice();\n         debug!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n                 crateid = {} pkgsrc start_dir = {}\", workspace.display(),\n-               in_rust_path(&workspace), is_git_dir(&workspace.join(&crateid.path)),\n+               in_rust_path(&workspace), is_git_dir(&workspace.join(path)),\n                crateid.to_str(), pkg_src.start_dir.display());\n         debug!(\"build: what to build = {:?}\", what_to_build);\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n-        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(&crateid.path)) {\n+        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(path)) {\n             let mut out_dir = default_workspace().join(\"src\");\n-            out_dir.push(&crateid.path);\n-            let git_result = source_control::safe_git_clone(&workspace.join(&crateid.path),\n+            out_dir.push(path);\n+            let git_result = source_control::safe_git_clone(&workspace.join(path),\n                                                             &crateid.version,\n                                                             &out_dir);\n             match git_result {\n                 CheckedOutSources => make_read_only(&out_dir),\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                _ => cond.raise((crateid.path.as_str().unwrap().to_owned(), out_dir.clone()))\n+                _ => cond.raise((path.to_owned(), out_dir.clone()))\n             };\n             let default_ws = default_workspace();\n             debug!(\"Calling build recursively with {:?} and {:?}\", default_ws.display(),\n@@ -652,7 +651,8 @@ impl CtxMethods for BuildContext {\n                target_exec.display(), target_lib,\n                maybe_executable, maybe_library);\n \n-        self.workcache_context.with_prep(id.install_tag(), |prep| {\n+        let install_tag = format!(\"install({}-{})\", id.path, id.version_or_default());\n+        self.workcache_context.with_prep(install_tag, |prep| {\n             for ee in maybe_executable.iter() {\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"binary\","}, {"sha": "5ac62c5284e080f3713149d5f98552efab7997df", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 54, "deletions": 26, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -11,7 +11,6 @@\n extern mod extra;\n \n use target::*;\n-use crate_id::CrateId;\n use std::io;\n use std::io::fs;\n use std::os;\n@@ -27,7 +26,7 @@ use workcache_support;\n use workcache_support::{digest_only_date, digest_file_with_date, crate_tag};\n use extra::workcache;\n use extra::treemap::TreeMap;\n-\n+use syntax::crateid::CrateId;\n use rustc::driver::session;\n \n // An enumeration of the unpacked source of a package workspace.\n@@ -68,12 +67,38 @@ impl ToStr for PkgSrc {\n     }\n }\n condition! {\n-    // #6009: should this be pub or not, when #8215 is fixed?\n     build_err: (~str) -> ~str;\n }\n \n-impl PkgSrc {\n+fn prefixes(p: &Path) -> Prefixes {\n+    Prefixes {\n+        components: p.str_components().map(|x|x.unwrap().to_owned()).to_owned_vec(),\n+        remaining: ~[]\n+    }\n+}\n+\n+struct Prefixes {\n+    priv components: ~[~str],\n+    priv remaining: ~[~str]\n+}\n+\n+impl Iterator<(Path, Path)> for Prefixes {\n+    #[inline]\n+    fn next(&mut self) -> Option<(Path, Path)> {\n+        if self.components.len() <= 1 {\n+            None\n+        }\n+        else {\n+            let last = self.components.pop().unwrap();\n+            self.remaining.unshift(last);\n+            // converting to str and then back is a little unfortunate\n+            Some((Path::new(self.components.connect(\"/\")),\n+                  Path::new(self.remaining.connect(\"/\"))))\n+        }\n+    }\n+}\n \n+impl PkgSrc {\n     pub fn new(mut source_workspace: Path,\n                destination_workspace: Path,\n                use_rust_path_hack: bool,\n@@ -98,21 +123,22 @@ impl PkgSrc {\n         } else {\n             // We search for sources under both src/ and build/ , because build/ is where\n             // automatically-checked-out sources go.\n+            let path = Path::new(id.path.as_slice());\n             let mut result = source_workspace.join(\"src\");\n-            result.push(&id.path.dir_path());\n-            result.push(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n+            result.push(&path.dir_path());\n+            result.push(id.short_name_with_version());\n             to_try.push(result);\n             let mut result = source_workspace.join(\"src\");\n-            result.push(&id.path);\n+            result.push(&path);\n             to_try.push(result);\n \n             let mut result = build_dir.join(\"src\");\n-            result.push(&id.path.dir_path());\n-            result.push(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n+            result.push(&path.dir_path());\n+            result.push(id.short_name_with_version());\n             to_try.push(result.clone());\n             output_names.push(result);\n             let mut other_result = build_dir.join(\"src\");\n-            other_result.push(&id.path);\n+            other_result.push(&path);\n             to_try.push(other_result.clone());\n             output_names.push(other_result);\n \n@@ -132,9 +158,10 @@ impl PkgSrc {\n             None => {\n                 // See if any of the prefixes of this package ID form a valid package ID\n                 // That is, is this a package ID that points into the middle of a workspace?\n-                for (prefix, suffix) in id.prefixes() {\n-                    let crate_id = CrateId::new(prefix.as_str().unwrap());\n-                    let path = build_dir.join(&crate_id.path);\n+                for (prefix, suffix) in prefixes(&Path::new(id.path.as_slice())) {\n+                    let crate_id: Option<CrateId> = from_str(prefix.as_str().unwrap());\n+                    let crate_id = crate_id.expect(\"valid crate id\");\n+                    let path = build_dir.join(crate_id.path.as_slice());\n                     debug!(\"in loop: checking if {} is a directory\", path.display());\n                     if path.is_dir() {\n                         let ps = PkgSrc::new(source_workspace,\n@@ -163,7 +190,7 @@ impl PkgSrc {\n                             }\n                         }\n \n-                    };\n+                    }\n                 }\n \n                 // Ok, no prefixes work, so try fetching from git\n@@ -179,11 +206,12 @@ impl PkgSrc {\n                     }\n                     match ok_d {\n                         Some(ref d) => {\n-                            if d.is_ancestor_of(&id.path)\n-                                || d.is_ancestor_of(&versionize(&id.path, &id.version)) {\n+                            let path = Path::new(id.path.as_slice());\n+                            if d.is_ancestor_of(&path)\n+                                || d.is_ancestor_of(&versionize(id.path, &id.version)) {\n                                 // Strip off the package ID\n                                 source_workspace = d.clone();\n-                                for _ in id.path.components() {\n+                                for _ in path.components() {\n                                     source_workspace.pop();\n                                 }\n                                 // Strip off the src/ part\n@@ -226,8 +254,7 @@ impl PkgSrc {\n                                         exist, and couldn't interpret it as a URL fragment\"))\n                                 }\n                             }\n-                        }\n-                        else {\n+                        } else {\n                             cond.raise((id.clone(),\n                                 ~\"supplied path for package dir does not \\\n                                 exist, and couldn't interpret it as a URL fragment\"))\n@@ -268,26 +295,27 @@ impl PkgSrc {\n         use conditions::git_checkout_failed::cond;\n \n         let cwd = os::getcwd();\n+        let path = Path::new(crateid.path.as_slice());\n         debug!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n-                crateid.to_str(), crateid.path.display(),\n+                crateid.to_str(), crateid.path,\n                 cwd.display(),\n-                crateid.path.exists());\n+                path.exists());\n \n-        match safe_git_clone(&crateid.path, &crateid.version, local) {\n+        match safe_git_clone(&path, &crateid.version, local) {\n             CheckedOutSources => {\n                 make_read_only(local);\n                 Some(local.clone())\n             }\n             DirToUse(clone_target) => {\n-                if crateid.path.components().nth(1).is_none() {\n+                if path.components().nth(1).is_none() {\n                     // If a non-URL, don't bother trying to fetch\n                     return None;\n                 }\n \n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                let url = format!(\"https://{}\", crateid.path.as_str().unwrap());\n+                let url = format!(\"https://{}\", path.as_str().unwrap());\n                 debug!(\"Fetching package: git clone {} {} [version={}]\",\n-                        url, clone_target.display(), crateid.version.to_str());\n+                        url, clone_target.display(), crateid.version_or_default());\n \n                 let mut failed = false;\n \n@@ -345,7 +373,7 @@ impl PkgSrc {\n         use conditions::missing_pkg_files::cond;\n \n         let prefix = self.start_dir.components().len();\n-        debug!(\"Matching against {}\", self.id.short_name);\n+        debug!(\"Matching against {}\", self.id.name);\n         for pth in fs::walk_dir(&self.start_dir) {\n             let maybe_known_crate_set = match pth.filename_str() {\n                 Some(filename) if filter(filename) => match filename {"}, {"sha": "a0d49e7565f185062373793f55b1bef787f57bef", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 56, "deletions": 142, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -12,19 +12,20 @@\n \n #[allow(dead_code)];\n \n-pub use crate_id::CrateId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n-pub use version::{Version, ExactRevision, NoVersion, split_version, split_version_general,\n-    try_parsing_version};\n+pub use version::{Version, split_version_general};\n pub use rustc::metadata::filesearch::rust_path;\n-use rustc::metadata::filesearch::{libdir, relative_target_lib_path};\n-use rustc::driver::driver::host_triple;\n \n use std::libc;\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os;\n use std::io;\n use std::io::fs;\n+use extra::hex::ToHex;\n+use syntax::crateid::CrateId;\n+use rustc::util::sha2::{Digest, Sha256};\n+use rustc::metadata::filesearch::{libdir, relative_target_lib_path};\n+use rustc::driver::driver::host_triple;\n use messages::*;\n \n pub fn default_workspace() -> Path {\n@@ -78,14 +79,14 @@ pub fn workspace_contains_crate_id_(crateid: &CrateId, workspace: &Path,\n     let mut found = None;\n     for p in fs::walk_dir(&src_dir) {\n         if p.is_dir() {\n-            if p == src_dir.join(&crateid.path) || {\n+            if p == src_dir.join(crateid.path.as_slice()) || {\n                 let pf = p.filename_str();\n                 pf.iter().any(|&g| {\n                     match split_version_general(g, '-') {\n                         None => false,\n                         Some((ref might_match, ref vers)) => {\n-                            *might_match == crateid.short_name\n-                                && (crateid.version == *vers || crateid.version == NoVersion)\n+                            *might_match == crateid.name\n+                                && (crateid.version == *vers || crateid.version == None)\n                         }\n                     }\n                 })\n@@ -173,151 +174,63 @@ fn output_in_workspace(crateid: &CrateId, workspace: &Path, what: OutputType) ->\n /// Figure out what the library name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_library_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&crateid.path, crateid.short_name, Build, workspace, \"build\",\n-                         &crateid.version)\n+    library_in_workspace(crateid, Build, workspace)\n }\n \n /// Does the actual searching stuff\n-pub fn installed_library_in_workspace(pkg_path: &Path, workspace: &Path) -> Option<Path> {\n+pub fn installed_library_in_workspace(crate_id: &CrateId, workspace: &Path) -> Option<Path> {\n     // This could break once we're handling multiple versions better -- I should add a test for it\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    match pkg_path.filename_str() {\n+    let path = Path::new(crate_id.path.as_slice());\n+    match path.filename_str() {\n         None => None,\n-        Some(short_name) => library_in_workspace(pkg_path,\n-                                                 short_name,\n-                                                 Install,\n-                                                 workspace,\n-                                                 libdir(),\n-                                                 &NoVersion)\n+        Some(_short_name) => library_in_workspace(crate_id, Install, workspace)\n     }\n }\n \n /// `workspace` is used to figure out the directory to search.\n-/// `short_name` is taken as the link name of the library.\n-pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n-                        workspace: &Path, prefix: &str, version: &Version) -> Option<Path> {\n+/// `name` is taken as the link name of the library.\n+pub fn library_in_workspace(crate_id: &CrateId, where: Target, workspace: &Path) -> Option<Path> {\n     debug!(\"library_in_workspace: checking whether a library named {} exists\",\n-           short_name);\n-\n-    // We don't know what the hash is, so we have to search through the directory\n-    // contents\n-\n-    debug!(\"short_name = {} where = {:?} workspace = {} \\\n-            prefix = {}\", short_name, where, workspace.display(), prefix);\n+           crate_id.name);\n \n     let dir_to_search = match where {\n-        Build => target_build_dir(workspace).join(path),\n+        Build => target_build_dir(workspace).join(crate_id.path.as_slice()),\n         Install => target_lib_dir(workspace)\n     };\n \n-    library_in(short_name, version, &dir_to_search)\n+    library_in(crate_id, &dir_to_search)\n }\n \n-pub fn system_library(sysroot: &Path, crate_id: &str) -> Option<Path> {\n-    let (lib_name, version) = split_crate_id(crate_id);\n-    library_in(lib_name, &version, &sysroot.join(relative_target_lib_path(host_triple())))\n+pub fn system_library(sysroot: &Path, crate_id: &CrateId) -> Option<Path> {\n+    library_in(crate_id, &sysroot.join(relative_target_lib_path(host_triple())))\n }\n \n-fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n-    debug!(\"Listing directory {}\", dir_to_search.display());\n-    let dir_contents = {\n-        let _guard = io::ignore_io_error();\n-        fs::readdir(dir_to_search)\n-    };\n-    debug!(\"dir has {:?} entries\", dir_contents.len());\n-\n-    let dll_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n-    let dll_filetype = os::consts::DLL_EXTENSION;\n-    let rlib_prefix = format!(\"{}{}\", \"lib\", short_name);\n-    let rlib_filetype = \"rlib\";\n-\n-    debug!(\"dll_prefix = {} and dll_filetype = {}\", dll_prefix, dll_filetype);\n-    debug!(\"rlib_prefix = {} and rlib_filetype = {}\", rlib_prefix, rlib_filetype);\n-\n-    // Find a filename that matches the pattern:\n-    // (lib_prefix)-hash-(version)(lib_suffix)\n-    let mut libraries = dir_contents.iter().filter(|p| {\n-        let extension = p.extension_str();\n-        debug!(\"p = {}, p's extension is {:?}\", p.display(), extension);\n-        match extension {\n-            None => false,\n-            Some(ref s) => dll_filetype == *s || rlib_filetype == *s,\n-        }\n-    });\n-\n-    let mut result_filename = None;\n-    for p_path in libraries {\n-        // Find a filename that matches the pattern: (lib_prefix)-hash-(version)(lib_suffix)\n-        // and remember what the hash was\n-        let mut f_name = match p_path.filestem_str() {\n-            Some(s) => s, None => continue\n-        };\n-        // Already checked the filetype above\n-\n-         // This is complicated because library names and versions can both contain dashes\n-         loop {\n-            if f_name.is_empty() { break; }\n-            match f_name.rfind('-') {\n-                Some(i) => {\n-                    debug!(\"Maybe {} is a version\", f_name.slice(i + 1, f_name.len()));\n-                    match try_parsing_version(f_name.slice(i + 1, f_name.len())) {\n-                        Some(ref found_vers) if version == found_vers => {\n-                            match f_name.slice(0, i).rfind('-') {\n-                                Some(j) => {\n-                                    let lib_prefix = match p_path.extension_str() {\n-                                        Some(ref s) if dll_filetype == *s => &dll_prefix,\n-                                        _ => &rlib_prefix,\n-                                    };\n-                                    debug!(\"Maybe {} equals {}\", f_name.slice(0, j), *lib_prefix);\n-                                    if f_name.slice(0, j) == *lib_prefix {\n-                                        result_filename = Some(p_path.clone());\n-                                    }\n-                                    break;\n-                                }\n-                                None => break\n-                            }\n-\n-                       }\n-                       _ => { f_name = f_name.slice(0, i); }\n-                 }\n-               }\n-               None => break\n-         } // match\n-       } // loop\n-    } // for\n-\n-    if result_filename.is_none() {\n-        debug!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n-                  dir_to_search.display(), short_name);\n-    }\n+fn library_in(crate_id: &CrateId, dir_to_search: &Path) -> Option<Path> {\n+    let mut hasher = Sha256::new();\n+    hasher.reset();\n+    hasher.input_str(crate_id.to_str());\n+    let hash = hasher.result_bytes().to_hex();\n+    let hash = hash.slice_chars(0, 8);\n+\n+    let lib_name = format!(\"{}-{}-{}\", crate_id.name, hash, crate_id.version_or_default());\n+    let filenames = [\n+        format!(\"{}{}.{}\", \"lib\", lib_name, \"rlib\"),\n+        format!(\"{}{}{}\", os::consts::DLL_PREFIX, lib_name, os::consts::DLL_SUFFIX),\n+    ];\n \n-    // Return the filename that matches, which we now know exists\n-    // (if result_filename != None)\n-    let abs_path = result_filename.map(|result_filename| {\n-        let absolute_path = dir_to_search.join(&result_filename);\n-        debug!(\"result_filename = {}\", absolute_path.display());\n-        absolute_path\n-    });\n-\n-    abs_path\n-}\n-\n-fn split_crate_id<'a>(crate_id: &'a str) -> (&'a str, Version) {\n-    match split_version(crate_id) {\n-        Some((name, vers)) =>\n-            match vers {\n-                ExactRevision(ref v) => match v.find('-') {\n-                    Some(pos) => (name, ExactRevision(v.slice(0, pos).to_owned())),\n-                    None => (name, ExactRevision(v.to_owned()))\n-                },\n-                _ => (name, vers)\n-            },\n-        None => (crate_id, NoVersion)\n+    for filename in filenames.iter() {\n+        debug!(\"filename = {}\", filename.as_slice());\n+        let path = dir_to_search.join(filename.as_slice());\n+        if path.exists() {\n+            debug!(\"found: {}\", path.display());\n+            return Some(path);\n+        }\n     }\n+    debug!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n+           dir_to_search.display(), crate_id.to_str());\n+    return None;\n }\n \n-\n-\n /// Returns the executable that would be installed for <crateid>\n /// in <workspace>\n /// As a side effect, creates the bin-dir if it doesn't exist\n@@ -366,7 +279,7 @@ fn target_file_in_workspace(crateid: &CrateId, workspace: &Path,\n     // Artifacts in the build directory live in a package-ID-specific subdirectory,\n     // but installed ones don't.\n     let result = match (where, what) {\n-                (Build, _)      => target_build_dir(workspace).join(&crateid.path),\n+                (Build, _)      => target_build_dir(workspace).join(crateid.path.as_slice()),\n                 (Install, Lib)  => target_lib_dir(workspace),\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n@@ -382,7 +295,7 @@ fn target_file_in_workspace(crateid: &CrateId, workspace: &Path,\n /// Creates it if it doesn't exist.\n pub fn build_pkg_id_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n     let mut result = target_build_dir(workspace);\n-    result.push(&crateid.path);\n+    result.push(crateid.path.as_slice());\n     debug!(\"Creating build dir {} for package id {}\", result.display(),\n            crateid.to_str());\n     fs::mkdir_recursive(&result, io::UserRWX);\n@@ -392,25 +305,24 @@ pub fn build_pkg_id_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n pub fn mk_output_path(what: OutputType, where: Target,\n-                      pkg_id: &CrateId, workspace: Path) -> Path {\n-    let short_name_with_version = format!(\"{}-{}\", pkg_id.short_name,\n-                                          pkg_id.version.to_str());\n+                      crate_id: &CrateId, workspace: Path) -> Path {\n+    let short_name_with_version = crate_id.short_name_with_version();\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n     // the executable blat-0.5 to live under blat/\n     let dir = match where {\n         // If we're installing, it just goes under <workspace>...\n         Install => workspace,\n         // and if we're just building, it goes in a package-specific subdir\n-        Build => workspace.join(&pkg_id.path)\n+        Build => workspace.join(crate_id.path.as_slice())\n     };\n-    debug!(\"[{:?}:{:?}] mk_output_path: short_name = {}, path = {}\", what, where,\n-           if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },\n+    debug!(\"[{:?}:{:?}] mk_output_path: name = {}, path = {}\", what, where,\n+           if what == Lib { short_name_with_version.clone() } else { crate_id.name.clone() },\n            dir.display());\n     let mut output_path = match what {\n         // this code is duplicated from elsewhere; fix this\n         Lib => dir.join(os::dll_filename(short_name_with_version)),\n         // executable names *aren't* versioned\n-        _ => dir.join(format!(\"{}{}{}\", pkg_id.short_name,\n+        _ => dir.join(format!(\"{}{}{}\", crate_id.name,\n                            match what {\n                                Test => \"test\",\n                                Bench => \"bench\",\n@@ -457,11 +369,12 @@ fn dir_has_file(dir: &Path, file: &str) -> bool {\n \n pub fn find_dir_using_rust_path_hack(p: &CrateId) -> Option<Path> {\n     let rp = rust_path();\n+    let path = Path::new(p.path.as_slice());\n     for dir in rp.iter() {\n         // Require that the parent directory match the package ID\n         // Note that this only matches if the package ID being searched for\n         // has a name that's a single component\n-        if dir.ends_with_path(&p.path) || dir.ends_with_path(&versionize(&p.path, &p.version)) {\n+        if dir.ends_with_path(&path) || dir.ends_with_path(&versionize(p.path, &p.version)) {\n             debug!(\"In find_dir_using_rust_path_hack: checking dir {}\", dir.display());\n             if dir_has_crate_file(dir) {\n                 debug!(\"Did find id {} in dir {}\", p.to_str(), dir.display());\n@@ -483,11 +396,12 @@ pub fn user_set_rust_path() -> bool {\n }\n \n /// Append the version string onto the end of the path's filename\n-pub fn versionize(p: &Path, v: &Version) -> Path {\n+pub fn versionize(p: &str, v: &Version) -> Path {\n+    let p = Path::new(p);\n     let q = p.filename().expect(\"path is a directory\");\n     let mut q = q.to_owned();\n     q.push('-' as u8);\n-    let vs = v.to_str();\n+    let vs = match v { &Some(ref s) => s.to_owned(), &None => ~\"0.0\" };\n     q.push_all(vs.as_bytes());\n     p.with_filename(q)\n }"}, {"sha": "2346749feb53a0da3a0516dc8f2bc2236a1f4fa5", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -14,15 +14,14 @@ use std::{run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n use std::io::fs;\n use extra::tempfile::TempDir;\n-use version::*;\n use path_util::chmod_read_only;\n \n /// Attempts to clone `source`, a local git repository, into `target`, a local\n /// directory that doesn't exist.\n /// Returns `DirToUse(p)` if the clone fails, where `p` is a newly created temporary\n /// directory (that the callee may use, for example, to check out remote sources into).\n /// Returns `CheckedOutSources` if the clone succeeded.\n-pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult {\n+pub fn safe_git_clone(source: &Path, v: &Option<~str>, target: &Path) -> CloneResult {\n     if source.exists() {\n         debug!(\"{} exists locally! Cloning it into {}\",\n                 source.display(), target.display());\n@@ -44,7 +43,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n             }\n             else {\n                 match v {\n-                    &ExactRevision(ref s) => {\n+                    &Some(ref s) => {\n                         let git_dir = target.join(\".git\");\n                         debug!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n                                 *s, target.display(), git_dir.display());\n@@ -65,7 +64,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n         } else {\n             // Check that no version was specified. There's no reason to not handle the\n             // case where a version was requested, but I haven't implemented it.\n-            assert!(*v == NoVersion);\n+            assert!(*v == None);\n             let git_dir = target.join(\".git\");\n             debug!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n                     target.display(), git_dir.display(), source.display());\n@@ -106,7 +105,7 @@ pub fn make_read_only(target: &Path) {\n }\n \n /// Source can be either a URL or a local file path.\n-pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n+pub fn git_clone_url(source: &str, target: &Path, v: &Option<~str>) {\n     use conditions::git_checkout_failed::cond;\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -120,7 +119,7 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n     }\n     else {\n         match v {\n-            &ExactRevision(ref s) | &Tagged(ref s) => {\n+            &Some(ref s) => {\n                     let opt_outp = process_output_in_cwd(\"git\", [~\"checkout\", s.to_owned()],\n                                                          target);\n                     let outp = opt_outp.expect(\"Failed to exec `git`\");"}, {"sha": "bf8ec1e738cabc2538ef7f4702169681ef427bc7", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 296, "deletions": 331, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -20,13 +20,12 @@ use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::TempDir;\n use extra::workcache;\n-use extra::workcache::{Database};\n+use extra::workcache::Database;\n use extra::treemap::TreeMap;\n use extra::getopts::groups::getopts;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n-use crate_id::{CrateId};\n-use version::{ExactRevision, NoVersion, Version};\n+use syntax::crateid::CrateId;\n use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                target_bench_in_workspace, make_dir_rwx,\n                library_in_workspace, installed_library_in_workspace,\n@@ -59,19 +58,18 @@ fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n }\n \n fn fake_pkg() -> CrateId {\n-    let sn = ~\"bogus\";\n     CrateId {\n-        path: Path::new(sn.as_slice()),\n-        short_name: sn,\n-        version: NoVersion\n+        path: ~\"bogus\",\n+        name: ~\"bogus\",\n+        version: None\n     }\n }\n \n fn git_repo_pkg() -> CrateId {\n     CrateId {\n-        path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n-        short_name: ~\"test-pkg\",\n-        version: NoVersion\n+        path: ~\"mockgithub.com/catamorphism/test-pkg\",\n+        name: ~\"test-pkg\",\n+        version: None\n     }\n }\n \n@@ -88,28 +86,24 @@ fn mk_emptier_workspace(tag: &str) -> TempDir {\n     workspace\n }\n \n-fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> TempDir {\n+fn mk_empty_workspace(crate_id: &CrateId, tag: &str) -> TempDir {\n     let workspace_dir = TempDir::new(tag).expect(\"couldn't create temp dir\");\n-    mk_workspace(workspace_dir.path(), short_name, version);\n+    mk_workspace(workspace_dir.path(), crate_id);\n     workspace_dir\n }\n \n-fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path {\n+fn mk_workspace(workspace: &Path, crate_id: &CrateId) -> Path {\n     // include version number in directory name\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let package_dir = workspace.join_many([~\"src\", format!(\"{}-{}\",\n-                                           short_name.as_str().unwrap(), version.to_str())]);\n+    let package_dir = workspace.join_many([~\"src\", crate_id.short_name_with_version()]);\n     fs::mkdir_recursive(&package_dir, io::UserRWX);\n     package_dir\n }\n \n-fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n-    let workspace_dir = mk_empty_workspace(short_name, version, \"temp_workspace\");\n+fn mk_temp_workspace(crate_id: &CrateId) -> (TempDir, Path) {\n+    let workspace_dir = mk_empty_workspace(crate_id, \"temp_workspace\");\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let package_dir = workspace_dir.path().join_many([~\"src\",\n-                                                      format!(\"{}-{}\",\n-                                                              short_name.as_str().unwrap(),\n-                                                              version.to_str())]);\n+    let package_dir = workspace_dir.path().join_many([~\"src\", crate_id.short_name_with_version()]);\n \n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n            package_dir.is_dir());\n@@ -278,14 +272,11 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         err_fd: None\n     }).expect(format!(\"failed to exec `{}`\", cmd));\n     let output = prog.finish_with_output();\n-    debug!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n+    debug!(\"Output from command {} with args {:?} was --- {} \\\\{{}\\\\} --- [{:?}]\",\n            cmd, args, str::from_utf8(output.output).unwrap(),\n            str::from_utf8(output.error).unwrap(),\n            output.status);\n     if !output.status.success() {\n-        debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} {} ---\",\n-              cmd, args, output.status,\n-              str::from_utf8(output.output).unwrap(), str::from_utf8(output.error).unwrap());\n         Fail(output)\n     }\n     else {\n@@ -294,15 +285,15 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n }\n \n fn create_local_package(crateid: &CrateId) -> TempDir {\n-    let (workspace, parent_dir) = mk_temp_workspace(&crateid.path, &crateid.version);\n+    let (workspace, parent_dir) = mk_temp_workspace(crateid);\n     debug!(\"Created empty package dir for {}, returning {}\", crateid.to_str(),\n            parent_dir.display());\n     workspace\n }\n \n fn create_local_package_in(crateid: &CrateId, pkgdir: &Path) -> Path {\n \n-    let package_dir = pkgdir.join_many([~\"src\", crateid.to_str()]);\n+    let package_dir = pkgdir.join_many([~\"src\", crateid.short_name_with_version()]);\n \n     // Create main, lib, test, and bench files\n     fs::mkdir_recursive(&package_dir, io::UserRWX);\n@@ -330,11 +321,15 @@ fn create_local_package_with_dep(crateid: &CrateId, subord_crateid: &CrateId) ->\n     let package_dir = create_local_package(crateid);\n     create_local_package_in(subord_crateid, package_dir.path());\n     // Write a main.rs file into crateid that references subord_crateid\n-    writeFile(&package_dir.path().join_many([~\"src\", crateid.to_str(), ~\"main.rs\"]),\n+    writeFile(&package_dir.path().join_many([~\"src\",\n+                                             crateid.short_name_with_version(),\n+                                             ~\"main.rs\"]),\n               format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n-                   subord_crateid.short_name));\n+                   subord_crateid.name));\n     // Write a lib.rs file into subord_crateid that has something in it\n-    writeFile(&package_dir.path().join_many([~\"src\", subord_crateid.to_str(), ~\"lib.rs\"]),\n+    writeFile(&package_dir.path().join_many([~\"src\",\n+                                             subord_crateid.short_name_with_version(),\n+                                             ~\"lib.rs\"]),\n               \"pub fn f() {}\");\n     package_dir\n }\n@@ -348,13 +343,13 @@ fn create_local_package_with_custom_build_hook(crateid: &CrateId,\n \n }\n \n-fn assert_lib_exists(repo: &Path, pkg_path: &Path, v: Version) {\n-    assert!(lib_exists(repo, pkg_path, v));\n+fn assert_lib_exists(repo: &Path, crate_id: &CrateId) {\n+    assert!(lib_exists(repo, crate_id));\n }\n \n-fn lib_exists(repo: &Path, pkg_path: &Path, _v: Version) -> bool { // ??? version?\n-    debug!(\"assert_lib_exists: repo = {}, pkg_path = {}\", repo.display(), pkg_path.display());\n-    let lib = installed_library_in_workspace(pkg_path, repo);\n+fn lib_exists(repo: &Path, crate_id: &CrateId) -> bool {\n+    debug!(\"assert_lib_exists: repo = {}, crate_id = {}\", repo.display(), crate_id.to_str());\n+    let lib = installed_library_in_workspace(crate_id, repo);\n     debug!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n@@ -367,19 +362,21 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n     debug!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = target_executable_in_workspace(&CrateId::new(short_name), repo);\n+    let exec = target_executable_in_workspace(&crate_id, repo);\n     exec.exists() && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n     debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = built_test_in_workspace(&CrateId::new(short_name), repo);\n+    let exec = built_test_in_workspace(&crate_id, repo);\n     exec.map_or(false, |exec| exec.exists() && is_rwx(&exec))\n }\n \n fn remove_executable_file(p: &CrateId, workspace: &Path) {\n-    let exec = target_executable_in_workspace(&CrateId::new(p.short_name), workspace);\n+    let exec = target_executable_in_workspace(p, workspace);\n     if exec.exists() {\n         fs::unlink(&exec);\n     }\n@@ -392,15 +389,16 @@ fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n             repo.display(), short_name);\n-    let exec = built_executable_in_workspace(&CrateId::new(short_name), repo);\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n+    let exec = built_executable_in_workspace(&crate_id, repo);\n     exec.is_some() && {\n        let execname = exec.get_ref();\n        execname.exists() && is_rwx(execname)\n     }\n }\n \n fn remove_built_executable_file(p: &CrateId, workspace: &Path) {\n-    let exec = built_executable_in_workspace(&CrateId::new(p.short_name), workspace);\n+    let exec = built_executable_in_workspace(p, workspace);\n     match exec {\n         Some(r) => fs::unlink(&r),\n         None    => ()\n@@ -435,7 +433,8 @@ fn assert_built_library_exists(repo: &Path, short_name: &str) {\n \n fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let lib = built_library_in_workspace(&CrateId::new(short_name), repo);\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n+    let lib = built_library_in_workspace(&crate_id, repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n         libname.exists() && is_rwx(libname)\n@@ -470,18 +469,16 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n     debug!(\"lib_output_file_name: given {} and short name {}\",\n            workspace.display(), short_name);\n-    library_in_workspace(&Path::new(short_name),\n-                         short_name,\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n+    library_in_workspace(&crate_id,\n                          Build,\n-                         workspace,\n-                         \"build\",\n-                         &NoVersion).expect(\"lib_output_file_name\")\n+                         workspace).expect(\"lib_output_file_name\")\n }\n \n #[cfg(target_os = \"linux\")]\n fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.short_name_with_version()]);\n     let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n@@ -501,7 +498,7 @@ fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n #[cfg(not(target_os = \"linux\"))]\n fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.short_name_with_version()]);\n     let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n@@ -520,7 +517,7 @@ fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n /// Add a comment at the end\n fn frob_source_file(workspace: &Path, crateid: &CrateId, filename: &str) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.short_name_with_version()]);\n     let mut maybe_p = None;\n     let maybe_file = pkg_src_dir.join(filename);\n     debug!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n@@ -567,7 +564,7 @@ fn test_install_valid() {\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = {}\", sysroot.display());\n     let temp_pkg_id = fake_pkg();\n-    let (temp_workspace, _pkg_dir) = mk_temp_workspace(&temp_pkg_id.path, &NoVersion);\n+    let (temp_workspace, _pkg_dir) = mk_temp_workspace(&temp_pkg_id);\n     let temp_workspace = temp_workspace.path();\n     let ctxt = fake_ctxt(sysroot, temp_workspace);\n     debug!(\"temp_workspace = {}\", temp_workspace.display());\n@@ -583,7 +580,7 @@ fn test_install_valid() {\n     assert!(exec.exists());\n     assert!(is_rwx(&exec));\n \n-    let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n+    let lib = installed_library_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"lib = {:?}\", lib);\n     assert!(lib.as_ref().map_or(false, |l| l.exists()));\n     assert!(lib.as_ref().map_or(false, |l| is_rwx(l)));\n@@ -623,9 +620,8 @@ fn test_install_invalid() {\n \n #[test]\n fn test_install_valid_external() {\n-    let temp_pkg_id = CrateId::new(\"foo\");\n-    let (tempdir, _) = mk_temp_workspace(&temp_pkg_id.path,\n-                                         &temp_pkg_id.version);\n+    let temp_pkg_id: CrateId = from_str(\"foo\").unwrap();\n+    let (tempdir, _) = mk_temp_workspace(&temp_pkg_id);\n     let temp_workspace = tempdir.path();\n     command_line_test([~\"install\", ~\"foo\"], temp_workspace);\n \n@@ -635,7 +631,7 @@ fn test_install_valid_external() {\n     assert!(exec.exists());\n     assert!(is_rwx(&exec));\n \n-    let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n+    let lib = installed_library_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"lib = {:?}\", lib);\n     assert!(lib.as_ref().map_or(false, |l| l.exists()));\n     assert!(lib.as_ref().map_or(false, |l| is_rwx(l)));\n@@ -662,7 +658,8 @@ fn test_install_invalid_external() {\n #[test]\n fn test_install_git() {\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&temp_pkg_id.path);\n+    let path = Path::new(temp_pkg_id.path.as_slice());\n+    let repo = init_git_repo(&path);\n     let repo = repo.path();\n     debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n@@ -679,10 +676,9 @@ fn test_install_git() {\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n     debug!(\"test_install_git: calling rustpkg install {} in {}\",\n-           temp_pkg_id.path.display(), repo.display());\n+           temp_pkg_id.path, repo.display());\n     // should have test, bench, lib, and main\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n+    command_line_test([~\"install\", temp_pkg_id.path.to_owned()], repo);\n     let ws = repo.join(\".rust\");\n     // Check that all files exist\n     debug!(\"Checking for files in {}\", ws.display());\n@@ -693,7 +689,7 @@ fn test_install_git() {\n     let _built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n                                    &ws).expect(\"test_install_git: built lib should exist\");\n-    assert_lib_exists(&ws, &temp_pkg_id.path, temp_pkg_id.version.clone());\n+    assert_lib_exists(&ws, &temp_pkg_id);\n     let built_test = built_test_in_workspace(&temp_pkg_id,\n                          &ws).expect(\"test_install_git: built test should exist\");\n     assert!(built_test.exists());\n@@ -711,8 +707,6 @@ fn test_install_git() {\n \n #[test]\n fn test_crate_ids_must_be_relative_path_like() {\n-    use conditions::bad_pkg_id::cond;\n-\n     /*\n     Okay:\n     - One identifier, with no slashes\n@@ -724,72 +718,16 @@ fn test_crate_ids_must_be_relative_path_like() {\n \n     */\n \n-    let whatever = CrateId::new(\"foo\");\n+    let foo: CrateId = from_str(\"foo\").unwrap();\n+    assert_eq!(~\"foo#0.0\", foo.to_str());\n+    let test_pkg: CrateId = from_str(\"github.com/catamorphism/test-pkg\").unwrap();\n+    assert_eq!(~\"github.com/catamorphism/test-pkg#0.0\", test_pkg.to_str());\n \n-    assert_eq!(~\"foo-0.0\", whatever.to_str());\n-    assert!(\"github.com/catamorphism/test-pkg-0.0\" ==\n-            CrateId::new(\"github.com/catamorphism/test-pkg\").to_str());\n-\n-    cond.trap(|(p, e)| {\n-        assert!(p.filename().is_none());\n-        assert!(\"bad crateid\" == e);\n-        whatever.clone()\n-    }).inside(|| {\n-        let x = CrateId::new(\"\");\n-        assert_eq!(~\"foo-0.0\", x.to_str());\n-    });\n+    let x: Option<CrateId> = from_str(\"\");\n+    assert_eq!(x, None);\n \n-    cond.trap(|(p, e)| {\n-        let abs = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n-        assert_eq!(p, abs);\n-        assert!(\"bad crateid\" == e);\n-        whatever.clone()\n-    }).inside(|| {\n-        let zp = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let z = CrateId::new(zp.as_str().unwrap());\n-        assert_eq!(~\"foo-0.0\", z.to_str());\n-    })\n-}\n-\n-#[test]\n-fn test_package_version() {\n-    let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n-    let repo = init_git_repo(&Path::new(local_path));\n-    let repo = repo.path();\n-    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n-    debug!(\"Writing files in: {}\", repo_subdir.display());\n-    fs::mkdir_recursive(&repo_subdir, io::UserRWX);\n-    writeFile(&repo_subdir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join(\"lib.rs\"),\n-              \"pub fn f() { let _x = (); }\");\n-    writeFile(&repo_subdir.join(\"test.rs\"),\n-              \"#[test] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.join(\"bench.rs\"),\n-              \"#[bench] pub fn f() { (); }\");\n-    add_git_tag(&repo_subdir, ~\"0.4\");\n-\n-    // It won't pick up the 0.4 version because the dir isn't in the RUST_PATH, but...\n-    let temp_pkg_id = CrateId::new(\"mockgithub.com/catamorphism/test_pkg_version\");\n-    // This should look at the prefix, clone into a workspace, then build.\n-    command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg_version\"],\n-                      repo);\n-    let ws = repo.join(\".rust\");\n-    // we can still match on the filename to make sure it contains the 0.4 version\n-    assert!(match built_library_in_workspace(&temp_pkg_id,\n-                                             &ws) {\n-        Some(p) => {\n-            let suffix = format!(\"0.4{}\", os::consts::DLL_SUFFIX);\n-            p.as_vec().ends_with(suffix.as_bytes())\n-        }\n-        None    => false\n-    });\n-    assert!(built_executable_in_workspace(&temp_pkg_id, &ws)\n-            == Some(target_build_dir(&ws).join_many([\"mockgithub.com\",\n-                                                     \"catamorphism\",\n-                                                     \"test_pkg_version\",\n-                                                     \"test_pkg_version\"])));\n+    let z: Option<CrateId> = from_str(\"/foo/bar/quux\");\n+    assert_eq!(z, None);\n }\n \n #[test]\n@@ -814,7 +752,8 @@ fn test_package_request_version() {\n \n     command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], repo);\n \n-    assert!(match installed_library_in_workspace(&Path::new(\"test_pkg_version\"),\n+    let crate_id = from_str(format!(\"{}\\\\#0.3\", local_path)).unwrap();\n+    assert!(match installed_library_in_workspace(&crate_id,\n                                                  &repo.join(\".rust\")) {\n         Some(p) => {\n             debug!(\"installed: {}\", p.display());\n@@ -823,7 +762,7 @@ fn test_package_request_version() {\n         }\n         None    => false\n     });\n-    let temp_pkg_id = CrateId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n+    let temp_pkg_id = from_str(\"mockgithub.com/catamorphism/test_pkg_version#0.3\").unwrap();\n     assert!(target_executable_in_workspace(&temp_pkg_id, &repo.join(\".rust\"))\n             == repo.join_many([\".rust\", \"bin\", \"test_pkg_version\"]));\n \n@@ -858,23 +797,26 @@ fn rustpkg_library_target() {\n               \"#[test] pub fn f() { (); }\");\n     writeFile(&package_dir.join(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n+    add_git_tag(&package_dir, ~\"0.0\");\n \n-    add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], foo_repo);\n-    assert_lib_exists(&foo_repo.join(\".rust\"), &Path::new(\"foo\"), ExactRevision(~\"1.0\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    assert_lib_exists(&foo_repo.join(\".rust\"), &crate_id);\n }\n \n #[test]\n fn rustpkg_local_pkg() {\n-    let dir = create_local_package(&CrateId::new(\"foo\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let dir = create_local_package(&crate_id);\n     command_line_test([~\"install\", ~\"foo\"], dir.path());\n     assert_executable_exists(dir.path(), \"foo\");\n }\n \n #[test]\n #[ignore(reason=\"busted\")]\n fn package_script_with_default_build() {\n-    let dir = create_local_package(&CrateId::new(\"fancy-lib\"));\n+    let crate_id: CrateId = from_str(\"fancy-lib\").unwrap();\n+    let dir = create_local_package(&crate_id);\n     let dir = dir.path();\n     debug!(\"dir = {}\", dir.display());\n     let mut source = test_sysroot().dir_path();\n@@ -884,7 +826,7 @@ fn package_script_with_default_build() {\n     debug!(\"package_script_with_default_build: {}\", source.display());\n     fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.0\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n-    assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n+    assert_lib_exists(dir, &crate_id);\n     assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n     let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n     debug!(\"generated path = {}\", generated_path.display());\n@@ -915,7 +857,8 @@ fn rustpkg_install_no_arg() {\n               \"fn main() { let _x = (); }\");\n     debug!(\"install_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"install\"], &package_dir);\n-    assert_lib_exists(&tmp, &Path::new(\"foo\"), NoVersion);\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    assert_lib_exists(&tmp, &crate_id);\n }\n \n #[test]\n@@ -931,14 +874,16 @@ fn rustpkg_clean_no_arg() {\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n-    let res = built_executable_in_workspace(&CrateId::new(\"foo\"), &tmp);\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let res = built_executable_in_workspace(&crate_id, &tmp);\n     assert!(!res.as_ref().map_or(false, |m| m.exists()));\n }\n \n #[test]\n fn rust_path_test() {\n     let dir_for_path = TempDir::new(\"more_rust\").expect(\"rust_path_test failed\");\n-    let dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let dir = mk_workspace(dir_for_path.path(), &crate_id);\n     debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n@@ -989,11 +934,11 @@ fn rust_path_parse() {\n fn test_list() {\n     let dir = TempDir::new(\"test_list\").expect(\"test_list failed\");\n     let dir = dir.path();\n-    let foo = CrateId::new(\"foo\");\n+    let foo: CrateId = from_str(\"foo\").unwrap();\n     create_local_package_in(&foo, dir);\n-    let bar = CrateId::new(\"bar\");\n+    let bar: CrateId = from_str(\"bar\").unwrap();\n     create_local_package_in(&bar, dir);\n-    let quux = CrateId::new(\"quux\");\n+    let quux: CrateId = from_str(\"quux\").unwrap();\n     create_local_package_in(&quux, dir);\n \n // list doesn't output very much right now...\n@@ -1019,9 +964,9 @@ fn test_list() {\n fn install_remove() {\n     let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n     let dir = dir.path();\n-    let foo = CrateId::new(\"foo\");\n-    let bar = CrateId::new(\"bar\");\n-    let quux = CrateId::new(\"quux\");\n+    let foo: CrateId = from_str(\"foo\").unwrap();\n+    let bar: CrateId = from_str(\"bar\").unwrap();\n+    let quux: CrateId = from_str(\"quux\").unwrap();\n     create_local_package_in(&foo, dir);\n     create_local_package_in(&bar, dir);\n     create_local_package_in(&quux, dir);\n@@ -1048,15 +993,15 @@ fn install_check_duplicates() {\n     // check invariant that there are no dups in the pkg database\n     let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n     let dir = dir.path();\n-    let foo = CrateId::new(\"foo\");\n+    let foo: CrateId = from_str(\"foo\").unwrap();\n     create_local_package_in(&foo, dir);\n \n     command_line_test([~\"install\", ~\"foo\"], dir);\n     command_line_test([~\"install\", ~\"foo\"], dir);\n     let mut contents = ~[];\n     let check_dups = |p: &CrateId| {\n         if contents.contains(p) {\n-            fail!(\"package {} appears in `list` output more than once\", p.path.display());\n+            fail!(\"package {} appears in `list` output more than once\", p.path);\n         }\n         else {\n             contents.push((*p).clone());\n@@ -1068,7 +1013,7 @@ fn install_check_duplicates() {\n \n #[test]\n fn no_rebuilding() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1089,11 +1034,11 @@ fn no_rebuilding() {\n #[test]\n #[ignore]\n fn no_recopying() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"install\", ~\"foo\"], workspace);\n-    let foo_lib = installed_library_in_workspace(&p_id.path, workspace);\n+    let foo_lib = installed_library_in_workspace(&p_id, workspace);\n     assert!(foo_lib.is_some());\n     // Now make `foo` read-only so that subsequent attempts to copy to it will fail\n     assert!(chmod_read_only(&foo_lib.unwrap()));\n@@ -1108,8 +1053,8 @@ fn no_recopying() {\n \n #[test]\n fn no_rebuilding_dep() {\n-    let p_id = CrateId::new(\"foo\");\n-    let dep_id = CrateId::new(\"bar\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let dep_id: CrateId = from_str(\"bar\").unwrap();\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1127,8 +1072,8 @@ fn no_rebuilding_dep() {\n \n #[test]\n fn do_rebuild_dep_dates_change() {\n-    let p_id = CrateId::new(\"foo\");\n-    let dep_id = CrateId::new(\"bar\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let dep_id: CrateId = from_str(\"bar\").unwrap();\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1147,8 +1092,8 @@ fn do_rebuild_dep_dates_change() {\n \n #[test]\n fn do_rebuild_dep_only_contents_change() {\n-    let p_id = CrateId::new(\"foo\");\n-    let dep_id = CrateId::new(\"bar\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let dep_id: CrateId = from_str(\"bar\").unwrap();\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1168,8 +1113,10 @@ fn do_rebuild_dep_only_contents_change() {\n \n #[test]\n fn test_versions() {\n-    let workspace = create_local_package(&CrateId::new(\"foo#0.1\"));\n-    let _other_workspace = create_local_package(&CrateId::new(\"foo#0.2\"));\n+    let foo_01: CrateId = from_str(\"foo#0.1\").unwrap();\n+    let foo_02: CrateId = from_str(\"foo#0.2\").unwrap();\n+    let workspace = create_local_package(&foo_01);\n+    let _other_workspace = create_local_package(&foo_02);\n     command_line_test([~\"install\", ~\"foo#0.1\"], workspace.path());\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n@@ -1179,7 +1126,8 @@ fn test_versions() {\n #[test]\n #[ignore(reason = \"do not yet implemented\")]\n fn test_build_hooks() {\n-    let workspace = create_local_package_with_custom_build_hook(&CrateId::new(\"foo\"),\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let workspace = create_local_package_with_custom_build_hook(&crate_id,\n                                                                 \"frob\");\n     command_line_test([~\"do\", ~\"foo\", ~\"frob\"], workspace.path());\n }\n@@ -1189,14 +1137,16 @@ fn test_build_hooks() {\n #[ignore(reason = \"info not yet implemented\")]\n fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n-    let workspace = create_local_package(&CrateId::new(\"foo\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let workspace = create_local_package(&crate_id);\n     let output = command_line_test([~\"info\", ~\"foo\"], workspace.path());\n     assert_eq!(str::from_utf8_owned(output.output).unwrap(), expected_info);\n }\n \n #[test]\n fn test_uninstall() {\n-    let workspace = create_local_package(&CrateId::new(\"foo\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let workspace = create_local_package(&crate_id);\n     command_line_test([~\"uninstall\", ~\"foo\"], workspace.path());\n     let output = command_line_test([~\"list\"], workspace.path());\n     assert!(!str::from_utf8(output.output).unwrap().contains(\"foo\"));\n@@ -1205,7 +1155,7 @@ fn test_uninstall() {\n #[test]\n fn test_non_numeric_tag() {\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo = init_git_repo(&Path::new(temp_pkg_id.path.as_slice()));\n     let repo = repo.path();\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n     writeFile(&repo_subdir.join(\"foo\"), \"foo\");\n@@ -1217,9 +1167,7 @@ fn test_non_numeric_tag() {\n     writeFile(&repo_subdir.join(\"not_on_testbranch_only\"), \"bye bye\");\n     add_all_and_commit(&repo_subdir);\n \n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\",\n-                                           temp_pkg_id.path.as_str().unwrap())], repo);\n+    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\", temp_pkg_id.path)], repo);\n     let file1 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"testbranch_only\"]);\n     let file2 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"master_only\"]);\n     assert!(file1.exists());\n@@ -1332,7 +1280,7 @@ fn test_extern_mod_simpler() {\n \n #[test]\n fn test_import_rustpkg() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n@@ -1345,7 +1293,7 @@ fn test_import_rustpkg() {\n \n #[test]\n fn test_macro_pkg_script() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n@@ -1362,8 +1310,10 @@ fn multiple_workspaces() {\n // Copy the exact same package into directory B and install it\n // Set the RUST_PATH to A:B\n // Make a third package that uses foo, make sure we can build/install it\n-    let (a_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n-    let (b_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_p_id: CrateId = from_str(\"bar\").unwrap();\n+    let (a_loc, _pkg_dir) = mk_temp_workspace(&p_id);\n+    let (b_loc, _pkg_dir) = mk_temp_workspace(&p_id);\n     let (a_loc, b_loc) = (a_loc.path(), b_loc.path());\n     debug!(\"Trying to install foo in {}\", a_loc.display());\n     command_line_test([~\"install\", ~\"foo\"], a_loc);\n@@ -1372,7 +1322,7 @@ fn multiple_workspaces() {\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.as_str().unwrap(),\n                                             b_loc.as_str().unwrap()))]);\n-    let c_loc = create_local_package_with_dep(&CrateId::new(\"bar\"), &CrateId::new(\"foo\"));\n+    let c_loc = create_local_package_with_dep(&bar_p_id, &p_id);\n     command_line_test_with_env([~\"install\", ~\"bar\"], c_loc.path(), env);\n }\n \n@@ -1385,26 +1335,28 @@ fn rust_path_hack_test(hack_flag: bool) {\n       make sure built files for foo are in B\n       make sure nothing gets built into A or A/../build[lib,bin]\n */\n-   let p_id = CrateId::new(\"foo\");\n-   let workspace = create_local_package(&p_id);\n-   let workspace = workspace.path();\n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   let foo_path = workspace.join_many([\"src\", \"foo-0.0\"]);\n-   let rust_path = Some(~[(~\"RUST_PATH\",\n-       format!(\"{}:{}\",\n-               dest_workspace.as_str().unwrap(),\n-               foo_path.as_str().unwrap()))]);\n-   command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n-                               ~[~\"foo\"], dest_workspace, rust_path);\n-   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n-   assert_executable_exists(dest_workspace, \"foo\");\n-   assert_built_library_exists(dest_workspace, \"foo\");\n-   assert_built_executable_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(workspace, &Path::new(\"foo\"), NoVersion));\n-   assert!(!executable_exists(workspace, \"foo\"));\n-   assert!(!built_library_exists(workspace, \"foo\"));\n-   assert!(!built_executable_exists(workspace, \"foo\"));\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_p_id: CrateId = from_str(\"bar\").unwrap();\n+    let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n+    let dest_workspace = mk_empty_workspace(&bar_p_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    let foo_path = workspace.join_many([\"src\", \"foo-0.0\"]);\n+    let rust_path = Some(~[(~\"RUST_PATH\",\n+        format!(\"{}:{}\",\n+                dest_workspace.as_str().unwrap(),\n+                foo_path.as_str().unwrap()))]);\n+    command_line_test_with_env(~[~\"install\"] +\n+                               if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } + ~[~\"foo\"],\n+                               dest_workspace, rust_path);\n+    assert_lib_exists(dest_workspace, &p_id);\n+    assert_executable_exists(dest_workspace, \"foo\");\n+    assert_built_library_exists(dest_workspace, \"foo\");\n+    assert_built_executable_exists(dest_workspace, \"foo\");\n+    assert!(!lib_exists(workspace, &p_id));\n+    assert!(!executable_exists(workspace, \"foo\"));\n+    assert!(!built_library_exists(workspace, \"foo\"));\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n }\n \n // Notice that this is the only test case where the --rust-path-hack\n@@ -1430,88 +1382,95 @@ fn test_rust_path_can_contain_package_dirs_without_flag() {\n \n #[test]\n fn rust_path_hack_cwd() {\n-   // Same as rust_path_hack_test, but the CWD is the dir to build out of\n-   let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n-   let cwd = cwd.path().join(\"foo\");\n-   fs::mkdir_recursive(&cwd, io::UserRWX);\n-   writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n-\n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   // FIXME (#9639): This needs to handle non-utf8 paths\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-   command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n-   debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n-   assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&cwd, &Path::new(\"foo\"), NoVersion));\n-   assert!(!built_library_exists(&cwd, \"foo\"));\n+    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n+    let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n+    let cwd = cwd.path().join(\"foo\");\n+    fs::mkdir_recursive(&cwd, io::UserRWX);\n+    writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n+\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n+    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n+    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n+    assert_lib_exists(dest_workspace, &foo_id);\n+    assert_built_library_exists(dest_workspace, \"foo\");\n+    assert!(!lib_exists(&cwd, &foo_id));\n+    assert!(!built_library_exists(&cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_multi_path() {\n-   // Same as rust_path_hack_test, but with a more complex package ID\n-   let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n-   let subdir = cwd.path().join_many([\"foo\", \"bar\", \"quux\"]);\n-   fs::mkdir_recursive(&subdir, io::UserRWX);\n-   writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n-   let name = ~\"foo/bar/quux\";\n-\n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   // FIXME (#9639): This needs to handle non-utf8 paths\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-   command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n-   debug!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::new(\"quux\"), NoVersion);\n-   assert_built_library_exists(dest_workspace, name);\n-   assert!(!lib_exists(&subdir, &Path::new(\"quux\"), NoVersion));\n-   assert!(!built_library_exists(&subdir, name));\n+    // Same as rust_path_hack_test, but with a more complex package ID\n+    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n+    let subdir = cwd.path().join_many([\"foo\", \"bar\", \"quux\"]);\n+    fs::mkdir_recursive(&subdir, io::UserRWX);\n+    writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n+    let name = ~\"foo/bar/quux\";\n+    let foo_id: CrateId = from_str(\"foo/bar/quux\").unwrap();\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n+\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n+    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n+    debug!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n+    assert_lib_exists(dest_workspace, &foo_id);\n+    assert_built_library_exists(dest_workspace, name);\n+    assert!(!lib_exists(&subdir, &foo_id));\n+    assert!(!built_library_exists(&subdir, name));\n }\n \n #[test]\n fn rust_path_hack_install_no_arg() {\n-   // Same as rust_path_hack_cwd, but making rustpkg infer the pkg id\n-   let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n-   let cwd = cwd.path();\n-   let source_dir = cwd.join(\"foo\");\n-   assert!(make_dir_rwx(&source_dir));\n-   writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n-\n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   // FIXME (#9639): This needs to handle non-utf8 paths\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-   command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n-   assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&source_dir, &Path::new(\"foo\"), NoVersion));\n-   assert!(!built_library_exists(cwd, \"foo\"));\n+    // Same as rust_path_hack_cwd, but making rustpkg infer the pkg id\n+    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n+    let cwd = cwd.path();\n+    let source_dir = cwd.join(\"foo\");\n+    assert!(make_dir_rwx(&source_dir));\n+    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n+\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n+    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n+    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n+    assert_lib_exists(dest_workspace, &foo_id);\n+    assert_built_library_exists(dest_workspace, \"foo\");\n+    assert!(!lib_exists(&source_dir, &foo_id));\n+    assert!(!built_library_exists(cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_build_no_arg() {\n-   // Same as rust_path_hack_install_no_arg, but building instead of installing\n-   let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n-   let source_dir = cwd.path().join(\"foo\");\n-   assert!(make_dir_rwx(&source_dir));\n-   writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n-\n-   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   // FIXME (#9639): This needs to handle non-utf8 paths\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-   command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!built_library_exists(&source_dir, \"foo\"));\n+    // Same as rust_path_hack_install_no_arg, but building instead of installing\n+    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n+    let source_dir = cwd.path().join(\"foo\");\n+    assert!(make_dir_rwx(&source_dir));\n+    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n+\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n+    command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n+    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n+    assert_built_library_exists(dest_workspace, \"foo\");\n+    assert!(!built_library_exists(&source_dir, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_build_with_dependency() {\n-    let foo_id = CrateId::new(\"foo\");\n-    let dep_id = CrateId::new(\"dep\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let dep_id: CrateId = from_str(\"dep\").unwrap();\n     // Tests that when --rust-path-hack is in effect, dependencies get built\n     // into the destination workspace and not the source directory\n     let work_dir = create_local_package(&foo_id);\n@@ -1536,7 +1495,8 @@ fn rust_path_hack_build_with_dependency() {\n fn rust_path_install_target() {\n     let dir_for_path = TempDir::new(\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n-    let mut dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let mut dir = mk_workspace(dir_for_path.path(), &foo_id);\n     debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n     let dir_to_install_to = TempDir::new(\n@@ -1559,7 +1519,7 @@ fn rust_path_install_target() {\n \n #[test]\n fn sysroot_flag() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // no-op sysroot setting; I'm not sure how else to test this\n@@ -1575,7 +1535,7 @@ fn sysroot_flag() {\n \n #[test]\n fn compile_flag_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1592,7 +1552,7 @@ fn compile_flag_build() {\n #[test]\n fn compile_flag_fail() {\n     // --no-link shouldn't be accepted for install\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1608,7 +1568,7 @@ fn compile_flag_fail() {\n \n #[test]\n fn notrans_flag_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n@@ -1633,7 +1593,7 @@ fn notrans_flag_build() {\n #[test]\n fn notrans_flag_fail() {\n     // --no-trans shouldn't be accepted for install\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n@@ -1648,13 +1608,13 @@ fn notrans_flag_fail() {\n                           workspace, None, BAD_FLAG_CODE);\n         assert!(!built_executable_exists(workspace, \"foo\"));\n         assert!(!object_file_exists(workspace, \"foo\"));\n-        assert!(!lib_exists(workspace, &Path::new(\"foo\"), NoVersion));\n+        assert!(!lib_exists(workspace, &p_id));\n     }\n }\n \n #[test]\n fn dash_S() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1671,7 +1631,7 @@ fn dash_S() {\n \n #[test]\n fn dash_S_fail() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1688,7 +1648,7 @@ fn dash_S_fail() {\n \n #[test]\n fn test_cfg_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // If the cfg flag gets messed up, this won't compile\n@@ -1707,7 +1667,7 @@ fn test_cfg_build() {\n \n #[test]\n fn test_cfg_fail() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]),\n@@ -1726,7 +1686,7 @@ fn test_cfg_fail() {\n \n #[test]\n fn test_emit_llvm_S_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1744,7 +1704,7 @@ fn test_emit_llvm_S_build() {\n \n #[test]\n fn test_emit_llvm_S_fail() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1764,7 +1724,7 @@ fn test_emit_llvm_S_fail() {\n \n #[test]\n fn test_emit_llvm_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1783,7 +1743,7 @@ fn test_emit_llvm_build() {\n \n #[test]\n fn test_emit_llvm_fail() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1804,7 +1764,7 @@ fn test_emit_llvm_fail() {\n \n #[test]\n fn test_linker_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let matches = getopts([], optgroups());\n@@ -1849,7 +1809,7 @@ fn test_build_install_flags_fail() {\n \n #[test]\n fn test_optimized_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1879,19 +1839,19 @@ fn crateid_pointing_to_subdir() {\n     fs::mkdir_recursive(&foo_dir, io::UserRWX);\n     fs::mkdir_recursive(&bar_dir, io::UserRWX);\n     writeFile(&foo_dir.join(\"lib.rs\"),\n-              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/rust-foo#foo:0.0\\\"];\" +\n+              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/foo\\\"];\" +\n               \"pub fn f() {}\");\n     writeFile(&bar_dir.join(\"lib.rs\"),\n-              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/rust-bar#bar:0.0\\\"];\" +\n+              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/bar\\\"];\" +\n               \"pub fn g() {}\");\n \n     debug!(\"Creating a file in {}\", workspace.display());\n     let testpkg_dir = workspace.join_many([\"src\", \"testpkg-0.0\"]);\n     fs::mkdir_recursive(&testpkg_dir, io::UserRWX);\n \n     writeFile(&testpkg_dir.join(\"main.rs\"),\n-              \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo\\\";\\n\n-               extern mod bar = \\\"mockgithub.com/mozilla/some_repo/extras/bar\\\";\\n\n+              \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo#foo:0.0\\\";\\n\n+               extern mod bar = \\\"mockgithub.com/mozilla/some_repo/extras/bar#bar:0.0\\\";\\n\n                use foo::f; use bar::g; \\n\n                fn main() { f(); g(); }\");\n \n@@ -1901,9 +1861,9 @@ fn crateid_pointing_to_subdir() {\n \n #[test]\n fn test_recursive_deps() {\n-    let a_id = CrateId::new(\"a\");\n-    let b_id = CrateId::new(\"b\");\n-    let c_id = CrateId::new(\"c\");\n+    let a_id: CrateId = from_str(\"a\").unwrap();\n+    let b_id: CrateId = from_str(\"b\").unwrap();\n+    let c_id: CrateId = from_str(\"c\").unwrap();\n     let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n     let b_workspace = b_workspace.path();\n     writeFile(&b_workspace.join_many([\"src\", \"c-0.0\", \"lib.rs\"]),\n@@ -1920,17 +1880,18 @@ fn test_recursive_deps() {\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                a_workspace,\n                                environment);\n-    assert_lib_exists(a_workspace, &Path::new(\"a\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path::new(\"b\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path::new(\"c\"), NoVersion);\n+    assert_lib_exists(a_workspace, &a_id);\n+    assert_lib_exists(b_workspace, &b_id);\n+    assert_lib_exists(b_workspace, &c_id);\n }\n \n #[test]\n fn test_install_to_rust_path() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let second_workspace = create_local_package(&p_id);\n     let second_workspace = second_workspace.path();\n-    let first_workspace = mk_empty_workspace(&Path::new(\"p\"), &NoVersion, \"dest\");\n+    let none_id: CrateId = from_str(\"p\").unwrap();\n+    let first_workspace = mk_empty_workspace(&none_id, \"dest\");\n     let first_workspace = first_workspace.path();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let rust_path = Some(~[(~\"RUST_PATH\",\n@@ -1951,7 +1912,7 @@ fn test_install_to_rust_path() {\n \n #[test]\n fn test_target_specific_build_dir() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1967,7 +1928,7 @@ fn test_target_specific_build_dir() {\n \n #[test]\n fn test_target_specific_install_dir() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1977,7 +1938,7 @@ fn test_target_specific_install_dir() {\n                        ~\"foo\"],\n                       workspace);\n     assert!(workspace.join_many([~\"lib\", host_triple()]).is_dir());\n-    assert_lib_exists(workspace, &Path::new(\"foo\"), NoVersion);\n+    assert_lib_exists(workspace, &p_id);\n     assert!(fs::readdir(&workspace.join(\"lib\")).len() == 1);\n     assert!(workspace.join(\"bin\").is_dir());\n     assert_executable_exists(workspace, \"foo\");\n@@ -1986,7 +1947,7 @@ fn test_target_specific_install_dir() {\n #[test]\n #[ignore(reason = \"See #7240\")]\n fn test_dependencies_terminate() {\n-    let b_id = CrateId::new(\"b\");\n+    let b_id: CrateId = from_str(\"b\").unwrap();\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n     let b_dir = workspace.join_many([\"src\", \"b-0.0\"]);\n@@ -1999,42 +1960,42 @@ fn test_dependencies_terminate() {\n \n #[test]\n fn install_after_build() {\n-    let b_id = CrateId::new(\"b\");\n+    let b_id: CrateId = from_str(\"b\").unwrap();\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"b\"], workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b_id.short_name);\n-    assert_lib_exists(workspace, &b_id.path, NoVersion);\n+    assert_executable_exists(workspace, b_id.name);\n+    assert_lib_exists(workspace, &b_id);\n }\n \n #[test]\n fn reinstall() {\n-    let b = CrateId::new(\"b\");\n+    let b: CrateId = from_str(\"b\").unwrap();\n     let workspace = create_local_package(&b);\n     let workspace = workspace.path();\n     // 1. Install, then remove executable file, then install again,\n     // and make sure executable was re-installed\n     command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b.short_name);\n-    assert_lib_exists(workspace, &b.path, NoVersion);\n+    assert_executable_exists(workspace, b.name);\n+    assert_lib_exists(workspace, &b);\n     remove_executable_file(&b, workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b.short_name);\n+    assert_executable_exists(workspace, b.name);\n     // 2. Build, then remove build executable file, then build again,\n     // and make sure executable was re-built.\n     command_line_test([~\"build\", ~\"b\"], workspace);\n     remove_built_executable_file(&b, workspace);\n     command_line_test([~\"build\", ~\"b\"], workspace);\n-    assert_built_executable_exists(workspace, b.short_name);\n+    assert_built_executable_exists(workspace, b.name);\n     // 3. Install, then remove both executable and built executable,\n     // then install again, make sure both were recreated\n     command_line_test([~\"install\", ~\"b\"], workspace);\n     remove_executable_file(&b, workspace);\n     remove_built_executable_file(&b, workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b.short_name);\n-    assert_built_executable_exists(workspace, b.short_name);\n+    assert_executable_exists(workspace, b.name);\n+    assert_built_executable_exists(workspace, b.name);\n }\n \n #[test]\n@@ -2049,11 +2010,11 @@ fn correct_package_name_with_rust_path_hack() {\n     */\n \n     // Set RUST_PATH to something containing only the sources for foo\n-    let foo_id = CrateId::new(\"foo\");\n-    let bar_id = CrateId::new(\"bar\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n     let dest_workspace = dest_workspace.path();\n \n     writeFile(&dest_workspace.join_many([\"src\", \"bar-0.0\", \"main.rs\"]),\n@@ -2068,18 +2029,18 @@ fn correct_package_name_with_rust_path_hack() {\n                                   // FIXME #3408: Should be NONEXISTENT_PACKAGE_CODE\n                                dest_workspace, rust_path, COPY_FAILED_CODE);\n     assert!(!executable_exists(dest_workspace, \"bar\"));\n-    assert!(!lib_exists(dest_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n+    assert!(!lib_exists(dest_workspace, &bar_id));\n     assert!(!executable_exists(dest_workspace, \"foo\"));\n-    assert!(!lib_exists(dest_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n+    assert!(!lib_exists(dest_workspace, &foo_id));\n     assert!(!executable_exists(foo_workspace, \"bar\"));\n-    assert!(!lib_exists(foo_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n+    assert!(!lib_exists(foo_workspace, &bar_id));\n     assert!(!executable_exists(foo_workspace, \"foo\"));\n-    assert!(!lib_exists(foo_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n+    assert!(!lib_exists(foo_workspace, &foo_id));\n }\n \n #[test]\n fn test_rustpkg_test_creates_exec() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2090,7 +2051,8 @@ fn test_rustpkg_test_creates_exec() {\n \n #[test]\n fn test_rustpkg_test_output() {\n-    let workspace = create_local_package_with_test(&CrateId::new(\"foo\"));\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let workspace = create_local_package_with_test(&foo_id);\n     let output = command_line_test([~\"test\", ~\"foo\"], workspace.path());\n     let output_str = str::from_utf8(output.output).unwrap();\n     // The first two assertions are separate because test output may\n@@ -2102,7 +2064,7 @@ fn test_rustpkg_test_output() {\n \n #[test]\n fn test_rustpkg_test_failure_exit_status() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2116,7 +2078,7 @@ fn test_rustpkg_test_failure_exit_status() {\n \n #[test]\n fn test_rustpkg_test_cfg() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2129,7 +2091,7 @@ fn test_rustpkg_test_cfg() {\n \n #[test]\n fn test_rebuild_when_needed() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n@@ -2150,7 +2112,7 @@ fn test_rebuild_when_needed() {\n #[test]\n #[ignore] // FIXME (#10257): This doesn't work as is since a read only file can't execute\n fn test_no_rebuilding() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n@@ -2172,8 +2134,9 @@ fn test_no_rebuilding() {\n fn test_installed_read_only() {\n     // Install sources from a \"remote\" (actually a local github repo)\n     // Check that afterward, sources are read-only and installed under build/\n-    let mut temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&temp_pkg_id.path);\n+    let temp_pkg_id = git_repo_pkg();\n+    let path = Path::new(temp_pkg_id.path.as_slice());\n+    let repo = init_git_repo(&path);\n     let repo = repo.path();\n     debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n@@ -2183,12 +2146,11 @@ fn test_installed_read_only() {\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n+    add_git_tag(&repo_subdir, ~\"0.0\"); // this has the effect of committing the files\n     // update crateid to what will be auto-detected\n-    temp_pkg_id.version = ExactRevision(~\"0.1\");\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n+    command_line_test([~\"install\", temp_pkg_id.to_str()], repo);\n \n     let ws = repo.join(\".rust\");\n     // Check that all files exist\n@@ -2204,8 +2166,10 @@ fn test_installed_read_only() {\n     assert!(is_rwx(&built_lib));\n \n     // Make sure sources are (a) under \"build\" and (b) read-only\n-    let src1 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"main.rs\"]);\n-    let src2 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"lib.rs\"]);\n+    let temp_dir = format!(\"{}-{}\", temp_pkg_id.path, temp_pkg_id.version_or_default());\n+    let src1 = target_build_dir(&ws).join_many([~\"src\", temp_dir.clone(), ~\"main.rs\"]);\n+    let src2 = target_build_dir(&ws).join_many([~\"src\", temp_dir.clone(), ~\"lib.rs\"]);\n+    debug!(\"src1: {}\", src1.display());\n     assert!(src1.exists());\n     assert!(src2.exists());\n     assert!(is_read_only(&src1));\n@@ -2215,7 +2179,7 @@ fn test_installed_read_only() {\n #[test]\n fn test_installed_local_changes() {\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo = init_git_repo(&Path::new(temp_pkg_id.path.as_slice()));\n     let repo = repo.path();\n     debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n@@ -2228,9 +2192,7 @@ fn test_installed_local_changes() {\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n-\n+    command_line_test([~\"install\", temp_pkg_id.path.to_owned()], repo);\n \n     // We installed the dependency.\n     // Now start a new workspace and clone it into it\n@@ -2242,7 +2204,7 @@ fn test_installed_local_changes() {\n                                                   \"test-pkg-0.0\"]);\n     debug!(\"---- git clone {} {}\", repo_subdir.display(), target_dir.display());\n \n-    let c_res = safe_git_clone(&repo_subdir, &NoVersion, &target_dir);\n+    let c_res = safe_git_clone(&repo_subdir, &None, &target_dir);\n \n     match c_res {\n         DirToUse(_) => fail!(\"test_installed_local_changes failed\"),\n@@ -2262,14 +2224,13 @@ fn test_installed_local_changes() {\n               fn main() { g(); }\");\n     // And make sure we can build it\n \n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"build\", importer_pkg_id.path.as_str().unwrap().to_owned()],\n-                      hacking_workspace);\n+    command_line_test([~\"build\", importer_pkg_id.path.to_owned()], hacking_workspace);\n }\n \n #[test]\n fn test_7402() {\n-    let dir = create_local_package(&CrateId::new(\"foo\"));\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let dir = create_local_package(&foo_id);\n     let dest_workspace = TempDir::new(\"more_rust\").expect(\"test_7402\");\n     let dest_workspace = dest_workspace.path();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -2283,7 +2244,7 @@ fn test_7402() {\n \n #[test]\n fn test_compile_error() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let main_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]);\n@@ -2317,7 +2278,8 @@ fn test_c_dependency_ok() {\n     // registers a hook to build it if it's not fresh\n     // After running `build`, test that the C library built\n \n-    let dir = create_local_package(&CrateId::new(\"cdep\"));\n+    let cdep_id: CrateId = from_str(\"cdep\").unwrap();\n+    let dir = create_local_package(&cdep_id);\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2340,7 +2302,8 @@ fn test_c_dependency_ok() {\n #[test]\n #[ignore(reason=\"busted\")]\n fn test_c_dependency_no_rebuilding() {\n-    let dir = create_local_package(&CrateId::new(\"cdep\"));\n+    let cdep_id: CrateId = from_str(\"cdep\").unwrap();\n+    let dir = create_local_package(&cdep_id);\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2374,7 +2337,8 @@ fn test_c_dependency_no_rebuilding() {\n #[test]\n #[ignore(reason=\"busted\")]\n fn test_c_dependency_yes_rebuilding() {\n-    let dir = create_local_package(&CrateId::new(\"cdep\"));\n+    let cdep_id: CrateId = from_str(\"cdep\").unwrap();\n+    let dir = create_local_package(&cdep_id);\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2395,7 +2359,7 @@ fn test_c_dependency_yes_rebuilding() {\n     assert!(c_library_path.exists());\n \n     // Now, make the Rust library read-only so rebuilding will fail\n-    match built_library_in_workspace(&CrateId::new(\"cdep\"), dir) {\n+    match built_library_in_workspace(&cdep_id, dir) {\n         Some(ref pth) => assert!(chmod_read_only(pth)),\n         None => assert_built_library_exists(dir, \"cdep\")\n     }\n@@ -2413,7 +2377,8 @@ fn test_c_dependency_yes_rebuilding() {\n fn correct_error_dependency() {\n     // Supposing a package we're trying to install via a dependency doesn't\n     // exist, we should throw a condition, and not ICE\n-    let workspace_dir = create_local_package(&CrateId::new(\"badpkg\"));\n+    let crate_id: CrateId = from_str(\"badpkg\").unwrap();\n+    let workspace_dir = create_local_package(&crate_id);\n \n     let dir = workspace_dir.path();\n     let main_rs = dir.join_many([\"src\", \"badpkg-0.0\", \"main.rs\"]);"}, {"sha": "b6dba40ebd46aed7600e3d4b7053116c8ec355cb", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -13,7 +13,7 @@ extern mod rustc;\n \n use std::{os, task};\n use rustpkg::api;\n-use rustpkg::version::NoVersion;\n+use rustpkg::version::None;\n use rustpkg::workcache_support::digest_file_with_date;\n use rustpkg::exit_codes::COPY_FAILED_CODE;\n \n@@ -73,7 +73,7 @@ pub fn main() {\n         api::install_pkg(&mut cc,\n                          os::getcwd(),\n                          ~\"cdep\",\n-                         NoVersion,\n+                         None,\n                          ~[(~\"binary\", out_lib_path.clone()), (~\"file\", foo_c_name.clone())]);\n     };\n "}, {"sha": "7b1291025e40b222ae51f7195943b651a606586b", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -14,7 +14,7 @@ extern mod rustc;\n use std::os;\n use std::io::File;\n use rustpkg::api;\n-use rustpkg::version::NoVersion;\n+use rustpkg::version::None;\n \n pub fn main() {\n     let args = os::args();\n@@ -48,5 +48,5 @@ pub fn main() {\n                 for _ in xs.iter() { assert!(true); } }\".as_bytes());\n \n     let context = api::default_context(sysroot, api::default_workspace());\n-    api::install_pkg(&context, os::getcwd(), ~\"fancy-lib\", NoVersion, ~[]);\n+    api::install_pkg(&context, os::getcwd(), ~\"fancy-lib\", None, ~[]);\n }"}, {"sha": "9042dfea2562e0a1aa518cdd64ead7af778d30c2", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -10,14 +10,18 @@\n \n #[allow(dead_code)];\n \n+pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n+pub use target::{Target, Build, Install};\n+pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n+\n use std::cell::RefCell;\n use std::libc;\n use std::os;\n use std::io;\n use std::io::fs;\n use extra::workcache;\n use rustc::metadata::creader::Loader;\n-use rustc::driver::{driver, session};\n+use extra::treemap::TreeMap;\n use extra::getopts::groups::getopts;\n use syntax;\n use syntax::codemap::{DUMMY_SP, Spanned};\n@@ -28,19 +32,16 @@ use syntax::attr::AttrMetaMethods;\n use syntax::fold::Folder;\n use syntax::visit::Visitor;\n use syntax::util::small_vector::SmallVector;\n+use syntax::crateid::CrateId;\n use rustc::back::link::OutputTypeExe;\n use rustc::back::link;\n+use rustc::driver::{driver, session};\n use CtxMethods;\n use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n-use crate_id::CrateId;\n use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n use path_util::{system_library, target_build_dir};\n use path_util::{default_workspace, built_library_in_workspace};\n-pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n-pub use target::{Target, Build, Install};\n-use extra::treemap::TreeMap;\n-pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n use workcache_support::{digest_file_with_date, digest_only_date};\n use messages::error;\n \n@@ -135,7 +136,7 @@ struct CrateSetup<'a> {\n     ctx: &'a mut ReadyCtx<'a>,\n }\n \n-impl<'a> fold::Folder for CrateSetup<'a> {\n+impl<'a> Folder for CrateSetup<'a> {\n     fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n         fold_item(item, self)\n     }\n@@ -162,7 +163,7 @@ pub fn ready_crate(sess: session::Session,\n \n pub fn compile_input(context: &BuildContext,\n                      exec: &mut workcache::Exec,\n-                     pkg_id: &CrateId,\n+                     crate_id: &CrateId,\n                      in_file: &Path,\n                      workspace: &Path,\n                      deps: &mut DepMap,\n@@ -177,11 +178,11 @@ pub fn compile_input(context: &BuildContext,\n     // not sure if we should support anything else\n \n     let mut out_dir = target_build_dir(workspace);\n-    out_dir.push(&pkg_id.path);\n+    out_dir.push(crate_id.path.as_slice());\n     // Make the output directory if it doesn't exist already\n     fs::mkdir_recursive(&out_dir, io::UserRWX);\n \n-    let binary = os::args()[0].to_owned();\n+    let binary = os::args()[0];\n \n     debug!(\"flags: {}\", flags.connect(\" \"));\n     debug!(\"cfgs: {}\", cfgs.connect(\" \"));\n@@ -276,7 +277,7 @@ pub fn compile_input(context: &BuildContext,\n     let (mut crate, ast_map) = {\n         let installer = CrateInstaller {\n             context: context,\n-            parent: pkg_id,\n+            parent: crate_id,\n             parent_crate: in_file,\n             sess: sess,\n             exec: exec,\n@@ -312,10 +313,7 @@ pub fn compile_input(context: &BuildContext,\n     if !attr::contains_name(crate.attrs, \"crate_id\") {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let crateid_attr =\n-            attr::mk_name_value_item_str(@\"crate_id\",\n-                                         format!(\"{}\\\\#{}\",\n-                                                 pkg_id.path.as_str().unwrap(),\n-                                                 pkg_id.version.to_str()).to_managed());\n+            attr::mk_name_value_item_str(@\"crate_id\", crate_id.to_str().to_managed());\n \n         debug!(\"crateid attr: {:?}\", crateid_attr);\n         crate.attrs.push(attr::mk_attr(crateid_attr));\n@@ -333,7 +331,7 @@ pub fn compile_input(context: &BuildContext,\n                                           what);\n     // Discover the output\n     let discovered_output = if what == Lib  {\n-        built_library_in_workspace(pkg_id, workspace) // Huh???\n+        built_library_in_workspace(crate_id, workspace) // Huh???\n     }\n     else {\n         result\n@@ -435,7 +433,7 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n // Called by build_crates\n pub fn compile_crate(ctxt: &BuildContext,\n                      exec: &mut workcache::Exec,\n-                     pkg_id: &CrateId,\n+                     crate_id: &CrateId,\n                      crate: &Path,\n                      workspace: &Path,\n                      deps: &mut DepMap,\n@@ -444,11 +442,11 @@ pub fn compile_crate(ctxt: &BuildContext,\n                      opt: session::OptLevel,\n                      what: OutputType) -> Option<Path> {\n     debug!(\"compile_crate: crate={}, workspace={}\", crate.display(), workspace.display());\n-    debug!(\"compile_crate: short_name = {}, flags =...\", pkg_id.to_str());\n+    debug!(\"compile_crate: name = {}, flags =...\", crate_id.to_str());\n     for fl in flags.iter() {\n         debug!(\"+++ {}\", *fl);\n     }\n-    compile_input(ctxt, exec, pkg_id, crate, workspace, deps, flags, cfgs, opt, what)\n+    compile_input(ctxt, exec, crate_id, crate, workspace, deps, flags, cfgs, opt, what)\n }\n \n struct CrateInstaller<'a> {\n@@ -473,8 +471,9 @@ impl<'a> CrateInstaller<'a> {\n                     None => self.sess.str_of(lib_ident)\n                 };\n                 debug!(\"Finding and installing... {}\", lib_name);\n+                let crate_id: CrateId = from_str(lib_name).expect(\"valid crate id\");\n                 // Check standard Rust library path first\n-                let whatever = system_library(&self.context.sysroot_to_use(), lib_name);\n+                let whatever = system_library(&self.context.sysroot_to_use(), &crate_id);\n                 debug!(\"system library returned {:?}\", whatever);\n                 match whatever {\n                     Some(ref installed_path) => {\n@@ -494,13 +493,11 @@ impl<'a> CrateInstaller<'a> {\n                     }\n                     None => {\n                         // FIXME #8711: need to parse version out of path_opt\n-                        debug!(\"Trying to install library {}, rebuilding it\",\n-                               lib_name.to_str());\n+                        debug!(\"Trying to install library {}, rebuilding it\", crate_id.to_str());\n                         // Try to install it\n-                        let pkg_id = CrateId::new(lib_name);\n                         // Find all the workspaces in the RUST_PATH that contain this package.\n                         let workspaces = pkg_parent_workspaces(&self.context.context,\n-                                                               &pkg_id);\n+                                                               &crate_id);\n                         // Three cases:\n                         // (a) `workspaces` is empty. That means there's no local source\n                         // for this package. In that case, we pass the default workspace\n@@ -529,16 +526,16 @@ impl<'a> CrateInstaller<'a> {\n                                  // Nonexistent package? Then print a better error\n                                  error(format!(\"Package {} depends on {}, but I don't know \\\n                                                how to find it\",\n-                                               self.parent.path.display(),\n-                                               pkg_id.path.display()));\n+                                               self.parent.path,\n+                                               crate_id.path));\n                                  fail!()\n                         }).inside(|| {\n                             PkgSrc::new(source_workspace.clone(),\n                                         dest_workspace.clone(),\n                                         // Use the rust_path_hack to search for dependencies iff\n                                         // we were already using it\n                                         self.context.context.use_rust_path_hack,\n-                                        pkg_id.clone())\n+                                        crate_id.clone())\n                         });\n                         let (outputs_disc, inputs_disc) =\n                             self.context.install("}, {"sha": "93e7a052efa06d9bf29917e18968f3d6fee7ab22", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 10, "deletions": 177, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -13,170 +13,9 @@\n \n extern mod std;\n \n-use extra::semver;\n-use std::{char, result, run, str};\n-use extra::tempfile::TempDir;\n-use path_util::rust_path;\n+use std::char;\n \n-#[deriving(Clone)]\n-pub enum Version {\n-    ExactRevision(~str), // Should look like a m.n.(...).x\n-    SemanticVersion(semver::Version),\n-    Tagged(~str), // String that can't be parsed as a version.\n-                  // Requirements get interpreted exactly\n-    NoVersion // user didn't specify a version -- prints as 0.0\n-}\n-\n-// Equality on versions is non-symmetric: if self is NoVersion, it's equal to\n-// anything; but if self is a precise version, it's not equal to NoVersion.\n-// We should probably make equality symmetric, and use less-than and greater-than\n-// where we currently use eq\n-impl Eq for Version {\n-    fn eq(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(ref s1), &ExactRevision(ref s2)) => *s1 == *s2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => *v1 == *v2,\n-            (&NoVersion, _) => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-impl Ord for Version {\n-    fn lt(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&NoVersion, _) => true,\n-            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 < f2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 < v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn le(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&NoVersion, _) => true,\n-            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 <= f2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 <= v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn ge(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 > f2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 > v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn gt(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 >= f2,\n-            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 >= v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-\n-}\n-\n-impl ToStr for Version {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            ExactRevision(ref n) | Tagged(ref n) => format!(\"{}\", n.to_str()),\n-            SemanticVersion(ref v) => format!(\"{}\", v.to_str()),\n-            NoVersion => ~\"0.0\"\n-        }\n-    }\n-}\n-\n-pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n-    match semver::parse(vers) {\n-        Some(vers) => result::Ok(vers),\n-        None => result::Err(~\"could not parse version: invalid\")\n-    }\n-}\n-\n-/// If `local_path` is a git repo in the RUST_PATH, and the most recent tag\n-/// in that repo denotes a version, return it; otherwise, `None`\n-pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n-    let rustpath = rust_path();\n-    for rp in rustpath.iter() {\n-        let local_path = rp.join(local_path);\n-        let git_dir = local_path.join(\".git\");\n-        if !git_dir.is_dir() {\n-            continue;\n-        }\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let opt_outp = run::process_output(\"git\",\n-                                   [\"--git-dir=\" + git_dir.as_str().unwrap(), ~\"tag\", ~\"-l\"]);\n-        let outp = opt_outp.expect(\"Failed to exec `git`\");\n-\n-        debug!(\"git --git-dir={} tag -l ~~~> {:?}\", git_dir.display(), outp.status);\n-\n-        if !outp.status.success() {\n-            continue;\n-        }\n-\n-        let mut output = None;\n-        let output_text = str::from_utf8(outp.output).unwrap();\n-        for l in output_text.lines() {\n-            if !l.is_whitespace() {\n-                output = Some(l);\n-            }\n-            match output.and_then(try_parsing_version) {\n-                Some(v) => return Some(v),\n-                None    => ()\n-            }\n-        }\n-    }\n-    None\n-}\n-\n-/// If `remote_path` refers to a git repo that can be downloaded,\n-/// and the most recent tag in that repo denotes a version, return it;\n-/// otherwise, `None`\n-pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n-    if is_url_like(remote_path) {\n-        let tmp_dir = TempDir::new(\"test\");\n-        let tmp_dir = tmp_dir.expect(\"try_getting_version: couldn't create temp dir\");\n-        let tmp_dir = tmp_dir.path();\n-        debug!(\"(to get version) executing \\\\{git clone https://{} {}\\\\}\",\n-               remote_path.display(),\n-               tmp_dir.display());\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let opt_outp = run::process_output(\"git\", [~\"clone\", format!(\"https://{}\",\n-                                                                     remote_path.as_str().unwrap()),\n-                                                   tmp_dir.as_str().unwrap().to_owned()]);\n-        let outp = opt_outp.expect(\"Failed to exec `git`\");\n-        if outp.status.success() {\n-            debug!(\"Cloned it... ( {}, {} )\",\n-                   str::from_utf8(outp.output).unwrap(),\n-                   str::from_utf8(outp.error).unwrap());\n-            let mut output = None;\n-            let git_dir = tmp_dir.join(\".git\");\n-            debug!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n-                   git_dir.display());\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            let opt_outp = run::process_output(\"git\",\n-                                               [\"--git-dir=\" + git_dir.as_str().unwrap(),\n-                                                ~\"tag\", ~\"-l\"]);\n-            let outp = opt_outp.expect(\"Failed to exec `git`\");\n-            let output_text = str::from_utf8(outp.output).unwrap();\n-            debug!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n-            for l in output_text.lines() {\n-                debug!(\"A line of output: {}\", l);\n-                if !l.is_whitespace() {\n-                    output = Some(l);\n-                }\n-            }\n-\n-            output.and_then(try_parsing_version)\n-        }\n-        else {\n-            None\n-        }\n-    }\n-    else {\n-        None\n-    }\n-}\n+pub type Version = Option<~str>;\n \n // Being lazy since we don't have a regexp library now\n #[deriving(Eq)]\n@@ -186,7 +25,7 @@ enum ParseState {\n     SawDot\n }\n \n-pub fn try_parsing_version(s: &str) -> Option<Version> {\n+pub fn try_parsing_version(s: &str) -> Option<~str> {\n     let s = s.trim();\n     debug!(\"Attempting to parse: {}\", s);\n     let mut parse_state = Start;\n@@ -202,17 +41,11 @@ pub fn try_parsing_version(s: &str) -> Option<Version> {\n         }\n     }\n     match parse_state {\n-        SawDigit => Some(ExactRevision(s.to_owned())),\n+        SawDigit => Some(s.to_owned()),\n         _        => None\n     }\n }\n \n-/// Just an approximation\n-fn is_url_like(p: &Path) -> bool {\n-    // check if there are more than 2 /-separated components\n-    p.as_vec().split(|b| *b == '/' as u8).nth(2).is_some()\n-}\n-\n /// If s is of the form foo#bar, where bar is a valid version\n /// number, return the prefix before the # and the version.\n /// Otherwise, return None.\n@@ -229,7 +62,7 @@ pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Vers\n         Some(i) => {\n             let path = s.slice(0, i);\n             // n.b. for now, assuming an exact revision is intended, not a SemVer\n-            Some((path, ExactRevision(s.slice(i + 1, s.len()).to_owned())))\n+            Some((path, Some(s.slice(i + 1, s.len()).to_owned())))\n         }\n         None => {\n             None\n@@ -239,11 +72,11 @@ pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Vers\n \n #[test]\n fn test_parse_version() {\n-    assert!(try_parsing_version(\"1.2\") == Some(ExactRevision(~\"1.2\")));\n-    assert!(try_parsing_version(\"1.0.17\") == Some(ExactRevision(~\"1.0.17\")));\n+    assert!(try_parsing_version(\"1.2\") == Some(~\"1.2\"));\n+    assert!(try_parsing_version(\"1.0.17\") == Some(~\"1.0.17\"));\n     assert!(try_parsing_version(\"you're_a_kitty\") == None);\n     assert!(try_parsing_version(\"42..1\") == None);\n-    assert!(try_parsing_version(\"17\") == Some(ExactRevision(~\"17\")));\n+    assert!(try_parsing_version(\"17\") == Some(~\"17\"));\n     assert!(try_parsing_version(\".1.2.3\") == None);\n     assert!(try_parsing_version(\"2.3.\") == None);\n }\n@@ -252,9 +85,9 @@ fn test_parse_version() {\n fn test_split_version() {\n     let s = \"a/b/c#0.1\";\n     debug!(\"== {:?} ==\", split_version(s));\n-    assert!(split_version(s) == Some((s.slice(0, 5), ExactRevision(~\"0.1\"))));\n+    assert!(split_version(s) == Some((s.slice(0, 5), Some(~\"0.1\"))));\n     assert!(split_version(\"a/b/c\") == None);\n     let s = \"a#1.2\";\n-    assert!(split_version(s) == Some((s.slice(0, 1), ExactRevision(~\"1.2\"))));\n+    assert!(split_version(s) == Some((s.slice(0, 1), Some(~\"1.2\"))));\n     assert!(split_version(\"a#a#3.4\") == None);\n }"}, {"sha": "e19a19dc8ab6addaae34142a44a487bd7e6fec00", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -11,12 +11,11 @@\n // rustpkg utilities having to do with workspaces\n \n use std::os;\n-use std::path::Path;\n use context::Context;\n use path_util::{workspace_contains_crate_id, find_dir_using_rust_path_hack, default_workspace};\n use path_util::rust_path;\n use util::option_to_vec;\n-use crate_id::CrateId;\n+use syntax::crateid::CrateId;\n \n pub fn each_pkg_parent_workspace(cx: &Context,\n                                  crateid: &CrateId,\n@@ -29,7 +28,7 @@ pub fn each_pkg_parent_workspace(cx: &Context,\n         // tjc: make this a condition\n         fail!(\"Package {} not found in any of \\\n                     the following workspaces: {}\",\n-                   crateid.path.display(),\n+                   crateid.path,\n                    rust_path().map(|p| p.display().to_str()).to_str());\n     }\n     for ws in workspaces.iter() {\n@@ -64,7 +63,8 @@ pub fn cwd_to_workspace() -> Option<(Path, CrateId)> {\n             let rel = cwd.path_relative_from(&srcpath);\n             let rel_s = rel.as_ref().and_then(|p|p.as_str());\n             if rel_s.is_some() {\n-                return Some((path, CrateId::new(rel_s.unwrap())));\n+                let crate_id = from_str(rel_s.unwrap()).expect(\"valid crate id\");\n+                return Some((path, crate_id));\n             }\n         }\n     }"}, {"sha": "0831f319ce7b9f9fac92ac17c3fa6027c50ffff9", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b62371c205d408cf5a833d12dc937012047a506/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=2b62371c205d408cf5a833d12dc937012047a506", "patch": "@@ -70,7 +70,11 @@ impl FromStr for CrateId {\n             };\n \n             let version = if !hash_version.is_empty() {\n-                Some(hash_version.to_owned())\n+                if hash_version == \"0.0\" {\n+                    None\n+                } else {\n+                    Some(hash_version.to_owned())\n+                }\n             } else {\n                 None\n             };\n@@ -93,6 +97,10 @@ impl CrateId {\n             Some(ref version) => version.as_slice(),\n         }\n     }\n+\n+    pub fn short_name_with_version(&self) -> ~str {\n+        format!(\"{}-{}\", self.name, self.version_or_default())\n+    }\n }\n \n #[test]"}]}