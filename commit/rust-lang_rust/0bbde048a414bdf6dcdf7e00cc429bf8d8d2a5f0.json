{"sha": "0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYmRlMDQ4YTQxNGJkZjZkY2RmN2UwMGNjNDI5YmY4ZDhkMmE1ZjA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-23T09:01:09Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-23T09:11:37Z"}, "message": "Make sure no dynamic allocas are used before they are allocated\n\nCloses #965", "tree": {"sha": "29b3c6e7841c141d535076aa9bd49d0bf37c26cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29b3c6e7841c141d535076aa9bd49d0bf37c26cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0", "html_url": "https://github.com/rust-lang/rust/commit/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49813cffb12d00886bfd3d3a1a027deafad49bbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/49813cffb12d00886bfd3d3a1a027deafad49bbd", "html_url": "https://github.com/rust-lang/rust/commit/49813cffb12d00886bfd3d3a1a027deafad49bbd"}], "stats": {"total": 65, "additions": 29, "deletions": 36}, "files": [{"sha": "e5736071060de08868c6e29bc66c395583ced629", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0", "patch": "@@ -1186,17 +1186,17 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n \n     let ty_param_count = std::vec::len::<uint>(ty_params);\n     let lltyparams = llvm::LLVMGetParam(llfn, 3u);\n-    let copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n+    let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n     let lltydescs = [mutable];\n     let p = 0u;\n     while p < ty_param_count {\n-        let llparam = GEP(copy_args_bcx, lltyparams, [C_int(p as int)]);\n-        llparam = Load(copy_args_bcx, llparam);\n+        let llparam = GEP(load_env_bcx, lltyparams, [C_int(p as int)]);\n+        llparam = Load(load_env_bcx, llparam);\n         std::vec::grow_set(lltydescs, ty_params[p], 0 as ValueRef, llparam);\n         p += 1u;\n     }\n \n-    // TODO: Implement some kind of freeze operation in the standard library.\n+    // FIXME: Implement some kind of freeze operation in the standard library.\n     let lltydescs_frozen = [];\n     for lltydesc: ValueRef in lltydescs { lltydescs_frozen += [lltydesc]; }\n     fcx.lltydescs = lltydescs_frozen;\n@@ -2653,7 +2653,7 @@ fn find_environment_tydescs(bcx: @block_ctxt, envty: ty::t, closure: ValueRef)\n // with the upvars and type descriptors.\n fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n                     upvars: @[ast::def], copying: bool) {\n-    let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n+    let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n \n     let ty = ty::mk_imm_box(bcx_tcx(bcx), envty);\n \n@@ -3322,8 +3322,8 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     // Since we might need to construct derived tydescs that depend on\n     // our bound tydescs, we need to load tydescs out of the environment\n     // before derived tydescs are constructed. To do this, we load them\n-    // in the copy_args block.\n-    let copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n+    // in the load_env block.\n+    let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n \n     // The 'llenv' that will arrive in the thunk we're creating is an\n     // environment that will contain the values of its arguments and a pointer\n@@ -3336,7 +3336,7 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     // (Issue #586)\n     check (type_has_static_size(ccx, closure_ty));\n     let llclosure_ptr_ty = type_of(ccx, sp, closure_ty);\n-    let llclosure = PointerCast(copy_args_bcx, fcx.llenv, llclosure_ptr_ty);\n+    let llclosure = PointerCast(load_env_bcx, fcx.llenv, llclosure_ptr_ty);\n \n     // \"target\", in this context, means the function that's having some of its\n     // arguments bound and that will be called inside the thunk we're\n@@ -3388,13 +3388,13 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     let i: uint = 0u;\n     while i < ty_param_count {\n         // Silly check\n-        check type_is_tup_like(copy_args_bcx, closure_ty);\n+        check type_is_tup_like(load_env_bcx, closure_ty);\n         let lltyparam_ptr =\n-            GEP_tup_like(copy_args_bcx, closure_ty, llclosure,\n+            GEP_tup_like(load_env_bcx, closure_ty, llclosure,\n                          [0, abi::box_rc_field_body,\n                           abi::closure_elt_ty_params, i as int]);\n-        copy_args_bcx = lltyparam_ptr.bcx;\n-        let td = Load(copy_args_bcx, lltyparam_ptr.val);\n+        load_env_bcx = lltyparam_ptr.bcx;\n+        let td = Load(load_env_bcx, lltyparam_ptr.val);\n         llargs += [td];\n         fcx.lltydescs += [td];\n         i += 1u;\n@@ -4972,7 +4972,7 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n              str::as_buf(\"static_allocas\",\n                          {|buf| llvm::LLVMAppendBasicBlock(llfn, buf) }),\n          ca:\n-             str::as_buf(\"copy_args\",\n+             str::as_buf(\"load_env\",\n                          {|buf| llvm::LLVMAppendBasicBlock(llfn, buf) }),\n          dt:\n              str::as_buf(\"derived_tydescs\",\n@@ -5001,7 +5001,7 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n           llenv: llvm::LLVMGetParam(llfndecl, 2u),\n           llretptr: llvm::LLVMGetParam(llfndecl, 0u),\n           mutable llstaticallocas: llbbs.sa,\n-          mutable llcopyargs: llbbs.ca,\n+          mutable llloadenv: llbbs.ca,\n           mutable llderivedtydescs_first: llbbs.dt,\n           mutable llderivedtydescs: llbbs.dt,\n           mutable lldynamicallocas: llbbs.da,\n@@ -5082,10 +5082,9 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, proto: ast::proto,\n     }\n }\n \n-fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt, args: [ast::arg],\n-                        arg_tys: [ty::arg], ignore_mut: bool) {\n-    let llcopyargs = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n-    let bcx = llcopyargs;\n+fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n+                        arg_tys: [ty::arg], ignore_mut: bool)\n+    -> @block_ctxt {\n     let arg_n: uint = 0u;\n     for aarg: ast::arg in args {\n         let arg_ty = arg_tys[arg_n].ty;\n@@ -5097,23 +5096,23 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt, args: [ast::arg],\n             // Overwrite the llargs entry for locally mutated params\n             // with a local alloca.\n             if mutated {\n-                let aptr = bcx.fcx.llargs.get(aarg.id);\n+                let aptr = fcx.llargs.get(aarg.id);\n                 let {bcx: bcx, val: alloc} = alloc_ty(bcx, arg_ty);\n                 bcx =\n                     copy_val(bcx, INIT, alloc,\n                              load_if_immediate(bcx, aptr, arg_ty), arg_ty);\n-                bcx.fcx.llargs.insert(aarg.id, alloc);\n-                add_clean(scope, alloc, arg_ty);\n+                fcx.llargs.insert(aarg.id, alloc);\n+                add_clean(bcx, alloc, arg_ty);\n             }\n           }\n           ast::by_move. {\n-            add_clean(scope, bcx.fcx.llargs.get(aarg.id), arg_ty);\n+            add_clean(bcx, fcx.llargs.get(aarg.id), arg_ty);\n           }\n           _ { }\n         }\n         arg_n += 1u;\n     }\n-    fcx.llcopyargs = llcopyargs.llbb;\n+    ret bcx;\n }\n \n fn arg_tys_of_fn(ccx: @crate_ctxt, id: ast::node_id) -> [ty::arg] {\n@@ -5170,11 +5169,11 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n }\n \n \n-// Ties up the llstaticallocas -> llcopyargs -> llderivedtydescs ->\n+// Ties up the llstaticallocas -> llloadenv -> llderivedtydescs ->\n // lldynamicallocas -> lltop edges, and builds the return block.\n fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n-    Br(new_raw_block_ctxt(fcx, fcx.llstaticallocas), fcx.llcopyargs);\n-    Br(new_raw_block_ctxt(fcx, fcx.llcopyargs), fcx.llderivedtydescs_first);\n+    Br(new_raw_block_ctxt(fcx, fcx.llstaticallocas), fcx.llloadenv);\n+    Br(new_raw_block_ctxt(fcx, fcx.llloadenv), fcx.llderivedtydescs_first);\n     Br(new_raw_block_ctxt(fcx, fcx.llderivedtydescs), fcx.lldynamicallocas);\n     Br(new_raw_block_ctxt(fcx, fcx.lldynamicallocas), lltop);\n \n@@ -5210,7 +5209,7 @@ fn trans_closure(bcx_maybe: option::t<@block_ctxt>,\n     let block_ty = node_id_type(cx.ccx, f.body.node.id);\n \n     let arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n-    copy_args_to_allocas(fcx, bcx, f.decl.inputs, arg_tys, false);\n+    bcx = copy_args_to_allocas(fcx, bcx, f.decl.inputs, arg_tys, false);\n \n     // Figure out if we need to build a closure and act accordingly\n     let res =\n@@ -5362,8 +5361,8 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     }\n     let arg_tys = arg_tys_of_fn(cx.ccx, variant.node.id);\n     let bcx = new_top_block_ctxt(fcx);\n-    copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n     let lltop = bcx.llbb;\n+    bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n \n     // Cast the tag to a type we can GEP into.\n     let llblobptr ="}, {"sha": "b0c64b1d474f8689673b770461ead3e960e4c8cb", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0", "patch": "@@ -183,12 +183,6 @@ type fn_ctxt =\n     // after llderivedtydescs, because these sometimes depend on\n     // information computed from derived tydescs.\n \n-    // FIXME: Is llcopyargs actually the block containing the allocas\n-    // for incoming function arguments?  Or is it merely the block\n-    // containing code that copies incoming args to space already\n-    // alloca'd by code in llallocas?\n-\n-\n     // The token used to clear the dynamic allocas at the end of this frame.\n \n     // The 'self' object currently in use in this function, if there\n@@ -245,7 +239,7 @@ type fn_ctxt =\n      llenv: ValueRef,\n      llretptr: ValueRef,\n      mutable llstaticallocas: BasicBlockRef,\n-     mutable llcopyargs: BasicBlockRef,\n+     mutable llloadenv: BasicBlockRef,\n      mutable llderivedtydescs_first: BasicBlockRef,\n      mutable llderivedtydescs: BasicBlockRef,\n      mutable lldynamicallocas: BasicBlockRef,"}, {"sha": "01f7eec58733f7cce2e422eb001cb901227cb7f1", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=0bbde048a414bdf6dcdf7e00cc429bf8d8d2a5f0", "patch": "@@ -55,7 +55,7 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n                               ty_params);\n     let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n-    copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n+    bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n \n     // Pick up the type of this object by looking at our own output type, that\n     // is, the output type of the object constructor we're building."}]}