{"sha": "76c68dbefe1af573967cb3a4338c40ff61119144", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YzY4ZGJlZmUxYWY1NzM5NjdjYjNhNDMzOGM0MGZmNjExMTkxNDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-07T11:03:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-07T11:03:49Z"}, "message": "Merge #6167\n\n6167: Add comparisons guideline to style r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "29c6fdbc4e8a1c313886c8690585d21799ed43c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29c6fdbc4e8a1c313886c8690585d21799ed43c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76c68dbefe1af573967cb3a4338c40ff61119144", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJffaCVCRBK7hj4Ov3rIwAAdHIIAKSVkMymLcmoVGwet58Z3Jnc\nr066OEJFkfKhIOl28mYpbguJaR0aDkjAPi0Uo6IiVdVlnwAcp0351+DTb6SlVHlc\npcIz2EyHQ2lb2j88LWv9yLNP7M3KLq+oY+FxuMAKcIf47upgtocWDKdxuLCoKYsj\nyWO5Dfz4fFaz61EKyjZTO+mbG4A1+5YT5xLdBTcraUJ8EMdmlZMlRhwOJ/VHm/Op\nRpUayaahIZ9UeinLpvwRQ1u6PvJ2/1xa0cHmHTbFPrbWO3p1e3ipW0EVQjuPREpK\niarbVBQq4qgykgEe8SFGYX/7JlxhhjcvTXGRO8uefGdprjXOSwocJw4VRRCI/j0=\n=wHGK\n-----END PGP SIGNATURE-----\n", "payload": "tree 29c6fdbc4e8a1c313886c8690585d21799ed43c2\nparent 2aa46034c2eeb3d994b2760878ac1969487542e3\nparent 1688e481b31e0f67fba72beee4079adb6b95f83c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1602068629 +0000\ncommitter GitHub <noreply@github.com> 1602068629 +0000\n\nMerge #6167\n\n6167: Add comparisons guideline to style r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76c68dbefe1af573967cb3a4338c40ff61119144", "html_url": "https://github.com/rust-lang/rust/commit/76c68dbefe1af573967cb3a4338c40ff61119144", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76c68dbefe1af573967cb3a4338c40ff61119144/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2aa46034c2eeb3d994b2760878ac1969487542e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa46034c2eeb3d994b2760878ac1969487542e3", "html_url": "https://github.com/rust-lang/rust/commit/2aa46034c2eeb3d994b2760878ac1969487542e3"}, {"sha": "1688e481b31e0f67fba72beee4079adb6b95f83c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1688e481b31e0f67fba72beee4079adb6b95f83c", "html_url": "https://github.com/rust-lang/rust/commit/1688e481b31e0f67fba72beee4079adb6b95f83c"}], "stats": {"total": 388, "additions": 210, "deletions": 178}, "files": [{"sha": "7aed7816ec9a004e2fa3e62ce50d7a04c97e82cf", "filename": "docs/dev/style.md", "status": "modified", "additions": 210, "deletions": 178, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/76c68dbefe1af573967cb3a4338c40ff61119144/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/76c68dbefe1af573967cb3a4338c40ff61119144/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=76c68dbefe1af573967cb3a4338c40ff61119144", "patch": "@@ -6,7 +6,9 @@ Our approach to \"clean code\" is two-fold:\n It is explicitly OK for a reviewer to flag only some nits in the PR, and then send a follow-up cleanup PR for things which are easier to explain by example, cc-ing the original author.\n Sending small cleanup PRs (like renaming a single local variable) is encouraged.\n \n-# Scale of Changes\n+# General\n+\n+## Scale of Changes\n \n Everyone knows that it's better to send small & focused pull requests.\n The problem is, sometimes you *have* to, eg, rewrite the whole compiler, and that just doesn't fit into a set of isolated PRs.\n@@ -45,13 +47,35 @@ That said, adding an innocent-looking `pub use` is a very simple way to break en\n Note: if you enjoyed this abstract hand-waving about boundaries, you might appreciate\n https://www.tedinski.com/2018/02/06/system-boundaries.html\n \n-# Crates.io Dependencies\n+## Crates.io Dependencies\n \n We try to be very conservative with usage of crates.io dependencies.\n Don't use small \"helper\" crates (exception: `itertools` is allowed).\n If there's some general reusable bit of code you need, consider adding it to the `stdx` crate.\n \n-# Minimal Tests\n+## Commit Style\n+\n+We don't have specific rules around git history hygiene.\n+Maintaining clean git history is strongly encouraged, but not enforced.\n+Use rebase workflow, it's OK to rewrite history during PR review process.\n+After you are happy with the state of the code, please use [interactive rebase](https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History) to squash fixup commits.\n+\n+Avoid @mentioning people in commit messages and pull request descriptions(they are added to commit message by bors).\n+Such messages create a lot of duplicate notification traffic during rebases.\n+\n+## Clippy\n+\n+We don't enforce Clippy.\n+A number of default lints have high false positive rate.\n+Selectively patching false-positives with `allow(clippy)` is considered worse than not using Clippy at all.\n+There's `cargo xtask lint` command which runs a subset of low-FPR lints.\n+Careful tweaking of `xtask lint` is welcome.\n+See also [rust-lang/clippy#5537](https://github.com/rust-lang/rust-clippy/issues/5537).\n+Of course, applying Clippy suggestions is welcome as long as they indeed improve the code.\n+\n+# Code\n+\n+## Minimal Tests\n \n Most tests in rust-analyzer start with a snippet of Rust code.\n This snippets should be minimal -- if you copy-paste a snippet of real code into the tests, make sure to remove everything which could be removed.\n@@ -65,119 +89,7 @@ There are many benefits to this:\n It also makes sense to format snippets more compactly (for example, by placing enum definitions like `enum E { Foo, Bar }` on a single line),\n as long as they are still readable.\n \n-# Order of Imports\n-\n-Separate import groups with blank lines.\n-Use one `use` per crate.\n-\n-```rust\n-mod x;\n-mod y;\n-\n-// First std.\n-use std::{ ... }\n-\n-// Second, external crates (both crates.io crates and other rust-analyzer crates).\n-use crate_foo::{ ... }\n-use crate_bar::{ ... }\n-\n-// Then current crate.\n-use crate::{}\n-\n-// Finally, parent and child modules, but prefer `use crate::`.\n-use super::{}\n-```\n-\n-Module declarations come before the imports.\n-Order them in \"suggested reading order\" for a person new to the code base.\n-\n-# Import Style\n-\n-Qualify items from `hir` and `ast`.\n-\n-```rust\n-// Good\n-use syntax::ast;\n-\n-fn frobnicate(func: hir::Function, strukt: ast::StructDef) {}\n-\n-// Not as good\n-use hir::Function;\n-use syntax::ast::StructDef;\n-\n-fn frobnicate(func: Function, strukt: StructDef) {}\n-```\n-\n-Avoid local `use MyEnum::*` imports.\n-\n-Prefer `use crate::foo::bar` to `use super::bar`.\n-\n-When implementing `Debug` or `Display`, import `std::fmt`:\n-\n-```rust\n-// Good\n-use std::fmt;\n-\n-impl fmt::Display for RenameError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { .. }\n-}\n-\n-// Not as good\n-impl std::fmt::Display for RenameError {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { .. }\n-}\n-```\n-\n-# Order of Items\n-\n-Optimize for the reader who sees the file for the first time, and wants to get a general idea about what's going on.\n-People read things from top to bottom, so place most important things first.\n-\n-Specifically, if all items except one are private, always put the non-private item on top.\n-\n-Put `struct`s and `enum`s first, functions and impls last.\n-\n-Do\n-\n-```rust\n-// Good\n-struct Foo {\n-    bars: Vec<Bar>\n-}\n-\n-struct Bar;\n-```\n-\n-rather than\n-\n-```rust\n-// Not as good\n-struct Bar;\n-\n-struct Foo {\n-    bars: Vec<Bar>\n-}\n-```\n-\n-# Variable Naming\n-\n-Use boring and long names for local variables ([yay code completion](https://github.com/rust-analyzer/rust-analyzer/pull/4162#discussion_r417130973)).\n-The default name is a lowercased name of the type: `global_state: GlobalState`.\n-Avoid ad-hoc acronyms and contractions, but use the ones that exist consistently (`db`, `ctx`, `acc`).\n-\n-Default names:\n-\n-* `res` -- \"result of the function\" local variable\n-* `it` -- I don't really care about the name\n-* `n_foo` -- number of foos\n-* `foo_idx` -- index of `foo`\n-\n-# Collection types\n-\n-Prefer `rustc_hash::FxHashMap` and `rustc_hash::FxHashSet` instead of the ones in `std::collections`.\n-They use a hasher that's slightly faster and using them consistently will reduce code size by some small amount.\n-\n-# Preconditions\n+## Preconditions\n \n Express function preconditions in types and force the caller to provide them (rather than checking in callee):\n \n@@ -199,9 +111,15 @@ fn frobnicate(walrus: Option<Walrus>) {\n \n Avoid preconditions that span across function boundaries:\n \n-\n ```rust\n // Good\n+fn main() {\n+    let s: &str = ...;\n+    if let Some(contents) = string_literal_contents(s) {\n+\n+    }\n+}\n+\n fn string_literal_contents(s: &str) -> Option<&str> {\n     if s.starts_with('\"') && s.ends_with('\"') {\n         Some(&s[1..s.len() - 1])\n@@ -210,54 +128,37 @@ fn string_literal_contents(s: &str) -> Option<&str> {\n     }\n }\n \n-fn foo() {\n+// Not as good\n+fn main() {\n     let s: &str = ...;\n-    if let Some(contents) = string_literal_contents(s) {\n-\n+    if is_string_literal(s) {\n+        let contents = &s[1..s.len() - 1];\n     }\n }\n \n-// Not as good\n fn is_string_literal(s: &str) -> bool {\n     s.starts_with('\"') && s.ends_with('\"')\n }\n-\n-fn foo() {\n-    let s: &str = ...;\n-    if is_string_literal(s) {\n-        let contents = &s[1..s.len() - 1];\n-    }\n-}\n ```\n \n In the \"Not as good\" version, the precondition that `1` is a valid char boundary is checked in `is_string_literal` and used in `foo`.\n In the \"Good\" version, the precondition check and usage are checked in the same block, and then encoded in the types.\n \n-# Early Returns\n-\n-Do use early returns\n+When checking a boolean precondition, prefer `if !invariant` to `if negated_invariant`:\n \n ```rust\n // Good\n-fn foo() -> Option<Bar> {\n-    if !condition() {\n-        return None;\n-    }\n-\n-    Some(...)\n+if !(idx < len) {\n+    return None;\n }\n \n // Not as good\n-fn foo() -> Option<Bar> {\n-    if condition() {\n-        Some(...)\n-    } else {\n-        None\n-    }\n+if idx >= len {\n+    return None;\n }\n ```\n \n-# Getters & Setters\n+## Getters & Setters\n \n If a field can have any value without breaking invariants, make the field public.\n Conversely, if there is an invariant, document it, enforce it in the \"constructor\" function, make the field private, and provide a getter.\n@@ -285,6 +186,40 @@ impl Person {\n }\n ```\n \n+## Avoid Monomorphization\n+\n+Rust uses monomorphization to compile generic code, meaning that for each instantiation of a generic functions with concrete types, the function is compiled afresh, *per crate*.\n+This allows for exceptionally good performance, but leads to increased compile times.\n+Runtime performance obeys 80%/20% rule -- only a small fraction of code is hot.\n+Compile time **does not** obey this rule -- all code has to be compiled.\n+For this reason, avoid making a lot of code type parametric, *especially* on the boundaries between crates.\n+\n+```rust\n+// Good\n+fn frbonicate(f: impl FnMut()) {\n+    frobnicate_impl(&mut f)\n+}\n+fn frobnicate_impl(f: &mut dyn FnMut()) {\n+    // lots of code\n+}\n+\n+// Not as good\n+fn frbonicate(f: impl FnMut()) {\n+    // lots of code\n+}\n+```\n+\n+Avoid `AsRef` polymorphism, it pays back only for widely used libraries:\n+\n+```rust\n+// Good\n+fn frbonicate(f: &Path) {\n+}\n+\n+// Not as good\n+fn frbonicate(f: impl AsRef<Path>) {\n+}\n+```\n \n # Premature Pessimization\n \n@@ -322,62 +257,159 @@ fn frobnicate(s: &str) {\n }\n ```\n \n-# Avoid Monomorphization\n+## Collection types\n \n-Rust uses monomorphization to compile generic code, meaning that for each instantiation of a generic functions with concrete types, the function is compiled afresh, *per crate*.\n-This allows for exceptionally good performance, but leads to increased compile times.\n-Runtime performance obeys 80%/20% rule -- only a small fraction of code is hot.\n-Compile time **does not** obey this rule -- all code has to be compiled.\n-For this reason, avoid making a lot of code type parametric, *especially* on the boundaries between crates.\n+Prefer `rustc_hash::FxHashMap` and `rustc_hash::FxHashSet` instead of the ones in `std::collections`.\n+They use a hasher that's slightly faster and using them consistently will reduce code size by some small amount.\n+\n+# Style\n+\n+## Order of Imports\n+\n+Separate import groups with blank lines.\n+Use one `use` per crate.\n+\n+```rust\n+mod x;\n+mod y;\n+\n+// First std.\n+use std::{ ... }\n+\n+// Second, external crates (both crates.io crates and other rust-analyzer crates).\n+use crate_foo::{ ... }\n+use crate_bar::{ ... }\n+\n+// Then current crate.\n+use crate::{}\n+\n+// Finally, parent and child modules, but prefer `use crate::`.\n+use super::{}\n+```\n+\n+Module declarations come before the imports.\n+Order them in \"suggested reading order\" for a person new to the code base.\n+\n+## Import Style\n+\n+Qualify items from `hir` and `ast`.\n \n ```rust\n // Good\n-fn frbonicate(f: impl FnMut()) {\n-    frobnicate_impl(&mut f)\n-}\n-fn frobnicate_impl(f: &mut dyn FnMut()) {\n-    // lots of code\n+use syntax::ast;\n+\n+fn frobnicate(func: hir::Function, strukt: ast::StructDef) {}\n+\n+// Not as good\n+use hir::Function;\n+use syntax::ast::StructDef;\n+\n+fn frobnicate(func: Function, strukt: StructDef) {}\n+```\n+\n+Avoid local `use MyEnum::*` imports.\n+\n+Prefer `use crate::foo::bar` to `use super::bar`.\n+\n+When implementing `Debug` or `Display`, import `std::fmt`:\n+\n+```rust\n+// Good\n+use std::fmt;\n+\n+impl fmt::Display for RenameError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { .. }\n }\n \n // Not as good\n-fn frbonicate(f: impl FnMut()) {\n-    // lots of code\n+impl std::fmt::Display for RenameError {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { .. }\n }\n ```\n \n-Avoid `AsRef` polymorphism, it pays back only for widely used libraries:\n+## Order of Items\n+\n+Optimize for the reader who sees the file for the first time, and wants to get a general idea about what's going on.\n+People read things from top to bottom, so place most important things first.\n+\n+Specifically, if all items except one are private, always put the non-private item on top.\n+\n+Put `struct`s and `enum`s first, functions and impls last.\n+\n+Do\n \n ```rust\n // Good\n-fn frbonicate(f: &Path) {\n+struct Foo {\n+    bars: Vec<Bar>\n }\n \n+struct Bar;\n+```\n+\n+rather than\n+\n+```rust\n // Not as good\n-fn frbonicate(f: impl AsRef<Path>) {\n+struct Bar;\n+\n+struct Foo {\n+    bars: Vec<Bar>\n }\n ```\n \n-# Documentation\n+## Variable Naming\n \n-For `.md` and `.adoc` files, prefer a sentence-per-line format, don't wrap lines.\n-If the line is too long, you want to split the sentence in two :-)\n+Use boring and long names for local variables ([yay code completion](https://github.com/rust-analyzer/rust-analyzer/pull/4162#discussion_r417130973)).\n+The default name is a lowercased name of the type: `global_state: GlobalState`.\n+Avoid ad-hoc acronyms and contractions, but use the ones that exist consistently (`db`, `ctx`, `acc`).\n \n-# Commit Style\n+Default names:\n \n-We don't have specific rules around git history hygiene.\n-Maintaining clean git history is strongly encouraged, but not enforced.\n-Use rebase workflow, it's OK to rewrite history during PR review process.\n-After you are happy with the state of the code, please use [interactive rebase](https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History) to squash fixup commits.\n+* `res` -- \"result of the function\" local variable\n+* `it` -- I don't really care about the name\n+* `n_foo` -- number of foos\n+* `foo_idx` -- index of `foo`\n \n-Avoid @mentioning people in commit messages and pull request descriptions(they are added to commit message by bors).\n-Such messages create a lot of duplicate notification traffic during rebases.\n \n-# Clippy\n+## Early Returns\n \n-We don't enforce Clippy.\n-A number of default lints have high false positive rate.\n-Selectively patching false-positives with `allow(clippy)` is considered worse than not using Clippy at all.\n-There's `cargo xtask lint` command which runs a subset of low-FPR lints.\n-Careful tweaking of `xtask lint` is welcome.\n-See also [rust-lang/clippy#5537](https://github.com/rust-lang/rust-clippy/issues/5537).\n-Of course, applying Clippy suggestions is welcome as long as they indeed improve the code.\n+Do use early returns\n+\n+```rust\n+// Good\n+fn foo() -> Option<Bar> {\n+    if !condition() {\n+        return None;\n+    }\n+\n+    Some(...)\n+}\n+\n+// Not as good\n+fn foo() -> Option<Bar> {\n+    if condition() {\n+        Some(...)\n+    } else {\n+        None\n+    }\n+}\n+```\n+\n+## Comparisons\n+\n+Use `<`/`<=`, avoid `>`/`>=`.\n+Less-then comparisons are more intuitive, they correspond spatially to [real line](https://en.wikipedia.org/wiki/Real_line)\n+\n+```rs\n+// Good\n+assert!(lo <= x && x <= hi);\n+\n+// Not as good\n+assert!(x >= lo && x <= hi>);\n+```\n+\n+## Documentation\n+\n+For `.md` and `.adoc` files, prefer a sentence-per-line format, don't wrap lines.\n+If the line is too long, you want to split the sentence in two :-)"}]}