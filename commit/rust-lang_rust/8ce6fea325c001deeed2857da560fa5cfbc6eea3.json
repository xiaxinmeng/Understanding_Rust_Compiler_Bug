{"sha": "8ce6fea325c001deeed2857da560fa5cfbc6eea3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZTZmZWEzMjVjMDAxZGVlZWQyODU3ZGE1NjBmYTVjZmJjNmVlYTM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-08T12:16:05Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-08T12:23:17Z"}, "message": "Remove identity impls for ToChalk", "tree": {"sha": "4f9fb1a7f0b9987d9e23c0667b7495d68f08c03d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f9fb1a7f0b9987d9e23c0667b7495d68f08c03d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ce6fea325c001deeed2857da560fa5cfbc6eea3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ce6fea325c001deeed2857da560fa5cfbc6eea3", "html_url": "https://github.com/rust-lang/rust/commit/8ce6fea325c001deeed2857da560fa5cfbc6eea3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ce6fea325c001deeed2857da560fa5cfbc6eea3/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a163554857db677e892c211b41deda676a6d1511", "url": "https://api.github.com/repos/rust-lang/rust/commits/a163554857db677e892c211b41deda676a6d1511", "html_url": "https://github.com/rust-lang/rust/commit/a163554857db677e892c211b41deda676a6d1511"}], "stats": {"total": 236, "additions": 21, "deletions": 215}, "files": [{"sha": "6584bcf34d67be57b7810d54fb3840aaf4e66a28", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ce6fea325c001deeed2857da560fa5cfbc6eea3/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce6fea325c001deeed2857da560fa5cfbc6eea3/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=8ce6fea325c001deeed2857da560fa5cfbc6eea3", "patch": "@@ -950,8 +950,7 @@ pub(crate) fn trait_environment_query(\n                 traits_in_scope\n                     .push((tr.self_type_parameter(&Interner).clone(), tr.hir_trait_id()));\n             }\n-            let program_clause: chalk_ir::ProgramClause<Interner> =\n-                pred.clone().to_chalk(db).cast(&Interner);\n+            let program_clause: chalk_ir::ProgramClause<Interner> = pred.clone().cast(&Interner);\n             clauses.push(program_clause.into_from_env_clause(&Interner));\n         }\n     }\n@@ -974,7 +973,7 @@ pub(crate) fn trait_environment_query(\n         let substs = TyBuilder::type_params_subst(db, trait_id);\n         let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution: substs };\n         let pred = WhereClause::Implemented(trait_ref);\n-        let program_clause: chalk_ir::ProgramClause<Interner> = pred.to_chalk(db).cast(&Interner);\n+        let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(&Interner);\n         clauses.push(program_clause.into_from_env_clause(&Interner));\n     }\n "}, {"sha": "63d87fe6106cdcac6863e07ddd27d1f6952e8ceb", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ce6fea325c001deeed2857da560fa5cfbc6eea3/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce6fea325c001deeed2857da560fa5cfbc6eea3/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=8ce6fea325c001deeed2857da560fa5cfbc6eea3", "patch": "@@ -96,7 +96,7 @@ pub(crate) fn trait_solve_query(\n         }\n     }\n \n-    let canonical = goal.to_chalk(db).cast(&Interner);\n+    let canonical = goal.cast(&Interner);\n \n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)"}, {"sha": "fcdcc2b4dffba91ec78749de3fbbc4c57409bb41", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8ce6fea325c001deeed2857da560fa5cfbc6eea3/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce6fea325c001deeed2857da560fa5cfbc6eea3/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=8ce6fea325c001deeed2857da560fa5cfbc6eea3", "patch": "@@ -86,7 +86,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n         let trait_: hir_def::TraitId = from_chalk(self.db, trait_id);\n \n-        let ty: Ty = from_chalk(self.db, parameters[0].assert_ty_ref(&Interner).clone());\n+        let ty: Ty = parameters[0].assert_ty_ref(&Interner).clone();\n \n         fn binder_kind(\n             ty: &Ty,\n@@ -187,15 +187,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                 let (datas, binders) = (*datas).as_ref().into_value_and_skipped_binders();\n                 let data = &datas.impl_traits[idx as usize];\n                 let bound = OpaqueTyDatumBound {\n-                    bounds: make_binders(\n-                        data.bounds\n-                            .skip_binders()\n-                            .iter()\n-                            .cloned()\n-                            .map(|b| b.to_chalk(self.db))\n-                            .collect(),\n-                        1,\n-                    ),\n+                    bounds: make_binders(data.bounds.skip_binders().iter().cloned().collect(), 1),\n                     where_clauses: make_binders(vec![], 0),\n                 };\n                 chalk_ir::Binders::new(binders, bound)\n@@ -246,8 +238,8 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     let bound = OpaqueTyDatumBound {\n                         bounds: make_binders(\n                             vec![\n-                                crate::wrap_empty_binders(impl_bound).to_chalk(self.db),\n-                                crate::wrap_empty_binders(proj_bound).to_chalk(self.db),\n+                                crate::wrap_empty_binders(impl_bound),\n+                                crate::wrap_empty_binders(proj_bound),\n                             ],\n                             1,\n                         ),\n@@ -272,7 +264,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n     fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {\n         // FIXME: actually provide the hidden type; it is relevant for auto traits\n-        TyKind::Error.intern(&Interner).to_chalk(self.db)\n+        TyKind::Error.intern(&Interner)\n     }\n \n     fn is_object_safe(&self, _trait_id: chalk_ir::TraitId<Interner>) -> bool {\n@@ -293,12 +285,11 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<rust_ir::FnDefInputsAndOutputDatum<Interner>> {\n-        let sig_ty: Ty =\n-            from_chalk(self.db, substs.at(&Interner, 0).assert_ty_ref(&Interner).clone());\n+        let sig_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n         let sig = &sig_ty.callable_sig(self.db).expect(\"first closure param should be fn ptr\");\n         let io = rust_ir::FnDefInputsAndOutputDatum {\n-            argument_types: sig.params().iter().map(|ty| ty.clone().to_chalk(self.db)).collect(),\n-            return_type: sig.ret().clone().to_chalk(self.db),\n+            argument_types: sig.params().iter().cloned().collect(),\n+            return_type: sig.ret().clone(),\n         };\n         make_binders(io.shifted_in(&Interner), 0)\n     }\n@@ -307,15 +298,15 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<chalk_ir::Ty<Interner>> {\n-        let ty = TyBuilder::unit().to_chalk(self.db);\n+        let ty = TyBuilder::unit();\n         make_binders(ty, 0)\n     }\n     fn closure_fn_substitution(\n         &self,\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Substitution<Interner> {\n-        Substitution::empty(&Interner).to_chalk(self.db)\n+        Substitution::empty(&Interner)\n     }\n \n     fn trait_name(&self, trait_id: chalk_ir::TraitId<Interner>) -> String {\n@@ -410,7 +401,7 @@ pub(crate) fn associated_ty_data_query(\n     let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n     let bound_data = rust_ir::AssociatedTyDatumBound { bounds, where_clauses };\n     let datum = AssociatedTyDatum {\n-        trait_id: trait_.to_chalk(db),\n+        trait_id: to_chalk_trait_id(trait_),\n         id,\n         name: type_alias,\n         binders: make_binders(bound_data, generic_params.len()),\n@@ -563,7 +554,6 @@ fn impl_def_datum(\n         trait_ref.display(db),\n         where_clauses\n     );\n-    let trait_ref = trait_ref.to_chalk(db);\n \n     let polarity = if negative { rust_ir::Polarity::Negative } else { rust_ir::Polarity::Positive };\n \n@@ -624,7 +614,7 @@ fn type_alias_associated_ty_value(\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n     let (ty, binders) = db.ty(type_alias.into()).into_value_and_skipped_binders();\n-    let value_bound = rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n+    let value_bound = rust_ir::AssociatedTyValueBound { ty };\n     let value = rust_ir::AssociatedTyValue {\n         impl_id: impl_id.to_chalk(db),\n         associated_ty_id: to_assoc_type_id(assoc_ty),\n@@ -647,8 +637,8 @@ pub(crate) fn fn_def_datum_query(\n         // Note: Chalk doesn't actually use this information yet as far as I am aware, but we provide it anyway\n         inputs_and_output: make_binders(\n             rust_ir::FnDefInputsAndOutputDatum {\n-                argument_types: sig.params().iter().map(|ty| ty.clone().to_chalk(db)).collect(),\n-                return_type: sig.ret().clone().to_chalk(db),\n+                argument_types: sig.params().iter().cloned().collect(),\n+                return_type: sig.ret().clone(),\n             }\n             .shifted_in(&Interner),\n             0,"}, {"sha": "54783b58c3457eb880bbf09fec105003f336ca73", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 4, "deletions": 187, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/8ce6fea325c001deeed2857da560fa5cfbc6eea3/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce6fea325c001deeed2857da560fa5cfbc6eea3/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=8ce6fea325c001deeed2857da560fa5cfbc6eea3", "patch": "@@ -18,55 +18,6 @@ use crate::{\n use super::interner::*;\n use super::*;\n \n-impl ToChalk for Ty {\n-    type Chalk = chalk_ir::Ty<Interner>;\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n-        self\n-    }\n-    fn from_chalk(db: &dyn HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n-        chalk\n-    }\n-}\n-\n-impl ToChalk for GenericArg {\n-    type Chalk = chalk_ir::GenericArg<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk {\n-        self\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n-        chalk\n-    }\n-}\n-\n-impl ToChalk for Substitution {\n-    type Chalk = chalk_ir::Substitution<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Substitution<Interner> {\n-        self\n-    }\n-\n-    fn from_chalk(\n-        db: &dyn HirDatabase,\n-        parameters: chalk_ir::Substitution<Interner>,\n-    ) -> Substitution {\n-        parameters\n-    }\n-}\n-\n-impl ToChalk for TraitRef {\n-    type Chalk = chalk_ir::TraitRef<Interner>;\n-\n-    fn to_chalk(self: TraitRef, db: &dyn HirDatabase) -> chalk_ir::TraitRef<Interner> {\n-        self\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, trait_ref: chalk_ir::TraitRef<Interner>) -> Self {\n-        trait_ref\n-    }\n-}\n-\n impl ToChalk for hir_def::TraitId {\n     type Chalk = TraitId;\n \n@@ -120,140 +71,6 @@ impl ToChalk for TypeAliasAsValue {\n     }\n }\n \n-impl ToChalk for WhereClause {\n-    type Chalk = chalk_ir::WhereClause<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::WhereClause<Interner> {\n-        self\n-    }\n-\n-    fn from_chalk(\n-        db: &dyn HirDatabase,\n-        where_clause: chalk_ir::WhereClause<Interner>,\n-    ) -> WhereClause {\n-        where_clause\n-    }\n-}\n-\n-impl ToChalk for ProjectionTy {\n-    type Chalk = chalk_ir::ProjectionTy<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::ProjectionTy<Interner> {\n-        self\n-    }\n-\n-    fn from_chalk(\n-        db: &dyn HirDatabase,\n-        projection_ty: chalk_ir::ProjectionTy<Interner>,\n-    ) -> ProjectionTy {\n-        projection_ty\n-    }\n-}\n-impl ToChalk for OpaqueTy {\n-    type Chalk = chalk_ir::OpaqueTy<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk {\n-        self\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n-        chalk\n-    }\n-}\n-\n-impl ToChalk for AliasTy {\n-    type Chalk = chalk_ir::AliasTy<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk {\n-        self\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n-        chalk\n-    }\n-}\n-\n-impl ToChalk for AliasEq {\n-    type Chalk = chalk_ir::AliasEq<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::AliasEq<Interner> {\n-        self\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, alias_eq: chalk_ir::AliasEq<Interner>) -> Self {\n-        alias_eq\n-    }\n-}\n-\n-impl ToChalk for DomainGoal {\n-    type Chalk = chalk_ir::DomainGoal<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::DomainGoal<Interner> {\n-        self\n-    }\n-\n-    fn from_chalk(_db: &dyn HirDatabase, goal: chalk_ir::DomainGoal<Interner>) -> Self {\n-        goal\n-    }\n-}\n-\n-impl<T> ToChalk for Canonical<T>\n-where\n-    T: HasInterner<Interner = Interner>,\n-{\n-    type Chalk = chalk_ir::Canonical<T>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T> {\n-        self\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T>) -> Canonical<T> {\n-        canonical\n-    }\n-}\n-\n-impl<T: ToChalk> ToChalk for InEnvironment<T>\n-where\n-    T: HasInterner<Interner = Interner>,\n-{\n-    type Chalk = chalk_ir::InEnvironment<T>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::InEnvironment<T> {\n-        self\n-    }\n-\n-    fn from_chalk(_db: &dyn HirDatabase, in_env: chalk_ir::InEnvironment<T>) -> InEnvironment<T> {\n-        in_env\n-    }\n-}\n-\n-impl<T: ToChalk> ToChalk for crate::Binders<T>\n-where\n-    T: HasInterner<Interner = Interner>,\n-{\n-    type Chalk = chalk_ir::Binders<T>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Binders<T> {\n-        self\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, binders: chalk_ir::Binders<T>) -> crate::Binders<T> {\n-        binders\n-    }\n-}\n-\n-impl ToChalk for crate::ConstrainedSubst {\n-    type Chalk = chalk_ir::ConstrainedSubst<Interner>;\n-\n-    fn to_chalk(self, _db: &dyn HirDatabase) -> Self::Chalk {\n-        self\n-    }\n-\n-    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n-        chalk\n-    }\n-}\n-\n pub(super) fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T>\n where\n     T: HasInterner<Interner = Interner>,\n@@ -276,7 +93,7 @@ pub(super) fn convert_where_clauses(\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n-        result.push(pred.clone().substitute(&Interner, substs).to_chalk(db));\n+        result.push(pred.clone().substitute(&Interner, substs));\n     }\n     result\n }\n@@ -299,7 +116,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n             }\n             let args_no_self = trait_ref.substitution.interned()[1..]\n                 .iter()\n-                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .map(|ty| ty.clone().cast(&Interner))\n                 .collect();\n             let trait_bound = rust_ir::TraitBound { trait_id: trait_ref.trait_id, args_no_self };\n             Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n@@ -311,10 +128,10 @@ pub(super) fn generic_predicate_to_inline_bound(\n             let trait_ = projection_ty.trait_(db);\n             let args_no_self = projection_ty.substitution.interned()[1..]\n                 .iter()\n-                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .map(|ty| ty.clone().cast(&Interner))\n                 .collect();\n             let alias_eq_bound = rust_ir::AliasEqBound {\n-                value: ty.clone().to_chalk(db),\n+                value: ty.clone(),\n                 trait_bound: rust_ir::TraitBound { trait_id: trait_.to_chalk(db), args_no_self },\n                 associated_ty_id: projection_ty.associated_ty_id,\n                 parameters: Vec::new(), // FIXME we don't support generic associated types yet"}]}