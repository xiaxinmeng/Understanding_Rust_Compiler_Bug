{"sha": "f279e0d76e3cfb7753074bc4c77926c0e7e48990", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNzllMGQ3NmUzY2ZiNzc1MzA3NGJjNGM3NzkyNmMwZTdlNDg5OTA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-06T02:57:34Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-06T02:58:49Z"}, "message": "Handle pattern-bound upvars\n\nIf a closure inside a case alternative (for example, a for each loop)\nreferenced a pattern-bound variable, this would cause an assertion\nfailure in trans. Changed trans::collect_upvars to handle pattern-bound\nvars correctly.\n\nIncidentally, eliminated all direct uses of option::get in trans.", "tree": {"sha": "821a57ddf3f7f267a3770d934f1cb92cc9d031c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/821a57ddf3f7f267a3770d934f1cb92cc9d031c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f279e0d76e3cfb7753074bc4c77926c0e7e48990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f279e0d76e3cfb7753074bc4c77926c0e7e48990", "html_url": "https://github.com/rust-lang/rust/commit/f279e0d76e3cfb7753074bc4c77926c0e7e48990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f279e0d76e3cfb7753074bc4c77926c0e7e48990/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bba58504414c845bd6b24b31c3be2d3f982c511", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bba58504414c845bd6b24b31c3be2d3f982c511", "html_url": "https://github.com/rust-lang/rust/commit/1bba58504414c845bd6b24b31c3be2d3f982c511"}], "stats": {"total": 235, "additions": 186, "deletions": 49}, "files": [{"sha": "8b5a37081ccb2c3f8abc9370312f9804fef05e4d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 162, "deletions": 49, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/f279e0d76e3cfb7753074bc4c77926c0e7e48990/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f279e0d76e3cfb7753074bc4c77926c0e7e48990/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f279e0d76e3cfb7753074bc4c77926c0e7e48990", "patch": "@@ -2147,7 +2147,10 @@ fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n     cx = val.bcx;\n     // Find and call the actual destructor.\n     auto dtor_pair = if (did._0 == ast::local_crate) {\n-        ccx.fn_pairs.get(did._1)\n+        alt (ccx.fn_pairs.find(did._1)) {\n+            case (some(?x)) { x }\n+            case (_) { ccx.tcx.sess.bug(\"internal error in trans_res_drop\") }\n+        }\n     } else {\n         auto params = decoder::get_type_param_count(ccx.tcx, did);\n         auto f_t = type_of_fn(ccx, cx.sp, ast::proto_fn,\n@@ -4338,18 +4341,26 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n     type env =\n         @rec(mutable vec[ast::node_id] refs,\n              hashmap[ast::node_id, ()] decls,\n-             resolve::def_map def_map);\n+             resolve::def_map def_map,\n+             session::session sess);\n \n     fn walk_expr(env e, &@ast::expr expr) {\n         alt (expr.node) {\n             case (ast::expr_path(?path)) {\n+                if (! e.def_map.contains_key(expr.id)) {\n+                    e.sess.span_fatal(expr.span,\n+                       \"internal error in collect_upvars\");\n+                }\n                 alt (e.def_map.get(expr.id)) {\n                     case (ast::def_arg(?did)) {\n                         vec::push(e.refs, did._1);\n                     }\n                     case (ast::def_local(?did)) {\n                         vec::push(e.refs, did._1);\n                     }\n+                    case (ast::def_binding(?did)) {\n+                        vec::push(e.refs, did._1);\n+                    }\n                     case (_) { }\n                 }\n             }\n@@ -4359,15 +4370,25 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n     fn walk_local(env e, &@ast::local local) {\n         e.decls.insert(local.node.id, ());\n     }\n+    fn walk_pat(env e, &@ast::pat p) {\n+        alt (p.node) {\n+            case (ast::pat_bind(_)) {\n+                e.decls.insert(p.id, ());\n+            }\n+            case (_) {}\n+        }\n+    }\n     let hashmap[ast::node_id, ()] decls = new_int_hash[()]();\n     decls.insert(initial_decl, ());\n     let env e =\n         @rec(mutable refs=[],\n              decls=decls,\n-             def_map=cx.fcx.lcx.ccx.tcx.def_map);\n+             def_map=cx.fcx.lcx.ccx.tcx.def_map,\n+             sess=cx.fcx.lcx.ccx.tcx.sess);\n     auto visitor =\n         @rec(visit_local_pre=bind walk_local(e, _),\n-             visit_expr_pre=bind walk_expr(e, _)\n+             visit_expr_pre=bind walk_expr(e, _),\n+             visit_pat_pre=bind walk_pat(e, _)\n              with walk::default_visitor());\n     walk::walk_block(*visitor, bloc);\n     // Calculate (refs - decls). This is the set of captured upvars.\n@@ -4398,10 +4419,15 @@ fn build_environment(&@block_ctxt cx, &vec[ast::node_id] upvars) ->\n             alt (cx.fcx.lllocals.find(nid)) {\n                 case (none) {\n                     alt (cx.fcx.llupvars.find(nid)) {\n-                        case (none[ValueRef]) {\n-                            llbinding = cx.fcx.llargs.get(nid);\n+                        case (none) {\n+                            alt (cx.fcx.llargs.find(nid)) {\n+                                case (some(?x)) { llbinding = x; }\n+                                case (_) {\n+                                    cx.fcx.lcx.ccx.sess.bug(\"unbound var \\\n+                                      in build_environment \" + istr(nid)); }\n+                            }\n                         }\n-                        case (some[ValueRef](?llval)) { llbinding = llval; }\n+                        case (some(?llval)) { llbinding = llval; }\n                     }\n                 }\n                 case (some(?llval)) { llbinding = llval; }\n@@ -4637,8 +4663,15 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             ret rslt(matched_cx, llval);\n         }\n         case (ast::pat_tag(?ident, ?subpats)) {\n-            auto vdef =\n-                ast::variant_def_ids(cx.fcx.lcx.ccx.tcx.def_map.get(pat.id));\n+            auto vdef;\n+            alt (cx.fcx.lcx.ccx.tcx.def_map.find(pat.id)) {\n+                case (some(?x)) { vdef = ast::variant_def_ids(x); }\n+                case (_) {\n+                    cx.fcx.lcx.ccx.sess.span_fatal(pat.span,\n+                                             \"trans_pat_match: unbound var\");\n+                }\n+            }\n+\n             auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0);\n             auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n             auto llblobptr = llval;\n@@ -4720,8 +4753,12 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             if (vec::len[@ast::pat](subpats) == 0u) { ret rslt(cx, llval); }\n             // Get the appropriate variant for this tag.\n \n-            auto vdef =\n-                ast::variant_def_ids(cx.fcx.lcx.ccx.tcx.def_map.get(pat.id));\n+            auto vdef;\n+            alt (cx.fcx.lcx.ccx.tcx.def_map.find(pat.id)) {\n+                case (some(?x)) { vdef = ast::variant_def_ids(x); }\n+                case (_) { cx.fcx.lcx.ccx.sess.span_fatal(pat.span,\n+                      \"trans_pat_binding: internal error, unbound var\"); }\n+            }\n             auto llblobptr = llval;\n             if (vec::len(ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0))!=1u) {\n                 auto lltagptr = cx.build.PointerCast\n@@ -4863,8 +4900,8 @@ fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n \n fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n     auto ccx = cx.fcx.lcx.ccx;\n-    alt (cx.fcx.lcx.ccx.tcx.def_map.get(id)) {\n-        case (ast::def_arg(?did)) {\n+    alt (cx.fcx.lcx.ccx.tcx.def_map.find(id)) {\n+        case (some(ast::def_arg(?did))) {\n             alt (cx.fcx.llargs.find(did._1)) {\n                 case (none) {\n                     assert (cx.fcx.llupvars.contains_key(did._1));\n@@ -4873,7 +4910,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n                 case (some(?llval)) { ret lval_mem(cx, llval); }\n             }\n         }\n-        case (ast::def_local(?did)) {\n+        case (some(ast::def_local(?did))) {\n             alt (cx.fcx.lllocals.find(did._1)) {\n                 case (none) {\n                     assert (cx.fcx.llupvars.contains_key(did._1));\n@@ -4882,19 +4919,24 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n                 case (some(?llval)) { ret lval_mem(cx, llval); }\n             }\n         }\n-        case (ast::def_binding(?did)) {\n-            assert (cx.fcx.lllocals.contains_key(did._1));\n-            ret lval_mem(cx, cx.fcx.lllocals.get(did._1));\n+        case (some(ast::def_binding(?did))) {\n+            alt (cx.fcx.lllocals.find(did._1)) {\n+                case (none) {\n+                    assert (cx.fcx.llupvars.contains_key(did._1));\n+                    ret lval_mem(cx, cx.fcx.llupvars.get(did._1));\n+                }\n+                case (some(?llval)) { ret lval_mem(cx, llval); }\n+            }\n         }\n-        case (ast::def_obj_field(?did)) {\n+        case (some(ast::def_obj_field(?did))) {\n             assert (cx.fcx.llobjfields.contains_key(did._1));\n             ret lval_mem(cx, cx.fcx.llobjfields.get(did._1));\n         }\n-        case (ast::def_fn(?did, _)) {\n+        case (some(ast::def_fn(?did, _))) {\n             auto tyt = ty::lookup_item_type(ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, id);\n         }\n-        case (ast::def_variant(?tid, ?vid)) {\n+        case (some(ast::def_variant(?tid, ?vid))) {\n             auto v_tyt = ty::lookup_item_type(ccx.tcx, vid);\n             alt (ty::struct(ccx.tcx, v_tyt._1)) {\n                 case (ty::ty_fn(_, _, _, _, _)) {\n@@ -4923,12 +4965,12 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n                 }\n             }\n         }\n-        case (ast::def_const(?did)) {\n+        case (some(ast::def_const(?did))) {\n             // TODO: externals\n             assert (ccx.consts.contains_key(did._1));\n             ret lval_mem(cx, ccx.consts.get(did._1));\n         }\n-        case (ast::def_native_fn(?did)) {\n+        case (some(ast::def_native_fn(?did))) {\n             auto tyt = ty::lookup_item_type(ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, id);\n         }\n@@ -7572,7 +7614,12 @@ fn copy_args_to_allocas(@fn_ctxt fcx, vec[ast::arg] args,\n         if (aarg.mode == ast::val) {\n             auto arg_t = type_of_arg(bcx.fcx.lcx, fcx.sp, arg_tys.(arg_n));\n             auto a = alloca(bcx, arg_t);\n-            auto argval = bcx.fcx.llargs.get(aarg.id);\n+            auto argval;\n+            alt (bcx.fcx.llargs.find(aarg.id)) {\n+                case (some(?x)) { argval = x; }\n+                case (_) { bcx.fcx.lcx.ccx.sess.span_fatal(aarg.ty.span,\n+                         \"unbound arg ID in copy_args_to_allocas\"); }\n+            }\n             bcx.build.Store(argval, a);\n             // Overwrite the llargs entry for this arg with its alloca.\n \n@@ -7587,7 +7634,12 @@ fn add_cleanups_for_args(&@block_ctxt bcx, vec[ast::arg] args,\n     let uint arg_n = 0u;\n     for (ast::arg aarg in args) {\n         if (aarg.mode == ast::val) {\n-            auto argval = bcx.fcx.llargs.get(aarg.id);\n+            auto argval;\n+            alt (bcx.fcx.llargs.find(aarg.id)) {\n+                case (some(?x)) { argval = x; }\n+                case (_) { bcx.fcx.lcx.ccx.sess.span_fatal(aarg.ty.span,\n+                      \"unbound arg ID in copy_args_to_allocas\"); }\n+            }\n             find_scope_cx(bcx).cleanups +=\n                 [clean(bind drop_slot(_, argval, arg_tys.(arg_n).ty))];\n         }\n@@ -7795,7 +7847,12 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // that, a number of block contexts for which code is generated.\n \n     auto ccx = cx.ccx;\n-    auto llctor_decl = ccx.item_ids.get(ctor_id);\n+    auto llctor_decl;\n+    alt (ccx.item_ids.find(ctor_id)) {\n+        case (some(?x)) { llctor_decl = x; }\n+        case (_) { cx.ccx.sess.span_fatal(sp,\n+                     \"unbound llctor_decl in trans_obj\"); }\n+    }\n     // Much like trans_fn, we must create an LLVM function, but since we're\n     // starting with an ast::_obj rather than an ast::_fn, we have some setup\n     // work to do.\n@@ -7957,13 +8014,21 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n         bcx = body_fields.bcx;\n         i = 0;\n         for (ast::obj_field f in ob.fields) {\n-            auto arg = bcx.fcx.llargs.get(f.id);\n-            arg = load_if_immediate(bcx, arg, arg_tys.(i).ty);\n-            auto field =\n-                GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n-            bcx = field.bcx;\n-            bcx = copy_val(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n-            i += 1;\n+            alt (bcx.fcx.llargs.find(f.id)) {\n+                case (some(?arg1)) {\n+                    auto arg = load_if_immediate(bcx, arg1, arg_tys.(i).ty);\n+                    auto field =\n+                        GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n+                    bcx = field.bcx;\n+                    bcx = copy_val(bcx, INIT, field.val, arg,\n+                                   arg_tys.(i).ty).bcx;\n+                    i += 1;\n+                }\n+                case (none) {\n+                    bcx.fcx.lcx.ccx.sess.span_fatal(f.ty.span,\n+                                  \"internal error in trans_obj\");\n+                }\n+            }\n         }\n \n         // Store box ptr in outer pair.\n@@ -7979,7 +8044,13 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n                   ast::node_id ctor_id, &vec[ast::ty_param] ty_params) {\n     // Create a function for the constructor\n-    auto llctor_decl = cx.ccx.item_ids.get(ctor_id);\n+    auto llctor_decl;\n+    alt (cx.ccx.item_ids.find(ctor_id)) {\n+        case (some(?x)) { llctor_decl = x; }\n+        case (_) { \n+            cx.ccx.sess.span_fatal(sp, \"unbound ctor_id in trans_res_ctor\");\n+        }\n+    }\n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     auto ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n@@ -7988,8 +8059,13 @@ fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n     auto lltop = bcx.llbb;\n     auto arg_t = arg_tys_of_fn(cx.ccx, ctor_id).(0).ty;\n     auto tup_t = ty::mk_imm_tup(cx.ccx.tcx, ~[ty::mk_int(cx.ccx.tcx), arg_t]);\n-    auto arg = load_if_immediate\n-        (bcx, fcx.llargs.get(dtor.decl.inputs.(0).id), arg_t);\n+    auto arg;\n+    alt (fcx.llargs.find(dtor.decl.inputs.(0).id)) {\n+        case (some(?x)) { arg = load_if_immediate(bcx, x, arg_t); }\n+        case (_) {\n+            cx.ccx.sess.span_fatal(sp, \"unbound dtor decl in trans_res_ctor\");\n+        }\n+    }\n \n     auto llretptr = fcx.llretptr;\n     if (ty::type_has_dynamic_size(cx.ccx.tcx, ret_t)) {\n@@ -8027,7 +8103,14 @@ fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n                  id=varg.id)];\n     }\n     assert (cx.ccx.item_ids.contains_key(variant.node.id));\n-    let ValueRef llfndecl = cx.ccx.item_ids.get(variant.node.id);\n+    let ValueRef llfndecl;\n+    alt (cx.ccx.item_ids.find(variant.node.id)) {\n+        case (some(?x)) { llfndecl = x; }\n+        case (_) {\n+            cx.ccx.sess.span_fatal(variant.span,\n+                               \"unbound variant id in trans_tag_variant\");\n+        }\n+    }\n     auto fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n                               ty::ret_ty_of_fn(cx.ccx.tcx, variant.node.id),\n@@ -8065,8 +8148,16 @@ fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n \n-        auto llargptr =\n-            bcx.build.PointerCast(fcx.llargs.get(va.id), val_ty(lldestptr));\n+        auto llargptr;\n+        alt (fcx.llargs.find(va.id)) {\n+            case (some(?x)) {\n+                llargptr = bcx.build.PointerCast(x, val_ty(lldestptr));\n+            }\n+            case (none) {\n+                bcx.fcx.lcx.ccx.sess.bug(\"unbound argptr in \\\n+                   trans_tag_variant\");\n+            }\n+        }\n         auto arg_ty = arg_tys.(i).ty;\n         auto llargval;\n         if (ty::type_is_structural(cx.ccx.tcx, arg_ty) ||\n@@ -8100,18 +8191,31 @@ fn trans_const(&@crate_ctxt cx, @ast::expr e, ast::node_id id) {\n     // The scalars come back as 1st class LLVM vals\n     // which we have to stick into global constants.\n \n-    auto g = cx.consts.get(id);\n-    llvm::LLVMSetInitializer(g, v);\n-    llvm::LLVMSetGlobalConstant(g, True);\n+    alt (cx.consts.find(id)) {\n+        case (some(?g)) {\n+            llvm::LLVMSetInitializer(g, v);\n+            llvm::LLVMSetGlobalConstant(g, True);\n+        }\n+        case (_) {\n+            cx.sess.span_fatal(e.span, \"Unbound const in trans_const\");\n+        }\n+    }\n }\n \n fn trans_item(@local_ctxt cx, &ast::item item) {\n     alt (item.node) {\n         case (ast::item_fn(?f, ?tps)) {\n             auto sub_cx = extend_path(cx, item.ident);\n-            auto llfndecl = cx.ccx.item_ids.get(item.id);\n-            trans_fn(sub_cx, item.span, f, llfndecl, none[ty_self_pair], tps,\n-                     item.id);\n+            alt (cx.ccx.item_ids.find(item.id)) {\n+                case (some(?llfndecl)) {\n+                    trans_fn(sub_cx, item.span, f, llfndecl,\n+                             none[ty_self_pair], tps, item.id);\n+                }\n+                case (_) {\n+                    cx.ccx.sess.span_fatal(item.span,\n+                           \"unbound function item in trans_item\");\n+                }\n+            }\n         }\n         case (ast::item_obj(?ob, ?tps, ?ctor_id)) {\n             auto sub_cx =\n@@ -8122,8 +8226,14 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n         case (ast::item_res(?dtor, ?dtor_id, ?tps, ?ctor_id)) {\n             trans_res_ctor(cx, item.span, dtor, ctor_id, tps);\n             // Create a function for the destructor\n-            auto lldtor_decl = cx.ccx.item_ids.get(item.id);\n-            trans_fn(cx, item.span, dtor, lldtor_decl, none, tps, dtor_id)\n+            alt (cx.ccx.item_ids.find(item.id)) {\n+                case (some(?lldtor_decl)) {\n+                    trans_fn(cx, item.span, dtor, lldtor_decl, none, tps,\n+                             dtor_id);\n+                }\n+                case (_) { cx.ccx.sess.span_fatal(item.span,\n+                                          \"unbound dtor in trans_item\"); }\n+            }\n         }\n         case (ast::item_mod(?m)) {\n             auto sub_cx =\n@@ -8238,8 +8348,8 @@ fn register_fn_pair(&@crate_ctxt cx, str ps, TypeRef llfnty, ValueRef llfn,\n // Returns the number of type parameters that the given native function has.\n fn native_fn_ty_param_count(&@crate_ctxt cx, ast::node_id id) -> uint {\n     auto count;\n-    auto native_item = alt (cx.ast_map.get(id)) {\n-        case (ast_map::node_native_item(?i)) { i }\n+    auto native_item = alt (cx.ast_map.find(id)) {\n+        case (some(ast_map::node_native_item(?i))) { i }\n     };\n     alt (native_item.node) {\n         case (ast::native_item_ty) {\n@@ -8623,7 +8733,10 @@ fn trace_ptr(&@block_ctxt cx, ValueRef v) {\n \n fn trap(&@block_ctxt bcx) {\n     let vec[ValueRef] v = [];\n-    bcx.build.Call(bcx.fcx.lcx.ccx.intrinsics.get(\"llvm.trap\"), v);\n+    alt (bcx.fcx.lcx.ccx.intrinsics.find(\"llvm.trap\")) {\n+        case (some(?x)) { bcx.build.Call(x, v); }\n+        case (_) { bcx.fcx.lcx.ccx.sess.bug(\"unbound llvm.trap in trap\"); }\n+    }\n }\n \n fn decl_no_op_type_glue(ModuleRef llmod, type_names tn) -> ValueRef {"}, {"sha": "8bc4370d9f41f632764eade5dc8805cdacefbacf", "filename": "src/test/run-pass/pattern-bound-var-in-for-each.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f279e0d76e3cfb7753074bc4c77926c0e7e48990/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f279e0d76e3cfb7753074bc4c77926c0e7e48990/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs?ref=f279e0d76e3cfb7753074bc4c77926c0e7e48990", "patch": "@@ -0,0 +1,24 @@\n+// xfail-stage0\n+// Tests that trans_path checks whether a\n+// pattern-bound var is an upvar (when translating\n+// the for-each body)\n+use std;\n+import std::option::*;\n+import std::uint;\n+\n+fn foo(uint src) {\n+\n+    alt (some(src)) {\n+        case (some(?src_id)) {\n+          for each (uint i in uint::range(0u, 10u)) {\n+            auto yyy = src_id;\n+            assert (yyy == 0u);\n+          }\n+        }\n+        case (_) {}\n+    }\n+}\n+\n+fn main() {\n+  foo(0u);\n+}"}]}