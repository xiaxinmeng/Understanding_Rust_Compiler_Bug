{"sha": "bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "node_id": "C_kwDOAAsO6NoAKGJkOWU2ZTA1ZDJkMTVlYTJhNDFlODkwYzVlM2VlOWNjYzdlNmNkNDg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-05T06:01:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-05T06:01:28Z"}, "message": "Rollup merge of #103660 - ozkanonur:master, r=jyn514\n\nimprove `filesearch::get_or_default_sysroot`\n\n`fn get_or_default_sysroot` is now improved and used in `miri` and `clippy`, and tests are still passing as they should. So we no longer need to implement custom workarounds/hacks to find sysroot in tools like miri/clippy.\n\nResolves https://github.com/rust-lang/rust/issues/98832\n\nre-opened from #103581", "tree": {"sha": "fed2e3e69f196ff95fdedb9ea4578f50ad639e2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fed2e3e69f196ff95fdedb9ea4578f50ad639e2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjZfw4CRBK7hj4Ov3rIwAAjY0IAIuhkVyEAbxqmNFOg6sKjdki\n+hTkMYihWh0xttgUfhPHqw9ShH+7wbmbAqM2UNIM99mqrgsI5DyGGnQCndJKz2fm\nOhmolWt2uGjheh8gVik3BAp/zH9kFfHDBASbr7+4aIwRhOEuL81qtQrb8+7GVS+7\nyJEnmWTDGcbixt6Xw1Otg896PbEFI/B3iA4C1Bjvj91AZCsiL4Dp7gi2oBl9RxWs\nf1Wwo167/m7heA5a5UrH6KB1Ytbptzw0Iz3lSWitvAZ66/ofGgL8DEG9+fYrbcX7\nLONselSM11b64gm6sk7CZoislN3/v7Gi7pSAFxeeGT0WCE0A49fNXJ86sf/cEO4=\n=F6ey\n-----END PGP SIGNATURE-----\n", "payload": "tree fed2e3e69f196ff95fdedb9ea4578f50ad639e2e\nparent 3450aa38d0af7264bb5eb5450880ab82e87b051f\nparent 71a3a48ee52a5cbc3fa3e3e8d322ebeb97ed109f\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1667628088 +0530\ncommitter GitHub <noreply@github.com> 1667628088 +0530\n\nRollup merge of #103660 - ozkanonur:master, r=jyn514\n\nimprove `filesearch::get_or_default_sysroot`\n\n`fn get_or_default_sysroot` is now improved and used in `miri` and `clippy`, and tests are still passing as they should. So we no longer need to implement custom workarounds/hacks to find sysroot in tools like miri/clippy.\n\nResolves https://github.com/rust-lang/rust/issues/98832\n\nre-opened from #103581\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "html_url": "https://github.com/rust-lang/rust/commit/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3450aa38d0af7264bb5eb5450880ab82e87b051f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3450aa38d0af7264bb5eb5450880ab82e87b051f", "html_url": "https://github.com/rust-lang/rust/commit/3450aa38d0af7264bb5eb5450880ab82e87b051f"}, {"sha": "71a3a48ee52a5cbc3fa3e3e8d322ebeb97ed109f", "url": "https://api.github.com/repos/rust-lang/rust/commits/71a3a48ee52a5cbc3fa3e3e8d322ebeb97ed109f", "html_url": "https://github.com/rust-lang/rust/commit/71a3a48ee52a5cbc3fa3e3e8d322ebeb97ed109f"}], "stats": {"total": 407, "additions": 152, "deletions": 255}, "files": [{"sha": "1948bc30e0a7a82f27775148d0299466a7a9ddc7", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -3664,7 +3664,6 @@ dependencies = [\n name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n- \"libc\",\n  \"libloading\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -3707,7 +3706,6 @@ dependencies = [\n  \"rustc_ty_utils\",\n  \"smallvec\",\n  \"tracing\",\n- \"winapi\",\n ]\n \n [[package]]\n@@ -4127,6 +4125,7 @@ name = \"rustc_session\"\n version = \"0.0.0\"\n dependencies = [\n  \"getopts\",\n+ \"libc\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -4138,7 +4137,9 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"smallvec\",\n  \"tracing\",\n+ \"winapi\",\n ]\n \n [[package]]"}, {"sha": "5a1ad792924fcf2ce45a784a9550e5af6d7603da", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -1123,7 +1123,8 @@ fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {\n         if path.exists() {\n             return session_tlib;\n         } else {\n-            let default_sysroot = filesearch::get_or_default_sysroot();\n+            let default_sysroot =\n+                filesearch::get_or_default_sysroot().expect(\"Failed finding sysroot\");\n             let default_tlib = filesearch::make_target_lib_path(\n                 &default_sysroot,\n                 sess.opts.target_triple.triple(),"}, {"sha": "2e526733df974b6e33a7c287505c46f200669f33", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -48,12 +48,6 @@ rustc_resolve = { path = \"../rustc_resolve\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n \n-[target.'cfg(unix)'.dependencies]\n-libc = \"0.2\"\n-\n-[target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"libloaderapi\"] }\n-\n [dev-dependencies]\n rustc_target = { path = \"../rustc_target\" }\n "}, {"sha": "62ee72f9883083185e691cae4e023eb319c0b25c", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 95, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -9,6 +9,7 @@ use rustc_session as session;\n use rustc_session::config::CheckCfg;\n use rustc_session::config::{self, CrateType};\n use rustc_session::config::{ErrorOutputType, Input, OutputFilenames};\n+use rustc_session::filesearch::sysroot_candidates;\n use rustc_session::lint::{self, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::CrateConfig;\n use rustc_session::{early_error, filesearch, output, Session};\n@@ -78,7 +79,7 @@ pub fn create_session(\n \n     let bundle = match rustc_errors::fluent_bundle(\n         sopts.maybe_sysroot.clone(),\n-        sysroot_candidates(),\n+        sysroot_candidates().to_vec(),\n         sopts.unstable_opts.translate_lang.clone(),\n         sopts.unstable_opts.translate_additional_ftl.as_deref(),\n         sopts.unstable_opts.translate_directionality_markers,\n@@ -273,100 +274,6 @@ fn get_rustc_path_inner(bin_path: &str) -> Option<PathBuf> {\n     })\n }\n \n-fn sysroot_candidates() -> Vec<PathBuf> {\n-    let target = session::config::host_triple();\n-    let mut sysroot_candidates = vec![filesearch::get_or_default_sysroot()];\n-    let path = current_dll_path().and_then(|s| s.canonicalize().ok());\n-    if let Some(dll) = path {\n-        // use `parent` twice to chop off the file name and then also the\n-        // directory containing the dll which should be either `lib` or `bin`.\n-        if let Some(path) = dll.parent().and_then(|p| p.parent()) {\n-            // The original `path` pointed at the `rustc_driver` crate's dll.\n-            // Now that dll should only be in one of two locations. The first is\n-            // in the compiler's libdir, for example `$sysroot/lib/*.dll`. The\n-            // other is the target's libdir, for example\n-            // `$sysroot/lib/rustlib/$target/lib/*.dll`.\n-            //\n-            // We don't know which, so let's assume that if our `path` above\n-            // ends in `$target` we *could* be in the target libdir, and always\n-            // assume that we may be in the main libdir.\n-            sysroot_candidates.push(path.to_owned());\n-\n-            if path.ends_with(target) {\n-                sysroot_candidates.extend(\n-                    path.parent() // chop off `$target`\n-                        .and_then(|p| p.parent()) // chop off `rustlib`\n-                        .and_then(|p| p.parent()) // chop off `lib`\n-                        .map(|s| s.to_owned()),\n-                );\n-            }\n-        }\n-    }\n-\n-    return sysroot_candidates;\n-\n-    #[cfg(unix)]\n-    fn current_dll_path() -> Option<PathBuf> {\n-        use std::ffi::{CStr, OsStr};\n-        use std::os::unix::prelude::*;\n-\n-        unsafe {\n-            let addr = current_dll_path as usize as *mut _;\n-            let mut info = mem::zeroed();\n-            if libc::dladdr(addr, &mut info) == 0 {\n-                info!(\"dladdr failed\");\n-                return None;\n-            }\n-            if info.dli_fname.is_null() {\n-                info!(\"dladdr returned null pointer\");\n-                return None;\n-            }\n-            let bytes = CStr::from_ptr(info.dli_fname).to_bytes();\n-            let os = OsStr::from_bytes(bytes);\n-            Some(PathBuf::from(os))\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn current_dll_path() -> Option<PathBuf> {\n-        use std::ffi::OsString;\n-        use std::io;\n-        use std::os::windows::prelude::*;\n-        use std::ptr;\n-\n-        use winapi::um::libloaderapi::{\n-            GetModuleFileNameW, GetModuleHandleExW, GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n-        };\n-\n-        unsafe {\n-            let mut module = ptr::null_mut();\n-            let r = GetModuleHandleExW(\n-                GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n-                current_dll_path as usize as *mut _,\n-                &mut module,\n-            );\n-            if r == 0 {\n-                info!(\"GetModuleHandleExW failed: {}\", io::Error::last_os_error());\n-                return None;\n-            }\n-            let mut space = Vec::with_capacity(1024);\n-            let r = GetModuleFileNameW(module, space.as_mut_ptr(), space.capacity() as u32);\n-            if r == 0 {\n-                info!(\"GetModuleFileNameW failed: {}\", io::Error::last_os_error());\n-                return None;\n-            }\n-            let r = r as usize;\n-            if r >= space.capacity() {\n-                info!(\"our buffer was too small? {}\", io::Error::last_os_error());\n-                return None;\n-            }\n-            space.set_len(r);\n-            let os = OsString::from_wide(&space);\n-            Some(PathBuf::from(os))\n-        }\n-    }\n-}\n-\n fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> MakeBackendFn {\n     // For now we only allow this function to be called once as it'll dlopen a\n     // few things, which seems to work best if we only do that once. In"}, {"sha": "a052f29334169ebd5d6478caf780b41fb8e4df0d", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -17,3 +17,10 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n+smallvec = \"1.8.1\"\n+\n+[target.'cfg(unix)'.dependencies]\n+libc = \"0.2\"\n+\n+[target.'cfg(windows)'.dependencies]\n+winapi = { version = \"0.3\", features = [\"libloaderapi\"] }"}, {"sha": "aece29ca0cbf6197f509e73e7596fc191c684ea7", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -2447,7 +2447,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let sysroot = match &sysroot_opt {\n         Some(s) => s,\n         None => {\n-            tmp_buf = crate::filesearch::get_or_default_sysroot();\n+            tmp_buf = crate::filesearch::get_or_default_sysroot().expect(\"Failed finding sysroot\");\n             &tmp_buf\n         }\n     };"}, {"sha": "1b66773be6f0804a02627989199547c8c6616769", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 120, "deletions": 16, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -1,5 +1,6 @@\n //! A module for searching for libraries\n \n+use smallvec::{smallvec, SmallVec};\n use std::env;\n use std::fs;\n use std::iter::FromIterator;\n@@ -62,9 +63,99 @@ pub fn make_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n     PathBuf::from_iter([sysroot, Path::new(&rustlib_path), Path::new(\"lib\")])\n }\n \n+#[cfg(unix)]\n+fn current_dll_path() -> Result<PathBuf, String> {\n+    use std::ffi::{CStr, OsStr};\n+    use std::os::unix::prelude::*;\n+\n+    unsafe {\n+        let addr = current_dll_path as usize as *mut _;\n+        let mut info = std::mem::zeroed();\n+        if libc::dladdr(addr, &mut info) == 0 {\n+            return Err(\"dladdr failed\".into());\n+        }\n+        if info.dli_fname.is_null() {\n+            return Err(\"dladdr returned null pointer\".into());\n+        }\n+        let bytes = CStr::from_ptr(info.dli_fname).to_bytes();\n+        let os = OsStr::from_bytes(bytes);\n+        Ok(PathBuf::from(os))\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn current_dll_path() -> Result<PathBuf, String> {\n+    use std::ffi::OsString;\n+    use std::io;\n+    use std::os::windows::prelude::*;\n+    use std::ptr;\n+\n+    use winapi::um::libloaderapi::{\n+        GetModuleFileNameW, GetModuleHandleExW, GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+    };\n+\n+    unsafe {\n+        let mut module = ptr::null_mut();\n+        let r = GetModuleHandleExW(\n+            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+            current_dll_path as usize as *mut _,\n+            &mut module,\n+        );\n+        if r == 0 {\n+            return Err(format!(\"GetModuleHandleExW failed: {}\", io::Error::last_os_error()));\n+        }\n+        let mut space = Vec::with_capacity(1024);\n+        let r = GetModuleFileNameW(module, space.as_mut_ptr(), space.capacity() as u32);\n+        if r == 0 {\n+            return Err(format!(\"GetModuleFileNameW failed: {}\", io::Error::last_os_error()));\n+        }\n+        let r = r as usize;\n+        if r >= space.capacity() {\n+            return Err(format!(\"our buffer was too small? {}\", io::Error::last_os_error()));\n+        }\n+        space.set_len(r);\n+        let os = OsString::from_wide(&space);\n+        Ok(PathBuf::from(os))\n+    }\n+}\n+\n+pub fn sysroot_candidates() -> SmallVec<[PathBuf; 2]> {\n+    let target = crate::config::host_triple();\n+    let mut sysroot_candidates: SmallVec<[PathBuf; 2]> =\n+        smallvec![get_or_default_sysroot().expect(\"Failed finding sysroot\")];\n+    let path = current_dll_path().and_then(|s| Ok(s.canonicalize().map_err(|e| e.to_string())?));\n+    if let Ok(dll) = path {\n+        // use `parent` twice to chop off the file name and then also the\n+        // directory containing the dll which should be either `lib` or `bin`.\n+        if let Some(path) = dll.parent().and_then(|p| p.parent()) {\n+            // The original `path` pointed at the `rustc_driver` crate's dll.\n+            // Now that dll should only be in one of two locations. The first is\n+            // in the compiler's libdir, for example `$sysroot/lib/*.dll`. The\n+            // other is the target's libdir, for example\n+            // `$sysroot/lib/rustlib/$target/lib/*.dll`.\n+            //\n+            // We don't know which, so let's assume that if our `path` above\n+            // ends in `$target` we *could* be in the target libdir, and always\n+            // assume that we may be in the main libdir.\n+            sysroot_candidates.push(path.to_owned());\n+\n+            if path.ends_with(target) {\n+                sysroot_candidates.extend(\n+                    path.parent() // chop off `$target`\n+                        .and_then(|p| p.parent()) // chop off `rustlib`\n+                        .and_then(|p| p.parent()) // chop off `lib`\n+                        .map(|s| s.to_owned()),\n+                );\n+            }\n+        }\n+    }\n+\n+    return sysroot_candidates;\n+}\n+\n /// This function checks if sysroot is found using env::args().next(), and if it\n-/// is not found, uses env::current_exe() to imply sysroot.\n-pub fn get_or_default_sysroot() -> PathBuf {\n+/// is not found, finds sysroot from current rustc_driver dll.\n+pub fn get_or_default_sysroot() -> Result<PathBuf, String> {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n     fn canonicalize(path: PathBuf) -> PathBuf {\n         let path = fs::canonicalize(&path).unwrap_or(path);\n@@ -74,17 +165,32 @@ pub fn get_or_default_sysroot() -> PathBuf {\n         fix_windows_verbatim_for_gcc(&path)\n     }\n \n-    // Use env::current_exe() to get the path of the executable following\n-    // symlinks/canonicalizing components.\n-    fn from_current_exe() -> PathBuf {\n-        match env::current_exe() {\n-            Ok(exe) => {\n-                let mut p = canonicalize(exe);\n-                p.pop();\n-                p.pop();\n-                p\n-            }\n-            Err(e) => panic!(\"failed to get current_exe: {e}\"),\n+    fn default_from_rustc_driver_dll() -> Result<PathBuf, String> {\n+        let dll = current_dll_path().and_then(|s| Ok(canonicalize(s)))?;\n+\n+        // `dll` will be in one of the following two:\n+        // - compiler's libdir: $sysroot/lib/*.dll\n+        // - target's libdir: $sysroot/lib/rustlib/$target/lib/*.dll\n+        //\n+        // use `parent` twice to chop off the file name and then also the\n+        // directory containing the dll\n+        let dir = dll.parent().and_then(|p| p.parent()).ok_or(format!(\n+            \"Could not move 2 levels upper using `parent()` on {}\",\n+            dll.display()\n+        ))?;\n+\n+        // if `dir` points target's dir, move up to the sysroot\n+        if dir.ends_with(crate::config::host_triple()) {\n+            dir.parent() // chop off `$target`\n+                .and_then(|p| p.parent()) // chop off `rustlib`\n+                .and_then(|p| p.parent()) // chop off `lib`\n+                .map(|s| s.to_owned())\n+                .ok_or(format!(\n+                    \"Could not move 3 levels upper using `parent()` on {}\",\n+                    dir.display()\n+                ))\n+        } else {\n+            Ok(dir.to_owned())\n         }\n     }\n \n@@ -118,7 +224,5 @@ pub fn get_or_default_sysroot() -> PathBuf {\n         }\n     }\n \n-    // Check if sysroot is found using env::args().next(), and if is not found,\n-    // use env::current_exe() to imply sysroot.\n-    from_env_args_next().unwrap_or_else(from_current_exe)\n+    Ok(from_env_args_next().unwrap_or(default_from_rustc_driver_dll()?))\n }"}, {"sha": "103521983578bc4d8670429afd93e6c3dde5cb6e", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -1309,7 +1309,7 @@ pub fn build_session(\n \n     let sysroot = match &sopts.maybe_sysroot {\n         Some(sysroot) => sysroot.clone(),\n-        None => filesearch::get_or_default_sysroot(),\n+        None => filesearch::get_or_default_sysroot().expect(\"Failed finding sysroot\"),\n     };\n \n     let target_cfg = config::build_target_config(&sopts, target_override, &sysroot);"}, {"sha": "f24d3507823ecaf9d8ae0e32e9124bdbb0ffb320", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 5, "deletions": 74, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -23,8 +23,8 @@ use std::borrow::Cow;\n use std::env;\n use std::ops::Deref;\n use std::panic;\n-use std::path::{Path, PathBuf};\n-use std::process::{exit, Command};\n+use std::path::Path;\n+use std::process::exit;\n use std::sync::LazyLock;\n \n /// If a command-line option matches `find_arg`, then apply the predicate `pred` on its value. If\n@@ -210,83 +210,21 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     interface::try_print_query_stack(&handler, num_frames);\n }\n \n-fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<PathBuf> {\n-    home.and_then(|home| {\n-        toolchain.map(|toolchain| {\n-            let mut path = PathBuf::from(home);\n-            path.push(\"toolchains\");\n-            path.push(toolchain);\n-            path\n-        })\n-    })\n-}\n-\n #[allow(clippy::too_many_lines)]\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n     LazyLock::force(&ICE_HOOK);\n     exit(rustc_driver::catch_with_exit_code(move || {\n         let mut orig_args: Vec<String> = env::args().collect();\n \n-        // Get the sysroot, looking from most specific to this invocation to the least:\n-        // - command line\n-        // - runtime environment\n-        //    - SYSROOT\n-        //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n-        // - sysroot from rustc in the path\n-        // - compile-time environment\n-        //    - SYSROOT\n-        //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n-        let sys_root_arg = arg_value(&orig_args, \"--sysroot\", |_| true);\n-        let have_sys_root_arg = sys_root_arg.is_some();\n-        let sys_root = sys_root_arg\n-            .map(PathBuf::from)\n-            .or_else(|| std::env::var(\"SYSROOT\").ok().map(PathBuf::from))\n-            .or_else(|| {\n-                let home = std::env::var(\"RUSTUP_HOME\")\n-                    .or_else(|_| std::env::var(\"MULTIRUST_HOME\"))\n-                    .ok();\n-                let toolchain = std::env::var(\"RUSTUP_TOOLCHAIN\")\n-                    .or_else(|_| std::env::var(\"MULTIRUST_TOOLCHAIN\"))\n-                    .ok();\n-                toolchain_path(home, toolchain)\n-            })\n-            .or_else(|| {\n-                Command::new(\"rustc\")\n-                    .arg(\"--print\")\n-                    .arg(\"sysroot\")\n-                    .output()\n-                    .ok()\n-                    .and_then(|out| String::from_utf8(out.stdout).ok())\n-                    .map(|s| PathBuf::from(s.trim()))\n-            })\n-            .or_else(|| option_env!(\"SYSROOT\").map(PathBuf::from))\n-            .or_else(|| {\n-                let home = option_env!(\"RUSTUP_HOME\")\n-                    .or(option_env!(\"MULTIRUST_HOME\"))\n-                    .map(ToString::to_string);\n-                let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\")\n-                    .or(option_env!(\"MULTIRUST_TOOLCHAIN\"))\n-                    .map(ToString::to_string);\n-                toolchain_path(home, toolchain)\n-            })\n-            .map(|pb| pb.to_string_lossy().to_string())\n-            .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\");\n-\n         // make \"clippy-driver --rustc\" work like a subcommand that passes further args to \"rustc\"\n         // for example `clippy-driver --rustc --version` will print the rustc version that clippy-driver\n         // uses\n         if let Some(pos) = orig_args.iter().position(|arg| arg == \"--rustc\") {\n             orig_args.remove(pos);\n             orig_args[0] = \"rustc\".to_string();\n \n-            // if we call \"rustc\", we need to pass --sysroot here as well\n-            let mut args: Vec<String> = orig_args.clone();\n-            if !have_sys_root_arg {\n-                args.extend(vec![\"--sysroot\".into(), sys_root]);\n-            };\n-\n-            return rustc_driver::RunCompiler::new(&args, &mut DefaultCallbacks).run();\n+            return rustc_driver::RunCompiler::new(&orig_args, &mut DefaultCallbacks).run();\n         }\n \n         if orig_args.iter().any(|a| a == \"--version\" || a == \"-V\") {\n@@ -309,14 +247,6 @@ pub fn main() {\n             exit(0);\n         }\n \n-        // this conditional check for the --sysroot flag is there so users can call\n-        // `clippy_driver` directly\n-        // without having to pass --sysroot or anything\n-        let mut args: Vec<String> = orig_args.clone();\n-        if !have_sys_root_arg {\n-            args.extend(vec![\"--sysroot\".into(), sys_root]);\n-        };\n-\n         let mut no_deps = false;\n         let clippy_args_var = env::var(\"CLIPPY_ARGS\").ok();\n         let clippy_args = clippy_args_var\n@@ -345,10 +275,11 @@ pub fn main() {\n \n         let clippy_enabled = !cap_lints_allow && (!no_deps || in_primary_package);\n         if clippy_enabled {\n+            let mut args: Vec<String> = orig_args.clone();\n             args.extend(clippy_args);\n             rustc_driver::RunCompiler::new(&args, &mut ClippyCallbacks { clippy_args_var }).run()\n         } else {\n-            rustc_driver::RunCompiler::new(&args, &mut RustcCallbacks { clippy_args_var }).run()\n+            rustc_driver::RunCompiler::new(&orig_args, &mut RustcCallbacks { clippy_args_var }).run()\n         }\n     }))\n }"}, {"sha": "e673ea67dbc5bbf32c8ae1bd238f4317e1e21004", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 11, "deletions": 59, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=bd9e6e05d2d15ea2a41e890c5e3ee9ccc7e6cd48", "patch": "@@ -216,76 +216,28 @@ fn init_late_loggers(tcx: TyCtxt<'_>) {\n     }\n }\n \n-/// Returns the \"default sysroot\" that Miri will use for host things if no `--sysroot` flag is set.\n-/// Should be a compile-time constant.\n-fn host_sysroot() -> Option<String> {\n-    if option_env!(\"RUSTC_STAGE\").is_some() {\n-        // This is being built as part of rustc, and gets shipped with rustup.\n-        // We can rely on the sysroot computation in librustc_session.\n-        return None;\n-    }\n-    // For builds outside rustc, we need to ensure that we got a sysroot\n-    // that gets used as a default.  The sysroot computation in librustc_session would\n-    // end up somewhere in the build dir (see `get_or_default_sysroot`).\n-    // Taken from PR <https://github.com/Manishearth/rust-clippy/pull/911>.\n-    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n-    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n-    Some(match (home, toolchain) {\n-        (Some(home), Some(toolchain)) => {\n-            // Check that at runtime, we are still in this toolchain (if there is any toolchain).\n-            if let Some(toolchain_runtime) =\n-                env::var_os(\"RUSTUP_TOOLCHAIN\").or_else(|| env::var_os(\"MULTIRUST_TOOLCHAIN\"))\n-            {\n-                if toolchain_runtime != toolchain {\n-                    show_error!(\n-                        \"This Miri got built with local toolchain `{toolchain}`, but now is being run under a different toolchain. \\n\\\n-                        Make sure to run Miri in the toolchain it got built with, e.g. via `cargo +{toolchain} miri`.\"\n-                    )\n-                }\n-            }\n-            format!(\"{home}/toolchains/{toolchain}\")\n-        }\n-        _ => option_env!(\"RUST_SYSROOT\")\n-            .unwrap_or_else(|| {\n-                show_error!(\n-                    \"To build Miri without rustup, set the `RUST_SYSROOT` env var at build time\",\n-                )\n-            })\n-            .to_owned(),\n-    })\n-}\n-\n /// Execute a compiler with the given CLI arguments and callbacks.\n fn run_compiler(\n     mut args: Vec<String>,\n     target_crate: bool,\n     callbacks: &mut (dyn rustc_driver::Callbacks + Send),\n ) -> ! {\n-    // Make sure we use the right default sysroot. The default sysroot is wrong,\n-    // because `get_or_default_sysroot` in `librustc_session` bases that on `current_exe`.\n-    //\n-    // Make sure we always call `host_sysroot` as that also does some sanity-checks\n-    // of the environment we were built in and whether it matches what we are running in.\n-    let host_default_sysroot = host_sysroot();\n-    // Now see if we even need to set something.\n-    let sysroot_flag = \"--sysroot\";\n-    if !args.iter().any(|e| e == sysroot_flag) {\n-        // No sysroot was set, let's see if we have a custom default we want to configure.\n-        let default_sysroot = if target_crate {\n+    if target_crate {\n+        // Miri needs a custom sysroot for target crates.\n+        // If no `--sysroot` is given, the `MIRI_SYSROOT` env var is consulted to find where\n+        // that sysroot lives, and that is passed to rustc.\n+        let sysroot_flag = \"--sysroot\";\n+        if !args.iter().any(|e| e == sysroot_flag) {\n             // Using the built-in default here would be plain wrong, so we *require*\n             // the env var to make sure things make sense.\n-            Some(env::var(\"MIRI_SYSROOT\").unwrap_or_else(|_| {\n+            let miri_sysroot = env::var(\"MIRI_SYSROOT\").unwrap_or_else(|_| {\n                 show_error!(\n                     \"Miri was invoked in 'target' mode without `MIRI_SYSROOT` or `--sysroot` being set\"\n-                )\n-            }))\n-        } else {\n-            host_default_sysroot\n-        };\n-        if let Some(sysroot) = default_sysroot {\n-            // We need to overwrite the default that librustc_session would compute.\n+                    )\n+            });\n+\n             args.push(sysroot_flag.to_owned());\n-            args.push(sysroot);\n+            args.push(miri_sysroot);\n         }\n     }\n "}]}