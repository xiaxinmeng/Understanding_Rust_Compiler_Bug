{"sha": "000b36c505a8865322c376486791cdee8f38d0c5", "node_id": "C_kwDOAAsO6NoAKDAwMGIzNmM1MDVhODg2NTMyMmMzNzY0ODY3OTFjZGVlOGYzOGQwYzU", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-01-12T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-01-12T17:51:31Z"}, "message": "Remove deprecated LLVM-style inline assembly", "tree": {"sha": "3efb3d84c08ebe0f3d2e43eeeac59dbc5f79b0b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3efb3d84c08ebe0f3d2e43eeeac59dbc5f79b0b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/000b36c505a8865322c376486791cdee8f38d0c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/000b36c505a8865322c376486791cdee8f38d0c5", "html_url": "https://github.com/rust-lang/rust/commit/000b36c505a8865322c376486791cdee8f38d0c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/000b36c505a8865322c376486791cdee8f38d0c5/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72e74d7b9cf1a7901650227e74650f1fcc797600", "url": "https://api.github.com/repos/rust-lang/rust/commits/72e74d7b9cf1a7901650227e74650f1fcc797600", "html_url": "https://github.com/rust-lang/rust/commit/72e74d7b9cf1a7901650227e74650f1fcc797600"}], "stats": {"total": 1159, "additions": 27, "deletions": 1132}, "files": [{"sha": "079b9e43373fa4847b9f6941e5bd0285843e0e2e", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1266,7 +1266,7 @@ impl Expr {\n             ExprKind::Break(..) => ExprPrecedence::Break,\n             ExprKind::Continue(..) => ExprPrecedence::Continue,\n             ExprKind::Ret(..) => ExprPrecedence::Ret,\n-            ExprKind::InlineAsm(..) | ExprKind::LlvmInlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n             ExprKind::MacCall(..) => ExprPrecedence::Mac,\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n@@ -1423,8 +1423,6 @@ pub enum ExprKind {\n \n     /// Output of the `asm!()` macro.\n     InlineAsm(P<InlineAsm>),\n-    /// Output of the `llvm_asm!()` macro.\n-    LlvmInlineAsm(P<LlvmInlineAsm>),\n \n     /// A macro invocation; pre-expansion.\n     MacCall(MacCall),\n@@ -2076,41 +2074,6 @@ pub struct InlineAsm {\n     pub line_spans: Vec<Span>,\n }\n \n-/// Inline assembly dialect.\n-///\n-/// E.g., `\"intel\"` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`.\n-#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy, Hash, HashStable_Generic)]\n-pub enum LlvmAsmDialect {\n-    Att,\n-    Intel,\n-}\n-\n-/// LLVM-style inline assembly.\n-///\n-/// E.g., `\"={eax}\"(result)` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`.\n-#[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct LlvmInlineAsmOutput {\n-    pub constraint: Symbol,\n-    pub expr: P<Expr>,\n-    pub is_rw: bool,\n-    pub is_indirect: bool,\n-}\n-\n-/// LLVM-style inline assembly.\n-///\n-/// E.g., `llvm_asm!(\"NOP\");`.\n-#[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct LlvmInlineAsm {\n-    pub asm: Symbol,\n-    pub asm_str_style: StrStyle,\n-    pub outputs: Vec<LlvmInlineAsmOutput>,\n-    pub inputs: Vec<(Symbol, P<Expr>)>,\n-    pub clobbers: Vec<Symbol>,\n-    pub volatile: bool,\n-    pub alignstack: bool,\n-    pub dialect: LlvmAsmDialect,\n-}\n-\n /// A parameter in a function header.\n ///\n /// E.g., `bar: usize` as in `fn foo(bar: usize)`."}, {"sha": "564a8a8c8729eba2a7ed09f2664f17ca23541bff", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1350,23 +1350,6 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n         ExprKind::InlineAsm(asm) => noop_visit_inline_asm(asm, vis),\n-        ExprKind::LlvmInlineAsm(asm) => {\n-            let LlvmInlineAsm {\n-                asm: _,\n-                asm_str_style: _,\n-                outputs,\n-                inputs,\n-                clobbers: _,\n-                volatile: _,\n-                alignstack: _,\n-                dialect: _,\n-            } = asm.deref_mut();\n-            for out in outputs {\n-                let LlvmInlineAsmOutput { constraint: _, expr, is_rw: _, is_indirect: _ } = out;\n-                vis.visit_expr(expr);\n-            }\n-            visit_vec(inputs, |(_c, expr)| vis.visit_expr(expr));\n-        }\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(se) => {\n             let StructExpr { qself, path, fields, rest } = se.deref_mut();"}, {"sha": "0b95270a4e1ef25804269c7f0de8577f17ca92dd", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -864,14 +864,6 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n         ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::InlineAsm(ref asm) => walk_inline_asm(visitor, asm),\n-        ExprKind::LlvmInlineAsm(ref ia) => {\n-            for &(_, ref input) in &ia.inputs {\n-                visitor.visit_expr(input)\n-            }\n-            for output in &ia.outputs {\n-                visitor.visit_expr(&output.expr)\n-            }\n-        }\n         ExprKind::Yield(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }"}, {"sha": "15bf1a5a2ab73a24ff5783154de52075e5c16203", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -226,7 +226,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::InlineAsm(ref asm) => {\n                     hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n                 }\n-                ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_llvm_asm(asm),\n                 ExprKind::Struct(ref se) => {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n@@ -1284,38 +1283,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         result\n     }\n \n-    fn lower_expr_llvm_asm(&mut self, asm: &LlvmInlineAsm) -> hir::ExprKind<'hir> {\n-        let inner = hir::LlvmInlineAsmInner {\n-            inputs: asm.inputs.iter().map(|&(c, _)| c).collect(),\n-            outputs: asm\n-                .outputs\n-                .iter()\n-                .map(|out| hir::LlvmInlineAsmOutput {\n-                    constraint: out.constraint,\n-                    is_rw: out.is_rw,\n-                    is_indirect: out.is_indirect,\n-                    span: self.lower_span(out.expr.span),\n-                })\n-                .collect(),\n-            asm: asm.asm,\n-            asm_str_style: asm.asm_str_style,\n-            clobbers: asm.clobbers.clone(),\n-            volatile: asm.volatile,\n-            alignstack: asm.alignstack,\n-            dialect: asm.dialect,\n-        };\n-        let hir_asm = hir::LlvmInlineAsm {\n-            inner,\n-            inputs_exprs: self.arena.alloc_from_iter(\n-                asm.inputs.iter().map(|&(_, ref input)| self.lower_expr_mut(input)),\n-            ),\n-            outputs_exprs: self\n-                .arena\n-                .alloc_from_iter(asm.outputs.iter().map(|out| self.lower_expr_mut(&out.expr))),\n-        };\n-        hir::ExprKind::LlvmInlineAsm(self.arena.alloc(hir_asm))\n-    }\n-\n     fn lower_expr_field(&mut self, f: &ExprField) -> hir::ExprField<'hir> {\n         hir::ExprField {\n             hir_id: self.next_id(),"}, {"sha": "45920bb27d5b6dab93cb7262ddca99da301dea35", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -960,15 +960,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 return;\n             }\n             ExprKind::Let(..) if !let_allowed => this.ban_let_expr(expr),\n-            ExprKind::LlvmInlineAsm(..) if !this.session.target.allow_asm => {\n-                struct_span_err!(\n-                    this.session,\n-                    expr.span,\n-                    E0472,\n-                    \"llvm_asm! is unsupported on this target\"\n-                )\n-                .emit();\n-            }\n             ExprKind::Match(expr, arms) => {\n                 this.visit_expr(expr);\n                 for arm in arms {"}, {"sha": "f4fc2789d9e9001d5fc9fb0fa92443202eb9d649", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -2168,62 +2168,6 @@ impl<'a> State<'a> {\n                 self.word(\"asm!\");\n                 self.print_inline_asm(a);\n             }\n-            ast::ExprKind::LlvmInlineAsm(ref a) => {\n-                self.word(\"llvm_asm!\");\n-                self.popen();\n-                self.print_symbol(a.asm, a.asm_str_style);\n-                self.word_space(\":\");\n-\n-                self.commasep(Inconsistent, &a.outputs, |s, out| {\n-                    let constraint = out.constraint.as_str();\n-                    let mut ch = constraint.chars();\n-                    match ch.next() {\n-                        Some('=') if out.is_rw => {\n-                            s.print_string(&format!(\"+{}\", ch.as_str()), ast::StrStyle::Cooked)\n-                        }\n-                        _ => s.print_string(&constraint, ast::StrStyle::Cooked),\n-                    }\n-                    s.popen();\n-                    s.print_expr(&out.expr);\n-                    s.pclose();\n-                });\n-                self.space();\n-                self.word_space(\":\");\n-\n-                self.commasep(Inconsistent, &a.inputs, |s, &(co, ref o)| {\n-                    s.print_symbol(co, ast::StrStyle::Cooked);\n-                    s.popen();\n-                    s.print_expr(o);\n-                    s.pclose();\n-                });\n-                self.space();\n-                self.word_space(\":\");\n-\n-                self.commasep(Inconsistent, &a.clobbers, |s, &co| {\n-                    s.print_symbol(co, ast::StrStyle::Cooked);\n-                });\n-\n-                let mut options = vec![];\n-                if a.volatile {\n-                    options.push(\"volatile\");\n-                }\n-                if a.alignstack {\n-                    options.push(\"alignstack\");\n-                }\n-                if a.dialect == ast::LlvmAsmDialect::Intel {\n-                    options.push(\"intel\");\n-                }\n-\n-                if !options.is_empty() {\n-                    self.space();\n-                    self.word_space(\":\");\n-                    self.commasep(Inconsistent, &options, |s, &co| {\n-                        s.print_string(co, ast::StrStyle::Cooked);\n-                    });\n-                }\n-\n-                self.pclose();\n-            }\n             ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n             ast::ExprKind::Paren(ref e) => {\n                 self.popen();"}, {"sha": "f0036f09c3881fccb3af7fccd7025e3b68c70db0", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -8,7 +8,6 @@ use rustc_mir_dataflow::ResultsVisitable;\n use rustc_mir_dataflow::{self, fmt::DebugWithContext, CallReturnPlaces, GenKill};\n use rustc_mir_dataflow::{Analysis, Direction, Results};\n use std::fmt;\n-use std::iter;\n \n use crate::{\n     places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext, ToRegionVid,\n@@ -385,14 +384,6 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n                 self.kill_borrows_on_place(trans, Place::from(local));\n             }\n \n-            mir::StatementKind::LlvmInlineAsm(ref asm) => {\n-                for (output, kind) in iter::zip(&*asm.outputs, &asm.asm.outputs) {\n-                    if !kind.is_indirect && !kind.is_rw {\n-                        self.kill_borrows_on_place(trans, *output);\n-                    }\n-                }\n-            }\n-\n             mir::StatementKind::FakeRead(..)\n             | mir::StatementKind::SetDiscriminant { .. }\n             | mir::StatementKind::StorageLive(..)"}, {"sha": "eec994f88b96e3500ab57a9f125e8f243a92ecc5", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -16,9 +16,6 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n \n         PlaceContext::MutatingUse(MutatingUseContext::Store) |\n \n-        // This is potentially both a def and a use...\n-        PlaceContext::MutatingUse(MutatingUseContext::LlvmAsmOutput) |\n-\n         // We let Call define the result in both the success and\n         // unwind cases. This is not really correct, however it\n         // does not seem to be observable due to the way that we"}, {"sha": "820fc2e7e4a0744067dfdf0a9d6c628797c6cfce", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -5,12 +5,11 @@ use rustc_middle::mir::{BorrowKind, Mutability, Operand};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::mir::{Statement, StatementKind};\n use rustc_middle::ty::TyCtxt;\n-use std::iter;\n \n use crate::{\n     borrow_set::BorrowSet, facts::AllFacts, location::LocationTable, path_utils::*, AccessDepth,\n     Activation, ArtificialField, BorrowIndex, Deep, JustWrite, LocalMutationIsAllowed, MutateMode,\n-    Read, ReadKind, ReadOrWrite, Reservation, Shallow, Write, WriteAndRead, WriteKind,\n+    Read, ReadKind, ReadOrWrite, Reservation, Shallow, Write, WriteKind,\n };\n \n pub(super) fn generate_invalidates<'tcx>(\n@@ -67,30 +66,6 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             StatementKind::SetDiscriminant { place, variant_index: _ } => {\n                 self.mutate_place(location, **place, Shallow(None), JustWrite);\n             }\n-            StatementKind::LlvmInlineAsm(asm) => {\n-                for (o, output) in iter::zip(&asm.asm.outputs, &*asm.outputs) {\n-                    if o.is_indirect {\n-                        // FIXME(eddyb) indirect inline asm outputs should\n-                        // be encoded through MIR place derefs instead.\n-                        self.access_place(\n-                            location,\n-                            *output,\n-                            (Deep, Read(ReadKind::Copy)),\n-                            LocalMutationIsAllowed::No,\n-                        );\n-                    } else {\n-                        self.mutate_place(\n-                            location,\n-                            *output,\n-                            if o.is_rw { Deep } else { Shallow(None) },\n-                            if o.is_rw { WriteAndRead } else { JustWrite },\n-                        );\n-                    }\n-                }\n-                for (_, input) in asm.inputs.iter() {\n-                    self.consume_operand(location, input);\n-                }\n-            }\n             StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n                 ref src,\n                 ref dst,"}, {"sha": "c9fc7b690c1b59015db97300f3823e3e1ae93031", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -40,7 +40,6 @@ use either::Either;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n-use std::iter;\n use std::mem;\n use std::rc::Rc;\n \n@@ -55,7 +54,7 @@ use rustc_mir_dataflow::MoveDataParamEnv;\n use self::diagnostics::{AccessKind, RegionName};\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n-use self::MutateMode::{JustWrite, WriteAndRead};\n+use self::MutateMode::JustWrite;\n use facts::AllFacts;\n \n use self::path_utils::*;\n@@ -653,39 +652,6 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             StatementKind::SetDiscriminant { place, variant_index: _ } => {\n                 self.mutate_place(location, (**place, span), Shallow(None), JustWrite, flow_state);\n             }\n-            StatementKind::LlvmInlineAsm(ref asm) => {\n-                for (o, output) in iter::zip(&asm.asm.outputs, &*asm.outputs) {\n-                    if o.is_indirect {\n-                        // FIXME(eddyb) indirect inline asm outputs should\n-                        // be encoded through MIR place derefs instead.\n-                        self.access_place(\n-                            location,\n-                            (*output, o.span),\n-                            (Deep, Read(ReadKind::Copy)),\n-                            LocalMutationIsAllowed::No,\n-                            flow_state,\n-                        );\n-                        self.check_if_path_or_subpath_is_moved(\n-                            location,\n-                            InitializationRequiringAction::Use,\n-                            (output.as_ref(), o.span),\n-                            flow_state,\n-                        );\n-                    } else {\n-                        self.mutate_place(\n-                            location,\n-                            (*output, o.span),\n-                            if o.is_rw { Deep } else { Shallow(None) },\n-                            if o.is_rw { WriteAndRead } else { JustWrite },\n-                            flow_state,\n-                        );\n-                    }\n-                }\n-                for (_, input) in asm.inputs.iter() {\n-                    self.consume_operand(location, (input, span), flow_state);\n-                }\n-            }\n-\n             StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n                 ..\n             }) => {"}, {"sha": "a58d506eebb3de5460258f10661d8a7cf1bbc1e2", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1477,7 +1477,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             StatementKind::FakeRead(..)\n             | StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)\n-            | StatementKind::LlvmInlineAsm { .. }\n             | StatementKind::Retag { .. }\n             | StatementKind::Coverage(..)\n             | StatementKind::Nop => {}"}, {"sha": "304c74e6326af30a03c10e195cb6f32eeecf4b37", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -50,15 +50,6 @@ pub fn parse_asm_args<'a>(\n         return Err(diag.struct_span_err(sp, \"requires at least a template string argument\"));\n     }\n \n-    // Detect use of the legacy llvm_asm! syntax (which used to be called asm!)\n-    if !is_global_asm && p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n-        let mut err =\n-            diag.struct_span_err(sp, \"the legacy LLVM-style asm! syntax is no longer supported\");\n-        err.note(\"consider migrating to the new asm! syntax specified in RFC 2873\");\n-        err.note(\"alternatively, switch to llvm_asm! to keep your code working as it is\");\n-        return Err(err);\n-    }\n-\n     let first_template = p.parse_expr()?;\n     let mut args = AsmArgs {\n         templates: vec![first_template],"}, {"sha": "65f785b9097e72f0bd7e1506e2c57cdb40445219", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -33,7 +33,6 @@ mod env;\n mod format;\n mod format_foreign;\n mod global_allocator;\n-mod llvm_asm;\n mod log_syntax;\n mod panic;\n mod source_util;\n@@ -78,7 +77,6 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n         include_str: source_util::expand_include_str,\n         include: source_util::expand_include,\n         line: source_util::expand_line,\n-        llvm_asm: llvm_asm::expand_llvm_asm,\n         log_syntax: log_syntax::expand_log_syntax,\n         module_path: source_util::expand_mod,\n         option_env: env::expand_option_env,"}, {"sha": "d72bfa660e58f855725ff145087abd63b2181af3", "filename": "compiler/rustc_builtin_macros/src/llvm_asm.rs", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/72e74d7b9cf1a7901650227e74650f1fcc797600/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72e74d7b9cf1a7901650227e74650f1fcc797600/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs?ref=72e74d7b9cf1a7901650227e74650f1fcc797600", "patch": "@@ -1,303 +0,0 @@\n-// Llvm-style inline assembly support.\n-//\n-use State::*;\n-\n-use rustc_ast as ast;\n-use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, Token};\n-use rustc_ast::tokenstream::{self, TokenStream};\n-use rustc_ast::LlvmAsmDialect;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, PResult};\n-use rustc_expand::base::*;\n-use rustc_parse::parser::Parser;\n-use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::Span;\n-\n-enum State {\n-    Asm,\n-    Outputs,\n-    Inputs,\n-    Clobbers,\n-    Options,\n-    StateNone,\n-}\n-\n-impl State {\n-    fn next(&self) -> State {\n-        match *self {\n-            Asm => Outputs,\n-            Outputs => Inputs,\n-            Inputs => Clobbers,\n-            Clobbers => Options,\n-            Options => StateNone,\n-            StateNone => StateNone,\n-        }\n-    }\n-}\n-\n-const OPTIONS: &[Symbol] = &[sym::volatile, sym::alignstack, sym::intel];\n-\n-pub fn expand_llvm_asm<'cx>(\n-    cx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Box<dyn MacResult + 'cx> {\n-    let mut inline_asm = match parse_inline_asm(cx, sp, tts) {\n-        Ok(Some(inline_asm)) => inline_asm,\n-        Ok(None) => return DummyResult::any(sp),\n-        Err(mut err) => {\n-            err.emit();\n-            return DummyResult::any(sp);\n-        }\n-    };\n-\n-    // If there are no outputs, the inline assembly is executed just for its side effects,\n-    // so ensure that it is volatile\n-    if inline_asm.outputs.is_empty() {\n-        inline_asm.volatile = true;\n-    }\n-\n-    MacEager::expr(P(ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        kind: ast::ExprKind::LlvmInlineAsm(P(inline_asm)),\n-        span: cx.with_def_site_ctxt(sp),\n-        attrs: ast::AttrVec::new(),\n-        tokens: None,\n-    }))\n-}\n-\n-fn parse_asm_str<'a>(p: &mut Parser<'a>) -> PResult<'a, Symbol> {\n-    match p.parse_str_lit() {\n-        Ok(str_lit) => Ok(str_lit.symbol_unescaped),\n-        Err(opt_lit) => {\n-            let span = opt_lit.map_or(p.token.span, |lit| lit.span);\n-            let mut err = p.sess.span_diagnostic.struct_span_err(span, \"expected string literal\");\n-            err.span_label(span, \"not a string literal\");\n-            Err(err)\n-        }\n-    }\n-}\n-\n-fn parse_inline_asm<'a>(\n-    cx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Result<Option<ast::LlvmInlineAsm>, DiagnosticBuilder<'a>> {\n-    // Split the tts before the first colon, to avoid `llvm_asm!(\"x\": y)`  being\n-    // parsed as `llvm_asm!(z)` with `z = \"x\": y` which is type ascription.\n-    let first_colon = tts\n-        .trees()\n-        .position(|tt| {\n-            matches!(\n-                tt,\n-                tokenstream::TokenTree::Token(Token { kind: token::Colon | token::ModSep, .. })\n-            )\n-        })\n-        .unwrap_or(tts.len());\n-    let mut p = cx.new_parser_from_tts(tts.trees().skip(first_colon).collect());\n-    let mut asm = kw::Empty;\n-    let mut asm_str_style = None;\n-    let mut outputs = Vec::new();\n-    let mut inputs = Vec::new();\n-    let mut clobs = Vec::new();\n-    let mut volatile = false;\n-    let mut alignstack = false;\n-    let mut dialect = LlvmAsmDialect::Att;\n-\n-    let mut state = Asm;\n-\n-    'statement: loop {\n-        match state {\n-            Asm => {\n-                if asm_str_style.is_some() {\n-                    // If we already have a string with instructions,\n-                    // ending up in Asm state again is an error.\n-                    return Err(struct_span_err!(\n-                        cx.sess.parse_sess.span_diagnostic,\n-                        sp,\n-                        E0660,\n-                        \"malformed inline assembly\"\n-                    ));\n-                }\n-                // Nested parser, stop before the first colon (see above).\n-                let mut p2 = cx.new_parser_from_tts(tts.trees().take(first_colon).collect());\n-\n-                if p2.token == token::Eof {\n-                    let mut err =\n-                        cx.struct_span_err(sp, \"macro requires a string literal as an argument\");\n-                    err.span_label(sp, \"string literal required\");\n-                    return Err(err);\n-                }\n-\n-                let expr = p2.parse_expr()?;\n-                let (s, style) =\n-                    match expr_to_string(cx, expr, \"inline assembly must be a string literal\") {\n-                        Some((s, st)) => (s, st),\n-                        None => return Ok(None),\n-                    };\n-\n-                // This is most likely malformed.\n-                if p2.token != token::Eof {\n-                    let mut extra_tts = p2.parse_all_token_trees()?;\n-                    extra_tts.extend(tts.trees().skip(first_colon));\n-                    p = cx.new_parser_from_tts(extra_tts.into_iter().collect());\n-                }\n-\n-                asm = s;\n-                asm_str_style = Some(style);\n-            }\n-            Outputs => {\n-                while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n-                    if !outputs.is_empty() {\n-                        p.eat(&token::Comma);\n-                    }\n-\n-                    let constraint = parse_asm_str(&mut p)?;\n-\n-                    let span = p.prev_token.span;\n-\n-                    p.expect(&token::OpenDelim(token::Paren))?;\n-                    let expr = p.parse_expr()?;\n-                    p.expect(&token::CloseDelim(token::Paren))?;\n-\n-                    // Expands a read+write operand into two operands.\n-                    //\n-                    // Use '+' modifier when you want the same expression\n-                    // to be both an input and an output at the same time.\n-                    // It's the opposite of '=&' which means that the memory\n-                    // cannot be shared with any other operand (usually when\n-                    // a register is clobbered early.)\n-                    let constraint_str = constraint.as_str();\n-                    let mut ch = constraint_str.chars();\n-                    let output = match ch.next() {\n-                        Some('=') => None,\n-                        Some('+') => Some(Symbol::intern(&format!(\"={}\", ch.as_str()))),\n-                        _ => {\n-                            struct_span_err!(\n-                                cx.sess.parse_sess.span_diagnostic,\n-                                span,\n-                                E0661,\n-                                \"output operand constraint lacks '=' or '+'\"\n-                            )\n-                            .emit();\n-                            None\n-                        }\n-                    };\n-\n-                    let is_rw = output.is_some();\n-                    let is_indirect = constraint_str.contains('*');\n-                    outputs.push(ast::LlvmInlineAsmOutput {\n-                        constraint: output.unwrap_or(constraint),\n-                        expr,\n-                        is_rw,\n-                        is_indirect,\n-                    });\n-                }\n-            }\n-            Inputs => {\n-                while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n-                    if !inputs.is_empty() {\n-                        p.eat(&token::Comma);\n-                    }\n-\n-                    let constraint = parse_asm_str(&mut p)?;\n-\n-                    if constraint.as_str().starts_with('=') {\n-                        struct_span_err!(\n-                            cx.sess.parse_sess.span_diagnostic,\n-                            p.prev_token.span,\n-                            E0662,\n-                            \"input operand constraint contains '='\"\n-                        )\n-                        .emit();\n-                    } else if constraint.as_str().starts_with('+') {\n-                        struct_span_err!(\n-                            cx.sess.parse_sess.span_diagnostic,\n-                            p.prev_token.span,\n-                            E0663,\n-                            \"input operand constraint contains '+'\"\n-                        )\n-                        .emit();\n-                    }\n-\n-                    p.expect(&token::OpenDelim(token::Paren))?;\n-                    let input = p.parse_expr()?;\n-                    p.expect(&token::CloseDelim(token::Paren))?;\n-\n-                    inputs.push((constraint, input));\n-                }\n-            }\n-            Clobbers => {\n-                while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n-                    if !clobs.is_empty() {\n-                        p.eat(&token::Comma);\n-                    }\n-\n-                    let s = parse_asm_str(&mut p)?;\n-\n-                    if OPTIONS.iter().any(|&opt| s == opt) {\n-                        cx.span_warn(p.prev_token.span, \"expected a clobber, found an option\");\n-                    } else if s.as_str().starts_with('{') || s.as_str().ends_with('}') {\n-                        struct_span_err!(\n-                            cx.sess.parse_sess.span_diagnostic,\n-                            p.prev_token.span,\n-                            E0664,\n-                            \"clobber should not be surrounded by braces\"\n-                        )\n-                        .emit();\n-                    }\n-\n-                    clobs.push(s);\n-                }\n-            }\n-            Options => {\n-                let option = parse_asm_str(&mut p)?;\n-\n-                if option == sym::volatile {\n-                    // Indicates that the inline assembly has side effects\n-                    // and must not be optimized out along with its outputs.\n-                    volatile = true;\n-                } else if option == sym::alignstack {\n-                    alignstack = true;\n-                } else if option == sym::intel {\n-                    dialect = LlvmAsmDialect::Intel;\n-                } else {\n-                    cx.span_warn(p.prev_token.span, \"unrecognized option\");\n-                }\n-\n-                if p.token == token::Comma {\n-                    p.eat(&token::Comma);\n-                }\n-            }\n-            StateNone => (),\n-        }\n-\n-        loop {\n-            // MOD_SEP is a double colon '::' without space in between.\n-            // When encountered, the state must be advanced twice.\n-            match (&p.token.kind, state.next(), state.next().next()) {\n-                (&token::Colon, StateNone, _) | (&token::ModSep, _, StateNone) => {\n-                    p.bump();\n-                    break 'statement;\n-                }\n-                (&token::Colon, st, _) | (&token::ModSep, _, st) => {\n-                    p.bump();\n-                    state = st;\n-                }\n-                (&token::Eof, ..) => break 'statement,\n-                _ => break,\n-            }\n-        }\n-    }\n-\n-    Ok(Some(ast::LlvmInlineAsm {\n-        asm,\n-        asm_str_style: asm_str_style.unwrap(),\n-        outputs,\n-        inputs,\n-        clobbers: clobs,\n-        volatile,\n-        alignstack,\n-        dialect,\n-    }))\n-}"}, {"sha": "5a889734f215b4007efc699b49e876c289ab0647", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -749,18 +749,6 @@ fn codegen_stmt<'tcx>(\n         | StatementKind::Retag { .. }\n         | StatementKind::AscribeUserType(..) => {}\n \n-        StatementKind::LlvmInlineAsm(asm) => {\n-            match asm.asm.asm.as_str().trim() {\n-                \"\" => {\n-                    // Black box\n-                }\n-                _ => fx.tcx.sess.span_fatal(\n-                    stmt.source_info.span,\n-                    \"Legacy `llvm_asm!` inline assembly is not supported. \\\n-                    Try using the new `asm!` instead.\",\n-                ),\n-            }\n-        }\n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n         StatementKind::CopyNonOverlapping(inner) => {\n             let dst = codegen_operand(fx, &inner.dst);"}, {"sha": "7ef09a1a6141d22557a069cc0375dabd75e597fb", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -506,7 +506,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                         {\n                             return None;\n                         }\n-                        StatementKind::LlvmInlineAsm(_) | StatementKind::CopyNonOverlapping(_) => {\n+                        StatementKind::CopyNonOverlapping(_) => {\n                             return None;\n                         } // conservative handling\n                         StatementKind::Assign(_)"}, {"sha": "d620b24e0677ac114adf8ec0ce86127c1ff7f92a", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -4,7 +4,6 @@ use rustc_codegen_ssa::mir::operand::OperandValue;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{AsmBuilderMethods, AsmMethods, BaseTypeMethods, BuilderMethods, GlobalAsmOperandRef, InlineAsmOperandRef};\n \n-use rustc_hir::LlvmInlineAsmInner;\n use rustc_middle::{bug, ty::Instance};\n use rustc_span::{Span, Symbol};\n use rustc_target::asm::*;\n@@ -106,17 +105,6 @@ enum ConstraintOrRegister {\n \n \n impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn codegen_llvm_inline_asm(&mut self, _ia: &LlvmInlineAsmInner, _outputs: Vec<PlaceRef<'tcx, RValue<'gcc>>>, _inputs: Vec<RValue<'gcc>>, span: Span) -> bool {\n-        self.sess().struct_span_err(span, \"GCC backend does not support `llvm_asm!`\")\n-            .help(\"consider using the `asm!` macro instead\")\n-            .emit();\n-\n-        // We return `true` even if we've failed to generate the asm\n-        // because we want to suppress the \"malformed inline assembly\" error\n-        // generated by the frontend.\n-        true\n-    }\n-\n     fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], rust_operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, span: &[Span], _instance: Instance<'_>, _dest_catch_funclet: Option<(Self::BasicBlock, Self::BasicBlock, Option<&Self::Funclet>)>) {\n         if options.contains(InlineAsmOptions::MAY_UNWIND) {\n             self.sess()"}, {"sha": "8335f841bec5688acaf2b0fdf5454452a0bf9771", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 5, "deletions": 102, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -7,13 +7,10 @@ use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n \n-use rustc_ast::LlvmAsmDialect;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::mir::operand::OperandValue;\n-use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::{bug, span_bug, ty::Instance};\n use rustc_span::{Pos, Span, Symbol};\n@@ -24,100 +21,6 @@ use libc::{c_char, c_uint};\n use tracing::debug;\n \n impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n-    fn codegen_llvm_inline_asm(\n-        &mut self,\n-        ia: &hir::LlvmInlineAsmInner,\n-        outputs: Vec<PlaceRef<'tcx, &'ll Value>>,\n-        mut inputs: Vec<&'ll Value>,\n-        span: Span,\n-    ) -> bool {\n-        let mut ext_constraints = vec![];\n-        let mut output_types = vec![];\n-\n-        // Prepare the output operands\n-        let mut indirect_outputs = vec![];\n-        for (i, (out, &place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n-            if out.is_rw {\n-                let operand = self.load_operand(place);\n-                if let OperandValue::Immediate(_) = operand.val {\n-                    inputs.push(operand.immediate());\n-                }\n-                ext_constraints.push(i.to_string());\n-            }\n-            if out.is_indirect {\n-                let operand = self.load_operand(place);\n-                if let OperandValue::Immediate(_) = operand.val {\n-                    indirect_outputs.push(operand.immediate());\n-                }\n-            } else {\n-                output_types.push(place.layout.llvm_type(self.cx));\n-            }\n-        }\n-        if !indirect_outputs.is_empty() {\n-            indirect_outputs.extend_from_slice(&inputs);\n-            inputs = indirect_outputs;\n-        }\n-\n-        let clobbers = ia.clobbers.iter().map(|s| format!(\"~{{{}}}\", &s));\n-\n-        // Default per-arch clobbers\n-        // Basically what clang does\n-        let arch_clobbers = match &self.sess().target.arch[..] {\n-            \"x86\" | \"x86_64\" => &[\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"][..],\n-            \"mips\" | \"mips64\" => &[\"~{$1}\"],\n-            _ => &[],\n-        };\n-\n-        let all_constraints = ia\n-            .outputs\n-            .iter()\n-            .map(|out| out.constraint.to_string())\n-            .chain(ia.inputs.iter().map(|s| s.to_string()))\n-            .chain(ext_constraints)\n-            .chain(clobbers)\n-            .chain(arch_clobbers.iter().map(|s| (*s).to_string()))\n-            .collect::<Vec<String>>()\n-            .join(\",\");\n-\n-        debug!(\"Asm Constraints: {}\", &all_constraints);\n-\n-        // Depending on how many outputs we have, the return type is different\n-        let num_outputs = output_types.len();\n-        let output_type = match num_outputs {\n-            0 => self.type_void(),\n-            1 => output_types[0],\n-            _ => self.type_struct(&output_types, false),\n-        };\n-\n-        let asm = ia.asm.as_str();\n-        let r = inline_asm_call(\n-            self,\n-            &asm,\n-            &all_constraints,\n-            &inputs,\n-            output_type,\n-            ia.volatile,\n-            ia.alignstack,\n-            ia.dialect,\n-            &[span],\n-            false,\n-            None,\n-        );\n-        if r.is_none() {\n-            return false;\n-        }\n-        let r = r.unwrap();\n-\n-        // Again, based on how many outputs we have\n-        let outputs = ia.outputs.iter().zip(&outputs).filter(|&(o, _)| !o.is_indirect);\n-        for (i, (_, &place)) in outputs.enumerate() {\n-            let v = if num_outputs == 1 { r } else { self.extract_value(r, i as u64) };\n-            OperandValue::Immediate(v).store(self, place);\n-        }\n-\n-        true\n-    }\n-\n     fn codegen_inline_asm(\n         &mut self,\n         template: &[InlineAsmTemplatePiece],\n@@ -349,9 +252,9 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n             InlineAsmArch::X86 | InlineAsmArch::X86_64\n                 if !options.contains(InlineAsmOptions::ATT_SYNTAX) =>\n             {\n-                LlvmAsmDialect::Intel\n+                llvm::AsmDialect::Intel\n             }\n-            _ => LlvmAsmDialect::Att,\n+            _ => llvm::AsmDialect::Att,\n         };\n         let result = inline_asm_call(\n             self,\n@@ -455,7 +358,7 @@ pub(crate) fn inline_asm_call<'ll>(\n     output: &'ll llvm::Type,\n     volatile: bool,\n     alignstack: bool,\n-    dia: LlvmAsmDialect,\n+    dia: llvm::AsmDialect,\n     line_spans: &[Span],\n     unwind: bool,\n     dest_catch_funclet: Option<(\n@@ -498,7 +401,7 @@ pub(crate) fn inline_asm_call<'ll>(\n                 cons.len(),\n                 volatile,\n                 alignstack,\n-                llvm::AsmDialect::from_generic(dia),\n+                dia,\n                 can_throw,\n             );\n \n@@ -522,7 +425,7 @@ pub(crate) fn inline_asm_call<'ll>(\n             // we just encode the start position of each line.\n             // FIXME: Figure out a way to pass the entire line spans.\n             let mut srcloc = vec![];\n-            if dia == LlvmAsmDialect::Intel && line_spans.len() > 1 {\n+            if dia == llvm::AsmDialect::Intel && line_spans.len() > 1 {\n                 // LLVM inserts an extra line to add the \".intel_syntax\", so add\n                 // a dummy srcloc entry for it.\n                 //"}, {"sha": "cebb6d13c4e9f2be272c6605aa488a34326f14e0", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -7,7 +7,6 @@ use crate::type_of::LayoutLlvmExt;\n use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n-use rustc_ast as ast;\n use rustc_codegen_ssa::base::{compare_simd_types, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n@@ -351,7 +350,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                     self.type_void(),\n                     true,\n                     false,\n-                    ast::LlvmAsmDialect::Att,\n+                    llvm::AsmDialect::Att,\n                     &[span],\n                     false,\n                     None,"}, {"sha": "bc8d7b3e9e21c62a3b7e590028fc27d3417caa8b", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -423,22 +423,13 @@ pub enum MetadataType {\n }\n \n /// LLVMRustAsmDialect\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n pub enum AsmDialect {\n     Att,\n     Intel,\n }\n \n-impl AsmDialect {\n-    pub fn from_generic(asm: rustc_ast::LlvmAsmDialect) -> Self {\n-        match asm {\n-            rustc_ast::LlvmAsmDialect::Att => AsmDialect::Att,\n-            rustc_ast::LlvmAsmDialect::Intel => AsmDialect::Intel,\n-        }\n-    }\n-}\n-\n /// LLVMRustCodeGenOptLevel\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]"}, {"sha": "d768d4920c5b45009da0e30a3a042d2cf82b3625", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -211,7 +211,6 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n             PlaceContext::MutatingUse(\n                 MutatingUseContext::Store\n-                | MutatingUseContext::LlvmAsmOutput\n                 | MutatingUseContext::AsmOutput\n                 | MutatingUseContext::Borrow\n                 | MutatingUseContext::AddressOf"}, {"sha": "773dc2adcfa0c93705c544bffa4c8a517cd7440e", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1,9 +1,7 @@\n-use rustc_errors::struct_span_err;\n use rustc_middle::mir;\n \n use super::FunctionCx;\n use super::LocalRef;\n-use super::OperandValue;\n use crate::traits::BuilderMethods;\n use crate::traits::*;\n \n@@ -66,51 +64,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n                 bx\n             }\n-            mir::StatementKind::LlvmInlineAsm(ref asm) => {\n-                let outputs = asm\n-                    .outputs\n-                    .iter()\n-                    .map(|output| self.codegen_place(&mut bx, output.as_ref()))\n-                    .collect();\n-\n-                let input_vals = asm.inputs.iter().fold(\n-                    Vec::with_capacity(asm.inputs.len()),\n-                    |mut acc, (span, input)| {\n-                        let op = self.codegen_operand(&mut bx, input);\n-                        if let OperandValue::Immediate(_) = op.val {\n-                            acc.push(op.immediate());\n-                        } else {\n-                            struct_span_err!(\n-                                bx.sess(),\n-                                span.to_owned(),\n-                                E0669,\n-                                \"invalid value for constraint in inline assembly\"\n-                            )\n-                            .emit();\n-                        }\n-                        acc\n-                    },\n-                );\n-\n-                if input_vals.len() == asm.inputs.len() {\n-                    let res = bx.codegen_llvm_inline_asm(\n-                        &asm.asm,\n-                        outputs,\n-                        input_vals,\n-                        statement.source_info.span,\n-                    );\n-                    if !res {\n-                        struct_span_err!(\n-                            bx.sess(),\n-                            statement.source_info.span,\n-                            E0668,\n-                            \"malformed inline assembly\"\n-                        )\n-                        .emit();\n-                    }\n-                }\n-                bx\n-            }\n             mir::StatementKind::Coverage(box ref coverage) => {\n                 self.codegen_coverage(&mut bx, coverage.clone(), statement.source_info.scope);\n                 bx"}, {"sha": "11111a7974410f1d9ab2ebe377bf7a6ade571c1d", "filename": "compiler/rustc_codegen_ssa/src/traits/asm.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -3,7 +3,6 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::LlvmInlineAsmInner;\n use rustc_middle::ty::Instance;\n use rustc_span::Span;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n@@ -42,15 +41,6 @@ pub enum GlobalAsmOperandRef {\n }\n \n pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n-    /// Take an inline assembly expression and splat it out via LLVM\n-    fn codegen_llvm_inline_asm(\n-        &mut self,\n-        ia: &LlvmInlineAsmInner,\n-        outputs: Vec<PlaceRef<'tcx, Self::Value>>,\n-        inputs: Vec<Self::Value>,\n-        span: Span,\n-    ) -> bool;\n-\n     /// Take an inline assembly expression and splat it out via LLVM\n     fn codegen_inline_asm(\n         &mut self,"}, {"sha": "57ba9b4099232f0c7719b9781748e0c23c179c14", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -140,8 +140,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly.\n             Nop => {}\n-\n-            LlvmInlineAsm { .. } => throw_unsup_format!(\"inline assembly is not supported\"),\n         }\n \n         self.stack_mut()[frame_idx].loc.as_mut().unwrap().statement_index += 1;"}, {"sha": "f619af051ca7bb5c35c40ee2dd280d4c32a3a468", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -752,10 +752,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n         self.super_statement(statement, location);\n \n         match statement.kind {\n-            StatementKind::LlvmInlineAsm { .. } => {\n-                self.check_op(ops::InlineAsm);\n-            }\n-\n             StatementKind::Assign(..)\n             | StatementKind::SetDiscriminant { .. }\n             | StatementKind::FakeRead(..)"}, {"sha": "22ef0b2dda50688197872161a8e26f27fe062f31", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -352,7 +352,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             StatementKind::SetDiscriminant { .. }\n             | StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)\n-            | StatementKind::LlvmInlineAsm(..)\n             | StatementKind::Retag(_, _)\n             | StatementKind::Coverage(_)\n             | StatementKind::Nop => {}"}, {"sha": "27ec461906419ea93328a5de07aa98cbb9f804a2", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -30,7 +30,6 @@ macro_rules! arena_types {\n             [] impl_item_ref: rustc_hir::ImplItemRef,\n             [] item: rustc_hir::Item<'tcx>,\n             [] inline_asm: rustc_hir::InlineAsm<'tcx>,\n-            [] llvm_inline_asm: rustc_hir::LlvmInlineAsm<'tcx>,\n             [] local: rustc_hir::Local<'tcx>,\n             [] mod_: rustc_hir::Mod<'tcx>,\n             [] owner_info: rustc_hir::OwnerInfo<'tcx>,"}, {"sha": "0d6ef7734e49b1401bfe920f740c3a8cfe593121", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -5,8 +5,8 @@ use crate::intravisit::FnKind;\n use crate::LangItem;\n \n use rustc_ast::util::parser::ExprPrecedence;\n-use rustc_ast::{self as ast, CrateSugar, LlvmAsmDialect};\n-use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, TraitObjectSyntax, UintTy};\n+use rustc_ast::{self as ast, CrateSugar};\n+use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, TraitObjectSyntax, UintTy};\n pub use rustc_ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -1471,7 +1471,6 @@ impl Expr<'_> {\n             ExprKind::Continue(..) => ExprPrecedence::Continue,\n             ExprKind::Ret(..) => ExprPrecedence::Ret,\n             ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n-            ExprKind::LlvmInlineAsm(..) => ExprPrecedence::InlineAsm,\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n@@ -1531,7 +1530,6 @@ impl Expr<'_> {\n             | ExprKind::Loop(..)\n             | ExprKind::Assign(..)\n             | ExprKind::InlineAsm(..)\n-            | ExprKind::LlvmInlineAsm(..)\n             | ExprKind::AssignOp(..)\n             | ExprKind::Lit(_)\n             | ExprKind::ConstBlock(..)\n@@ -1614,7 +1612,6 @@ impl Expr<'_> {\n             | ExprKind::Loop(..)\n             | ExprKind::Assign(..)\n             | ExprKind::InlineAsm(..)\n-            | ExprKind::LlvmInlineAsm(..)\n             | ExprKind::AssignOp(..)\n             | ExprKind::ConstBlock(..)\n             | ExprKind::Box(..)\n@@ -1755,8 +1752,6 @@ pub enum ExprKind<'hir> {\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n     InlineAsm(&'hir InlineAsm<'hir>),\n-    /// Inline assembly (from `llvm_asm!`), with its outputs and inputs.\n-    LlvmInlineAsm(&'hir LlvmInlineAsm<'hir>),\n \n     /// A struct or struct-like variant literal expression.\n     ///\n@@ -2368,36 +2363,6 @@ pub struct InlineAsm<'hir> {\n     pub line_spans: &'hir [Span],\n }\n \n-#[derive(Copy, Clone, Encodable, Decodable, Debug, Hash, HashStable_Generic, PartialEq)]\n-pub struct LlvmInlineAsmOutput {\n-    pub constraint: Symbol,\n-    pub is_rw: bool,\n-    pub is_indirect: bool,\n-    pub span: Span,\n-}\n-\n-// NOTE(eddyb) This is used within MIR as well, so unlike the rest of the HIR,\n-// it needs to be `Clone` and `Decodable` and use plain `Vec<T>` instead of\n-// arena-allocated slice.\n-#[derive(Clone, Encodable, Decodable, Debug, Hash, HashStable_Generic, PartialEq)]\n-pub struct LlvmInlineAsmInner {\n-    pub asm: Symbol,\n-    pub asm_str_style: StrStyle,\n-    pub outputs: Vec<LlvmInlineAsmOutput>,\n-    pub inputs: Vec<Symbol>,\n-    pub clobbers: Vec<Symbol>,\n-    pub volatile: bool,\n-    pub alignstack: bool,\n-    pub dialect: LlvmAsmDialect,\n-}\n-\n-#[derive(Debug, HashStable_Generic)]\n-pub struct LlvmInlineAsm<'hir> {\n-    pub inner: LlvmInlineAsmInner,\n-    pub outputs_exprs: &'hir [Expr<'hir>],\n-    pub inputs_exprs: &'hir [Expr<'hir>],\n-}\n-\n /// Represents a parameter in a function header.\n #[derive(Debug, HashStable_Generic)]\n pub struct Param<'hir> {"}, {"sha": "ca64af2c93cbfa512e536aa6bde10e70c7f17917", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1251,10 +1251,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         ExprKind::InlineAsm(ref asm) => {\n             walk_inline_asm(visitor, asm);\n         }\n-        ExprKind::LlvmInlineAsm(ref asm) => {\n-            walk_list!(visitor, visit_expr, asm.outputs_exprs);\n-            walk_list!(visitor, visit_expr, asm.inputs_exprs);\n-        }\n         ExprKind::Yield(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n         }"}, {"sha": "bf2dae5edf16d075f3a8e2519343594cf209cda1", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1581,67 +1581,6 @@ impl<'a> State<'a> {\n                 self.word(\"asm!\");\n                 self.print_inline_asm(asm);\n             }\n-            hir::ExprKind::LlvmInlineAsm(ref a) => {\n-                let i = &a.inner;\n-                self.word(\"llvm_asm!\");\n-                self.popen();\n-                self.print_symbol(i.asm, i.asm_str_style);\n-                self.word_space(\":\");\n-\n-                let mut out_idx = 0;\n-                self.commasep(Inconsistent, &i.outputs, |s, out| {\n-                    let constraint = out.constraint.as_str();\n-                    let mut ch = constraint.chars();\n-                    match ch.next() {\n-                        Some('=') if out.is_rw => {\n-                            s.print_string(&format!(\"+{}\", ch.as_str()), ast::StrStyle::Cooked)\n-                        }\n-                        _ => s.print_string(&constraint, ast::StrStyle::Cooked),\n-                    }\n-                    s.popen();\n-                    s.print_expr(&a.outputs_exprs[out_idx]);\n-                    s.pclose();\n-                    out_idx += 1;\n-                });\n-                self.space();\n-                self.word_space(\":\");\n-\n-                let mut in_idx = 0;\n-                self.commasep(Inconsistent, &i.inputs, |s, &co| {\n-                    s.print_symbol(co, ast::StrStyle::Cooked);\n-                    s.popen();\n-                    s.print_expr(&a.inputs_exprs[in_idx]);\n-                    s.pclose();\n-                    in_idx += 1;\n-                });\n-                self.space();\n-                self.word_space(\":\");\n-\n-                self.commasep(Inconsistent, &i.clobbers, |s, &co| {\n-                    s.print_symbol(co, ast::StrStyle::Cooked);\n-                });\n-\n-                let mut options = vec![];\n-                if i.volatile {\n-                    options.push(\"volatile\");\n-                }\n-                if i.alignstack {\n-                    options.push(\"alignstack\");\n-                }\n-                if i.dialect == ast::LlvmAsmDialect::Intel {\n-                    options.push(\"intel\");\n-                }\n-\n-                if !options.is_empty() {\n-                    self.space();\n-                    self.word_space(\":\");\n-                    self.commasep(Inconsistent, &options, |s, &co| {\n-                        s.print_string(co, ast::StrStyle::Cooked);\n-                    });\n-                }\n-\n-                self.pclose();\n-            }\n             hir::ExprKind::Yield(ref expr, _) => {\n                 self.word_space(\"yield\");\n                 self.print_expr_maybe_paren(&expr, parser::PREC_JUMP);"}, {"sha": "38c379919d2891ddea1cde2b58b9a367f9a3dc86", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1565,10 +1565,6 @@ pub enum StatementKind<'tcx> {\n     /// End the current live range for the storage of the local.\n     StorageDead(Local),\n \n-    /// Executes a piece of inline Assembly. Stored in a Box to keep the size\n-    /// of `StatementKind` low.\n-    LlvmInlineAsm(Box<LlvmInlineAsm<'tcx>>),\n-\n     /// Retag references in the given place, ensuring they got fresh tags. This is\n     /// part of the Stacked Borrows model. These statements are currently only interpreted\n     /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n@@ -1688,13 +1684,6 @@ pub enum FakeReadCause {\n     ForIndex,\n }\n \n-#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n-pub struct LlvmInlineAsm<'tcx> {\n-    pub asm: hir::LlvmInlineAsmInner,\n-    pub outputs: Box<[Place<'tcx>]>,\n-    pub inputs: Box<[(Span, Operand<'tcx>)]>,\n-}\n-\n impl Debug for Statement<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n@@ -1719,9 +1708,6 @@ impl Debug for Statement<'_> {\n             SetDiscriminant { ref place, variant_index } => {\n                 write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index)\n             }\n-            LlvmInlineAsm(ref asm) => {\n-                write!(fmt, \"llvm_asm!({:?} : {:?} : {:?})\", asm.asm, asm.outputs, asm.inputs)\n-            }\n             AscribeUserType(box (ref place, ref c_ty), ref variance) => {\n                 write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }"}, {"sha": "589e1579d39bfe3649b25dbe4795b46834e1568b", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -245,7 +245,6 @@ pub fn statement_kind_name(statement: &Statement<'_>) -> &'static str {\n         SetDiscriminant { .. } => \"SetDiscriminant\",\n         StorageLive(..) => \"StorageLive\",\n         StorageDead(..) => \"StorageDead\",\n-        LlvmInlineAsm(..) => \"LlvmInlineAsm\",\n         Retag(..) => \"Retag\",\n         AscribeUserType(..) => \"AscribeUserType\",\n         Coverage(..) => \"Coverage\","}, {"sha": "4452ac5e3e0d4b92f0f46dc7b1e91d5343feb8fc", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -408,19 +408,6 @@ macro_rules! make_mir_visitor {\n                             location\n                         );\n                     }\n-                    StatementKind::LlvmInlineAsm(asm) => {\n-                        for output in & $($mutability)? asm.outputs[..] {\n-                            self.visit_place(\n-                                output,\n-                                PlaceContext::MutatingUse(MutatingUseContext::LlvmAsmOutput),\n-                                location\n-                            );\n-                        }\n-                        for (span, input) in & $($mutability)? asm.inputs[..] {\n-                            self.visit_span(span);\n-                            self.visit_operand(input, location);\n-                        }\n-                    }\n                     StatementKind::Retag(kind, place) => {\n                         self.visit_retag(kind, place, location);\n                     }\n@@ -1178,10 +1165,6 @@ pub enum NonMutatingUseContext {\n pub enum MutatingUseContext {\n     /// Appears as LHS of an assignment.\n     Store,\n-    /// Can often be treated as a `Store`, but needs to be separate because\n-    /// ASM is allowed to read outputs as well, so a `Store`-`LlvmAsmOutput` sequence\n-    /// cannot be simplified the way a `Store`-`Store` can be.\n-    LlvmAsmOutput,\n     /// Output operand of an inline assembly block.\n     AsmOutput,\n     /// Destination of a call.\n@@ -1271,7 +1254,6 @@ impl PlaceContext {\n             PlaceContext::MutatingUse(\n                 MutatingUseContext::Store\n                     | MutatingUseContext::Call\n-                    | MutatingUseContext::LlvmAsmOutput\n                     | MutatingUseContext::AsmOutput,\n             )\n         )"}, {"sha": "eef42666f2a07853940678aa13675df7919d41c1", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -431,12 +431,6 @@ pub enum ExprKind<'tcx> {\n     },\n     /// An expression taking a reference to a thread local.\n     ThreadLocalRef(DefId),\n-    /// Inline LLVM assembly, i.e. `llvm_asm!()`.\n-    LlvmInlineAsm {\n-        asm: &'tcx hir::LlvmInlineAsmInner,\n-        outputs: Box<[ExprId]>,\n-        inputs: Box<[ExprId]>,\n-    },\n     /// A `yield` expression.\n     Yield {\n         value: ExprId,"}, {"sha": "9f9947341c5c1a6079fa9cad8dc83d3ec908e6e3", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -145,14 +145,6 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n             }\n         }\n         ThreadLocalRef(_) => {}\n-        LlvmInlineAsm { ref outputs, ref inputs, asm: _ } => {\n-            for &out_expr in &**outputs {\n-                visitor.visit_expr(&visitor.thir()[out_expr]);\n-            }\n-            for &in_expr in &**inputs {\n-                visitor.visit_expr(&visitor.thir()[in_expr]);\n-            }\n-        }\n         Yield { value } => visitor.visit_expr(&visitor.thir()[value]),\n     }\n }"}, {"sha": "fe56544dab3bec277cefb2c68f8fa316f86e0898", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -225,7 +225,6 @@ TrivialTypeFoldableAndLiftImpls! {\n     ::rustc_hir::def_id::DefId,\n     ::rustc_hir::def_id::LocalDefId,\n     ::rustc_hir::HirId,\n-    ::rustc_hir::LlvmInlineAsmInner,\n     ::rustc_hir::MatchSource,\n     ::rustc_hir::Mutability,\n     ::rustc_hir::Unsafety,"}, {"sha": "167b3aaed4695881ab16ddf44a645f3ea0eb8aad", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -570,7 +570,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::ConstBlock { .. }\n             | ExprKind::StaticRef { .. }\n             | ExprKind::InlineAsm { .. }\n-            | ExprKind::LlvmInlineAsm { .. }\n             | ExprKind::Yield { .. }\n             | ExprKind::ThreadLocalRef(_)\n             | ExprKind::Call { .. } => {"}, {"sha": "1dc49256a6a9f6430039a43211e94f14a8c70572", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -350,7 +350,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n             | ExprKind::InlineAsm { .. }\n-            | ExprKind::LlvmInlineAsm { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => {\n                 // these do not have corresponding `Rvalue` variants,"}, {"sha": "d31f6ed93840ad08deb23604ceb72a6f91d2c915", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -67,8 +67,7 @@ impl Category {\n             | ExprKind::Repeat { .. }\n             | ExprKind::Assign { .. }\n             | ExprKind::AssignOp { .. }\n-            | ExprKind::ThreadLocalRef(_)\n-            | ExprKind::LlvmInlineAsm { .. } => Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n+            | ExprKind::ThreadLocalRef(_) => Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n \n             ExprKind::ConstBlock { .. } | ExprKind::Literal { .. } | ExprKind::StaticRef { .. } => {\n                 Some(Category::Constant)"}, {"sha": "43060ecfced12082353f5fa5d8799a759fc86a53", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -477,9 +477,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             // These cases don't actually need a destination\n-            ExprKind::Assign { .. }\n-            | ExprKind::AssignOp { .. }\n-            | ExprKind::LlvmInlineAsm { .. } => {\n+            ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n                 unpack!(block = this.stmt_expr(block, expr, None));\n                 this.cfg.push_assign_unit(block, source_info, destination, this.tcx);\n                 block.unit()"}, {"sha": "7419c5b2f7588e56a556db5ad4fcc3efbd386517", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -101,38 +101,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 BreakableTarget::Return,\n                 source_info,\n             ),\n-            ExprKind::LlvmInlineAsm { asm, ref outputs, ref inputs } => {\n-                debug!(\"stmt_expr LlvmInlineAsm block_context.push(SubExpr) : {:?}\", expr);\n-                this.block_context.push(BlockFrame::SubExpr);\n-                let outputs = outputs\n-                    .into_iter()\n-                    .copied()\n-                    .map(|output| unpack!(block = this.as_place(block, &this.thir[output])))\n-                    .collect::<Vec<_>>()\n-                    .into_boxed_slice();\n-                let inputs = inputs\n-                    .into_iter()\n-                    .copied()\n-                    .map(|input| {\n-                        let input = &this.thir[input];\n-                        (input.span, unpack!(block = this.as_local_operand(block, &input)))\n-                    })\n-                    .collect::<Vec<_>>()\n-                    .into_boxed_slice();\n-                this.cfg.push(\n-                    block,\n-                    Statement {\n-                        source_info,\n-                        kind: StatementKind::LlvmInlineAsm(Box::new(LlvmInlineAsm {\n-                            asm: asm.clone(),\n-                            outputs,\n-                            inputs,\n-                        })),\n-                    },\n-                );\n-                this.block_context.pop();\n-                block.unit()\n-            }\n             _ => {\n                 assert!(\n                     statement_scope.is_some(),"}, {"sha": "8ca2449cea9c47d12ab4d8bd82bca5ef2f0c8338", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -329,7 +329,6 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n             | ExprKind::Box { .. }\n             | ExprKind::If { .. }\n             | ExprKind::InlineAsm { .. }\n-            | ExprKind::LlvmInlineAsm { .. }\n             | ExprKind::LogicalOp { .. }\n             | ExprKind::Use { .. } => {\n                 // We don't need to save the old value and restore it\n@@ -377,7 +376,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                     self.requires_unsafe(expr.span, DerefOfRawPointer);\n                 }\n             }\n-            ExprKind::InlineAsm { .. } | ExprKind::LlvmInlineAsm { .. } => {\n+            ExprKind::InlineAsm { .. } => {\n                 self.requires_unsafe(expr.span, UseOfInlineAssembly);\n             }\n             ExprKind::Adt(box Adt {"}, {"sha": "6865dd202cf9e85691040baf1a27c17dd0d8bc89", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -570,12 +570,6 @@ impl<'tcx> Cx<'tcx> {\n                 line_spans: asm.line_spans,\n             },\n \n-            hir::ExprKind::LlvmInlineAsm(ref asm) => ExprKind::LlvmInlineAsm {\n-                asm: &asm.inner,\n-                outputs: self.mirror_exprs(asm.outputs_exprs),\n-                inputs: self.mirror_exprs(asm.inputs_exprs),\n-            },\n-\n             hir::ExprKind::ConstBlock(ref anon_const) => {\n                 let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n                 let value = ty::Const::from_inline_const(self.tcx, anon_const_def_id);"}, {"sha": "4871320fdb5c08e11e1cbae159cb00407eaab561", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -176,7 +176,6 @@ impl DefUse {\n             // All other contexts are uses...\n             PlaceContext::MutatingUse(\n                 MutatingUseContext::AddressOf\n-                | MutatingUseContext::LlvmAsmOutput\n                 | MutatingUseContext::Borrow\n                 | MutatingUseContext::Drop\n                 | MutatingUseContext::Retag,"}, {"sha": "60cde6546dcfc62d2a7c0e5be2fa7e999d463869", "filename": "compiler/rustc_mir_dataflow/src/impls/storage_liveness.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -134,11 +134,6 @@ impl<'mir, 'tcx> crate::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tc\n             | StatementKind::SetDiscriminant { box place, .. } => {\n                 trans.gen(place.local);\n             }\n-            StatementKind::LlvmInlineAsm(asm) => {\n-                for place in &*asm.outputs {\n-                    trans.gen(place.local);\n-                }\n-            }\n \n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n             // variants are added."}, {"sha": "26bbc34e780bb03a5545706f6f1bc6ddaba3a9f3", "filename": "compiler/rustc_mir_dataflow/src/move_paths/builder.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -4,7 +4,6 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n use smallvec::{smallvec, SmallVec};\n \n-use std::iter;\n use std::mem;\n \n use super::abs_domain::Lift;\n@@ -293,16 +292,6 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             StatementKind::FakeRead(box (_, place)) => {\n                 self.create_move_path(*place);\n             }\n-            StatementKind::LlvmInlineAsm(ref asm) => {\n-                for (output, kind) in iter::zip(&*asm.outputs, &asm.asm.outputs) {\n-                    if !kind.is_indirect {\n-                        self.gather_init(output.as_ref(), InitKind::Deep);\n-                    }\n-                }\n-                for (_, input) in asm.inputs.iter() {\n-                    self.gather_operand(input);\n-                }\n-            }\n             StatementKind::StorageLive(_) => {}\n             StatementKind::StorageDead(local) => {\n                 self.gather_move(Place::from(*local));"}, {"sha": "4a773c5772dab4af742fa73ea164b6e954ed9e1d", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -104,10 +104,6 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n                 // safe (at least as emitted during MIR construction)\n             }\n \n-            StatementKind::LlvmInlineAsm { .. } => self.require_unsafe(\n-                UnsafetyViolationKind::General,\n-                UnsafetyViolationDetails::UseOfInlineAssembly,\n-            ),\n             StatementKind::CopyNonOverlapping(..) => unreachable!(),\n         }\n         self.super_statement(statement, location);\n@@ -208,7 +204,6 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n                             MutatingUseContext::Store\n                                 | MutatingUseContext::Drop\n                                 | MutatingUseContext::AsmOutput\n-                                | MutatingUseContext::LlvmAsmOutput\n                         )\n                     );\n                 // If this is just an assignment, determine if the assigned type needs dropping."}, {"sha": "7649fafc3550488b7c1236826b078723069b6686", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1035,8 +1035,7 @@ impl Visitor<'_> for CanConstProp {\n \n             // These could be propagated with a smarter analysis or just some careful thinking about\n             // whether they'd be fine right now.\n-            MutatingUse(MutatingUseContext::LlvmAsmOutput)\n-            | MutatingUse(MutatingUseContext::Yield)\n+            MutatingUse(MutatingUseContext::Yield)\n             | MutatingUse(MutatingUseContext::Drop)\n             | MutatingUse(MutatingUseContext::Retag)\n             // These can't ever be propagated under any scheme, as we can't reason about indirect"}, {"sha": "a9161580bc68185ac0b268c1474dd44ef34477db", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -835,7 +835,6 @@ pub(super) fn filtered_statement_span(statement: &Statement<'_>) -> Option<Span>\n         | StatementKind::CopyNonOverlapping(..)\n         | StatementKind::Assign(_)\n         | StatementKind::SetDiscriminant { .. }\n-        | StatementKind::LlvmInlineAsm(_)\n         | StatementKind::Retag(_, _)\n         | StatementKind::AscribeUserType(_, _) => {\n             Some(statement.source_info.span)"}, {"sha": "d469be746414414175e81a914b086d3d32fa383d", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -534,25 +534,6 @@ impl<'a> Conflicts<'a> {\n             // eliminate the resulting self-assignments automatically.\n             StatementKind::Assign(_) => {}\n \n-            StatementKind::LlvmInlineAsm(asm) => {\n-                // Inputs and outputs must not overlap.\n-                for (_, input) in &*asm.inputs {\n-                    if let Some(in_place) = input.place() {\n-                        if !in_place.is_indirect() {\n-                            for out_place in &*asm.outputs {\n-                                if !out_place.is_indirect() && !in_place.is_indirect() {\n-                                    self.record_local_conflict(\n-                                        in_place.local,\n-                                        out_place.local,\n-                                        \"aliasing llvm_asm! operands\",\n-                                    );\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n             StatementKind::SetDiscriminant { .. }\n             | StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)"}, {"sha": "433a1c6ad67cc2694dd6c2d636555d537e7b7ffc", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1449,9 +1449,6 @@ impl<'tcx> Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n                 self.check_assigned_place(*lhs, |this| this.visit_rvalue(rhs, location));\n             }\n \n-            // FIXME: Does `llvm_asm!` have any aliasing requirements?\n-            StatementKind::LlvmInlineAsm(_) => {}\n-\n             StatementKind::FakeRead(..)\n             | StatementKind::SetDiscriminant { .. }\n             | StatementKind::StorageLive(_)"}, {"sha": "77fb092d5806f31c95a10be67d9bae9be2b08cee", "filename": "compiler/rustc_mir_transform/src/remove_noop_landing_pads.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -50,7 +50,6 @@ impl RemoveNoopLandingPads {\n \n                 StatementKind::Assign { .. }\n                 | StatementKind::SetDiscriminant { .. }\n-                | StatementKind::LlvmInlineAsm { .. }\n                 | StatementKind::CopyNonOverlapping(..)\n                 | StatementKind::Retag { .. } => {\n                     return false;"}, {"sha": "d265720e18296bfad3ff6469aa7e406a3c6cf8bb", "filename": "compiler/rustc_mir_transform/src/separate_const_switch.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -239,10 +239,6 @@ fn is_likely_const<'tcx>(mut tracked_place: Place<'tcx>, block: &BasicBlockData<\n                 }\n             }\n \n-            // If inline assembly is found, we probably should\n-            // not try to analyze the code\n-            StatementKind::LlvmInlineAsm(_) => return false,\n-\n             // These statements have no influence on the place\n             // we are interested in\n             StatementKind::FakeRead(_)\n@@ -320,10 +316,6 @@ fn find_determining_place<'tcx>(\n             | StatementKind::CopyNonOverlapping(_)\n             | StatementKind::Nop => {}\n \n-            // If inline assembly is found, we probably should\n-            // not try to analyze the code\n-            StatementKind::LlvmInlineAsm(_) => return None,\n-\n             // If the discriminant is set, it is always set\n             // as a constant, so the job is already done.\n             // As we are **ignoring projections**, if the place"}, {"sha": "7e0c8e233e9e8cfd94efa213717d79e860f08261", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -483,8 +483,7 @@ impl UsedLocals {\n impl<'tcx> Visitor<'tcx> for UsedLocals {\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         match statement.kind {\n-            StatementKind::LlvmInlineAsm(..)\n-            | StatementKind::CopyNonOverlapping(..)\n+            StatementKind::CopyNonOverlapping(..)\n             | StatementKind::Retag(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::FakeRead(..)"}, {"sha": "d5507fcc78cad8016befb447a1bad1c52fa23e39", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -631,10 +631,6 @@ impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n                     .filter(|(_, bb)| {\n                         // Reaching `unreachable` is UB so assume it doesn't happen.\n                         bb.terminator().kind != TerminatorKind::Unreachable\n-                    // But `asm!(...)` could abort the program,\n-                    // so we cannot assume that the `unreachable` terminator itself is reachable.\n-                    // FIXME(Centril): use a normalization pass instead of a check.\n-                    || bb.statements.iter().any(|stmt| matches!(stmt.kind, StatementKind::LlvmInlineAsm(..)))\n                     })\n                     .peekable();\n "}, {"sha": "f916ca36217b4c0ff4c0ceb15d81cb8e97801b48", "filename": "compiler/rustc_mir_transform/src/unreachable_prop.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -23,23 +23,14 @@ impl MirPass<'_> for UnreachablePropagation {\n \n         for (bb, bb_data) in traversal::postorder(body) {\n             let terminator = bb_data.terminator();\n-            // HACK: If the block contains any asm statement it is not regarded as unreachable.\n-            // This is a temporary solution that handles possibly diverging asm statements.\n-            // Accompanying testcases: mir-opt/unreachable_asm.rs and mir-opt/unreachable_asm_2.rs\n-            let asm_stmt_in_block = || {\n-                bb_data.statements.iter().any(|stmt: &Statement<'_>| {\n-                    matches!(stmt.kind, StatementKind::LlvmInlineAsm(..))\n-                })\n-            };\n-\n-            if terminator.kind == TerminatorKind::Unreachable && !asm_stmt_in_block() {\n+            if terminator.kind == TerminatorKind::Unreachable {\n                 unreachable_blocks.insert(bb);\n             } else {\n                 let is_unreachable = |succ: BasicBlock| unreachable_blocks.contains(&succ);\n                 let terminator_kind_opt = remove_successors(&terminator.kind, is_unreachable);\n \n                 if let Some(terminator_kind) = terminator_kind_opt {\n-                    if terminator_kind == TerminatorKind::Unreachable && !asm_stmt_in_block() {\n+                    if terminator_kind == TerminatorKind::Unreachable {\n                         unreachable_blocks.insert(bb);\n                     }\n                     replacements.insert(bb, terminator_kind);"}, {"sha": "4660d04788594f176cee2b9e5b4a4120d5a9c006", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -103,7 +103,6 @@ use rustc_span::Span;\n use std::collections::VecDeque;\n use std::io;\n use std::io::prelude::*;\n-use std::iter;\n use std::rc::Rc;\n \n mod rwu_table;\n@@ -470,7 +469,6 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n             | hir::ExprKind::Struct(..)\n             | hir::ExprKind::Repeat(..)\n             | hir::ExprKind::InlineAsm(..)\n-            | hir::ExprKind::LlvmInlineAsm(..)\n             | hir::ExprKind::Box(..)\n             | hir::ExprKind::Type(..)\n             | hir::ExprKind::Err\n@@ -1091,26 +1089,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 succ\n             }\n \n-            hir::ExprKind::LlvmInlineAsm(ref asm) => {\n-                let ia = &asm.inner;\n-                let outputs = asm.outputs_exprs;\n-                let inputs = asm.inputs_exprs;\n-                let succ = iter::zip(&ia.outputs, outputs).rev().fold(succ, |succ, (o, output)| {\n-                    // see comment on places\n-                    // in propagate_through_place_components()\n-                    if o.is_indirect {\n-                        self.propagate_through_expr(output, succ)\n-                    } else {\n-                        let acc = if o.is_rw { ACC_WRITE | ACC_READ } else { ACC_WRITE };\n-                        let succ = self.write_place(output, succ, acc);\n-                        self.propagate_through_place_components(output, succ)\n-                    }\n-                });\n-\n-                // Inputs are executed first. Propagate last because of rev order\n-                self.propagate_through_exprs(inputs, succ)\n-            }\n-\n             hir::ExprKind::Lit(..)\n             | hir::ExprKind::ConstBlock(..)\n             | hir::ExprKind::Err\n@@ -1387,20 +1365,6 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n         }\n \n-        hir::ExprKind::LlvmInlineAsm(ref asm) => {\n-            for input in asm.inputs_exprs {\n-                this.visit_expr(input);\n-            }\n-\n-            // Output operands must be places\n-            for (o, output) in iter::zip(&asm.inner.outputs, asm.outputs_exprs) {\n-                if !o.is_indirect {\n-                    this.check_place(output);\n-                }\n-                this.visit_expr(output);\n-            }\n-        }\n-\n         hir::ExprKind::Let(let_expr) => {\n             this.check_unused_vars_in_pat(let_expr.pat, None, |_, _, _, _| {});\n         }"}, {"sha": "dd14dce4b5b83247424fcb6b7400bbef60246f5e", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -236,22 +236,6 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n                 self.check_inline_asm(expr.hir_id, asm, span);\n             }\n \n-            ExprKind::LlvmInlineAsm(..) => {\n-                self.items.push((ItemKind::Asm, span));\n-                self.tcx.struct_span_lint_hir(\n-                    UNSUPPORTED_NAKED_FUNCTIONS,\n-                    expr.hir_id,\n-                    span,\n-                    |lint| {\n-                        lint.build(\n-                            \"the LLVM-style inline assembly is unsupported in naked functions\",\n-                        )\n-                        .help(\"use the new asm! syntax specified in RFC 2873\")\n-                        .emit();\n-                    },\n-                );\n-            }\n-\n             ExprKind::DropTemps(..) | ExprKind::Block(..) | ExprKind::Err => {\n                 hir::intravisit::walk_expr(self, expr);\n             }"}, {"sha": "9b906a735dba79d7b9926396438bff9576d43e3d", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -786,7 +786,6 @@ symbols! {\n         linkage,\n         lint_reasons,\n         literal,\n-        llvm_asm,\n         load,\n         loaded_from_disk,\n         local,"}, {"sha": "76e51b8d7d93b022ea2930c6152e139a690f078a", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -480,7 +480,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             // let expressions imply control flow\n             ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } =>\n                 self.error(node.span, \"control flow is not supported in generic constants\")?,\n-            ExprKind::LlvmInlineAsm { .. } | ExprKind::InlineAsm { .. } => {\n+            ExprKind::InlineAsm { .. } => {\n                 self.error(node.span, \"assembly is not supported in generic constants\")?\n             }\n "}, {"sha": "3b6e87b6a88eba414856417d2a9605bd4953791d", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -282,12 +282,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ExprKind::Path(ref qpath) => self.check_expr_path(qpath, expr, &[]),\n             ExprKind::InlineAsm(asm) => self.check_expr_asm(asm),\n-            ExprKind::LlvmInlineAsm(asm) => {\n-                for expr in asm.outputs_exprs.iter().chain(asm.inputs_exprs.iter()) {\n-                    self.check_expr(expr);\n-                }\n-                tcx.mk_unit()\n-            }\n             ExprKind::Break(destination, ref expr_opt) => {\n                 self.check_expr_break(destination, expr_opt.as_deref(), expr)\n             }"}, {"sha": "564aac4825a57b4aee31459dc13aa87e85f367b5", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -17,7 +17,6 @@ use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, adjustment, AdtKind, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n-use std::iter;\n \n use crate::mem_categorization as mc;\n \n@@ -360,17 +359,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::LlvmInlineAsm(ia) => {\n-                for (o, output) in iter::zip(&ia.inner.outputs, ia.outputs_exprs) {\n-                    if o.is_indirect {\n-                        self.consume_expr(output);\n-                    } else {\n-                        self.mutate_expr(output);\n-                    }\n-                }\n-                self.consume_exprs(ia.inputs_exprs);\n-            }\n-\n             hir::ExprKind::Continue(..)\n             | hir::ExprKind::Lit(..)\n             | hir::ExprKind::ConstBlock(..)"}, {"sha": "2c2d2be8bb5141e9eac2f9c9073b64164243074b", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -378,7 +378,6 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             | hir::ExprKind::Struct(..)\n             | hir::ExprKind::Repeat(..)\n             | hir::ExprKind::InlineAsm(..)\n-            | hir::ExprKind::LlvmInlineAsm(..)\n             | hir::ExprKind::Box(..)\n             | hir::ExprKind::Err => Ok(self.cat_rvalue(expr.hir_id, expr.span, expr_ty)),\n         }"}, {"sha": "d8ac816fb15a0309648809330f6452d5fa894ac8", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -180,7 +180,6 @@\n #![feature(intrinsics)]\n #![feature(lang_items)]\n #![feature(link_llvm_intrinsics)]\n-#![feature(llvm_asm)]\n #![feature(min_specialization)]\n #![feature(mixed_integer_ops)]\n #![feature(must_not_suspend)]"}, {"sha": "5184eb91bf3f4445dc072a686f7ad4c9799cad11", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -1373,32 +1373,6 @@ pub(crate) mod builtin {\n         ($cond:expr, $($arg:tt)+) => {{ /* compiler built-in */ }};\n     }\n \n-    /// LLVM-style inline assembly.\n-    ///\n-    /// Read the [unstable book] for the usage.\n-    ///\n-    /// [unstable book]: ../unstable-book/library-features/llvm-asm.html\n-    #[unstable(\n-        feature = \"llvm_asm\",\n-        issue = \"70173\",\n-        reason = \"prefer using the new asm! syntax instead\"\n-    )]\n-    #[rustc_deprecated(\n-        since = \"1.56\",\n-        reason = \"will be removed from the compiler, use asm! instead\"\n-    )]\n-    #[rustc_builtin_macro]\n-    #[macro_export]\n-    macro_rules! llvm_asm {\n-        (\"assembly template\"\n-                        : $(\"output\"(operand),)*\n-                        : $(\"input\"(operand),)*\n-                        : $(\"clobbers\",)*\n-                        : $(\"options\",)*) => {\n-            /* compiler built-in */\n-        };\n-    }\n-\n     /// Prints passed tokens into the standard output.\n     #[unstable(\n         feature = \"log_syntax\","}, {"sha": "d91289fad2009ea64c65b8c68df3de8b9f80d4b0", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -56,8 +56,8 @@ pub use crate::hash::macros::Hash;\n #[doc(no_inline)]\n pub use crate::{\n     assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n-    format_args_nl, include, include_bytes, include_str, line, llvm_asm, log_syntax, module_path,\n-    option_env, stringify, trace_macros,\n+    format_args_nl, include, include_bytes, include_str, line, log_syntax, module_path, option_env,\n+    stringify, trace_macros,\n };\n \n #[unstable("}, {"sha": "51d5f1cd4e1e04f68c3c80c1c6794d3e95d4d9f7", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -294,7 +294,6 @@\n #![feature(intra_doc_pointers)]\n #![feature(lang_items)]\n #![feature(linkage)]\n-#![feature(llvm_asm)]\n #![feature(log_syntax)]\n #![feature(map_try_insert)]\n #![feature(maybe_uninit_extra)]\n@@ -572,8 +571,8 @@ pub use core::{\n #[allow(deprecated)]\n pub use core::{\n     assert, assert_matches, cfg, column, compile_error, concat, concat_idents, const_format_args,\n-    env, file, format_args, format_args_nl, include, include_bytes, include_str, line, llvm_asm,\n-    log_syntax, module_path, option_env, stringify, trace_macros,\n+    env, file, format_args, format_args_nl, include, include_bytes, include_str, line, log_syntax,\n+    module_path, option_env, stringify, trace_macros,\n };\n \n #[unstable("}, {"sha": "53124daa3a683a0fafa0f17766462d428b3b9f90", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b36c505a8865322c376486791cdee8f38d0c5/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=000b36c505a8865322c376486791cdee8f38d0c5", "patch": "@@ -40,9 +40,8 @@ pub use crate::result::Result::{self, Err, Ok};\n #[doc(no_inline)]\n pub use core::prelude::v1::{\n     assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n-    format_args_nl, include, include_bytes, include_str, line, llvm_asm, log_syntax, module_path,\n-    option_env, stringify, trace_macros, Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq,\n-    PartialOrd,\n+    format_args_nl, include, include_bytes, include_str, line, log_syntax, module_path, option_env,\n+    stringify, trace_macros, Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd,\n };\n \n #[unstable("}]}