{"sha": "1ca103a16885564a999dce3916d97007766f2ff1", "node_id": "C_kwDOAAsO6NoAKDFjYTEwM2ExNjg4NTU2NGE5OTlkY2UzOTE2ZDk3MDA3NzY2ZjJmZjE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-06T14:57:05Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-11T22:41:01Z"}, "message": "Ensure value is on the on-disk cache before returning.", "tree": {"sha": "c52a55a06bfbad937dcb68673af47a7900f280b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c52a55a06bfbad937dcb68673af47a7900f280b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ca103a16885564a999dce3916d97007766f2ff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ca103a16885564a999dce3916d97007766f2ff1", "html_url": "https://github.com/rust-lang/rust/commit/1ca103a16885564a999dce3916d97007766f2ff1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ca103a16885564a999dce3916d97007766f2ff1/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a73f50d875840b8077b8ec080fa41881d7ce40d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a73f50d875840b8077b8ec080fa41881d7ce40d", "html_url": "https://github.com/rust-lang/rust/commit/8a73f50d875840b8077b8ec080fa41881d7ce40d"}], "stats": {"total": 62, "additions": 53, "deletions": 9}, "files": [{"sha": "035bfe978f20831702974893202fff28305b1053", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=1ca103a16885564a999dce3916d97007766f2ff1", "patch": "@@ -31,6 +31,7 @@ use rustc_span::Span;\n #[macro_use]\n mod plumbing;\n pub use plumbing::QueryCtxt;\n+use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n use rustc_query_system::query::*;\n #[cfg(parallel_compiler)]\n pub use rustc_query_system::query::{deadlock, QueryContext};"}, {"sha": "35b7e5919e42ac99b15ed723c2f98177760995a9", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=1ca103a16885564a999dce3916d97007766f2ff1", "patch": "@@ -388,6 +388,12 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_assert!(prev.is_none());\n     }\n \n+    /// Return whether the cached query result can be decoded.\n+    pub fn loadable_from_disk(&self, dep_node_index: SerializedDepNodeIndex) -> bool {\n+        self.query_result_index.contains_key(&dep_node_index)\n+        // with_decoder is infallible, so we can stop here\n+    }\n+\n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     pub fn try_load_query_result<'tcx, T>(\n@@ -398,7 +404,9 @@ impl<'sess> OnDiskCache<'sess> {\n     where\n         T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n-        self.load_indexed(tcx, dep_node_index, &self.query_result_index)\n+        let opt_value = self.load_indexed(tcx, dep_node_index, &self.query_result_index);\n+        debug_assert_eq!(opt_value.is_some(), self.loadable_from_disk(dep_node_index));\n+        opt_value\n     }\n \n     /// Stores side effect emitted during computation of an anonymous query.\n@@ -428,8 +436,8 @@ impl<'sess> OnDiskCache<'sess> {\n         T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n-\n-        self.with_decoder(tcx, pos, |decoder| Some(decode_tagged(decoder, dep_node_index)))\n+        let value = self.with_decoder(tcx, pos, |decoder| decode_tagged(decoder, dep_node_index));\n+        Some(value)\n     }\n \n     fn with_decoder<'a, 'tcx, T, F: for<'s> FnOnce(&mut CacheDecoder<'s, 'tcx>) -> T>("}, {"sha": "ca3c3997df003d43d55277cbc3b227578396cf21", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=1ca103a16885564a999dce3916d97007766f2ff1", "patch": "@@ -364,6 +364,14 @@ where\n     }\n }\n \n+pub(crate) fn loadable_from_disk<'tcx>(tcx: QueryCtxt<'tcx>, id: SerializedDepNodeIndex) -> bool {\n+    if let Some(cache) = tcx.on_disk_cache().as_ref() {\n+        cache.loadable_from_disk(id)\n+    } else {\n+        false\n+    }\n+}\n+\n pub(crate) fn try_load_from_disk<'tcx, V>(\n     tcx: QueryCtxt<'tcx>,\n     id: SerializedDepNodeIndex,\n@@ -535,6 +543,21 @@ macro_rules! define_queries {\n                 })\n             }\n \n+            #[inline]\n+            fn loadable_from_disk(\n+                self,\n+                _qcx: QueryCtxt<'tcx>,\n+                _key: &Self::Key,\n+                _index: SerializedDepNodeIndex,\n+            ) -> bool {\n+                should_ever_cache_on_disk!([$($modifiers)*] {\n+                    self.cache_on_disk(_qcx.tcx, _key) &&\n+                        $crate::plumbing::loadable_from_disk(_qcx, _index)\n+                } {\n+                    false\n+                })\n+            }\n+\n             #[inline(always)]\n             fn anon(self) -> bool {\n                 is_anon!([$($modifiers)*])"}, {"sha": "a0aeb812af968124f211fa6202335da3c32ed499", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=1ca103a16885564a999dce3916d97007766f2ff1", "patch": "@@ -43,6 +43,8 @@ pub trait QueryConfig<Qcx: QueryContext>: Copy {\n \n     fn try_load_from_disk(self, qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self::Value>;\n \n+    fn loadable_from_disk(self, qcx: Qcx, key: &Self::Key, idx: SerializedDepNodeIndex) -> bool;\n+\n     fn anon(self) -> bool;\n     fn eval_always(self) -> bool;\n     fn depth_limit(self) -> bool;"}, {"sha": "1229a5fe5e803cb3beb2bf5e60966cf0a2e2facd", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca103a16885564a999dce3916d97007766f2ff1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=1ca103a16885564a999dce3916d97007766f2ff1", "patch": "@@ -557,10 +557,17 @@ where\n         // can be forced from `DepNode`.\n         debug_assert!(\n             !qcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n-            \"missing on-disk cache entry for {dep_node:?}\"\n+            \"missing on-disk cache entry for reconstructible {dep_node:?}\"\n         );\n     }\n \n+    // Sanity check for the logic in `ensure`: if the node is green and the result loadable,\n+    // we should actually be able to load it.\n+    debug_assert!(\n+        !query.loadable_from_disk(qcx, &key, prev_dep_node_index),\n+        \"missing on-disk cache entry for loadable {dep_node:?}\"\n+    );\n+\n     // We could not load a result from the on-disk cache, so\n     // recompute.\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n@@ -719,22 +726,25 @@ where\n     let dep_node = query.construct_dep_node(*qcx.dep_context(), key);\n \n     let dep_graph = qcx.dep_context().dep_graph();\n-    match dep_graph.try_mark_green(qcx, &dep_node) {\n+    let serialized_dep_node_index = match dep_graph.try_mark_green(qcx, &dep_node) {\n         None => {\n             // A None return from `try_mark_green` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n             // Either way, we can't call `dep_graph.read()` as we don't have the\n             // DepNodeIndex. We must invoke the query itself. The performance cost\n             // this introduces should be negligible as we'll immediately hit the\n             // in-memory cache, or another query down the line will.\n-            (true, Some(dep_node))\n+            return (true, Some(dep_node));\n         }\n-        Some((_, dep_node_index)) => {\n+        Some((serialized_dep_node_index, dep_node_index)) => {\n             dep_graph.read_index(dep_node_index);\n             qcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n-            (false, None)\n+            serialized_dep_node_index\n         }\n-    }\n+    };\n+\n+    let loadable = query.loadable_from_disk(qcx, key, serialized_dep_node_index);\n+    (!loadable, Some(dep_node))\n }\n \n #[derive(Debug)]"}]}