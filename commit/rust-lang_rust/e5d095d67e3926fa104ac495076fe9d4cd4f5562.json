{"sha": "e5d095d67e3926fa104ac495076fe9d4cd4f5562", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZDA5NWQ2N2UzOTI2ZmExMDRhYzQ5NTA3NmZlOWQ0Y2Q0ZjU1NjI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-01T01:05:20Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-01T01:05:20Z"}, "message": "Change option::t to option\n\nNow that core exports \"option\" as a synonym for option::t, search-and-\nreplace option::t with option.\n\nThe only place that still refers to option::t are the modules in libcore\nthat use option, because fixing this requires a new snapshot\n(forthcoming).", "tree": {"sha": "07be94199b1062e4ba99be9c014178d26543a0aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07be94199b1062e4ba99be9c014178d26543a0aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5d095d67e3926fa104ac495076fe9d4cd4f5562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d095d67e3926fa104ac495076fe9d4cd4f5562", "html_url": "https://github.com/rust-lang/rust/commit/e5d095d67e3926fa104ac495076fe9d4cd4f5562", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5d095d67e3926fa104ac495076fe9d4cd4f5562/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f795ff3b0c0cac31c1d9fd2406d0d53e774683a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f795ff3b0c0cac31c1d9fd2406d0d53e774683a", "html_url": "https://github.com/rust-lang/rust/commit/1f795ff3b0c0cac31c1d9fd2406d0d53e774683a"}], "stats": {"total": 727, "additions": 362, "deletions": 365}, "files": [{"sha": "fd39797b29fc09bccd902b4521472a28bd454ce5", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -32,16 +32,16 @@ type package = {\n     url: str,\n     method: str,\n     description: str,\n-    ref: option::t<str>,\n+    ref: option<str>,\n     tags: [str]\n };\n \n type source = {\n     name: str,\n     url: str,\n-    sig: option::t<str>,\n-    key: option::t<str>,\n-    keyfp: option::t<str>,\n+    sig: option<str>,\n+    key: option<str>,\n+    keyfp: option<str>,\n     mutable packages: [package]\n };\n \n@@ -60,9 +60,9 @@ type pkg = {\n     name: str,\n     vers: str,\n     uuid: str,\n-    desc: option::t<str>,\n-    sigs: option::t<str>,\n-    crate_type: option::t<str>\n+    desc: option<str>,\n+    sigs: option<str>,\n+    crate_type: option<str>\n };\n \n fn info(msg: str) {\n@@ -77,9 +77,9 @@ fn error(msg: str) {\n     io::stdout().write_line(\"error: \" + msg);\n }\n \n-fn load_link(mis: [@ast::meta_item]) -> (option::t<str>,\n-                                         option::t<str>,\n-                                         option::t<str>) {\n+fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n+                                         option<str>,\n+                                         option<str>) {\n     let name = none;\n     let vers = none;\n     let uuid = none;\n@@ -99,7 +99,7 @@ fn load_link(mis: [@ast::meta_item]) -> (option::t<str>,\n     (name, vers, uuid)\n }\n \n-fn load_pkg(filename: str) -> option::t<pkg> {\n+fn load_pkg(filename: str) -> option<pkg> {\n     let cm = codemap::new_codemap();\n     let handler = diagnostic::mk_handler(none);\n     let sess = @{\n@@ -439,7 +439,7 @@ fn install_source(c: cargo, path: str) {\n     }\n }\n \n-fn install_git(c: cargo, wd: str, url: str, ref: option::t<str>) {\n+fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n     run::run_program(\"git\", [\"clone\", url, wd]);\n     if option::is_some::<str>(ref) {\n         let r = option::get::<str>(ref);"}, {"sha": "b7a16d7e863b8fcbe942a6473fc749f2d6ef30bc", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -38,7 +38,7 @@ fn llvm_err(sess: session, msg: str) unsafe {\n     } else { sess.fatal(msg + \": \" + str::from_cstr(buf)); }\n }\n \n-fn load_intrinsics_bc(sess: session) -> option::t<ModuleRef> {\n+fn load_intrinsics_bc(sess: session) -> option<ModuleRef> {\n     let path = alt filesearch::search(\n         sess.filesearch,\n         bind filesearch::pick_file(\"intrinsics.bc\", _)) {\n@@ -368,14 +368,14 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n                    sha: sha1) -> link_meta {\n \n     type provided_metas =\n-        {name: option::t<str>,\n-         vers: option::t<str>,\n+        {name: option<str>,\n+         vers: option<str>,\n          cmh_items: [@ast::meta_item]};\n \n     fn provided_link_metas(sess: session, c: ast::crate) ->\n        provided_metas {\n-        let name: option::t<str> = none;\n-        let vers: option::t<str> = none;\n+        let name: option<str> = none;\n+        let vers: option<str> = none;\n         let cmh_items: [@ast::meta_item] = [];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);"}, {"sha": "3a96762f41e9444a874b7b8aad067dc9f2d0be44", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -105,8 +105,8 @@ enum compile_upto {\n \n fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                 input: str, upto: compile_upto,\n-                outputs: option::t<output_filenames>)\n-    -> {crate: @ast::crate, tcx: option::t<ty::ctxt>} {\n+                outputs: option<output_filenames>)\n+    -> {crate: @ast::crate, tcx: option<ty::ctxt>} {\n     let time_passes = sess.opts.time_passes;\n     let crate = time(time_passes, \"parsing\",\n                      bind parse_input(sess, cfg, input));\n@@ -197,7 +197,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n }\n \n fn compile_input(sess: session, cfg: ast::crate_cfg, input: str,\n-                 outdir: option::t<str>, output: option::t<str>) {\n+                 outdir: option<str>, output: option<str>) {\n \n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n@@ -504,8 +504,8 @@ fn opts() -> [getopts::opt] {\n type output_filenames = @{out_filename: str, obj_filename:str};\n \n fn build_output_filenames(ifile: str,\n-                          odir: option::t<str>,\n-                          ofile: option::t<str>,\n+                          odir: option<str>,\n+                          ofile: option<str>,\n                           sess: session)\n         -> output_filenames {\n     let obj_path = \"\";"}, {"sha": "897e367251c38e232b6a4e84bd5e201f392b7275", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -40,7 +40,7 @@ type options =\n      time_llvm_passes: bool,\n      output_type: back::link::output_type,\n      addl_lib_search_paths: [str],\n-     maybe_sysroot: option::t<str>,\n+     maybe_sysroot: option<str>,\n      target_triple: str,\n      cfg: ast::crate_cfg,\n      test: bool,\n@@ -58,7 +58,7 @@ type session = @{targ_cfg: @config,\n                  parse_sess: parse_sess,\n                  codemap: codemap::codemap,\n                  // For a library crate, this is always none\n-                 mutable main_fn: option::t<(node_id, codemap::span)>,\n+                 mutable main_fn: option<(node_id, codemap::span)>,\n                  span_diagnostic: diagnostic::span_handler,\n                  filesearch: filesearch::filesearch,\n                  mutable building_library: bool,"}, {"sha": "e90fd0ecdfb13e67a8d8707a10238306649a01e8", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -48,7 +48,7 @@ fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n fn find_attrs_by_name(attrs: [ast::attribute], name: ast::ident) ->\n    [ast::attribute] {\n     let filter = (\n-        fn@(a: ast::attribute) -> option::t<ast::attribute> {\n+        fn@(a: ast::attribute) -> option<ast::attribute> {\n             if get_attr_name(a) == name {\n                 option::some(a)\n             } else { option::none }\n@@ -67,7 +67,7 @@ fn get_attr_name(attr: ast::attribute) -> ast::ident {\n \n fn find_meta_items_by_name(metas: [@ast::meta_item], name: ast::ident) ->\n    [@ast::meta_item] {\n-    let filter = fn@(&&m: @ast::meta_item) -> option::t<@ast::meta_item> {\n+    let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n         if get_meta_item_name(m) == name {\n             option::some(m)\n         } else { option::none }\n@@ -85,7 +85,7 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n \n // Gets the string value if the meta_item is a meta_name_value variant\n // containing a string, otherwise none\n-fn get_meta_item_value_str(meta: @ast::meta_item) -> option::t<str> {\n+fn get_meta_item_value_str(meta: @ast::meta_item) -> option<str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n         alt v.node { ast::lit_str(s) { option::some(s) } _ { option::none } }\n@@ -95,15 +95,15 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> option::t<str> {\n }\n \n fn get_meta_item_value_str_by_name(attrs: [ast::attribute], name: ast::ident)\n-    -> option::t<str> {\n+    -> option<str> {\n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n         ret get_meta_item_value_str(attr_meta(mattrs[0]));\n     }\n     ret option::none;\n }\n \n-fn get_meta_item_list(meta: @ast::meta_item) -> option::t<[@ast::meta_item]> {\n+fn get_meta_item_list(meta: @ast::meta_item) -> option<[@ast::meta_item]> {\n     alt meta.node {\n       ast::meta_list(_, l) { option::some(l) }\n       _ { option::none }\n@@ -184,7 +184,7 @@ fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->\n    [@ast::meta_item] {\n \n-    let filter = fn@(&&item: @ast::meta_item) -> option::t<@ast::meta_item> {\n+    let filter = fn@(&&item: @ast::meta_item) -> option<@ast::meta_item> {\n         if get_meta_item_name(item) != name {\n             option::some(item)\n         } else { option::none }"}, {"sha": "5e5723680d9cfdfc54b0a2914afd00ef85cc0e69", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -37,7 +37,7 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n }\n \n fn filter_item(cx: ctxt, &&item: @ast::item) ->\n-   option::t<@ast::item> {\n+   option<@ast::item> {\n     if item_in_cfg(cx, item) { option::some(item) } else { option::none }\n }\n \n@@ -50,7 +50,7 @@ fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) ->\n }\n \n fn filter_native_item(cx: ctxt, &&item: @ast::native_item) ->\n-   option::t<@ast::native_item> {\n+   option<@ast::native_item> {\n     if native_item_in_cfg(cx, item) {\n         option::some(item)\n     } else { option::none }\n@@ -65,7 +65,7 @@ fn fold_native_mod(cx: ctxt, nm: ast::native_mod,\n }\n \n fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n-   option::t<@ast::stmt> {\n+   option<@ast::stmt> {\n     alt stmt.node {\n       ast::stmt_decl(decl, _) {\n         alt decl.node {"}, {"sha": "0e84930658a8ecbd7fdc9de0affd406f03fff938", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -67,7 +67,7 @@ fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     // the one we're going to add.  FIXME: This is sloppy. Instead we should\n     // have some mechanism to indicate to the translation pass which function\n     // we want to be main.\n-    fn nomain(&&item: @ast::item) -> option::t<@ast::item> {\n+    fn nomain(&&item: @ast::item) -> option<@ast::item> {\n         alt item.node {\n           ast::item_fn(_, _, _) {\n             if item.ident == \"main\" {"}, {"sha": "9dcee021b56db960e83193760086f6369828f90d", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -917,11 +917,11 @@ fn associate_type(tn: type_names, s: str, t: TypeRef) {\n     assert tn.named_types.insert(s, t);\n }\n \n-fn type_has_name(tn: type_names, t: TypeRef) -> option::t<str> {\n+fn type_has_name(tn: type_names, t: TypeRef) -> option<str> {\n     ret tn.type_names.find(t);\n }\n \n-fn name_has_type(tn: type_names, s: str) -> option::t<TypeRef> {\n+fn name_has_type(tn: type_names, s: str) -> option<TypeRef> {\n     ret tn.named_types.find(s);\n }\n \n@@ -1072,7 +1072,7 @@ resource object_file_res(ObjectFile: ObjectFileRef) {\n \n type object_file = {llof: ObjectFileRef, dtor: @object_file_res};\n \n-fn mk_object_file(llmb: MemoryBufferRef) -> option::t<object_file> {\n+fn mk_object_file(llmb: MemoryBufferRef) -> option<object_file> {\n     let llof = llvm::LLVMCreateObjectFile(llmb);\n     if llof as int == 0 { ret option::none::<object_file>; }\n     ret option::some({llof: llof, dtor: @object_file_res(llof)});"}, {"sha": "4929b02b7af477faf8bb4fe858d65aada18a22d8", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -137,7 +137,7 @@ fn default_native_lib_naming(sess: session::session, static: bool) ->\n \n fn find_library_crate(sess: session::session, ident: ast::ident,\n                       metas: [@ast::meta_item])\n-   -> option::t<{ident: str, data: @[u8]}> {\n+   -> option<{ident: str, data: @[u8]}> {\n \n     attr::require_unique_names(sess, metas);\n     let metas = metas;\n@@ -173,7 +173,7 @@ fn find_library_crate_aux(sess: session::session,\n                           crate_name: str,\n                           metas: [@ast::meta_item],\n                           filesearch: filesearch::filesearch) ->\n-   option::t<{ident: str, data: @[u8]}> {\n+   option<{ident: str, data: @[u8]}> {\n     let prefix: str = nn.prefix + crate_name + \"-\";\n     let suffix: str = nn.suffix;\n \n@@ -206,7 +206,7 @@ fn find_library_crate_aux(sess: session::session,\n }\n \n fn get_metadata_section(sess: session::session,\n-                        filename: str) -> option::t<@[u8]> unsafe {\n+                        filename: str) -> option<@[u8]> unsafe {\n     let mb = str::as_buf(filename, {|buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n                                    });"}, {"sha": "941fedb0c205223258123a979d2df3112122d05c", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -63,7 +63,7 @@ fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n }\n \n fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n-                     name: option::t<ast::ident>)\n+                     name: option<ast::ident>)\n     -> @[@middle::resolve::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impls_for_mod(cdata, def.node, name)\n@@ -82,7 +82,7 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n }\n \n fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id)\n-    -> option::t<ty::t> {\n+    -> option<ty::t> {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_iface(cdata, def.node, tcx)"}, {"sha": "2ce10e8673cac80db920014057984ad22a5afa27", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -55,7 +55,7 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]) -> bool, hash: uint) ->\n     ret result;\n }\n \n-fn maybe_find_item(item_id: int, items: ebml::doc) -> option::t<ebml::doc> {\n+fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n     fn eq_item(bytes: [u8], item_id: int) -> bool {\n         ret ebml::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n     }\n@@ -92,7 +92,7 @@ fn variant_enum_id(d: ebml::doc) -> ast::def_id {\n     ret parse_def_id(ebml::doc_data(tagdoc));\n }\n \n-fn variant_disr_val(d: ebml::doc) -> option::t<int> {\n+fn variant_disr_val(d: ebml::doc) -> option<int> {\n     alt ebml::maybe_get_doc(d, tag_disr_val) {\n       some(val_doc) {\n         let val_buf = ebml::doc_data(val_doc);\n@@ -118,7 +118,7 @@ fn item_type(item: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n }\n \n fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n-    -> option::t<ty::t> {\n+    -> option<ty::t> {\n     let result = none;\n     ebml::tagged_docs(item, tag_impl_iface) {|ity|\n         let t = parse_ty_data(ity.data, cdata.cnum, ity.start, tcx, {|did|\n@@ -227,7 +227,7 @@ fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {\n }\n \n fn get_impl_iface(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-    -> option::t<ty::t> {\n+    -> option<ty::t> {\n     item_impl_iface(lookup_item(id, cdata.data), tcx, cdata)\n }\n \n@@ -279,7 +279,7 @@ fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n }\n \n fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n-                     name: option::t<ast::ident>)\n+                     name: option<ast::ident>)\n     -> @[@middle::resolve::_impl] {\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data), result = [];"}, {"sha": "cecdffc35c18023abec6002d7517ce09a3f98bcf", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -27,7 +27,7 @@ enum unsafe_ty { contains(ty::t), mut_contains(ty::t), }\n \n type binding = @{node_id: node_id,\n                  span: span,\n-                 root_var: option::t<node_id>,\n+                 root_var: option<node_id>,\n                  local_id: uint,\n                  unsafe_tys: [unsafe_ty],\n                  mutable copied: copied};\n@@ -36,7 +36,7 @@ type binding = @{node_id: node_id,\n type scope = {bs: [binding],\n               invalid: @mutable list<@invalid>};\n \n-fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option::t<node_id>,\n+fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option<node_id>,\n               unsafe_tys: [unsafe_ty]) -> binding {\n     alt root_var {\n       some(r_id) { cx.ref_map.insert(id, r_id); }\n@@ -427,7 +427,7 @@ fn check_assign(cx: @ctx, dest: @ast::expr, src: @ast::expr, sc: scope,\n     check_lval(cx, dest, sc, v);\n }\n \n-fn check_if(c: @ast::expr, then: ast::blk, els: option::t<@ast::expr>,\n+fn check_if(c: @ast::expr, then: ast::blk, els: option<@ast::expr>,\n             sc: scope, v: vt<scope>) {\n     v.visit_expr(c, sc, v);\n     let orig_invalid = *sc.invalid;\n@@ -476,14 +476,14 @@ fn test_scope(cx: ctx, sc: scope, b: binding, p: @ast::path) {\n     }\n }\n \n-fn path_def(cx: ctx, ex: @ast::expr) -> option::t<ast::def> {\n+fn path_def(cx: ctx, ex: @ast::expr) -> option<ast::def> {\n     ret alt ex.node {\n           ast::expr_path(_) { some(cx.tcx.def_map.get(ex.id)) }\n           _ { none }\n         }\n }\n \n-fn path_def_id(cx: ctx, ex: @ast::expr) -> option::t<ast::node_id> {\n+fn path_def_id(cx: ctx, ex: @ast::expr) -> option<ast::node_id> {\n     alt ex.node {\n       ast::expr_path(_) {\n         ret some(ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id)).node);\n@@ -589,12 +589,12 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n \n type pattern_root = {id: node_id,\n                      name: ident,\n-                     mut: option::t<unsafe_ty>,\n+                     mut: option<unsafe_ty>,\n                      span: span};\n \n-fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n+fn pattern_roots(tcx: ty::ctxt, mut: option<unsafe_ty>, pat: @ast::pat)\n     -> [pattern_root] {\n-    fn walk(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat,\n+    fn walk(tcx: ty::ctxt, mut: option<unsafe_ty>, pat: @ast::pat,\n             &set: [pattern_root]) {\n         alt normalize_pat(tcx, pat).node {\n           ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) {}\n@@ -642,7 +642,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n // Wraps the expr_root in mut.rs to also handle roots that exist through\n // return-by-reference\n fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n-    -> {ex: @ast::expr, mut: option::t<unsafe_ty>} {\n+    -> {ex: @ast::expr, mut: option<unsafe_ty>} {\n     let base_root = mut::expr_root(cx.tcx, ex, autoderef);\n     let unsafe_ty = none;\n     for d in *base_root.ds {\n@@ -651,12 +651,12 @@ fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n     ret {ex: base_root.ex, mut: unsafe_ty};\n }\n \n-fn unsafe_set(from: option::t<unsafe_ty>) -> [unsafe_ty] {\n+fn unsafe_set(from: option<unsafe_ty>) -> [unsafe_ty] {\n     alt from { some(t) { [t] } _ { [] } }\n }\n \n fn find_invalid(id: node_id, lst: list<@invalid>)\n-    -> option::t<@invalid> {\n+    -> option<@invalid> {\n     let cur = lst;\n     while true {\n         alt cur {"}, {"sha": "177bbef06eac32810e54bef09dbee6b2625b01b6", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -143,7 +143,7 @@ fn md_from_metadata<T>(val: debug_metadata) -> T unsafe {\n }\n \n fn cached_metadata<T: copy>(cache: metadata_cache, mdtag: int,\n-                           eq: fn(md: T) -> bool) -> option::t<T> unsafe {\n+                           eq: fn(md: T) -> bool) -> option<T> unsafe {\n     if cache.contains_key(mdtag) {\n         let items = cache.get(mdtag);\n         for item in items {\n@@ -456,8 +456,8 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n \n fn create_composite_type(type_tag: int, name: str, file: ValueRef, line: int,\n                          size: int, align: int, offset: int,\n-                         derived: option::t<ValueRef>,\n-                         members: option::t<[ValueRef]>)\n+                         derived: option<ValueRef>,\n+                         members: option<[ValueRef]>)\n     -> ValueRef {\n     let lldata = [lltag(type_tag),\n                   file,"}, {"sha": "27968048a57d9fbc2a913477bec5384dd890eedf", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -298,7 +298,7 @@ fn clear_def_if_path(cx: ctx, d: def, to: bool)\n }\n \n fn clear_if_path(cx: ctx, ex: @expr, v: visit::vt<ctx>, to: bool)\n-    -> option::t<node_id> {\n+    -> option<node_id> {\n     alt ex.node {\n       expr_path(_) {\n         ret clear_def_if_path(cx, cx.def_map.get(ex.id), to);"}, {"sha": "bf9f3b1c88bf0cb4338b2527ed7f1cfb0a800f38", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -240,7 +240,7 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n     }\n }\n \n-fn check_bind(cx: @ctx, f: @expr, args: [option::t<@expr>]) {\n+fn check_bind(cx: @ctx, f: @expr, args: [option<@expr>]) {\n     let arg_ts = ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f));\n     let i = 0u;\n     for arg in args {\n@@ -264,7 +264,7 @@ fn check_bind(cx: @ctx, f: @expr, args: [option::t<@expr>]) {\n     }\n }\n \n-fn is_immutable_def(cx: @ctx, def: def) -> option::t<str> {\n+fn is_immutable_def(cx: @ctx, def: def) -> option<str> {\n     alt def {\n       def_fn(_, _) | def_mod(_) | def_native_mod(_) | def_const(_) |\n       def_use(_) {"}, {"sha": "12895459b75a67986afdde98984053024fb53c80", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -48,19 +48,19 @@ enum import_state {\n     todo(ast::node_id, ast::ident, @[ast::ident], span, scopes),\n     is_glob(@[ast::ident], scopes, span),\n     resolving(span),\n-    resolved(option::t<def>, /* value */\n-             option::t<def>, /* type */\n-             option::t<def>, /* module */\n+    resolved(option<def>, /* value */\n+             option<def>, /* type */\n+             option<def>, /* module */\n              @[@_impl], /* impls */\n              /* used for reporting unused import warning */\n              ast::ident, span),\n }\n \n enum glob_import_state {\n     glob_resolving(span),\n-    glob_resolved(option::t<def>,  /* value */\n-                  option::t<def>,  /* type */\n-                  option::t<def>), /* module */\n+    glob_resolved(option<def>,  /* value */\n+                  option<def>,  /* type */\n+                  option<def>), /* module */\n }\n \n type ext_hash = hashmap<{did: def_id, ident: str, ns: namespace}, def>;\n@@ -98,7 +98,7 @@ type mod_index = hashmap<ident, list<mod_index_entry>>;\n type glob_imp_def = {def: def, item: @ast::view_item};\n \n type indexed_mod = {\n-    m: option::t<ast::_mod>,\n+    m: option<ast::_mod>,\n     index: mod_index,\n     mutable glob_imports: [glob_imp_def],\n     glob_imported_names: hashmap<str, glob_import_state>,\n@@ -113,7 +113,7 @@ type def_map = hashmap<node_id, def>;\n type ext_map = hashmap<def_id, [ident]>;\n type exp_map = hashmap<str, @mutable [def]>;\n type impl_map = hashmap<node_id, iscopes>;\n-type impl_cache = hashmap<def_id, option::t<@[@_impl]>>;\n+type impl_cache = hashmap<def_id, option<@[@_impl]>>;\n \n type env =\n     {cstore: cstore::cstore,\n@@ -131,7 +131,7 @@ type env =\n                     mutable data: [ast::node_id]},\n      mutable reported: [{ident: str, sc: scope}],\n      mutable ignored_imports: [node_id],\n-     mutable current_tp: option::t<uint>,\n+     mutable current_tp: option<uint>,\n      mutable resolve_unexported: bool,\n      sess: session};\n \n@@ -324,7 +324,7 @@ fn resolve_capture_item(e: @env, sc: scopes, &&cap_item: @ast::capture_item) {\n     maybe_insert(e, cap_item.id, dcur);\n }\n \n-fn maybe_insert(e: @env, id: node_id, def: option::t<def>) {\n+fn maybe_insert(e: @env, id: node_id, def: option<def>) {\n     if option::is_some(def) { e.def_map.insert(id, option::get(def)); }\n }\n \n@@ -578,7 +578,7 @@ fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n \n \n fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n-   option::t<def> {\n+   option<def> {\n     let path_len = vec::len(path);\n     let dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n     let i = 1u;\n@@ -623,7 +623,7 @@ fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n                   ids: [ast::ident], sp: codemap::span, sc: scopes) {\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n-                name: ast::ident, lookup: fn(namespace) -> option::t<def>,\n+                name: ast::ident, lookup: fn(namespace) -> option<def>,\n                 impls: [@_impl]) {\n         let val = lookup(ns_val(ns_any_value)), typ = lookup(ns_type),\n             md = lookup(ns_module);\n@@ -746,7 +746,7 @@ fn ns_name(ns: namespace) -> str {\n enum ctxt { in_mod(def), in_scope(scopes), }\n \n fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n-    fn find_fn_or_mod_scope(sc: scopes) -> option::t<scope> {\n+    fn find_fn_or_mod_scope(sc: scopes) -> option<scope> {\n         let sc = sc;\n         while true {\n             alt sc {\n@@ -803,7 +803,7 @@ fn mk_unresolved_msg(id: ident, kind: str) -> str {\n \n // Lookup helpers\n fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n-                      ns: namespace) -> option::t<def> {\n+                      ns: namespace) -> option<def> {\n     let n_idents = vec::len(pth.idents);\n     let headns = if n_idents == 1u { ns } else { ns_module };\n \n@@ -827,7 +827,7 @@ fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n }\n \n fn lookup_in_scope_strict(e: env, sc: scopes, sp: span, name: ident,\n-                          ns: namespace) -> option::t<def> {\n+                          ns: namespace) -> option<def> {\n     alt lookup_in_scope(e, sc, sp, name, ns) {\n       none {\n         unresolved_err(e, in_scope(sc), sp, name, ns_name(ns));\n@@ -847,7 +847,7 @@ fn scope_is_fn(sc: scope) -> bool {\n // Returns:\n //   none - does not close\n //   some(node_id) - closes via the expr w/ node_id\n-fn scope_closes(sc: scope) -> option::t<node_id> {\n+fn scope_closes(sc: scope) -> option<node_id> {\n     alt sc {\n       scope_fn_expr(_, node_id, _) { some(node_id) }\n       _ { none }\n@@ -874,9 +874,9 @@ fn def_is_ty_arg(d: def) -> bool {\n }\n \n fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n-   -> option::t<def> {\n+   -> option<def> {\n     fn in_scope(e: env, sp: span, name: ident, s: scope, ns: namespace) ->\n-       option::t<def> {\n+       option<def> {\n         alt s {\n           scope_crate {\n             ret lookup_in_local_mod(e, ast::crate_node_id, sp,\n@@ -1003,7 +1003,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n }\n \n fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n-    -> option::t<def> {\n+    -> option<def> {\n     let n = 0u;\n     for tp: ast::ty_param in ty_params {\n         if str::eq(tp.ident, name) && alt e.current_tp {\n@@ -1014,7 +1014,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n     ret none::<def>;\n }\n \n-fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option::t<def_id> {\n+fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option<def_id> {\n     let found = none;\n \n     pat_util::pat_bindings(normalize_pat_def_map(e.def_map, pat))\n@@ -1027,7 +1027,7 @@ fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option::t<def_id> {\n \n fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n                 ty_params: [ast::ty_param],\n-                ns: namespace) -> option::t<def> {\n+                ns: namespace) -> option<def> {\n     alt ns {\n       ns_val(ns_any_value) {\n         for a: ast::arg in decl.inputs {\n@@ -1044,7 +1044,7 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n \n \n fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n-                   loc_pos: uint, ns: namespace) -> option::t<def> {\n+                   loc_pos: uint, ns: namespace) -> option<def> {\n     let i = vec::len(b.stmts);\n     while i > 0u {\n         i -= 1u;\n@@ -1132,7 +1132,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n     ret none;\n }\n \n-fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n+fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n     alt i.node {\n       ast::item_const(_, _) {\n         if ns == ns_val(ns_any_value) {\n@@ -1167,7 +1167,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n }\n \n fn lookup_in_mod_strict(e: env, m: def, sp: span, name: ident,\n-                        ns: namespace, dr: dir) -> option::t<def> {\n+                        ns: namespace, dr: dir) -> option<def> {\n     alt lookup_in_mod(e, m, sp, name, ns, dr) {\n       none {\n         unresolved_err(e, in_mod(m), sp, name, ns_name(ns));\n@@ -1178,7 +1178,7 @@ fn lookup_in_mod_strict(e: env, m: def, sp: span, name: ident,\n }\n \n fn lookup_in_mod(e: env, m: def, sp: span, name: ident, ns: namespace,\n-                 dr: dir) -> option::t<def> {\n+                 dr: dir) -> option<def> {\n     let defid = def_id_of_def(m);\n     if defid.crate != ast::local_crate {\n         // examining a module in an external crate\n@@ -1214,7 +1214,7 @@ fn found_view_item(e: env, id: node_id) -> def {\n     ret ast::def_mod({crate: cnum, node: ast::crate_node_id});\n }\n \n-fn lookup_import(e: env, defid: def_id, ns: namespace) -> option::t<def> {\n+fn lookup_import(e: env, defid: def_id, ns: namespace) -> option<def> {\n     // Imports are simply ignored when resolving themselves.\n     if vec::member(defid.node, e.ignored_imports) { ret none; }\n     alt e.imports.get(defid.node) {\n@@ -1240,7 +1240,7 @@ fn lookup_import(e: env, defid: def_id, ns: namespace) -> option::t<def> {\n }\n \n fn lookup_in_local_native_mod(e: env, node_id: node_id, sp: span, id: ident,\n-                              ns: namespace) -> option::t<def> {\n+                              ns: namespace) -> option<def> {\n     ret lookup_in_local_mod(e, node_id, sp, id, ns, inside);\n }\n \n@@ -1249,7 +1249,7 @@ fn is_exported(e: env, i: ident, m: _mod) -> bool {\n }\n \n fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n-                       ns: namespace, dr: dir) -> option::t<def> {\n+                       ns: namespace, dr: dir) -> option<def> {\n     let info = e.mod_map.get(node_id);\n     if dr == outside && !is_exported(e, id, option::get(info.m)) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n@@ -1276,9 +1276,9 @@ fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n }\n \n fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n-                   ns: namespace, dr: dir) -> option::t<def> {\n+                   ns: namespace, dr: dir) -> option<def> {\n     fn lookup_in_mod_(e: env, def: glob_imp_def, sp: span, name: ident,\n-                      ns: namespace, dr: dir) -> option::t<glob_imp_def> {\n+                      ns: namespace, dr: dir) -> option<glob_imp_def> {\n         alt def.item.node {\n           ast::view_item_import_glob(_, id) {\n             if vec::member(id, e.ignored_imports) { ret none; }\n@@ -1310,7 +1310,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n }\n \n fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n-                      wanted_ns: namespace, dr: dir) -> option::t<def> {\n+                      wanted_ns: namespace, dr: dir) -> option<def> {\n     // since we don't know what names we have in advance,\n     // absence takes the place of todo()\n     if !info.glob_imported_names.contains_key(id) {\n@@ -1339,7 +1339,7 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n }\n \n fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n-   option::t<def> {\n+   option<def> {\n     alt mie {\n       mie_view_item(_, id, _) {\n          if ns == ns_module { ret some(found_view_item(e, id)); }\n@@ -1487,7 +1487,7 @@ fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n }\n \n fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n-   option::t<def> {\n+   option<def> {\n     for d: def in csearch::lookup_defs(e.sess.cstore, cnum, ids) {\n         e.ext_map.insert(def_id_of_def(d), ids);\n         if ns_ok(ns, ns_for_def(d)) { ret some(d); }\n@@ -1734,7 +1734,7 @@ fn check_exports(e: @env) {\n         is_some(m) || is_some(v) || is_some(t)\n     }\n \n-    fn maybe_add_reexport(e: @env, path: str, def: option::t<def>) {\n+    fn maybe_add_reexport(e: @env, path: str, def: option<def>) {\n         alt def {\n           some(def) {\n             alt e.exp_map.find(path) {\n@@ -1868,7 +1868,7 @@ fn resolve_impls(e: @env, c: @ast::crate) {\n }\n \n fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n-                           &impls: [@_impl], sc: option::t<iscopes>) {\n+                           &impls: [@_impl], sc: option<iscopes>) {\n     fn lookup_imported_impls(e: env, id: ast::node_id,\n                              act: fn(@[@_impl])) {\n         alt e.imports.get(id) {\n@@ -1930,8 +1930,8 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n }\n \n fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n-                      name: option::t<ident>,\n-                      ck_exports: option::t<ast::_mod>) {\n+                      name: option<ident>,\n+                      ck_exports: option<ast::_mod>) {\n     alt i.node {\n       ast::item_impl(_, ifce, _, mthds) {\n         if alt name { some(n) { n == i.ident } _ { true } } &&\n@@ -1953,7 +1953,7 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n }\n \n fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n-                           name: option::t<ident>) {\n+                           name: option<ident>) {\n     let cached;\n     alt e.impl_cache.find(defid) {\n       some(some(v)) { cached = v; }\n@@ -1987,7 +1987,7 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n }\n \n fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n-                     name: option::t<ident>) {\n+                     name: option<ident>) {\n     alt m {\n       ast::def_mod(defid) {\n         find_impls_in_mod_by_id(e, defid, impls, name);"}, {"sha": "0203edb90d13870c1ba3fc4f51ea5f1fb3388727", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -77,7 +77,7 @@ fn variant_opt(ccx: @crate_ctxt, pat_id: ast::node_id) -> opt {\n }\n \n type bind_map = [{ident: ast::ident, val: ValueRef}];\n-fn assoc(key: str, list: bind_map) -> option::t<ValueRef> {\n+fn assoc(key: str, list: bind_map) -> option<ValueRef> {\n     for elt: {ident: ast::ident, val: ValueRef} in list {\n         if str::eq(elt.ident, key) { ret some(elt.val); }\n     }\n@@ -88,7 +88,7 @@ type match_branch =\n     @{pats: [@ast::pat],\n       bound: bind_map,\n       data: @{body: BasicBlockRef,\n-              guard: option::t<@ast::expr>,\n+              guard: option<@ast::expr>,\n               id_map: pat_id_map}};\n type match = [match_branch];\n \n@@ -120,7 +120,7 @@ fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n     result\n }\n \n-type enter_pat = fn@(@ast::pat) -> option::t<[@ast::pat]>;\n+type enter_pat = fn@(@ast::pat) -> option<[@ast::pat]>;\n \n fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n     let result = [];\n@@ -153,7 +153,7 @@ fn enter_default(m: match, col: uint, val: ValueRef) -> match {\n                 _ { false }\n         }\n     }\n-    fn e(p: @ast::pat) -> option::t<[@ast::pat]> {\n+    fn e(p: @ast::pat) -> option<[@ast::pat]> {\n         ret if matches_always(p) { some([]) } else { none };\n     }\n     ret enter_match(m, col, val, e);\n@@ -163,7 +163,7 @@ fn enter_opt(ccx: @crate_ctxt, m: match, opt: opt, col: uint, enum_size: uint,\n              val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(ccx: @crate_ctxt, dummy: @ast::pat, opt: opt, size: uint,\n-         p: @ast::pat) -> option::t<[@ast::pat]> {\n+         p: @ast::pat) -> option<[@ast::pat]> {\n         alt p.node {\n           ast::pat_enum(ctor, subpats) {\n             ret if opt_eq(variant_opt(ccx, p.id), opt) {\n@@ -186,7 +186,7 @@ fn enter_rec(m: match, col: uint, fields: [ast::ident], val: ValueRef) ->\n    match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(dummy: @ast::pat, fields: [ast::ident], p: @ast::pat) ->\n-       option::t<[@ast::pat]> {\n+       option<[@ast::pat]> {\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n             let pats = [];\n@@ -208,7 +208,7 @@ fn enter_rec(m: match, col: uint, fields: [ast::ident], val: ValueRef) ->\n fn enter_tup(m: match, col: uint, val: ValueRef, n_elts: uint) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(dummy: @ast::pat, n_elts: uint, p: @ast::pat) ->\n-       option::t<[@ast::pat]> {\n+       option<[@ast::pat]> {\n         alt p.node {\n           ast::pat_tup(elts) { ret some(elts); }\n           _ { ret some(vec::init_elt(n_elts, dummy)); }\n@@ -219,7 +219,7 @@ fn enter_tup(m: match, col: uint, val: ValueRef, n_elts: uint) -> match {\n \n fn enter_box(m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: @ast::pat, p: @ast::pat) -> option::t<[@ast::pat]> {\n+    fn e(dummy: @ast::pat, p: @ast::pat) -> option<[@ast::pat]> {\n         alt p.node {\n           ast::pat_box(sub) { ret some([sub]); }\n           _ { ret some([dummy]); }\n@@ -230,7 +230,7 @@ fn enter_box(m: match, col: uint, val: ValueRef) -> match {\n \n fn enter_uniq(m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: @ast::pat, p: @ast::pat) -> option::t<[@ast::pat]> {\n+    fn e(dummy: @ast::pat, p: @ast::pat) -> option<[@ast::pat]> {\n         alt p.node {\n           ast::pat_uniq(sub) { ret some([sub]); }\n           _ { ret some([dummy]); }\n@@ -682,7 +682,7 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n     // Cached fail-on-fallthrough block\n     let fail_cx = @mutable none;\n     fn mk_fail(cx: @block_ctxt, sp: span,\n-               done: @mutable option::t<BasicBlockRef>) -> BasicBlockRef {\n+               done: @mutable option<BasicBlockRef>) -> BasicBlockRef {\n         alt *done { some(bb) { ret bb; } _ { } }\n         let fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n         base::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;"}, {"sha": "16cf9952bf7cca5706712aab18827959f1845015", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -878,7 +878,7 @@ fn trans_stack_local_derived_tydesc(cx: @block_ctxt, llsz: ValueRef,\n }\n \n fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n-                      &static_ti: option::t<@tydesc_info>) -> result {\n+                      &static_ti: option<@tydesc_info>) -> result {\n     alt cx.fcx.derived_tydescs.find(t) {\n       some(info) {\n         // If the tydesc escapes in this context, the cached derived\n@@ -949,7 +949,7 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n type get_tydesc_result = {kind: tydesc_kind, result: result};\n \n fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n-              &static_ti: option::t<@tydesc_info>)\n+              &static_ti: option<@tydesc_info>)\n    -> get_tydesc_result {\n \n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n@@ -1366,7 +1366,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     let dtor_addr = common::get_res_dtor(ccx, did, inner_t);\n     let args = [cx.fcx.llretptr, null_env_ptr(cx)];\n     for tp: ty::t in tps {\n-        let ti: option::t<@tydesc_info> = none;\n+        let ti: option<@tydesc_info> = none;\n         let td = get_tydesc(cx, tp, false, ti).result;\n         args += [td.val];\n         cx = td.bcx;\n@@ -1641,7 +1641,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n }\n \n fn lazily_emit_all_tydesc_glue(cx: @block_ctxt,\n-                               static_ti: option::t<@tydesc_info>) {\n+                               static_ti: option<@tydesc_info>) {\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, static_ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_free_glue, static_ti);\n@@ -1650,13 +1650,13 @@ fn lazily_emit_all_tydesc_glue(cx: @block_ctxt,\n \n fn lazily_emit_all_generic_info_tydesc_glues(cx: @block_ctxt,\n                                              gi: generic_info) {\n-    for ti: option::t<@tydesc_info> in gi.static_tis {\n+    for ti: option<@tydesc_info> in gi.static_tis {\n         lazily_emit_all_tydesc_glue(cx, ti);\n     }\n }\n \n fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n-                           static_ti: option::t<@tydesc_info>) {\n+                           static_ti: option<@tydesc_info>) {\n     alt static_ti {\n       none { }\n       some(ti) {\n@@ -1731,7 +1731,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n }\n \n fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n-                         field: int, static_ti: option::t<@tydesc_info>) {\n+                         field: int, static_ti: option<@tydesc_info>) {\n     lazily_emit_tydesc_glue(cx, field, static_ti);\n \n     let static_glue_fn = none;\n@@ -1768,7 +1768,7 @@ fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n \n fn call_tydesc_glue(cx: @block_ctxt, v: ValueRef, t: ty::t, field: int) ->\n    @block_ctxt {\n-    let ti: option::t<@tydesc_info> = none::<@tydesc_info>;\n+    let ti: option<@tydesc_info> = none::<@tydesc_info>;\n     let {bcx: bcx, val: td} = get_tydesc(cx, t, false, ti).result;\n     call_tydesc_glue_full(bcx, v, td, field, ti);\n     ret bcx;\n@@ -2402,7 +2402,7 @@ fn get_dest_addr(dest: dest) -> ValueRef {\n }\n \n fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n-            els: option::t<@ast::expr>, dest: dest)\n+            els: option<@ast::expr>, dest: dest)\n     -> @block_ctxt {\n     let {bcx, val: cond_val} = trans_temp_expr(cx, cond);\n \n@@ -2505,10 +2505,10 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n \n type generic_info = {\n     item_type: ty::t,\n-    static_tis: [option::t<@tydesc_info>],\n+    static_tis: [option<@tydesc_info>],\n     tydescs: [ValueRef],\n     param_bounds: @[ty::param_bounds],\n-    origins: option::t<typeck::dict_res>\n+    origins: option<typeck::dict_res>\n };\n \n enum lval_kind {\n@@ -2528,7 +2528,7 @@ type lval_maybe_callee = {bcx: @block_ctxt,\n                           val: ValueRef,\n                           kind: lval_kind,\n                           env: callee_env,\n-                          generic: option::t<generic_info>};\n+                          generic: option<generic_info>};\n \n fn null_env_ptr(bcx: @block_ctxt) -> ValueRef {\n     C_null(T_opaque_cbox_ptr(bcx_ccx(bcx)))\n@@ -3055,7 +3055,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n //  - new_fn_ctxt\n //  - trans_args\n fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n-              gen: option::t<generic_info>, es: [@ast::expr], fn_ty: ty::t,\n+              gen: option<generic_info>, es: [@ast::expr], fn_ty: ty::t,\n               dest: dest)\n    -> {bcx: @block_ctxt,\n        args: [ValueRef],\n@@ -3378,7 +3378,7 @@ fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n }\n \n fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n-             base: option::t<@ast::expr>, id: ast::node_id,\n+             base: option<@ast::expr>, id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(bcx), id);\n     let bcx = bcx;\n@@ -3809,8 +3809,8 @@ fn trans_check_expr(cx: @block_ctxt, e: @ast::expr, s: str) -> @block_ctxt {\n     ret next_cx;\n }\n \n-fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option::t<span>,\n-                   fail_expr: option::t<@ast::expr>) -> @block_ctxt {\n+fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option<span>,\n+                   fail_expr: option<@ast::expr>) -> @block_ctxt {\n     let bcx = bcx;\n     alt fail_expr {\n       some(expr) {\n@@ -3836,13 +3836,13 @@ fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option::t<span>,\n     }\n }\n \n-fn trans_fail(bcx: @block_ctxt, sp_opt: option::t<span>, fail_str: str) ->\n+fn trans_fail(bcx: @block_ctxt, sp_opt: option<span>, fail_str: str) ->\n     @block_ctxt {\n     let V_fail_str = C_cstr(bcx_ccx(bcx), fail_str);\n     ret trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(bcx: @block_ctxt, sp_opt: option::t<span>,\n+fn trans_fail_value(bcx: @block_ctxt, sp_opt: option<span>,\n                     V_fail_str: ValueRef) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx);\n     let V_filename;\n@@ -3907,7 +3907,7 @@ fn trans_cont(cx: @block_ctxt) -> @block_ctxt {\n     ret trans_break_cont(cx, false);\n }\n \n-fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n+fn trans_ret(bcx: @block_ctxt, e: option<@ast::expr>) -> @block_ctxt {\n     let cleanup_cx = bcx, bcx = bcx;\n     alt e {\n       some(x) { bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr); }\n@@ -4057,7 +4057,7 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n // You probably don't want to use this one. See the\n // next three functions instead.\n fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n-                  name: str, block_span: option::t<span>) -> @block_ctxt {\n+                  name: str, block_span: option<span>) -> @block_ctxt {\n     let s = \"\";\n     if cx.lcx.ccx.sess.opts.save_temps ||\n            cx.lcx.ccx.sess.opts.debuginfo {\n@@ -4086,7 +4086,7 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n \n \n // Use this when you're at the top block of a function or the like.\n-fn new_top_block_ctxt(fcx: @fn_ctxt, sp: option::t<span>) -> @block_ctxt {\n+fn new_top_block_ctxt(fcx: @fn_ctxt, sp: option<span>) -> @block_ctxt {\n     ret new_block_ctxt(fcx, parent_none, SCOPE_BLOCK, \"function top level\",\n                        sp);\n }\n@@ -4101,7 +4101,7 @@ fn new_real_block_ctxt(bcx: @block_ctxt, n: str, sp: span) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n, some(sp));\n }\n \n-fn new_loop_scope_block_ctxt(bcx: @block_ctxt, _cont: option::t<@block_ctxt>,\n+fn new_loop_scope_block_ctxt(bcx: @block_ctxt, _cont: option<@block_ctxt>,\n                              _break: @block_ctxt, n: str, sp: span)\n     -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx),\n@@ -4336,7 +4336,7 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - trans_args\n fn new_fn_ctxt_w_id(cx: @local_ctxt, llfndecl: ValueRef,\n                     id: ast::node_id, rstyle: ast::ret_style,\n-                    sp: option::t<span>) -> @fn_ctxt {\n+                    sp: option<span>) -> @fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     ret @{llfn: llfndecl,\n           llenv: llvm::LLVMGetParam(llfndecl, 1u as c_uint),\n@@ -4360,7 +4360,7 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, llfndecl: ValueRef,\n           lcx: cx};\n }\n \n-fn new_fn_ctxt(cx: @local_ctxt, llfndecl: ValueRef, sp: option::t<span>)\n+fn new_fn_ctxt(cx: @local_ctxt, llfndecl: ValueRef, sp: option<span>)\n     -> @fn_ctxt {\n     ret new_fn_ctxt_w_id(cx, llfndecl, -1, ast::return_val, sp);\n }\n@@ -5198,7 +5198,7 @@ fn link_name(i: @ast::native_item) -> str {\n }\n \n fn collect_native_item(ccx: @crate_ctxt,\n-                       abi: @mutable option::t<ast::native_abi>,\n+                       abi: @mutable option<ast::native_abi>,\n                        i: @ast::native_item,\n                        &&pt: [str],\n                        _v: vt<[str]>) {\n@@ -5248,7 +5248,7 @@ fn collect_native_item(ccx: @crate_ctxt,\n     }\n }\n \n-fn collect_item(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n+fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n                 i: @ast::item, &&pt: [str], v: vt<[str]>) {\n     let new_pt = pt + [i.ident];\n     alt i.node {"}, {"sha": "6873646a48f329d2574a18f0639de0ba200a7f60", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -541,7 +541,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     ret bcx;\n }\n \n-fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option::t<@ast::expr>],\n+fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option<@ast::expr>],\n               id: ast::node_id, dest: dest) -> @block_ctxt {\n     let f_res = trans_callee(cx, f);\n     ret trans_bind_1(cx, ty::expr_ty(bcx_tcx(cx), f), f_res, args,\n@@ -550,10 +550,10 @@ fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option::t<@ast::expr>],\n \n fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n                 f_res: lval_maybe_callee,\n-                args: [option::t<@ast::expr>], pair_ty: ty::t,\n+                args: [option<@ast::expr>], pair_ty: ty::t,\n                 dest: dest) -> @block_ctxt {\n     let bound: [@ast::expr] = [];\n-    for argopt: option::t<@ast::expr> in args {\n+    for argopt: option<@ast::expr> in args {\n         alt argopt { none { } some(e) { bound += [e]; } }\n     }\n     let bcx = f_res.bcx;\n@@ -781,10 +781,10 @@ fn make_opaque_cbox_free_glue(\n fn trans_bind_thunk(cx: @local_ctxt,\n                     incoming_fty: ty::t,\n                     outgoing_fty: ty::t,\n-                    args: [option::t<@ast::expr>],\n+                    args: [option<@ast::expr>],\n                     cbox_ty: ty::t,\n                     param_bounds: [ty::param_bounds],\n-                    target_fn: option::t<ValueRef>)\n+                    target_fn: option<ValueRef>)\n     -> {val: ValueRef, ty: TypeRef} {\n     // If we supported constraints on record fields, we could make the\n     // constraints for this function:\n@@ -926,7 +926,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: [TypeRef] =\n         type_of_explicit_args(cx.ccx, outgoing_args);\n-    for arg: option::t<@ast::expr> in args {\n+    for arg: option<@ast::expr> in args {\n         let out_arg = outgoing_args[outgoing_arg_index];\n         let llout_arg_ty = llout_arg_tys[outgoing_arg_index];\n         alt arg {"}, {"sha": "46a49fd7fbdb06a9cb9ae1a0a0e165f9da4b753a", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -43,10 +43,10 @@ type tydesc_info =\n      tydesc: ValueRef,\n      size: ValueRef,\n      align: ValueRef,\n-     mutable take_glue: option::t<ValueRef>,\n-     mutable drop_glue: option::t<ValueRef>,\n-     mutable free_glue: option::t<ValueRef>,\n-     mutable cmp_glue: option::t<ValueRef>,\n+     mutable take_glue: option<ValueRef>,\n+     mutable drop_glue: option<ValueRef>,\n+     mutable free_glue: option<ValueRef>,\n+     mutable cmp_glue: option<ValueRef>,\n      ty_params: [uint]};\n \n /*\n@@ -90,7 +90,7 @@ type crate_ctxt =\n      ast_map: ast_map::map,\n      exp_map: resolve::exp_map,\n      item_symbols: hashmap<ast::node_id, str>,\n-     mutable main_fn: option::t<ValueRef>,\n+     mutable main_fn: option<ValueRef>,\n      link_meta: link::link_meta,\n      enum_sizes: hashmap<ty::t, uint>,\n      discrims: hashmap<ast::def_id, ValueRef>,\n@@ -122,7 +122,7 @@ type crate_ctxt =\n      shape_cx: shape::ctxt,\n      gc_cx: gc::ctxt,\n      crate_map: ValueRef,\n-     dbg_cx: option::t<@debuginfo::debug_ctxt>};\n+     dbg_cx: option<@debuginfo::debug_ctxt>};\n \n type local_ctxt =\n     {path: [str],\n@@ -134,7 +134,7 @@ type val_self_pair = {v: ValueRef, t: ty::t};\n \n enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n \n-type fn_ty_param = {desc: ValueRef, dicts: option::t<[ValueRef]>};\n+type fn_ty_param = {desc: ValueRef, dicts: option<[ValueRef]>};\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n@@ -231,16 +231,16 @@ type fn_ctxt =\n      mutable llderivedtydescs: BasicBlockRef,\n      mutable lldynamicallocas: BasicBlockRef,\n      mutable llreturn: BasicBlockRef,\n-     mutable llobstacktoken: option::t<ValueRef>,\n-     mutable llself: option::t<val_self_pair>,\n+     mutable llobstacktoken: option<ValueRef>,\n+     mutable llself: option<val_self_pair>,\n      llargs: hashmap<ast::node_id, local_val>,\n      lllocals: hashmap<ast::node_id, local_val>,\n      llupvars: hashmap<ast::node_id, ValueRef>,\n      mutable lltyparams: [fn_ty_param],\n      derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n      id: ast::node_id,\n      ret_style: ast::ret_style,\n-     span: option::t<span>,\n+     span: option<span>,\n      lcx: @local_ctxt};\n \n enum cleanup {\n@@ -339,7 +339,7 @@ enum block_kind {\n     SCOPE_BLOCK,\n     // A basic block created from the body of a loop.  Contains pointers to\n     // which block to jump to in the case of \"continue\" or \"break\".\n-    LOOP_SCOPE_BLOCK(option::t<@block_ctxt>, @block_ctxt),\n+    LOOP_SCOPE_BLOCK(option<@block_ctxt>, @block_ctxt),\n     // A non-scope block is a basic block created as a translation artifact\n     // from translating code that expresses conditional logic rather than by\n     // explicit { ... } block structure in the source language.  It's called a\n@@ -374,11 +374,11 @@ type block_ctxt =\n      kind: block_kind,\n      mutable cleanups: [cleanup],\n      mutable lpad_dirty: bool,\n-     mutable lpad: option::t<BasicBlockRef>,\n-     block_span: option::t<span>,\n+     mutable lpad: option<BasicBlockRef>,\n+     block_span: option<span>,\n      fcx: @fn_ctxt};\n \n-// FIXME: we should be able to use option::t<@block_parent> here but\n+// FIXME: we should be able to use option<@block_parent> here but\n // the infinite-enum check in rustboot gets upset.\n enum block_parent { parent_none, parent_some(@block_ctxt), }\n "}, {"sha": "3ca8a0b89fb0b78eaae0aab6a45df0e85eaa60f4", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -300,7 +300,7 @@ fn add_node(ccx: crate_ctxt, i: node_id, a: ts_ann) {\n     ccx.node_anns[i] = a;\n }\n \n-fn get_ts_ann(ccx: crate_ctxt, i: node_id) -> option::t<ts_ann> {\n+fn get_ts_ann(ccx: crate_ctxt, i: node_id) -> option<ts_ann> {\n     if i as uint < vec::len(*ccx.node_anns) {\n         ret some::<ts_ann>(ccx.node_anns[i]);\n     } else { ret none::<ts_ann>; }\n@@ -515,7 +515,7 @@ fn node_id_to_def_strict(cx: ty::ctxt, id: node_id) -> def {\n     }\n }\n \n-fn node_id_to_def(ccx: crate_ctxt, id: node_id) -> option::t<def> {\n+fn node_id_to_def(ccx: crate_ctxt, id: node_id) -> option<def> {\n     ret ccx.tcx.def_map.find(id);\n }\n \n@@ -691,7 +691,7 @@ fn pred_args_matches(pattern: [constr_arg_general_<inst>], desc: pred_args) ->\n }\n \n fn find_instance_(pattern: [constr_arg_general_<inst>], descs: [pred_args]) ->\n-   option::t<uint> {\n+   option<uint> {\n     for d: pred_args in descs {\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n     }\n@@ -725,7 +725,7 @@ fn find_instances(_fcx: fn_ctxt, subst: subst, c: constraint) ->\n     rslt\n }\n \n-fn find_in_subst(id: node_id, s: subst) -> option::t<inst> {\n+fn find_in_subst(id: node_id, s: subst) -> option<inst> {\n     for p: {from: inst, to: inst} in s {\n         if id == p.from.node { ret some(p.to); }\n     }\n@@ -805,11 +805,11 @@ fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n     }\n }\n \n-fn local_node_id_to_def(fcx: fn_ctxt, i: node_id) -> option::t<def> {\n+fn local_node_id_to_def(fcx: fn_ctxt, i: node_id) -> option<def> {\n     fcx.ccx.tcx.def_map.find(i)\n }\n \n-fn local_node_id_to_def_id(fcx: fn_ctxt, i: node_id) -> option::t<def_id> {\n+fn local_node_id_to_def_id(fcx: fn_ctxt, i: node_id) -> option<def_id> {\n     alt local_node_id_to_def(fcx, i) {\n       some(def_local(id, _)) | some(def_arg(id, _)) | some(def_binding(id)) |\n       some(def_upvar(id, _, _)) {\n@@ -820,7 +820,7 @@ fn local_node_id_to_def_id(fcx: fn_ctxt, i: node_id) -> option::t<def_id> {\n }\n \n fn local_node_id_to_local_def_id(fcx: fn_ctxt, i: node_id) ->\n-   option::t<node_id> {\n+   option<node_id> {\n     alt local_node_id_to_def_id(fcx, i) {\n       some(did) { some(did.node) }\n       _ { none }\n@@ -1053,7 +1053,7 @@ fn ast_constr_to_sp_constr(tcx: ty::ctxt, args: [arg], c: @constr) ->\n     ret respan(c.span, tconstr);\n }\n \n-type binding = {lhs: [inst], rhs: option::t<initializer>};\n+type binding = {lhs: [inst], rhs: option<initializer>};\n \n fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n     let lhs = [];"}, {"sha": "e0fa0728eace50837674dab254a8ea3bd2c4ee26", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -110,7 +110,7 @@ fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,\n // annotation for an if-expression with consequent conseq\n // and alternative maybe_alt\n fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n-                  maybe_alt: option::t<@expr>, id: node_id, chck: if_ty) {\n+                  maybe_alt: option<@expr>, id: node_id, chck: if_ty) {\n     find_pre_post_expr(fcx, antec);\n     find_pre_post_block(fcx, conseq);\n     alt maybe_alt {\n@@ -521,7 +521,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         let cmodes = callee_modes(fcx, operator.id);\n         let modes = [];\n         let i = 0;\n-        for expr_opt: option::t<@expr> in maybe_args {\n+        for expr_opt: option<@expr> in maybe_args {\n             alt expr_opt {\n               none {/* no-op */ }\n               some(expr) { modes += [cmodes[i]]; args += [expr]; }"}, {"sha": "f68c7ba7a105d5431527e0077f9ed7571ae109a1", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -103,7 +103,7 @@ fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n }\n \n fn find_pre_post_state_sub(fcx: fn_ctxt, pres: prestate, e: @expr,\n-                           parent: node_id, c: option::t<tsconstr>) -> bool {\n+                           parent: node_id, c: option<tsconstr>) -> bool {\n     let changed = find_pre_post_state_expr(fcx, pres, e);\n \n     changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n@@ -261,7 +261,7 @@ fn gen_if_local(fcx: fn_ctxt, p: poststate, e: @expr) -> bool {\n }\n \n fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n-                  maybe_alt: option::t<@expr>, id: node_id, chk: if_ty,\n+                  maybe_alt: option<@expr>, id: node_id, chk: if_ty,\n                   pres: prestate) -> bool {\n     let changed =\n         set_prestate_ann(fcx.ccx, id, pres) |\n@@ -376,7 +376,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         let callee_ops = callee_arg_init_ops(fcx, operator.id);\n         let ops = [];\n         let i = 0;\n-        for a_opt: option::t<@expr> in maybe_args {\n+        for a_opt: option<@expr> in maybe_args {\n             alt a_opt {\n               none {/* no-op */ }\n               some(a) { ops += [callee_ops[i]]; args += [a]; }"}, {"sha": "e2390ab991142b4ed0014e6ad7c4bdc0539e3e0f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -217,7 +217,7 @@ type ctxt =\n       short_names_cache: hashmap<t, @str>,\n       needs_drop_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, kind>,\n-      ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>,\n+      ast_ty_to_ty_cache: hashmap<@ast::ty, option<t>>,\n       enum_var_cache: hashmap<def_id, @[variant_info]>,\n       iface_method_cache: hashmap<def_id, @[method]>,\n       ty_param_bounds: hashmap<ast::node_id, param_bounds>};\n@@ -648,7 +648,7 @@ pure fn mach_sty(cfg: @session::config, s: sty) -> sty {\n     }\n }\n \n-pure fn ty_name(cx: ctxt, typ: t) -> option::t<@str> {\n+pure fn ty_name(cx: ctxt, typ: t) -> option<@str> {\n     alt interner::get(*cx.ts, typ).struct {\n       ty_named(_, n) { some(n) }\n       _ { none }\n@@ -1229,7 +1229,7 @@ fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_param(cx: ctxt, ty: t) -> option::t<uint> {\n+fn type_param(cx: ctxt, ty: t) -> option<uint> {\n     alt struct(cx, ty) {\n       ty_param(id, _) { ret some(id); }\n       _ {/* fall through */ }\n@@ -1579,7 +1579,7 @@ fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n     }\n }\n \n-fn field_idx(id: ast::ident, fields: [field]) -> option::t<uint> {\n+fn field_idx(id: ast::ident, fields: [field]) -> option<uint> {\n     let i = 0u;\n     for f in fields { if f.ident == id { ret some(i); } i += 1u; }\n     ret none;\n@@ -1600,7 +1600,7 @@ fn get_fields(tcx:ctxt, rec_ty:t) -> [field] {\n     }\n }\n \n-fn method_idx(id: ast::ident, meths: [method]) -> option::t<uint> {\n+fn method_idx(id: ast::ident, meths: [method]) -> option<uint> {\n     let i = 0u;\n     for m in meths { if m.ident == id { ret some(i); } i += 1u; }\n     ret none;\n@@ -1613,7 +1613,7 @@ fn sort_methods(meths: [method]) -> [method] {\n     ret std::sort::merge_sort(bind method_lteq(_, _), meths);\n }\n \n-fn occurs_check_fails(tcx: ctxt, sp: option::t<span>, vid: int, rt: t) ->\n+fn occurs_check_fails(tcx: ctxt, sp: option<span>, vid: int, rt: t) ->\n    bool {\n     if !type_contains_vars(tcx, rt) {\n         // Fast path\n@@ -1821,7 +1821,7 @@ mod unify {\n     // Unifies two mutability flags.\n     fn unify_mut(expected: ast::mutability, actual: ast::mutability,\n                  variance: variance) ->\n-       option::t<(ast::mutability, variance)> {\n+       option<(ast::mutability, variance)> {\n \n         // If you're unifying on something mutable then we have to\n         // be invariant on the inner type\n@@ -1847,7 +1847,7 @@ mod unify {\n         ret none;\n     }\n     fn unify_fn_proto(e_proto: ast::proto, a_proto: ast::proto,\n-                      variance: variance) -> option::t<result> {\n+                      variance: variance) -> option<result> {\n         // Prototypes form a diamond-shaped partial order:\n         //\n         //        block\n@@ -2365,7 +2365,7 @@ mod unify {\n         while i < vec::len::<ufind::node>(vb.sets.nodes) {\n             let sets = \"\";\n             let j = 0u;\n-            while j < vec::len::<option::t<uint>>(vb.sets.nodes) {\n+            while j < vec::len::<option<uint>>(vb.sets.nodes) {\n                 if ufind::find(vb.sets, j) == i { sets += #fmt[\" %u\", j]; }\n                 j += 1u;\n             }\n@@ -2383,10 +2383,10 @@ mod unify {\n     //    Takes an optional span - complain about occurs check violations\n     //    iff the span is present (so that if we already know we're going\n     //    to error anyway, we don't complain)\n-    fn fixup_vars(tcx: ty_ctxt, sp: option::t<span>, vb: @var_bindings,\n+    fn fixup_vars(tcx: ty_ctxt, sp: option<span>, vb: @var_bindings,\n                   typ: t) -> fixup_result {\n-        fn subst_vars(tcx: ty_ctxt, sp: option::t<span>, vb: @var_bindings,\n-                      unresolved: @mutable option::t<int>,\n+        fn subst_vars(tcx: ty_ctxt, sp: option<span>, vb: @var_bindings,\n+                      unresolved: @mutable option<int>,\n                       vars_seen: std::list::list<int>, vid: int) -> t {\n             // Should really return a fixup_result instead of a t, but fold_ty\n             // doesn't allow returning anything but a t.\n@@ -2426,7 +2426,7 @@ mod unify {\n           some(var_id) { ret fix_err(var_id); }\n         }\n     }\n-    fn resolve_type_var(tcx: ty_ctxt, sp: option::t<span>, vb: @var_bindings,\n+    fn resolve_type_var(tcx: ty_ctxt, sp: option<span>, vb: @var_bindings,\n                         vid: int) -> fixup_result {\n         if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n         let root_id = ufind::find(vb.sets, vid as uint);\n@@ -2537,7 +2537,7 @@ fn iface_methods(cx: ctxt, id: ast::def_id) -> @[method] {\n     result\n }\n \n-fn impl_iface(cx: ctxt, id: ast::def_id) -> option::t<t> {\n+fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n     if id.crate == ast::local_crate {\n         option::map(cx.tcache.find(id), {|it| it.ty})\n     } else {"}, {"sha": "c2f79c6c13ee9f2ed1d6831bd8a7452695a4ee7e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -191,7 +191,7 @@ fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n // Returns the one-level-deep structure of the given type or none if it\n // is not known yet.\n fn structure_of_maybe(fcx: @fn_ctxt, _sp: span, typ: ty::t) ->\n-   option::t<ty::sty> {\n+   option<ty::sty> {\n     let r =\n         ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, typ);\n     ret alt r {\n@@ -545,7 +545,7 @@ fn ast_ty_to_ty_crate(ccx: @crate_ctxt, &&ast_ty: @ast::ty) -> ty::t {\n \n // A wrapper around ast_ty_to_ty_crate that handles ty_infer.\n fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, &&ast_ty: @ast::ty) ->\n-   option::t<ty::t> {\n+   option<ty::t> {\n     alt ast_ty.node {\n       ast::ty_infer { none }\n       _ { some(ast_ty_to_ty_crate(ccx, ast_ty)) }\n@@ -946,7 +946,7 @@ mod writeback {\n     export resolve_type_vars_in_expr;\n \n     fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n-       option::t<ty::t> {\n+       option<ty::t> {\n         if !ty::type_contains_vars(fcx.ccx.tcx, typ) { ret some(typ); }\n         alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp), fcx.var_bindings,\n                                   typ) {\n@@ -1077,7 +1077,7 @@ fn gather_locals(ccx: @crate_ctxt,\n                  decl: ast::fn_decl,\n                  body: ast::blk,\n                  id: ast::node_id,\n-                 old_fcx: option::t<@fn_ctxt>) -> gather_result {\n+                 old_fcx: option<@fn_ctxt>) -> gather_result {\n     let {vb: vb, locals: locals, nvi: nvi} =\n         alt old_fcx {\n           none {\n@@ -1094,7 +1094,7 @@ fn gather_locals(ccx: @crate_ctxt,\n     let tcx = ccx.tcx;\n \n     let next_var_id = fn@() -> int { let rv = *nvi; *nvi += 1; ret rv; };\n-    let assign = fn@(nid: ast::node_id, ty_opt: option::t<ty::t>) {\n+    let assign = fn@(nid: ast::node_id, ty_opt: option<ty::t>) {\n             let var_id = next_var_id();\n             locals.insert(nid, var_id);\n             alt ty_opt {\n@@ -1445,7 +1445,7 @@ fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n \n fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                  name: ast::ident, ty: ty::t, sp: span)\n-    -> option::t<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n+    -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n                   origin: method_origin}> {\n     let tcx = fcx.ccx.tcx;\n \n@@ -1579,7 +1579,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(fcx: @fn_ctxt, sp: span, fty: ty::t,\n-                          args: [option::t<@ast::expr>]) -> bool {\n+                          args: [option<@ast::expr>]) -> bool {\n         let sty = structure_of(fcx, sp, fty);\n         // Grab the argument types\n         let arg_tys = alt sty {\n@@ -1658,7 +1658,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     // A generic function for checking call expressions\n     fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr])\n         -> bool {\n-        let args_opt_0: [option::t<@ast::expr>] = [];\n+        let args_opt_0: [option<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n             args_opt_0 += [some::<@ast::expr>(arg)];\n         }\n@@ -1712,7 +1712,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: @fn_ctxt, thn: ast::blk,\n-                       elsopt: option::t<@ast::expr>, id: ast::node_id,\n+                       elsopt: option<@ast::expr>, id: ast::node_id,\n                        _sp: span) -> bool {\n         let (if_t, if_bot) =\n             alt elsopt {\n@@ -1737,7 +1737,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         ret if_bot;\n     }\n \n-    fn binop_method(op: ast::binop) -> option::t<str> {\n+    fn binop_method(op: ast::binop) -> option<str> {\n         alt op {\n           ast::add | ast::subtract | ast::mul | ast::div | ast::rem |\n           ast::bitxor | ast::bitand | ast::bitor | ast::lsl | ast::lsr |\n@@ -1747,7 +1747,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     }\n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr, self_t: ty::t,\n                         opname: str,\n-                        args: [option::t<@ast::expr>]) -> option::t<ty::t> {\n+                        args: [option<@ast::expr>]) -> option<ty::t> {\n         let isc = fcx.ccx.impl_map.get(op_ex.id);\n         alt lookup_method(fcx, isc, opname, self_t, op_ex.span) {\n           some({method_ty, n_tps: 0u, substs, origin}) {\n@@ -2329,7 +2329,7 @@ fn bind_params(fcx: @fn_ctxt, tp: ty::t, count: uint)\n     {vars: vars, ty: ty::substitute_type_params(fcx.ccx.tcx, vars, tp)}\n }\n \n-fn get_self_info(ccx: @crate_ctxt) -> option::t<self_info> {\n+fn get_self_info(ccx: @crate_ctxt) -> option<self_info> {\n     ret vec::last(ccx.self_infos);\n }\n \n@@ -2633,7 +2633,7 @@ fn check_fn(ccx: @crate_ctxt,\n             decl: ast::fn_decl,\n             body: ast::blk,\n             id: ast::node_id,\n-            old_fcx: option::t<@fn_ctxt>) {\n+            old_fcx: option<@fn_ctxt>) {\n     // If old_fcx is some(...), this is a block fn { |x| ... }.\n     // In that case, the purity is inherited from the context.\n     let purity = alt old_fcx {"}, {"sha": "38986ea9d64125760ab513f952f544f40d549025", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -8,7 +8,7 @@ type spanned<T> = {node: T, span: span};\n type ident = str;\n \n // Functions may or may not have names.\n-type fn_ident = option::t<ident>;\n+type fn_ident = option<ident>;\n \n // FIXME: with typestate constraint, could say\n // idents and types are the same length, and are\n@@ -87,7 +87,7 @@ enum meta_item_ {\n \n type blk = spanned<blk_>;\n \n-type blk_ = {view_items: [@view_item], stmts: [@stmt], expr: option::t<@expr>,\n+type blk_ = {view_items: [@view_item], stmts: [@stmt], expr: option<@expr>,\n              id: node_id, rules: blk_check_mode};\n \n type pat = {id: node_id, node: pat_, span: span};\n@@ -106,7 +106,7 @@ enum pat_ {\n     // After the resolution phase, code should never pattern-\n     // match on a pat directly! Always call pat_util::normalize_pat --\n     // it turns any pat_idents that refer to nullary enums into pat_enums.\n-    pat_ident(@path, option::t<@pat>),\n+    pat_ident(@path, option<@pat>),\n     pat_enum(@path, [@pat]),\n     pat_rec([field_pat], bool),\n     pat_tup([@pat]),\n@@ -180,7 +180,7 @@ enum init_op { init_assign, init_move, }\n type initializer = {op: init_op, expr: @expr};\n \n type local_ =  // FIXME: should really be a refinement on pat\n-    {ty: @ty, pat: @pat, init: option::t<initializer>, id: node_id};\n+    {ty: @ty, pat: @pat, init: option<initializer>, id: node_id};\n \n type local = spanned<local_>;\n \n@@ -190,7 +190,7 @@ enum let_style { let_copy, let_ref, }\n \n enum decl_ { decl_local([(let_style, @local)]), decl_item(@item), }\n \n-type arm = {pats: [@pat], guard: option::t<@expr>, body: blk};\n+type arm = {pats: [@pat], guard: option<@expr>, body: blk};\n \n type field_ = {mut: mutability, ident: ident, expr: @expr};\n \n@@ -204,15 +204,15 @@ type expr = {id: node_id, node: expr_, span: span};\n \n enum expr_ {\n     expr_vec([@expr], mutability),\n-    expr_rec([field], option::t<@expr>),\n+    expr_rec([field], option<@expr>),\n     expr_call(@expr, [@expr], bool),\n     expr_tup([@expr]),\n-    expr_bind(@expr, [option::t<@expr>]),\n+    expr_bind(@expr, [option<@expr>]),\n     expr_binary(binop, @expr, @expr),\n     expr_unary(unop, @expr),\n     expr_lit(@lit),\n     expr_cast(@expr, @ty),\n-    expr_if(@expr, blk, option::t<@expr>),\n+    expr_if(@expr, blk, option<@expr>),\n     expr_while(@expr, blk),\n     expr_for(@local, @expr, blk),\n     expr_do_while(blk, @expr),\n@@ -233,10 +233,10 @@ enum expr_ {\n     expr_field(@expr, ident, [@ty]),\n     expr_index(@expr, @expr),\n     expr_path(@path),\n-    expr_fail(option::t<@expr>),\n+    expr_fail(option<@expr>),\n     expr_break,\n     expr_cont,\n-    expr_ret(option::t<@expr>),\n+    expr_ret(option<@expr>),\n     expr_be(@expr),\n     expr_log(int, @expr, @expr),\n \n@@ -248,7 +248,7 @@ enum expr_ {\n \n     /* FIXME Would be nice if expr_check desugared\n        to expr_if_check. */\n-    expr_if_check(@expr, blk, option::t<@expr>),\n+    expr_if_check(@expr, blk, option<@expr>),\n     expr_mac(mac),\n }\n \n@@ -274,7 +274,7 @@ enum blk_sort {\n type mac = spanned<mac_>;\n \n enum mac_ {\n-    mac_invoc(@path, @expr, option::t<str>),\n+    mac_invoc(@path, @expr, option<str>),\n     mac_embed_type(@ty),\n     mac_embed_block(blk),\n     mac_ellipsis,\n@@ -415,7 +415,7 @@ type native_mod =\n type variant_arg = {ty: @ty, id: node_id};\n \n type variant_ = {name: ident, attrs: [attribute], args: [variant_arg],\n-                 id: node_id, disr_expr: option::t<@expr>};\n+                 id: node_id, disr_expr: option<@expr>};\n \n type variant = spanned<variant_>;\n \n@@ -465,7 +465,7 @@ enum item_ {\n     item_res(fn_decl /* dtor */, [ty_param], blk,\n              node_id /* dtor id */, node_id /* ctor id */),\n     item_iface([ty_param], [ty_method]),\n-    item_impl([ty_param], option::t<@ty> /* iface */,\n+    item_impl([ty_param], option<@ty> /* iface */,\n               @ty /* self */, [@method]),\n }\n "}, {"sha": "2e6be5d27d98ef340cd8eb8df54eee6a2bc60883", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -203,7 +203,7 @@ fn block_from_expr(e: @expr) -> blk {\n     ret {node: blk_, span: e.span};\n }\n \n-fn default_block(stmts1: [@stmt], expr1: option::t<@expr>, id1: node_id) ->\n+fn default_block(stmts1: [@stmt], expr1: option<@expr>, id1: node_id) ->\n    blk_ {\n     {view_items: [], stmts: stmts1, expr: expr1, id: id1, rules: default_blk}\n }\n@@ -364,7 +364,7 @@ pure fn is_unguarded(&&a: arm) -> bool {\n     }\n }\n \n-pure fn unguarded_pat(a: arm) -> option::t<[@pat]> {\n+pure fn unguarded_pat(a: arm) -> option<[@pat]> {\n     if is_unguarded(a) { some(a.pats) } else { none }\n }\n "}, {"sha": "0b893376bdbfaf92737e90fcb3279429767f18f5", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -67,7 +67,7 @@ fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n \n enum opt_span {\n \n-    //hack (as opposed to option::t), to make `span` compile\n+    //hack (as opposed to option), to make `span` compile\n     os_none,\n     os_some(@span),\n }"}, {"sha": "bfe3e36c0bc4894f10604c16e73bc914e90579e6", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -6,10 +6,10 @@ import std::map::new_str_hash;\n import codemap;\n \n type syntax_expander =\n-    fn@(ext_ctxt, span, @ast::expr, option::t<str>) -> @ast::expr;\n+    fn@(ext_ctxt, span, @ast::expr, option<str>) -> @ast::expr;\n type macro_def = {ident: str, ext: syntax_extension};\n type macro_definer =\n-    fn@(ext_ctxt, span, @ast::expr, option::t<str>) -> macro_def;\n+    fn@(ext_ctxt, span, @ast::expr, option<str>) -> macro_def;\n \n enum syntax_extension {\n     normal(syntax_expander),"}, {"sha": "0a9d5b4cf3e4535b43b5ed7cfb3fe9af8e808d32", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -3,7 +3,7 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: option::t<str>) -> @ast::expr {\n+                     _body: option<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }"}, {"sha": "fe464473e031a096437585c7688d336ae632207f", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -10,7 +10,7 @@ import base::*;\n export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: option::t<str>) -> @ast::expr {\n+                     _body: option<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n@@ -22,7 +22,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n         cx.span_fatal(sp, \"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an\n-    // option::t<str> rather than just an maybe-empty string.\n+    // option<str> rather than just an maybe-empty string.\n \n     let var = expr_to_str(cx, args[0], \"#env requires a string\");\n     alt generic_os::getenv(var) {"}, {"sha": "0dfe2cb17d0dccf3d83c931acfefaf1d38f47fcf", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -13,7 +13,7 @@ import codemap::span;\n export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: @ast::expr,\n-                     _body: option::t<str>) -> @ast::expr {\n+                     _body: option<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }"}, {"sha": "5fbc05062ee560f2af8bd58ac2e57dcc8ac85809", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -3,7 +3,7 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: option::t<str>) -> @ast::expr {\n+                     _body: option<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }"}, {"sha": "b7be75e349f83c3b1af5646742f5aa1bab3541fe", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -3,7 +3,7 @@ import syntax::ast;\n import std::io::writer_util;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: option::t<str>) -> @ast::expr {\n+                     _body: option<str>) -> @ast::expr {\n \n     cx.print_backtrace();\n     std::io::stdout().write_line(print::pprust::expr_to_str(arg));"}, {"sha": "cc133e704e723b16ecee1b2ff42b27b4960384a6", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -15,7 +15,7 @@ import ast::{ident, path, ty, blk_, expr, path_, expr_path,\n \n export add_new_extension;\n \n-fn path_to_ident(pth: @path) -> option::t<ident> {\n+fn path_to_ident(pth: @path) -> option<ident> {\n     if vec::len(pth.node.idents) == 1u && vec::len(pth.node.types) == 0u {\n         ret some(pth.node.idents[0u]);\n     }\n@@ -71,11 +71,11 @@ fn match_error(cx: ext_ctxt, m: matchable, expected: str) -> ! {\n // If we want better match failure error messages (like in Fortifying Syntax),\n // we'll want to return something indicating amount of progress and location\n // of failure instead of `none`.\n-type match_result = option::t<arb_depth<matchable>>;\n+type match_result = option<arb_depth<matchable>>;\n type selector = fn@(matchable) -> match_result;\n \n fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n-   {pre: [@expr], rep: option::t<@expr>, post: [@expr]} {\n+   {pre: [@expr], rep: option<@expr>, post: [@expr]} {\n     let idx: uint = 0u;\n     let res = none;\n     for elt: @expr in elts {\n@@ -104,8 +104,8 @@ fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n         }\n }\n \n-fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option::t<U>, v: [T]) ->\n-   option::t<[U]> {\n+fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: [T]) ->\n+   option<[U]> {\n     let res = [];\n     for elem: T in v {\n         alt f(elem) { none { ret none; } some(fv) { res += [fv]; } }\n@@ -165,7 +165,7 @@ fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n bindings. Most of the work is done in p_t_s, which generates the\n selectors. */\n \n-fn use_selectors_to_bind(b: binders, e: @expr) -> option::t<bindings> {\n+fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n     let res = new_str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for sel: selector in b.literal_ast_matchers {\n@@ -223,8 +223,8 @@ fn follow(m: arb_depth<matchable>, idx_path: @mutable [uint]) ->\n     ret res;\n }\n \n-fn follow_for_trans(cx: ext_ctxt, mmaybe: option::t<arb_depth<matchable>>,\n-                    idx_path: @mutable [uint]) -> option::t<matchable> {\n+fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n+                    idx_path: @mutable [uint]) -> option<matchable> {\n     alt mmaybe {\n       none { ret none }\n       some(m) {\n@@ -269,7 +269,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n         alt repeat_me_maybe {\n           none { }\n           some(repeat_me) {\n-            let repeat: option::t<{rep_count: uint, name: ident}> = none;\n+            let repeat: option<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n             free_vars(b, repeat_me) {|fv|\n@@ -523,7 +523,7 @@ fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n     }\n }\n \n-fn block_to_ident(blk: blk_) -> option::t<ident> {\n+fn block_to_ident(blk: blk_) -> option<ident> {\n     if vec::len(blk.stmts) != 0u { ret none; }\n     ret alt blk.expr {\n           some(expr) {\n@@ -667,7 +667,7 @@ fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: [@expr], _repeat_after: bool,\n }\n \n fn add_new_extension(cx: ext_ctxt, sp: span, arg: @expr,\n-                     _body: option::t<str>) -> base::macro_def {\n+                     _body: option<str>) -> base::macro_def {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n@@ -677,7 +677,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: @expr,\n           }\n         };\n \n-    let macro_name: option::t<str> = none;\n+    let macro_name: option<str> = none;\n     let clauses: [@clause] = [];\n     for arg: @expr in args {\n         alt arg.node {\n@@ -751,7 +751,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: @expr,\n          ext: normal(ext)};\n \n     fn generic_extension(cx: ext_ctxt, sp: span, arg: @expr,\n-                         _body: option::t<str>, clauses: [@clause]) -> @expr {\n+                         _body: option<str>, clauses: [@clause]) -> @expr {\n         for c: @clause in clauses {\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) { ret transcribe(cx, bindings, c.body); }"}, {"sha": "74d2259c51e5ecc8dde6bc695fb1718c93949e4a", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -25,7 +25,7 @@ fn eval_crate_directives(cx: ctx, cdirs: [@ast::crate_directive], prefix: str,\n }\n \n fn eval_crate_directives_to_mod(cx: ctx, cdirs: [@ast::crate_directive],\n-                                prefix: str, suffix: option::t<str>)\n+                                prefix: str, suffix: option<str>)\n     -> (ast::_mod, [ast::attribute]) {\n     #debug(\"eval crate prefix: %s\", prefix);\n     #debug(\"eval crate suffix: %s\",\n@@ -50,10 +50,10 @@ companion mod is a .rs file with the same name as the directory.\n We build the path to the companion mod by combining the prefix and the\n optional suffix then adding the .rs extension.\n */\n-fn parse_companion_mod(cx: ctx, prefix: str, suffix: option::t<str>)\n+fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n     -> ([@ast::view_item], [@ast::item], [ast::attribute]) {\n \n-    fn companion_file(prefix: str, suffix: option::t<str>) -> str {\n+    fn companion_file(prefix: str, suffix: option<str>) -> str {\n         ret alt suffix {\n           option::some(s) { fs::connect(prefix, s) }\n           option::none { prefix }"}, {"sha": "03fc4017106193342a236e73516d7d9b0a04924a", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -148,7 +148,7 @@ fn consume_block_comment(rdr: reader) {\n     be consume_whitespace_and_comments(rdr);\n }\n \n-fn scan_exponent(rdr: reader) -> option::t<str> {\n+fn scan_exponent(rdr: reader) -> option<str> {\n     let c = rdr.curr;\n     let rslt = \"\";\n     if c == 'e' || c == 'E' {"}, {"sha": "06f4e78372d00e80399480a312f9ee4f2a316109", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -542,7 +542,7 @@ fn parse_fn_block_arg(p: parser) -> ast::arg {\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n-fn parse_seq_to_before_gt<T: copy>(sep: option::t<token::token>,\n+fn parse_seq_to_before_gt<T: copy>(sep: option<token::token>,\n                                   f: fn(parser) -> T,\n                                   p: parser) -> [T] {\n     let first = true;\n@@ -559,15 +559,15 @@ fn parse_seq_to_before_gt<T: copy>(sep: option::t<token::token>,\n     ret v;\n }\n \n-fn parse_seq_to_gt<T: copy>(sep: option::t<token::token>,\n+fn parse_seq_to_gt<T: copy>(sep: option<token::token>,\n                            f: fn(parser) -> T, p: parser) -> [T] {\n     let v = parse_seq_to_before_gt(sep, f, p);\n     expect_gt(p);\n \n     ret v;\n }\n \n-fn parse_seq_lt_gt<T: copy>(sep: option::t<token::token>,\n+fn parse_seq_lt_gt<T: copy>(sep: option<token::token>,\n                            f: fn(parser) -> T,\n                            p: parser) -> spanned<[T]> {\n     let lo = p.span.lo;\n@@ -586,7 +586,7 @@ fn parse_seq_to_end<T: copy>(ket: token::token, sep: seq_sep,\n }\n \n type seq_sep = {\n-    sep: option::t<token::token>,\n+    sep: option<token::token>,\n     trailing_opt: bool   // is trailing separator optional?\n };\n \n@@ -845,7 +845,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         ret pexpr(mk_mac_expr(p, lo, p.span.hi, ast::mac_ellipsis));\n     } else if eat_word(p, \"bind\") {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n-        fn parse_expr_opt(p: parser) -> option::t<@ast::expr> {\n+        fn parse_expr_opt(p: parser) -> option<@ast::expr> {\n             alt p.token {\n               token::UNDERSCORE { p.bump(); ret none; }\n               _ { ret some(parse_expr(p)); }\n@@ -1202,13 +1202,13 @@ fn parse_assign_expr(p: parser) -> @ast::expr {\n fn parse_if_expr_1(p: parser) ->\n    {cond: @ast::expr,\n     then: ast::blk,\n-    els: option::t<@ast::expr>,\n+    els: option<@ast::expr>,\n     lo: uint,\n     hi: uint} {\n     let lo = p.last_span.lo;\n     let cond = parse_expr(p);\n     let thn = parse_block(p);\n-    let els: option::t<@ast::expr> = none;\n+    let els: option<@ast::expr> = none;\n     let hi = thn.span.hi;\n     if eat_word(p, \"else\") {\n         let elexpr = parse_else_expr(p);\n@@ -1364,7 +1364,7 @@ fn parse_expr_res(p: parser, r: restriction) -> @ast::expr {\n     ret e;\n }\n \n-fn parse_initializer(p: parser) -> option::t<ast::initializer> {\n+fn parse_initializer(p: parser) -> option<ast::initializer> {\n     alt p.token {\n       token::EQ {\n         p.bump();\n@@ -2143,7 +2143,7 @@ fn fn_expr_lookahead(tok: token::token) -> bool {\n     }\n }\n \n-fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n+fn parse_item(p: parser, attrs: [ast::attribute]) -> option<@ast::item> {\n     if eat_word(p, \"const\") {\n         ret some(parse_item_const(p, attrs));\n     } else if eat_word(p, \"inline\") {\n@@ -2178,7 +2178,7 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n-type attr_or_ext = option::t<either::t<[ast::attribute], @ast::expr>>;\n+type attr_or_ext = option<either::t<[ast::attribute], @ast::expr>>;\n \n fn parse_outer_attrs_or_ext(\n     p: parser,\n@@ -2292,7 +2292,7 @@ fn parse_use(p: parser) -> ast::view_item_ {\n }\n \n fn parse_rest_import_name(p: parser, first: ast::ident,\n-                          def_ident: option::t<ast::ident>) ->\n+                          def_ident: option<ast::ident>) ->\n    ast::view_item_ {\n     let identifiers: [ast::ident] = [first];\n     let glob: bool = false;"}, {"sha": "938e86fc74e18a68fa762d597d94c341ec875485", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -28,9 +28,9 @@ fn no_ann() -> pp_ann {\n \n type ps =\n     @{s: pp::printer,\n-      cm: option::t<codemap>,\n-      comments: option::t<[lexer::cmnt]>,\n-      literals: option::t<[lexer::lit]>,\n+      cm: option<codemap>,\n+      comments: option<[lexer::cmnt]>,\n+      literals: option<[lexer::lit]>,\n       mutable cur_cmnt: uint,\n       mutable cur_lit: uint,\n       mutable boxes: [pp::breaks],\n@@ -688,13 +688,13 @@ fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n }\n \n fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n-            elseopt: option::t<@ast::expr>, chk: bool) {\n+            elseopt: option<@ast::expr>, chk: bool) {\n     head(s, \"if\");\n     if chk { word_nbsp(s, \"check\"); }\n     print_maybe_parens_discrim(s, test);\n     space(s.s);\n     print_block(s, blk);\n-    fn do_else(s: ps, els: option::t<@ast::expr>) {\n+    fn do_else(s: ps, els: option<@ast::expr>) {\n         alt els {\n           some(_else) {\n             alt _else.node {\n@@ -809,7 +809,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n       }\n       ast::expr_bind(func, args) {\n-        fn print_opt(s: ps, expr: option::t<@ast::expr>) {\n+        fn print_opt(s: ps, expr: option<@ast::expr>) {\n             alt expr {\n               some(expr) { print_expr(s, expr); }\n               _ { word(s.s, \"_\"); }\n@@ -1411,8 +1411,8 @@ fn print_mt(s: ps, mt: ast::mt) {\n }\n \n fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n-               decl: ast::fn_decl, id: option::t<ast::ident>,\n-               tps: option::t<[ast::ty_param]>) {\n+               decl: ast::fn_decl, id: option<ast::ident>,\n+               tps: option<[ast::ty_param]>) {\n     ibox(s, indent_unit);\n     word(s.s, opt_proto_to_str(opt_proto));\n     alt id { some(id) { word(s.s, \" \"); word(s.s, id); } _ { } }\n@@ -1442,7 +1442,7 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n }\n \n fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n-                                next_pos: option::t<uint>) {\n+                                next_pos: option<uint>) {\n     let cm;\n     alt s.cm { some(ccm) { cm = ccm; } _ { ret; } }\n     alt next_comment(s) {\n@@ -1512,7 +1512,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n \n fn lit_to_str(l: @ast::lit) -> str { be to_str(l, print_literal); }\n \n-fn next_lit(s: ps, pos: uint) -> option::t<lexer::lit> {\n+fn next_lit(s: ps, pos: uint) -> option<lexer::lit> {\n     alt s.literals {\n       some(lits) {\n         while s.cur_lit < vec::len(lits) {\n@@ -1621,7 +1621,7 @@ fn to_str<T>(t: T, f: fn@(ps, T)) -> str {\n     io::mem_buffer_str(buffer)\n }\n \n-fn next_comment(s: ps) -> option::t<lexer::cmnt> {\n+fn next_comment(s: ps) -> option<lexer::cmnt> {\n     alt s.comments {\n       some(cmnts) {\n         if s.cur_cmnt < vec::len(cmnts) {"}, {"sha": "de8b53af2c44cf367bb382619b897b21ce8a07a5", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -264,7 +264,7 @@ fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_expr_opt<E>(eo: option::t<@expr>, e: E, v: vt<E>) {\n+fn visit_expr_opt<E>(eo: option<@expr>, e: E, v: vt<E>) {\n     alt eo { none { } some(ex) { v.visit_expr(ex, e, v); } }\n }\n \n@@ -295,7 +295,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       }\n       expr_bind(callee, args) {\n         v.visit_expr(callee, e, v);\n-        for eo: option::t<@expr> in args { visit_expr_opt(eo, e, v); }\n+        for eo: option<@expr> in args { visit_expr_opt(eo, e, v); }\n       }\n       expr_binary(_, a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_unary(_, a) { v.visit_expr(a, e, v); }"}, {"sha": "0e4c3671bf118d5ccaa0251253eb6f7d8268d3e1", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -18,9 +18,9 @@ export relative_target_lib_path;\n export get_cargo_root;\n export libdir;\n \n-type pick<T> = fn(path: fs::path) -> option::t<T>;\n+type pick<T> = fn(path: fs::path) -> option<T>;\n \n-fn pick_file(file: fs::path, path: fs::path) -> option::t<fs::path> {\n+fn pick_file(file: fs::path, path: fs::path) -> option<fs::path> {\n     if fs::basename(path) == file { option::some(path) }\n     else { option::none }\n }\n@@ -32,7 +32,7 @@ iface filesearch {\n     fn get_target_lib_file_path(file: fs::path) -> fs::path;\n }\n \n-fn mk_filesearch(maybe_sysroot: option::t<fs::path>,\n+fn mk_filesearch(maybe_sysroot: option<fs::path>,\n                  target_triple: str,\n                  addl_lib_search_paths: [fs::path]) -> filesearch {\n     type filesearch_impl = {sysroot: fs::path,\n@@ -64,7 +64,7 @@ fn mk_filesearch(maybe_sysroot: option::t<fs::path>,\n }\n \n // FIXME #1001: This can't be an obj method\n-fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option::t<T> {\n+fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n     for lib_search_path in filesearch.lib_search_paths() {\n         #debug(\"searching %s\", lib_search_path);\n         for path in fs::list_dir(lib_search_path) {\n@@ -102,7 +102,7 @@ fn get_default_sysroot() -> fs::path {\n     }\n }\n \n-fn get_sysroot(maybe_sysroot: option::t<fs::path>) -> fs::path {\n+fn get_sysroot(maybe_sysroot: option<fs::path>) -> fs::path {\n     alt maybe_sysroot {\n       option::some(sr) { sr }\n       option::none { get_default_sysroot() }"}, {"sha": "6d8af8e3846e24351469aba85e6e532bf7e103a3", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -33,7 +33,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         };\n         modestr + ty_to_str(cx, input.ty)\n     }\n-    fn fn_to_str(cx: ctxt, proto: ast::proto, ident: option::t<ast::ident>,\n+    fn fn_to_str(cx: ctxt, proto: ast::proto, ident: option<ast::ident>,\n                  inputs: [arg], output: t, cf: ast::ret_style,\n                  constrs: [@constr]) -> str {\n         let s = proto_to_str(proto);"}, {"sha": "bb5e629ef624df9cf3054087063467cb6b7a3918", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -24,9 +24,9 @@ type config =\n      stage_id: str,\n      mode: mode,\n      run_ignored: bool,\n-     filter: option::t<str>,\n-     runtool: option::t<str>,\n-     rustcflags: option::t<str>,\n+     filter: option<str>,\n+     runtool: option<str>,\n+     rustcflags: option<str>,\n      verbose: bool};\n \n type cx = {config: config, procsrv: procsrv::handle};"}, {"sha": "32f8762577f04ea97437a6e4b93d181bdc4d4f8a", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -84,11 +84,11 @@ fn log_config(config: config) {\n     logv(c, #fmt[\"\\n\"]);\n }\n \n-fn opt_str(maybestr: option::t<str>) -> str {\n+fn opt_str(maybestr: option<str>) -> str {\n     alt maybestr { option::some(s) { s } option::none { \"(none)\" } }\n }\n \n-fn str_opt(maybestr: str) -> option::t<str> {\n+fn str_opt(maybestr: str) -> option<str> {\n     if maybestr != \"(none)\" { option::some(maybestr) } else { option::none }\n }\n "}, {"sha": "ec881caebbcf116fc85b10fe5ce85ae0ebb25d4e", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -14,10 +14,10 @@ type test_props = {\n     // Lines that should be expected, in order, on standard out\n     error_patterns: [str],\n     // Extra flags to pass to the compiler\n-    compile_flags: option::t<str>,\n+    compile_flags: option<str>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n-    pp_exact: option::t<str>\n+    pp_exact: option<str>\n };\n \n // Load any test directives embedded in the file\n@@ -78,15 +78,15 @@ fn iter_header(testfile: str, it: fn(str)) {\n     }\n }\n \n-fn parse_error_pattern(line: str) -> option::t<str> {\n+fn parse_error_pattern(line: str) -> option<str> {\n     parse_name_value_directive(line, \"error-pattern\")\n }\n \n-fn parse_compile_flags(line: str) -> option::t<str> {\n+fn parse_compile_flags(line: str) -> option<str> {\n     parse_name_value_directive(line, \"compile-flags\")\n }\n \n-fn parse_pp_exact(line: str, testfile: str) -> option::t<str> {\n+fn parse_pp_exact(line: str, testfile: str) -> option<str> {\n     alt parse_name_value_directive(line, \"pp-exact\") {\n       option::some(s) { option::some(s) }\n       option::none {\n@@ -104,7 +104,7 @@ fn parse_name_directive(line: str, directive: str) -> bool {\n }\n \n fn parse_name_value_directive(line: str,\n-                              directive: str) -> option::t<str> {\n+                              directive: str) -> option<str> {\n     let keycolon = directive + \":\";\n     if str::find(line, keycolon) >= 0 {\n         let colon = str::find(line, keycolon) as uint;"}, {"sha": "4d01d299548ff4dff2b808f01782ba5dc15c9818", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -26,7 +26,7 @@ export reqchan;\n type reqchan = chan<request>;\n \n type handle =\n-    {task: option::t<(task::task, port<task::task_notification>)>,\n+    {task: option<(task::task, port<task::task_notification>)>,\n      chan: reqchan};\n \n enum request { exec([u8], [u8], [[u8]], chan<response>), stop, }\n@@ -54,7 +54,7 @@ fn close(handle: handle) {\n }\n \n fn run(handle: handle, lib_path: str, prog: str, args: [str],\n-       input: option::t<str>) -> {status: int, out: str, err: str} {\n+       input: option<str>) -> {status: int, out: str, err: str} {\n     let p = port();\n     let ch = chan(p);\n     send(handle.chan,\n@@ -69,7 +69,7 @@ fn run(handle: handle, lib_path: str, prog: str, args: [str],\n     ret {status: status, out: output, err: errput};\n }\n \n-fn writeclose(fd: fd_t, s: option::t<str>) {\n+fn writeclose(fd: fd_t, s: option<str>) {\n     if option::is_some(s) {\n         let writer = io::fd_writer(fd, false);\n         writer.write_str(option::get(s));"}, {"sha": "a3920ccb1849a22ca3aa493ae4af839fc755155d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -298,7 +298,7 @@ fn exec_compiled_test(cx: cx, props: test_props, testfile: str) -> procres {\n \n fn compose_and_run(cx: cx, testfile: str,\n                    make_args: fn@(config, str) -> procargs, lib_path: str,\n-                   input: option::t<str>) -> procres {\n+                   input: option<str>) -> procres {\n     let procargs = make_args(cx.config, testfile);\n     ret program_output(cx, testfile, lib_path, procargs.prog, procargs.args,\n                        input);\n@@ -334,9 +334,9 @@ fn make_run_args(config: config, _props: test_props, testfile: str) ->\n     ret {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n }\n \n-fn split_maybe_args(argstr: option::t<str>) -> [str] {\n+fn split_maybe_args(argstr: option<str>) -> [str] {\n     fn rm_whitespace(v: [str]) -> [str] {\n-        fn flt(&&s: str) -> option::t<str> {\n+        fn flt(&&s: str) -> option<str> {\n             if !is_whitespace(s) { option::some(s) } else { option::none }\n         }\n \n@@ -355,7 +355,7 @@ fn split_maybe_args(argstr: option::t<str>) -> [str] {\n }\n \n fn program_output(cx: cx, testfile: str, lib_path: str, prog: str,\n-                  args: [str], input: option::t<str>) -> procres {\n+                  args: [str], input: option<str>) -> procres {\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);"}, {"sha": "23ac02b75849c45719d54db73d08279a7473f1c9", "filename": "src/libcore/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -1,6 +1,6 @@\n // Top-level, visible-everywhere definitions.\n \n-// Export type option as a synonym for option::t and export the some and none\n+// Export type option as a synonym for option and export the some and none\n // enum constructors.\n \n import option::{some,  none};"}, {"sha": "9bdc9fb006d42136f6433cc0c6c4172b464ef5ae", "filename": "src/libcore/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -122,7 +122,7 @@ fn spawn(+f: fn~()) -> task {\n }\n \n fn spawn_inner(-f: fn~(),\n-               notify: option<comm::chan<task_notification>>) -> task unsafe {\n+            notify: option::t<comm::chan<task_notification>>) -> task unsafe {\n     let closure: *rust_closure = unsafe::reinterpret_cast(ptr::addr_of(f));\n     #debug(\"spawn: closure={%x,%x}\", (*closure).fnptr, (*closure).envptr);\n     let id = rustrt::new_task();"}, {"sha": "53dccda3f15dff4069b27234f652bf2eece114a0", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -46,7 +46,7 @@ enum t<T> {\n     t({ base: *mutable T, len: uint, rsrc: @dtor_res})\n }\n \n-resource dtor_res(dtor: option::t<fn@()>) {\n+resource dtor_res(dtor: option<fn@()>) {\n     alt dtor {\n       option::none { }\n       option::some(f) { f(); }"}, {"sha": "e6c30f67302ece860375cbbf3a5515ed2edbf4a5", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -38,7 +38,7 @@ Function: create\n // FIXME eventually, a proper datatype plus an exported impl would be\n // preferrable\n fn create<T: copy>() -> t<T> {\n-    type cell<T> = option::t<T>;\n+    type cell<T> = option<T>;\n \n     let initial_capacity: uint = 32u; // 2^5\n      /**"}, {"sha": "19cf97624ab5257d27a9524dcf2748cce6f72c78", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -50,7 +50,7 @@ fn doc_at(data: @[u8], start: uint) -> doc {\n     ret {data: data, start: elt_size.next, end: end};\n }\n \n-fn maybe_get_doc(d: doc, tg: uint) -> option::t<doc> {\n+fn maybe_get_doc(d: doc, tg: uint) -> option<doc> {\n     let pos = d.start;\n     while pos < d.end {\n         let elt_tag = vint_at(*d.data, pos);"}, {"sha": "77db136dc25c310c1ab3db220aa69b42ff3f3c7c", "filename": "src/libstd/freebsd_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ffreebsd_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ffreebsd_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffreebsd_os.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -127,7 +127,7 @@ fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n \n /// Returns the directory containing the running program\n /// followed by a path separator\n-fn get_exe_path() -> option::t<fs::path> unsafe {\n+fn get_exe_path() -> option<fs::path> unsafe {\n     let bufsize = 1023u;\n     // FIXME: path \"strings\" will likely need fixing...\n     let path = str::from_bytes(vec::init_elt(bufsize, 0u8));"}, {"sha": "d497b2a4963b89fcae419133b8894be4a1496bed", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -13,7 +13,7 @@ of features.\n */\n \n import option::{some, none};\n-import option = option::t;\n+import option = option;\n \n export treemap;\n export init;"}, {"sha": "f41e83fa5fbe5aeac3273ce2e479a1f538d256c7", "filename": "src/libstd/generic_os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgeneric_os.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -16,7 +16,7 @@ Function: getenv\n \n Get the value of an environment variable\n */\n-fn getenv(n: str) -> option::t<str> { }\n+fn getenv(n: str) -> option<str> { }\n \n #[cfg(bogus)]\n /*\n@@ -29,7 +29,7 @@ fn setenv(n: str, v: str) { }\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn getenv(n: str) -> option::t<str> unsafe {\n+fn getenv(n: str) -> option<str> unsafe {\n     let s = str::as_buf(n, {|buf| os::libc::getenv(buf) });\n     ret if unsafe::reinterpret_cast(s) == 0 {\n             option::none::<str>\n@@ -55,7 +55,7 @@ fn setenv(n: str, v: str) {\n }\n \n #[cfg(target_os = \"win32\")]\n-fn getenv(n: str) -> option::t<str> {\n+fn getenv(n: str) -> option<str> {\n     let nsize = 256u;\n     while true {\n         let v: [u8] = [];"}, {"sha": "585ea48725f94ff805d480704cfed86575fbbc97", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -148,7 +148,7 @@ fn name_str(nm: name) -> str {\n     ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n }\n \n-fn find_opt(opts: [opt], nm: name) -> option::t<uint> {\n+fn find_opt(opts: [opt], nm: name) -> option<uint> {\n     vec::position_pred(opts, { |opt| opt.name == nm })\n }\n \n@@ -354,7 +354,7 @@ Function: opt_str\n \n Returns the string argument supplied to a matching option or none\n */\n-fn opt_maybe_str(m: match, nm: str) -> option::t<str> {\n+fn opt_maybe_str(m: match, nm: str) -> option<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n     ret alt vals[0] { val(s) { some::<str>(s) } _ { none::<str> } };\n@@ -370,7 +370,7 @@ Returns none if the option was not present, `def` if the option was\n present but no argument was provided, and the argument if the option was\n present and an argument was provided.\n */\n-fn opt_default(m: match, nm: str, def: str) -> option::t<str> {\n+fn opt_default(m: match, nm: str, def: str) -> option<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n     ret alt vals[0] { val(s) { some::<str>(s) } _ { some::<str>(def) } }"}, {"sha": "ba8f1e62fc6f5eb89bb10cd0f96f882eb5f7b854", "filename": "src/libstd/io.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -525,13 +525,13 @@ mod fsync {\n \n     type arg<t> = {\n         val: t,\n-        opt_level: option::t<level>,\n+        opt_level: option<level>,\n         fsync_fn: fn@(t, level) -> int\n     };\n \n     // fsync file after executing blk\n     // FIXME find better way to create resources within lifetime of outer res\n-    fn FILE_res_sync(&&file: FILE_res, opt_level: option::t<level>,\n+    fn FILE_res_sync(&&file: FILE_res, opt_level: option<level>,\n                   blk: fn(&&res<os::libc::FILE>)) {\n         blk(res({\n             val: *file, opt_level: opt_level,\n@@ -542,7 +542,7 @@ mod fsync {\n     }\n \n     // fsync fd after executing blk\n-    fn fd_res_sync(&&fd: fd_res, opt_level: option::t<level>,\n+    fn fd_res_sync(&&fd: fd_res, opt_level: option<level>,\n                    blk: fn(&&res<fd_t>)) {\n         blk(res({\n             val: *fd, opt_level: opt_level,\n@@ -556,7 +556,7 @@ mod fsync {\n     iface t { fn fsync(l: level) -> int; }\n \n     // Call o.fsync after executing blk\n-    fn obj_sync(&&o: t, opt_level: option::t<level>, blk: fn(&&res<t>)) {\n+    fn obj_sync(&&o: t, opt_level: option<level>, blk: fn(&&res<t>)) {\n         blk(res({\n             val: o, opt_level: opt_level,\n             fsync_fn: fn@(&&o: t, l: level) -> int { ret o.fsync(l); }"}, {"sha": "306bcf6e16a21412b1a97c4b7dd8218344c62248", "filename": "src/libstd/json.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -74,7 +74,7 @@ fn rest(s: str) -> str {\n     str::char_slice(s, 1u, str::char_len(s))\n }\n \n-fn from_str_str(s: str) -> (option::t<json>, str) {\n+fn from_str_str(s: str) -> (option<json>, str) {\n     let pos = 0u;\n     let len = str::byte_len(s);\n     let escape = false;\n@@ -107,7 +107,7 @@ fn from_str_str(s: str) -> (option::t<json>, str) {\n     ret (none, s);\n }\n \n-fn from_str_list(s: str) -> (option::t<json>, str) {\n+fn from_str_list(s: str) -> (option<json>, str) {\n     if str::char_at(s, 0u) != '[' { ret (none, s); }\n     let s0 = str::trim_left(rest(s));\n     let vals = [];\n@@ -133,7 +133,7 @@ fn from_str_list(s: str) -> (option::t<json>, str) {\n     ret (none, s0);\n }\n \n-fn from_str_dict(s: str) -> (option::t<json>, str) {\n+fn from_str_dict(s: str) -> (option<json>, str) {\n     if str::char_at(s, 0u) != '{' { ret (none, s); }\n     let s0 = str::trim_left(rest(s));\n     let vals = map::new_str_hash::<json>();\n@@ -170,7 +170,7 @@ fn from_str_dict(s: str) -> (option::t<json>, str) {\n     (none, s)\n }\n \n-fn from_str_float(s: str) -> (option::t<json>, str) {\n+fn from_str_float(s: str) -> (option<json>, str) {\n     let pos = 0u;\n     let len = str::byte_len(s);\n     let res = 0f;\n@@ -226,7 +226,7 @@ fn from_str_float(s: str) -> (option::t<json>, str) {\n     ret (some(num(neg * res)), str::char_slice(s, pos, str::char_len(s)));\n }\n \n-fn from_str_bool(s: str) -> (option::t<json>, str) {\n+fn from_str_bool(s: str) -> (option<json>, str) {\n     if (str::starts_with(s, \"true\")) {\n         (some(boolean(true)), str::slice(s, 4u, str::byte_len(s)))\n     } else if (str::starts_with(s, \"false\")) {\n@@ -236,15 +236,15 @@ fn from_str_bool(s: str) -> (option::t<json>, str) {\n     }\n }\n \n-fn from_str_null(s: str) -> (option::t<json>, str) {\n+fn from_str_null(s: str) -> (option<json>, str) {\n     if (str::starts_with(s, \"null\")) {\n         (some(null), str::slice(s, 4u, str::byte_len(s)))\n     } else {\n         (none, s)\n     }\n }\n \n-fn from_str_helper(s: str) -> (option::t<json>, str) {\n+fn from_str_helper(s: str) -> (option<json>, str) {\n     let s = str::trim_left(s);\n     if str::is_empty(s) { ret (none, s); }\n     let start = str::char_at(s, 0u);\n@@ -264,7 +264,7 @@ Function: from_str\n \n Deserializes a json value from a string.\n */\n-fn from_str(s: str) -> option::t<json> {\n+fn from_str(s: str) -> option<json> {\n     let (j, _) = from_str_helper(s);\n     j\n }"}, {"sha": "378186c78509617dcd4c9a26de431c7a9ef3968d", "filename": "src/libstd/linux_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flinux_os.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -123,7 +123,7 @@ fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n \n /// Returns the directory containing the running program\n /// followed by a path separator\n-fn get_exe_path() -> option::t<fs::path> {\n+fn get_exe_path() -> option<fs::path> {\n     let bufsize = 1023u;\n     // FIXME: path \"strings\" will likely need fixing...\n     let path = str::from_bytes(vec::init_elt(bufsize, 0u8));"}, {"sha": "be6ce7338a3f55bdd82f4ced400cdc3692969489", "filename": "src/libstd/list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -61,8 +61,8 @@ Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n */\n-fn find<T: copy, U: copy>(ls: list<T>, f: fn(T) -> option::t<U>)\n-    -> option::t<U> {\n+fn find<T: copy, U: copy>(ls: list<T>, f: fn(T) -> option<U>)\n+    -> option<U> {\n     let ls = ls;\n     while true {\n         alt ls {\n@@ -259,7 +259,7 @@ mod tests {\n \n     #[test]\n     fn test_find_success() {\n-        fn match(&&i: int) -> option::t<int> {\n+        fn match(&&i: int) -> option<int> {\n             ret if i == 2 { option::some(i) } else { option::none::<int> };\n         }\n         let l = from_vec([0, 1, 2]);\n@@ -268,7 +268,7 @@ mod tests {\n \n     #[test]\n     fn test_find_fail() {\n-        fn match(&&_i: int) -> option::t<int> { ret option::none::<int>; }\n+        fn match(&&_i: int) -> option<int> { ret option::none::<int>; }\n         let l = from_vec([0, 1, 2]);\n         let empty = list::nil::<int>;\n         assert (list::find(l, match) == option::none::<int>);"}, {"sha": "eb2efddc35bc46c78a37ba40b6adb49924cf10a3", "filename": "src/libstd/macos_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacos_os.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -131,7 +131,7 @@ fn target_os() -> str { ret \"macos\"; }\n \n fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".dylib\"; }\n \n-fn get_exe_path() -> option::t<fs::path> {\n+fn get_exe_path() -> option<fs::path> {\n     // FIXME: This doesn't handle the case where the buffer is too small\n     // FIXME: path \"strings\" will likely need fixing...\n     let bufsize = 1023u32;"}, {"sha": "3f53270ed1012dcbb49baf9eb5ef8a9f131f8160", "filename": "src/libstd/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -75,14 +75,14 @@ iface map<K: copy, V: copy> {\n     Get the value for the specified key. If the key does not exist\n     in the map then returns none.\n     */\n-    fn find(K) -> option::t<V>;\n+    fn find(K) -> option<V>;\n     /*\n     Method: remove\n \n     Remove and return a value from the map. If the key does not exist\n     in the map then returns none.\n     */\n-    fn remove(K) -> option::t<V>;\n+    fn remove(K) -> option<V>;\n     /*\n     Method: items\n \n@@ -205,7 +205,7 @@ mod chained {\n         }\n     }\n \n-    fn get<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option::t<V> {\n+    fn get<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option<V> {\n         alt search_tbl(tbl, k, tbl.hasher(k)) {\n           not_found {\n             ret core::option::none;\n@@ -221,7 +221,7 @@ mod chained {\n         }\n     }\n \n-    fn remove<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option::t<V> {\n+    fn remove<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option<V> {\n         alt search_tbl(tbl, k, tbl.hasher(k)) {\n           not_found {\n             ret core::option::none;\n@@ -306,9 +306,9 @@ mod chained {\n \n         fn get(k: K) -> V { option::get(get(self, k)) }\n \n-        fn find(k: K) -> option::t<V> { get(self, k) }\n+        fn find(k: K) -> option<V> { get(self, k) }\n \n-        fn remove(k: K) -> option::t<V> { remove(self, k) }\n+        fn remove(k: K) -> option<V> { remove(self, k) }\n \n         fn items(blk: fn(K, V)) { items(self, blk); }\n "}, {"sha": "28cdbfa3d4055ed0b54cd4f53b831256ae984893", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -481,7 +481,7 @@ mod iterator {\n               node::content(x) { ret node::leaf_iterator::start(x) }\n             }\n         }\n-        fn next(it: node::leaf_iterator::t) -> option::t<node::leaf> {\n+        fn next(it: node::leaf_iterator::t) -> option<node::leaf> {\n             ret node::leaf_iterator::next(it);\n         }\n     }\n@@ -492,7 +492,7 @@ mod iterator {\n               node::content(x) { ret node::char_iterator::start(x) }\n             }\n         }\n-        fn next(it: node::char_iterator::t) -> option::t<char> {\n+        fn next(it: node::char_iterator::t) -> option<char> {\n             ret node::char_iterator::next(it)\n         }\n     }\n@@ -952,7 +952,7 @@ mod node {\n     - `option::some(x)` otherwise, in which case `x` has the same contents\n        as `node` bot lower height and/or fragmentation.\n     */\n-    fn bal(node: @node) -> option::t<@node> {\n+    fn bal(node: @node) -> option<@node> {\n         if height(node) < hint_max_node_height { ret option::none; }\n         //1. Gather all leaves as a forest\n         let forest = [mutable];\n@@ -1230,7 +1230,7 @@ mod node {\n             }\n         }\n \n-        fn next(it: t) -> option::t<leaf> {\n+        fn next(it: t) -> option<leaf> {\n             if it.stackpos < 0 { ret option::none; }\n             while true {\n                 let current = it.stack[it.stackpos];\n@@ -1254,7 +1254,7 @@ mod node {\n     mod char_iterator {\n         type t = {\n             leaf_iterator: leaf_iterator::t,\n-            mutable leaf:  option::t<leaf>,\n+            mutable leaf:  option<leaf>,\n             mutable leaf_byte_pos: uint\n         };\n \n@@ -1274,7 +1274,7 @@ mod node {\n             }\n         }\n \n-        fn next(it: t) -> option::t<char> {\n+        fn next(it: t) -> option<char> {\n             while true {\n                 alt(get_current_or_next_leaf(it)) {\n                   option::none { ret option::none; }\n@@ -1294,7 +1294,7 @@ mod node {\n             fail;//unreachable\n         }\n \n-        fn get_current_or_next_leaf(it: t) -> option::t<leaf> {\n+        fn get_current_or_next_leaf(it: t) -> option<leaf> {\n             alt(it.leaf) {\n               option::some(_) { ret it.leaf }\n               option::none {\n@@ -1311,7 +1311,7 @@ mod node {\n             }\n         }\n \n-        fn get_next_char_in_leaf(it: t) -> option::t<char> {\n+        fn get_next_char_in_leaf(it: t) -> option<char> {\n             alt(it.leaf) {\n               option::none { ret option::none }\n               option::some(aleaf) {"}, {"sha": "d76e37e5071432f67769e00cd75be54738414905", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -12,15 +12,15 @@ import core::option::{some, none};\n /*\n Type: smallintmap\n */\n-type smallintmap<T> = @{mutable v: [mutable option::t<T>]};\n+type smallintmap<T> = @{mutable v: [mutable option<T>]};\n \n /*\n Function: mk\n \n Create a smallintmap\n */\n fn mk<T>() -> smallintmap<T> {\n-    let v: [mutable option::t<T>] = [mutable];\n+    let v: [mutable option<T>] = [mutable];\n     ret @{mutable v: v};\n }\n \n@@ -31,7 +31,7 @@ Add a value to the map. If the map already contains a value for\n the specified key then the original value is replaced.\n */\n fn insert<T: copy>(m: smallintmap<T>, key: uint, val: T) {\n-    vec::grow_set::<option::t<T>>(m.v, key, none::<T>, some::<T>(val));\n+    vec::grow_set::<option<T>>(m.v, key, none::<T>, some::<T>(val));\n }\n \n /*\n@@ -40,8 +40,8 @@ Function: find\n Get the value for the specified key. If the key does not exist\n in the map then returns none\n */\n-fn find<T: copy>(m: smallintmap<T>, key: uint) -> option::t<T> {\n-    if key < vec::len::<option::t<T>>(m.v) { ret m.v[key]; }\n+fn find<T: copy>(m: smallintmap<T>, key: uint) -> option<T> {\n+    if key < vec::len::<option<T>>(m.v) { ret m.v[key]; }\n     ret none::<T>;\n }\n \n@@ -73,11 +73,11 @@ fn contains_key<T: copy>(m: smallintmap<T>, key: uint) -> bool {\n // FIXME: Are these really useful?\n \n fn truncate<T: copy>(m: smallintmap<T>, len: uint) {\n-    m.v = vec::slice_mut::<option::t<T>>(m.v, 0u, len);\n+    m.v = vec::slice_mut::<option<T>>(m.v, 0u, len);\n }\n \n fn max_key<T>(m: smallintmap<T>) -> uint {\n-    ret vec::len::<option::t<T>>(m.v);\n+    ret vec::len::<option<T>>(m.v);\n }\n \n /*\n@@ -98,7 +98,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n         insert(self, key, value);\n         ret !exists;\n     }\n-    fn remove(&&key: uint) -> option::t<V> {\n+    fn remove(&&key: uint) -> option<V> {\n         if key >= vec::len(self.v) { ret none; }\n         let old = self.v[key];\n         self.v[key] = none;\n@@ -108,7 +108,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n         contains_key(self, key)\n     }\n     fn get(&&key: uint) -> V { get(self, key) }\n-    fn find(&&key: uint) -> option::t<V> { find(self, key) }\n+    fn find(&&key: uint) -> option<V> { find(self, key) }\n     fn rehash() { fail }\n     fn items(it: fn(&&uint, V)) {\n         let idx = 0u;"}, {"sha": "eaf1409da1d77b1130a8100cdb5438f94c5e9ff9", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -12,7 +12,7 @@ import rand;\n /*\n Function: mkdtemp\n */\n-fn mkdtemp(prefix: str, suffix: str) -> option::t<str> {\n+fn mkdtemp(prefix: str, suffix: str) -> option<str> {\n     let r = rand::mk_rng();\n     let i = 0u;\n     while (i < 1000u) {"}, {"sha": "072850a6a65fdcfe8098898841639bd7ca34f1d9", "filename": "src/libstd/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -56,7 +56,7 @@ fn test_main(args: [str], tests: [test_desc]) {\n     if !run_tests_console(opts, tests) { fail \"Some tests failed\"; }\n }\n \n-type test_opts = {filter: option::t<str>, run_ignored: bool};\n+type test_opts = {filter: option<str>, run_ignored: bool};\n \n type opt_res = either::t<test_opts, str>;\n \n@@ -248,7 +248,7 @@ fn filter_tests(opts: test_opts,\n         };\n \n         fn filter_fn(test: test_desc, filter_str: str) ->\n-            option::t<test_desc> {\n+            option<test_desc> {\n             if str::find(test.name, filter_str) >= 0 {\n                 ret option::some(test);\n             } else { ret option::none; }\n@@ -263,7 +263,7 @@ fn filter_tests(opts: test_opts,\n     filtered = if !opts.run_ignored {\n         filtered\n     } else {\n-        fn filter(test: test_desc) -> option::t<test_desc> {\n+        fn filter(test: test_desc) -> option<test_desc> {\n             if test.ignore {\n                 ret option::some({name: test.name,\n                                   fn: test.fn,"}, {"sha": "bcea14df37720465fb17e31bd2c36112a2eef56e", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -10,7 +10,7 @@ red-black tree or something else.\n */\n \n import core::option::{some, none};\n-import option = core::option::t;\n+import option = core::option;\n \n export treemap;\n export init;"}, {"sha": "eee4c836277a872782489f95270a4a278a3c7194", "filename": "src/libstd/ufind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fufind.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -6,7 +6,7 @@ import option::{some, none};\n // A very naive implementation of union-find with unsigned integer nodes.\n // Maintains the invariant that the root of a node is always equal to or less\n // than the node itself.\n-type node = option::t<uint>;\n+type node = option<uint>;\n \n type ufind = {mutable nodes: [mutable node]};\n "}, {"sha": "0d874da458a9aa56918527a2341e6672d9d15daf", "filename": "src/libstd/win32_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Flibstd%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fwin32_os.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -111,7 +111,7 @@ fn waitpid(pid: pid_t) -> i32 { ret rustrt::rust_process_wait(pid); }\n \n fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n \n-fn get_exe_path() -> option::t<fs::path> {\n+fn get_exe_path() -> option<fs::path> {\n     // FIXME: This doesn't handle the case where the buffer is too small\n     // FIXME: path \"strings\" will likely need fixing...\n     let bufsize = 1023u;"}, {"sha": "338a494ad160d10c7e3dfae6f4e95d4913722349", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -12,7 +12,7 @@\n \n use std;\n \n-import option = option::t;\n+import option = option;\n import option::some;\n import option::none;\n import str;"}, {"sha": "67b1505afd9ce2976c9d463db2544db806cf59ed", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -10,7 +10,7 @@\n \n use std;\n \n-import option = option::t;\n+import option = option;\n import option::{some, none};\n import std::{map, io, time};\n import io::reader_util;"}, {"sha": "6ebc4a2762671f7467db72861c616f6bf174437c", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -6,7 +6,7 @@ import option::some;\n \n // error-pattern: mismatched types\n \n-enum bar { t1((), option::t<[int]>), t2, }\n+enum bar { t1((), option<[int]>), t2, }\n \n fn foo(t: bar) -> int { alt t { t1(_, some(x)) { ret x * 3; } _ { fail; } } }\n "}, {"sha": "607e32685f3275f11e3d4e5d0dd5ca23ec128648", "filename": "src/test/compile-fail/pattern-tyvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -5,7 +5,7 @@ import option::some;\n \n // error-pattern: mismatched types\n \n-enum bar { t1((), option::t<[int]>), t2, }\n+enum bar { t1((), option<[int]>), t2, }\n \n fn foo(t: bar) {\n     alt t {"}, {"sha": "e429db659ab1915af5831f819dbc24648d152ac2", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n // xfail-test\n-// error-pattern:option::t\n+// error-pattern:option\n use std;\n import vec::*;\n "}, {"sha": "0679022d37a9879309d3054288928148a5d9a050", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -7,9 +7,9 @@ import option::none;\n \n enum sty { ty_nil, }\n \n-type raw_t = {struct: sty, cname: option::t<str>, hash: uint};\n+type raw_t = {struct: sty, cname: option<str>, hash: uint};\n \n-fn mk_raw_ty(st: sty, cname: option::t<str>) -> raw_t {\n+fn mk_raw_ty(st: sty, cname: option<str>) -> raw_t {\n     ret {struct: st, cname: cname, hash: 0u};\n }\n "}, {"sha": "77b52da4acfc660593d17080b76dc77fc8046fbb", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -1,11 +1,8 @@\n \n use std;\n import option;\n-import option::t;\n-import option::none;\n-import option::some;\n \n-fn foo<T>(y: option::t<T>) {\n+fn foo<T>(y: option<T>) {\n     let x: int;\n     let rs: [int] = [];\n     /* tests that x doesn't get put in the precondition for the"}, {"sha": "eeed3d32800a559594103ee30388b618fc130738", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -6,7 +6,7 @@\n \n use std;\n \n-import option = option::t;\n+import option = option;\n import option::some;\n import option::none;\n import str;"}, {"sha": "34e8a8e47b920c3430fa6539104006cf094e6410", "filename": "src/test/run-pass/issue-511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-511.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -1,7 +1,7 @@\n use std;\n import option;\n \n-fn f<T>(&o: option::t<T>) {\n+fn f<T>(&o: option<T>) {\n     assert o == option::none;\n }\n "}, {"sha": "6eda8f11489c9d68b28e97df6235ea5be95b2665", "filename": "src/test/run-pass/nested-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-pattern.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -6,7 +6,7 @@ import option;\n import option::some;\n import option::none;\n \n-enum t { foo(int, uint), bar(int, option::t<int>), }\n+enum t { foo(int, uint), bar(int, option<int>), }\n \n fn nested(o: t) {\n     alt o {"}, {"sha": "65b793564ad876de246770ba9d3a25fead74cc19", "filename": "src/test/run-pass/shape_intrinsic_tag_then_rec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d095d67e3926fa104ac495076fe9d4cd4f5562/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs?ref=e5d095d67e3926fa104ac495076fe9d4cd4f5562", "patch": "@@ -9,7 +9,7 @@ import option;\n \n enum opt_span {\n \n-    //hack (as opposed to option::t), to make `span` compile\n+    //hack (as opposed to option), to make `span` compile\n     os_none,\n     os_some(@span),\n }"}]}