{"sha": "f7d59b2e574888912cf7fb670c742b4636e451d0", "node_id": "C_kwDOAAsO6NoAKGY3ZDU5YjJlNTc0ODg4OTEyY2Y3ZmI2NzBjNzQyYjQ2MzZlNDUxZDA", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-02-01T21:50:43Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-02-01T21:50:43Z"}, "message": "Don't depend on FormatArgsExpn in ManualAssert.", "tree": {"sha": "f64bdd8ba5d08a4892bcb994667b43b32b01b7af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f64bdd8ba5d08a4892bcb994667b43b32b01b7af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7d59b2e574888912cf7fb670c742b4636e451d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7d59b2e574888912cf7fb670c742b4636e451d0", "html_url": "https://github.com/rust-lang/rust/commit/f7d59b2e574888912cf7fb670c742b4636e451d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7d59b2e574888912cf7fb670c742b4636e451d0/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "588c1ba3ff758223f71ccadefc79bdb4cf362fe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/588c1ba3ff758223f71ccadefc79bdb4cf362fe7", "html_url": "https://github.com/rust-lang/rust/commit/588c1ba3ff758223f71ccadefc79bdb4cf362fe7"}], "stats": {"total": 97, "additions": 48, "deletions": 49}, "files": [{"sha": "ce5d657bcf0e3cff6e44a6a65410d471e7a62852", "filename": "clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f7d59b2e574888912cf7fb670c742b4636e451d0/clippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7d59b2e574888912cf7fb670c742b4636e451d0/clippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_assert.rs?ref=f7d59b2e574888912cf7fb670c742b4636e451d0", "patch": "@@ -1,7 +1,6 @@\n use crate::rustc_lint::LintContext;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::macros::{root_macro_call, FormatArgsExpn};\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::macros::root_macro_call;\n use clippy_utils::{is_else_clause, peel_blocks_with_stmt, span_extract_comment, sugg};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, UnOp};\n@@ -38,57 +37,57 @@ declare_lint_pass!(ManualAssert => [MANUAL_ASSERT]);\n \n impl<'tcx> LateLintPass<'tcx> for ManualAssert {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if_chain! {\n-            if let ExprKind::If(cond, then, None) = expr.kind;\n-            if !matches!(cond.kind, ExprKind::Let(_));\n-            if !expr.span.from_expansion();\n-            let then = peel_blocks_with_stmt(then);\n-            if let Some(macro_call) = root_macro_call(then.span);\n-            if cx.tcx.item_name(macro_call.def_id) == sym::panic;\n-            if !cx.tcx.sess.source_map().is_multiline(cond.span);\n-            if let Some(format_args) = FormatArgsExpn::find_nested(cx, then, macro_call.expn);\n+        if let ExprKind::If(cond, then, None) = expr.kind\n+            && !matches!(cond.kind, ExprKind::Let(_))\n+            && !expr.span.from_expansion()\n+            && let then = peel_blocks_with_stmt(then)\n+            && let Some(macro_call) = root_macro_call(then.span)\n+            && cx.tcx.item_name(macro_call.def_id) == sym::panic\n+            && !cx.tcx.sess.source_map().is_multiline(cond.span)\n+            && let Ok(panic_snippet) = cx.sess().source_map().span_to_snippet(macro_call.span)\n+            && let Some(panic_snippet) = panic_snippet.strip_suffix(')')\n+            && let Some((_, format_args_snip)) = panic_snippet.split_once('(')\n             // Don't change `else if foo { panic!(..) }` to `else { assert!(foo, ..) }` as it just\n             // shuffles the condition around.\n             // Should this have a config value?\n-            if !is_else_clause(cx.tcx, expr);\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let format_args_snip = snippet_with_applicability(cx, format_args.inputs_span(), \"..\", &mut applicability);\n-                let cond = cond.peel_drop_temps();\n-                let mut comments = span_extract_comment(cx.sess().source_map(), expr.span);\n-                if !comments.is_empty() {\n-                    comments += \"\\n\";\n-                }\n-                let (cond, not) = match cond.kind {\n-                    ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n-                    _ => (cond, \"!\"),\n-                };\n-                let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n-                let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n-                // we show to the user the suggestion without the comments, but when applicating the fix, include the comments in the block\n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_ASSERT,\n-                    expr.span,\n-                    \"only a `panic!` in `if`-then statement\",\n-                    |diag| {\n-                        // comments can be noisy, do not show them to the user\n-                        if !comments.is_empty() {\n-                            diag.tool_only_span_suggestion(\n-                                        expr.span.shrink_to_lo(),\n-                                        \"add comments back\",\n-                                        comments,\n-                                        applicability);\n-                        }\n-                        diag.span_suggestion(\n-                                    expr.span,\n-                                    \"try instead\",\n-                                    sugg,\n-                                    applicability);\n-                                     }\n-\n-                );\n+            && !is_else_clause(cx.tcx, expr)\n+        {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let cond = cond.peel_drop_temps();\n+            let mut comments = span_extract_comment(cx.sess().source_map(), expr.span);\n+            if !comments.is_empty() {\n+                comments += \"\\n\";\n             }\n+            let (cond, not) = match cond.kind {\n+                ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n+                _ => (cond, \"!\"),\n+            };\n+            let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n+            let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n+            // we show to the user the suggestion without the comments, but when applicating the fix, include the comments in the block\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_ASSERT,\n+                expr.span,\n+                \"only a `panic!` in `if`-then statement\",\n+                |diag| {\n+                    // comments can be noisy, do not show them to the user\n+                    if !comments.is_empty() {\n+                        diag.tool_only_span_suggestion(\n+                            expr.span.shrink_to_lo(),\n+                            \"add comments back\",\n+                            comments,\n+                            applicability\n+                        );\n+                    }\n+                    diag.span_suggestion(\n+                        expr.span,\n+                        \"try instead\",\n+                        sugg,\n+                        applicability\n+                    );\n+                }\n+            );\n         }\n     }\n }"}]}