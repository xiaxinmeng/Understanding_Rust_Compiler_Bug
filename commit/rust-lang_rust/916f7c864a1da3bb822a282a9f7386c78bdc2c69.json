{"sha": "916f7c864a1da3bb822a282a9f7386c78bdc2c69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNmY3Yzg2NGExZGEzYmI4MjJhMjgyYTlmNzM4NmM3OGJkYzJjNjk=", "commit": {"author": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-06-26T17:21:55Z"}, "committer": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-06-26T18:31:35Z"}, "message": "Revert \"Remove functions that always error\"\n\nThis reverts commit 21d09b983de87fec2e98832f4c30b52f12d6342f.", "tree": {"sha": "8a3c2ee624686d75dba981361a7456ac441437ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a3c2ee624686d75dba981361a7456ac441437ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/916f7c864a1da3bb822a282a9f7386c78bdc2c69", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEvF2uTsFosfm5TJhQMFXVRymnJmYFAlsyhocACgkQMFXVRymn\nJmY3SAf/QXJtNAv7QFNiHIlwiW17x7mp1QxuVFK8kx3h9F0fkTxdOqZmNmdM6TOV\nbsfgn1ZAuNSAj7K+nY1eTOBJMO6nJI9X2AFH9860kMthiIQr0kPXKzGA3DLwcCPO\ntZdN2S9NSOHhHtXM57EtZn+k1fY5ZKEk94srrjuRj7OiBoL9RySbJQecQ7tVZJRF\nSp47wNtpQP+hDPltBVmozkyTt1qkFVRtl0QHTyAvPOBqoIuSdzdIkvrBhBLgl1HX\ncrSe+oO9ji+YVqwTv6l7/5XcX7ShIYXiZnnycfQ4f/taGfkRAPisAL1T6JXpsSE4\nZobFcp+wdreBk4zAtAQj7Yu1qbqgIw==\n=eII/\n-----END PGP SIGNATURE-----", "payload": "tree 8a3c2ee624686d75dba981361a7456ac441437ca\nparent c86a7a01e27f78474ff5ce2fe7f88aa2cb14caad\nauthor jD91mZM2 <me@krake.one> 1530033715 +0200\ncommitter jD91mZM2 <me@krake.one> 1530037895 +0200\n\nRevert \"Remove functions that always error\"\n\nThis reverts commit 21d09b983de87fec2e98832f4c30b52f12d6342f.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/916f7c864a1da3bb822a282a9f7386c78bdc2c69", "html_url": "https://github.com/rust-lang/rust/commit/916f7c864a1da3bb822a282a9f7386c78bdc2c69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/916f7c864a1da3bb822a282a9f7386c78bdc2c69/comments", "author": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c86a7a01e27f78474ff5ce2fe7f88aa2cb14caad", "url": "https://api.github.com/repos/rust-lang/rust/commits/c86a7a01e27f78474ff5ce2fe7f88aa2cb14caad", "html_url": "https://github.com/rust-lang/rust/commit/c86a7a01e27f78474ff5ce2fe7f88aa2cb14caad"}], "stats": {"total": 181, "additions": 181, "deletions": 0}, "files": [{"sha": "d29d28c8427d07e899d23955b3153a5c0b585757", "filename": "src/libstd/sys/redox/ext/net.rs", "status": "modified", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/916f7c864a1da3bb822a282a9f7386c78bdc2c69/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/916f7c864a1da3bb822a282a9f7386c78bdc2c69/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs?ref=916f7c864a1da3bb822a282a9f7386c78bdc2c69", "patch": "@@ -94,6 +94,12 @@ impl fmt::Debug for UnixStream {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixStream\");\n         builder.field(\"fd\", &self.0.raw());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n         builder.finish()\n     }\n }\n@@ -171,6 +177,142 @@ impl UnixStream {\n         self.0.duplicate().map(UnixStream)\n     }\n \n+    /// Returns the socket address of the local half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n+    }\n+\n+    /// Returns the socket address of the remote half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`read`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n+    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    pub fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`write`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n+    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    pub fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n+    }\n+\n     /// Moves the socket into or out of nonblocking mode.\n     ///\n     /// # Examples\n@@ -203,6 +345,27 @@ impl UnixStream {\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)\n     }\n+\n+    /// Shuts down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n+    pub fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n+    }\n }\n \n impl io::Read for UnixStream {\n@@ -299,6 +462,9 @@ impl fmt::Debug for UnixListener {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixListener\");\n         builder.field(\"fd\", &self.0.raw());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n         builder.finish()\n     }\n }\n@@ -375,6 +541,21 @@ impl UnixListener {\n         self.0.duplicate().map(UnixListener)\n     }\n \n+    /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n+    }\n+\n     /// Moves the socket into or out of nonblocking mode.\n     ///\n     /// # Examples"}]}