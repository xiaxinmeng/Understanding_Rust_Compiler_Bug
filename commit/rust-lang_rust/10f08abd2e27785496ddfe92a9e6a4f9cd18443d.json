{"sha": "10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZjA4YWJkMmUyNzc4NTQ5NmRkZmU5MmE5ZTZhNGY5Y2QxODQ0M2Q=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-13T01:23:38Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-21T12:23:50Z"}, "message": "rustc: keep upvars tupled in {Closure,Generator}Substs.", "tree": {"sha": "d903fec550e648c38d1a42fb6c9b8e004be77662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d903fec550e648c38d1a42fb6c9b8e004be77662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "html_url": "https://github.com/rust-lang/rust/commit/10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98803c182b2ba6ef5dccb6bf501958249295eac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/98803c182b2ba6ef5dccb6bf501958249295eac0", "html_url": "https://github.com/rust-lang/rust/commit/98803c182b2ba6ef5dccb6bf501958249295eac0"}], "stats": {"total": 685, "additions": 353, "deletions": 332}, "files": [{"sha": "67f4b15f9194dc153946a825ea4d4f1bee6a0782", "filename": "src/librustc/traits/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -229,8 +229,8 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n         ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n-        ty::Closure(def_id, ref substs) => {\n-            substs.as_closure().upvar_tys(def_id, tcx).all(|t| trivial_dropck_outlives(tcx, t))\n+        ty::Closure(_, ref substs) => {\n+            substs.as_closure().upvar_tys().all(|t| trivial_dropck_outlives(tcx, t))\n         }\n \n         ty::Adt(def, _) => {"}, {"sha": "ae3487bee7abfc4eaf22992e9ea430d8ce054f2b", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -341,7 +341,7 @@ impl<'tcx> Instance<'tcx> {\n         substs: ty::SubstsRef<'tcx>,\n         requested_kind: ty::ClosureKind,\n     ) -> Instance<'tcx> {\n-        let actual_kind = substs.as_closure().kind(def_id, tcx);\n+        let actual_kind = substs.as_closure().kind();\n \n         match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n             Ok(true) => Instance::fn_once_adapter_instance(tcx, def_id, substs),\n@@ -372,7 +372,7 @@ impl<'tcx> Instance<'tcx> {\n \n         let self_ty = tcx.mk_closure(closure_did, substs);\n \n-        let sig = substs.as_closure().sig(closure_did, tcx);\n+        let sig = substs.as_closure().sig();\n         let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         assert_eq!(sig.inputs().len(), 1);\n         let substs = tcx.mk_substs_trait(self_ty, &[sig.inputs()[0].into()]);"}, {"sha": "f0f083733e0978443eb68341c122574a06facf21", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -632,8 +632,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n             ty::Generator(def_id, substs, _) => self.generator_layout(ty, def_id, substs)?,\n \n-            ty::Closure(def_id, ref substs) => {\n-                let tys = substs.as_closure().upvar_tys(def_id, tcx);\n+            ty::Closure(_, ref substs) => {\n+                let tys = substs.as_closure().upvar_tys();\n                 univariant(\n                     &tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n@@ -1406,7 +1406,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // Build a prefix layout, including \"promoting\" all ineligible\n         // locals as part of the prefix. We compute the layout of all of\n         // these fields at once to get optimal packing.\n-        let discr_index = substs.as_generator().prefix_tys(def_id, tcx).count();\n+        let discr_index = substs.as_generator().prefix_tys().count();\n \n         // `info.variant_fields` already accounts for the reserved variants, so no need to add them.\n         let max_discr = (info.variant_fields.len() - 1) as u128;\n@@ -1423,7 +1423,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             .map(|ty| self.layout_of(ty));\n         let prefix_layouts = substs\n             .as_generator()\n-            .prefix_tys(def_id, tcx)\n+            .prefix_tys()\n             .map(|ty| self.layout_of(ty))\n             .chain(iter::once(Ok(discr_layout)))\n             .chain(promoted_layouts)\n@@ -2099,9 +2099,7 @@ where\n             ty::Str => tcx.types.u8,\n \n             // Tuples, generators and closures.\n-            ty::Closure(def_id, ref substs) => {\n-                substs.as_closure().upvar_tys(def_id, tcx).nth(i).unwrap()\n-            }\n+            ty::Closure(_, ref substs) => substs.as_closure().upvar_tys().nth(i).unwrap(),\n \n             ty::Generator(def_id, ref substs, _) => match this.variants {\n                 Variants::Single { index } => substs\n@@ -2115,7 +2113,7 @@ where\n                     if i == discr_index {\n                         return discr_layout(discr);\n                     }\n-                    substs.as_generator().prefix_tys(def_id, tcx).nth(i).unwrap()\n+                    substs.as_generator().prefix_tys().nth(i).unwrap()\n                 }\n             },\n \n@@ -2302,7 +2300,7 @@ impl<'tcx> ty::Instance<'tcx> {\n                 sig\n             }\n             ty::Closure(def_id, substs) => {\n-                let sig = substs.as_closure().sig(def_id, tcx);\n+                let sig = substs.as_closure().sig();\n \n                 let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n                 sig.map_bound(|sig| tcx.mk_fn_sig(\n@@ -2313,8 +2311,8 @@ impl<'tcx> ty::Instance<'tcx> {\n                     sig.abi\n                 ))\n             }\n-            ty::Generator(def_id, substs, _) => {\n-                let sig = substs.as_generator().poly_sig(def_id, tcx);\n+            ty::Generator(_, substs, _) => {\n+                let sig = substs.as_generator().poly_sig();\n \n                 let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n                 let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);"}, {"sha": "9dd96f2f2b507f049f73f44c585acbe05c08727c", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -61,15 +61,15 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n     // in the `subtys` iterator (e.g., when encountering a\n     // projection).\n     match ty.kind {\n-            ty::Closure(def_id, ref substs) => {\n-                for upvar_ty in substs.as_closure().upvar_tys(def_id, tcx) {\n+            ty::Closure(_, ref substs) => {\n+                for upvar_ty in substs.as_closure().upvar_tys() {\n                     compute_components(tcx, upvar_ty, out);\n                 }\n             }\n \n-            ty::Generator(def_id, ref substs, _) => {\n+            ty::Generator(_, ref substs, _) => {\n                 // Same as the closure case\n-                for upvar_ty in substs.as_generator().upvar_tys(def_id, tcx) {\n+                for upvar_ty in substs.as_generator().upvar_tys() {\n                     compute_components(tcx, upvar_ty, out);\n                 }\n "}, {"sha": "3a95c573ca30c500baa69a539b51eeb186c22bc8", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -617,8 +617,6 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Str => p!(write(\"str\")),\n             ty::Generator(did, substs, movability) => {\n-                let upvar_tys = substs.as_generator().upvar_tys(did, self.tcx());\n-                let witness = substs.as_generator().witness(did, self.tcx());\n                 match movability {\n                     hir::Movability::Movable => p!(write(\"[generator\")),\n                     hir::Movability::Static => p!(write(\"[static generator\")),\n@@ -627,31 +625,47 @@ pub trait PrettyPrinter<'tcx>:\n                 // FIXME(eddyb) should use `def_span`.\n                 if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n                     p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n-                    let mut sep = \" \";\n-                    for (&var_id, upvar_ty) in\n-                        self.tcx().upvars(did).as_ref().iter().flat_map(|v| v.keys()).zip(upvar_tys)\n-                    {\n-                        p!(write(\"{}{}:\", sep, self.tcx().hir().name(var_id)), print(upvar_ty));\n-                        sep = \", \";\n+\n+                    if substs.as_generator().is_valid() {\n+                        let upvar_tys = substs.as_generator().upvar_tys();\n+                        let mut sep = \" \";\n+                        for (&var_id, upvar_ty) in self\n+                            .tcx()\n+                            .upvars(did)\n+                            .as_ref()\n+                            .iter()\n+                            .flat_map(|v| v.keys())\n+                            .zip(upvar_tys)\n+                        {\n+                            p!(write(\"{}{}:\", sep, self.tcx().hir().name(var_id)), print(upvar_ty));\n+                            sep = \", \";\n+                        }\n                     }\n                 } else {\n                     // Cross-crate closure types should only be\n                     // visible in codegen bug reports, I imagine.\n                     p!(write(\"@{:?}\", did));\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        p!(write(\"{}{}:\", sep, index), print(upvar_ty));\n-                        sep = \", \";\n+\n+                    if substs.as_generator().is_valid() {\n+                        let upvar_tys = substs.as_generator().upvar_tys();\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            p!(write(\"{}{}:\", sep, index), print(upvar_ty));\n+                            sep = \", \";\n+                        }\n                     }\n                 }\n \n-                p!(write(\" \"), print(witness), write(\"]\"))\n+                if substs.as_generator().is_valid() {\n+                    p!(write(\" \"), print(substs.as_generator().witness()));\n+                }\n+\n+                p!(write(\"]\"))\n             }\n             ty::GeneratorWitness(types) => {\n                 p!(in_binder(&types));\n             }\n             ty::Closure(did, substs) => {\n-                let upvar_tys = substs.as_closure().upvar_tys(did, self.tcx());\n                 p!(write(\"[closure\"));\n \n                 // FIXME(eddyb) should use `def_span`.\n@@ -661,30 +675,43 @@ pub trait PrettyPrinter<'tcx>:\n                     } else {\n                         p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n                     }\n-                    let mut sep = \" \";\n-                    for (&var_id, upvar_ty) in\n-                        self.tcx().upvars(did).as_ref().iter().flat_map(|v| v.keys()).zip(upvar_tys)\n-                    {\n-                        p!(write(\"{}{}:\", sep, self.tcx().hir().name(var_id)), print(upvar_ty));\n-                        sep = \", \";\n+\n+                    if substs.as_closure().is_valid() {\n+                        let upvar_tys = substs.as_closure().upvar_tys();\n+                        let mut sep = \" \";\n+                        for (&var_id, upvar_ty) in self\n+                            .tcx()\n+                            .upvars(did)\n+                            .as_ref()\n+                            .iter()\n+                            .flat_map(|v| v.keys())\n+                            .zip(upvar_tys)\n+                        {\n+                            p!(write(\"{}{}:\", sep, self.tcx().hir().name(var_id)), print(upvar_ty));\n+                            sep = \", \";\n+                        }\n                     }\n                 } else {\n                     // Cross-crate closure types should only be\n                     // visible in codegen bug reports, I imagine.\n                     p!(write(\"@{:?}\", did));\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        p!(write(\"{}{}:\", sep, index), print(upvar_ty));\n-                        sep = \", \";\n+\n+                    if substs.as_closure().is_valid() {\n+                        let upvar_tys = substs.as_closure().upvar_tys();\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            p!(write(\"{}{}:\", sep, index), print(upvar_ty));\n+                            sep = \", \";\n+                        }\n                     }\n                 }\n \n-                if self.tcx().sess.verbose() {\n-                    p!(write(\n-                        \" closure_kind_ty={:?} closure_sig_as_fn_ptr_ty={:?}\",\n-                        substs.as_closure().kind_ty(did, self.tcx()),\n-                        substs.as_closure().sig_as_fn_ptr_ty(did, self.tcx())\n-                    ));\n+                if self.tcx().sess.verbose() && substs.as_closure().is_valid() {\n+                    p!(write(\" closure_kind_ty=\"), print(substs.as_closure().kind_ty()));\n+                    p!(\n+                        write(\" closure_sig_as_fn_ptr_ty=\"),\n+                        print(substs.as_closure().sig_as_fn_ptr_ty())\n+                    );\n                 }\n \n                 p!(write(\"]\"))"}, {"sha": "5bdab69e2ca978ca52bd2cbd808c37ce2e586bdf", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 89, "deletions": 74, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -11,7 +11,7 @@ use crate::mir::interpret::ConstValue;\n use crate::mir::interpret::Scalar;\n use crate::mir::Promoted;\n use crate::ty::layout::VariantIdx;\n-use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n+use crate::ty::subst::{GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use crate::ty::{\n     self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable, WithConstness,\n };\n@@ -260,15 +260,11 @@ static_assert_size!(TyKind<'_>, 24);\n \n /// A closure can be modeled as a struct that looks like:\n ///\n-///     struct Closure<'l0...'li, T0...Tj, CK, CS, U0...Uk> {\n-///         upvar0: U0,\n-///         ...\n-///         upvark: Uk\n-///     }\n+///     struct Closure<'l0...'li, T0...Tj, CK, CS, U>(...U);\n ///\n /// where:\n ///\n-/// - 'l0...'li and T0...Tj are the lifetime and type parameters\n+/// - 'l0...'li and T0...Tj are the generic parameters\n ///   in scope on the function that defined the closure,\n /// - CK represents the *closure kind* (Fn vs FnMut vs FnOnce). This\n ///   is rather hackily encoded via a scalar type. See\n@@ -277,9 +273,9 @@ static_assert_size!(TyKind<'_>, 24);\n ///   type. For example, `fn(u32, u32) -> u32` would mean that the closure\n ///   implements `CK<(u32, u32), Output = u32>`, where `CK` is the trait\n ///   specified above.\n-/// - U0...Uk are type parameters representing the types of its upvars\n-///   (borrowed, if appropriate; that is, if Ui represents a by-ref upvar,\n-///    and the up-var has the type `Foo`, then `Ui = &Foo`).\n+/// - U is a type parameter representing the types of its upvars, tupled up\n+///   (borrowed, if appropriate; that is, if an U field represents a by-ref upvar,\n+///    and the up-var has the type `Foo`, then that field of U will be `&Foo`).\n ///\n /// So, for example, given this function:\n ///\n@@ -289,17 +285,15 @@ static_assert_size!(TyKind<'_>, 24);\n ///\n /// the type of the closure would be something like:\n ///\n-///     struct Closure<'a, T, U0> {\n-///         data: U0\n-///     }\n+///     struct Closure<'a, T, U>(...U);\n ///\n /// Note that the type of the upvar is not specified in the struct.\n /// You may wonder how the impl would then be able to use the upvar,\n /// if it doesn't know it's type? The answer is that the impl is\n /// (conceptually) not fully generic over Closure but rather tied to\n /// instances with the expected upvar types:\n ///\n-///     impl<'b, 'a, T> FnMut() for Closure<'a, T, &'b mut &'a mut T> {\n+///     impl<'b, 'a, T> FnMut() for Closure<'a, T, (&'b mut &'a mut T,)> {\n ///         ...\n ///     }\n ///\n@@ -308,7 +302,7 @@ static_assert_size!(TyKind<'_>, 24);\n /// (Here, I am assuming that `data` is mut-borrowed.)\n ///\n /// Now, the last question you may ask is: Why include the upvar types\n-/// as extra type parameters? The reason for this design is that the\n+/// in an extra type parameter? The reason for this design is that the\n /// upvar types can reference lifetimes that are internal to the\n /// creating function. In my example above, for example, the lifetime\n /// `'b` represents the scope of the closure itself; this is some\n@@ -360,7 +354,7 @@ static_assert_size!(TyKind<'_>, 24);\n #[derive(Copy, Clone, Debug, TypeFoldable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n-    /// concatenated with the types of the upvars.\n+    /// concatenated with a tuple containing the types of the upvars.\n     ///\n     /// These are separated out because codegen wants to pass them around\n     /// when monomorphizing.\n@@ -370,33 +364,42 @@ pub struct ClosureSubsts<'tcx> {\n /// Struct returned by `split()`. Note that these are subslices of the\n /// parent slice and not canonical substs themselves.\n struct SplitClosureSubsts<'tcx> {\n+    // FIXME(eddyb) maybe replace these with `GenericArg` to avoid having\n+    // `GenericArg::expect_ty` called on all of them when only one is used.\n     closure_kind_ty: Ty<'tcx>,\n     closure_sig_as_fn_ptr_ty: Ty<'tcx>,\n-    upvar_kinds: &'tcx [GenericArg<'tcx>],\n+    tupled_upvars_ty: Ty<'tcx>,\n }\n \n impl<'tcx> ClosureSubsts<'tcx> {\n     /// Divides the closure substs into their respective\n     /// components. Single source of truth with respect to the\n     /// ordering.\n-    fn split(self, def_id: DefId, tcx: TyCtxt<'_>) -> SplitClosureSubsts<'tcx> {\n-        let generics = tcx.generics_of(def_id);\n-        let parent_len = generics.parent_count;\n+    fn split(self) -> SplitClosureSubsts<'tcx> {\n+        let parent_len = self.substs.len() - 3;\n         SplitClosureSubsts {\n             closure_kind_ty: self.substs.type_at(parent_len),\n             closure_sig_as_fn_ptr_ty: self.substs.type_at(parent_len + 1),\n-            upvar_kinds: &self.substs[parent_len + 2..],\n+            tupled_upvars_ty: self.substs.type_at(parent_len + 2),\n         }\n     }\n \n+    /// Returns `true` only if enough of the synthetic types are known to\n+    /// allow using all of the methods on `ClosureSubsts` without panicking.\n+    ///\n+    /// Used primarily by `ty::print::pretty` to be able to handle closure\n+    /// types that haven't had their synthetic types substituted in.\n+    pub fn is_valid(self) -> bool {\n+        self.substs.len() >= 3 && matches!(self.split().tupled_upvars_ty.kind, Tuple(_))\n+    }\n+\n     #[inline]\n-    pub fn upvar_tys(\n-        self,\n-        def_id: DefId,\n-        tcx: TyCtxt<'_>,\n-    ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n-        let SplitClosureSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n-        upvar_kinds.iter().map(|t| {\n+    pub fn upvar_tys(self) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n+        let upvars = match self.split().tupled_upvars_ty.kind {\n+            Tuple(upvars) => upvars,\n+            _ => bug!(\"upvars should be tupled\"),\n+        };\n+        upvars.iter().map(|t| {\n             if let GenericArgKind::Type(ty) = t.unpack() {\n                 ty\n             } else {\n@@ -407,29 +410,32 @@ impl<'tcx> ClosureSubsts<'tcx> {\n \n     /// Returns the closure kind for this closure; may return a type\n     /// variable during inference. To get the closure kind during\n-    /// inference, use `infcx.closure_kind(def_id, substs)`.\n-    pub fn kind_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n-        self.split(def_id, tcx).closure_kind_ty\n+    /// inference, use `infcx.closure_kind(substs)`.\n+    pub fn kind_ty(self) -> Ty<'tcx> {\n+        self.split().closure_kind_ty\n     }\n \n     /// Returns the `fn` pointer type representing the closure signature for this\n     /// closure.\n-    pub fn sig_as_fn_ptr_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n-        self.split(def_id, tcx).closure_sig_as_fn_ptr_ty\n+    // FIXME(eddyb) this should be unnecessary, as the shallowly resolved\n+    // type is known at the time of the creation of `ClosureSubsts`,\n+    // see `rustc_typeck::check::closure`.\n+    pub fn sig_as_fn_ptr_ty(self) -> Ty<'tcx> {\n+        self.split().closure_sig_as_fn_ptr_ty\n     }\n \n     /// Returns the closure kind for this closure; only usable outside\n     /// of an inference context, because in that context we know that\n     /// there are no type variables.\n     ///\n     /// If you have an inference context, use `infcx.closure_kind()`.\n-    pub fn kind(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> ty::ClosureKind {\n-        self.split(def_id, tcx).closure_kind_ty.to_opt_closure_kind().unwrap()\n+    pub fn kind(self) -> ty::ClosureKind {\n+        self.split().closure_kind_ty.to_opt_closure_kind().unwrap()\n     }\n \n     /// Extracts the signature from the closure.\n-    pub fn sig(&self, def_id: DefId, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let ty = self.sig_as_fn_ptr_ty(def_id, tcx);\n+    pub fn sig(self) -> ty::PolyFnSig<'tcx> {\n+        let ty = self.sig_as_fn_ptr_ty();\n         match ty.kind {\n             ty::FnPtr(sig) => sig,\n             _ => bug!(\"closure_sig_as_fn_ptr_ty is not a fn-ptr: {:?}\", ty.kind),\n@@ -444,43 +450,52 @@ pub struct GeneratorSubsts<'tcx> {\n }\n \n struct SplitGeneratorSubsts<'tcx> {\n+    // FIXME(eddyb) maybe replace these with `GenericArg` to avoid having\n+    // `GenericArg::expect_ty` called on all of them when only one is used.\n     resume_ty: Ty<'tcx>,\n     yield_ty: Ty<'tcx>,\n     return_ty: Ty<'tcx>,\n     witness: Ty<'tcx>,\n-    upvar_kinds: &'tcx [GenericArg<'tcx>],\n+    tupled_upvars_ty: Ty<'tcx>,\n }\n \n impl<'tcx> GeneratorSubsts<'tcx> {\n-    fn split(self, def_id: DefId, tcx: TyCtxt<'_>) -> SplitGeneratorSubsts<'tcx> {\n-        let generics = tcx.generics_of(def_id);\n-        let parent_len = generics.parent_count;\n+    fn split(self) -> SplitGeneratorSubsts<'tcx> {\n+        let parent_len = self.substs.len() - 5;\n         SplitGeneratorSubsts {\n             resume_ty: self.substs.type_at(parent_len),\n             yield_ty: self.substs.type_at(parent_len + 1),\n             return_ty: self.substs.type_at(parent_len + 2),\n             witness: self.substs.type_at(parent_len + 3),\n-            upvar_kinds: &self.substs[parent_len + 4..],\n+            tupled_upvars_ty: self.substs.type_at(parent_len + 4),\n         }\n     }\n \n+    /// Returns `true` only if enough of the synthetic types are known to\n+    /// allow using all of the methods on `GeneratorSubsts` without panicking.\n+    ///\n+    /// Used primarily by `ty::print::pretty` to be able to handle generator\n+    /// types that haven't had their synthetic types substituted in.\n+    pub fn is_valid(self) -> bool {\n+        self.substs.len() >= 5 && matches!(self.split().tupled_upvars_ty.kind, Tuple(_))\n+    }\n+\n     /// This describes the types that can be contained in a generator.\n     /// It will be a type variable initially and unified in the last stages of typeck of a body.\n     /// It contains a tuple of all the types that could end up on a generator frame.\n     /// The state transformation MIR pass may only produce layouts which mention types\n     /// in this tuple. Upvars are not counted here.\n-    pub fn witness(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n-        self.split(def_id, tcx).witness\n+    pub fn witness(self) -> Ty<'tcx> {\n+        self.split().witness\n     }\n \n     #[inline]\n-    pub fn upvar_tys(\n-        self,\n-        def_id: DefId,\n-        tcx: TyCtxt<'_>,\n-    ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n-        let SplitGeneratorSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n-        upvar_kinds.iter().map(|t| {\n+    pub fn upvar_tys(self) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n+        let upvars = match self.split().tupled_upvars_ty.kind {\n+            Tuple(upvars) => upvars,\n+            _ => bug!(\"upvars should be tupled\"),\n+        };\n+        upvars.iter().map(|t| {\n             if let GenericArgKind::Type(ty) = t.unpack() {\n                 ty\n             } else {\n@@ -490,18 +505,18 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     }\n \n     /// Returns the type representing the resume type of the generator.\n-    pub fn resume_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n-        self.split(def_id, tcx).resume_ty\n+    pub fn resume_ty(self) -> Ty<'tcx> {\n+        self.split().resume_ty\n     }\n \n     /// Returns the type representing the yield type of the generator.\n-    pub fn yield_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n-        self.split(def_id, tcx).yield_ty\n+    pub fn yield_ty(self) -> Ty<'tcx> {\n+        self.split().yield_ty\n     }\n \n     /// Returns the type representing the return type of the generator.\n-    pub fn return_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n-        self.split(def_id, tcx).return_ty\n+    pub fn return_ty(self) -> Ty<'tcx> {\n+        self.split().return_ty\n     }\n \n     /// Returns the \"generator signature\", which consists of its yield\n@@ -510,17 +525,17 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// N.B., some bits of the code prefers to see this wrapped in a\n     /// binder, but it never contains bound regions. Probably this\n     /// function should be removed.\n-    pub fn poly_sig(self, def_id: DefId, tcx: TyCtxt<'_>) -> PolyGenSig<'tcx> {\n-        ty::Binder::dummy(self.sig(def_id, tcx))\n+    pub fn poly_sig(self) -> PolyGenSig<'tcx> {\n+        ty::Binder::dummy(self.sig())\n     }\n \n     /// Returns the \"generator signature\", which consists of its resume, yield\n     /// and return types.\n-    pub fn sig(self, def_id: DefId, tcx: TyCtxt<'_>) -> GenSig<'tcx> {\n+    pub fn sig(self) -> GenSig<'tcx> {\n         ty::GenSig {\n-            resume_ty: self.resume_ty(def_id, tcx),\n-            yield_ty: self.yield_ty(def_id, tcx),\n-            return_ty: self.return_ty(def_id, tcx),\n+            resume_ty: self.resume_ty(),\n+            yield_ty: self.yield_ty(),\n+            return_ty: self.return_ty(),\n         }\n     }\n }\n@@ -612,8 +627,8 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// This is the types of the fields of a generator which are not stored in a\n     /// variant.\n     #[inline]\n-    pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = Ty<'tcx>> {\n-        self.upvar_tys(def_id, tcx)\n+    pub fn prefix_tys(self) -> impl Iterator<Item = Ty<'tcx>> {\n+        self.upvar_tys()\n     }\n }\n \n@@ -625,16 +640,16 @@ pub enum UpvarSubsts<'tcx> {\n \n impl<'tcx> UpvarSubsts<'tcx> {\n     #[inline]\n-    pub fn upvar_tys(\n-        self,\n-        def_id: DefId,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n-        let upvar_kinds = match self {\n-            UpvarSubsts::Closure(substs) => substs.as_closure().split(def_id, tcx).upvar_kinds,\n-            UpvarSubsts::Generator(substs) => substs.as_generator().split(def_id, tcx).upvar_kinds,\n+    pub fn upvar_tys(self) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n+        let tupled_upvars_ty = match self {\n+            UpvarSubsts::Closure(substs) => substs.as_closure().split().tupled_upvars_ty,\n+            UpvarSubsts::Generator(substs) => substs.as_generator().split().tupled_upvars_ty,\n+        };\n+        let upvars = match tupled_upvars_ty.kind {\n+            Tuple(upvars) => upvars,\n+            _ => bug!(\"upvars should be tupled\"),\n         };\n-        upvar_kinds.iter().map(|t| {\n+        upvars.iter().map(|t| {\n             if let GenericArgKind::Type(ty) = t.unpack() {\n                 ty\n             } else {"}, {"sha": "1f512f1dde7d663d848dc0d4df4465dddf43d08d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -502,7 +502,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> Option<ty::Binder<Ty<'tcx>>> {\n         let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n         let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n-        let closure_kind_ty = closure_substs.as_closure().kind_ty(closure_def_id, self);\n+        let closure_kind_ty = closure_substs.as_closure().kind_ty();\n         let closure_kind = closure_kind_ty.to_opt_closure_kind()?;\n         let env_ty = match closure_kind {\n             ty::ClosureKind::Fn => self.mk_imm_ref(self.mk_region(env_region), closure_ty),"}, {"sha": "8c0cb4668c6643a4d68cd40448e2f6c4e551ae0c", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -663,7 +663,7 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n         }\n         ty::Closure(def_id, substs) => {\n-            let upvar_tys: Vec<_> = substs.as_closure().upvar_tys(def_id, cx.tcx).collect();\n+            let upvar_tys: Vec<_> = substs.as_closure().upvar_tys().collect();\n             let containing_scope = get_namespace_for_item(cx, def_id);\n             prepare_tuple_metadata(\n                 cx,\n@@ -678,7 +678,7 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n         ty::Generator(def_id, substs, _) => {\n             let upvar_tys: Vec<_> = substs\n                 .as_generator()\n-                .prefix_tys(def_id, cx.tcx)\n+                .prefix_tys()\n                 .map(|t| cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t))\n                 .collect();\n             prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span, upvar_tys)"}, {"sha": "b76e5a51ff29c9be14c30aa4db42bdbf460980fb", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -277,8 +277,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         let ty_msg = match local_visitor.found_ty {\n-            Some(ty::TyS { kind: ty::Closure(def_id, substs), .. }) => {\n-                let fn_sig = substs.as_closure().sig(*def_id, self.tcx);\n+            Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n+                let fn_sig = substs.as_closure().sig();\n                 let args = closure_args(&fn_sig);\n                 let ret = fn_sig.output().skip_binder().to_string();\n                 format!(\" for the closure `fn({}) -> {}`\", args, ret)\n@@ -311,8 +311,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n \n         let suffix = match local_visitor.found_ty {\n-            Some(ty::TyS { kind: ty::Closure(def_id, substs), .. }) => {\n-                let fn_sig = substs.as_closure().sig(*def_id, self.tcx);\n+            Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n+                let fn_sig = substs.as_closure().sig();\n                 let ret = fn_sig.output().skip_binder().to_string();\n \n                 if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {"}, {"sha": "a9c2c7d4f938f7a04fb5f1e40c78646cfcf0fe82", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -1496,12 +1496,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Obtains the latest type of the given closure; this may be a\n     /// closure in the current function, in which case its\n     /// `ClosureKind` may not yet be known.\n-    pub fn closure_kind(\n-        &self,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Option<ty::ClosureKind> {\n-        let closure_kind_ty = closure_substs.as_closure().kind_ty(closure_def_id, self.tcx);\n+    pub fn closure_kind(&self, closure_substs: SubstsRef<'tcx>) -> Option<ty::ClosureKind> {\n+        let closure_kind_ty = closure_substs.as_closure().kind_ty();\n         let closure_kind_ty = self.shallow_resolve(closure_kind_ty);\n         closure_kind_ty.to_opt_closure_kind()\n     }"}, {"sha": "53bc70a5344ec40f19596d2db6f85cad57c20194", "filename": "src/librustc_infer/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -54,6 +54,7 @@ pub enum TypeVariableOriginKind {\n \n     /// One of the upvars or closure kind parameters in a `ClosureSubsts`\n     /// (before it has been determined).\n+    // FIXME(eddyb) distinguish upvar inference variables from the rest.\n     ClosureSynthetic,\n     SubstitutionPlaceholder,\n     AutoDeref,"}, {"sha": "8f5600cf44d4fc87798acf01f6b72239e540ea66", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -1320,7 +1320,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         self.encode_item_type(def_id);\n         if let ty::Closure(def_id, substs) = ty.kind {\n-            record!(self.per_def.fn_sig[def_id] <- substs.as_closure().sig(def_id, self.tcx));\n+            record!(self.per_def.fn_sig[def_id] <- substs.as_closure().sig());\n         }\n         self.encode_generics(def_id);\n         self.encode_optimized_mir(def_id);"}, {"sha": "27a861693970495f4a1061163d76d582786813e0", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -1682,10 +1682,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 // If a closure captured our `target` and then assigned\n                                 // into a place then we should annotate the closure in\n                                 // case it ends up being assigned into the return place.\n-                                annotated_closure = self.annotate_fn_sig(\n-                                    *def_id,\n-                                    substs.as_closure().sig(*def_id, self.infcx.tcx),\n-                                );\n+                                annotated_closure =\n+                                    self.annotate_fn_sig(*def_id, substs.as_closure().sig());\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: \\\n                                      annotated_closure={:?} assigned_from_local={:?} \\"}, {"sha": "edf915e65eb0b41e691c390ffde8fc5f81daf45f", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -333,7 +333,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             ty::Closure(def_id, closure_substs)\n                 if def_id == self.mir_def_id && upvar_field.is_some() =>\n             {\n-                let closure_kind_ty = closure_substs.as_closure().kind_ty(def_id, self.infcx.tcx);\n+                let closure_kind_ty = closure_substs.as_closure().kind_ty();\n                 let closure_kind = closure_kind_ty.to_opt_closure_kind();\n                 let capture_description = match closure_kind {\n                     Some(ty::ClosureKind::Fn) => \"captured variable in an `Fn` closure\","}, {"sha": "93800d2a2b38da96033feb53348ada9499080a0b", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -135,11 +135,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn is_closure_fn_mut(&self, fr: RegionVid) -> bool {\n         if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n             if let ty::BoundRegion::BrEnv = free_region.bound_region {\n-                if let DefiningTy::Closure(def_id, substs) =\n+                if let DefiningTy::Closure(_, substs) =\n                     self.regioncx.universal_regions().defining_ty\n                 {\n-                    return substs.as_closure().kind(def_id, self.infcx.tcx)\n-                        == ty::ClosureKind::FnMut;\n+                    return substs.as_closure().kind() == ty::ClosureKind::FnMut;\n                 }\n             }\n         }"}, {"sha": "164125a145b237b8655e2006d745a39e701a3c05", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -245,7 +245,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         .expect(\"non-local mir\");\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n-                    if let DefiningTy::Closure(def_id, substs) = def_ty {\n+                    if let DefiningTy::Closure(_, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n                             tcx.hir().expect_expr(mir_hir_id).kind\n                         {\n@@ -255,7 +255,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         };\n                         let region_name = self.synthesize_region_name();\n \n-                        let closure_kind_ty = substs.as_closure().kind_ty(def_id, tcx);\n+                        let closure_kind_ty = substs.as_closure().kind_ty();\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n                             Some(ty::ClosureKind::Fn) => {\n                                 \"closure implements `Fn`, so references to captured variables \\"}, {"sha": "c4933bedc227130c9e708733c1dadb5d4230b782", "filename": "src/librustc_mir/borrow_check/diagnostics/var_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -35,7 +35,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Search the upvars (if any) to find one that references fr. Return its index.\n     crate fn get_upvar_index_for_region(&self, tcx: TyCtxt<'tcx>, fr: RegionVid) -> Option<usize> {\n         let upvar_index =\n-            self.universal_regions().defining_ty.upvar_tys(tcx).position(|upvar_ty| {\n+            self.universal_regions().defining_ty.upvar_tys().position(|upvar_ty| {\n                 debug!(\"get_upvar_index_for_region: upvar_ty={:?}\", upvar_ty);\n                 tcx.any_free_region_meets(&upvar_ty, |r| {\n                     let r = r.to_region_vid();\n@@ -44,7 +44,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 })\n             })?;\n \n-        let upvar_ty = self.universal_regions().defining_ty.upvar_tys(tcx).nth(upvar_index);\n+        let upvar_ty = self.universal_regions().defining_ty.upvar_tys().nth(upvar_index);\n \n         debug!(\n             \"get_upvar_index_for_region: found {:?} in upvar {} which has type {:?}\","}, {"sha": "52fc48806fb12f27c29ea6b93bb04c06afc76c9d", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -757,21 +757,21 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() => {\n                     (&adt_def.variants[VariantIdx::new(0)], substs)\n                 }\n-                ty::Closure(def_id, substs) => {\n-                    return match substs.as_closure().upvar_tys(def_id, tcx).nth(field.index()) {\n+                ty::Closure(_, substs) => {\n+                    return match substs.as_closure().upvar_tys().nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.as_closure().upvar_tys(def_id, tcx).count(),\n+                            field_count: substs.as_closure().upvar_tys().count(),\n                         }),\n                     };\n                 }\n-                ty::Generator(def_id, substs, _) => {\n+                ty::Generator(_, substs, _) => {\n                     // Only prefix fields (upvars and current state) are\n                     // accessible without a variant index.\n-                    return match substs.as_generator().prefix_tys(def_id, tcx).nth(field.index()) {\n+                    return match substs.as_generator().prefix_tys().nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.as_generator().prefix_tys(def_id, tcx).count(),\n+                            field_count: substs.as_generator().prefix_tys().count(),\n                         }),\n                     };\n                 }\n@@ -1946,22 +1946,22 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n                 }\n             }\n-            AggregateKind::Closure(def_id, substs) => {\n-                match substs.as_closure().upvar_tys(def_id, tcx).nth(field_index) {\n+            AggregateKind::Closure(_, substs) => {\n+                match substs.as_closure().upvar_tys().nth(field_index) {\n                     Some(ty) => Ok(ty),\n                     None => Err(FieldAccessError::OutOfRange {\n-                        field_count: substs.as_closure().upvar_tys(def_id, tcx).count(),\n+                        field_count: substs.as_closure().upvar_tys().count(),\n                     }),\n                 }\n             }\n-            AggregateKind::Generator(def_id, substs, _) => {\n+            AggregateKind::Generator(_, substs, _) => {\n                 // It doesn't make sense to look at a field beyond the prefix;\n                 // these require a variant index, and are not initialized in\n                 // aggregate rvalues.\n-                match substs.as_generator().prefix_tys(def_id, tcx).nth(field_index) {\n+                match substs.as_generator().prefix_tys().nth(field_index) {\n                     Some(ty) => Ok(ty),\n                     None => Err(FieldAccessError::OutOfRange {\n-                        field_count: substs.as_generator().prefix_tys(def_id, tcx).count(),\n+                        field_count: substs.as_generator().prefix_tys().count(),\n                     }),\n                 }\n             }\n@@ -2085,7 +2085,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n                         let sig = match op.ty(*body, tcx).kind {\n-                            ty::Closure(def_id, substs) => substs.as_closure().sig(def_id, tcx),\n+                            ty::Closure(_, substs) => substs.as_closure().sig(),\n                             _ => bug!(),\n                         };\n                         let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig, *unsafety);"}, {"sha": "825931cf8922f398768e2455e108788623db607c", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -108,13 +108,11 @@ impl<'tcx> DefiningTy<'tcx> {\n     /// not a closure or generator, there are no upvars, and hence it\n     /// will be an empty list. The order of types in this list will\n     /// match up with the upvar order in the HIR, typesystem, and MIR.\n-    pub fn upvar_tys(self, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n+    pub fn upvar_tys(self) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         match self {\n-            DefiningTy::Closure(def_id, substs) => {\n-                Either::Left(substs.as_closure().upvar_tys(def_id, tcx))\n-            }\n-            DefiningTy::Generator(def_id, substs, _) => {\n-                Either::Right(Either::Left(substs.as_generator().upvar_tys(def_id, tcx)))\n+            DefiningTy::Closure(_, substs) => Either::Left(substs.as_closure().upvar_tys()),\n+            DefiningTy::Generator(_, substs, _) => {\n+                Either::Right(Either::Left(substs.as_generator().upvar_tys()))\n             }\n             DefiningTy::FnDef(..) | DefiningTy::Const(..) => {\n                 Either::Right(Either::Right(iter::empty()))\n@@ -470,9 +468,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         debug!(\"build: local regions  = {}..{}\", first_local_index, num_universals);\n \n         let yield_ty = match defining_ty {\n-            DefiningTy::Generator(def_id, substs, _) => {\n-                Some(substs.as_generator().yield_ty(def_id, self.infcx.tcx))\n-            }\n+            DefiningTy::Generator(_, substs, _) => Some(substs.as_generator().yield_ty()),\n             _ => None,\n         };\n \n@@ -580,7 +576,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 assert_eq!(self.mir_def_id, def_id);\n-                let closure_sig = substs.as_closure().sig(def_id, tcx);\n+                let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n                 let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n                 ty::Binder::fuse(closure_ty, inputs_and_output, |closure_ty, inputs_and_output| {\n@@ -604,8 +600,8 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n                 assert_eq!(self.mir_def_id, def_id);\n-                let resume_ty = substs.as_generator().resume_ty(def_id, tcx);\n-                let output = substs.as_generator().return_ty(def_id, tcx);\n+                let resume_ty = substs.as_generator().resume_ty();\n+                let output = substs.as_generator().return_ty();\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n                 let inputs_and_output =\n                     self.infcx.tcx.intern_type_list(&[generator_ty, resume_ty, output]);"}, {"sha": "eeb9d5f5a1fcce9bb84586db856e97497791ab62", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -341,8 +341,8 @@ fn build_clone_shim<'tcx>(\n             let len = len.eval_usize(tcx, param_env);\n             builder.array_shim(dest, src, ty, len)\n         }\n-        ty::Closure(def_id, substs) => {\n-            builder.tuple_like_shim(dest, src, substs.as_closure().upvar_tys(def_id, tcx))\n+        ty::Closure(_, substs) => {\n+            builder.tuple_like_shim(dest, src, substs.as_closure().upvar_tys())\n         }\n         ty::Tuple(..) => builder.tuple_like_shim(dest, src, self_ty.tuple_fields()),\n         _ => bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty),"}, {"sha": "349cda831053f851cf487f634183d0ac8fe8c099", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -1236,8 +1236,8 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             ty::Generator(_, substs, movability) => {\n                 let substs = substs.as_generator();\n                 (\n-                    substs.upvar_tys(def_id, tcx).collect(),\n-                    substs.witness(def_id, tcx),\n+                    substs.upvar_tys().collect(),\n+                    substs.witness(),\n                     substs.discr_ty(tcx),\n                     movability == hir::Movability::Movable,\n                 )"}, {"sha": "14895ddfbe44f3a4985fa537c1ef3b86770d75b6", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -798,8 +798,8 @@ where\n     fn open_drop(&mut self) -> BasicBlock {\n         let ty = self.place_ty(self.place);\n         match ty.kind {\n-            ty::Closure(def_id, substs) => {\n-                let tys: Vec<_> = substs.as_closure().upvar_tys(def_id, self.tcx()).collect();\n+            ty::Closure(_, substs) => {\n+                let tys: Vec<_> = substs.as_closure().upvar_tys().collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n             // Note that `elaborate_drops` only drops the upvars of a generator,\n@@ -808,8 +808,8 @@ where\n             // This should only happen for the self argument on the resume function.\n             // It effetively only contains upvars until the generator transformation runs.\n             // See librustc_body/transform/generator.rs for more details.\n-            ty::Generator(def_id, substs, _) => {\n-                let tys: Vec<_> = substs.as_generator().upvar_tys(def_id, self.tcx()).collect();\n+            ty::Generator(_, substs, _) => {\n+                let tys: Vec<_> = substs.as_generator().upvar_tys().collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n             ty::Tuple(..) => {"}, {"sha": "b2a5b5a2b8c6f577e2ccdbc4198f7230e0249479", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -140,9 +140,7 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n \n             let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n                 let gen_sig = match ty.kind {\n-                    ty::Generator(gen_def_id, gen_substs, ..) => {\n-                        gen_substs.as_generator().sig(gen_def_id, tcx)\n-                    }\n+                    ty::Generator(_, gen_substs, ..) => gen_substs.as_generator().sig(),\n                     _ => span_bug!(tcx.hir().span(id), \"generator w/o generator type: {:?}\", ty),\n                 };\n                 (Some(gen_sig.yield_ty), gen_sig.return_ty)\n@@ -848,12 +846,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 closure_env_projs.push(ProjectionElem::Deref);\n                 closure_ty = ty;\n             }\n-            let (def_id, upvar_substs) = match closure_ty.kind {\n-                ty::Closure(def_id, substs) => (def_id, ty::UpvarSubsts::Closure(substs)),\n-                ty::Generator(def_id, substs, _) => (def_id, ty::UpvarSubsts::Generator(substs)),\n+            let upvar_substs = match closure_ty.kind {\n+                ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n+                ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n                 _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty),\n             };\n-            let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n+            let upvar_tys = upvar_substs.upvar_tys();\n             let upvars_with_tys = upvars.iter().zip(upvar_tys);\n             self.upvar_mutbls = upvars_with_tys\n                 .enumerate()"}, {"sha": "148836e35c7e64d31ab542ef56b990aff5c417ab", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -387,7 +387,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 .upvars(def_id)\n                 .iter()\n                 .flat_map(|upvars| upvars.iter())\n-                .zip(substs.upvar_tys(def_id, cx.tcx))\n+                .zip(substs.upvar_tys())\n                 .map(|((&var_hir_id, _), ty)| capture_upvar(cx, expr, var_hir_id, ty))\n                 .collect();\n             ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n@@ -830,7 +830,7 @@ fn convert_var<'tcx>(\n             let region = cx.tcx.mk_region(region);\n \n             let self_expr = if let ty::Closure(_, closure_substs) = closure_ty.kind {\n-                match cx.infcx.closure_kind(closure_def_id, closure_substs).unwrap() {\n+                match cx.infcx.closure_kind(closure_substs).unwrap() {\n                     ty::ClosureKind::Fn => {\n                         let ref_closure_ty = cx.tcx.mk_ref(\n                             region,"}, {"sha": "9cd97c34f3ba4d8abc41b8e1fbd784294bdcb0d6", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -423,7 +423,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n             for required_region in required_region_bounds {\n                 concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n-                    tcx: self.tcx,\n                     op: |r| self.sub_regions(infer::CallReturn(span), required_region, r),\n                 });\n             }\n@@ -504,7 +503,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n-            tcx: self.tcx,\n             op: |r| self.sub_regions(infer::CallReturn(span), least_region, r),\n         });\n     }\n@@ -541,7 +539,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         );\n \n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n-            tcx: self.tcx,\n             op: |r| {\n                 self.member_constraint(\n                     opaque_type_def_id,\n@@ -682,15 +679,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n //\n // We ignore any type parameters because impl trait values are assumed to\n // capture all the in-scope type parameters.\n-struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n-where\n-    OP: FnMut(ty::Region<'tcx>),\n-{\n-    tcx: TyCtxt<'tcx>,\n+struct ConstrainOpaqueTypeRegionVisitor<OP> {\n     op: OP,\n }\n \n-impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n+impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<OP>\n where\n     OP: FnMut(ty::Region<'tcx>),\n {\n@@ -717,27 +710,27 @@ where\n         }\n \n         match ty.kind {\n-            ty::Closure(def_id, ref substs) => {\n+            ty::Closure(_, ref substs) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n \n-                for upvar_ty in substs.as_closure().upvar_tys(def_id, self.tcx) {\n+                for upvar_ty in substs.as_closure().upvar_tys() {\n                     upvar_ty.visit_with(self);\n                 }\n \n-                substs.as_closure().sig_as_fn_ptr_ty(def_id, self.tcx).visit_with(self);\n+                substs.as_closure().sig_as_fn_ptr_ty().visit_with(self);\n             }\n \n-            ty::Generator(def_id, ref substs, _) => {\n+            ty::Generator(_, ref substs, _) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n                 // Also skip the witness type, because that has no free regions.\n \n-                for upvar_ty in substs.as_generator().upvar_tys(def_id, self.tcx) {\n+                for upvar_ty in substs.as_generator().upvar_tys() {\n                     upvar_ty.visit_with(self);\n                 }\n \n-                substs.as_generator().return_ty(def_id, self.tcx).visit_with(self);\n-                substs.as_generator().yield_ty(def_id, self.tcx).visit_with(self);\n-                substs.as_generator().resume_ty(def_id, self.tcx).visit_with(self);\n+                substs.as_generator().return_ty().visit_with(self);\n+                substs.as_generator().yield_ty().visit_with(self);\n+                substs.as_generator().resume_ty().visit_with(self);\n             }\n             _ => {\n                 ty.super_visit_with(self);"}, {"sha": "0c12b0122aa90cf6f11ba2ccb909fa7814447b86", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -481,7 +481,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n+                        let found_kind = self.closure_kind(closure_substs).unwrap();\n                         let closure_span = self\n                             .tcx\n                             .sess"}, {"sha": "cb556bf1d5dfae345c39a77ed6a7eb2da3384611", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -367,9 +367,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) {\n         let self_ty = trait_ref.self_ty();\n         let (def_id, output_ty, callable) = match self_ty.kind {\n-            ty::Closure(def_id, substs) => {\n-                (def_id, substs.as_closure().sig(def_id, self.tcx).output(), \"closure\")\n-            }\n+            ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig().output(), \"closure\"),\n             ty::FnDef(def_id, _) => (def_id, self_ty.fn_sig(self.tcx).output(), \"function\"),\n             _ => return,\n         };"}, {"sha": "5f03ee686543d2f8fc920d764c5e2c5a2428473c", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -445,8 +445,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                match self.selcx.infcx().closure_kind(closure_def_id, closure_substs) {\n+            ty::Predicate::ClosureKind(_, closure_substs, kind) => {\n+                match self.selcx.infcx().closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n                             ProcessResult::Changed(vec![])"}, {"sha": "26aaf12d359d98cb0570819ba5f6ff2e89db8725", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -1237,7 +1237,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let gen_sig = vtable.substs.as_generator().poly_sig(vtable.generator_def_id, selcx.tcx());\n+    let gen_sig = vtable.substs.as_generator().poly_sig();\n     let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,\n@@ -1310,8 +1310,7 @@ fn confirm_closure_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let tcx = selcx.tcx();\n-    let closure_sig = vtable.substs.as_closure().sig(vtable.closure_def_id, tcx);\n+    let closure_sig = vtable.substs.as_closure().sig();\n     let Normalized { value: closure_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,"}, {"sha": "03c6cf35e8881b653cba96ad6c22f52a103102b2", "filename": "src/librustc_trait_selection/traits/query/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -109,8 +109,8 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n         ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n-        ty::Closure(def_id, ref substs) => {\n-            substs.as_closure().upvar_tys(def_id, tcx).all(|t| trivial_dropck_outlives(tcx, t))\n+        ty::Closure(_, ref substs) => {\n+            substs.as_closure().upvar_tys().all(|t| trivial_dropck_outlives(tcx, t))\n         }\n \n         ty::Adt(def, _) => {"}, {"sha": "551e813a5ce426f89371db007992f062ea5e57c8", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -478,8 +478,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                match self.infcx.closure_kind(closure_def_id, closure_substs) {\n+            ty::Predicate::ClosureKind(_, closure_substs, kind) => {\n+                match self.infcx.closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n                             Ok(EvaluatedToOk)\n@@ -1600,9 +1600,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         match obligation.self_ty().skip_binder().kind {\n-            ty::Closure(closure_def_id, closure_substs) => {\n+            ty::Closure(_, closure_substs) => {\n                 debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\", kind, obligation);\n-                match self.infcx.closure_kind(closure_def_id, closure_substs) {\n+                match self.infcx.closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n                         if closure_kind.extends(kind) {\n@@ -2234,9 +2234,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Where(ty::Binder::bind(tys.iter().map(|k| k.expect_ty()).collect()))\n             }\n \n-            ty::Closure(def_id, substs) => {\n+            ty::Closure(_, substs) => {\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(substs.as_closure().upvar_tys(def_id, self.tcx()).collect()))\n+                Where(ty::Binder::bind(substs.as_closure().upvar_tys().collect()))\n             }\n \n             ty::Adt(..) | ty::Projection(..) | ty::Param(..) | ty::Opaque(..) => {\n@@ -2313,17 +2313,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 tys.iter().map(|k| k.expect_ty()).collect()\n             }\n \n-            ty::Closure(def_id, ref substs) => {\n-                substs.as_closure().upvar_tys(def_id, self.tcx()).collect()\n-            }\n+            ty::Closure(_, ref substs) => substs.as_closure().upvar_tys().collect(),\n \n-            ty::Generator(def_id, ref substs, _) => {\n-                let witness = substs.as_generator().witness(def_id, self.tcx());\n-                substs\n-                    .as_generator()\n-                    .upvar_tys(def_id, self.tcx())\n-                    .chain(iter::once(witness))\n-                    .collect()\n+            ty::Generator(_, ref substs, _) => {\n+                let witness = substs.as_generator().witness();\n+                substs.as_generator().upvar_tys().chain(iter::once(witness)).collect()\n             }\n \n             ty::GeneratorWitness(types) => {\n@@ -2811,7 +2805,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"confirm_generator_candidate({:?},{:?},{:?})\", obligation, generator_def_id, substs);\n \n-        let trait_ref = self.generator_trait_ref_unnormalized(obligation, generator_def_id, substs);\n+        let trait_ref = self.generator_trait_ref_unnormalized(obligation, substs);\n         let Normalized { value: trait_ref, mut obligations } = normalize_with_depth(\n             self,\n             obligation.param_env,\n@@ -2856,7 +2850,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n         };\n \n-        let trait_ref = self.closure_trait_ref_unnormalized(obligation, closure_def_id, substs);\n+        let trait_ref = self.closure_trait_ref_unnormalized(obligation, substs);\n         let Normalized { value: trait_ref, mut obligations } = normalize_with_depth(\n             self,\n             obligation.param_env,\n@@ -3342,14 +3336,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn closure_trait_ref_unnormalized(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        closure_def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> ty::PolyTraitRef<'tcx> {\n-        debug!(\n-            \"closure_trait_ref_unnormalized(obligation={:?}, closure_def_id={:?}, substs={:?})\",\n-            obligation, closure_def_id, substs,\n-        );\n-        let closure_sig = substs.as_closure().sig(closure_def_id, self.tcx());\n+        debug!(\"closure_trait_ref_unnormalized(obligation={:?}, substs={:?})\", obligation, substs);\n+        let closure_sig = substs.as_closure().sig();\n \n         debug!(\"closure_trait_ref_unnormalized: closure_sig = {:?}\", closure_sig);\n \n@@ -3371,10 +3361,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn generator_trait_ref_unnormalized(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        closure_def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> ty::PolyTraitRef<'tcx> {\n-        let gen_sig = substs.as_generator().poly_sig(closure_def_id, self.tcx());\n+        let gen_sig = substs.as_generator().poly_sig();\n \n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an generator type and hence is"}, {"sha": "ac2da006df35d746480e8b21ebc393322e4749e5", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -474,7 +474,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // generators don't take arguments.\n                 }\n \n-                ty::Closure(def_id, substs) => {\n+                ty::Closure(_, substs) => {\n                     // Only check the upvar types for WF, not the rest\n                     // of the types within. This is needed because we\n                     // capture the signature and it may not be WF\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // anyway, except via auto trait matching (which\n                     // only inspects the upvar types).\n                     subtys.skip_current_subtree(); // subtree handled by compute_projection\n-                    for upvar_ty in substs.as_closure().upvar_tys(def_id, self.infcx.tcx) {\n+                    for upvar_ty in substs.as_closure().upvar_tys() {\n                         self.compute(upvar_ty);\n                     }\n                 }"}, {"sha": "7068723f534e7f5551248de1fe607e071393c3e5", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -207,13 +207,13 @@ fn dtorck_constraint_for_ty<'tcx>(\n             }\n         }\n \n-        ty::Closure(def_id, substs) => {\n-            for ty in substs.as_closure().upvar_tys(def_id, tcx) {\n+        ty::Closure(_, substs) => {\n+            for ty in substs.as_closure().upvar_tys() {\n                 dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n             }\n         }\n \n-        ty::Generator(def_id, substs, _movability) => {\n+        ty::Generator(_, substs, _movability) => {\n             // rust-lang/rust#49918: types can be constructed, stored\n             // in the interior, and sit idle when generator yields\n             // (and is subsequently dropped).\n@@ -240,10 +240,10 @@ fn dtorck_constraint_for_ty<'tcx>(\n             constraints.outlives.extend(\n                 substs\n                     .as_generator()\n-                    .upvar_tys(def_id, tcx)\n+                    .upvar_tys()\n                     .map(|t| -> ty::subst::GenericArg<'tcx> { t.into() }),\n             );\n-            constraints.outlives.push(substs.as_generator().resume_ty(def_id, tcx).into());\n+            constraints.outlives.push(substs.as_generator().resume_ty().into());\n         }\n \n         ty::Adt(def, substs) => {"}, {"sha": "37af8168f87d9d3f2529cdee6372e0ee113efb4d", "filename": "src/librustc_ty/needs_drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_ty%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_ty%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fneeds_drop.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -93,8 +93,8 @@ where\n                 match component.kind {\n                     _ if component.is_copy_modulo_regions(tcx, self.param_env, DUMMY_SP) => (),\n \n-                    ty::Closure(def_id, substs) => {\n-                        for upvar_ty in substs.as_closure().upvar_tys(def_id, tcx) {\n+                    ty::Closure(_, substs) => {\n+                        for upvar_ty in substs.as_closure().upvar_tys() {\n                             queue_type(self, upvar_ty);\n                         }\n                     }"}, {"sha": "ec796043d3ac85c205fd7694b13f763f5a4d8453", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -104,8 +104,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Check whether this is a call to a closure where we\n                 // haven't yet decided on whether the closure is fn vs\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n-                if self.closure_kind(def_id, substs).is_none() {\n-                    let closure_sig = substs.as_closure().sig(def_id, self.tcx);\n+                if self.closure_kind(substs).is_none() {\n+                    let closure_sig = substs.as_closure().sig();\n                     let closure_sig = self\n                         .replace_bound_vars_with_fresh_vars(\n                             call_expr.span,\n@@ -122,7 +122,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             adjusted_ty,\n                             adjustments,\n                             fn_sig: closure_sig,\n-                            closure_def_id: def_id,\n                             closure_substs: substs,\n                         },\n                     );\n@@ -459,7 +458,6 @@ pub struct DeferredCallResolution<'tcx> {\n     adjusted_ty: Ty<'tcx>,\n     adjustments: Vec<Adjustment<'tcx>>,\n     fn_sig: ty::FnSig<'tcx>,\n-    closure_def_id: DefId,\n     closure_substs: SubstsRef<'tcx>,\n }\n \n@@ -469,7 +467,7 @@ impl<'a, 'tcx> DeferredCallResolution<'tcx> {\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n-        assert!(fcx.closure_kind(self.closure_def_id, self.closure_substs).is_some());\n+        assert!(fcx.closure_kind(self.closure_substs).is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n         match fcx.try_overloaded_call_traits(self.call_expr, self.adjusted_ty, None) {"}, {"sha": "ded42482973d0222beba3ae4737f1cd37671847a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -82,40 +82,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // inference phase (`upvar.rs`).\n         let base_substs =\n             InternalSubsts::identity_for_item(self.tcx, self.tcx.closure_base_def_id(expr_def_id));\n+        // HACK(eddyb) this hardcodes indices into substs but it should rely on\n+        // `ClosureSubsts` and `GeneratorSubsts` providing constructors, instead.\n+        // That would also remove the need for most of the inference variables,\n+        // as they immediately unified with the actual type below, including\n+        // the `InferCtxt::closure_sig` and `ClosureSubsts::sig_ty` methods.\n+        let tupled_upvars_idx = base_substs.len() + if generator_types.is_some() { 4 } else { 2 };\n         let substs = base_substs.extend_to(self.tcx, expr_def_id, |param, _| match param.kind {\n             GenericParamDefKind::Lifetime => span_bug!(expr.span, \"closure has lifetime param\"),\n-            GenericParamDefKind::Type { .. } => self\n-                .infcx\n-                .next_ty_var(TypeVariableOrigin {\n+            GenericParamDefKind::Type { .. } => if param.index as usize == tupled_upvars_idx {\n+                self.tcx.mk_tup(self.tcx.upvars(expr_def_id).iter().flat_map(|upvars| {\n+                    upvars.iter().map(|(&var_hir_id, _)| {\n+                        self.infcx.next_ty_var(TypeVariableOrigin {\n+                            // FIXME(eddyb) distinguish upvar inference variables from the rest.\n+                            kind: TypeVariableOriginKind::ClosureSynthetic,\n+                            span: self.tcx.hir().span(var_hir_id),\n+                        })\n+                    })\n+                }))\n+            } else {\n+                self.infcx.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::ClosureSynthetic,\n                     span: expr.span,\n                 })\n-                .into(),\n+            }\n+            .into(),\n             GenericParamDefKind::Const => span_bug!(expr.span, \"closure has const param\"),\n         });\n         if let Some(GeneratorTypes { resume_ty, yield_ty, interior, movability }) = generator_types\n         {\n             let generator_substs = substs.as_generator();\n-            self.demand_eqtype(\n-                expr.span,\n-                resume_ty,\n-                generator_substs.resume_ty(expr_def_id, self.tcx),\n-            );\n-            self.demand_eqtype(\n-                expr.span,\n-                yield_ty,\n-                generator_substs.yield_ty(expr_def_id, self.tcx),\n-            );\n-            self.demand_eqtype(\n-                expr.span,\n-                liberated_sig.output(),\n-                generator_substs.return_ty(expr_def_id, self.tcx),\n-            );\n-            self.demand_eqtype(\n-                expr.span,\n-                interior,\n-                generator_substs.witness(expr_def_id, self.tcx),\n-            );\n+            self.demand_eqtype(expr.span, resume_ty, generator_substs.resume_ty());\n+            self.demand_eqtype(expr.span, yield_ty, generator_substs.yield_ty());\n+            self.demand_eqtype(expr.span, liberated_sig.output(), generator_substs.return_ty());\n+            self.demand_eqtype(expr.span, interior, generator_substs.witness());\n \n             // HACK(eddyb) this forces the types equated above into `substs` but\n             // it should rely on `GeneratorSubsts` providing a constructor, instead.\n@@ -142,18 +142,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         let sig_fn_ptr_ty = self.tcx.mk_fn_ptr(sig);\n-        self.demand_eqtype(\n-            expr.span,\n-            sig_fn_ptr_ty,\n-            substs.as_closure().sig_as_fn_ptr_ty(expr_def_id, self.tcx),\n-        );\n+        self.demand_eqtype(expr.span, sig_fn_ptr_ty, substs.as_closure().sig_as_fn_ptr_ty());\n \n         if let Some(kind) = opt_kind {\n-            self.demand_eqtype(\n-                expr.span,\n-                kind.to_ty(self.tcx),\n-                substs.as_closure().kind_ty(expr_def_id, self.tcx),\n-            );\n+            self.demand_eqtype(expr.span, kind.to_ty(self.tcx), substs.as_closure().kind_ty());\n         }\n \n         // HACK(eddyb) this forces the types equated above into `substs` but"}, {"sha": "33fc18b4b6e689ed5aa36b804ed4007318df67c5", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -62,7 +62,6 @@ use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TypeAndMut};\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n use rustc_session::parse::feature_err;\n@@ -236,11 +235,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 // unsafe qualifier.\n                 self.coerce_from_fn_pointer(a, a_f, b)\n             }\n-            ty::Closure(def_id_a, substs_a) => {\n+            ty::Closure(_, substs_a) => {\n                 // Non-capturing closures are coercible to\n                 // function pointers or unsafe function pointers.\n                 // It cannot convert closures that require unsafe.\n-                self.coerce_closure_to_fn(a, def_id_a, substs_a, b)\n+                self.coerce_closure_to_fn(a, substs_a, b)\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n@@ -732,7 +731,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn coerce_closure_to_fn(\n         &self,\n         a: Ty<'tcx>,\n-        def_id_a: DefId,\n         substs_a: SubstsRef<'tcx>,\n         b: Ty<'tcx>,\n     ) -> CoerceResult<'tcx> {\n@@ -743,14 +741,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let b = self.shallow_resolve(b);\n \n         match b.kind {\n-            ty::FnPtr(fn_ty) if self.tcx.upvars(def_id_a).map_or(true, |v| v.is_empty()) => {\n+            ty::FnPtr(fn_ty) if substs_a.as_closure().upvar_tys().next().is_none() => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n                 //     `fn(arg0,arg1,...) -> _`\n                 // or\n                 //     `unsafe fn(arg0,arg1,...) -> _`\n-                let closure_sig = substs_a.as_closure().sig(def_id_a, self.tcx);\n+                let closure_sig = substs_a.as_closure().sig();\n                 let unsafety = fn_ty.unsafety();\n                 let pointer_ty = self.tcx.coerce_closure_fn_ty(closure_sig, unsafety);\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\", a, b, pointer_ty);"}, {"sha": "7e50512a3478526f8d0d9d227c8255796b58679d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -4837,7 +4837,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hir = self.tcx.hir();\n         let (def_id, sig) = match found.kind {\n             ty::FnDef(def_id, _) => (def_id, found.fn_sig(self.tcx)),\n-            ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig(def_id, self.tcx)),\n+            ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig()),\n             _ => return false,\n         };\n "}, {"sha": "a1345895689e0e5c50dc01e2a08baa29eb50e921", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -1228,8 +1228,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n         // A closure capture can't be borrowed for longer than the\n         // reference to the closure.\n-        if let ty::Closure(closure_def_id, substs) = ty.kind {\n-            match self.infcx.closure_kind(closure_def_id, substs) {\n+        if let ty::Closure(_, substs) = ty.kind {\n+            match self.infcx.closure_kind(substs) {\n                 Some(ty::ClosureKind::Fn) | Some(ty::ClosureKind::FnMut) => {\n                     // Region of environment pointer\n                     let env_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {"}, {"sha": "ff4e2cdab78d79d080632cbf91a3d34ebe711bd3", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let infer_kind = if let UpvarSubsts::Closure(closure_substs) = substs {\n-            self.closure_kind(closure_def_id, closure_substs).is_none().then_some(closure_substs)\n+            self.closure_kind(closure_substs).is_none().then_some(closure_substs)\n         } else {\n             None\n         };\n@@ -168,7 +168,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Unify the (as yet unbound) type variable in the closure\n             // substs with the kind we inferred.\n             let inferred_kind = delegate.current_closure_kind;\n-            let closure_kind_ty = closure_substs.as_closure().kind_ty(closure_def_id, self.tcx);\n+            let closure_kind_ty = closure_substs.as_closure().kind_ty();\n             self.demand_eqtype(span, inferred_kind.to_ty(self.tcx), closure_kind_ty);\n \n             // If we have an origin, store it.\n@@ -197,9 +197,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"analyze_closure: id={:?} substs={:?} final_upvar_tys={:?}\",\n             closure_hir_id, substs, final_upvar_tys\n         );\n-        for (upvar_ty, final_upvar_ty) in\n-            substs.upvar_tys(closure_def_id, self.tcx).zip(final_upvar_tys)\n-        {\n+        for (upvar_ty, final_upvar_ty) in substs.upvar_tys().zip(final_upvar_tys) {\n             self.demand_suptype(span, upvar_ty, final_upvar_ty);\n         }\n "}, {"sha": "3a545db9fe853e771d5b3744de6b14b6d558cf30", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -1354,9 +1354,9 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     // and we don't do that for closures.\n     if let Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(.., gen), .. }) = node {\n         let dummy_args = if gen.is_some() {\n-            &[\"<resume_ty>\", \"<yield_ty>\", \"<return_ty>\", \"<witness>\"][..]\n+            &[\"<resume_ty>\", \"<yield_ty>\", \"<return_ty>\", \"<witness>\", \"<upvars>\"][..]\n         } else {\n-            &[\"<closure_kind>\", \"<closure_signature>\"][..]\n+            &[\"<closure_kind>\", \"<closure_signature>\", \"<upvars>\"][..]\n         };\n \n         params.extend(dummy_args.iter().enumerate().map(|(i, &arg)| ty::GenericParamDef {\n@@ -1370,22 +1370,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                 synthetic: None,\n             },\n         }));\n-\n-        if let Some(upvars) = tcx.upvars(def_id) {\n-            params.extend(upvars.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n-                ty::GenericParamDef {\n-                    index: type_start + i,\n-                    name: Symbol::intern(\"<upvar>\"),\n-                    def_id,\n-                    pure_wrt_drop: false,\n-                    kind: ty::GenericParamDefKind::Type {\n-                        has_default: false,\n-                        object_lifetime_default: rl::Set1::Empty,\n-                        synthetic: None,\n-                    },\n-                }\n-            }));\n-        }\n     }\n \n     let param_def_id_to_index = params.iter().map(|param| (param.def_id, param.index)).collect();"}, {"sha": "41965d6b35536bda7e47306563a299febf18a068", "filename": "src/test/ui/issues/issue-22638.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -8,7 +8,7 @@ LL | |         a.matches(f)\n LL | |     }\n    | |_____^\n    |\n-   = note: consider adding a `#![type_length_limit=\"26214380\"]` attribute to your crate\n+   = note: consider adding a `#![type_length_limit=\"30408681\"]` attribute to your crate\n \n error: aborting due to previous error\n "}, {"sha": "f0d169f419c73b45f13264eaf1da209123497b4c", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |         let mut closure = expect_sig(|p, y| *p = y);\n    = note: defining type: test::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's, 't0> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed('r)) mut &ReLateBound(DebruijnIndex(0), BrNamed('s)) i32, &ReLateBound(DebruijnIndex(0), BrNamed('t0)) i32)),\n+               (),\n            ]\n \n error: lifetime may not live long enough"}, {"sha": "e251e69997eba8e349f5b8cb15050edf58d9e9a7", "filename": "src/test/ui/nll/closure-requirements/escape-argument.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |         let mut closure = expect_sig(|p, y| *p = y);\n    = note: defining type: test::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed('r)) mut &ReLateBound(DebruijnIndex(0), BrNamed('s)) i32, &ReLateBound(DebruijnIndex(0), BrNamed('s)) i32)),\n+               (),\n            ]\n \n note: no external requirements"}, {"sha": "36257700bef0c5a1ec478d7c4a7b73dfbc5c3284", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,8 +7,7 @@ LL |             let mut closure1 = || p = &y;\n    = note: defining type: test::{{closure}}#0::{{closure}}#0 with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               &'_#1r i32,\n-               &'_#2r mut &'_#3r i32,\n+               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n    = note: where '_#1r: '_#3r\n@@ -26,8 +25,7 @@ LL | |         };\n    = note: defining type: test::{{closure}}#0 with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               &'_#1r i32,\n-               &'_#2r mut &'_#3r i32,\n+               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n    = note: where '_#1r: '_#3r"}, {"sha": "d1c64fac3c1e3dabe3d6bde8661e7b9bafe69344", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,8 +7,7 @@ LL |         let mut closure = || p = &y;\n    = note: defining type: test::{{closure}}#0 with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               &'_#1r i32,\n-               &'_#2r mut &'_#3r i32,\n+               (&'_#1r i32, &'_#2r mut &'_#3r i32),\n            ]\n    = note: number of external vids: 4\n    = note: where '_#1r: '_#3r"}, {"sha": "549ebb78d78876bf06ec0b4eadcacfb295e069db", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -11,6 +11,7 @@ LL | |         },\n    = note: defining type: supply::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BrNamed('r)) u32>, std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BrNamed('r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) &'_#3r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>)),\n+               (),\n            ]\n    = note: late-bound region is '_#4r\n    = note: late-bound region is '_#5r"}, {"sha": "346b4af6caac8eace8ccdaed08f5a8a633458936", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -12,6 +12,7 @@ LL | |     });\n    = note: defining type: supply::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed('r)) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t0)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('t1)) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t2)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t3)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('t1)) u32>)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n    = note: late-bound region is '_#4r"}, {"sha": "3b1769ed3a2eeaaf85b8cb151f3ee7e79e5c97d1", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -11,6 +11,7 @@ LL | |     })\n    = note: defining type: case1::{{closure}}#0 with closure substs [\n                i32,\n                for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('r)) u32>)),\n+               (),\n            ]\n \n error[E0521]: borrowed data escapes outside of closure\n@@ -49,6 +50,7 @@ LL | |     })\n    = note: defining type: case2::{{closure}}#0 with closure substs [\n                i32,\n                for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('r)) u32>)),\n+               (),\n            ]\n    = note: number of external vids: 2\n    = note: where '_#1r: '_#0r"}, {"sha": "b167dafff013687de3f3162adb3f603000aa78a2", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -13,6 +13,7 @@ LL | |     });\n    = note: defining type: supply::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed('r)) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t0)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t1)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('t2)) u32>)),\n+               (),\n            ]\n    = note: late-bound region is '_#2r\n    = note: late-bound region is '_#3r"}, {"sha": "91aacc3dff60f5a01f68c7aff9687e61c5bfe083", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -13,6 +13,7 @@ LL | |     });\n    = note: defining type: supply::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed('r)) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t0)) std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BrNamed('t1)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t2)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t3)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('t1)) u32>)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n    = note: late-bound region is '_#4r"}, {"sha": "ae447708621ed4132ab31ba706b905b1b3730731", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -12,6 +12,7 @@ LL | |     });\n    = note: defining type: test::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BrNamed('r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n    = note: late-bound region is '_#4r"}, {"sha": "256446a6e8d8dde68c0835f66144ed9ae658f18e", "filename": "src/test/ui/nll/closure-requirements/propagate-despite-same-free-region.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -11,6 +11,7 @@ LL | |         },\n    = note: defining type: supply::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BrNamed('r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n    = note: number of external vids: 4"}, {"sha": "5c156d0d1e3781871adbb409c12680bbd79b9bd7", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -12,6 +12,7 @@ LL | |     });\n    = note: defining type: supply::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed('r)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t0)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('t1)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t2)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>)),\n+               (),\n            ]\n    = note: late-bound region is '_#2r\n    = note: late-bound region is '_#3r"}, {"sha": "46e3f2e75f49efc97599e316f6399bf86864d0e2", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -12,6 +12,7 @@ LL | |     });\n    = note: defining type: supply::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed('r)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t0)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('t1)) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t2)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('s)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed('t3)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed('t1)) u32>)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n    = note: late-bound region is '_#4r"}, {"sha": "ef941472894b2afffb51cfd331500a3c960cf7d1", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -14,6 +14,7 @@ LL | |     });\n    = note: defining type: supply::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((T,)),\n+               (),\n            ]\n    = note: number of external vids: 2\n    = note: where T: '_#1r"}, {"sha": "2a382030f935cfa60b2c75268c84079d1a688faa", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |     expect_sig(|a, b| b); // ought to return `a`\n    = note: defining type: test::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed('r)) i32, &ReLateBound(DebruijnIndex(0), BrNamed('s)) i32)) -> &ReLateBound(DebruijnIndex(0), BrNamed('r)) i32,\n+               (),\n            ]\n \n error: lifetime may not live long enough"}, {"sha": "38e59ae3e26ba2f1a37c07d7a04637b9977c4e20", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |     with_signature(x, |mut y| Box::new(y.next()))\n    = note: defining type: no_region::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<(dyn Anything + '_#2r)>,\n+               (),\n            ]\n    = note: number of external vids: 3\n    = note: where <T as std::iter::Iterator>::Item: '_#2r\n@@ -42,6 +43,7 @@ LL |     with_signature(x, |mut y| Box::new(y.next()))\n    = note: defining type: correct_region::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<(dyn Anything + '_#2r)>,\n+               (),\n            ]\n    = note: number of external vids: 3\n    = note: where <T as std::iter::Iterator>::Item: '_#2r\n@@ -68,6 +70,7 @@ LL |     with_signature(x, |mut y| Box::new(y.next()))\n    = note: defining type: wrong_region::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<(dyn Anything + '_#3r)>,\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where <T as std::iter::Iterator>::Item: '_#3r\n@@ -103,6 +106,7 @@ LL |     with_signature(x, |mut y| Box::new(y.next()))\n    = note: defining type: outlives_region::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<(dyn Anything + '_#3r)>,\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where <T as std::iter::Iterator>::Item: '_#3r"}, {"sha": "e8aba9d8d4de6fda04d19810848ab409ceb7b6cd", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: no_relationships_late::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n    = note: number of external vids: 4\n@@ -57,6 +58,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: no_relationships_early::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where T: '_#3r\n@@ -106,6 +108,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: projection_outlives::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where <T as Anything<ReClosureBound('_#2r)>>::AssocType: '_#3r\n@@ -133,6 +136,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: elements_outlive::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where T: '_#3r"}, {"sha": "58ea527d9598024385592b11b9fad2e3dcb4a058", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: no_relationships_late::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n    = note: number of external vids: 4\n@@ -48,6 +49,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: no_relationships_early::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where '_#2r: '_#3r\n@@ -88,6 +90,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: projection_outlives::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where <T as Anything<ReClosureBound('_#2r)>>::AssocType: '_#3r\n@@ -115,6 +118,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: elements_outlive::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where '_#2r: '_#3r\n@@ -142,6 +146,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: one_region::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#2r"}, {"sha": "3d9a01fec101d4f0d6f182e0cf6ac92e8c8d2e6a", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-static-closure.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: no_relationships_late::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n \n@@ -32,6 +33,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: no_relationships_early::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n \n note: no external requirements\n@@ -57,6 +59,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: projection_outlives::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n \n note: no external requirements\n@@ -82,6 +85,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: elements_outlive::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n \n note: no external requirements\n@@ -107,6 +111,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: one_region::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T)),\n+               (),\n            ]\n \n note: no external requirements"}, {"sha": "7c82b147394028bc1c9deea0c6fa11d03386f31c", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: no_relationships_late::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n    = note: late-bound region is '_#4r\n    = note: number of external vids: 5\n@@ -43,6 +44,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: no_relationships_early::<'_#1r, '_#2r, '_#3r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 5\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n@@ -78,6 +80,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: projection_outlives::<'_#1r, '_#2r, '_#3r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 5\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n@@ -105,6 +108,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: elements_outlive1::<'_#1r, '_#2r, '_#3r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 5\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n@@ -132,6 +136,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: elements_outlive2::<'_#1r, '_#2r, '_#3r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 5\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n@@ -159,6 +164,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: two_regions::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n    = note: number of external vids: 4\n@@ -200,6 +206,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: two_regions_outlive::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n@@ -227,6 +234,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: defining type: one_region::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 3\n    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r"}, {"sha": "167ca740c657c5ea0b7d1f5b4c3423ec7d0a865f", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |     twice(cell, value, |a, b| invoke(a, b));\n    = note: defining type: generic::<T>::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BrNamed('r)) ()>>, &ReLateBound(DebruijnIndex(0), BrNamed('s)) T)),\n+               (),\n            ]\n    = note: number of external vids: 2\n    = note: where T: '_#1r\n@@ -31,6 +32,7 @@ LL |     twice(cell, value, |a, b| invoke(a, b));\n    = note: defining type: generic_fail::<T>::{{closure}}#0 with closure substs [\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BrNamed('r)) ()>>, &ReLateBound(DebruijnIndex(0), BrNamed('s)) T)),\n+               (),\n            ]\n    = note: late-bound region is '_#2r\n    = note: number of external vids: 3"}, {"sha": "528da502b9d40b4c50a7f4e1458421f0b8366c7c", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -7,6 +7,7 @@ LL |     with_signature(x, |y| y)\n    = note: defining type: no_region::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<(dyn std::fmt::Debug + '_#2r)>,\n+               (),\n            ]\n    = note: number of external vids: 3\n    = note: where T: '_#2r"}, {"sha": "e341ee48291a9f40a4cf0d1e258cfda8833e11eb", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f08abd2e27785496ddfe92a9e6a4f9cd18443d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "patch": "@@ -14,6 +14,7 @@ LL | |     })\n    = note: defining type: no_region::<T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#1r ()>, T)),\n+               (),\n            ]\n    = note: late-bound region is '_#2r\n    = note: number of external vids: 3\n@@ -64,6 +65,7 @@ LL | |     })\n    = note: defining type: correct_region::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 3\n    = note: where T: '_#2r\n@@ -96,6 +98,7 @@ LL | |     })\n    = note: defining type: wrong_region::<'_#1r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T)),\n+               (),\n            ]\n    = note: late-bound region is '_#3r\n    = note: number of external vids: 4\n@@ -141,6 +144,7 @@ LL | |     })\n    = note: defining type: outlives_region::<'_#1r, '_#2r, T>::{{closure}}#0 with closure substs [\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T)),\n+               (),\n            ]\n    = note: number of external vids: 4\n    = note: where T: '_#3r"}]}