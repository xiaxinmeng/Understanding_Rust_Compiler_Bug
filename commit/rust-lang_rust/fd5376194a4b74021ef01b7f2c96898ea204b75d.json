{"sha": "fd5376194a4b74021ef01b7f2c96898ea204b75d", "node_id": "C_kwDOAAsO6NoAKGZkNTM3NjE5NGE0Yjc0MDIxZWYwMWI3ZjJjOTY4OThlYTIwNGI3NWQ", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-06T00:39:57Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-19T14:54:55Z"}, "message": "Move `range_zip_with_len` into `Methods` lint pass", "tree": {"sha": "1e5556fb134a7c30c2a233550d56d35d7b9f3e13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e5556fb134a7c30c2a233550d56d35d7b9f3e13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd5376194a4b74021ef01b7f2c96898ea204b75d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd5376194a4b74021ef01b7f2c96898ea204b75d", "html_url": "https://github.com/rust-lang/rust/commit/fd5376194a4b74021ef01b7f2c96898ea204b75d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd5376194a4b74021ef01b7f2c96898ea204b75d/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "226f135a033f48178ffaa629045664a54c23aa0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/226f135a033f48178ffaa629045664a54c23aa0e", "html_url": "https://github.com/rust-lang/rust/commit/226f135a033f48178ffaa629045664a54c23aa0e"}], "stats": {"total": 147, "additions": 77, "deletions": 70}, "files": [{"sha": "d2c8c44b14f4f202e1fd11af9919680e2a3dcea0", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=fd5376194a4b74021ef01b7f2c96898ea204b75d", "patch": "@@ -196,6 +196,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::OPTION_MAP_OR_NONE),\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::OR_THEN_UNWRAP),\n+    LintId::of(methods::RANGE_ZIP_WITH_LEN),\n     LintId::of(methods::RESULT_MAP_OR_INTO_OPTION),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SHOULD_IMPLEMENT_TRAIT),\n@@ -276,7 +277,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n     LintId::of(question_mark::QUESTION_MARK),\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n-    LintId::of(ranges::RANGE_ZIP_WITH_LEN),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n     LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n     LintId::of(read_zero_byte_vec::READ_ZERO_BYTE_VEC),"}, {"sha": "f77483de4e4b6a7def2f55e285681cfcae2e3000", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=fd5376194a4b74021ef01b7f2c96898ea204b75d", "patch": "@@ -51,6 +51,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n     LintId::of(methods::OPTION_FILTER_MAP),\n     LintId::of(methods::OR_THEN_UNWRAP),\n+    LintId::of(methods::RANGE_ZIP_WITH_LEN),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SKIP_WHILE_NEXT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n@@ -76,7 +77,6 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),\n     LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n-    LintId::of(ranges::RANGE_ZIP_WITH_LEN),\n     LintId::of(redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n     LintId::of(redundant_slicing::REDUNDANT_SLICING),\n     LintId::of(reference::DEREF_ADDROF),"}, {"sha": "2e48e3449552868b538251541b03d04978ee22ee", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=fd5376194a4b74021ef01b7f2c96898ea204b75d", "patch": "@@ -345,6 +345,7 @@ store.register_lints(&[\n     methods::OR_FUN_CALL,\n     methods::OR_THEN_UNWRAP,\n     methods::PATH_BUF_PUSH_OVERWRITE,\n+    methods::RANGE_ZIP_WITH_LEN,\n     methods::RESULT_MAP_OR_INTO_OPTION,\n     methods::SEARCH_IS_SOME,\n     methods::SHOULD_IMPLEMENT_TRAIT,\n@@ -473,7 +474,6 @@ store.register_lints(&[\n     ranges::MANUAL_RANGE_CONTAINS,\n     ranges::RANGE_MINUS_ONE,\n     ranges::RANGE_PLUS_ONE,\n-    ranges::RANGE_ZIP_WITH_LEN,\n     ranges::REVERSED_EMPTY_RANGES,\n     rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT,\n     read_zero_byte_vec::READ_ZERO_BYTE_VEC,"}, {"sha": "4a768117296938f9dbd619964fd68389c4ed8f06", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=fd5376194a4b74021ef01b7f2c96898ea204b75d", "patch": "@@ -64,6 +64,7 @@ mod option_map_unwrap_or;\n mod or_fun_call;\n mod or_then_unwrap;\n mod path_buf_push_overwrite;\n+mod range_zip_with_len;\n mod search_is_some;\n mod single_char_add_str;\n mod single_char_insert_string;\n@@ -2734,6 +2735,31 @@ declare_clippy_lint! {\n     \"calling `push` with file system root on `PathBuf` can overwrite it\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for zipping a collection with the range of\n+    /// `0.._.len()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The code is better expressed with `.enumerate()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = vec![1];\n+    /// let _ = x.iter().zip(0..x.len());\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = vec![1];\n+    /// let _ = x.iter().enumerate();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub RANGE_ZIP_WITH_LEN,\n+    complexity,\n+    \"zipping iterator with a range when `enumerate()` would do\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2848,6 +2874,7 @@ impl_lint_pass!(Methods => [\n     MUT_MUTEX_LOCK,\n     NONSENSICAL_OPEN_OPTIONS,\n     PATH_BUF_PUSH_OVERWRITE,\n+    RANGE_ZIP_WITH_LEN,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -3304,6 +3331,13 @@ impl Methods {\n                 (\"replace\" | \"replacen\", [arg1, arg2] | [arg1, arg2, _]) => {\n                     no_effect_replace::check(cx, expr, arg1, arg2);\n                 },\n+                (\"zip\", [arg]) => {\n+                    if let ExprKind::MethodCall(name, [iter_recv], _) = recv.kind\n+                        && name.ident.name == sym::iter\n+                    {\n+                        range_zip_with_len::check(cx, expr, iter_recv, arg);\n+                    }\n+                },\n                 _ => {},\n             }\n         }"}, {"sha": "00a2a0d14d1132946ef80749581d3e0e12644ea8", "filename": "clippy_lints/src/methods/range_zip_with_len.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs?ref=fd5376194a4b74021ef01b7f2c96898ea204b75d", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{higher, SpanlessEq};\n+use clippy_utils::{is_integer_const, is_trait_method};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::RANGE_ZIP_WITH_LEN;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'tcx Expr<'_>, zip_arg: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if is_trait_method(cx, expr, sym::Iterator);\n+        // range expression in `.zip()` call: `0..x.len()`\n+        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n+        if is_integer_const(cx, start, 0);\n+        // `.len()` call\n+        if let ExprKind::MethodCall(len_path, [len_recv], _) = end.kind;\n+        if len_path.ident.name == sym::len;\n+        // `.iter()` and `.len()` called on same `Path`\n+        if let ExprKind::Path(QPath::Resolved(_, iter_path)) = recv.kind;\n+        if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_recv.kind;\n+        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n+        then {\n+            span_lint(cx,\n+                RANGE_ZIP_WITH_LEN,\n+                expr.span,\n+                &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n+                    snippet(cx, recv.span, \"_\"))\n+            );\n+        }\n+    }\n+}"}, {"sha": "490f345d2970777634c6554ec54cbb5fd5c040cb", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 6, "deletions": 67, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5376194a4b74021ef01b7f2c96898ea204b75d/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=fd5376194a4b74021ef01b7f2c96898ea204b75d", "patch": "@@ -1,46 +1,20 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::higher;\n use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{get_parent_expr, in_constant, is_integer_const, meets_msrv, msrvs, path_to_local};\n-use clippy_utils::{higher, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, HirId, PathSegment, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::sym;\n use std::cmp::Ordering;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for zipping a collection with the range of\n-    /// `0.._.len()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The code is better expressed with `.enumerate()`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = vec![1];\n-    /// let _ = x.iter().zip(0..x.len());\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = vec![1];\n-    /// let _ = x.iter().enumerate();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub RANGE_ZIP_WITH_LEN,\n-    complexity,\n-    \"zipping iterator with a range when `enumerate()` would do\"\n-}\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for exclusive ranges where 1 is added to the\n@@ -198,7 +172,6 @@ impl Ranges {\n }\n \n impl_lint_pass!(Ranges => [\n-    RANGE_ZIP_WITH_LEN,\n     RANGE_PLUS_ONE,\n     RANGE_MINUS_ONE,\n     REVERSED_EMPTY_RANGES,\n@@ -207,16 +180,10 @@ impl_lint_pass!(Ranges => [\n \n impl<'tcx> LateLintPass<'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        match expr.kind {\n-            ExprKind::MethodCall(path, args, _) => {\n-                check_range_zip_with_len(cx, path, args, expr.span);\n-            },\n-            ExprKind::Binary(ref op, l, r) => {\n-                if meets_msrv(self.msrv, msrvs::RANGE_CONTAINS) {\n-                    check_possible_range_contains(cx, op.node, l, r, expr, expr.span);\n-                }\n-            },\n-            _ => {},\n+        if let ExprKind::Binary(ref op, l, r) = expr.kind {\n+            if meets_msrv(self.msrv, msrvs::RANGE_CONTAINS) {\n+                check_possible_range_contains(cx, op.node, l, r, expr, expr.span);\n+            }\n         }\n \n         check_exclusive_range_plus_one(cx, expr);\n@@ -380,34 +347,6 @@ fn check_range_bounds<'a>(cx: &'a LateContext<'_>, ex: &'a Expr<'_>) -> Option<R\n     None\n }\n \n-fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n-    if_chain! {\n-        if path.ident.as_str() == \"zip\";\n-        if let [iter, zip_arg] = args;\n-        // `.iter()` call\n-        if let ExprKind::MethodCall(iter_path, [iter_caller, ..], _) = iter.kind;\n-        if iter_path.ident.name == sym::iter;\n-        // range expression in `.zip()` call: `0..x.len()`\n-        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n-        if is_integer_const(cx, start, 0);\n-        // `.len()` call\n-        if let ExprKind::MethodCall(len_path, [len_caller], _) = end.kind;\n-        if len_path.ident.name == sym::len;\n-        // `.iter()` and `.len()` called on same `Path`\n-        if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_caller.kind;\n-        if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_caller.kind;\n-        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n-        then {\n-            span_lint(cx,\n-                RANGE_ZIP_WITH_LEN,\n-                span,\n-                &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n-                    snippet(cx, iter_caller.span, \"_\"))\n-            );\n-        }\n-    }\n-}\n-\n // exclusive range plus one: `x..(y+1)`\n fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {"}]}