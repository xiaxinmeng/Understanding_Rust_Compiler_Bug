{"sha": "bd97074517c6ba334247b70f33199e40374c223a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkOTcwNzQ1MTdjNmJhMzM0MjQ3YjcwZjMzMTk5ZTQwMzc0YzIyM2E=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-19T16:44:32Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-24T22:02:54Z"}, "message": "Small changes.", "tree": {"sha": "faf1968995d99b165ca09cd43202b4fe42391c71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faf1968995d99b165ca09cd43202b4fe42391c71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd97074517c6ba334247b70f33199e40374c223a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd97074517c6ba334247b70f33199e40374c223a", "html_url": "https://github.com/rust-lang/rust/commit/bd97074517c6ba334247b70f33199e40374c223a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd97074517c6ba334247b70f33199e40374c223a/comments", "author": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "babedc938e2c9a681737b3468b9124a58b2ec677", "url": "https://api.github.com/repos/rust-lang/rust/commits/babedc938e2c9a681737b3468b9124a58b2ec677", "html_url": "https://github.com/rust-lang/rust/commit/babedc938e2c9a681737b3468b9124a58b2ec677"}], "stats": {"total": 119, "additions": 77, "deletions": 42}, "files": [{"sha": "4fe3534739811538176aab487625cb72f2290b77", "filename": "src/shims/sync.rs", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bd97074517c6ba334247b70f33199e40374c223a/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd97074517c6ba334247b70f33199e40374c223a/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=bd97074517c6ba334247b70f33199e40374c223a", "patch": "@@ -288,15 +288,12 @@ fn release_cond_mutex<'mir, 'tcx: 'mir>(\n     active_thread: ThreadId,\n     mutex: MutexId,\n ) -> InterpResult<'tcx> {\n-    if let Some((old_owner_thread, old_locked_count)) = ecx.mutex_unlock(mutex)? {\n+    if let Some(old_locked_count) = ecx.mutex_unlock(mutex, active_thread)? {\n         if old_locked_count != 1 {\n             throw_unsup_format!(\"awaiting on a lock acquired multiple times is not supported\");\n         }\n-        if old_owner_thread != active_thread {\n-            throw_ub_format!(\"awaiting on a mutex owned by a different thread\");\n-        }\n     } else {\n-        throw_ub_format!(\"awaiting on unlocked mutex\");\n+        throw_ub_format!(\"awaiting on unlocked or owned by a different thread mutex\");\n     }\n     ecx.block_thread(active_thread)?;\n     Ok(())\n@@ -321,7 +318,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let kind = this.read_scalar(kind_op)?.not_undef()?;\n-        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")?\n+        if kind == this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n+            || kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")?\n             || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n             || kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")?\n         {\n@@ -380,6 +378,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Ok(0)\n             } else {\n                 // Trying to acquire the same mutex again.\n+                if kind == this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")? {\n+                    // FIXME: Sometimes this is actually a Deadlock.\n+                    // https://github.com/rust-lang/miri/issues/1419\n+                    throw_ub_format!(\n+                        \"trying to acquire already locked PTHREAD_MUTEX_DEFAULT (see #1419)\"\n+                    );\n+                }\n                 if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n                     throw_machine_stop!(TerminationInfo::Deadlock);\n                 } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n@@ -388,7 +393,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n-                    throw_ub_format!(\"called pthread_mutex_lock on an unsupported type of mutex\");\n+                    throw_unsup_format!(\n+                        \"called pthread_mutex_lock on an unsupported type of mutex\"\n+                    );\n                 }\n             }\n         } else {\n@@ -410,15 +417,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if owner_thread != active_thread {\n                 this.eval_libc_i32(\"EBUSY\")\n             } else {\n-                if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")?\n+                if kind == this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n+                    || kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")?\n                     || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n                 {\n                     this.eval_libc_i32(\"EBUSY\")\n                 } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n-                    throw_ub_format!(\n+                    throw_unsup_format!(\n                         \"called pthread_mutex_trylock on an unsupported type of mutex\"\n                     );\n                 }\n@@ -435,21 +443,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let active_thread = this.get_active_thread()?;\n \n-        if let Some((old_owner_thread, _old_locked_count)) = this.mutex_unlock(id)? {\n-            if old_owner_thread != this.get_active_thread()? {\n-                throw_ub_format!(\"called pthread_mutex_unlock on a mutex owned by another thread\");\n-            }\n+        if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread)? {\n+            // The mutex was locked by the current thread.\n             Ok(0)\n         } else {\n-            if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n-                throw_ub_format!(\"unlocked a PTHREAD_MUTEX_NORMAL mutex that was not locked\");\n+            // The mutex was locked by another thread or not locked at all. See\n+            // the \u201cUnlock When Not Owner\u201d column in\n+            // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_unlock.html.\n+            if kind == this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")? {\n+                throw_ub_format!(\n+                    \"unlocked a PTHREAD_MUTEX_DEFAULT mutex that was not locked by the current thread\"\n+                );\n+            } else if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n+                throw_ub_format!(\n+                    \"unlocked a PTHREAD_MUTEX_NORMAL mutex that was not locked by the current thread\"\n+                );\n             } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n                 this.eval_libc_i32(\"EPERM\")\n             } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n                 this.eval_libc_i32(\"EPERM\")\n             } else {\n-                throw_ub_format!(\"called pthread_mutex_unlock on an unsupported type of mutex\");\n+                throw_unsup_format!(\"called pthread_mutex_unlock on an unsupported type of mutex\");\n             }\n         }\n     }\n@@ -505,6 +521,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let active_thread = this.get_active_thread()?;\n \n         if this.rwlock_is_locked(id) {\n+            // Note: this will deadlock if the lock is already locked by this\n+            // thread in any way.\n+            //\n+            // Relevant documentation:\n+            // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html\n+            // An in depth discussion on this topic:\n+            // https://github.com/rust-lang/rust/issues/53127\n+            //\n+            // FIXME: Detect and report the deadlock proactively. (We currently\n+            // report the deadlock only when no thread can continue execution,\n+            // but we could detect that this lock is already locked and report\n+            // an error.)\n             this.rwlock_enqueue_and_block_writer(id, active_thread)?;\n         } else {\n             this.rwlock_writer_lock(id, active_thread);\n@@ -719,19 +747,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let clock_id = cond_get_clock_id(this, cond_op)?.to_i32()?;\n         let duration = {\n             let tp = this.deref_operand(abstime_op)?;\n-            let mut offset = Size::from_bytes(0);\n-            let layout = this.libc_ty_layout(\"time_t\")?;\n-            let seconds_place = tp.offset(offset, MemPlaceMeta::None, layout, this)?;\n+            let seconds_place = this.mplace_field(tp, 0)?;\n             let seconds = this.read_scalar(seconds_place.into())?;\n-            offset += layout.size;\n-            let layout = this.libc_ty_layout(\"c_long\")?;\n-            let nanoseconds_place = tp.offset(offset, MemPlaceMeta::None, layout, this)?;\n+            let nanoseconds_place = this.mplace_field(tp, 1)?;\n             let nanoseconds = this.read_scalar(nanoseconds_place.into())?;\n-            let (seconds, nanoseconds) = if this.pointer_size().bytes() == 8 {\n-                (seconds.to_u64()?, nanoseconds.to_u64()?.try_into().unwrap())\n-            } else {\n-                (seconds.to_u32()?.into(), nanoseconds.to_u32()?)\n-            };\n+            let (seconds, nanoseconds) = (\n+                seconds.to_machine_usize(this)?,\n+                nanoseconds.to_machine_usize(this)?.try_into().unwrap(),\n+            );\n             Duration::new(seconds, nanoseconds)\n         };\n \n@@ -740,7 +763,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n             Time::Monotonic(this.machine.time_anchor.checked_add(duration).unwrap())\n         } else {\n-            throw_unsup_format!(\"Unsupported clock id.\");\n+            throw_unsup_format!(\"unsupported clock id: {}\", clock_id);\n         };\n \n         // Register the timeout callback."}, {"sha": "026542926ed841f559911e8402057aea95fd62c9", "filename": "src/sync.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd97074517c6ba334247b70f33199e40374c223a/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd97074517c6ba334247b70f33199e40374c223a/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=bd97074517c6ba334247b70f33199e40374c223a", "patch": "@@ -30,10 +30,12 @@ macro_rules! declare_id {\n                 // We use 0 as a sentinel value (see the comment above) and,\n                 // therefore, need to shift by one when converting from an index\n                 // into a vector.\n-                $name(NonZeroU32::new(u32::try_from(idx).unwrap() + 1).unwrap())\n+                let shifted_idx = u32::try_from(idx).unwrap().checked_add(1).unwrap();\n+                $name(NonZeroU32::new(shifted_idx).unwrap())\n             }\n             fn index(self) -> usize {\n                 // See the comment in `Self::new`.\n+                // (This cannot underflow because self is NonZeroU32.)\n                 usize::try_from(self.0.get() - 1).unwrap()\n             }\n         }\n@@ -150,11 +152,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ///\n     /// Note: It is the caller's responsibility to check that the thread that\n     /// unlocked the lock actually is the same one, which owned it.\n-    fn mutex_unlock(&mut self, id: MutexId) -> InterpResult<'tcx, Option<(ThreadId, usize)>> {\n+    fn mutex_unlock(\n+        &mut self,\n+        id: MutexId,\n+        expected_owner: ThreadId,\n+    ) -> InterpResult<'tcx, Option<usize>> {\n         let this = self.eval_context_mut();\n         let mutex = &mut this.machine.threads.sync.mutexes[id];\n         if let Some(current_owner) = mutex.owner {\n             // Mutex is locked.\n+            if current_owner != expected_owner {\n+                // Only the owner can unlock the mutex.\n+                return Ok(None);\n+            }\n             let old_lock_count = mutex.lock_count;\n             mutex.lock_count = old_lock_count\n                 .checked_sub(1)\n@@ -168,7 +178,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.unblock_thread(new_owner)?;\n                 }\n             }\n-            Ok(Some((current_owner, old_lock_count)))\n+            Ok(Some(old_lock_count))\n         } else {\n             // Mutex is unlocked.\n             Ok(None)"}, {"sha": "45b07477fa2397a7b389620e3579fc06f81792cb", "filename": "src/thread.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd97074517c6ba334247b70f33199e40374c223a/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd97074517c6ba334247b70f33199e40374c223a/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=bd97074517c6ba334247b70f33199e40374c223a", "patch": "@@ -159,6 +159,7 @@ impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n     }\n }\n \n+/// A specific moment in time.\n #[derive(Debug)]\n pub enum Time {\n     Monotonic(Instant),\n@@ -449,9 +450,9 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         //\n         // Documentation:\n         // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html#\n-        if let Some(sleep_time) =\n-            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min()\n-        {\n+        let potential_sleep_time =\n+            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min();\n+        if let Some(sleep_time) = potential_sleep_time {\n             if sleep_time == Duration::new(0, 0) {\n                 return Ok(SchedulingAction::ExecuteTimeoutCallback);\n             }\n@@ -479,9 +480,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         // We have not found a thread to execute.\n         if self.threads.iter().all(|thread| thread.state == ThreadState::Terminated) {\n             unreachable!(\"all threads terminated without the main thread terminating?!\");\n-        } else if let Some(sleep_time) =\n-            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min()\n-        {\n+        } else if let Some(sleep_time) = potential_sleep_time {\n             // All threads are currently blocked, but we have unexecuted\n             // timeout_callbacks, which may unblock some of the threads. Hence,\n             // sleep until the first callback."}, {"sha": "4af8ee5df4b7faea8e45db7e1478fea05ad2be3e", "filename": "tests/compile-fail/sync/libc_pthread_mutex_normal_deadlock.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd97074517c6ba334247b70f33199e40374c223a/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_normal_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd97074517c6ba334247b70f33199e40374c223a/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_normal_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_normal_deadlock.rs?ref=bd97074517c6ba334247b70f33199e40374c223a", "patch": "@@ -11,6 +11,8 @@ fn main() {\n         let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n         assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n         assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-        libc::pthread_mutex_lock(&mut mutex as *mut _); //~ ERROR deadlock\n+        // FIXME: The error should be deadlock. See issue\n+        // https://github.com/rust-lang/miri/issues/1419.\n+        libc::pthread_mutex_lock(&mut mutex as *mut _); //~ ERROR Undefined Behavior\n     }\n }"}, {"sha": "e67e8d366ebf8167a2879953aa34225be61a61dd", "filename": "tests/compile-fail/sync/libc_pthread_mutex_wrong_owner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd97074517c6ba334247b70f33199e40374c223a/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_wrong_owner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd97074517c6ba334247b70f33199e40374c223a/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_wrong_owner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_wrong_owner.rs?ref=bd97074517c6ba334247b70f33199e40374c223a", "patch": "@@ -24,7 +24,7 @@ fn main() {\n \n         let lock_copy = lock.clone();\n         thread::spawn(move || {\n-            assert_eq!(libc::pthread_mutex_unlock(lock_copy.0.get() as *mut _), 0); //~ ERROR: Undefined Behavior: called pthread_mutex_unlock on a mutex owned by another thread\n+            assert_eq!(libc::pthread_mutex_unlock(lock_copy.0.get() as *mut _), 0); //~ ERROR: Undefined Behavior: unlocked a PTHREAD_MUTEX_DEFAULT mutex that was not locked\n         })\n         .join()\n         .unwrap();"}, {"sha": "2009c01ce9f952e33ec6c41d2cf70b89c944bffe", "filename": "tests/run-pass/concurrency/sync.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd97074517c6ba334247b70f33199e40374c223a/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd97074517c6ba334247b70f33199e40374c223a/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync.rs?ref=bd97074517c6ba334247b70f33199e40374c223a", "patch": "@@ -91,7 +91,8 @@ fn check_conditional_variables_timed_wait_timeout() {\n     let now = Instant::now();\n     let (_guard, timeout) = cvar.wait_timeout(guard, Duration::from_millis(100)).unwrap();\n     assert!(timeout.timed_out());\n-    assert!(now.elapsed().as_millis() >= 100);\n+    let elapsed_time = now.elapsed().as_millis();\n+    assert!(100 <= elapsed_time && elapsed_time <= 300);\n }\n \n /// Test that signaling a conditional variable when waiting with a timeout works\n@@ -243,7 +244,7 @@ fn get_cached_val() -> usize {\n fn expensive_computation() -> usize {\n     let mut i = 1;\n     let mut c = 1;\n-    while i < 10000 {\n+    while i < 1000 {\n         i *= c;\n         c += 1;\n     }\n@@ -257,7 +258,7 @@ fn check_once() {\n             thread::spawn(|| {\n                 thread::yield_now();\n                 let val = get_cached_val();\n-                assert_eq!(val, 40320);\n+                assert_eq!(val, 5040);\n             })\n         })\n         .collect();"}]}