{"sha": "ac9166a7af593b0e0cd9cbd9971a5f1cd74fc659", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjOTE2NmE3YWY1OTNiMGUwY2Q5Y2JkOTk3MWE1ZjFjZDc0ZmM2NTk=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-06-16T10:01:03Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-06-17T08:28:24Z"}, "message": "Remove :expr from placeholders\n\nReasoning discussed at #3186", "tree": {"sha": "6911bc91e718ff1ea83b122d6f07d9f10a9e7635", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6911bc91e718ff1ea83b122d6f07d9f10a9e7635"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac9166a7af593b0e0cd9cbd9971a5f1cd74fc659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac9166a7af593b0e0cd9cbd9971a5f1cd74fc659", "html_url": "https://github.com/rust-lang/rust/commit/ac9166a7af593b0e0cd9cbd9971a5f1cd74fc659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac9166a7af593b0e0cd9cbd9971a5f1cd74fc659/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d7974e5fb921236fea74731d8edde518f08e73a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d7974e5fb921236fea74731d8edde518f08e73a", "html_url": "https://github.com/rust-lang/rust/commit/5d7974e5fb921236fea74731d8edde518f08e73a"}], "stats": {"total": 74, "additions": 20, "deletions": 54}, "files": [{"sha": "762aab962a91de3fab6050ac03a6e68b0db1ca6d", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 20, "deletions": 54, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ac9166a7af593b0e0cd9cbd9971a5f1cd74fc659/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9166a7af593b0e0cd9cbd9971a5f1cd74fc659/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=ac9166a7af593b0e0cd9cbd9971a5f1cd74fc659", "patch": "@@ -27,11 +27,11 @@ impl std::error::Error for SsrError {}\n //\n // Search and replace with named wildcards that will match any expression.\n // The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n-// A `$<name>:expr` placeholder in the search pattern will match any expression and `$<name>` will reference it in the replacement.\n+// A `$<name>` placeholder in the search pattern will match any AST node and `$<name>` will reference it in the replacement.\n // Available via the command `rust-analyzer.ssr`.\n //\n // ```rust\n-// // Using structural search replace command [foo($a:expr, $b:expr) ==>> ($a).foo($b)]\n+// // Using structural search replace command [foo($a, $b) ==>> ($a).foo($b)]\n //\n // // BEFORE\n // String::from(foo(y + 5, z))\n@@ -79,7 +79,7 @@ struct SsrPattern {\n     vars: Vec<Var>,\n }\n \n-/// represents an `$var` in an SSR query\n+/// Represents a `$var` in an SSR query.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n struct Var(String);\n \n@@ -122,8 +122,7 @@ impl FromStr for SsrQuery {\n         let mut pattern = it.next().expect(\"something\").to_string();\n \n         for part in it.map(split_by_var) {\n-            let (var, var_type, remainder) = part?;\n-            is_expr(var_type)?;\n+            let (var, remainder) = part?;\n             let new_var = create_name(var, &mut vars)?;\n             pattern.push_str(new_var);\n             pattern.push_str(remainder);\n@@ -166,15 +165,11 @@ fn traverse(node: &SyntaxNode, go: &mut impl FnMut(&SyntaxNode) -> bool) {\n     }\n }\n \n-fn split_by_var(s: &str) -> Result<(&str, &str, &str), SsrError> {\n-    let end_of_name = s.find(':').ok_or_else(|| SsrError(\"Use $<name>:expr\".into()))?;\n-    let name = &s[0..end_of_name];\n+fn split_by_var(s: &str) -> Result<(&str, &str), SsrError> {\n+    let end_of_name = s.find(|c| !char::is_ascii_alphanumeric(&c)).unwrap_or_else(|| s.len());\n+    let name = &s[..end_of_name];\n     is_name(name)?;\n-    let type_begin = end_of_name + 1;\n-    let type_length =\n-        s[type_begin..].find(|c| !char::is_ascii_alphanumeric(&c)).unwrap_or_else(|| s.len());\n-    let type_name = &s[type_begin..type_begin + type_length];\n-    Ok((name, type_name, &s[type_begin + type_length..]))\n+    Ok((name, &s[end_of_name..]))\n }\n \n fn is_name(s: &str) -> Result<(), SsrError> {\n@@ -185,14 +180,6 @@ fn is_name(s: &str) -> Result<(), SsrError> {\n     }\n }\n \n-fn is_expr(s: &str) -> Result<(), SsrError> {\n-    if s == \"expr\" {\n-        Ok(())\n-    } else {\n-        Err(SsrError(\"Only $<name>:expr is supported\".into()))\n-    }\n-}\n-\n fn replace_in_template(template: String, var: &str, new_var: &str) -> String {\n     let name = format!(\"${}\", var);\n     template.replace(&name, new_var)\n@@ -450,7 +437,7 @@ mod tests {\n \n     #[test]\n     fn parser_happy_case() {\n-        let result: SsrQuery = \"foo($a:expr, $b:expr) ==>> bar($b, $a)\".parse().unwrap();\n+        let result: SsrQuery = \"foo($a, $b) ==>> bar($b, $a)\".parse().unwrap();\n         assert_eq!(&result.pattern.pattern.text(), \"foo(__search_pattern_a, __search_pattern_b)\");\n         assert_eq!(result.pattern.vars.len(), 2);\n         assert_eq!(result.pattern.vars[0].0, \"__search_pattern_a\");\n@@ -476,31 +463,10 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn parser_no_pattern_type() {\n-        assert_eq!(parse_error_text(\"foo($a) ==>>\"), \"Parse error: Use $<name>:expr\");\n-    }\n-\n-    #[test]\n-    fn parser_invalid_name() {\n-        assert_eq!(\n-            parse_error_text(\"foo($a+:expr) ==>>\"),\n-            \"Parse error: Name can contain only alphanumerics and _\"\n-        );\n-    }\n-\n-    #[test]\n-    fn parser_invalid_type() {\n-        assert_eq!(\n-            parse_error_text(\"foo($a:ident) ==>>\"),\n-            \"Parse error: Only $<name>:expr is supported\"\n-        );\n-    }\n-\n     #[test]\n     fn parser_repeated_name() {\n         assert_eq!(\n-            parse_error_text(\"foo($a:expr, $a:expr) ==>>\"),\n+            parse_error_text(\"foo($a, $a) ==>>\"),\n             \"Parse error: Name `a` repeats more than once\"\n         );\n     }\n@@ -517,7 +483,7 @@ mod tests {\n \n     #[test]\n     fn parse_match_replace() {\n-        let query: SsrQuery = \"foo($x:expr) ==>> bar($x)\".parse().unwrap();\n+        let query: SsrQuery = \"foo($x) ==>> bar($x)\".parse().unwrap();\n         let input = \"fn main() { foo(1+2); }\";\n \n         let code = SourceFile::parse(input).tree();\n@@ -549,7 +515,7 @@ mod tests {\n     #[test]\n     fn ssr_function_to_method() {\n         assert_ssr_transform(\n-            \"my_function($a:expr, $b:expr) ==>> ($a).my_method($b)\",\n+            \"my_function($a, $b) ==>> ($a).my_method($b)\",\n             \"loop { my_function( other_func(x, y), z + w) }\",\n             \"loop { (other_func(x, y)).my_method(z + w) }\",\n         )\n@@ -558,7 +524,7 @@ mod tests {\n     #[test]\n     fn ssr_nested_function() {\n         assert_ssr_transform(\n-            \"foo($a:expr, $b:expr, $c:expr) ==>> bar($c, baz($a, $b))\",\n+            \"foo($a, $b, $c) ==>> bar($c, baz($a, $b))\",\n             \"fn main { foo  (x + value.method(b), x+y-z, true && false) }\",\n             \"fn main { bar(true && false, baz(x + value.method(b), x+y-z)) }\",\n         )\n@@ -567,7 +533,7 @@ mod tests {\n     #[test]\n     fn ssr_expected_spacing() {\n         assert_ssr_transform(\n-            \"foo($x:expr) + bar() ==>> bar($x)\",\n+            \"foo($x) + bar() ==>> bar($x)\",\n             \"fn main() { foo(5) + bar() }\",\n             \"fn main() { bar(5) }\",\n         );\n@@ -576,7 +542,7 @@ mod tests {\n     #[test]\n     fn ssr_with_extra_space() {\n         assert_ssr_transform(\n-            \"foo($x:expr  ) +    bar() ==>> bar($x)\",\n+            \"foo($x  ) +    bar() ==>> bar($x)\",\n             \"fn main() { foo(  5 )  +bar(   ) }\",\n             \"fn main() { bar(5) }\",\n         );\n@@ -585,7 +551,7 @@ mod tests {\n     #[test]\n     fn ssr_keeps_nested_comment() {\n         assert_ssr_transform(\n-            \"foo($x:expr) ==>> bar($x)\",\n+            \"foo($x) ==>> bar($x)\",\n             \"fn main() { foo(other(5 /* using 5 */)) }\",\n             \"fn main() { bar(other(5 /* using 5 */)) }\",\n         )\n@@ -594,7 +560,7 @@ mod tests {\n     #[test]\n     fn ssr_keeps_comment() {\n         assert_ssr_transform(\n-            \"foo($x:expr) ==>> bar($x)\",\n+            \"foo($x) ==>> bar($x)\",\n             \"fn main() { foo(5 /* using 5 */) }\",\n             \"fn main() { bar(5)/* using 5 */ }\",\n         )\n@@ -603,7 +569,7 @@ mod tests {\n     #[test]\n     fn ssr_struct_lit() {\n         assert_ssr_transform(\n-            \"foo{a: $a:expr, b: $b:expr} ==>> foo::new($a, $b)\",\n+            \"foo{a: $a, b: $b} ==>> foo::new($a, $b)\",\n             \"fn main() { foo{b:2, a:1} }\",\n             \"fn main() { foo::new(1, 2) }\",\n         )\n@@ -612,7 +578,7 @@ mod tests {\n     #[test]\n     fn ssr_call_and_method_call() {\n         assert_ssr_transform(\n-            \"foo::<'a>($a:expr, $b:expr)) ==>> foo2($a, $b)\",\n+            \"foo::<'a>($a, $b)) ==>> foo2($a, $b)\",\n             \"fn main() { get().bar.foo::<'a>(1); }\",\n             \"fn main() { foo2(get().bar, 1); }\",\n         )\n@@ -621,7 +587,7 @@ mod tests {\n     #[test]\n     fn ssr_method_call_and_call() {\n         assert_ssr_transform(\n-            \"$o:expr.foo::<i32>($a:expr)) ==>> $o.foo2($a)\",\n+            \"$o.foo::<i32>($a)) ==>> $o.foo2($a)\",\n             \"fn main() { X::foo::<i32>(x, 1); }\",\n             \"fn main() { x.foo2(1); }\",\n         )"}]}