{"sha": "189930fcae287565dcef856ae8d60a83190a4b92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OTkzMGZjYWUyODc1NjVkY2VmODU2YWU4ZDYwYTgzMTkwYTRiOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-05T19:00:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-05T19:00:13Z"}, "message": "Auto merge of #21916 - japaric:no-as-slice, r=alexcrichton\n\nr? @alexcrichton \r\ncc @eddyb", "tree": {"sha": "325defba0f55b48273cd3f0814fe6c083dee5d41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/325defba0f55b48273cd3f0814fe6c083dee5d41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/189930fcae287565dcef856ae8d60a83190a4b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/189930fcae287565dcef856ae8d60a83190a4b92", "html_url": "https://github.com/rust-lang/rust/commit/189930fcae287565dcef856ae8d60a83190a4b92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/189930fcae287565dcef856ae8d60a83190a4b92/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c05354211b04a52cc66a0b8ad8b2225eaf9e972", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c05354211b04a52cc66a0b8ad8b2225eaf9e972", "html_url": "https://github.com/rust-lang/rust/commit/2c05354211b04a52cc66a0b8ad8b2225eaf9e972"}, {"sha": "17bc7d8d5be3be9674d702ccad2fa88c487d23b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/17bc7d8d5be3be9674d702ccad2fa88c487d23b0", "html_url": "https://github.com/rust-lang/rust/commit/17bc7d8d5be3be9674d702ccad2fa88c487d23b0"}], "stats": {"total": 2778, "additions": 1372, "deletions": 1406}, "files": [{"sha": "e3e7ca7691134a6f150c72f6d080d5ffd9b67d11", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -97,22 +97,22 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n     assert!(!args.is_empty());\n     let argv0 = args[0].clone();\n     let args_ = args.tail();\n-    if args[1].as_slice() == \"-h\" || args[1].as_slice() == \"--help\" {\n+    if args[1] == \"-h\" || args[1] == \"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::usage(message.as_slice(), groups.as_slice()));\n+        println!(\"{}\", getopts::usage(&message, &groups));\n         println!(\"\");\n         panic!()\n     }\n \n     let matches =\n-        &match getopts::getopts(args_.as_slice(), groups.as_slice()) {\n+        &match getopts::getopts(args_, &groups) {\n           Ok(m) => m,\n           Err(f) => panic!(\"{:?}\", f)\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::usage(message.as_slice(), groups.as_slice()));\n+        println!(\"{}\", getopts::usage(&message, &groups));\n         println!(\"\");\n         panic!()\n     }\n@@ -156,9 +156,9 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n         adb_device_status:\n             \"arm-linux-androideabi\" ==\n-                opt_str2(matches.opt_str(\"target\")).as_slice() &&\n+                opt_str2(matches.opt_str(\"target\")) &&\n             \"(none)\" !=\n-                opt_str2(matches.opt_str(\"adb-test-dir\")).as_slice() &&\n+                opt_str2(matches.opt_str(\"adb-test-dir\")) &&\n             !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n         verbose: matches.opt_present(\"verbose\"),\n@@ -201,7 +201,7 @@ pub fn log_config(config: &Config) {\n pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n     match *maybestr {\n         None => \"(none)\",\n-        Some(ref s) => s.as_slice(),\n+        Some(ref s) => s,\n     }\n }\n \n@@ -213,7 +213,7 @@ pub fn opt_str2(maybestr: Option<String>) -> String {\n }\n \n pub fn run_tests(config: &Config) {\n-    if config.target.as_slice() == \"arm-linux-androideabi\" {\n+    if config.target == \"arm-linux-androideabi\" {\n         match config.mode {\n             DebugInfoGdb => {\n                 println!(\"arm-linux-androideabi debug-info \\\n@@ -306,13 +306,13 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n     let mut valid = false;\n \n     for ext in &valid_extensions {\n-        if name.ends_with(ext.as_slice()) {\n+        if name.ends_with(ext) {\n             valid = true;\n         }\n     }\n \n     for pre in &invalid_prefixes {\n-        if name.starts_with(pre.as_slice()) {\n+        if name.starts_with(pre) {\n             valid = false;\n         }\n     }"}, {"sha": "d8faa53a2de647bc8c82262505ec266572e00daa", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -44,7 +44,7 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n     rdr.lines().enumerate().filter_map(|(line_no, ln)| {\n         parse_expected(last_nonfollow_error,\n                        line_no + 1,\n-                       ln.unwrap().as_slice())\n+                       &ln.unwrap())\n             .map(|(which, error)| {\n                 match which {\n                     FollowPrevious(_) => {}"}, {"sha": "c2539679643221332b31a32c6caba396dc6f3aee", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -145,7 +145,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n \n pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n     fn ignore_target(config: &Config) -> String {\n-        format!(\"ignore-{}\", util::get_os(config.target.as_slice()))\n+        format!(\"ignore-{}\", util::get_os(&config.target))\n     }\n     fn ignore_stage(config: &Config) -> String {\n         format!(\"ignore-{}\",\n@@ -169,8 +169,8 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n                                           .expect(\"Malformed GDB version directive\");\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    gdb_version_to_int(actual_version.as_slice()) <\n-                        gdb_version_to_int(min_version.as_slice())\n+                    gdb_version_to_int(actual_version) <\n+                        gdb_version_to_int(min_version)\n                 } else {\n                     false\n                 }\n@@ -197,8 +197,8 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n                                           .expect(\"Malformed lldb version directive\");\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    lldb_version_to_int(actual_version.as_slice()) <\n-                        lldb_version_to_int(min_version.as_slice())\n+                    lldb_version_to_int(actual_version) <\n+                        lldb_version_to_int(min_version)\n                 } else {\n                     false\n                 }\n@@ -209,8 +209,8 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n \n     let val = iter_header(testfile, |ln| {\n         !parse_name_directive(ln, \"ignore-test\") &&\n-        !parse_name_directive(ln, ignore_target(config).as_slice()) &&\n-        !parse_name_directive(ln, ignore_stage(config).as_slice()) &&\n+        !parse_name_directive(ln, &ignore_target(config)) &&\n+        !parse_name_directive(ln, &ignore_stage(config)) &&\n         !(config.mode == common::Pretty && parse_name_directive(ln, \"ignore-pretty\")) &&\n         !(config.target != config.host && parse_name_directive(ln, \"ignore-cross-compile\")) &&\n         !ignore_gdb(config, ln) &&\n@@ -294,7 +294,7 @@ fn parse_pretty_compare_only(line: &str) -> bool {\n fn parse_exec_env(line: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, \"exec-env\").map(|nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs: Vec<String> = nv.as_slice()\n+        let mut strs: Vec<String> = nv\n                                       .splitn(1, '=')\n                                       .map(|s| s.to_string())\n                                       .collect();\n@@ -330,7 +330,7 @@ fn parse_name_directive(line: &str, directive: &str) -> bool {\n pub fn parse_name_value_directive(line: &str, directive: &str)\n                                   -> Option<String> {\n     let keycolon = format!(\"{}:\", directive);\n-    match line.find_str(keycolon.as_slice()) {\n+    match line.find_str(&keycolon) {\n         Some(colon) => {\n             let value = line[(colon + keycolon.len()) .. line.len()].to_string();\n             debug!(\"{}: {}\", directive, value);\n@@ -344,16 +344,16 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n     let error_string = format!(\n         \"Encountered GDB version string with unexpected format: {}\",\n         version_string);\n-    let error_string = error_string.as_slice();\n+    let error_string = error_string;\n \n     let components: Vec<&str> = version_string.trim().split('.').collect();\n \n     if components.len() != 2 {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = components[0].parse().ok().expect(error_string);\n-    let minor: int = components[1].parse().ok().expect(error_string);\n+    let major: int = components[0].parse().ok().expect(&error_string);\n+    let minor: int = components[1].parse().ok().expect(&error_string);\n \n     return major * 1000 + minor;\n }\n@@ -362,7 +362,7 @@ pub fn lldb_version_to_int(version_string: &str) -> int {\n     let error_string = format!(\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n-    let error_string = error_string.as_slice();\n-    let major: int = version_string.parse().ok().expect(error_string);\n+    let error_string = error_string;\n+    let major: int = version_string.parse().ok().expect(&error_string);\n     return major;\n }"}, {"sha": "148a43e6c783196555b044efb3e4ec8e1791d4d6", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -23,7 +23,7 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n \n     // Add the new dylib search path var\n     let var = DynamicLibrary::envvar();\n-    let newpath = DynamicLibrary::create_path(path.as_slice());\n+    let newpath = DynamicLibrary::create_path(&path);\n     let newpath = String::from_utf8(newpath).unwrap();\n     cmd.env(var.to_string(), newpath);\n }"}, {"sha": "5a372fd7cdcb261f83898f29e0ace7a8a63738ab", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 109, "deletions": 116, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -40,7 +40,7 @@ use std::time::Duration;\n use test::MetricMap;\n \n pub fn run(config: Config, testfile: String) {\n-    match config.target.as_slice() {\n+    match &*config.target {\n \n         \"arm-linux-androideabi\" => {\n             if !config.adb_device_status {\n@@ -106,10 +106,10 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n         }\n         check_expected_errors(expected_errors, testfile, &proc_res);\n     } else {\n-        check_error_patterns(props, testfile, output_to_check.as_slice(), &proc_res);\n+        check_error_patterns(props, testfile, &output_to_check, &proc_res);\n     }\n     check_no_compiler_crash(&proc_res);\n-    check_forbid_output(props, output_to_check.as_slice(), &proc_res);\n+    check_forbid_output(props, &output_to_check, &proc_res);\n }\n \n fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n@@ -133,16 +133,16 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     let output_to_check = get_output(props, &proc_res);\n     check_correct_failure_status(&proc_res);\n-    check_error_patterns(props, testfile, output_to_check.as_slice(), &proc_res);\n+    check_error_patterns(props, testfile, &output_to_check, &proc_res);\n }\n \n fn check_correct_failure_status(proc_res: &ProcRes) {\n     // The value the rust runtime returns on failure\n     static RUST_ERR: int = 101;\n     if !proc_res.status.matches_exit_status(RUST_ERR) {\n         fatal_proc_rec(\n-            format!(\"failure produced the wrong error: {:?}\",\n-                    proc_res.status).as_slice(),\n+            &format!(\"failure produced the wrong error: {:?}\",\n+                     proc_res.status),\n             proc_res);\n     }\n }\n@@ -211,11 +211,10 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                     props,\n                                     testfile,\n                                     srcs[round].to_string(),\n-                                    props.pretty_mode.as_slice());\n+                                    &props.pretty_mode);\n \n         if !proc_res.status.success() {\n-            fatal_proc_rec(format!(\"pretty-printing failed in round {}\",\n-                                   round).as_slice(),\n+            fatal_proc_rec(&format!(\"pretty-printing failed in round {}\", round),\n                           &proc_res);\n         }\n \n@@ -237,11 +236,11 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n         let cr = \"\\r\".to_string();\n-        actual = actual.replace(cr.as_slice(), \"\").to_string();\n-        expected = expected.replace(cr.as_slice(), \"\").to_string();\n+        actual = actual.replace(&cr, \"\").to_string();\n+        expected = expected.replace(&cr, \"\").to_string();\n     }\n \n-    compare_source(expected.as_slice(), actual.as_slice());\n+    compare_source(&expected, &actual);\n \n     // If we're only making sure that the output matches then just stop here\n     if props.pretty_compare_only { return; }\n@@ -282,7 +281,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                      testfile,\n                                      pretty_type.to_string()),\n                         props.exec_env.clone(),\n-                        config.compile_lib_path.as_slice(),\n+                        &config.compile_lib_path,\n                         Some(aux_dir.as_str().unwrap()),\n                         Some(src))\n     }\n@@ -335,9 +334,9 @@ actual:\\n\\\n     fn make_typecheck_args(config: &Config, props: &TestProps, testfile: &Path) -> ProcArgs {\n         let aux_dir = aux_output_dir_name(config, testfile);\n         let target = if props.force_host {\n-            config.host.as_slice()\n+            &*config.host\n         } else {\n-            config.target.as_slice()\n+            &*config.target\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec!(\"-\".to_string(),\n@@ -382,7 +381,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let exe_file = make_exe_name(config, testfile);\n \n     let debugger_run_result;\n-    match config.target.as_slice() {\n+    match &*config.target {\n         \"arm-linux-androideabi\" => {\n \n             cmds = cmds.replace(\"run\", \"continue\").to_string();\n@@ -397,12 +396,12 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config,\n                              testfile,\n-                             script_str.as_slice(),\n+                             &script_str,\n                              \"debugger.script\");\n \n \n             procsrv::run(\"\",\n-                         config.adb_path.as_slice(),\n+                         &config.adb_path,\n                          None,\n                          &[\n                             \"push\".to_string(),\n@@ -411,10 +410,10 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                          ],\n                          vec!((\"\".to_string(), \"\".to_string())),\n                          Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{:?}`\", config.adb_path).as_slice());\n+                .expect(&format!(\"failed to exec `{:?}`\", config.adb_path));\n \n             procsrv::run(\"\",\n-                         config.adb_path.as_slice(),\n+                         &config.adb_path,\n                          None,\n                          &[\n                             \"forward\".to_string(),\n@@ -423,7 +422,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                          ],\n                          vec!((\"\".to_string(), \"\".to_string())),\n                          Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{:?}`\", config.adb_path).as_slice());\n+                .expect(&format!(\"failed to exec `{:?}`\", config.adb_path));\n \n             let adb_arg = format!(\"export LD_LIBRARY_PATH={}; \\\n                                    gdbserver :5039 {}/{}\",\n@@ -434,8 +433,8 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                       .unwrap()).unwrap());\n \n             let mut process = procsrv::run_background(\"\",\n-                                                      config.adb_path\n-                                                            .as_slice(),\n+                                                      &config.adb_path\n+                                                            ,\n                                                       None,\n                                                       &[\n                                                         \"shell\".to_string(),\n@@ -444,7 +443,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                                       vec!((\"\".to_string(),\n                                                             \"\".to_string())),\n                                                       Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{:?}`\", config.adb_path).as_slice());\n+                .expect(&format!(\"failed to exec `{:?}`\", config.adb_path));\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n@@ -477,16 +476,16 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 err,\n                 status\n             } = procsrv::run(\"\",\n-                             gdb_path.as_slice(),\n+                             &gdb_path,\n                              None,\n-                             debugger_opts.as_slice(),\n+                             &debugger_opts,\n                              vec!((\"\".to_string(), \"\".to_string())),\n                              None)\n-                .expect(format!(\"failed to exec `{:?}`\", gdb_path).as_slice());\n+                .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n             let cmdline = {\n                 let cmdline = make_cmdline(\"\",\n                                            \"arm-linux-androideabi-gdb\",\n-                                           debugger_opts.as_slice());\n+                                           &debugger_opts);\n                 logv(config, format!(\"executing {}\", cmdline));\n                 cmdline\n             };\n@@ -517,16 +516,16 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             match config.gdb_version {\n                 Some(ref version) => {\n                     println!(\"NOTE: compiletest thinks it is using GDB version {}\",\n-                             version.as_slice());\n+                             version);\n \n-                    if header::gdb_version_to_int(version.as_slice()) >\n+                    if header::gdb_version_to_int(version) >\n                         header::gdb_version_to_int(\"7.4\") {\n                         // Add the directory containing the pretty printers to\n                         // GDB's script auto loading safe path\n                         script_str.push_str(\n-                            format!(\"add-auto-load-safe-path {}\\n\",\n-                                    rust_pp_module_abs_path.replace(\"\\\\\", \"\\\\\\\\\").as_slice())\n-                                .as_slice());\n+                            &format!(\"add-auto-load-safe-path {}\\n\",\n+                                     rust_pp_module_abs_path.replace(\"\\\\\", \"\\\\\\\\\"))\n+                                );\n                     }\n                 }\n                 _ => {\n@@ -553,13 +552,13 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                              *line)[]);\n             }\n \n-            script_str.push_str(cmds.as_slice());\n+            script_str.push_str(&cmds);\n             script_str.push_str(\"quit\\n\");\n \n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config,\n                              testfile,\n-                             script_str.as_slice(),\n+                             &script_str,\n                              \"debugger.script\");\n \n             // run debugger script with gdb\n@@ -592,7 +591,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                                   testfile,\n                                                   proc_args,\n                                                   environment,\n-                                                  config.run_lib_path.as_slice(),\n+                                                  &config.run_lib_path,\n                                                   None,\n                                                   None);\n         }\n@@ -602,7 +601,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n         fatal(\"gdb failed to execute\");\n     }\n \n-    check_debugger_output(&debugger_run_result, check_lines.as_slice());\n+    check_debugger_output(&debugger_run_result, &check_lines);\n }\n \n fn find_rust_src_root(config: &Config) -> Option<Path> {\n@@ -644,7 +643,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     match config.lldb_version {\n         Some(ref version) => {\n             println!(\"NOTE: compiletest thinks it is using LLDB version {}\",\n-                     version.as_slice());\n+                     version);\n         }\n         _ => {\n             println!(\"NOTE: compiletest does not know which version of \\\n@@ -684,13 +683,12 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n \n     // Set breakpoints on every line that contains the string \"#break\"\n     for line in &breakpoint_lines {\n-        script_str.push_str(format!(\"breakpoint set --line {}\\n\",\n-                                    line).as_slice());\n+        script_str.push_str(&format!(\"breakpoint set --line {}\\n\", line));\n     }\n \n     // Append the other commands\n     for line in &commands {\n-        script_str.push_str(line.as_slice());\n+        script_str.push_str(line);\n         script_str.push_str(\"\\n\");\n     }\n \n@@ -701,7 +699,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     debug!(\"script_str = {}\", script_str);\n     dump_output_file(config,\n                      testfile,\n-                     script_str.as_slice(),\n+                     &script_str,\n                      \"debugger.script\");\n     let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n \n@@ -715,7 +713,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n         fatal_proc_rec(\"Error while running LLDB\", &debugger_run_result);\n     }\n \n-    check_debugger_output(&debugger_run_result, check_lines.as_slice());\n+    check_debugger_output(&debugger_run_result, &check_lines);\n \n     fn run_lldb(config: &Config,\n                 test_executable: &Path,\n@@ -729,7 +727,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n         cmd.arg(lldb_script_path)\n            .arg(test_executable)\n            .arg(debugger_script)\n-           .env_set_all(&[(\"PYTHONPATH\", config.lldb_python_dir.clone().unwrap().as_slice())]);\n+           .env_set_all(&[(\"PYTHONPATH\", config.lldb_python_dir.clone().unwrap())]);\n \n         let (status, out, err) = match cmd.spawn() {\n             Ok(process) => {\n@@ -741,12 +739,12 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                  String::from_utf8(error).unwrap())\n             },\n             Err(e) => {\n-                fatal(format!(\"Failed to setup Python process for \\\n-                               LLDB script: {}\", e).as_slice())\n+                fatal(&format!(\"Failed to setup Python process for \\\n+                                LLDB script: {}\", e))\n             }\n         };\n \n-        dump_output(config, test_executable, out.as_slice(), err.as_slice());\n+        dump_output(config, test_executable, &out, &err);\n         return ProcRes {\n             status: status,\n             stdout: out,\n@@ -782,20 +780,19 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n                 }\n \n                 header::parse_name_value_directive(\n-                        line.as_slice(),\n-                        command_directive.as_slice()).map(|cmd| {\n+                        &line,\n+                        &command_directive).map(|cmd| {\n                     commands.push(cmd)\n                 });\n \n                 header::parse_name_value_directive(\n-                        line.as_slice(),\n-                        check_directive.as_slice()).map(|cmd| {\n+                        &line,\n+                        &check_directive).map(|cmd| {\n                     check_lines.push(cmd)\n                 });\n             }\n             Err(e) => {\n-                fatal(format!(\"Error while parsing debugger commands: {}\",\n-                              e).as_slice())\n+                fatal(&format!(\"Error while parsing debugger commands: {}\", e))\n             }\n         }\n         counter += 1;\n@@ -834,7 +831,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n         // bits in the wrong case of an enum) with the notation \"[...]\".\n         let check_fragments: Vec<Vec<String>> =\n             check_lines.iter().map(|s| {\n-                s.as_slice()\n+                s\n                  .trim()\n                  .split_str(\"[...]\")\n                  .map(|x| x.to_string())\n@@ -849,13 +846,13 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             let mut failed = false;\n             for frag in &check_fragments[i] {\n                 let found = if first {\n-                    if rest.starts_with(frag.as_slice()) {\n+                    if rest.starts_with(frag) {\n                         Some(0)\n                     } else {\n                         None\n                     }\n                 } else {\n-                    rest.find_str(frag.as_slice())\n+                    rest.find_str(frag)\n                 };\n                 match found {\n                     None => {\n@@ -877,8 +874,8 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             }\n         }\n         if i != num_check_lines {\n-            fatal_proc_rec(format!(\"line not found in debugger output: {}\",\n-                                  check_lines.get(i).unwrap()).as_slice(),\n+            fatal_proc_rec(&format!(\"line not found in debugger output: {}\",\n+                                    check_lines.get(i).unwrap()),\n                           debugger_run_result);\n         }\n     }\n@@ -889,14 +886,13 @@ fn check_error_patterns(props: &TestProps,\n                         output_to_check: &str,\n                         proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(format!(\"no error pattern specified in {:?}\",\n-                      testfile.display()).as_slice());\n+        fatal(&format!(\"no error pattern specified in {:?}\", testfile.display()));\n     }\n     let mut next_err_idx = 0;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n     for line in output_to_check.lines() {\n-        if line.contains(next_err_pat.as_slice()) {\n+        if line.contains(next_err_pat) {\n             debug!(\"found error pattern {}\", next_err_pat);\n             next_err_idx += 1;\n             if next_err_idx == props.error_patterns.len() {\n@@ -911,13 +907,11 @@ fn check_error_patterns(props: &TestProps,\n \n     let missing_patterns = &props.error_patterns[next_err_idx..];\n     if missing_patterns.len() == 1 {\n-        fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n-                              missing_patterns[0]).as_slice(),\n+        fatal_proc_rec(&format!(\"error pattern '{}' not found!\", missing_patterns[0]),\n                       proc_res);\n     } else {\n         for pattern in missing_patterns {\n-            error(format!(\"error pattern '{}' not found!\",\n-                          *pattern).as_slice());\n+            error(&format!(\"error pattern '{}' not found!\", *pattern));\n         }\n         fatal_proc_rec(\"multiple error patterns not found\", proc_res);\n     }\n@@ -936,7 +930,7 @@ fn check_forbid_output(props: &TestProps,\n                        output_to_check: &str,\n                        proc_res: &ProcRes) {\n     for pat in &props.forbid_output {\n-        if output_to_check.contains(pat.as_slice()) {\n+        if output_to_check.contains(pat) {\n             fatal_proc_rec(\"forbidden pattern found in compiler output\", proc_res);\n         }\n     }\n@@ -959,7 +953,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n \n     #[cfg(windows)]\n     fn prefix_matches( line : &str, prefix : &str ) -> bool {\n-        line.to_ascii_lowercase().starts_with(prefix.to_ascii_lowercase().as_slice())\n+        line.to_ascii_lowercase().starts_with(&prefix.to_ascii_lowercase())\n     }\n \n     #[cfg(unix)]\n@@ -988,13 +982,13 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         for (i, ee) in expected_errors.iter().enumerate() {\n             if !found_flags[i] {\n                 debug!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n-                       prefixes[i].as_slice(),\n+                       prefixes[i],\n                        ee.kind,\n                        ee.msg,\n                        line);\n-                if (prefix_matches(line, prefixes[i].as_slice()) || continuation(line)) &&\n-                    line.contains(ee.kind.as_slice()) &&\n-                    line.contains(ee.msg.as_slice()) {\n+                if (prefix_matches(line, &prefixes[i]) || continuation(line)) &&\n+                    line.contains(&ee.kind) &&\n+                    line.contains(&ee.msg) {\n                     found_flags[i] = true;\n                     was_expected = true;\n                     break;\n@@ -1008,17 +1002,17 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         }\n \n         if !was_expected && is_compiler_error_or_warning(line) {\n-            fatal_proc_rec(format!(\"unexpected compiler error or warning: '{}'\",\n-                                  line).as_slice(),\n+            fatal_proc_rec(&format!(\"unexpected compiler error or warning: '{}'\",\n+                                    line),\n                           proc_res);\n         }\n     }\n \n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n             let ee = &expected_errors[i];\n-            fatal_proc_rec(format!(\"expected {} on line {} not found: {}\",\n-                                  ee.kind, ee.line, ee.msg).as_slice(),\n+            fatal_proc_rec(&format!(\"expected {} on line {} not found: {}\",\n+                                    ee.kind, ee.line, ee.msg),\n                           proc_res);\n         }\n     }\n@@ -1139,7 +1133,7 @@ fn exec_compiled_test(config: &Config, props: &TestProps,\n \n     let env = props.exec_env.clone();\n \n-    match config.target.as_slice() {\n+    match &*config.target {\n \n         \"arm-linux-androideabi\" => {\n             _arm_exec_compiled_test(config, props, testfile, env)\n@@ -1151,7 +1145,7 @@ fn exec_compiled_test(config: &Config, props: &TestProps,\n                             testfile,\n                             make_run_args(config, props, testfile),\n                             env,\n-                            config.run_lib_path.as_slice(),\n+                            &config.run_lib_path,\n                             Some(aux_dir.as_str().unwrap()),\n                             None)\n         }\n@@ -1174,7 +1168,7 @@ fn compose_and_run_compiler(\n     let extra_link_args = vec!(\"-L\".to_string(), aux_dir.as_str().unwrap().to_string());\n \n     for rel_ab in &props.aux_builds {\n-        let abs_ab = config.aux_base.join(rel_ab.as_slice());\n+        let abs_ab = config.aux_base.join(rel_ab);\n         let aux_props = header::load_props(&abs_ab);\n         let mut crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n@@ -1195,17 +1189,17 @@ fn compose_and_run_compiler(\n                                      &abs_ab,\n                                      aux_args,\n                                      Vec::new(),\n-                                     config.compile_lib_path.as_slice(),\n+                                     &config.compile_lib_path,\n                                      Some(aux_dir.as_str().unwrap()),\n                                      None);\n         if !auxres.status.success() {\n             fatal_proc_rec(\n-                format!(\"auxiliary build of {:?} failed to compile: \",\n-                        abs_ab.display()).as_slice(),\n+                &format!(\"auxiliary build of {:?} failed to compile: \",\n+                        abs_ab.display()),\n                 &auxres);\n         }\n \n-        match config.target.as_slice() {\n+        match &*config.target {\n             \"arm-linux-androideabi\" => {\n                 _arm_push_aux_shared_library(config, testfile);\n             }\n@@ -1217,7 +1211,7 @@ fn compose_and_run_compiler(\n                     testfile,\n                     args,\n                     Vec::new(),\n-                    config.compile_lib_path.as_slice(),\n+                    &config.compile_lib_path,\n                     Some(aux_dir.as_str().unwrap()),\n                     input)\n }\n@@ -1252,16 +1246,16 @@ fn make_compile_args<F>(config: &Config,\n {\n     let xform_file = xform(config, testfile);\n     let target = if props.force_host {\n-        config.host.as_slice()\n+        &*config.host\n     } else {\n-        config.target.as_slice()\n+        &*config.target\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let mut args = vec!(testfile.as_str().unwrap().to_string(),\n                         \"-L\".to_string(),\n                         config.build_base.as_str().unwrap().to_string(),\n                         format!(\"--target={}\", target));\n-    args.push_all(extras.as_slice());\n+    args.push_all(&extras);\n     if !props.no_prefer_dynamic {\n         args.push(\"-C\".to_string());\n         args.push(\"prefer-dynamic\".to_string());\n@@ -1329,7 +1323,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n fn split_maybe_args(argstr: &Option<String>) -> Vec<String> {\n     match *argstr {\n         Some(ref s) => {\n-            s.as_slice()\n+            s\n              .split(' ')\n              .filter_map(|s| {\n                  if s.chars().all(|c| c.is_whitespace()) {\n@@ -1350,8 +1344,8 @@ fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: String\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path,\n-                                       prog.as_slice(),\n-                                       args.as_slice());\n+                                       &prog,\n+                                       &args);\n             logv(config, format!(\"executing {}\", cmdline));\n             cmdline\n         };\n@@ -1360,12 +1354,12 @@ fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: String\n         err,\n         status\n     } = procsrv::run(lib_path,\n-                     prog.as_slice(),\n+                     &prog,\n                      aux_path,\n-                     args.as_slice(),\n+                     &args,\n                      env,\n-                     input).expect(format!(\"failed to exec `{}`\", prog).as_slice());\n-    dump_output(config, testfile, out.as_slice(), err.as_slice());\n+                     input).expect(&format!(\"failed to exec `{}`\", prog));\n+    dump_output(config, testfile, &out, &err);\n     return ProcRes {\n         status: status,\n         stdout: out,\n@@ -1422,7 +1416,7 @@ fn output_testname(testfile: &Path) -> Path {\n fn output_base_name(config: &Config, testfile: &Path) -> Path {\n     config.build_base\n         .join(&output_testname(testfile))\n-        .with_extension(config.stage_id.as_slice())\n+        .with_extension(&config.stage_id)\n }\n \n fn maybe_dump_to_stdout(config: &Config, out: &str, err: &str) {\n@@ -1465,20 +1459,19 @@ fn _arm_exec_compiled_test(config: &Config,\n                            -> ProcRes {\n     let args = make_run_args(config, props, testfile);\n     let cmdline = make_cmdline(\"\",\n-                               args.prog.as_slice(),\n-                               args.args.as_slice());\n+                               &args.prog,\n+                               &args.args);\n \n     // get bare program string\n     let mut tvec: Vec<String> = args.prog\n-                                    .as_slice()\n                                     .split('/')\n                                     .map(|ts| ts.to_string())\n                                     .collect();\n     let prog_short = tvec.pop().unwrap();\n \n     // copy to target\n     let copy_result = procsrv::run(\"\",\n-                                   config.adb_path.as_slice(),\n+                                   &config.adb_path,\n                                    None,\n                                    &[\n                                     \"push\".to_string(),\n@@ -1487,7 +1480,7 @@ fn _arm_exec_compiled_test(config: &Config,\n                                    ],\n                                    vec!((\"\".to_string(), \"\".to_string())),\n                                    Some(\"\".to_string()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+        .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     if config.verbose {\n         println!(\"push ({}) {} {} {}\",\n@@ -1514,11 +1507,11 @@ fn _arm_exec_compiled_test(config: &Config,\n         runargs.push(tv.to_string());\n     }\n     procsrv::run(\"\",\n-                 config.adb_path.as_slice(),\n+                 &config.adb_path,\n                  None,\n-                 runargs.as_slice(),\n+                 &runargs,\n                  vec!((\"\".to_string(), \"\".to_string())), Some(\"\".to_string()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+        .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get exitcode of result\n     runargs = Vec::new();\n@@ -1528,12 +1521,12 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n         procsrv::run(\"\",\n-                     config.adb_path.as_slice(),\n+                     &config.adb_path,\n                      None,\n-                     runargs.as_slice(),\n+                     &runargs,\n                      vec!((\"\".to_string(), \"\".to_string())),\n                      Some(\"\".to_string()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+        .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     let mut exitcode: int = 0;\n     for c in exitcode_out.chars() {\n@@ -1552,12 +1545,12 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n         procsrv::run(\"\",\n-                     config.adb_path.as_slice(),\n+                     &config.adb_path,\n                      None,\n-                     runargs.as_slice(),\n+                     &runargs,\n                      vec!((\"\".to_string(), \"\".to_string())),\n                      Some(\"\".to_string()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+        .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get stderr of result\n     runargs = Vec::new();\n@@ -1567,17 +1560,17 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n         procsrv::run(\"\",\n-                     config.adb_path.as_slice(),\n+                     &config.adb_path,\n                      None,\n-                     runargs.as_slice(),\n+                     &runargs,\n                      vec!((\"\".to_string(), \"\".to_string())),\n                      Some(\"\".to_string()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+        .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n     dump_output(config,\n                 testfile,\n-                stdout_out.as_slice(),\n-                stderr_out.as_slice());\n+                &stdout_out,\n+                &stderr_out);\n \n     ProcRes {\n         status: process::ProcessExit::ExitStatus(exitcode),\n@@ -1595,7 +1588,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let copy_result = procsrv::run(\"\",\n-                                           config.adb_path.as_slice(),\n+                                           &config.adb_path,\n                                            None,\n                                            &[\n                                             \"push\".to_string(),\n@@ -1607,7 +1600,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n                                            vec!((\"\".to_string(),\n                                                  \"\".to_string())),\n                                            Some(\"\".to_string()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n+                .expect(&format!(\"failed to exec `{}`\", config.adb_path));\n \n             if config.verbose {\n                 println!(\"push ({}) {:?} {} {}\",\n@@ -1702,7 +1695,7 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n \n fn count_extracted_lines(p: &Path) -> uint {\n     let x = File::open(&p.with_extension(\"ll\")).read_to_end().unwrap();\n-    let x = str::from_utf8(x.as_slice()).unwrap();\n+    let x = str::from_utf8(&x).unwrap();\n     x.lines().count()\n }\n "}, {"sha": "75b56f54cccc79efc4a5c48f8bd246b8fc986960", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -179,7 +179,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>) -> TokenAn\n     let toknum = &s[content_end + 3 .. toknum_end];\n \n     let proto_tok = tokens.get(toknum).expect(format!(\"didn't find token {:?} in the map\",\n-                                                              toknum).as_slice());\n+                                                              toknum));\n \n     let nm = parse::token::intern(content);\n \n@@ -242,16 +242,16 @@ fn main() {\n \n     let args = std::os::args();\n \n-    let mut token_file = File::open(&Path::new(args[2].as_slice()));\n-    let token_map = parse_token_list(token_file.read_to_string().unwrap().as_slice());\n+    let mut token_file = File::open(&Path::new(args[2]));\n+    let token_map = parse_token_list(token_file.read_to_string().unwrap());\n \n     let mut stdin = std::io::stdin();\n     let mut lock = stdin.lock();\n     let lines = lock.lines();\n     let mut antlr_tokens = lines.map(|l| parse_antlr_token(l.unwrap().trim(),\n                                                                    &token_map));\n \n-    let code = File::open(&Path::new(args[1].as_slice())).unwrap().read_to_string().unwrap();\n+    let code = File::open(&Path::new(args[1])).unwrap().read_to_string().unwrap();\n     let options = config::basic_options();\n     let session = session::build_session(options, None,\n                                          syntax::diagnostics::registry::Registry::new(&[]));"}, {"sha": "c5c19ee56bf0cec2bb9b69894fffa66e1f1aa370", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -77,7 +77,7 @@ pub fn find_rand_n<M, T, I, F>(n: uint,\n         insert(map, *k);\n     }\n \n-    rng.shuffle(keys.as_mut_slice());\n+    rng.shuffle(&mut keys);\n \n     // measure\n     let mut i = 0;"}, {"sha": "c9b3f72526f8c5c0d2c09770f7887cb8fa712d91", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1910,7 +1910,7 @@ mod tests {\n     fn test_0_elements() {\n         let act = Bitv::new();\n         let exp = Vec::new();\n-        assert!(act.eq_vec(exp.as_slice()));\n+        assert!(act.eq_vec(&exp));\n         assert!(act.none() && act.all());\n     }\n "}, {"sha": "d93e61b91f20026a7c2a3a8fd8abf074d9bc7ba4", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1054,12 +1054,12 @@ mod tests {\n         // Non-empty to non-empty\n         let v = vec![1,2,3,4,5];\n         let u = vec![9,8,1,2,3,4,5];\n-        let mut m = list_from(v.as_slice());\n-        let mut n = list_from(u.as_slice());\n+        let mut m = list_from(&v);\n+        let mut n = list_from(&u);\n         m.append(&mut n);\n         check_links(&m);\n         let mut sum = v;\n-        sum.push_all(u.as_slice());\n+        sum.push_all(&u);\n         assert_eq!(sum.len(), m.len());\n         for elt in sum {\n             assert_eq!(m.pop_front(), Some(elt))\n@@ -1090,7 +1090,7 @@ mod tests {\n         // not singleton, forwards\n         {\n             let u = vec![1,2,3,4,5];\n-            let mut m = list_from(u.as_slice());\n+            let mut m = list_from(&u);\n             let mut n = m.split_off(2);\n             assert_eq!(m.len(), 2);\n             assert_eq!(n.len(), 3);\n@@ -1104,7 +1104,7 @@ mod tests {\n         // not singleton, backwards\n         {\n             let u = vec![1,2,3,4,5];\n-            let mut m = list_from(u.as_slice());\n+            let mut m = list_from(&u);\n             let mut n = m.split_off(4);\n             assert_eq!(m.len(), 4);\n             assert_eq!(n.len(), 1);"}, {"sha": "8721de1299fb2fc71e48f2bb0082ad72081e7ef6", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1528,7 +1528,7 @@ mod tests {\n         // Test on-stack from_fn.\n         let mut v = (0u..3).map(square).collect::<Vec<_>>();\n         {\n-            let v = v.as_slice();\n+            let v = v;\n             assert_eq!(v.len(), 3u);\n             assert_eq!(v[0], 0u);\n             assert_eq!(v[1], 1u);\n@@ -1538,7 +1538,7 @@ mod tests {\n         // Test on-heap from_fn.\n         v = (0u..5).map(square).collect::<Vec<_>>();\n         {\n-            let v = v.as_slice();\n+            let v = v;\n             assert_eq!(v.len(), 5u);\n             assert_eq!(v[0], 0u);\n             assert_eq!(v[1], 1u);\n@@ -1553,7 +1553,7 @@ mod tests {\n         // Test on-stack from_elem.\n         let mut v = vec![10u, 10u];\n         {\n-            let v = v.as_slice();\n+            let v = v;\n             assert_eq!(v.len(), 2u);\n             assert_eq!(v[0], 10u);\n             assert_eq!(v[1], 10u);\n@@ -1562,7 +1562,7 @@ mod tests {\n         // Test on-heap from_elem.\n         v = vec![20u, 20u, 20u, 20u, 20u, 20u];\n         {\n-            let v = v.as_slice();\n+            let v = v;\n             assert_eq!(v[0], 20u);\n             assert_eq!(v[1], 20u);\n             assert_eq!(v[2], 20u);\n@@ -1715,7 +1715,7 @@ mod tests {\n         let vec_fixed = [1, 2, 3, 4];\n         let v_a = vec_fixed[1u..vec_fixed.len()].to_vec();\n         assert_eq!(v_a.len(), 3u);\n-        let v_a = v_a.as_slice();\n+        let v_a = v_a;\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n@@ -1724,15 +1724,15 @@ mod tests {\n         let vec_stack: &[_] = &[1, 2, 3];\n         let v_b = vec_stack[1u..3u].to_vec();\n         assert_eq!(v_b.len(), 2u);\n-        let v_b = v_b.as_slice();\n+        let v_b = v_b;\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1, 2, 3, 4, 5, 6];\n         let v_d = vec_unique[1u..6u].to_vec();\n         assert_eq!(v_d.len(), 5u);\n-        let v_d = v_d.as_slice();\n+        let v_d = v_d;\n         assert_eq!(v_d[0], 2);\n         assert_eq!(v_d[1], 3);\n         assert_eq!(v_d[2], 4);\n@@ -1813,20 +1813,20 @@ mod tests {\n         let mut v = vec![];\n         v.push(1);\n         assert_eq!(v.len(), 1u);\n-        assert_eq!(v.as_slice()[0], 1);\n+        assert_eq!(v[0], 1);\n \n         // Test on-heap push().\n         v.push(2);\n         assert_eq!(v.len(), 2u);\n-        assert_eq!(v.as_slice()[0], 1);\n-        assert_eq!(v.as_slice()[1], 2);\n+        assert_eq!(v[0], 1);\n+        assert_eq!(v[1], 2);\n     }\n \n     #[test]\n     fn test_truncate() {\n         let mut v = vec![box 6,box 5,box 4];\n         v.truncate(1);\n-        let v = v.as_slice();\n+        let v = v;\n         assert_eq!(v.len(), 1);\n         assert_eq!(*(v[0]), 6);\n         // If the unsafe block didn't drop things properly, we blow up here.\n@@ -2587,7 +2587,7 @@ mod tests {\n             ($x:expr, $x_str:expr) => ({\n                 let (x, x_str) = ($x, $x_str);\n                 assert_eq!(format!(\"{:?}\", x), x_str);\n-                assert_eq!(format!(\"{:?}\", x.as_slice()), x_str);\n+                assert_eq!(format!(\"{:?}\", x), x_str);\n             })\n         }\n         let empty: Vec<int> = vec![];\n@@ -2910,15 +2910,15 @@ mod bench {\n     fn starts_with_same_vector(b: &mut Bencher) {\n         let vec: Vec<uint> = (0u..100).collect();\n         b.iter(|| {\n-            vec.starts_with(vec.as_slice())\n+            vec.starts_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn starts_with_single_element(b: &mut Bencher) {\n         let vec: Vec<uint> = vec![0];\n         b.iter(|| {\n-            vec.starts_with(vec.as_slice())\n+            vec.starts_with(&vec)\n         })\n     }\n \n@@ -2928,33 +2928,33 @@ mod bench {\n         let mut match_vec: Vec<uint> = (0u..99).collect();\n         match_vec.push(0);\n         b.iter(|| {\n-            vec.starts_with(match_vec.as_slice())\n+            vec.starts_with(&match_vec)\n         })\n     }\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n         let vec: Vec<uint> = (0u..100).collect();\n         b.iter(|| {\n-            vec.ends_with(vec.as_slice())\n+            vec.ends_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn ends_with_single_element(b: &mut Bencher) {\n         let vec: Vec<uint> = vec![0];\n         b.iter(|| {\n-            vec.ends_with(vec.as_slice())\n+            vec.ends_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n         let vec: Vec<uint> = (0u..100).collect();\n         let mut match_vec: Vec<uint> = (0u..100).collect();\n-        match_vec.as_mut_slice()[0] = 200;\n+        match_vec[0] = 200;\n         b.iter(|| {\n-            vec.starts_with(match_vec.as_slice())\n+            vec.starts_with(&match_vec)\n         })\n     }\n \n@@ -3042,7 +3042,7 @@ mod bench {\n         let mut rng = weak_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<u64>().take(5).collect::<Vec<u64>>();\n-            v.as_mut_slice().sort();\n+            v.sort();\n         });\n         b.bytes = 5 * mem::size_of::<u64>() as u64;\n     }\n@@ -3052,7 +3052,7 @@ mod bench {\n         let mut rng = weak_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<u64>().take(100).collect::<Vec<u64>>();\n-            v.as_mut_slice().sort();\n+            v.sort();\n         });\n         b.bytes = 100 * mem::size_of::<u64>() as u64;\n     }\n@@ -3062,7 +3062,7 @@ mod bench {\n         let mut rng = weak_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<u64>().take(10000).collect::<Vec<u64>>();\n-            v.as_mut_slice().sort();\n+            v.sort();\n         });\n         b.bytes = 10000 * mem::size_of::<u64>() as u64;\n     }"}, {"sha": "336d9fcf5da1eb9b0419d64e459fe8db3cfa8514", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -203,7 +203,7 @@ impl<'a> Iterator for Decompositions<'a> {\n                         let class =\n                             unicode::char::canonical_combining_class(d);\n                         if class == 0 && !*sorted {\n-                            canonical_sort(buffer.as_mut_slice());\n+                            canonical_sort(buffer);\n                             *sorted = true;\n                         }\n                         buffer.push((d, class));\n@@ -224,7 +224,7 @@ impl<'a> Iterator for Decompositions<'a> {\n         }\n \n         if !self.sorted {\n-            canonical_sort(self.buffer.as_mut_slice());\n+            canonical_sort(&mut self.buffer);\n             self.sorted = true;\n         }\n \n@@ -1480,7 +1480,7 @@ mod tests {\n     fn test_concat_for_different_types() {\n         test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n         test_concat!(\"ab\", vec![\"a\", \"b\"]);\n-        test_concat!(\"ab\", vec![\"a\", \"b\"].as_slice());\n+        test_concat!(\"ab\", vec![\"a\", \"b\"]);\n         test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n     }\n \n@@ -1506,9 +1506,9 @@ mod tests {\n     fn test_connect_for_different_types() {\n         test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n         let hyphen = \"-\".to_string();\n-        test_connect!(\"a-b\", [s(\"a\"), s(\"b\")], hyphen.as_slice());\n-        test_connect!(\"a-b\", vec![\"a\", \"b\"], hyphen.as_slice());\n-        test_connect!(\"a-b\", vec![\"a\", \"b\"].as_slice(), \"-\");\n+        test_connect!(\"a-b\", [s(\"a\"), s(\"b\")], &*hyphen);\n+        test_connect!(\"a-b\", vec![\"a\", \"b\"], &*hyphen);\n+        test_connect!(\"a-b\", &*vec![\"a\", \"b\"], \"-\");\n         test_connect!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n     }\n \n@@ -1960,7 +1960,7 @@ mod tests {\n         let s1: String = String::from_str(\"All mimsy were the borogoves\");\n \n         let v: Vec<u8> = s1.as_bytes().to_vec();\n-        let s2: String = String::from_str(from_utf8(v.as_slice()).unwrap());\n+        let s2: String = String::from_str(from_utf8(&v).unwrap());\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n         let n2: uint = v.len();\n@@ -2791,11 +2791,11 @@ mod tests {\n \n         let s = String::from_str(\"01234\");\n         assert_eq!(5, sum_len(&[\"012\", \"\", \"34\"]));\n-        assert_eq!(5, sum_len(&[String::from_str(\"01\").as_slice(),\n-                                String::from_str(\"2\").as_slice(),\n-                                String::from_str(\"34\").as_slice(),\n-                                String::from_str(\"\").as_slice()]));\n-        assert_eq!(5, sum_len(&[s.as_slice()]));\n+        assert_eq!(5, sum_len(&[&String::from_str(\"01\"),\n+                                &String::from_str(\"2\"),\n+                                &String::from_str(\"34\"),\n+                                &String::from_str(\"\")]));\n+        assert_eq!(5, sum_len(&[&s]));\n     }\n \n     #[test]"}, {"sha": "a96ab40dd708fef1dfd30ea331b5eedd7ca5cd57", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -126,7 +126,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n-        match str::from_utf8(vec.as_slice()) {\n+        match str::from_utf8(&vec) {\n             Ok(..) => Ok(String { vec: vec }),\n             Err(e) => Err(FromUtf8Error { bytes: vec, error: e })\n         }\n@@ -489,7 +489,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.vec.as_slice()\n+        &self.vec\n     }\n \n     /// Shortens a string to the specified length.\n@@ -804,7 +804,7 @@ impl Str for String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a str {\n-        unsafe { mem::transmute(self.vec.as_slice()) }\n+        unsafe { mem::transmute(&*self.vec) }\n     }\n }\n \n@@ -882,7 +882,7 @@ impl ops::Index<ops::RangeFull> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, _index: &ops::RangeFull) -> &str {\n-        unsafe { mem::transmute(self.vec.as_slice()) }\n+        unsafe { mem::transmute(&*self.vec) }\n     }\n }\n \n@@ -980,7 +980,7 @@ pub type CowString<'a> = Cow<'a, String, str>;\n impl<'a> Str for CowString<'a> {\n     #[inline]\n     fn as_slice<'b>(&'b self) -> &'b str {\n-        (**self).as_slice()\n+        &**self\n     }\n }\n \n@@ -1005,13 +1005,13 @@ mod tests {\n     #[test]\n     fn test_as_string() {\n         let x = \"foo\";\n-        assert_eq!(x, as_string(x).as_slice());\n+        assert_eq!(x, &**as_string(x));\n     }\n \n     #[test]\n     fn test_from_str() {\n       let owned: Option<::std::string::String> = \"string\".parse().ok();\n-      assert_eq!(owned.as_ref().map(|s| s.as_slice()), Some(\"string\"));\n+      assert_eq!(owned.as_ref().map(|s| &**s), Some(\"string\"));\n     }\n \n     #[test]\n@@ -1121,15 +1121,15 @@ mod tests {\n         for p in &pairs {\n             let (s, u) = (*p).clone();\n             let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n-            let u_as_string = String::from_utf16(u.as_slice()).unwrap();\n+            let u_as_string = String::from_utf16(&u).unwrap();\n \n-            assert!(::unicode::str::is_utf16(u.as_slice()));\n+            assert!(::unicode::str::is_utf16(&u));\n             assert_eq!(s_as_utf16, u);\n \n             assert_eq!(u_as_string, s);\n-            assert_eq!(String::from_utf16_lossy(u.as_slice()), s);\n+            assert_eq!(String::from_utf16_lossy(&u), s);\n \n-            assert_eq!(String::from_utf16(s_as_utf16.as_slice()).unwrap(), s);\n+            assert_eq!(String::from_utf16(&s_as_utf16).unwrap(), s);\n             assert_eq!(u_as_string.utf16_units().collect::<Vec<u16>>(), u);\n         }\n     }\n@@ -1419,7 +1419,7 @@ mod tests {\n     fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n         let s = repeat(0xf5u8).take(100).collect::<Vec<_>>();\n         b.iter(|| {\n-            let _ = String::from_utf8_lossy(s.as_slice());\n+            let _ = String::from_utf8_lossy(&s);\n         });\n     }\n "}, {"sha": "8218469d6afb58e637e5c0e192192a993c8fc773", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -382,7 +382,7 @@ impl<T> Vec<T> {\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         self.shrink_to_fit();\n         unsafe {\n-            let xs: Box<[T]> = mem::transmute(self.as_mut_slice());\n+            let xs: Box<[T]> = mem::transmute(&mut *self);\n             mem::forget(self);\n             xs\n         }\n@@ -604,7 +604,7 @@ impl<T> Vec<T> {\n         let len = self.len();\n         let mut del = 0u;\n         {\n-            let v = self.as_mut_slice();\n+            let v = &mut **self;\n \n             for i in 0u..len {\n                 if !f(&v[i]) {\n@@ -1246,7 +1246,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n \n #[unstable(feature = \"collections\")]\n impl<T:Clone> Clone for Vec<T> {\n-    fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(self.as_slice()) }\n+    fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(&**self) }\n \n     fn clone_from(&mut self, other: &Vec<T>) {\n         // drop anything in self that will not be overwritten\n@@ -1269,7 +1269,7 @@ impl<T:Clone> Clone for Vec<T> {\n impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n+        Hash::hash(&**self, state)\n     }\n }\n \n@@ -1279,7 +1279,8 @@ impl<T> Index<uint> for Vec<T> {\n \n     #[inline]\n     fn index<'a>(&'a self, index: &uint) -> &'a T {\n-        &self.as_slice()[*index]\n+        // NB built-in indexing via `&[T]`\n+        &(**self)[*index]\n     }\n }\n \n@@ -1289,7 +1290,8 @@ impl<T> IndexMut<uint> for Vec<T> {\n \n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n-        &mut self.as_mut_slice()[*index]\n+        // NB built-in indexing via `&mut [T]`\n+        &mut (**self)[*index]\n     }\n }\n \n@@ -1299,23 +1301,23 @@ impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n-        self.as_slice().index(index)\n+        Index::index(&**self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n-        self.as_slice().index(index)\n+        Index::index(&**self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n-        self.as_slice().index(index)\n+        Index::index(&**self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1332,23 +1334,23 @@ impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n-        self.as_mut_slice().index_mut(index)\n+        IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n-        self.as_mut_slice().index_mut(index)\n+        IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n-        self.as_mut_slice().index_mut(index)\n+        IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1489,7 +1491,7 @@ impl_eq_for_cowvec! { &'b mut [B] }\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n-        self.as_slice().partial_cmp(other.as_slice())\n+        PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n@@ -1500,7 +1502,7 @@ impl<T: Eq> Eq for Vec<T> {}\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n-        self.as_slice().cmp(other.as_slice())\n+        Ord::cmp(&**self, &**other)\n     }\n }\n \n@@ -1567,7 +1569,7 @@ impl<T> Default for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(self.as_slice(), f)\n+        fmt::Debug::fmt(&**self, f)\n     }\n }\n \n@@ -1931,7 +1933,7 @@ mod tests {\n     #[test]\n     fn test_as_vec() {\n         let xs = [1u8, 2u8, 3u8];\n-        assert_eq!(as_vec(&xs).as_slice(), xs);\n+        assert_eq!(&**as_vec(&xs), xs);\n     }\n \n     #[test]\n@@ -2396,7 +2398,7 @@ mod tests {\n     fn test_into_boxed_slice() {\n         let xs = vec![1u, 2, 3];\n         let ys = xs.into_boxed_slice();\n-        assert_eq!(ys.as_slice(), [1u, 2, 3]);\n+        assert_eq!(ys, [1u, 2, 3]);\n     }\n \n     #[test]\n@@ -2636,7 +2638,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut dst = dst.clone();\n-            dst.push_all(src.as_slice());\n+            dst.push_all(&src);\n             assert_eq!(dst.len(), dst_len + src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });"}, {"sha": "a5d2618eff948959e881f655beaa839d75b4536d", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -123,7 +123,7 @@ macro_rules! impl_hash {\n                 let a: [u8; ::$ty::BYTES] = unsafe {\n                     mem::transmute((*self as $uty).to_le() as $ty)\n                 };\n-                state.write(a.as_slice())\n+                state.write(&a)\n             }\n         }\n     }"}, {"sha": "9ba9c2c4a9ca57599a0d12ea8f43625294660520", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -166,7 +166,7 @@ fn test_escape_unicode() {\n fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8; 4];\n-        let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n+        let n = input.encode_utf8(&mut buf).unwrap_or(0);\n         assert_eq!(&buf[..n], expect);\n     }\n \n@@ -180,7 +180,7 @@ fn test_encode_utf8() {\n fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16; 2];\n-        let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n+        let n = input.encode_utf16(&mut buf).unwrap_or(0);\n         assert_eq!(&buf[..n], expect);\n     }\n "}, {"sha": "248cad32ef4d24c7af645dc16543d783bf9cf682", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -110,7 +110,7 @@ fn test_siphash() {\n     fn to_hex_str(r: &[u8; 8]) -> String {\n         let mut s = String::new();\n         for b in r {\n-            s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n+            s.push_str(format!(\"{}\", fmt::radix(*b, 16)));\n         }\n         s\n     }\n@@ -131,20 +131,20 @@ fn test_siphash() {\n         let r = result_bytes(h);\n         let mut s = String::new();\n         for b in &r {\n-            s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n+            s.push_str(format!(\"{}\", fmt::radix(*b, 16)));\n         }\n         s\n     }\n \n     while t < 64 {\n         debug!(\"siphash test {}: {}\", t, buf);\n         let vec = u8to64_le!(vecs[t], 0);\n-        let out = hash_with_keys(k0, k1, &Bytes(buf.as_slice()));\n+        let out = hash_with_keys(k0, k1, &Bytes(buf));\n         debug!(\"got {}, expected {}\", out, vec);\n         assert_eq!(vec, out);\n \n         state_full.reset();\n-        state_full.write(buf.as_slice());\n+        state_full.write(buf);\n         let f = result_str(state_full.result());\n         let i = result_str(state_inc.result());\n         let v = to_hex_str(&vecs[t]);"}, {"sha": "1739475336539bb3d934b0c07907027113f7c2ec", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -147,24 +147,24 @@ mod tests {\n         for _ in 0..20 {\n             let mut input = vec![];\n             for _ in 0..2000 {\n-                input.push_all(r.choose(words.as_slice()).unwrap().as_slice());\n+                input.push_all(r.choose(&words).unwrap());\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n-            let cmp = deflate_bytes(input.as_slice()).expect(\"deflation failed\");\n-            let out = inflate_bytes(cmp.as_slice()).expect(\"inflation failed\");\n+            let cmp = deflate_bytes(&input).expect(\"deflation failed\");\n+            let out = inflate_bytes(&cmp).expect(\"inflation failed\");\n             debug!(\"{} bytes deflated to {} ({:.1}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n-            assert_eq!(input, out.as_slice());\n+            assert_eq!(&*input, &*out);\n         }\n     }\n \n     #[test]\n     fn test_zlib_flate() {\n         let bytes = vec!(1, 2, 3, 4, 5);\n-        let deflated = deflate_bytes(bytes.as_slice()).expect(\"deflation failed\");\n-        let inflated = inflate_bytes(deflated.as_slice()).expect(\"inflation failed\");\n-        assert_eq!(inflated.as_slice(), bytes);\n+        let deflated = deflate_bytes(&bytes).expect(\"deflation failed\");\n+        let inflated = inflate_bytes(&deflated).expect(\"inflation failed\");\n+        assert_eq!(&*inflated, &*bytes);\n     }\n }"}, {"sha": "1b30bdf230ec127b8af67e203f0bc4dd4f0fb468", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -316,7 +316,7 @@ impl Matches {\n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[String]) -> bool {\n         for nm in names {\n-            match find_opt(self.opts.as_slice(), Name::from_str(&nm[])) {\n+            match find_opt(&self.opts, Name::from_str(&**nm)) {\n                 Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n             };\n@@ -627,7 +627,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                        interpreted correctly\n                     */\n \n-                    let opt_id = match find_opt(opts.as_slice(), opt.clone()) {\n+                    let opt_id = match find_opt(&opts, opt.clone()) {\n                       Some(id) => id,\n                       None => return Err(UnrecognizedOption(opt.to_string()))\n                     };\n@@ -650,7 +650,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             let mut name_pos = 0;\n             for nm in &names {\n                 name_pos += 1;\n-                let optid = match find_opt(opts.as_slice(), (*nm).clone()) {\n+                let optid = match find_opt(&opts, (*nm).clone()) {\n                   Some(id) => id,\n                   None => return Err(UnrecognizedOption(nm.to_string()))\n                 };\n@@ -981,7 +981,7 @@ mod tests {\n     fn test_reqopt() {\n         let long_args = vec!(\"--test=20\".to_string());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(long_args.as_slice(), opts.as_slice());\n+        let rs = getopts(&long_args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n@@ -992,7 +992,7 @@ mod tests {\n           _ => { panic!(\"test_reqopt failed (long arg)\"); }\n         }\n         let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n-        match getopts(short_args.as_slice(), opts.as_slice()) {\n+        match getopts(&short_args, &opts) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n             assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n@@ -1007,7 +1007,7 @@ mod tests {\n     fn test_reqopt_missing() {\n         let args = vec!(\"blah\".to_string());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Err(OptionMissing(_)) => {},\n           _ => panic!()\n@@ -1018,13 +1018,13 @@ mod tests {\n     fn test_reqopt_no_arg() {\n         let long_args = vec!(\"--test\".to_string());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(long_args.as_slice(), opts.as_slice());\n+        let rs = getopts(&long_args, &opts);\n         match rs {\n           Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n-        match getopts(short_args.as_slice(), opts.as_slice()) {\n+        match getopts(&short_args, &opts) {\n           Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n@@ -1034,7 +1034,7 @@ mod tests {\n     fn test_reqopt_multi() {\n         let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Err(OptionDuplicated(_)) => {},\n           _ => panic!()\n@@ -1046,7 +1046,7 @@ mod tests {\n     fn test_optopt() {\n         let long_args = vec!(\"--test=20\".to_string());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(long_args.as_slice(), opts.as_slice());\n+        let rs = getopts(&long_args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n@@ -1057,7 +1057,7 @@ mod tests {\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n-        match getopts(short_args.as_slice(), opts.as_slice()) {\n+        match getopts(&short_args, &opts) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n             assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n@@ -1072,7 +1072,7 @@ mod tests {\n     fn test_optopt_missing() {\n         let args = vec!(\"blah\".to_string());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(!m.opt_present(\"test\"));\n@@ -1086,13 +1086,13 @@ mod tests {\n     fn test_optopt_no_arg() {\n         let long_args = vec!(\"--test\".to_string());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(long_args.as_slice(), opts.as_slice());\n+        let rs = getopts(&long_args, &opts);\n         match rs {\n           Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n-        match getopts(short_args.as_slice(), opts.as_slice()) {\n+        match getopts(&short_args, &opts) {\n           Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n@@ -1102,7 +1102,7 @@ mod tests {\n     fn test_optopt_multi() {\n         let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Err(OptionDuplicated(_)) => {},\n           _ => panic!()\n@@ -1114,7 +1114,7 @@ mod tests {\n     fn test_optflag() {\n         let long_args = vec!(\"--test\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n-        let rs = getopts(long_args.as_slice(), opts.as_slice());\n+        let rs = getopts(&long_args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n@@ -1123,7 +1123,7 @@ mod tests {\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n-        match getopts(short_args.as_slice(), opts.as_slice()) {\n+        match getopts(&short_args, &opts) {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n             assert!(m.opt_present(\"t\"));\n@@ -1136,7 +1136,7 @@ mod tests {\n     fn test_optflag_missing() {\n         let args = vec!(\"blah\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(!m.opt_present(\"test\"));\n@@ -1150,7 +1150,7 @@ mod tests {\n     fn test_optflag_long_arg() {\n         let args = vec!(\"--test=20\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Err(UnexpectedArgument(_)) => {},\n           _ => panic!()\n@@ -1161,7 +1161,7 @@ mod tests {\n     fn test_optflag_multi() {\n         let args = vec!(\"--test\".to_string(), \"-t\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Err(OptionDuplicated(_)) => {},\n           _ => panic!()\n@@ -1172,7 +1172,7 @@ mod tests {\n     fn test_optflag_short_arg() {\n         let args = vec!(\"-t\".to_string(), \"20\".to_string());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n@@ -1188,7 +1188,7 @@ mod tests {\n     fn test_optflagmulti_short1() {\n         let args = vec!(\"-v\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 1);\n@@ -1201,7 +1201,7 @@ mod tests {\n     fn test_optflagmulti_short2a() {\n         let args = vec!(\"-v\".to_string(), \"-v\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n@@ -1214,7 +1214,7 @@ mod tests {\n     fn test_optflagmulti_short2b() {\n         let args = vec!(\"-vv\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n@@ -1227,7 +1227,7 @@ mod tests {\n     fn test_optflagmulti_long1() {\n         let args = vec!(\"--verbose\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 1);\n@@ -1240,7 +1240,7 @@ mod tests {\n     fn test_optflagmulti_long2() {\n         let args = vec!(\"--verbose\".to_string(), \"--verbose\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 2);\n@@ -1254,7 +1254,7 @@ mod tests {\n         let args = vec!(\"--verbose\".to_string(), \"-v\".to_string(),\n                         \"-vv\".to_string(), \"verbose\".to_string());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 4);\n@@ -1269,7 +1269,7 @@ mod tests {\n     fn test_optmulti() {\n         let long_args = vec!(\"--test=20\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(long_args.as_slice(), opts.as_slice());\n+        let rs = getopts(&long_args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n@@ -1280,7 +1280,7 @@ mod tests {\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n-        match getopts(short_args.as_slice(), opts.as_slice()) {\n+        match getopts(&short_args, &opts) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n             assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n@@ -1295,7 +1295,7 @@ mod tests {\n     fn test_optmulti_missing() {\n         let args = vec!(\"blah\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(!m.opt_present(\"test\"));\n@@ -1309,13 +1309,13 @@ mod tests {\n     fn test_optmulti_no_arg() {\n         let long_args = vec!(\"--test\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(long_args.as_slice(), opts.as_slice());\n+        let rs = getopts(&long_args, &opts);\n         match rs {\n           Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n-        match getopts(short_args.as_slice(), opts.as_slice()) {\n+        match getopts(&short_args, &opts) {\n           Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n@@ -1325,7 +1325,7 @@ mod tests {\n     fn test_optmulti_multi() {\n         let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n               assert!(m.opt_present(\"test\"));\n@@ -1344,13 +1344,13 @@ mod tests {\n     fn test_unrecognized_option() {\n         let long_args = vec!(\"--untest\".to_string());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n-        let rs = getopts(long_args.as_slice(), opts.as_slice());\n+        let rs = getopts(&long_args, &opts);\n         match rs {\n           Err(UnrecognizedOption(_)) => {},\n           _ => panic!()\n         }\n         let short_args = vec!(\"-u\".to_string());\n-        match getopts(short_args.as_slice(), opts.as_slice()) {\n+        match getopts(&short_args, &opts) {\n           Err(UnrecognizedOption(_)) => {},\n           _ => panic!()\n         }\n@@ -1383,7 +1383,7 @@ mod tests {\n               optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n               optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n               optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\"));\n-        let rs = getopts(args.as_slice(), opts.as_slice());\n+        let rs = getopts(&args, &opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(m.free[0] == \"prog\");\n@@ -1412,8 +1412,7 @@ mod tests {\n                      optopt(\"f\", \"\", \"flag\", \"FLAG\"));\n \n         let args_single = vec!(\"-e\".to_string(), \"foo\".to_string());\n-        let matches_single = &match getopts(args_single.as_slice(),\n-                                            opts.as_slice()) {\n+        let matches_single = &match getopts(&args_single, &opts) {\n           result::Result::Ok(m) => m,\n           result::Result::Err(_) => panic!()\n         };\n@@ -1432,8 +1431,7 @@ mod tests {\n \n         let args_both = vec!(\"-e\".to_string(), \"foo\".to_string(), \"--encrypt\".to_string(),\n                              \"foo\".to_string());\n-        let matches_both = &match getopts(args_both.as_slice(),\n-                                          opts.as_slice()) {\n+        let matches_both = &match getopts(&args_both, &opts) {\n           result::Result::Ok(m) => m,\n           result::Result::Err(_) => panic!()\n         };\n@@ -1458,7 +1456,7 @@ mod tests {\n         let args = vec!(\"-Lfoo\".to_string(), \"-M.\".to_string());\n         let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n                      optmulti(\"M\", \"\", \"something\", \"MMMM\"));\n-        let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n+        let matches = &match getopts(&args, &opts) {\n           result::Result::Ok(m) => m,\n           result::Result::Err(_) => panic!()\n         };\n@@ -1474,7 +1472,7 @@ mod tests {\n         let args = vec!(\"-vvLverbose\".to_string(), \"-v\".to_string() );\n         let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n                      optflagmulti(\"v\", \"verbose\", \"Verbose\"));\n-        let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n+        let matches = &match getopts(&args, &opts) {\n           result::Result::Ok(m) => m,\n           result::Result::Err(e) => panic!( \"{}\", e )\n         };\n@@ -1508,7 +1506,7 @@ mod tests {\n \n         let args = vec!(\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string());\n \n-        let matches = getopts(args.as_slice(), opts.as_slice()).unwrap();\n+        let matches = getopts(&args, &opts).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n         assert_eq!(3, matches.opt_count(\"apple\"));\n     }\n@@ -1535,7 +1533,7 @@ Options:\n     -l VAL              Desc\n \";\n \n-        let generated_usage = usage(\"Usage: fruits\", optgroups.as_slice());\n+        let generated_usage = usage(\"Usage: fruits\", &optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", generated_usage);\n@@ -1562,7 +1560,7 @@ Options:\n                         wrapped..+..\n \";\n \n-        let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n+        let usage = usage(\"Usage: fruits\", &optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", usage);\n@@ -1588,7 +1586,7 @@ Options:\n                         some parts of Europe.\n \";\n \n-        let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n+        let usage = usage(\"Usage: fruits\", &optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", usage);\n@@ -1606,7 +1604,7 @@ Options:\n             optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n \n         let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_string();\n-        let generated_usage = short_usage(\"fruits\", optgroups.as_slice());\n+        let generated_usage = short_usage(\"fruits\", &optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", generated_usage);"}, {"sha": "069e4ccf41d7db0a4961a1517fa44b71ef3cc7c0", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -565,7 +565,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n         } else {\n             let escaped = g.node_label(n).escape();\n             try!(writeln(w, &[id.as_slice(),\n-                              \"[label=\\\"\", escaped.as_slice(), \"\\\"];\"]));\n+                              \"[label=\\\"\", &escaped, \"\\\"];\"]));\n         }\n     }\n \n@@ -582,7 +582,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n         } else {\n             try!(writeln(w, &[source_id.as_slice(),\n                               \" -> \", target_id.as_slice(),\n-                              \"[label=\\\"\", escaped_label.as_slice(), \"\\\"];\"]));\n+                              \"[label=\\\"\", &escaped_label, \"\\\"];\"]));\n         }\n     }\n \n@@ -746,7 +746,7 @@ mod tests {\n     fn test_input(g: LabelledGraph) -> IoResult<String> {\n         let mut writer = Vec::new();\n         render(&g, &mut writer).unwrap();\n-        (&mut writer.as_slice()).read_to_string()\n+        (&mut &*writer).read_to_string()\n     }\n \n     // All of the tests use raw-strings as the format for the expected outputs,\n@@ -858,7 +858,7 @@ r#\"digraph hasse_diagram {\n                  edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n \n         render(&g, &mut writer).unwrap();\n-        let r = (&mut writer.as_slice()).read_to_string();\n+        let r = (&mut &*writer).read_to_string();\n \n         assert_eq!(r.unwrap(),\n r#\"digraph syntax_tree {"}, {"sha": "2673649f3440cc9170cff3d79e4d0cd556d418b8", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -213,8 +213,8 @@ mod test {\n     #[test]\n     fn test_rng_rand_seeded() {\n         let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n-        let mut ra: ChaChaRng = SeedableRng::from_seed(s.as_slice());\n-        let mut rb: ChaChaRng = SeedableRng::from_seed(s.as_slice());\n+        let mut ra: ChaChaRng = SeedableRng::from_seed(&*s);\n+        let mut rb: ChaChaRng = SeedableRng::from_seed(&*s);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n                               rb.gen_ascii_chars().take(100)));\n     }\n@@ -231,10 +231,10 @@ mod test {\n     #[test]\n     fn test_rng_reseed() {\n         let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n-        let mut r: ChaChaRng = SeedableRng::from_seed(s.as_slice());\n+        let mut r: ChaChaRng = SeedableRng::from_seed(&*s);\n         let string1: String = r.gen_ascii_chars().take(100).collect();\n \n-        r.reseed(s.as_slice());\n+        r.reseed(&s);\n \n         let string2: String = r.gen_ascii_chars().take(100).collect();\n         assert_eq!(string1, string2);"}, {"sha": "d1d24cea8714e7c1b4fe544c9dfaf363b9903cb7", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -300,7 +300,7 @@ mod tests {\n         macro_rules! t {\n             ($items:expr, $expected:expr) => {{\n                 let mut items = $items;\n-                let wc = WeightedChoice::new(items.as_mut_slice());\n+                let wc = WeightedChoice::new(&mut items);\n                 let expected = $expected;\n \n                 let mut rng = CountingRng { i: 0 };"}, {"sha": "9361cddd2a19db065459caefdedde95d61d8a13e", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -514,16 +514,16 @@ mod test {\n     #[test]\n     fn test_rng_32_rand_seeded() {\n         let s = ::test::rng().gen_iter::<u32>().take(256).collect::<Vec<u32>>();\n-        let mut ra: IsaacRng = SeedableRng::from_seed(s.as_slice());\n-        let mut rb: IsaacRng = SeedableRng::from_seed(s.as_slice());\n+        let mut ra: IsaacRng = SeedableRng::from_seed(&*s);\n+        let mut rb: IsaacRng = SeedableRng::from_seed(&*s);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n                               rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_rand_seeded() {\n         let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n-        let mut ra: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n-        let mut rb: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n+        let mut ra: Isaac64Rng = SeedableRng::from_seed(&*s);\n+        let mut rb: Isaac64Rng = SeedableRng::from_seed(&*s);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n                               rb.gen_ascii_chars().take(100)));\n     }\n@@ -548,21 +548,21 @@ mod test {\n     #[test]\n     fn test_rng_32_reseed() {\n         let s = ::test::rng().gen_iter::<u32>().take(256).collect::<Vec<u32>>();\n-        let mut r: IsaacRng = SeedableRng::from_seed(s.as_slice());\n+        let mut r: IsaacRng = SeedableRng::from_seed(&*s);\n         let string1: String = r.gen_ascii_chars().take(100).collect();\n \n-        r.reseed(s.as_slice());\n+        r.reseed(&s);\n \n         let string2: String = r.gen_ascii_chars().take(100).collect();\n         assert_eq!(string1, string2);\n     }\n     #[test]\n     fn test_rng_64_reseed() {\n         let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n-        let mut r: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n+        let mut r: Isaac64Rng = SeedableRng::from_seed(&*s);\n         let string1: String = r.gen_ascii_chars().take(100).collect();\n \n-        r.reseed(s.as_slice());\n+        r.reseed(&s);\n \n         let string2: String = r.gen_ascii_chars().take(100).collect();\n         assert_eq!(string1, string2);"}, {"sha": "b18e36da7ea39adde21f7f13436538ff42868a6d", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -504,6 +504,7 @@ mod std {\n     pub use core::marker;\n     // for-loops\n     pub use core::iter;\n+    pub use core::ops; // slicing syntax\n }\n \n #[cfg(test)]"}, {"sha": "06828911471466d2e1e3eb58786eb04567aacf1a", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -216,7 +216,7 @@ mod test {\n     #[test]\n     fn test_rng_fill_bytes() {\n         let mut v = repeat(0u8).take(FILL_BYTES_V_LEN).collect::<Vec<_>>();\n-        ::test::rng().fill_bytes(v.as_mut_slice());\n+        ::test::rng().fill_bytes(&mut v);\n \n         // Sanity test: if we've gotten here, `fill_bytes` has not infinitely\n         // recursed."}, {"sha": "230fda11ab5ac58c9744787fd73a65826485e35c", "filename": "src/librbml/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -71,7 +71,7 @@ impl SeekableMemWriter {\n     /// No method is exposed for acquiring a mutable reference to the buffer\n     /// because it could corrupt the state of this `MemWriter`.\n     #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n+    pub fn get_ref<'a>(&'a self) -> &'a [u8] { &self.buf }\n \n     /// Unwraps this `SeekableMemWriter`, returning the underlying buffer\n     #[inline]\n@@ -190,7 +190,7 @@ mod tests {\n         b.iter(|| {\n             let mut wr = SeekableMemWriter::new();\n             for _ in 0..times {\n-                wr.write(src.as_slice()).unwrap();\n+                wr.write(&src).unwrap();\n             }\n \n             let v = wr.unwrap();"}, {"sha": "e204a2a65958f450d6a415ddd582bb17ff700d34", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1194,7 +1194,7 @@ mod bench {\n         b.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n-                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n+                sum += reader::vuint_at(&data, i).unwrap().val;\n                 i += 4;\n             }\n         });\n@@ -1212,7 +1212,7 @@ mod bench {\n         b.iter(|| {\n             let mut i = 1;\n             while i < data.len() {\n-                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n+                sum += reader::vuint_at(&data, i).unwrap().val;\n                 i += 4;\n             }\n         });\n@@ -1231,7 +1231,7 @@ mod bench {\n         b.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n-                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n+                sum += reader::vuint_at(&data, i).unwrap().val;\n                 i += 4;\n             }\n         });\n@@ -1250,7 +1250,7 @@ mod bench {\n         b.iter(|| {\n             let mut i = 1;\n             while i < data.len() {\n-                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n+                sum += reader::vuint_at(&data, i).unwrap().val;\n                 i += 4;\n             }\n         });"}, {"sha": "34565383c5a761bfff06adbeb3cde8b87b010574", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1082,12 +1082,12 @@ impl NonUpperCaseGlobals {\n                                            .map(|c| c.to_uppercase()).collect();\n             if uc != s.get() {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    format!(\"{} `{}` should have an upper case name such as `{}`\",\n-                            sort, s, uc).as_slice());\n+                    &format!(\"{} `{}` should have an upper case name such as `{}`\",\n+                             sort, s, uc));\n             } else {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    format!(\"{} `{}` should have an upper case name\",\n-                            sort, s).as_slice());\n+                    &format!(\"{} `{}` should have an upper case name\",\n+                             sort, s));\n             }\n         }\n     }\n@@ -2084,11 +2084,11 @@ impl LintPass for PrivateNoMangleFns {\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         match it.node {\n             ast::ItemFn(..) => {\n-                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") &&\n+                if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                        !cx.exported_items.contains(&it.id) {\n                     let msg = format!(\"function {} is marked #[no_mangle], but not exported\",\n                                       it.ident);\n-                    cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, msg.as_slice());\n+                    cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, &msg);\n                 }\n             },\n             _ => {},"}, {"sha": "844ad2be264448120dc072b0b7fa0773e0081152", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -509,8 +509,8 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                                                       .collect(),\n                                 None => {\n                                     self.span_lint(builtin::UNKNOWN_LINTS, span,\n-                                               format!(\"unknown `{}` attribute: `{}`\",\n-                                                       level.as_str(), lint_name).as_slice());\n+                                                   &format!(\"unknown `{}` attribute: `{}`\",\n+                                                            level.as_str(), lint_name));\n                                     continue;\n                                 }\n                             }\n@@ -797,8 +797,8 @@ pub fn check_crate(tcx: &ty::ctxt,\n     for (id, v) in &*tcx.sess.lints.borrow() {\n         for &(lint, span, ref msg) in v {\n             tcx.sess.span_bug(span,\n-                              format!(\"unprocessed lint {} at {}: {}\",\n-                                      lint.as_str(), tcx.map.node_to_string(*id), *msg).as_slice())\n+                              &format!(\"unprocessed lint {} at {}: {}\",\n+                                       lint.as_str(), tcx.map.node_to_string(*id), *msg))\n         }\n     }\n "}, {"sha": "070ab248f24b2169f4f1fb5c26edbbdc7d11f28b", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -93,7 +93,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n     let mut r = vec![ast_map::PathMod(token::intern(&cdata.name[]))];\n-    r.push_all(path.as_slice());\n+    r.push_all(&path);\n     r\n }\n "}, {"sha": "5fb047ea93b602e14a18a5de448555122300df9c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1044,7 +1044,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_attributes(rbml_w, &item.attrs);\n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1307,7 +1307,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n         encode_unsafety(rbml_w, trait_def.unsafety);\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n-        encode_associated_type_names(rbml_w, trait_def.associated_type_names.as_slice());\n+        encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);"}, {"sha": "d30df131d4d299da551e99f9545d7ab53ae8d2ed", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -394,8 +394,8 @@ impl<'a> Context<'a> {\n                     file.ends_with(\".rlib\") {\n                 (&file[(rlib_prefix.len()) .. (file.len() - \".rlib\".len())],\n                  true)\n-            } else if file.starts_with(dylib_prefix.as_slice()) &&\n-                      file.ends_with(dypair.1.as_slice()) {\n+            } else if file.starts_with(&dylib_prefix) &&\n+                      file.ends_with(&dypair.1) {\n                 (&file[(dylib_prefix.len()) .. (file.len() - dypair.1.len())],\n                  false)\n             } else {"}, {"sha": "7cc7e49b6d251a6f04d36588de4a6baef83eb426", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -555,7 +555,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n       'P' => {\n           assert_eq!(next(st), '[');\n           let trait_ref = parse_trait_ref_(st, conv);\n-          let name = token::intern(parse_str(st, ']').as_slice());\n+          let name = token::intern(&parse_str(st, ']'));\n           return ty::mk_projection(tcx, trait_ref, name);\n       }\n       'e' => {\n@@ -781,7 +781,7 @@ fn parse_projection_predicate_<'a,'tcx, F>(\n     ty::ProjectionPredicate {\n         projection_ty: ty::ProjectionTy {\n             trait_ref: parse_trait_ref_(st, conv),\n-            item_name: token::str_to_ident(parse_str(st, '|').as_slice()).name,\n+            item_name: token::str_to_ident(&parse_str(st, '|')).name,\n         },\n         ty: parse_ty_(st, conv),\n     }"}, {"sha": "b0fe743b683792dc358211967b8701db22d6ed00", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1185,7 +1185,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_from_vec(fv.as_slice(), |rbml_w, fv_entry| {\n+                rbml_w.emit_from_vec(fv, |rbml_w, fv_entry| {\n                     Ok(encode_freevar_entry(rbml_w, fv_entry))\n                 });\n             })"}, {"sha": "7ba83c62496f368cd8bf6dee9f9071faae273c03", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             Entry => on_entry,\n             Exit => {\n                 let mut t = on_entry.to_vec();\n-                self.apply_gen_kill(cfgidx, t.as_mut_slice());\n+                self.apply_gen_kill(cfgidx, &mut t);\n                 temp_bits = t;\n                 &temp_bits[]\n             }\n@@ -405,7 +405,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                     Some(cfg_idx) => {\n                         let (start, end) = self.compute_id_range(cfg_idx);\n                         let kills = &self.kills[start.. end];\n-                        if bitwise(orig_kills.as_mut_slice(), kills, &Union) {\n+                        if bitwise(&mut orig_kills, kills, &Union) {\n                             changed = true;\n                         }\n                     }\n@@ -450,8 +450,8 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n             let mut temp: Vec<_> = repeat(0).take(words_per_id).collect();\n             while propcx.changed {\n                 propcx.changed = false;\n-                propcx.reset(temp.as_mut_slice());\n-                propcx.walk_cfg(cfg, temp.as_mut_slice());\n+                propcx.reset(&mut temp);\n+                propcx.walk_cfg(cfg, &mut temp);\n             }\n         }\n "}, {"sha": "90d26f0f6bf53e79f7be1560c7a2c7bf8962c6f9", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -287,7 +287,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         let def_map = &self.tcx.def_map;\n         match pat.node {\n             ast::PatStruct(_, ref fields, _) => {\n-                self.handle_field_pattern_match(pat, fields.as_slice());\n+                self.handle_field_pattern_match(pat, fields);\n             }\n             _ if pat_util::pat_is_const(def_map, pat) => {\n                 // it might be the only use of a const\n@@ -313,7 +313,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n }\n \n fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n-    if attr::contains_name(attrs.as_slice(), \"lang\") {\n+    if attr::contains_name(attrs, \"lang\") {\n         return true;\n     }\n \n@@ -347,7 +347,7 @@ struct LifeSeeder {\n \n impl<'v> Visitor<'v> for LifeSeeder {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        let allow_dead_code = has_allow_dead_code_or_lang_attr(item.attrs.as_slice());\n+        let allow_dead_code = has_allow_dead_code_or_lang_attr(&item.attrs);\n         if allow_dead_code {\n             self.worklist.push(item.id);\n         }\n@@ -376,7 +376,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n         // Check for method here because methods are not ast::Item\n         match fk {\n             visit::FkMethod(_, _, method) => {\n-                if has_allow_dead_code_or_lang_attr(method.attrs.as_slice()) {\n+                if has_allow_dead_code_or_lang_attr(&method.attrs) {\n                     self.worklist.push(id);\n                 }\n             }\n@@ -467,12 +467,12 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         is_named\n             && !self.symbol_is_live(node.id, None)\n             && !is_marker_field\n-            && !has_allow_dead_code_or_lang_attr(node.attrs.as_slice())\n+            && !has_allow_dead_code_or_lang_attr(&node.attrs)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &ast::Variant_) -> bool {\n         !self.symbol_is_live(variant.id, None)\n-            && !has_allow_dead_code_or_lang_attr(variant.attrs.as_slice())\n+            && !has_allow_dead_code_or_lang_attr(&variant.attrs)\n     }\n \n     // id := node id of an item's definition."}, {"sha": "0ce9db1c80f3f21c4741083a46e983a4bb37ea23", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -56,7 +56,7 @@ pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(ast_map.krate().attrs.as_slice(), \"no_main\") {\n+    if attr::contains_name(&ast_map.krate().attrs, \"no_main\") {\n         session.entry_type.set(Some(config::EntryNone));\n         return\n     }\n@@ -96,7 +96,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n                 });\n             }\n \n-            if attr::contains_name(item.attrs.as_slice(), \"main\") {\n+            if attr::contains_name(&item.attrs, \"main\") {\n                 if ctxt.attr_main_fn.is_none() {\n                     ctxt.attr_main_fn = Some((item.id, item.span));\n                 } else {\n@@ -105,7 +105,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n                 }\n             }\n \n-            if attr::contains_name(item.attrs.as_slice(), \"start\") {\n+            if attr::contains_name(&item.attrs, \"start\") {\n                 if ctxt.start_fn.is_none() {\n                     ctxt.start_fn = Some((item.id, item.span));\n                 } else {"}, {"sha": "5cc7502b5128d3e2674769732670dec36c0ea0c1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -639,8 +639,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         None => {\n                             self.tcx().sess.span_bug(\n                                 callee.span,\n-                                format!(\"unexpected callee type {}\",\n-                                        callee_ty.repr(self.tcx())).as_slice())\n+                                &format!(\"unexpected callee type {}\", callee_ty.repr(self.tcx())))\n                         }\n                     };\n                 match overloaded_call_type {\n@@ -1150,7 +1149,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                 let msg = format!(\"Pattern has unexpected type: {:?} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n-                                tcx.sess.span_bug(pat.span, msg.as_slice())\n+                                tcx.sess.span_bug(pat.span, &msg)\n                             }\n                         }\n "}, {"sha": "989efdd235dffe76fd4cfd545404a46c06618c3d", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -112,14 +112,12 @@ impl<N,E> Graph<N,E> {\n \n     #[inline]\n     pub fn all_nodes<'a>(&'a self) -> &'a [Node<N>] {\n-        let nodes: &'a [Node<N>] = self.nodes.as_slice();\n-        nodes\n+        &self.nodes\n     }\n \n     #[inline]\n     pub fn all_edges<'a>(&'a self) -> &'a [Edge<E>] {\n-        let edges: &'a [Edge<E>] = self.edges.as_slice();\n-        edges\n+        &self.edges\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "daa820f43b57ec186aa67ae79ae2d5d587a14214", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -208,8 +208,8 @@ pub trait Combine<'tcx> : Sized {\n         }\n \n         let inputs = try!(argvecs(self,\n-                                  a.inputs.as_slice(),\n-                                  b.inputs.as_slice()));\n+                                  &a.inputs,\n+                                  &b.inputs));\n \n         let output = try!(match (a.output, b.output) {\n             (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>"}, {"sha": "05f0c247a759283bf3d8d618378fd4dec3ec9145", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1707,7 +1707,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n             Some(node) => match node {\n                 ast_map::NodeItem(item) => match item.node {\n                     ast::ItemImpl(_, _, ref gen, _, _, _) => {\n-                        taken.push_all(gen.lifetimes.as_slice());\n+                        taken.push_all(&gen.lifetimes);\n                     }\n                     _ => ()\n                 },"}, {"sha": "1b7e6c33c0575f723d341ec8373005765a0c5147", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -127,10 +127,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ty_infer(ty::FreshIntTy(c)) => {\n                 if c >= self.freshen_count {\n                     self.tcx().sess.bug(\n-                        format!(\"Encountered a freshend type with id {} \\\n-                                 but our counter is only at {}\",\n-                                c,\n-                                self.freshen_count).as_slice());\n+                        &format!(\"Encountered a freshend type with id {} \\\n+                                  but our counter is only at {}\",\n+                                 c,\n+                                 self.freshen_count));\n                 }\n                 t\n             }"}, {"sha": "4469e27a5b05af10e8e56825a2af5e1d02899e4c", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -133,7 +133,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                     self.tcx(),\n                     &result0,\n                     |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n-                                                    new_vars.as_slice(), &a_map, r));\n+                                                    &new_vars, &a_map, r));\n \n             debug!(\"lub({},{}) = {}\",\n                    a.repr(self.tcx()),\n@@ -227,8 +227,8 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                     self.tcx(),\n                     &result0,\n                     |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n-                                                    new_vars.as_slice(),\n-                                                    &a_map, a_vars.as_slice(), b_vars.as_slice(),\n+                                                    &new_vars,\n+                                                    &a_map, &a_vars, &b_vars,\n                                                     r));\n \n             debug!(\"glb({},{}) = {}\","}, {"sha": "6a75b1b0d3d60cdbc988d2ec06572c4569080479", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -71,7 +71,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n \n     let output_path = {\n         let output_template = match requested_output {\n-            Some(ref s) if s.as_slice() == \"help\" => {\n+            Some(ref s) if &**s == \"help\" => {\n                 static PRINTED_YET: AtomicBool = ATOMIC_BOOL_INIT;\n                 if !PRINTED_YET.load(Ordering::SeqCst) {\n                     print_help_message();\n@@ -92,7 +92,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n             let mut new_str = String::new();\n             for c in output_template.chars() {\n                 if c == '%' {\n-                    new_str.push_str(subject_node.to_string().as_slice());\n+                    new_str.push_str(&subject_node.to_string());\n                 } else {\n                     new_str.push(c);\n                 }\n@@ -104,11 +104,11 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     };\n \n     let constraints = &*region_vars.constraints.borrow();\n-    match dump_region_constraints_to(tcx, constraints, output_path.as_slice()) {\n+    match dump_region_constraints_to(tcx, constraints, &output_path) {\n         Ok(()) => {}\n         Err(e) => {\n             let msg = format!(\"io error dumping region constraints: {}\", e);\n-            region_vars.tcx.sess.err(msg.as_slice())\n+            region_vars.tcx.sess.err(&msg)\n         }\n     }\n }\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n \n impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     fn graph_id(&self) -> dot::Id {\n-        dot::Id::new(self.graph_name.as_slice()).ok().unwrap()\n+        dot::Id::new(&*self.graph_name).ok().unwrap()\n     }\n     fn node_id(&self, n: &Node) -> dot::Id {\n         dot::Id::new(format!(\"node_{}\", self.node_ids.get(n).unwrap())).ok().unwrap()"}, {"sha": "a5c40cac9e504d9563c473e93656922277305669", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -973,8 +973,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         debug!(\"----() End constraint listing {:?}---\", self.dump_constraints());\n         graphviz::maybe_print_constraints_for(self, subject);\n \n-        self.expansion(var_data.as_mut_slice());\n-        self.contraction(var_data.as_mut_slice());\n+        self.expansion(&mut var_data);\n+        self.contraction(&mut var_data);\n         let values =\n             self.extract_values_and_collect_conflicts(&var_data[],\n                                                       errors);\n@@ -1303,12 +1303,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     match var_data[idx].classification {\n                         Expanding => {\n                             self.collect_error_for_expanding_node(\n-                                graph, var_data, dup_vec.as_mut_slice(),\n+                                graph, var_data, &mut dup_vec,\n                                 node_vid, errors);\n                         }\n                         Contracting => {\n                             self.collect_error_for_contracting_node(\n-                                graph, var_data, dup_vec.as_mut_slice(),\n+                                graph, var_data, &mut dup_vec,\n                                 node_vid, errors);\n                         }\n                     }"}, {"sha": "8a293a67727787ff73b5439acaa83dc22285e46e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -147,7 +147,7 @@ struct LanguageItemCollector<'a> {\n \n impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        match extract(item.attrs.as_slice()) {\n+        match extract(&item.attrs) {\n             Some(value) => {\n                 let item_index = self.item_refs.get(value.get()).map(|x| *x);\n "}, {"sha": "5e27023e026fbc7152401ecec9649e3281c673e5", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -456,13 +456,13 @@ impl<'a> LifetimeContext<'a> {\n                     if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n                         self.sess.span_warn(\n                             lifetime.span,\n-                            format!(\"lifetime name `{}` shadows another \\\n-                                    lifetime name that is already in scope\",\n-                                    token::get_name(lifetime.name)).as_slice());\n+                            &format!(\"lifetime name `{}` shadows another \\\n+                                     lifetime name that is already in scope\",\n+                                     token::get_name(lifetime.name)));\n                         self.sess.span_note(\n                             lifetime_def.span,\n-                            format!(\"shadowed lifetime `{}` declared here\",\n-                                    token::get_name(lifetime.name)).as_slice());\n+                            &format!(\"shadowed lifetime `{}` declared here\",\n+                                     token::get_name(lifetime.name)));\n                         self.sess.span_note(\n                             lifetime.span,\n                             \"shadowed lifetimes are deprecated \\"}, {"sha": "dfbd11957da4409193b61127722fccdb67410535", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -57,7 +57,7 @@ impl<'a> Annotator<'a> {\n                    attrs: &Vec<Attribute>, item_sp: Span, f: F, required: bool) where\n         F: FnOnce(&mut Annotator),\n     {\n-        match attr::find_stability(self.sess.diagnostic(), attrs.as_slice(), item_sp) {\n+        match attr::find_stability(self.sess.diagnostic(), attrs, item_sp) {\n             Some(stab) => {\n                 self.index.local.insert(id, stab.clone());\n "}, {"sha": "8cb0447e732477343128db81a7878b185687031c", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -406,7 +406,7 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn as_slice(&self) -> &[T] {\n-        self.content.as_slice()\n+        &self.content\n     }\n \n     pub fn into_vec(self) -> Vec<T> {"}, {"sha": "d69f340ca1712bb8c8c0d7fc3c91770dccf1ca96", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -24,7 +24,7 @@ reference to a trait. So, for example, if there is a generic function like:\n \n and then a call to that function:\n \n-    let v: Vec<int> = clone_slice([1, 2, 3].as_slice())\n+    let v: Vec<int> = clone_slice([1, 2, 3])\n \n it is the job of trait resolution to figure out (in which case)\n whether there exists an impl of `int : Clone`"}, {"sha": "a1f3737cbb20826268230767dee6ac7cc62913a5", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -93,7 +93,7 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         Piece::String(s) => Some(s),\n                         Piece::NextArgument(a) => match a.position {\n                             Position::ArgumentNamed(s) => match generic_map.get(s) {\n-                                Some(val) => Some(val.as_slice()),\n+                                Some(val) => Some(val),\n                                 None => {\n                                     span_err!(infcx.tcx.sess, err_sp, E0272,\n                                                    \"the #[rustc_on_unimplemented] \\\n@@ -181,7 +181,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                                                           obligation.cause.span);\n                                 if let Some(s) = custom_note {\n                                     infcx.tcx.sess.span_note(obligation.cause.span,\n-                                                             s.as_slice());\n+                                                             &s);\n                                 }\n                             }\n                         }\n@@ -289,12 +289,12 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                 // Ambiguity. Coherence should have reported an error.\n                 infcx.tcx.sess.span_bug(\n                     obligation.cause.span,\n-                    format!(\n+                    &format!(\n                         \"coherence failed to report ambiguity: \\\n                          cannot locate the impl of the trait `{}` for \\\n                          the type `{}`\",\n                         trait_ref.user_string(infcx.tcx),\n-                        self_ty.user_string(infcx.tcx)).as_slice());\n+                        self_ty.user_string(infcx.tcx)));\n             }\n         }\n \n@@ -330,14 +330,14 @@ fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let item_name = ty::item_path_str(tcx, item_def_id);\n             tcx.sess.span_note(\n                 cause_span,\n-                format!(\"required by `{}`\", item_name).as_slice());\n+                &format!(\"required by `{}`\", item_name));\n         }\n         ObligationCauseCode::ObjectCastObligation(object_ty) => {\n             tcx.sess.span_note(\n                 cause_span,\n-                format!(\n+                &format!(\n                     \"required for the cast to the object type `{}`\",\n-                    infcx.ty_to_string(object_ty)).as_slice());\n+                    infcx.ty_to_string(object_ty)));\n         }\n         ObligationCauseCode::RepeatVec => {\n             tcx.sess.span_note("}, {"sha": "07c7453783d9561ccef45ca8d3f12612968b9629", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -180,7 +180,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     {\n         match self.region_obligations.get(&body_id) {\n             None => Default::default(),\n-            Some(vec) => vec.as_slice(),\n+            Some(vec) => vec,\n         }\n     }\n "}, {"sha": "9d3ad28e6138b574e69149333b64f552b7c9a81a", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -605,8 +605,8 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n         _ => {\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n-                format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n-                        object_ty.repr(selcx.tcx())).as_slice());\n+                &format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n+                         object_ty.repr(selcx.tcx())));\n         }\n     };\n     let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n@@ -693,8 +693,8 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // These traits have no associated types.\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n-                format!(\"Cannot project an associated type from `{}`\",\n-                        vtable.repr(selcx.tcx())).as_slice());\n+                &format!(\"Cannot project an associated type from `{}`\",\n+                         vtable.repr(selcx.tcx())));\n         }\n     }\n \n@@ -813,10 +813,10 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n         Err(e) => {\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n-                format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n-                        obligation.repr(selcx.tcx()),\n-                        projection.repr(selcx.tcx()),\n-                        ty::type_err_to_str(selcx.tcx(), &e)).as_slice());\n+                &format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n+                         obligation.repr(selcx.tcx()),\n+                         projection.repr(selcx.tcx()),\n+                         ty::type_err_to_str(selcx.tcx(), &e)));\n         }\n     }\n "}, {"sha": "2ea16d55343350459975e1b7a0095c7f7ac8ddc2", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -933,9 +933,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n-                    format!(\"match_projection_obligation_against_bounds_from_trait() called \\\n-                             but self-ty not a projection: {}\",\n-                            skol_trait_predicate.trait_ref.self_ty().repr(self.tcx())).as_slice());\n+                    &format!(\"match_projection_obligation_against_bounds_from_trait() called \\\n+                              but self-ty not a projection: {}\",\n+                             skol_trait_predicate.trait_ref.self_ty().repr(self.tcx())));\n             }\n         };\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n@@ -1787,9 +1787,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Ok(obligations) => obligations,\n             Err(()) => {\n                 self.tcx().sess.bug(\n-                    format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n-                            param.repr(self.tcx()),\n-                            obligation.repr(self.tcx())).as_slice());\n+                    &format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n+                             param.repr(self.tcx()),\n+                             obligation.repr(self.tcx())));\n             }\n         }\n     }\n@@ -1953,9 +1953,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Some(r) => r,\n             None => {\n                 self.tcx().sess.span_bug(obligation.cause.span,\n-                                         format!(\"unable to upcast from {} to {}\",\n-                                                 poly_trait_ref.repr(self.tcx()),\n-                                                 obligation_def_id.repr(self.tcx())).as_slice());\n+                                         &format!(\"unable to upcast from {} to {}\",\n+                                                  poly_trait_ref.repr(self.tcx()),\n+                                                  obligation_def_id.repr(self.tcx())));\n             }\n         };\n "}, {"sha": "5180b8379eace8c8305070d2762698d57c595fac", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -279,7 +279,7 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n             }))\n         }\n         Err(e) => {\n-            tcx.sess.err(e.as_slice());\n+            tcx.sess.err(&e);\n             Err(ErrorReported)\n         }\n     }"}, {"sha": "6964a0b9db8178af441144882a088286f6d66537", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -2793,7 +2793,7 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n                       bounds: ExistentialBounds<'tcx>)\n                       -> Ty<'tcx>\n {\n-    assert!(bound_list_is_sorted(bounds.projection_bounds.as_slice()));\n+    assert!(bound_list_is_sorted(&bounds.projection_bounds));\n \n     let inner = box TyTrait {\n         principal: principal,\n@@ -3406,8 +3406,8 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut` closure.\n                 let param_env = ty::empty_parameter_environment(cx);\n                 let upvars = closure_upvars(&param_env, did, substs).unwrap();\n-                TypeContents::union(upvars.as_slice(),\n-                                    |f| tc_ty(cx, f.ty, cache))\n+                TypeContents::union(&upvars,\n+                                    |f| tc_ty(cx, &f.ty, cache))\n                     | borrowed_contents(*r, MutMutable)\n             }\n \n@@ -3672,8 +3672,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // inference by-products or closure types\n-                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n-                                    ty).as_slice())\n+                cx.sess.bug(&format!(\"requires check invoked on inapplicable type: {:?}\", ty))\n             }\n \n             ty_tup(ref ts) => {\n@@ -3766,8 +3765,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n             ty_closure(..) => {\n                 // this check is run on type definitions, so we don't expect\n                 // to see closure types\n-                cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n-                                    ty).as_slice())\n+                cx.sess.bug(&format!(\"requires check invoked on inapplicable type: {:?}\", ty))\n             }\n             _ => Representable,\n         }\n@@ -6365,9 +6363,9 @@ pub fn construct_parameter_environment<'a,'tcx>(\n                         _ => {\n                             // All named regions are instantiated with free regions.\n                             tcx.sess.bug(\n-                                format!(\"record_region_bounds: non free region: {} / {}\",\n-                                        r_a.repr(tcx),\n-                                        r_b.repr(tcx)).as_slice());\n+                                &format!(\"record_region_bounds: non free region: {} / {}\",\n+                                         r_a.repr(tcx),\n+                                         r_b.repr(tcx)));\n                         }\n                     }\n                 }"}, {"sha": "40dfd479364a6c18c76f960518bef48a3e87777b", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -39,17 +39,17 @@ impl<'tcx> TypeWalker<'tcx> {\n             }\n             ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n                 self.push_reversed(principal.substs().types.as_slice());\n-                self.push_reversed(bounds.projection_bounds.iter().map(|pred| {\n+                self.push_reversed(&bounds.projection_bounds.iter().map(|pred| {\n                     pred.0.ty\n-                }).collect::<Vec<_>>().as_slice());\n+                }).collect::<Vec<_>>());\n             }\n             ty::ty_enum(_, ref substs) |\n             ty::ty_struct(_, ref substs) |\n             ty::ty_closure(_, _, ref substs) => {\n                 self.push_reversed(substs.types.as_slice());\n             }\n             ty::ty_tup(ref ts) => {\n-                self.push_reversed(ts.as_slice());\n+                self.push_reversed(ts);\n             }\n             ty::ty_bare_fn(_, ref ft) => {\n                 self.push_sig_subtypes(&ft.sig);\n@@ -62,7 +62,7 @@ impl<'tcx> TypeWalker<'tcx> {\n             ty::FnConverging(output) => { self.stack.push(output); }\n             ty::FnDiverging => { }\n         }\n-        self.push_reversed(sig.0.inputs.as_slice());\n+        self.push_reversed(&sig.0.inputs);\n     }\n \n     fn push_reversed(&mut self, tys: &[Ty<'tcx>]) {"}, {"sha": "b23d05ca64cf94c35d9b73e1eab8d0ab3aa0b38e", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -85,8 +85,8 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n \n     $(\n         if missing.contains(&lang_items::$item) && items.$name().is_none() {\n-            sess.err(format!(\"language item required, but not found: `{}`\",\n-                             stringify!($name)).as_slice());\n+            sess.err(&format!(\"language item required, but not found: `{}`\",\n+                              stringify!($name)));\n \n         }\n     )*\n@@ -108,7 +108,7 @@ impl<'a> Context<'a> {\n \n impl<'a, 'v> Visitor<'v> for Context<'a> {\n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        match lang_items::extract(i.attrs.as_slice()) {\n+        match lang_items::extract(&i.attrs) {\n             None => {}\n             Some(lang_item) => self.register(lang_item.get(), i.span),\n         }"}, {"sha": "818af33c34d142a4e4650dc57ddf8c961e5d7da8", "filename": "src/librustc/plugin/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -24,7 +24,7 @@ struct RegistrarFinder {\n impl<'v> Visitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &ast::Item) {\n         if let ast::ItemFn(..) = item.node {\n-            if attr::contains_name(item.attrs.as_slice(),\n+            if attr::contains_name(&item.attrs,\n                                    \"plugin_registrar\") {\n                 self.registrars.push((item.id, item.span));\n             }"}, {"sha": "a7592226fd67b1115a1a178ab9e079f0b8d55797", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -82,8 +82,8 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n     visit::walk_crate(&mut loader, krate);\n \n     if let Some(plugins) = addl_plugins {\n-        for plugin in &plugins {\n-            loader.load_plugin(CrateOrString::Str(plugin.as_slice()),\n+        for plugin in plugins {\n+            loader.load_plugin(CrateOrString::Str(&plugin),\n                                                   None, None, None)\n         }\n     }"}, {"sha": "5dfb16528e07d3b28f0a5501fc4a300cfeae1176", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -638,7 +638,7 @@ pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n     let target = match Target::search(&opts.target_triple[]) {\n         Ok(t) => t,\n         Err(e) => {\n-            sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).as_slice());\n+            sp.handler().fatal(&format!(\"Error loading target specification: {}\", e));\n     }\n     };\n \n@@ -856,7 +856,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         let unparsed_output_types = matches.opt_strs(\"emit\");\n         for unparsed_output_type in &unparsed_output_types {\n             for part in unparsed_output_type.split(',') {\n-                let output_type = match part.as_slice() {\n+                let output_type = match part {\n                     \"asm\" => OutputTypeAssembly,\n                     \"llvm-ir\" => OutputTypeLlvmAssembly,\n                     \"llvm-bc\" => OutputTypeBitcode,\n@@ -897,9 +897,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 Some(2) => Default,\n                 Some(3) => Aggressive,\n                 Some(arg) => {\n-                    early_error(format!(\"optimization level needs to be \\\n-                                         between 0-3 (instead was `{}`)\",\n-                                        arg).as_slice());\n+                    early_error(&format!(\"optimization level needs to be \\\n+                                          between 0-3 (instead was `{}`)\",\n+                                         arg));\n                 }\n             }\n         }\n@@ -916,9 +916,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             Some(1) => LimitedDebugInfo,\n             Some(2) => FullDebugInfo,\n             Some(arg) => {\n-                early_error(format!(\"debug info level needs to be between \\\n-                                     0-2 (instead was `{}`)\",\n-                                    arg).as_slice());\n+                early_error(&format!(\"debug info level needs to be between \\\n+                                      0-2 (instead was `{}`)\",\n+                                     arg));\n             }\n         }\n     };\n@@ -937,9 +937,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 \"framework\" => cstore::NativeFramework,\n                 \"static\" => cstore::NativeStatic,\n                 s => {\n-                    early_error(format!(\"unknown library kind `{}`, expected \\\n-                                         one of dylib, framework, or static\",\n-                                        s).as_slice());\n+                    early_error(&format!(\"unknown library kind `{}`, expected \\\n+                                          one of dylib, framework, or static\",\n+                                         s));\n                 }\n             };\n             return (name.to_string(), kind)\n@@ -968,12 +968,12 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let write_dependency_info = (output_types.contains(&OutputTypeDepInfo), None);\n \n     let prints = matches.opt_strs(\"print\").into_iter().map(|s| {\n-        match s.as_slice() {\n+        match &*s {\n             \"crate-name\" => PrintRequest::CrateName,\n             \"file-names\" => PrintRequest::FileNames,\n             \"sysroot\" => PrintRequest::Sysroot,\n             req => {\n-                early_error(format!(\"unknown print request `{}`\", req).as_slice())\n+                early_error(&format!(\"unknown print request `{}`\", req))\n             }\n         }\n     }).collect::<Vec<_>>();"}, {"sha": "bd44dbe78f5438d8a86cbcad98df0732895df8e1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -332,7 +332,7 @@ pub fn build_session_(sopts: config::Options,\n         Ok(t) => t,\n         Err(e) => {\n             span_diagnostic.handler()\n-                .fatal((format!(\"Error loading host specification: {}\", e)).as_slice());\n+                .fatal(&format!(\"Error loading host specification: {}\", e));\n     }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);"}, {"sha": "d39e1b8977a0efbf52dd616768508d248f17cb00", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -116,7 +116,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n             region::CodeExtent::Remainder(r) => {\n                 new_string = format!(\"block suffix following statement {}\",\n                                      r.first_statement_index);\n-                new_string.as_slice()\n+                &*new_string\n             }\n         };\n         explain_span(cx, scope_decorated_tag, span)\n@@ -263,7 +263,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         match unsafety {\n             ast::Unsafety::Normal => {}\n             ast::Unsafety::Unsafe => {\n-                s.push_str(unsafety.to_string().as_slice());\n+                s.push_str(&unsafety.to_string());\n                 s.push(' ');\n             }\n         };\n@@ -315,7 +315,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             .iter()\n             .map(|a| ty_to_string(cx, *a))\n             .collect::<Vec<_>>();\n-        s.push_str(strs.connect(\", \").as_slice());\n+        s.push_str(&strs.connect(\", \"));\n         if sig.0.variadic {\n             s.push_str(\", ...\");\n         }\n@@ -392,7 +392,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         ty_enum(did, substs) | ty_struct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n-            parameterized(cx, base.as_slice(), substs, &generics, did, &[])\n+            parameterized(cx, &base, substs, &generics, did, &[])\n         }\n         ty_trait(ref data) => {\n             data.user_string(cx)\n@@ -643,7 +643,7 @@ impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n         let base = ty::item_path_str(tcx, trait_ref.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n         parameterized(tcx,\n-                      base.as_slice(),\n+                      &base,\n                       trait_ref.substs,\n                       &trait_def.generics,\n                       trait_ref.def_id,\n@@ -780,7 +780,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"TraitRef({}, {})\",\n                 self.substs.self_ty().repr(tcx),\n-                parameterized(tcx, base.as_slice(), self.substs,\n+                parameterized(tcx, &base, self.substs,\n                               &trait_def.generics, self.def_id, &[]))\n     }\n }\n@@ -1235,7 +1235,7 @@ impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let path_str = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        parameterized(tcx, path_str.as_slice(), self.substs,\n+        parameterized(tcx, &path_str, self.substs,\n                       &trait_def.generics, self.def_id, &[])\n     }\n }"}, {"sha": "6654a46f7c31b51cdaee38add94af4f904eb793e", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -259,7 +259,7 @@ pub trait Digest {\n     /// newly allocated vec of bytes.\n     fn result_bytes(&mut self) -> Vec<u8> {\n         let mut buf: Vec<u8> = repeat(0u8).take((self.output_bits()+7)/8).collect();\n-        self.result(buf.as_mut_slice());\n+        self.result(&mut buf);\n         buf\n     }\n \n@@ -560,7 +560,7 @@ mod tests {\n         // Test that it works when accepting the message all at once\n         for t in tests {\n             sh.reset();\n-            sh.input_str(t.input.as_slice());\n+            sh.input_str(&t.input);\n             let out_str = sh.result_str();\n             assert!(out_str == t.output_str);\n         }\n@@ -606,7 +606,7 @@ mod tests {\n \n         let mut sh = box Sha256::new();\n \n-        test_hash(&mut *sh, tests.as_slice());\n+        test_hash(&mut *sh, &tests);\n     }\n \n     /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n@@ -630,7 +630,7 @@ mod tests {\n         let result_str = digest.result_str();\n         let result_bytes = digest.result_bytes();\n \n-        assert_eq!(expected, result_str.as_slice());\n+        assert_eq!(expected, result_str);\n \n         let expected_vec: Vec<u8> = expected.from_hex()\n                                             .unwrap()"}, {"sha": "c932d521bbe1bb9dacccfa81feacdeb088fead1f", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -798,8 +798,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n-                                       format!(\"{} in a captured outer \\\n-                                               variable in an `Fn` closure\", prefix).as_slice());\n+                                       &format!(\"{} in a captured outer \\\n+                                                variable in an `Fn` closure\", prefix));\n                 if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n                     // The aliasability violation with closure captures can\n                     // happen for nested closures, so we know the enclosing"}, {"sha": "0b0b1f9276fbb3d8539da98dabae33bf90f0f962", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -350,7 +350,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     }\n \n     if let Some(ref s) = sess.opts.show_span {\n-        syntax::show_span::run(sess.diagnostic(), s.as_slice(), &krate);\n+        syntax::show_span::run(sess.diagnostic(), s, &krate);\n     }\n \n     krate"}, {"sha": "9193debbe4243adeabda71a77f120272d3ade3c5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -93,7 +93,7 @@ pub mod driver;\n pub mod pretty;\n \n pub fn run(args: Vec<String>) -> int {\n-    monitor(move || run_compiler(args.as_slice()));\n+    monitor(move || run_compiler(&args));\n     0\n }\n \n@@ -165,7 +165,7 @@ fn run_compiler(args: &[String]) {\n     let pretty = if sess.opts.debugging_opts.unstable_options {\n         matches.opt_default(\"pretty\", \"normal\").map(|a| {\n             // stable pretty-print variants only\n-            pretty::parse_pretty(&sess, a.as_slice(), false)\n+            pretty::parse_pretty(&sess, &a, false)\n         })\n     } else {\n         None\n@@ -174,7 +174,7 @@ fn run_compiler(args: &[String]) {\n         sess.unstable_options() {\n             matches.opt_str(\"xpretty\").map(|a| {\n                 // extended with unstable pretty-print variants\n-                pretty::parse_pretty(&sess, a.as_slice(), true)\n+                pretty::parse_pretty(&sess, &a, true)\n             })\n         } else {\n             pretty\n@@ -313,7 +313,7 @@ Additional help:\n     -C help             Print codegen options\n     -W help             Print 'lint' options and default settings\n     -Z help             Print internal options for debugging rustc{}\\n\",\n-              getopts::usage(message.as_slice(), groups.as_slice()),\n+              getopts::usage(&message, &groups),\n               extra_help);\n }\n \n@@ -481,20 +481,20 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n                 // unstable ones.\n                 let all_groups : Vec<getopts::OptGroup>\n                     = config::rustc_optgroups().into_iter().map(|x|x.opt_group).collect();\n-                match getopts::getopts(args.as_slice(), all_groups.as_slice()) {\n+                match getopts::getopts(&args, &all_groups) {\n                     Ok(m_unstable) => {\n                         let r = m_unstable.opt_strs(\"Z\");\n                         let include_unstable_options = r.iter().any(|x| *x == \"unstable-options\");\n                         if include_unstable_options {\n                             m_unstable\n                         } else {\n-                            early_error(f_stable_attempt.to_string().as_slice());\n+                            early_error(&f_stable_attempt.to_string());\n                         }\n                     }\n                     Err(_) => {\n                         // ignore the error from the unstable attempt; just\n                         // pass the error we got from the first try.\n-                        early_error(f_stable_attempt.to_string().as_slice());\n+                        early_error(&f_stable_attempt.to_string());\n                     }\n                 }\n             }\n@@ -552,13 +552,13 @@ fn print_crate_info(sess: &Session,\n                     Some(input) => input,\n                     None => early_error(\"no input file provided\"),\n                 };\n-                let attrs = attrs.as_ref().unwrap().as_slice();\n+                let attrs = attrs.as_ref().unwrap();\n                 let t_outputs = driver::build_output_filenames(input,\n                                                                odir,\n                                                                ofile,\n                                                                attrs,\n                                                                sess);\n-                let id = link::find_crate_name(Some(sess), attrs.as_slice(),\n+                let id = link::find_crate_name(Some(sess), attrs,\n                                                input);\n                 if *req == PrintRequest::CrateName {\n                     println!(\"{}\", id);\n@@ -569,7 +569,7 @@ fn print_crate_info(sess: &Session,\n                 *sess.crate_metadata.borrow_mut() = metadata;\n                 for &style in &crate_types {\n                     let fname = link::filename_for_input(sess, style,\n-                                                         id.as_slice(),\n+                                                         &id,\n                                                          &t_outputs.with_extension(\"\"));\n                     println!(\"{}\", fname.filename_display());\n                 }"}, {"sha": "5dfef6c775e1e892a9980815aa21bd888e8b28ea", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -87,15 +87,15 @@ pub fn parse_pretty(sess: &Session,\n         (\"flowgraph,unlabelled\", true)    => PpmFlowGraph(PpFlowGraphMode::UnlabelledEdges),\n         _ => {\n             if extended {\n-                sess.fatal(format!(\n+                sess.fatal(&format!(\n                     \"argument to `xpretty` must be one of `normal`, \\\n                      `expanded`, `flowgraph[,unlabelled]=<nodeid>`, `typed`, `identified`, \\\n-                     `expanded,identified`, or `everybody_loops`; got {}\", name).as_slice());\n+                     `expanded,identified`, or `everybody_loops`; got {}\", name));\n             } else {\n-                sess.fatal(format!(\n+                sess.fatal(&format!(\n                     \"argument to `pretty` must be one of `normal`, \\\n                      `expanded`, `typed`, `identified`, \\\n-                     or `expanded,identified`; got {}\", name).as_slice());\n+                     or `expanded,identified`; got {}\", name));\n             }\n         }\n     };\n@@ -517,7 +517,7 @@ pub fn pretty_print_input(sess: Session,\n         krate\n     };\n \n-    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n+    let id = link::find_crate_name(Some(&sess), &krate.attrs, input);\n \n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);"}, {"sha": "8761b5f72ec57cde12abea280b454c41fb07ee1f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -56,7 +56,7 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n     }\n \n     debug!(\"Error: {}\", msg);\n-    match e.messages.iter().position(|m| msg.contains(m.as_slice())) {\n+    match e.messages.iter().position(|m| msg.contains(m)) {\n         Some(i) => {\n             e.messages.remove(i);\n         }"}, {"sha": "ec1d300dbec894079a3eaf52bd04bf8788a97ed0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1726,7 +1726,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            in this module\",\n                                           namespace_name,\n                                           token::get_name(name).get());\n-                        span_err!(self.session, import_directive.span, E0251, \"{}\", msg.as_slice());\n+                        span_err!(self.session, import_directive.span, E0251, \"{}\", msg);\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n                                                  name_bindings.clone(),\n@@ -3756,15 +3756,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         Some(_) => {\n                             self.resolve_error(path.span,\n-                                format!(\"`{}` is not an enum variant, struct or const\",\n+                                &format!(\"`{}` is not an enum variant, struct or const\",\n                                     token::get_ident(\n-                                        path.segments.last().unwrap().identifier)).as_slice());\n+                                        path.segments.last().unwrap().identifier)));\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n-                                format!(\"unresolved enum variant, struct or const `{}`\",\n-                                    token::get_ident(\n-                                        path.segments.last().unwrap().identifier)).as_slice());\n+                                &format!(\"unresolved enum variant, struct or const `{}`\",\n+                                    token::get_ident(path.segments.last().unwrap().identifier)));\n                         }\n                     }\n \n@@ -4061,7 +4060,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared type or module `{}`\",\n-                                          self.names_to_string(module_path.as_slice()));\n+                                          self.names_to_string(&module_path));\n                         (path.span, msg)\n                     }\n                 };\n@@ -4163,7 +4162,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let search_result = match namespace {\n             ValueNS => {\n                 let renamed = mtwt::resolve(ident);\n-                self.search_ribs(self.value_ribs.as_slice(), renamed, span)\n+                self.search_ribs(&self.value_ribs, renamed, span)\n             }\n             TypeNS => {\n                 let name = ident.name;\n@@ -4424,15 +4423,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((DefVariant(_, _, true), _)) => {\n                         let path_name = self.path_names_to_string(path);\n                         self.resolve_error(expr.span,\n-                                format!(\"`{}` is a struct variant name, but \\\n-                                         this expression \\\n-                                         uses it like a function name\",\n-                                        path_name).as_slice());\n+                                &format!(\"`{}` is a struct variant name, but \\\n+                                          this expression \\\n+                                          uses it like a function name\",\n+                                         path_name));\n \n                         self.session.span_help(expr.span,\n-                            format!(\"Did you mean to write: \\\n-                                    `{} {{ /* fields */ }}`?\",\n-                                    path_name).as_slice());\n+                            &format!(\"Did you mean to write: \\\n+                                     `{} {{ /* fields */ }}`?\",\n+                                     path_name));\n                     }\n                     Some(def) => {\n                         // Write the result into the def map.\n@@ -4452,15 +4451,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             Some((DefTy(struct_id, _), _))\n                               if self.structs.contains_key(&struct_id) => {\n                                 self.resolve_error(expr.span,\n-                                        format!(\"`{}` is a structure name, but \\\n-                                                 this expression \\\n-                                                 uses it like a function name\",\n-                                                path_name).as_slice());\n+                                        &format!(\"`{}` is a structure name, but \\\n+                                                  this expression \\\n+                                                  uses it like a function name\",\n+                                                 path_name));\n \n                                 self.session.span_help(expr.span,\n-                                    format!(\"Did you mean to write: \\\n-                                            `{} {{ /* fields */ }}`?\",\n-                                            path_name).as_slice());\n+                                    &format!(\"Did you mean to write: \\\n+                                             `{} {{ /* fields */ }}`?\",\n+                                             path_name));\n \n                             }\n                             _ => {\n@@ -4489,7 +4488,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         NoSuggestion => {\n                                             // limit search to 5 to reduce the number\n                                             // of stupid suggestions\n-                                            self.find_best_match_for_name(path_name.as_slice(), 5)\n+                                            self.find_best_match_for_name(&path_name, 5)\n                                                                 .map_or(\"\".to_string(),\n                                                                         |x| format!(\"`{}`\", x))\n                                         }\n@@ -4509,9 +4508,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                                     self.resolve_error(\n                                         expr.span,\n-                                        format!(\"unresolved name `{}`{}\",\n-                                                path_name,\n-                                                msg).as_slice());\n+                                        &format!(\"unresolved name `{}`{}\",\n+                                                 path_name,\n+                                                 msg));\n                                 }\n                             }\n                         }"}, {"sha": "2828fafddf02a5338bfb670d1b13a3cb97454a42", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -609,7 +609,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).as_slice());\n+                let bc_filename = obj_filename.with_extension(&format!(\"{}.bc\", i));\n                 let bc_deflated_filename = obj_filename.with_extension(\n                     &format!(\"{}.bytecode.deflate\", i)[]);\n \n@@ -1087,8 +1087,8 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             let lib = archive::find_library(&l[],\n-                                            sess.target.target.options.staticlib_prefix.as_slice(),\n-                                            sess.target.target.options.staticlib_suffix.as_slice(),\n+                                            &sess.target.target.options.staticlib_prefix,\n+                                            &sess.target.target.options.staticlib_suffix,\n                                             &search_path[],\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();"}, {"sha": "c88e76f42707348001214e34eff7889dba5cc897", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -64,7 +64,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         debug!(\"reading {}\", file);\n         for i in iter::count(0us, 1) {\n             let bc_encoded = time(sess.time_passes(),\n-                                  format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n+                                  &format!(\"check for {}.{}.bytecode.deflate\", name, i),\n                                   (),\n                                   |_| {\n                                       archive.read(&format!(\"{}.{}.bytecode.deflate\",\n@@ -84,7 +84,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             };\n \n             let bc_decoded = if is_versioned_bytecode_format(bc_encoded) {\n-                time(sess.time_passes(), format!(\"decode {}.{}.bc\", file, i).as_slice(), (), |_| {\n+                time(sess.time_passes(), &format!(\"decode {}.{}.bc\", file, i), (), |_| {\n                     // Read the version\n                     let version = extract_bytecode_format_version(bc_encoded);\n \n@@ -108,7 +108,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     }\n                 })\n             } else {\n-                time(sess.time_passes(), format!(\"decode {}.{}.bc\", file, i).as_slice(), (), |_| {\n+                time(sess.time_passes(), &format!(\"decode {}.{}.bc\", file, i), (), |_| {\n                 // the object must be in the old, pre-versioning format, so simply\n                 // inflate everything and let LLVM decide if it can make sense of it\n                     match flate::inflate_bytes(bc_encoded) {"}, {"sha": "8a30806f3b601ab62f98701f17e992df5e8199a0", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -50,7 +50,7 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n             handler.fatal(&msg[]);\n         } else {\n             let err = ffi::c_str_to_bytes(&cstr);\n-            let err = String::from_utf8_lossy(err.as_slice()).to_string();\n+            let err = String::from_utf8_lossy(err).to_string();\n             libc::free(cstr as *mut _);\n             handler.fatal(&format!(\"{}: {}\",\n                                   &msg[],\n@@ -223,8 +223,8 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let tm = unsafe {\n         let triple = CString::from_slice(triple.as_bytes());\n         let cpu = match sess.opts.cg.target_cpu {\n-            Some(ref s) => s.as_slice(),\n-            None => sess.target.target.options.cpu.as_slice()\n+            Some(ref s) => &**s,\n+            None => &*sess.target.target.options.cpu\n         };\n         let cpu = CString::from_slice(cpu.as_bytes());\n         let features = CString::from_slice(target_feature(sess).as_bytes());\n@@ -375,7 +375,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n             report_inline_asm(cgcx,\n-                              llvm::twine_to_string(inline.message).as_slice(),\n+                              &*llvm::twine_to_string(inline.message),\n                               inline.cookie);\n         }\n \n@@ -390,11 +390,11 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n \n             if enabled {\n                 let loc = llvm::debug_loc_to_string(llcx, opt.debug_loc);\n-                cgcx.handler.note(format!(\"optimization {} for {} at {}: {}\",\n-                                          opt.kind.describe(),\n-                                          pass_name,\n-                                          if loc.is_empty() { \"[unknown]\" } else { loc.as_slice() },\n-                                          llvm::twine_to_string(opt.message)).as_slice());\n+                cgcx.handler.note(&format!(\"optimization {} for {} at {}: {}\",\n+                                           opt.kind.describe(),\n+                                           pass_name,\n+                                           if loc.is_empty() { \"[unknown]\" } else { &*loc },\n+                                           llvm::twine_to_string(opt.message)));\n             }\n         }\n \n@@ -423,7 +423,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n-        let out = output_names.with_extension(ext.as_slice());\n+        let out = output_names.with_extension(&ext);\n         let out = CString::from_slice(out.as_vec());\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n@@ -455,8 +455,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             for pass in &config.passes {\n                 let pass = CString::from_slice(pass.as_bytes());\n                 if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n-                    cgcx.handler.warn(format!(\"unknown pass {:?}, ignoring\",\n-                                              pass).as_slice());\n+                    cgcx.handler.warn(&format!(\"unknown pass {:?}, ignoring\", pass));\n                 }\n             }\n \n@@ -477,7 +476,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n                     if config.emit_lto_bc {\n                         let name = format!(\"{}.lto.bc\", name_extra);\n-                        let out = output_names.with_extension(name.as_slice());\n+                        let out = output_names.with_extension(&name);\n                         let out = CString::from_slice(out.as_vec());\n                         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n                     }\n@@ -511,15 +510,15 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if config.emit_bc {\n         let ext = format!(\"{}.bc\", name_extra);\n-        let out = output_names.with_extension(ext.as_slice());\n+        let out = output_names.with_extension(&ext);\n         let out = CString::from_slice(out.as_vec());\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     time(config.time_passes, \"codegen passes\", (), |()| {\n         if config.emit_ir {\n             let ext = format!(\"{}.ll\", name_extra);\n-            let out = output_names.with_extension(ext.as_slice());\n+            let out = output_names.with_extension(&ext);\n             let out = CString::from_slice(out.as_vec());\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n@@ -1013,7 +1012,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n \n         // FIXME #21627 disable faulty FastISel on AArch64 (even for -O0)\n-        if sess.target.target.arch.as_slice() == \"aarch64\" { add(\"-fast-isel=0\"); }\n+        if sess.target.target.arch == \"aarch64\" { add(\"-fast-isel=0\"); }\n \n         for arg in &sess.opts.cg.llvm_args {\n             add(&(*arg)[]);"}, {"sha": "ab9617d6365cbf31e0c68173dfdb557cbd1e226f", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -309,7 +309,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        ty::item_path_str(&self.analysis.ty_cx, def_id).as_slice());\n+                                        &ty::item_path_str(&self.analysis.ty_cx, def_id));\n                                 },\n                                 None => {}\n                             }\n@@ -643,7 +643,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         item.id);\n \n                     for field in &struct_def.fields {\n-                        self.process_struct_field_def(field, qualname.as_slice(), variant.node.id);\n+                        self.process_struct_field_def(field, &qualname, variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n                 }\n@@ -795,7 +795,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&id) {\n             self.sess.span_bug(span,\n-                               format!(\"def_map has no key for {} in visit_expr\", id).as_slice());\n+                               &format!(\"def_map has no key for {} in visit_expr\", id));\n         }\n         let def = &(*def_map)[id];\n         let sub_span = self.span.span_for_last_ident(span);\n@@ -1117,7 +1117,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         self.fmt.use_glob_str(path.span,\n                                               sub_span,\n                                               item.id,\n-                                              name_string.as_slice(),\n+                                              &name_string,\n                                               self.cur_scope);\n                         self.write_sub_paths(path, true);\n                     }\n@@ -1200,7 +1200,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                      &value[]);\n \n                 self.visit_ty(&**ty);\n-                self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n+                self.process_generic_params(ty_params, item.span, &qualname, item.id);\n             },\n             ast::ItemMac(_) => (),\n             _ => visit::walk_item(self, item),"}, {"sha": "3bd04ed29d4a1139a2a3bc502a6241793931c616", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -229,8 +229,8 @@ impl<'a> FmtStrs<'a> {\n \n         if !needs_span {\n             self.span.sess.span_bug(span,\n-                                    format!(\"Called record_with_span for '{}' \\\n-                                             which does not require a span\", label).as_slice());\n+                                    &format!(\"Called record_with_span for '{}' \\\n+                                              which does not require a span\", label));\n         }\n \n         let values_str = match self.make_values_str(label, fields, values, span) {"}, {"sha": "1fea8f6aa3b1d8be9985b98207de536d07f27b90", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1029,8 +1029,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         field_vals.len())\n             );\n             let mut vals = field_vals;\n-            vals.push_all(vals_left.as_slice());\n-            compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n+            vals.push_all(&vals_left);\n+            compile_submatch(bcx, &pats, &vals, chk, has_genuine_default);\n             return;\n         }\n         _ => ()"}, {"sha": "21e52e5fffe56a509814ab7193c01515b0962754", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -265,9 +265,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // Use the minimum integer type we figured out above\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n-                ftys.push_all(c.tys.as_slice());\n+                ftys.push_all(&c.tys);\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                mk_struct(cx, ftys.as_slice(), false, t)\n+                mk_struct(cx, &ftys, false, t)\n             }).collect();\n \n \n@@ -283,7 +283,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // This check is needed to avoid increasing the size of types when\n             // the alignment of the first field is smaller than the overall\n             // alignment of the type.\n-            let (_, align) = union_size_and_align(fields.as_slice());\n+            let (_, align) = union_size_and_align(&fields);\n             let mut use_align = true;\n             for st in &fields {\n                 // Get the first non-zero-sized field"}, {"sha": "1d910c81da988318ff3cd69d06e8ff06fbc000ba", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -125,7 +125,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),\n                           constraints.as_ptr(),\n-                          inputs.as_slice(),\n+                          &inputs,\n                           output_type,\n                           ia.volatile,\n                           ia.alignstack,"}, {"sha": "38051a647caf3b2f2a87fa4a2f723241243f80f6", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -115,7 +115,7 @@ pub fn with_insn_ctxt<F>(blk: F) where\n     F: FnOnce(&[&'static str]),\n {\n     TASK_LOCAL_INSN_KEY.with(move |slot| {\n-        slot.borrow().as_ref().map(move |s| blk(s.as_slice()));\n+        slot.borrow().as_ref().map(move |s| blk(s));\n     })\n }\n \n@@ -1354,8 +1354,8 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         // glue, shims, etc\n         None if id == ast::DUMMY_NODE_ID => return (ast::DUMMY_NODE_ID, None),\n \n-        _ => tcx.sess.bug(format!(\"unexpected variant in has_nested_returns: {}\",\n-                                  tcx.map.path_to_string(id)).as_slice())\n+        _ => tcx.sess.bug(&format!(\"unexpected variant in has_nested_returns: {}\",\n+                                   tcx.map.path_to_string(id)))\n     };\n \n     (blk.id, Some(cfg::CFG::new(tcx, &**blk)))\n@@ -2247,7 +2247,7 @@ pub fn update_linkage(ccx: &CrateContext,\n     if let Some(id) = id {\n         let item = ccx.tcx().map.get(id);\n         if let ast_map::NodeItem(i) = item {\n-            if let Some(name) = attr::first_attr_value_str_by_name(i.attrs.as_slice(), \"linkage\") {\n+            if let Some(name) = attr::first_attr_value_str_by_name(&i.attrs, \"linkage\") {\n                 if let Some(linkage) = llvm_linkage_by_name(name.get()) {\n                     llvm::SetLinkage(llval, linkage);\n                 } else {\n@@ -2987,10 +2987,10 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let mut compressed = encoder::metadata_encoding_version.to_vec();\n-    compressed.push_all(match flate::deflate_bytes(metadata.as_slice()) {\n+    compressed.push_all(&match flate::deflate_bytes(&metadata) {\n         Some(compressed) => compressed,\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n-    }.as_slice());\n+    });\n     let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n@@ -3062,7 +3062,7 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                 let name = ffi::c_str_to_bytes(&llvm::LLVMGetValueName(val))\n                                .to_vec();\n                 if !declared.contains(&name) &&\n-                   !reachable.contains(str::from_utf8(name.as_slice()).unwrap()) {\n+                   !reachable.contains(str::from_utf8(&name).unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);\n                 }\n             }"}, {"sha": "bc171e3ae4381fbbce881c5fdc3e3627b53e1d1e", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -159,7 +159,7 @@ fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n \n fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, coerce_to_int(ccx, size).as_slice(), false)\n+    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n }\n \n pub fn compute_abi_info(ccx: &CrateContext,"}, {"sha": "4871617e89f3bfd1b0b9c5f319f984cd774ac18c", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -154,7 +154,7 @@ fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n \n fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, coerce_to_int(ccx, size).as_slice(), false)\n+    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n }\n \n pub fn compute_abi_info(ccx: &CrateContext,"}, {"sha": "ab41fe31a6e20b0343e7fbe409b75404119557b3", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -237,7 +237,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 unify(cls, ix + off / 8, SSEDs);\n             }\n             Struct => {\n-                classify_struct(ty.field_types().as_slice(), cls, ix, off, ty.is_packed());\n+                classify_struct(&ty.field_types(), cls, ix, off, ty.is_packed());\n             }\n             Array => {\n                 let len = ty.array_length();\n@@ -322,11 +322,11 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     let words = (ty_size(ty) + 7) / 8;\n     let mut cls: Vec<_> = repeat(NoClass).take(words).collect();\n     if words > 4 {\n-        all_mem(cls.as_mut_slice());\n+        all_mem(&mut cls);\n         return cls;\n     }\n-    classify(ty, cls.as_mut_slice(), 0, 0);\n-    fixup(ty, cls.as_mut_slice());\n+    classify(ty, &mut cls, 0, 0);\n+    fixup(ty, &mut cls);\n     return cls;\n }\n \n@@ -381,7 +381,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n         // if the type contains only a vector, pass it as that vector.\n         tys[0]\n     } else {\n-        Type::struct_(ccx, tys.as_slice(), false)\n+        Type::struct_(ccx, &tys, false)\n     }\n }\n \n@@ -398,11 +398,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     {\n         if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n-            if is_mem_cls(cls.as_slice()) {\n+            if is_mem_cls(&cls) {\n                 ArgType::indirect(ty, Some(ind_attr))\n             } else {\n                 ArgType::direct(ty,\n-                                Some(llreg_ty(ccx, cls.as_slice())),\n+                                Some(llreg_ty(ccx, &cls)),\n                                 None,\n                                 None)\n             }"}, {"sha": "5ca3d9ba1d9b6c9a165af5393d8def27e97d1a8c", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -582,7 +582,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               })\n           }\n           ast::ExprVec(ref es) => {\n-            const_vec(cx, e, es.as_slice()).0\n+            const_vec(cx, e, es).0\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n             let vec_ty = ty::expr_ty(cx.tcx(), e);"}, {"sha": "27dba9c4809b93b830279af8046af9c7698300f9", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -224,11 +224,11 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     let mod_name = CString::from_slice(mod_name.as_bytes());\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n-    let data_layout = sess.target.target.data_layout.as_slice();\n+    let data_layout = &*sess.target.target.data_layout;\n     let data_layout = CString::from_slice(data_layout.as_bytes());\n     llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n \n-    let llvm_target = sess.target.target.llvm_target.as_slice();\n+    let llvm_target = &*sess.target.target.llvm_target;\n     let llvm_target = CString::from_slice(llvm_target.as_bytes());\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n     (llcx, llmod)"}, {"sha": "1e788351172fc0e2ad26c00d6eccfc57915ca459", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1246,7 +1246,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n-            if contains_nodebug_attribute(item.attrs.as_slice()) {\n+            if contains_nodebug_attribute(&item.attrs) {\n                 return FunctionDebugContext::FunctionWithoutDebugInfo;\n             }\n \n@@ -1263,7 +1263,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeImplItem(ref item) => {\n             match **item {\n                 ast::MethodImplItem(ref method) => {\n-                    if contains_nodebug_attribute(method.attrs.as_slice()) {\n+                    if contains_nodebug_attribute(&method.attrs) {\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n@@ -1302,7 +1302,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeTraitItem(ref trait_method) => {\n             match **trait_method {\n                 ast::ProvidedMethod(ref method) => {\n-                    if contains_nodebug_attribute(method.attrs.as_slice()) {\n+                    if contains_nodebug_attribute(&method.attrs) {\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n@@ -1399,7 +1399,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     let scope_map = create_scope_map(cx,\n-                                     fn_decl.inputs.as_slice(),\n+                                     &fn_decl.inputs,\n                                      &*top_level_block,\n                                      fn_metadata,\n                                      fn_ast_id);\n@@ -2483,7 +2483,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         UNKNOWN_LINE_NUMBER,\n                         bytes_to_bits(discriminant_size),\n                         bytes_to_bits(discriminant_align),\n-                        create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n+                        create_DIArray(DIB(cx), &enumerators_metadata),\n                         discriminant_base_type_metadata)\n                 };\n \n@@ -3764,7 +3764,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             match optional_length {\n                 Some(len) => {\n-                    output.push_str(format!(\"; {}\", len).as_slice());\n+                    output.push_str(&format!(\"; {}\", len));\n                 }\n                 None => { /* nothing to do */ }\n             };\n@@ -4070,11 +4070,10 @@ fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n \n fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(ccx.tcx()\n-                               .map\n-                               .krate()\n-                               .attrs\n-                               .as_slice(),\n+        attr::contains_name(&ccx.tcx()\n+                                .map\n+                                .krate()\n+                                .attrs,\n                             \"omit_gdb_pretty_printer_section\");\n \n     !omit_gdb_pretty_printer_section &&"}, {"sha": "dea34baad376fc8e5b40e9f7781e3a5b61b94874", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1056,7 +1056,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if let Some(did) = did {\n                 let substs = Substs::new_type(ty_params, vec![]);\n                 trans_struct(bcx,\n-                             fields.as_slice(),\n+                             &fields,\n                              None,\n                              expr.span,\n                              expr.id,\n@@ -1398,7 +1398,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         trans_adt(bcx,\n                   ty,\n                   discr,\n-                  numbered_fields.as_slice(),\n+                  &numbered_fields,\n                   optbase,\n                   dest,\n                   DebugLoc::At(expr_id, expr_span))"}, {"sha": "48f519398cee5fd89d6b73048912e36358acaf7b", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -788,7 +788,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"calling llrustfn = {}, t = {}\",\n                ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n         let attributes = base::get_fn_llvm_attributes(ccx, t);\n-        let llrust_ret_val = builder.call(llrustfn, llrust_args.as_slice(), Some(attributes));\n+        let llrust_ret_val = builder.call(llrustfn, &llrust_args, Some(attributes));\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {\n@@ -898,7 +898,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n-    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n+    let llsig = foreign_signature(ccx, &fn_sig, &fn_sig.inputs);\n     let fn_ty = cabi::compute_abi_info(ccx,\n                                        &llsig.llarg_tys[],\n                                        llsig.llret_ty,\n@@ -911,7 +911,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            ty.repr(ccx.tcx()),\n            ccx.tn().types_to_str(&llsig.llarg_tys[]),\n            ccx.tn().type_to_string(llsig.llret_ty),\n-           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n+           ccx.tn().types_to_str(&fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n            llsig.ret_def);\n \n@@ -959,7 +959,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     }\n \n     if tys.fn_sig.variadic {\n-        Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n+        Type::variadic_func(&llargument_tys, &llreturn_ty)\n     } else {\n         Type::func(&llargument_tys[], &llreturn_ty)\n     }"}, {"sha": "08be8fa193dda951d65ea32421a94b549187d8be", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -118,25 +118,25 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n             if transmute_restriction.original_from != transmute_restriction.substituted_from {\n                 ccx.sess().span_err(\n                     transmute_restriction.span,\n-                    format!(\"transmute called on types with potentially different sizes: \\\n-                             {} (could be {} bit{}) to {} (could be {} bit{})\",\n-                            ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n-                            from_type_size as uint,\n-                            if from_type_size == 1 {\"\"} else {\"s\"},\n-                            ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n-                            to_type_size as uint,\n-                            if to_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n+                    &format!(\"transmute called on types with potentially different sizes: \\\n+                              {} (could be {} bit{}) to {} (could be {} bit{})\",\n+                             ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n+                             from_type_size as uint,\n+                             if from_type_size == 1 {\"\"} else {\"s\"},\n+                             ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n+                             to_type_size as uint,\n+                             if to_type_size == 1 {\"\"} else {\"s\"}));\n             } else {\n                 ccx.sess().span_err(\n                     transmute_restriction.span,\n-                    format!(\"transmute called on types with different sizes: \\\n-                             {} ({} bit{}) to {} ({} bit{})\",\n-                            ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n-                            from_type_size as uint,\n-                            if from_type_size == 1 {\"\"} else {\"s\"},\n-                            ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n-                            to_type_size as uint,\n-                            if to_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n+                    &format!(\"transmute called on types with different sizes: \\\n+                              {} ({} bit{}) to {} ({} bit{})\",\n+                             ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n+                             from_type_size as uint,\n+                             if from_type_size == 1 {\"\"} else {\"s\"},\n+                             ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n+                             to_type_size as uint,\n+                             if to_type_size == 1 {\"\"} else {\"s\"}));\n             }\n         }\n     }\n@@ -309,7 +309,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n     let llval = match (simple, name.get()) {\n         (Some(llfn), _) => {\n-            Call(bcx, llfn, llargs.as_slice(), None, call_debug_location)\n+            Call(bcx, llfn, &llargs, None, call_debug_location)\n         }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));"}, {"sha": "9c440d4509e0090c546ab848e7f3ba0201ee3c43", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -567,8 +567,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n                 data.principal_trait_ref_with_self_ty(tcx, object_ty)\n             }\n             _ => {\n-                tcx.sess.bug(format!(\"trans_object_shim() called on non-object: {}\",\n-                                     object_ty.repr(tcx)).as_slice());\n+                tcx.sess.bug(&format!(\"trans_object_shim() called on non-object: {}\",\n+                                      object_ty.repr(tcx)));\n             }\n         };\n \n@@ -595,7 +595,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let function_name =\n         link::mangle_internal_name_by_type_and_seq(ccx, method_bare_fn_ty, \"object_shim\");\n     let llfn =\n-        decl_internal_rust_fn(ccx, method_bare_fn_ty, function_name.as_slice());\n+        decl_internal_rust_fn(ccx, method_bare_fn_ty, &function_name);\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n \n@@ -624,11 +624,11 @@ pub fn trans_object_shim<'a, 'tcx>(\n             RustCall => {\n                 // unpack the tuple to extract the input type arguments:\n                 match sig.inputs[1].sty {\n-                    ty::ty_tup(ref tys) => tys.as_slice(),\n+                    ty::ty_tup(ref tys) => &**tys,\n                     _ => {\n                         bcx.sess().bug(\n-                            format!(\"rust-call expects a tuple not {}\",\n-                                    sig.inputs[1].repr(tcx)).as_slice());\n+                            &format!(\"rust-call expects a tuple not {}\",\n+                                     sig.inputs[1].repr(tcx)));\n                     }\n                 }\n             }\n@@ -673,7 +673,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n                                                                   method_bare_fn_ty,\n                                                                   method_offset_in_vtable,\n                                                                   llobject),\n-                           ArgVals(llargs.as_slice()),\n+                           ArgVals(&llargs),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n@@ -744,8 +744,8 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // an object type; this cannot happen because we\n                 // cannot cast an unsized type into a trait object\n                 bcx.sess().bug(\n-                    format!(\"cannot get vtable for an object type: {}\",\n-                            data.repr(bcx.tcx())).as_slice());\n+                    &format!(\"cannot get vtable for an object type: {}\",\n+                             data.repr(bcx.tcx())));\n             }\n             traits::VtableParam(..) => {\n                 bcx.sess().bug("}, {"sha": "9d1c0fadefcd22718ca1dac09debc1fb7cb9e3fc", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -113,7 +113,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let mut atys: Vec<Type> = Vec::new();\n \n     // First, munge the inputs, if this has the `rust-call` ABI.\n-    let inputs = untuple_arguments_if_necessary(cx, sig.inputs.as_slice(), abi);\n+    let inputs = untuple_arguments_if_necessary(cx, &sig.inputs, abi);\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)"}, {"sha": "58f4d3f1bc0379bc6b9e8cf1c1d10abfd5ee0bd0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -272,7 +272,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n         }\n     };\n \n-    prohibit_projections(this.tcx(), assoc_bindings.as_slice());\n+    prohibit_projections(this.tcx(), &assoc_bindings);\n \n     create_substs_for_ast_path(this,\n                                rscope,\n@@ -656,7 +656,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n \n     match projections {\n         None => {\n-            prohibit_projections(this.tcx(), assoc_bindings.as_slice());\n+            prohibit_projections(this.tcx(), &assoc_bindings);\n         }\n         Some(ref mut v) => {\n             for binding in &assoc_bindings {\n@@ -960,7 +960,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n         // FIXME(#20300) -- search where clauses, not bounds\n         suitable_bounds =\n-            traits::transitive_bounds(tcx, ty_param_def.bounds.trait_bounds.as_slice())\n+            traits::transitive_bounds(tcx, &ty_param_def.bounds.trait_bounds)\n             .filter(|b| trait_defines_associated_type_named(this, b.def_id(), assoc_name))\n             .collect();\n     }\n@@ -1595,11 +1595,11 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n     let region_bound = compute_region_bound(this,\n                                             rscope,\n                                             span,\n-                                            region_bounds.as_slice(),\n+                                            &region_bounds,\n                                             principal_trait_ref,\n                                             builtin_bounds);\n \n-    ty::sort_bounds_list(projection_bounds.as_mut_slice());\n+    ty::sort_bounds_list(&mut projection_bounds);\n \n     ty::ExistentialBounds {\n         region_bound: region_bound,"}, {"sha": "1249e0d8ce1e549979cf446f3368a49d1a809e58", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -164,7 +164,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_pat_enum(pcx, pat, path, subpats, expected);\n         }\n         ast::PatStruct(ref path, ref fields, etc) => {\n-            check_pat_struct(pcx, pat, path, fields.as_slice(), etc, expected);\n+            check_pat_struct(pcx, pat, path, fields, etc, expected);\n         }\n         ast::PatTup(ref elements) => {\n             let element_tys: Vec<_> =\n@@ -480,7 +480,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         .unwrap_or_else(|| Substs::empty());\n \n     let struct_fields = ty::struct_fields(tcx, variant_def_id, &item_substs);\n-    check_struct_pat_fields(pcx, pat.span, fields, struct_fields.as_slice(),\n+    check_struct_pat_fields(pcx, pat.span, fields, &struct_fields,\n                             variant_def_id, etc);\n }\n "}, {"sha": "6a9d34d7637b23d57a9be8b71387f5e991dd47b6", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -252,10 +252,10 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                                       call_expr.span,\n                                                       expected,\n                                                       fn_sig.output,\n-                                                      fn_sig.inputs.as_slice());\n+                                                      &fn_sig.inputs);\n     check_argument_types(fcx,\n                          call_expr.span,\n-                         fn_sig.inputs.as_slice(),\n+                         &fn_sig.inputs,\n                          &expected_arg_tys[],\n                          arg_exprs,\n                          AutorefArgs::No,"}, {"sha": "77701af25d39ab0f9aebde4fd8d7c19f77a41936", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -655,9 +655,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             None => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    format!(\"cannot upcast `{}` to `{}`\",\n-                            source_trait_ref.repr(self.tcx()),\n-                            target_trait_def_id.repr(self.tcx())).as_slice());\n+                    &format!(\"cannot upcast `{}` to `{}`\",\n+                             source_trait_ref.repr(self.tcx()),\n+                             target_trait_def_id.repr(self.tcx())));\n             }\n         }\n     }"}, {"sha": "ba49ae637b32e6cd9c6de0f2dd3bd8eeb2cd5d1d", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -368,7 +368,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(bounds.as_slice(), |this, poly_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&bounds, |this, poly_trait_ref, m, method_num| {\n             let trait_ref =\n                 this.erase_late_bound_regions(&poly_trait_ref);\n "}, {"sha": "fb05450373f7df437fcfb3a77ccae960ca627633", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -730,7 +730,7 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n                                                &*impl_trait_ref,\n-                                               impl_items.as_slice());\n+                                               impl_items);\n               }\n               None => { }\n           }\n@@ -806,7 +806,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }) {\n         if let Some(ref istring) = attr.value_str() {\n             let parser = Parser::new(istring.get());\n-            let types = generics.ty_params.as_slice();\n+            let types = &*generics.ty_params;\n             for token in parser {\n                 match token {\n                     Piece::String(_) => (), // Normal string, no need to check it\n@@ -908,9 +908,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 // caught in resolve.\n                                 tcx.sess.span_bug(\n                                     impl_method.span,\n-                                    format!(\"item `{}` is of a different kind from its trait `{}`\",\n-                                            token::get_name(impl_item_ty.name()),\n-                                            impl_trait_ref.repr(tcx)).as_slice());\n+                                    &format!(\"item `{}` is of a different kind from its trait `{}`\",\n+                                             token::get_name(impl_item_ty.name()),\n+                                             impl_trait_ref.repr(tcx)));\n                             }\n                         }\n                     }\n@@ -919,9 +919,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n                             impl_method.span,\n-                            format!(\"method `{}` is not a member of trait `{}`\",\n-                                    token::get_name(impl_item_ty.name()),\n-                                    impl_trait_ref.repr(tcx)).as_slice());\n+                            &format!(\"method `{}` is not a member of trait `{}`\",\n+                                     token::get_name(impl_item_ty.name()),\n+                                     impl_trait_ref.repr(tcx)));\n                     }\n                 }\n             }\n@@ -944,9 +944,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 // already been caught in resolve.\n                                 tcx.sess.span_bug(\n                                     typedef.span,\n-                                    format!(\"item `{}` is of a different kind from its trait `{}`\",\n-                                            token::get_name(typedef_ty.name()),\n-                                            impl_trait_ref.repr(tcx)).as_slice());\n+                                    &format!(\"item `{}` is of a different kind from its trait `{}`\",\n+                                             token::get_name(typedef_ty.name()),\n+                                             impl_trait_ref.repr(tcx)));\n                             }\n                         }\n                     }\n@@ -955,11 +955,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n                             typedef.span,\n-                            format!(\n+                            &format!(\n                                 \"associated type `{}` is not a member of \\\n                                  trait `{}`\",\n                                 token::get_name(typedef_ty.name()),\n-                                impl_trait_ref.repr(tcx)).as_slice());\n+                                impl_trait_ref.repr(tcx)));\n                     }\n                 }\n             }\n@@ -3123,7 +3123,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         if let Some(n) = best {\n             tcx.sess.span_help(field.span,\n-                format!(\"did you mean `{}`?\", n).as_slice());\n+                &format!(\"did you mean `{}`?\", n));\n         }\n     }\n \n@@ -3734,7 +3734,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprMatch(ref discrim, ref arms, match_src) => {\n-        _match::check_match(fcx, expr, &**discrim, arms.as_slice(), expected, match_src);\n+        _match::check_match(fcx, expr, &**discrim, arms, expected, match_src);\n       }\n       ast::ExprClosure(capture, ref decl, ref body) => {\n           closure::check_expr_closure(fcx, expr, capture, &**decl, &**body, expected);\n@@ -5217,7 +5217,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n-        let name = token::intern(format!(\"P{}\", n).as_slice());\n+        let name = token::intern(&format!(\"P{}\", n));\n         ty::mk_param(ccx.tcx, subst::FnSpace, n, name)\n     }\n "}, {"sha": "3ff36f8c44f5fbc7bf8d42654e3d43906e70ca38", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -153,31 +153,31 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n             ObjectSafetyViolation::Method(method, MethodViolationCode::ByValueSelf) => {\n                 tcx.sess.span_note(\n                     span,\n-                    format!(\"method `{}` has a receiver type of `Self`, \\\n-                             which cannot be used with a trait object\",\n-                            method.name.user_string(tcx)).as_slice());\n+                    &format!(\"method `{}` has a receiver type of `Self`, \\\n+                              which cannot be used with a trait object\",\n+                             method.name.user_string(tcx)));\n             }\n \n             ObjectSafetyViolation::Method(method, MethodViolationCode::StaticMethod) => {\n                 tcx.sess.span_note(\n                     span,\n-                    format!(\"method `{}` has no receiver\",\n-                            method.name.user_string(tcx)).as_slice());\n+                    &format!(\"method `{}` has no receiver\",\n+                             method.name.user_string(tcx)));\n             }\n \n             ObjectSafetyViolation::Method(method, MethodViolationCode::ReferencesSelf) => {\n                 tcx.sess.span_note(\n                     span,\n-                    format!(\"method `{}` references the `Self` type \\\n-                             in its arguments or return type\",\n-                            method.name.user_string(tcx)).as_slice());\n+                    &format!(\"method `{}` references the `Self` type \\\n+                              in its arguments or return type\",\n+                             method.name.user_string(tcx)));\n             }\n \n             ObjectSafetyViolation::Method(method, MethodViolationCode::Generic) => {\n                 tcx.sess.span_note(\n                     span,\n-                    format!(\"method `{}` has generic type parameters\",\n-                            method.name.user_string(tcx)).as_slice());\n+                    &format!(\"method `{}` has generic type parameters\",\n+                             method.name.user_string(tcx)));\n             }\n         }\n     }"}, {"sha": "1079e87a48bf620cac30fa691412f88e05adfe59", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -170,7 +170,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 variants.iter().flat_map(|v| v.fields.iter().map(|f| f.ty)).collect();\n \n             regionck::regionck_ensure_component_tys_wf(\n-                fcx, item.span, field_tys.as_slice());\n+                fcx, item.span, &field_tys);\n         });\n     }\n \n@@ -227,7 +227,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // There are special rules that apply to drop.\n             if\n                 fcx.tcx().lang_items.drop_trait() == Some(trait_ref.def_id) &&\n-                !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\")\n+                !attr::contains_name(&item.attrs, \"unsafe_destructor\")\n             {\n                 match self_ty.sty {\n                     ty::ty_struct(def_id, _) |"}, {"sha": "a571b2793df17906a806f40a12eb4305095fe82e", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -94,9 +94,9 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                     param_ty.user_string(self.tcx));\n                             self.tcx.sess.span_note(\n                                 item.span,\n-                                format!(\"for a limited time, you can add \\\n-                                         `#![feature(old_orphan_check)]` to your crate \\\n-                                         to disable this rule\").as_slice());\n+                                &format!(\"for a limited time, you can add \\\n+                                          `#![feature(old_orphan_check)]` to your crate \\\n+                                          to disable this rule\"));\n                         }\n                     }\n                 }"}, {"sha": "ce26658cf4b9392535ce65ff3ccf20d0327c6727", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -169,9 +169,9 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n                 ty_of_foreign_item(self, &*foreign_item, abi)\n             }\n             x => {\n-                self.tcx.sess.bug(format!(\"unexpected sort of node \\\n-                                           in get_item_type_scheme(): {:?}\",\n-                                          x).as_slice());\n+                self.tcx.sess.bug(&format!(\"unexpected sort of node \\\n+                                            in get_item_type_scheme(): {:?}\",\n+                                           x));\n             }\n         }\n     }\n@@ -562,7 +562,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n             get_enum_variant_types(ccx,\n                                    scheme.ty,\n-                                   enum_definition.variants.as_slice(),\n+                                   &enum_definition.variants,\n                                    generics);\n         },\n         ast::ItemImpl(_, _,\n@@ -846,7 +846,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                        ref generics,\n                        ref supertraits,\n                        ref items) => {\n-            (unsafety, generics, supertraits, items.as_slice())\n+            (unsafety, generics, supertraits, items)\n         }\n         ref s => {\n             tcx.sess.span_bug(\n@@ -878,7 +878,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     let bounds = compute_bounds(ccx,\n                                 self_param_ty.to_ty(ccx.tcx),\n-                                bounds.as_slice(),\n+                                bounds,\n                                 SizedByDefault::No,\n                                 it.span);\n \n@@ -1136,7 +1136,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n                 let bounds = compute_bounds(ccx,\n                                             assoc_ty,\n-                                            assoc_type_def.bounds.as_slice(),\n+                                            &*assoc_type_def.bounds,\n                                             SizedByDefault::Yes,\n                                             assoc_type_def.span);\n \n@@ -1448,7 +1448,7 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let astconv::PartitionedBounds { builtin_bounds,\n                                      trait_bounds,\n                                      region_bounds } =\n-        astconv::partition_bounds(ccx.tcx, span, ast_bounds.as_slice());\n+        astconv::partition_bounds(ccx.tcx, span, ast_bounds);\n \n     let mut projection_bounds = Vec::new();\n \n@@ -1701,18 +1701,18 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n             if ty::has_attr(tcx, impl_def_id, \"old_impl_check\") {\n                 tcx.sess.span_warn(\n                     ty_param.span,\n-                    format!(\"the type parameter `{}` is not constrained by the \\\n-                             impl trait, self type, or predicates\",\n-                            param_ty.user_string(tcx)).as_slice());\n+                    &format!(\"the type parameter `{}` is not constrained by the \\\n+                              impl trait, self type, or predicates\",\n+                             param_ty.user_string(tcx)));\n             } else {\n                 span_err!(tcx.sess, ty_param.span, E0207,\n                     \"the type parameter `{}` is not constrained by the \\\n                              impl trait, self type, or predicates\",\n                             param_ty.user_string(tcx));\n                 tcx.sess.span_help(\n                     ty_param.span,\n-                    format!(\"you can temporarily opt out of this rule by placing \\\n-                             the `#[old_impl_check]` attribute on the impl\").as_slice());\n+                    &format!(\"you can temporarily opt out of this rule by placing \\\n+                              the `#[old_impl_check]` attribute on the impl\"));\n             }\n         }\n     }"}, {"sha": "9cdad8fccbeb73d1bc5f2d16f67cc3375b0a2640", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -195,7 +195,7 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n     let fields = ty::lookup_struct_fields(tcx, did);\n \n     clean::Struct {\n-        struct_type: match fields.as_slice() {\n+        struct_type: match &*fields {\n             [] => doctree::Unit,\n             [ref f] if f.name == unnamed_field.name => doctree::Newtype,\n             [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n@@ -340,7 +340,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n     let polarity = csearch::get_impl_polarity(tcx, did);\n     return Some(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n-            derived: clean::detect_derived(attrs.as_slice()),\n+            derived: clean::detect_derived(&attrs),\n             trait_: associated_trait.clean(cx).map(|bound| {\n                 match bound {\n                     clean::TraitBound(polyt, _) => polyt.trait_,"}, {"sha": "248ce99ff9b724a453269d88283fea87ce9bdb65", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -48,7 +48,6 @@ use rustc::middle::stability;\n \n use std::rc::Rc;\n use std::u32;\n-use std::str::Str as StrTrait; // Conflicts with Str variant\n use std::old_path::Path as FsPath; // Conflicts with Path struct\n \n use core::DocContext;\n@@ -136,7 +135,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         // Figure out the name of this crate\n         let input = &cx.input;\n-        let name = link::find_crate_name(None, self.attrs.as_slice(), input);\n+        let name = link::find_crate_name(None, &self.attrs, input);\n \n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n@@ -171,7 +170,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     ModuleItem(..) => {}\n                     _ => continue,\n                 }\n-                let prim = match PrimitiveType::find(child.attrs.as_slice()) {\n+                let prim = match PrimitiveType::find(&child.attrs) {\n                     Some(prim) => prim,\n                     None => continue,\n                 };\n@@ -223,7 +222,7 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n                     _ => return\n                 };\n                 let attrs = inline::load_attrs(cx, tcx, did);\n-                PrimitiveType::find(attrs.as_slice()).map(|prim| primitives.push(prim));\n+                PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n             })\n         });\n         ExternalCrate {\n@@ -257,7 +256,7 @@ impl Item {\n         for attr in &self.attrs {\n             match *attr {\n                 List(ref x, ref list) if \"doc\" == *x => {\n-                    return Some(list.as_slice());\n+                    return Some(list);\n                 }\n                 _ => {}\n             }\n@@ -271,7 +270,7 @@ impl Item {\n         for attr in &self.attrs {\n             match *attr {\n                 NameValue(ref x, ref v) if \"doc\" == *x => {\n-                    return Some(v.as_slice());\n+                    return Some(v);\n                 }\n                 _ => {}\n             }\n@@ -433,15 +432,15 @@ impl attr::AttrMetaMethods for Attribute {\n     fn name(&self) -> InternedString {\n         match *self {\n             Word(ref n) | List(ref n, _) | NameValue(ref n, _) => {\n-                token::intern_and_get_ident(n.as_slice())\n+                token::intern_and_get_ident(n)\n             }\n         }\n     }\n \n     fn value_str(&self) -> Option<InternedString> {\n         match *self {\n             NameValue(_, ref v) => {\n-                Some(token::intern_and_get_ident(v.as_slice()))\n+                Some(token::intern_and_get_ident(v))\n             }\n             _ => None,\n         }\n@@ -626,7 +625,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         let fqn = csearch::get_item_path(tcx, self.def_id);\n         let fqn = fqn.into_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n-        let path = external_path(cx, fqn.last().unwrap().as_slice(),\n+        let path = external_path(cx, fqn.last().unwrap(),\n                                  Some(self.def_id), vec![], self.substs);\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n@@ -690,7 +689,7 @@ pub struct Lifetime(String);\n impl Lifetime {\n     pub fn get_ref<'a>(&'a self) -> &'a str {\n         let Lifetime(ref s) = *self;\n-        let s: &'a str = s.as_slice();\n+        let s: &'a str = s;\n         return s;\n     }\n \n@@ -952,7 +951,7 @@ impl Clean<Item> for ast::Method {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n-            ast::SelfStatic => all_inputs.as_slice(),\n+            ast::SelfStatic => &**all_inputs,\n             _ => &all_inputs[1..]\n         };\n         let decl = FnDecl {\n@@ -990,7 +989,7 @@ pub struct TyMethod {\n impl Clean<Item> for ast::TypeMethod {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n-            ast::SelfStatic => self.decl.inputs.as_slice(),\n+            ast::SelfStatic => &*self.decl.inputs,\n             _ => &self.decl.inputs[1..]\n         };\n         let decl = FnDecl {\n@@ -1104,7 +1103,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::PolyFnSig<'tcx>) {\n         } else {\n             Vec::new().into_iter()\n         }.peekable();\n-        if names.peek().map(|s| s.as_slice()) == Some(\"self\") {\n+        if names.peek().map(|s| &**s) == Some(\"self\") {\n             let _ = names.next();\n         }\n         FnDecl {\n@@ -1397,7 +1396,7 @@ pub enum TypeKind {\n \n impl PrimitiveType {\n     fn from_str(s: &str) -> Option<PrimitiveType> {\n-        match s.as_slice() {\n+        match s {\n             \"isize\" | \"int\" => Some(Isize),\n             \"i8\" => Some(I8),\n             \"i16\" => Some(I16),\n@@ -1428,7 +1427,7 @@ impl PrimitiveType {\n             for sub_attr in list {\n                 let value = match *sub_attr {\n                     NameValue(ref k, ref v)\n-                        if *k == \"primitive\" => v.as_slice(),\n+                        if *k == \"primitive\" => v,\n                     _ => continue,\n                 };\n                 match PrimitiveType::from_str(value) {\n@@ -1567,7 +1566,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     ty::ty_struct(..) => TypeStruct,\n                     _ => TypeEnum,\n                 };\n-                let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n+                let path = external_path(cx, &fqn.last().unwrap().to_string(),\n                                          None, vec![], substs);\n                 cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n                 ResolvedPath {\n@@ -1581,7 +1580,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let (typarams, bindings) = bounds.clean(cx);\n-                let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n+                let path = external_path(cx, &fqn.last().unwrap().to_string(),\n                                          Some(did), bindings, principal.substs());\n                 cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, TypeTrait));\n                 ResolvedPath {\n@@ -1780,7 +1779,7 @@ impl Clean<Item> for doctree::Variant {\n impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n-        let kind = match self.arg_names.as_ref().map(|s| s.as_slice()) {\n+        let kind = match self.arg_names.as_ref().map(|s| &**s) {\n             None | Some([]) if self.args.len() == 0 => CLikeVariant,\n             None | Some([]) => {\n                 TupleVariant(self.args.clean(cx))\n@@ -2132,7 +2131,7 @@ impl Clean<Item> for doctree::Impl {\n                             TypeImplItem(i) => i,\n                         }\n                     }).collect(),\n-                derived: detect_derived(self.attrs.as_slice()),\n+                derived: detect_derived(&self.attrs),\n                 polarity: Some(self.polarity.clean(cx)),\n             }),\n         }"}, {"sha": "f862970446c14909dd0a2a6568b0c923a3b1fa25", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -119,10 +119,10 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n \n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n \n-    let name = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n+    let name = link::find_crate_name(Some(&sess), &krate.attrs,\n                                      &input);\n \n-    let krate = driver::phase_2_configure_and_expand(&sess, krate, name.as_slice(), None)\n+    let krate = driver::phase_2_configure_and_expand(&sess, krate, &name, None)\n                     .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let mut forest = ast_map::Forest::new(krate);"}, {"sha": "942aec7d22f2c0bff99a4faaab2fce803e7cb477", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -36,7 +36,7 @@ impl ExternalHtml {\n pub fn load_string(input: &Path) -> old_io::IoResult<Option<String>> {\n     let mut f = try!(old_io::File::open(input));\n     let d = try!(f.read_to_end());\n-    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_string()).ok())\n+    Ok(str::from_utf8(&d).map(|s| s.to_string()).ok())\n }\n \n macro_rules! load_or_return {\n@@ -63,7 +63,7 @@ macro_rules! load_or_return {\n pub fn load_external_files(names: &[String]) -> Option<String> {\n     let mut out = String::new();\n     for name in names {\n-        out.push_str(load_or_return!(name.as_slice(), None, None).as_slice());\n+        out.push_str(&*load_or_return!(&name, None, None));\n         out.push('\\n');\n     }\n     Some(out)"}, {"sha": "f04e1cc75202f348ceb13318ad89ec88dd13ff75", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -24,7 +24,7 @@ impl<'a> fmt::Display for Escape<'a> {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n         let Escape(s) = *self;\n-        let pile_o_bits = s.as_slice();\n+        let pile_o_bits = s;\n         let mut last = 0;\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {"}, {"sha": "7a6157b63b5b003f543b2df5482f08d931d692e2", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -109,10 +109,10 @@ impl fmt::Display for clean::Generics {\n                 if i > 0 {\n                     try!(f.write_str(\", \"))\n                 }\n-                try!(f.write_str(tp.name.as_slice()));\n+                try!(f.write_str(&tp.name));\n \n                 if tp.bounds.len() > 0 {\n-                    try!(write!(f, \": {}\", TyParamBounds(tp.bounds.as_slice())));\n+                    try!(write!(f, \": {}\", TyParamBounds(&tp.bounds)));\n                 }\n \n                 match tp.default {\n@@ -139,7 +139,7 @@ impl<'a> fmt::Display for WhereClause<'a> {\n             }\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n-                    let bounds = bounds.as_slice();\n+                    let bounds = bounds;\n                     try!(write!(f, \"{}: {}\", ty, TyParamBounds(bounds)));\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime,\n@@ -259,7 +259,7 @@ impl fmt::Display for clean::PathParameters {\n \n impl fmt::Display for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.write_str(self.name.as_slice()));\n+        try!(f.write_str(&self.name));\n         write!(f, \"{}\", self.params)\n     }\n }\n@@ -321,8 +321,8 @@ fn path<F, G>(w: &mut fmt::Formatter,\n \n     let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n     let cache = cache();\n-    let abs_root = root(&*cache, loc.as_slice());\n-    let rel_root = match path.segments[0].name.as_slice() {\n+    let abs_root = root(&*cache, &loc);\n+    let rel_root = match &*path.segments[0].name {\n         \"self\" => Some(\"./\".to_string()),\n         _ => None,\n     };\n@@ -331,17 +331,17 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         let amt = path.segments.len() - 1;\n         match rel_root {\n             Some(root) => {\n-                let mut root = String::from_str(root.as_slice());\n+                let mut root = String::from_str(&root);\n                 for seg in &path.segments[..amt] {\n                     if \"super\" == seg.name ||\n                             \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n                     } else {\n-                        root.push_str(seg.name.as_slice());\n+                        root.push_str(&seg.name);\n                         root.push_str(\"/\");\n                         try!(write!(w, \"<a class='mod'\n                                             href='{}index.html'>{}</a>::\",\n-                                      root.as_slice(),\n+                                      root,\n                                       seg.name));\n                     }\n                 }\n@@ -357,21 +357,21 @@ fn path<F, G>(w: &mut fmt::Formatter,\n     match info(&*cache) {\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n-            let mut url = String::from_str(abs_root.unwrap().as_slice());\n+            let mut url = String::from_str(&abs_root.unwrap());\n             let to_link = &fqp[..fqp.len() - 1];\n             for component in to_link {\n-                url.push_str(component.as_slice());\n+                url.push_str(component);\n                 url.push_str(\"/\");\n             }\n             match shortty {\n                 ItemType::Module => {\n-                    url.push_str(fqp.last().unwrap().as_slice());\n+                    url.push_str(fqp.last().unwrap());\n                     url.push_str(\"/index.html\");\n                 }\n                 _ => {\n                     url.push_str(shortty.to_static_str());\n                     url.push_str(\".\");\n-                    url.push_str(fqp.last().unwrap().as_slice());\n+                    url.push_str(fqp.last().unwrap());\n                     url.push_str(\".html\");\n                 }\n             }\n@@ -384,7 +384,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n             try!(write!(w, \"{}\", last.name));\n         }\n     }\n-    try!(write!(w, \"{}\", generics.as_slice()));\n+    try!(write!(w, \"{}\", generics));\n     Ok(())\n }\n \n@@ -454,10 +454,10 @@ impl fmt::Display for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::TyParamBinder(id) => {\n-                f.write_str(cache().typarams[ast_util::local_def(id)].as_slice())\n+                f.write_str(&cache().typarams[ast_util::local_def(id)])\n             }\n             clean::Generic(ref name) => {\n-                f.write_str(name.as_slice())\n+                f.write_str(name)\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path } => {\n                 try!(resolved_path(f, did, path, false));\n@@ -468,7 +468,7 @@ impl fmt::Display for clean::Type {\n             clean::BareFunction(ref decl) => {\n                 write!(f, \"{}{}fn{}{}\",\n                        UnsafetySpace(decl.unsafety),\n-                       match decl.abi.as_slice() {\n+                       match &*decl.abi {\n                            \"\" => \" extern \".to_string(),\n                            \"\\\"Rust\\\"\" => \"\".to_string(),\n                            s => format!(\" extern {} \", s)\n@@ -478,18 +478,17 @@ impl fmt::Display for clean::Type {\n             }\n             clean::Tuple(ref typs) => {\n                 primitive_link(f, clean::PrimitiveTuple,\n-                               match typs.as_slice() {\n+                               &*match &**typs {\n                                     [ref one] => format!(\"({},)\", one),\n-                                    many => format!(\"({})\",\n-                                                    CommaSep(many.as_slice()))\n-                               }.as_slice())\n+                                    many => format!(\"({})\", CommaSep(&many)),\n+                               })\n             }\n             clean::Vector(ref t) => {\n-                primitive_link(f, clean::Slice, format!(\"[{}]\", **t).as_slice())\n+                primitive_link(f, clean::Slice, &format!(\"[{}]\", **t))\n             }\n             clean::FixedVector(ref t, ref s) => {\n                 primitive_link(f, clean::Slice,\n-                               format!(\"[{}; {}]\", **t, *s).as_slice())\n+                               &format!(\"[{}; {}]\", **t, *s))\n             }\n             clean::Bottom => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {\n@@ -506,10 +505,10 @@ impl fmt::Display for clean::Type {\n                         match **bt {\n                             clean::Generic(_) =>\n                                 primitive_link(f, clean::Slice,\n-                                    format!(\"&amp;{}{}[{}]\", lt, m, **bt).as_slice()),\n+                                    &format!(\"&amp;{}{}[{}]\", lt, m, **bt)),\n                             _ => {\n                                 try!(primitive_link(f, clean::Slice,\n-                                    format!(\"&amp;{}{}[\", lt, m).as_slice()));\n+                                    &format!(\"&amp;{}{}[\", lt, m)));\n                                 try!(write!(f, \"{}\", **bt));\n                                 primitive_link(f, clean::Slice, \"]\")\n                             }\n@@ -577,23 +576,21 @@ impl<'a> fmt::Display for Method<'a> {\n             clean::SelfStatic => {},\n             clean::SelfValue => args.push_str(\"self\"),\n             clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                args.push_str(format!(\"&amp;{} {}self\", *lt,\n-                                      MutableSpace(mtbl)).as_slice());\n+                args.push_str(&format!(\"&amp;{} {}self\", *lt, MutableSpace(mtbl)));\n             }\n             clean::SelfBorrowed(None, mtbl) => {\n-                args.push_str(format!(\"&amp;{}self\",\n-                                      MutableSpace(mtbl)).as_slice());\n+                args.push_str(&format!(\"&amp;{}self\", MutableSpace(mtbl)));\n             }\n             clean::SelfExplicit(ref typ) => {\n-                args.push_str(format!(\"self: {}\", *typ).as_slice());\n+                args.push_str(&format!(\"self: {}\", *typ));\n             }\n         }\n         for (i, input) in d.inputs.values.iter().enumerate() {\n             if i > 0 || args.len() > 0 { args.push_str(\", \"); }\n             if input.name.len() > 0 {\n-                args.push_str(format!(\"{}: \", input.name).as_slice());\n+                args.push_str(&format!(\"{}: \", input.name));\n             }\n-            args.push_str(format!(\"{}\", input.type_).as_slice());\n+            args.push_str(&format!(\"{}\", input.type_));\n         }\n         write!(f, \"({args}){arrow}\", args = args, arrow = d.output)\n     }\n@@ -748,7 +745,7 @@ impl fmt::Display for ModuleSummary {\n             let tot = cnt.total();\n             if tot == 0 { return Ok(()) }\n \n-            context.push(m.name.as_slice());\n+            context.push(&m.name);\n             let path = context.connect(\"::\");\n \n             try!(write!(f, \"<tr>\"));"}, {"sha": "143b4cdee487a207e2db01e93e17174af30d1f84", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -67,12 +67,12 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n \n         let klass = match next.tok {\n             token::Whitespace => {\n-                try!(write!(out, \"{}\", Escape(snip(next.sp).as_slice())));\n+                try!(write!(out, \"{}\", Escape(&snip(next.sp))));\n                 continue\n             },\n             token::Comment => {\n                 try!(write!(out, \"<span class='comment'>{}</span>\",\n-                            Escape(snip(next.sp).as_slice())));\n+                            Escape(&snip(next.sp))));\n                 continue\n             },\n             token::Shebang(s) => {\n@@ -179,10 +179,10 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n         // stringifying this token\n         let snip = sess.span_diagnostic.cm.span_to_snippet(next.sp).unwrap();\n         if klass == \"\" {\n-            try!(write!(out, \"{}\", Escape(snip.as_slice())));\n+            try!(write!(out, \"{}\", Escape(&snip)));\n         } else {\n             try!(write!(out, \"<span class='{}'>{}</span>\", klass,\n-                          Escape(snip.as_slice())));\n+                          Escape(&snip)));\n         }\n     }\n "}, {"sha": "64c27b47f4281f43cdbb7cd0842561101e047c81", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -224,15 +224,13 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                     let test = origtext.lines().map(|l| {\n                         stripped_filtered_line(l).unwrap_or(l)\n                     }).collect::<Vec<&str>>().connect(\"\\n\");\n-                    let krate = krate.as_ref().map(|s| s.as_slice());\n-                    let test = test::maketest(test.as_slice(), krate, false, false);\n-                    s.push_str(format!(\"<span class='rusttest'>{}</span>\",\n-                                         Escape(test.as_slice())).as_slice());\n+                    let krate = krate.as_ref().map(|s| &**s);\n+                    let test = test::maketest(&test, krate, false, false);\n+                    s.push_str(&format!(\"<span class='rusttest'>{}</span>\", Escape(&test)));\n                 });\n-                s.push_str(highlight::highlight(text.as_slice(),\n-                                                None,\n-                                                Some(\"rust-example-rendered\"))\n-                             .as_slice());\n+                s.push_str(&highlight::highlight(&text,\n+                                                 None,\n+                                                 Some(\"rust-example-rendered\")));\n                 let output = CString::from_vec(s.into_bytes());\n                 hoedown_buffer_puts(ob, output.as_ptr());\n             })\n@@ -459,14 +457,14 @@ impl<'a> fmt::Display for Markdown<'a> {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.len() == 0 { return Ok(()) }\n-        render(fmt, md.as_slice(), false)\n+        render(fmt, md, false)\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt, md.as_slice(), true)\n+        render(fmt, md, true)\n     }\n }\n \n@@ -555,7 +553,7 @@ mod tests {\n     #[test]\n     fn issue_17736() {\n         let markdown = \"# title\";\n-        format!(\"{}\", Markdown(markdown.as_slice()));\n+        format!(\"{}\", Markdown(markdown));\n     }\n \n     #[test]"}, {"sha": "f413ef7e9261d6cc9c9684acbf6dd1215e24359c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 64, "deletions": 68, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -447,7 +447,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<Stri\n             path = \"\";\n         } else {\n             lastpath = item.path.to_string();\n-            path = item.path.as_slice();\n+            path = &item.path;\n         };\n \n         if i > 0 {\n@@ -525,8 +525,7 @@ fn write_shared(cx: &Context,\n                 if !line.starts_with(key) {\n                     continue\n                 }\n-                if line.starts_with(\n-                        format!(\"{}['{}']\", key, krate).as_slice()) {\n+                if line.starts_with(&format!(\"{}['{}']\", key, krate)) {\n                     continue\n                 }\n                 ret.push(line.to_string());\n@@ -537,8 +536,7 @@ fn write_shared(cx: &Context,\n \n     // Update the search index\n     let dst = cx.dst.join(\"search-index.js\");\n-    let all_indexes = try!(collect(&dst, krate.name.as_slice(),\n-                                   \"searchIndex\"));\n+    let all_indexes = try!(collect(&dst, &krate.name, \"searchIndex\"));\n     let mut w = try!(File::create(&dst));\n     try!(writeln!(&mut w, \"var searchIndex = {{}};\"));\n     try!(writeln!(&mut w, \"{}\", search_index));\n@@ -565,13 +563,13 @@ fn write_shared(cx: &Context,\n \n         let mut mydst = dst.clone();\n         for part in &remote_path[..remote_path.len() - 1] {\n-            mydst.push(part.as_slice());\n+            mydst.push(part);\n             try!(mkdir(&mydst));\n         }\n         mydst.push(format!(\"{}.{}.js\",\n                            remote_item_type.to_static_str(),\n                            remote_path[remote_path.len() - 1]));\n-        let all_implementors = try!(collect(&mydst, krate.name.as_slice(),\n+        let all_implementors = try!(collect(&mydst, &krate.name,\n                                             \"implementors\"));\n \n         try!(mkdir(&mydst.dir_path()));\n@@ -611,7 +609,7 @@ fn render_sources(cx: &mut Context,\n     info!(\"emitting source files\");\n     let dst = cx.dst.join(\"src\");\n     try!(mkdir(&dst));\n-    let dst = dst.join(krate.name.as_slice());\n+    let dst = dst.join(&krate.name);\n     try!(mkdir(&dst));\n     let mut folder = SourceCollector {\n         dst: dst,\n@@ -662,7 +660,7 @@ fn clean_srcpath<F>(src_root: &Path, src: &[u8], mut f: F) where\n             if \"..\" == c {\n                 f(\"up\");\n             } else {\n-                f(c.as_slice())\n+                f(c)\n             }\n         }\n     }\n@@ -672,7 +670,7 @@ fn clean_srcpath<F>(src_root: &Path, src: &[u8], mut f: F) where\n /// rendering in to the specified source destination.\n fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n     // See if there's documentation generated into the local directory\n-    let local_location = dst.join(e.name.as_slice());\n+    let local_location = dst.join(&e.name);\n     if local_location.is_dir() {\n         return Local;\n     }\n@@ -715,9 +713,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n             self.cx\n-                .include_sources = match self.emit_source(item.source\n-                                                              .filename\n-                                                              .as_slice()) {\n+                .include_sources = match self.emit_source(&item.source .filename) {\n                 Ok(()) => true,\n                 Err(e) => {\n                     println!(\"warning: source code was requested to be rendered, \\\n@@ -750,7 +746,7 @@ impl<'a> SourceCollector<'a> {\n                        filename.ends_with(\"macros>\") => return Ok(()),\n             Err(e) => return Err(e)\n         };\n-        let contents = str::from_utf8(contents.as_slice()).unwrap();\n+        let contents = str::from_utf8(&contents).unwrap();\n \n         // Remove the utf-8 BOM if any\n         let contents = if contents.starts_with(\"\\u{feff}\") {\n@@ -776,10 +772,10 @@ impl<'a> SourceCollector<'a> {\n         let title = format!(\"{} -- source\", cur.filename_display());\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n         let page = layout::Page {\n-            title: title.as_slice(),\n+            title: &title,\n             ty: \"source\",\n-            root_path: root_path.as_slice(),\n-            description: desc.as_slice(),\n+            root_path: &root_path,\n+            description: &desc,\n             keywords: get_basic_keywords(),\n         };\n         try!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n@@ -865,13 +861,13 @@ impl DocFolder for Cache {\n                             Some(&(ref fqp, ItemType::Struct)) |\n                             Some(&(ref fqp, ItemType::Enum)) =>\n                                 Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(self.stack.as_slice()),\n+                            Some(..) => Some(&*self.stack),\n                             None => None\n                         };\n                         ((Some(*last), path), true)\n                     }\n                 }\n-                _ => ((None, Some(self.stack.as_slice())), false)\n+                _ => ((None, Some(&*self.stack)), false)\n             };\n             let hidden_field = match item.inner {\n                 clean::StructFieldItem(clean::HiddenStructField) => true,\n@@ -1059,7 +1055,7 @@ impl Context {\n             panic!(\"Unexpected empty destination: {:?}\", self.current);\n         }\n         let prev = self.dst.clone();\n-        self.dst.push(s.as_slice());\n+        self.dst.push(&s);\n         self.root_path.push_str(\"../\");\n         self.current.push(s);\n \n@@ -1103,9 +1099,9 @@ impl Context {\n                                this.layout.krate);\n             let page = layout::Page {\n                 ty: \"mod\",\n-                root_path: this.root_path.as_slice(),\n-                title: title.as_slice(),\n-                description: desc.as_slice(),\n+                root_path: &this.root_path,\n+                title: &title,\n+                description: &desc,\n                 keywords: get_basic_keywords(),\n             };\n             let html_dst = &this.dst.join(\"stability.html\");\n@@ -1151,7 +1147,7 @@ impl Context {\n                 if title.len() > 0 {\n                     title.push_str(\"::\");\n                 }\n-                title.push_str(it.name.as_ref().unwrap().as_slice());\n+                title.push_str(it.name.as_ref().unwrap());\n             }\n             title.push_str(\" - Rust\");\n             let tyname = shortty(it).to_static_str();\n@@ -1169,10 +1165,10 @@ impl Context {\n             let keywords = make_item_keywords(it);\n             let page = layout::Page {\n                 ty: tyname,\n-                root_path: cx.root_path.as_slice(),\n-                title: title.as_slice(),\n-                description: desc.as_slice(),\n-                keywords: keywords.as_slice(),\n+                root_path: &cx.root_path,\n+                title: &title,\n+                description: &desc,\n+                keywords: &keywords,\n             };\n \n             markdown::reset_headers();\n@@ -1191,11 +1187,11 @@ impl Context {\n                 match cache().paths.get(&it.def_id) {\n                     Some(&(ref names, _)) => {\n                         for name in &names[..names.len() - 1] {\n-                            url.push_str(name.as_slice());\n+                            url.push_str(name);\n                             url.push_str(\"/\");\n                         }\n-                        url.push_str(item_path(it).as_slice());\n-                        try!(layout::redirect(&mut writer, url.as_slice()));\n+                        url.push_str(&item_path(it));\n+                        try!(layout::redirect(&mut writer, &url));\n                     }\n                     None => {}\n                 }\n@@ -1378,17 +1374,17 @@ impl<'a> fmt::Display for Item<'a> {\n             _ => false,\n         };\n         if !is_primitive {\n-            let cur = self.cx.current.as_slice();\n+            let cur = &self.cx.current;\n             let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n             for (i, component) in cur.iter().enumerate().take(amt) {\n                 try!(write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n                             repeat(\"../\").take(cur.len() - i - 1)\n                                          .collect::<String>(),\n-                            component.as_slice()));\n+                            component));\n             }\n         }\n         try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-                    shortty(self.item), self.item.name.as_ref().unwrap().as_slice()));\n+                    shortty(self.item), self.item.name.as_ref().unwrap()));\n \n         // Write stability level\n         try!(write!(fmt, \"<wbr>{}\", Stability(&self.item.stability)));\n@@ -1433,7 +1429,7 @@ impl<'a> fmt::Display for Item<'a> {\n \n         match self.item.inner {\n             clean::ModuleItem(ref m) => {\n-                item_module(fmt, self.cx, self.item, m.items.as_slice())\n+                item_module(fmt, self.cx, self.item, &m.items)\n             }\n             clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n                 item_function(fmt, self.item, f),\n@@ -1467,7 +1463,7 @@ fn item_path(item: &clean::Item) -> String {\n fn full_path(cx: &Context, item: &clean::Item) -> String {\n     let mut s = cx.current.connect(\"::\");\n     s.push_str(\"::\");\n-    s.push_str(item.name.as_ref().unwrap().as_slice());\n+    s.push_str(item.name.as_ref().unwrap());\n     return s\n }\n \n@@ -1580,12 +1576,12 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                     Some(ref src) => {\n                         try!(write!(w, \"<tr><td><code>{}extern crate \\\"{}\\\" as {};\",\n                                     VisSpace(myitem.visibility),\n-                                    src.as_slice(),\n-                                    name.as_slice()))\n+                                    src,\n+                                    name))\n                     }\n                     None => {\n                         try!(write!(w, \"<tr><td><code>{}extern crate {};\",\n-                                    VisSpace(myitem.visibility), name.as_slice()))\n+                                    VisSpace(myitem.visibility), name))\n                     }\n                 }\n                 try!(write!(w, \"</code></td></tr>\"));\n@@ -1625,7 +1621,7 @@ impl<'a> fmt::Display for Initializer<'a> {\n         let Initializer(s) = *self;\n         if s.len() == 0 { return Ok(()); }\n         try!(write!(f, \"<code> = </code>\"));\n-        write!(f, \"<code>{}</code>\", s.as_slice())\n+        write!(f, \"<code>{}</code>\", s)\n     }\n }\n \n@@ -1634,9 +1630,9 @@ fn item_constant(w: &mut fmt::Formatter, it: &clean::Item,\n     try!(write!(w, \"<pre class='rust const'>{vis}const \\\n                     {name}: {typ}{init}</pre>\",\n            vis = VisSpace(it.visibility),\n-           name = it.name.as_ref().unwrap().as_slice(),\n+           name = it.name.as_ref().unwrap(),\n            typ = c.type_,\n-           init = Initializer(c.expr.as_slice())));\n+           init = Initializer(&c.expr)));\n     document(w, it)\n }\n \n@@ -1646,9 +1642,9 @@ fn item_static(w: &mut fmt::Formatter, it: &clean::Item,\n                     {name}: {typ}{init}</pre>\",\n            vis = VisSpace(it.visibility),\n            mutability = MutableSpace(s.mutability),\n-           name = it.name.as_ref().unwrap().as_slice(),\n+           name = it.name.as_ref().unwrap(),\n            typ = s.type_,\n-           init = Initializer(s.expr.as_slice())));\n+           init = Initializer(&s.expr)));\n     document(w, it)\n }\n \n@@ -1658,7 +1654,7 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n                     {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(it.visibility),\n            unsafety = UnsafetySpace(f.unsafety),\n-           name = it.name.as_ref().unwrap().as_slice(),\n+           name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n            where_clause = WhereClause(&f.generics),\n            decl = f.decl));\n@@ -1675,15 +1671,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         bounds.push_str(\": \");\n         for (i, p) in t.bounds.iter().enumerate() {\n             if i > 0 { bounds.push_str(\" + \"); }\n-            bounds.push_str(format!(\"{}\", *p).as_slice());\n+            bounds.push_str(&format!(\"{}\", *p));\n         }\n     }\n \n     // Output the trait definition\n     try!(write!(w, \"<pre class='rust trait'>{}{}trait {}{}{}{} \",\n                   VisSpace(it.visibility),\n                   UnsafetySpace(t.unsafety),\n-                  it.name.as_ref().unwrap().as_slice(),\n+                  it.name.as_ref().unwrap(),\n                   t.generics,\n                   bounds,\n                   WhereClause(&t.generics)));\n@@ -1823,7 +1819,7 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n                    _ => \"\",\n                },\n                ty = shortty(it),\n-               name = it.name.as_ref().unwrap().as_slice(),\n+               name = it.name.as_ref().unwrap(),\n                generics = *g,\n                decl = Method(selfty, d),\n                where_clause = WhereClause(g))\n@@ -1849,7 +1845,7 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                        it,\n                        Some(&s.generics),\n                        s.struct_type,\n-                       s.fields.as_slice(),\n+                       &s.fields,\n                        \"\",\n                        true));\n     try!(write!(w, \"</pre>\"));\n@@ -1869,7 +1865,7 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                 try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n                                   {stab}<code>{name}</code></td><td>\",\n                             stab = ConciseStability(&field.stability),\n-                            name = field.name.as_ref().unwrap().as_slice()));\n+                            name = field.name.as_ref().unwrap()));\n                 try!(document(w, field));\n                 try!(write!(w, \"</td></tr>\"));\n             }\n@@ -1883,7 +1879,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust enum'>{}enum {}{}{}\",\n                   VisSpace(it.visibility),\n-                  it.name.as_ref().unwrap().as_slice(),\n+                  it.name.as_ref().unwrap(),\n                   e.generics,\n                   WhereClause(&e.generics)));\n     if e.variants.len() == 0 && !e.variants_stripped {\n@@ -1892,7 +1888,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \" {{\\n\"));\n         for v in &e.variants {\n             try!(write!(w, \"    \"));\n-            let name = v.name.as_ref().unwrap().as_slice();\n+            let name = v.name.as_ref().unwrap();\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n@@ -1912,7 +1908,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n                                                v,\n                                                None,\n                                                s.struct_type,\n-                                               s.fields.as_slice(),\n+                                               &s.fields,\n                                                \"    \",\n                                                false));\n                         }\n@@ -1936,7 +1932,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         for variant in &e.variants {\n             try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n                           stab = ConciseStability(&variant.stability),\n-                          name = variant.name.as_ref().unwrap().as_slice()));\n+                          name = variant.name.as_ref().unwrap()));\n             try!(document(w, variant));\n             match variant.inner {\n                 clean::VariantItem(ref var) => {\n@@ -1957,8 +1953,8 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n                                 try!(write!(w, \"<tr><td \\\n                                                   id='variant.{v}.field.{f}'>\\\n                                                   <code>{f}</code></td><td>\",\n-                                              v = variant.name.as_ref().unwrap().as_slice(),\n-                                              f = field.name.as_ref().unwrap().as_slice()));\n+                                              v = variant.name.as_ref().unwrap(),\n+                                              f = field.name.as_ref().unwrap()));\n                                 try!(document(w, field));\n                                 try!(write!(w, \"</td></tr>\"));\n                             }\n@@ -1987,7 +1983,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     try!(write!(w, \"{}{}{}\",\n                   VisSpace(it.visibility),\n                   if structhead {\"struct \"} else {\"\"},\n-                  it.name.as_ref().unwrap().as_slice()));\n+                  it.name.as_ref().unwrap()));\n     match g {\n         Some(g) => try!(write!(w, \"{}{}\", *g, WhereClause(g))),\n         None => {}\n@@ -2004,7 +2000,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n                         try!(write!(w, \"    {}{}: {},\\n{}\",\n                                       VisSpace(field.visibility),\n-                                      field.name.as_ref().unwrap().as_slice(),\n+                                      field.name.as_ref().unwrap(),\n                                       *ty,\n                                       tab));\n                     }\n@@ -2091,7 +2087,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     match i.dox {\n         Some(ref dox) => {\n             try!(write!(w, \"<div class='docblock'>{}</div>\",\n-                          Markdown(dox.as_slice())));\n+                          Markdown(dox)));\n         }\n         None => {}\n     }\n@@ -2179,7 +2175,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust typedef'>type {}{} = {};</pre>\",\n-                  it.name.as_ref().unwrap().as_slice(),\n+                  it.name.as_ref().unwrap(),\n                   t.generics,\n                   t.type_));\n \n@@ -2205,7 +2201,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         fn block(w: &mut fmt::Formatter, short: &str, longty: &str,\n                  cur: &clean::Item, cx: &Context) -> fmt::Result {\n             let items = match cx.sidebar.get(short) {\n-                Some(items) => items.as_slice(),\n+                Some(items) => items,\n                 None => return Ok(())\n             };\n             try!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n@@ -2219,12 +2215,12 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                        class = class,\n                        href = if curty == \"mod\" {\"../\"} else {\"\"},\n                        path = if short == \"mod\" {\n-                           format!(\"{}/index.html\", name.as_slice())\n+                           format!(\"{}/index.html\", name)\n                        } else {\n-                           format!(\"{}.{}.html\", short, name.as_slice())\n+                           format!(\"{}.{}.html\", short, name)\n                        },\n-                       title = Escape(doc.as_ref().unwrap().as_slice()),\n-                       name = name.as_slice()));\n+                       title = Escape(doc.as_ref().unwrap()),\n+                       name = name));\n             }\n             try!(write!(w, \"</div>\"));\n             Ok(())\n@@ -2255,16 +2251,16 @@ impl<'a> fmt::Display for Source<'a> {\n             try!(write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols));\n         }\n         try!(write!(fmt, \"</pre>\"));\n-        try!(write!(fmt, \"{}\", highlight::highlight(s.as_slice(), None, None)));\n+        try!(write!(fmt, \"{}\", highlight::highlight(s, None, None)));\n         Ok(())\n     }\n }\n \n fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    try!(w.write_str(highlight::highlight(t.source.as_slice(),\n+    try!(w.write_str(&highlight::highlight(&t.source,\n                                           Some(\"macro\"),\n-                                          None).as_slice()));\n+                                          None)));\n     document(w, it)\n }\n "}, {"sha": "ecef4c9bf7226c182aa08dee218074609a6387d1", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -145,8 +145,7 @@ impl TocBuilder {\n                     (0, &self.top_level)\n                 }\n                 Some(entry) => {\n-                    sec_number = String::from_str(entry.sec_number\n-                                                       .as_slice());\n+                    sec_number = String::from_str(&entry.sec_number);\n                     sec_number.push_str(\".\");\n                     (entry.level, &entry.children)\n                 }\n@@ -158,7 +157,7 @@ impl TocBuilder {\n                 sec_number.push_str(\"0.\");\n             }\n             let number = toc.count_entries_with_level(level);\n-            sec_number.push_str(format!(\"{}\", number + 1).as_slice())\n+            sec_number.push_str(&format!(\"{}\", number + 1))\n         }\n \n         self.chain.push(TocEntry {\n@@ -172,7 +171,7 @@ impl TocBuilder {\n         // get the thing we just pushed, so we can borrow the string\n         // out of it with the right lifetime\n         let just_inserted = self.chain.last_mut().unwrap();\n-        just_inserted.sec_number.as_slice()\n+        &just_inserted.sec_number\n     }\n }\n "}, {"sha": "40e9703c03ffbf1a31ace44d3d685de6923730c3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -178,20 +178,20 @@ pub fn opts() -> Vec<getopts::OptGroup> {\n \n pub fn usage(argv0: &str) {\n     println!(\"{}\",\n-             getopts::usage(format!(\"{} [options] <input>\", argv0).as_slice(),\n-                            opts().as_slice()));\n+             getopts::usage(&format!(\"{} [options] <input>\", argv0),\n+                            &opts()));\n }\n \n pub fn main_args(args: &[String]) -> int {\n-    let matches = match getopts::getopts(args.tail(), opts().as_slice()) {\n+    let matches = match getopts::getopts(args.tail(), &opts()) {\n         Ok(m) => m,\n         Err(err) => {\n             println!(\"{}\", err);\n             return 1;\n         }\n     };\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(args[0].as_slice());\n+        usage(&args[0]);\n         return 0;\n     } else if matches.opt_present(\"version\") {\n         rustc_driver::version(\"rustdoc\", &matches);\n@@ -217,11 +217,11 @@ pub fn main_args(args: &[String]) -> int {\n         println!(\"only one input file may be specified\");\n         return 1;\n     }\n-    let input = matches.free[0].as_slice();\n+    let input = &matches.free[0];\n \n     let mut libs = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        libs.add_path(s.as_slice());\n+        libs.add_path(s);\n     }\n     let externs = match parse_externs(&matches) {\n         Ok(ex) => ex,\n@@ -244,9 +244,9 @@ pub fn main_args(args: &[String]) -> int {\n     let cfgs = matches.opt_strs(\"cfg\");\n \n     let external_html = match ExternalHtml::load(\n-            matches.opt_strs(\"html-in-header\").as_slice(),\n-            matches.opt_strs(\"html-before-content\").as_slice(),\n-            matches.opt_strs(\"html-after-content\").as_slice()) {\n+            &matches.opt_strs(\"html-in-header\"),\n+            &matches.opt_strs(\"html-before-content\"),\n+            &matches.opt_strs(\"html-after-content\")) {\n         Some(eh) => eh,\n         None => return 3\n     };\n@@ -274,7 +274,7 @@ pub fn main_args(args: &[String]) -> int {\n     };\n     let Output { krate, json_plugins, passes, } = out;\n     info!(\"going to format\");\n-    match matches.opt_str(\"w\").as_ref().map(|s| s.as_slice()) {\n+    match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n         Some(\"html\") | None => {\n             match html::render::run(krate, &external_html, output.unwrap_or(Path::new(\"doc\")),\n                                     passes.into_iter().collect()) {\n@@ -303,7 +303,7 @@ pub fn main_args(args: &[String]) -> int {\n fn acquire_input(input: &str,\n                  externs: core::Externs,\n                  matches: &getopts::Matches) -> Result<Output, String> {\n-    match matches.opt_str(\"r\").as_ref().map(|s| s.as_slice()) {\n+    match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n         Some(\"rust\") => Ok(rust_input(input, externs, matches)),\n         Some(\"json\") => json_input(input),\n         Some(s) => Err(format!(\"unknown input format: {}\", s)),\n@@ -357,7 +357,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // First, parse the crate and extract all relevant information.\n     let mut paths = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        paths.add_path(s.as_slice());\n+        paths.add_path(s);\n     }\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");\n@@ -512,7 +512,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n     let crate_json_str = format!(\"{}\", json::as_json(&krate));\n-    let crate_json = match json::from_str(crate_json_str.as_slice()) {\n+    let crate_json = match json::from_str(&crate_json_str) {\n         Ok(j) => j,\n         Err(e) => panic!(\"Rust generated JSON is invalid: {:?}\", e)\n     };"}, {"sha": "d64d9becc0c7c459f2ac2ebcb9e6132bc834bcb7", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -49,7 +49,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n     let mut css = String::new();\n     for name in &matches.opt_strs(\"markdown-css\") {\n         let s = format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\", name);\n-        css.push_str(s.as_slice())\n+        css.push_str(&s)\n     }\n \n     let input_str = load_or_return!(input, 1, 2);\n@@ -69,13 +69,13 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n         Ok(f) => f\n     };\n \n-    let (metadata, text) = extract_leading_metadata(input_str.as_slice());\n+    let (metadata, text) = extract_leading_metadata(&input_str);\n     if metadata.len() == 0 {\n         let _ = writeln!(&mut old_io::stderr(),\n                          \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n         return 5;\n     }\n-    let title = metadata[0].as_slice();\n+    let title = metadata[0];\n \n     reset_headers();\n \n@@ -141,8 +141,8 @@ pub fn test(input: &str, libs: SearchPaths, externs: core::Externs,\n     let input_str = load_or_return!(input, 1, 2);\n \n     let mut collector = Collector::new(input.to_string(), libs, externs, true);\n-    find_testable_code(input_str.as_slice(), &mut collector);\n+    find_testable_code(&input_str, &mut collector);\n     test_args.insert(0, \"rustdoctest\".to_string());\n-    testing::test_main(test_args.as_slice(), collector.tests);\n+    testing::test_main(&test_args, collector.tests);\n     0\n }"}, {"sha": "4e023039de7c8de81fe265b627f6f03e322f0d34", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -260,7 +260,7 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n                     &clean::NameValue(ref x, ref s)\n                             if \"doc\" == *x => {\n                         avec.push(clean::NameValue(\"doc\".to_string(),\n-                                                   unindent(s.as_slice())))\n+                                                   unindent(s)))\n                     }\n                     x => avec.push(x.clone())\n                 }\n@@ -284,7 +284,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n                             if \"doc\" == *x => {\n-                        docstr.push_str(s.as_slice());\n+                        docstr.push_str(s);\n                         docstr.push('\\n');\n                     },\n                     _ => ()\n@@ -352,14 +352,14 @@ pub fn unindent(s: &str) -> String {\n \n     if lines.len() >= 1 {\n         let mut unindented = vec![ lines[0].trim().to_string() ];\n-        unindented.push_all(lines.tail().iter().map(|&line| {\n+        unindented.push_all(&lines.tail().iter().map(|&line| {\n             if line.chars().all(|c| c.is_whitespace()) {\n                 line.to_string()\n             } else {\n                 assert!(line.len() >= min_indent);\n                 line[min_indent..].to_string()\n             }\n-        }).collect::<Vec<_>>().as_slice());\n+        }).collect::<Vec<_>>());\n         unindented.connect(\"\\n\")\n     } else {\n         s.to_string()\n@@ -373,14 +373,14 @@ mod unindent_tests {\n     #[test]\n     fn should_unindent() {\n         let s = \"    line1\\n    line2\".to_string();\n-        let r = unindent(s.as_slice());\n+        let r = unindent(&s);\n         assert_eq!(r, \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_unindent_multiple_paragraphs() {\n         let s = \"    line1\\n\\n    line2\".to_string();\n-        let r = unindent(s.as_slice());\n+        let r = unindent(&s);\n         assert_eq!(r, \"line1\\n\\nline2\");\n     }\n \n@@ -389,7 +389,7 @@ mod unindent_tests {\n         // Line 2 is indented another level beyond the\n         // base indentation and should be preserved\n         let s = \"    line1\\n\\n        line2\".to_string();\n-        let r = unindent(s.as_slice());\n+        let r = unindent(&s);\n         assert_eq!(r, \"line1\\n\\n    line2\");\n     }\n \n@@ -401,14 +401,14 @@ mod unindent_tests {\n         // #[doc = \"Start way over here\n         //          and continue here\"]\n         let s = \"line1\\n    line2\".to_string();\n-        let r = unindent(s.as_slice());\n+        let r = unindent(&s);\n         assert_eq!(r, \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n         let s = \"line1\\n\\n    line2\".to_string();\n-        let r = unindent(s.as_slice());\n+        let r = unindent(&s);\n         assert_eq!(r, \"line1\\n\\n    line2\");\n     }\n }"}, {"sha": "b65b2841aa0e5ce0ad6c874b17288fcef9a70057", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -88,7 +88,7 @@ fn libname(mut n: String) -> String {\n #[cfg(all(not(target_os=\"windows\"), not(target_os=\"macos\")))]\n fn libname(n: String) -> String {\n     let mut i = String::from_str(\"lib\");\n-    i.push_str(n.as_slice());\n+    i.push_str(&n);\n     i.push_str(\".so\");\n     i\n }"}, {"sha": "494efad896c5f41ea628aefea4345d0ea69c5e69", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -68,7 +68,7 @@ pub fn run(input: &str,\n \n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(cfgs.into_iter().map(|cfg_| {\n-        let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n+        let cfg_ = token::intern_and_get_ident(&cfg_);\n         P(dummy_spanned(ast::MetaWord(cfg_)))\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n@@ -105,7 +105,7 @@ pub fn run(input: &str,\n \n     test_args.insert(0, \"rustdoctest\".to_string());\n \n-    testing::test_main(test_args.as_slice(),\n+    testing::test_main(&test_args,\n                        collector.tests.into_iter().collect());\n     0\n }\n@@ -194,9 +194,9 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let newpath = {\n         let mut path = DynamicLibrary::search_path();\n         path.insert(0, libdir.clone());\n-        DynamicLibrary::create_path(path.as_slice())\n+        DynamicLibrary::create_path(&path)\n     };\n-    cmd.env(DynamicLibrary::envvar(), newpath.as_slice());\n+    cmd.env(DynamicLibrary::envvar(), newpath);\n \n     match cmd.output() {\n         Err(e) => panic!(\"couldn't run the test: {}{}\", e,\n@@ -208,7 +208,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n                 panic!(\"test executable succeeded when it should have failed\");\n             } else if !should_fail && !out.status.success() {\n                 panic!(\"test executable failed:\\n{:?}\",\n-                      str::from_utf8(out.error.as_slice()));\n+                      str::from_utf8(&out.error));\n             }\n         }\n     }\n@@ -228,8 +228,8 @@ pub fn maketest(s: &str, cratename: Option<&str>, lints: bool, dont_insert_main:\n         match cratename {\n             Some(cratename) => {\n                 if s.contains(cratename) {\n-                    prog.push_str(format!(\"extern crate {};\\n\",\n-                                          cratename).as_slice());\n+                    prog.push_str(&format!(\"extern crate {};\\n\",\n+                                           cratename));\n                 }\n             }\n             None => {}\n@@ -239,7 +239,7 @@ pub fn maketest(s: &str, cratename: Option<&str>, lints: bool, dont_insert_main:\n         prog.push_str(s);\n     } else {\n         prog.push_str(\"fn main() {\\n    \");\n-        prog.push_str(s.replace(\"\\n\", \"\\n    \").as_slice());\n+        prog.push_str(&s.replace(\"\\n\", \"\\n    \"));\n         prog.push_str(\"\\n}\");\n     }\n \n@@ -275,7 +275,7 @@ impl Collector {\n     pub fn add_test(&mut self, test: String,\n                     should_fail: bool, no_run: bool, should_ignore: bool, as_test_harness: bool) {\n         let name = if self.use_headers {\n-            let s = self.current_header.as_ref().map(|s| s.as_slice()).unwrap_or(\"\");\n+            let s = self.current_header.as_ref().map(|s| &**s).unwrap_or(\"\");\n             format!(\"{}_{}\", s, self.cnt)\n         } else {\n             format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt)\n@@ -292,8 +292,8 @@ impl Collector {\n                 should_fail: testing::ShouldFail::No, // compiler failures are test failures\n             },\n             testfn: testing::DynTestFn(Thunk::new(move|| {\n-                runtest(test.as_slice(),\n-                        cratename.as_slice(),\n+                runtest(&test,\n+                        &cratename,\n                         libs,\n                         externs,\n                         should_fail,"}, {"sha": "b8383577987539a03e281c9c21b9179472074748", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -2061,7 +2061,7 @@ pub fn from_reader(rdr: &mut old_io::Reader) -> Result<Json, BuilderError> {\n         Ok(c)  => c,\n         Err(e) => return Err(io_error_to_error(e))\n     };\n-    let s = match str::from_utf8(contents.as_slice()).ok() {\n+    let s = match str::from_utf8(&contents).ok() {\n         Some(s) => s,\n         _       => return Err(SyntaxError(NotUtf8, 0, 0))\n     };\n@@ -3550,7 +3550,7 @@ mod tests {\n         map.insert(Enum::Foo, 0);\n         let result = json::encode(&map).unwrap();\n         assert_eq!(&result[], r#\"{\"Foo\":0}\"#);\n-        let decoded: HashMap<Enum, _> = json::decode(result.as_slice()).unwrap();\n+        let decoded: HashMap<Enum, _> = json::decode(&result).unwrap();\n         assert_eq!(map, decoded);\n     }\n \n@@ -3591,7 +3591,7 @@ mod tests {\n                 None => { break; }\n             };\n             let (ref expected_evt, ref expected_stack) = expected[i];\n-            if !parser.stack().is_equal_to(expected_stack.as_slice()) {\n+            if !parser.stack().is_equal_to(expected_stack) {\n                 panic!(\"Parser stack is not equal to {:?}\", expected_stack);\n             }\n             assert_eq!(&evt, expected_evt);\n@@ -4022,6 +4022,6 @@ mod tests {\n     #[bench]\n     fn bench_large(b: &mut Bencher) {\n         let src = big_json();\n-        b.iter( || { let _ = from_str(src.as_slice()); });\n+        b.iter( || { let _ = from_str(&src); });\n     }\n }"}, {"sha": "892747e79ed45e80b7509b357920d24c688972af", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -421,7 +421,7 @@ mod tests {\n             let lower = if 'A' as u32 <= c && c <= 'Z' as u32 { c + 'a' as u32 - 'A' as u32 }\n                         else { c };\n             assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n-                    (from_u32(lower).unwrap()).to_string().as_slice()));\n+                    &from_u32(lower).unwrap().to_string()));\n             i += 1;\n         }\n     }"}, {"sha": "e1bcfe3ab7287183720959140e4dccb71b4e223b", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -67,9 +67,9 @@ impl DynamicLibrary {\n     pub fn prepend_search_path(path: &Path) {\n         let mut search_path = DynamicLibrary::search_path();\n         search_path.insert(0, path.clone());\n-        let newval = DynamicLibrary::create_path(search_path.as_slice());\n+        let newval = DynamicLibrary::create_path(&search_path);\n         env::set_var(DynamicLibrary::envvar(),\n-                     str::from_utf8(newval.as_slice()).unwrap());\n+                     str::from_utf8(&newval).unwrap());\n     }\n \n     /// From a slice of paths, create a new vector which is suitable to be an"}, {"sha": "4c8735bd4ad1055dbe674644ec65ab0d40cdb654", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -13,7 +13,7 @@ use iter::IteratorExt;\n use libc;\n use mem;\n use ops::Deref;\n-use slice::{self, SliceExt, AsSlice};\n+use slice::{self, SliceExt};\n use string::String;\n use vec::Vec;\n \n@@ -96,12 +96,12 @@ impl CString {\n \n     /// Create a view into this C string which includes the trailing nul\n     /// terminator at the end of the string.\n-    pub fn as_slice_with_nul(&self) -> &[libc::c_char] { self.inner.as_slice() }\n+    pub fn as_slice_with_nul(&self) -> &[libc::c_char] { &self.inner }\n \n     /// Similar to the `as_slice` method, but returns a `u8` slice instead of a\n     /// `libc::c_char` slice.\n     pub fn as_bytes(&self) -> &[u8] {\n-        unsafe { mem::transmute(self.as_slice()) }\n+        unsafe { mem::transmute(&**self) }\n     }\n \n     /// Equivalent to `as_slice_with_nul` except that the type returned is a\n@@ -197,7 +197,7 @@ mod tests {\n         assert_eq!(s.as_bytes(), b\"1234\");\n         assert_eq!(s.as_bytes_with_nul(), b\"1234\\0\");\n         unsafe {\n-            assert_eq!(s.as_slice(),\n+            assert_eq!(&*s,\n                        mem::transmute::<_, &[libc::c_char]>(b\"1234\"));\n             assert_eq!(s.as_slice_with_nul(),\n                        mem::transmute::<_, &[libc::c_char]>(b\"1234\\0\"));"}, {"sha": "59a437ad916537e23c47992b91b0b72bab8e6464", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -97,7 +97,7 @@ impl<R: Reader> BufferedReader<R> {\n impl<R: Reader> Buffer for BufferedReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n+            self.cap = try!(self.inner.read(&mut self.buf));\n             self.pos = 0;\n         }\n         Ok(&self.buf[self.pos..self.cap])"}, {"sha": "d8f9b1bb3feae4cd2c52d15f67f40bfaaddde6f1", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -191,14 +191,14 @@ mod test {\n         let a: &[u8] = &[7,8,6];\n         assert_eq!(a, buf);\n \n-        match reader.read(buf.as_mut_slice()) {\n+        match reader.read(&mut buf) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n         assert_eq!(a, buf);\n \n         // Ensure it continues to panic in the same way.\n-        match reader.read(buf.as_mut_slice()) {\n+        match reader.read(&mut buf) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }"}, {"sha": "95284f2ca40365b9f828d16ad953316c535372b3", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -24,7 +24,7 @@ use option::Option;\n use option::Option::{Some, None};\n use ptr::PtrExt;\n use result::Result::{Ok, Err};\n-use slice::{SliceExt, AsSlice};\n+use slice::SliceExt;\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `EndOfFile`.\n@@ -101,7 +101,7 @@ pub fn u64_to_le_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n             n >>= 8;\n             i -= 1u;\n         }\n-        f(bytes.as_slice())\n+        f(&bytes)\n       }\n     }\n }\n@@ -140,7 +140,7 @@ pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n             bytes.push((n >> shift) as u8);\n             i -= 1u;\n         }\n-        f(bytes.as_slice())\n+        f(&bytes)\n       }\n     }\n }\n@@ -455,7 +455,7 @@ mod test {\n         let buf = vec![0x41, 0x02, 0x00, 0x00];\n \n         let mut writer = Vec::new();\n-        writer.write(buf.as_slice()).unwrap();\n+        writer.write(&buf).unwrap();\n \n         let mut reader = MemReader::new(writer);\n         let f = reader.read_be_f32().unwrap();\n@@ -523,7 +523,7 @@ mod bench {\n             $b.iter(|| {\n                 let mut i = $start_index;\n                 while i < data.len() {\n-                    sum += u64_from_be_bytes(data.as_slice(), i, $size);\n+                    sum += u64_from_be_bytes(&data, i, $size);\n                     i += $stride;\n                 }\n             });"}, {"sha": "4e9c1b360552c4ee21d69146e72cf6261ac2bd9e", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -840,7 +840,7 @@ mod test {\n     macro_rules! error { ($e:expr, $s:expr) => (\n         match $e {\n             Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n-            Err(ref err) => assert!(err.to_string().contains($s.as_slice()),\n+            Err(ref err) => assert!(err.to_string().contains($s),\n                                     format!(\"`{}` did not contain `{}`\", err, $s))\n         }\n     ) }\n@@ -892,7 +892,7 @@ mod test {\n                 -1|0 => panic!(\"shouldn't happen\"),\n                 n => str::from_utf8(&read_buf[..n]).unwrap().to_string()\n             };\n-            assert_eq!(read_str.as_slice(), message);\n+            assert_eq!(read_str, message);\n         }\n         check!(unlink(filename));\n     }\n@@ -907,7 +907,7 @@ mod test {\n         if cfg!(unix) {\n             error!(result, \"no such file or directory\");\n         }\n-        error!(result, format!(\"path={}; mode=open; access=read\", filename.display()));\n+        error!(result, &format!(\"path={}; mode=open; access=read\", filename.display()));\n     }\n \n     #[test]\n@@ -921,7 +921,7 @@ mod test {\n         if cfg!(unix) {\n             error!(result, \"no such file or directory\");\n         }\n-        error!(result, format!(\"path={}\", filename.display()));\n+        error!(result, &format!(\"path={}\", filename.display()));\n     }\n \n     #[test]\n@@ -1120,7 +1120,7 @@ mod test {\n                     None|Some(\"\") => panic!(\"really shouldn't happen..\"),\n                     Some(n) => format!(\"{}{}\", prefix, n),\n                 };\n-                assert_eq!(expected.as_slice(), read_str);\n+                assert_eq!(expected, read_str);\n             }\n             check!(unlink(f));\n         }\n@@ -1189,7 +1189,7 @@ mod test {\n         error!(result, \"couldn't recursively mkdir\");\n         error!(result, \"couldn't create directory\");\n         error!(result, \"mode=0700\");\n-        error!(result, format!(\"path={}\", file.display()));\n+        error!(result, &format!(\"path={}\", file.display()));\n     }\n \n     #[test]\n@@ -1255,9 +1255,9 @@ mod test {\n         let to = Path::new(\"test/other-bogus-path\");\n \n         error!(copy(&from, &to),\n-            format!(\"couldn't copy path (the source path is not an \\\n-                    existing file; from={:?}; to={:?})\",\n-                    from.display(), to.display()));\n+            &format!(\"couldn't copy path (the source path is not an \\\n+                     existing file; from={:?}; to={:?})\",\n+                     from.display(), to.display()));\n \n         match copy(&from, &to) {\n             Ok(..) => panic!(),\n@@ -1277,7 +1277,7 @@ mod test {\n         check!(File::create(&input).write(b\"hello\"));\n         check!(copy(&input, &out));\n         let contents = check!(File::open(&out).read_to_end());\n-        assert_eq!(contents.as_slice(), b\"hello\");\n+        assert_eq!(contents, b\"hello\");\n \n         assert_eq!(check!(input.stat()).perm, check!(out.stat()).perm);\n     }"}, {"sha": "8f32703f200556b5c48563d9a3f28236ed808e0e", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -17,7 +17,7 @@ use option::Option::None;\n use result::Result::{Err, Ok};\n use old_io;\n use old_io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n-use slice::{self, AsSlice, SliceExt};\n+use slice::{self, SliceExt};\n use vec::Vec;\n \n const BUF_CAPACITY: uint = 128;\n@@ -92,7 +92,7 @@ impl MemWriter {\n     /// Acquires an immutable reference to the underlying buffer of this\n     /// `MemWriter`.\n     #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n+    pub fn get_ref<'a>(&'a self) -> &'a [u8] { &self.buf }\n \n     /// Unwraps this `MemWriter`, returning the underlying buffer\n     #[inline]\n@@ -147,7 +147,7 @@ impl MemReader {\n     /// No method is exposed for acquiring a mutable reference to the buffer\n     /// because it could corrupt the state of this `MemReader`.\n     #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n+    pub fn get_ref<'a>(&'a self) -> &'a [u8] { &self.buf }\n \n     /// Unwraps this `MemReader`, returning the underlying buffer\n     #[inline]\n@@ -407,7 +407,7 @@ mod test {\n         writer.write(&[1, 2, 3]).unwrap();\n         writer.write(&[4, 5, 6, 7]).unwrap();\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(writer.as_slice(), b);\n+        assert_eq!(writer, b);\n     }\n \n     #[test]\n@@ -511,24 +511,24 @@ mod test {\n     #[test]\n     fn test_slice_reader() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = &mut in_buf.as_slice();\n+        let mut reader = &mut &*in_buf;\n         let mut buf = [];\n         assert_eq!(reader.read(&mut buf), Ok(0));\n         let mut buf = [0];\n         assert_eq!(reader.read(&mut buf), Ok(1));\n         assert_eq!(reader.len(), 7);\n         let b: &[_] = &[0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         let mut buf = [0; 4];\n         assert_eq!(reader.read(&mut buf), Ok(4));\n         assert_eq!(reader.len(), 3);\n         let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n-        let mut reader = &mut in_buf.as_slice();\n+        let mut reader = &mut &*in_buf;\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n         assert!(reader.read(&mut buf).is_err());\n@@ -537,7 +537,7 @@ mod test {\n     #[test]\n     fn test_buf_reader() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = BufReader::new(in_buf.as_slice());\n+        let mut reader = BufReader::new(&in_buf);\n         let mut buf = [];\n         assert_eq!(reader.read(&mut buf), Ok(0));\n         assert_eq!(reader.tell(), Ok(0));\n@@ -555,7 +555,7 @@ mod test {\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n-        let mut reader = BufReader::new(in_buf.as_slice());\n+        let mut reader = BufReader::new(&in_buf);\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n         assert!(reader.read(&mut buf).is_err());\n@@ -664,7 +664,7 @@ mod test {\n         b.iter(|| {\n             let mut wr = MemWriter::new();\n             for _ in 0..times {\n-                wr.write(src.as_slice()).unwrap();\n+                wr.write(&src).unwrap();\n             }\n \n             let v = wr.into_inner();\n@@ -722,7 +722,7 @@ mod test {\n                 for _i in 0u..10 {\n                     let mut buf = [0 as u8; 10];\n                     rdr.read(&mut buf).unwrap();\n-                    assert_eq!(buf.as_slice(), [5; 10].as_slice());\n+                    assert_eq!(buf, [5; 10]);\n                 }\n             }\n         });"}, {"sha": "c3e4e7fc80d2e2a308c9bd9d835b00e2077c1d47", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1076,7 +1076,7 @@ pub trait Writer {\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8; 4];\n-        let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n+        let n = c.encode_utf8(&mut buf).unwrap_or(0);\n         self.write_all(&buf[..n])\n     }\n \n@@ -1870,7 +1870,7 @@ mod tests {\n                     // fall back on good\n                     return r.read(buf);\n                 }\n-                match behavior.as_mut_slice()[0] {\n+                match (&mut **behavior)[0] {\n                     GoodBehavior(0) => (),\n                     GoodBehavior(ref mut x) => {\n                         *x -= 1;"}, {"sha": "195d33c41a68e98e02210ccb4ad6eba323315a2d", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -239,8 +239,8 @@ impl Command {\n                 // if the env is currently just inheriting from the parent's,\n                 // materialize the parent's env into a hashtable.\n                 self.env = Some(os::env_as_bytes().into_iter().map(|(k, v)| {\n-                    (EnvKey(CString::from_slice(k.as_slice())),\n-                     CString::from_slice(v.as_slice()))\n+                    (EnvKey(CString::from_slice(&k)),\n+                     CString::from_slice(&v))\n                 }).collect());\n                 self.env.as_mut().unwrap()\n             }\n@@ -440,7 +440,7 @@ impl sys::process::ProcessConfig<EnvKey, CString> for Command {\n         &self.program\n     }\n     fn args(&self) -> &[CString] {\n-        self.args.as_slice()\n+        &self.args\n     }\n     fn env(&self) -> Option<&EnvMap> {\n         self.env.as_ref()\n@@ -915,7 +915,7 @@ mod tests {\n     fn test_process_output_output() {\n         let ProcessOutput {status, output, error}\n              = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n-        let output_str = str::from_utf8(output.as_slice()).unwrap();\n+        let output_str = str::from_utf8(&output).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n@@ -956,7 +956,7 @@ mod tests {\n     fn test_wait_with_output_once() {\n         let prog = Command::new(\"echo\").arg(\"hello\").spawn().unwrap();\n         let ProcessOutput {status, output, error} = prog.wait_with_output().unwrap();\n-        let output_str = str::from_utf8(output.as_slice()).unwrap();\n+        let output_str = str::from_utf8(&output).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n@@ -1049,7 +1049,7 @@ mod tests {\n         for &(ref k, ref v) in &r {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() ||\n-                    output.contains(format!(\"{}={}\", *k, *v).as_slice()),\n+                    output.contains(&format!(\"{}={}\", *k, *v)),\n                     \"output doesn't contain `{}={}`\\n{}\",\n                     k, v, output);\n         }\n@@ -1067,12 +1067,12 @@ mod tests {\n         for &(ref k, ref v) in &r {\n             // don't check android RANDOM variables\n             if *k != \"RANDOM\".to_string() {\n-                assert!(output.contains(format!(\"{}={}\",\n-                                                *k,\n-                                                *v).as_slice()) ||\n-                        output.contains(format!(\"{}=\\'{}\\'\",\n-                                                *k,\n-                                                *v).as_slice()));\n+                assert!(output.contains(&format!(\"{}={}\",\n+                                                 *k,\n+                                                 *v)) ||\n+                        output.contains(&format!(\"{}=\\'{}\\'\",\n+                                                 *k,\n+                                                 *v)));\n             }\n         }\n     }\n@@ -1091,13 +1091,13 @@ mod tests {\n             None => {}\n             Some(val) => {\n                 path_val = val;\n-                new_env.push((\"PATH\", path_val.as_slice()))\n+                new_env.push((\"PATH\", &path_val))\n             }\n         }\n \n-        let prog = env_cmd().env_set_all(new_env.as_slice()).spawn().unwrap();\n+        let prog = env_cmd().env_set_all(&new_env).spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n-        let output = String::from_utf8_lossy(result.output.as_slice()).to_string();\n+        let output = String::from_utf8_lossy(&result.output).to_string();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n@@ -1107,7 +1107,7 @@ mod tests {\n     fn test_add_to_env() {\n         let prog = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n-        let output = String::from_utf8_lossy(result.output.as_slice()).to_string();\n+        let output = String::from_utf8_lossy(&result.output).to_string();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "f42cb6ce8c97bf4d9c9f93d1b5ef9a2b5273945a", "filename": "src/libstd/old_io/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -112,7 +112,7 @@ mod test {\n         let mut buf = [0, 0];\n         reader.read(&mut buf).unwrap();\n         let b: &[_] = &[0, 1];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n     }\n \n     #[test]"}, {"sha": "5ae239014d188145e55a2014b36be610b3f03dba", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -101,7 +101,7 @@ impl Reader for ZeroReader {\n impl Buffer for ZeroReader {\n     fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         static DATA: [u8; 64] = [0; 64];\n-        Ok(DATA.as_slice())\n+        Ok(&DATA)\n     }\n \n     fn consume(&mut self, _amt: uint) {}\n@@ -321,23 +321,23 @@ mod test {\n     fn test_null_writer() {\n         let mut s = NullWriter;\n         let buf = vec![0, 0, 0];\n-        s.write_all(buf.as_slice()).unwrap();\n+        s.write_all(&buf).unwrap();\n         s.flush().unwrap();\n     }\n \n     #[test]\n     fn test_zero_reader() {\n         let mut s = ZeroReader;\n         let mut buf = vec![1, 2, 3];\n-        assert_eq!(s.read(buf.as_mut_slice()), Ok(3));\n+        assert_eq!(s.read(&mut buf), Ok(3));\n         assert_eq!(vec![0, 0, 0], buf);\n     }\n \n     #[test]\n     fn test_null_reader() {\n         let mut r = NullReader;\n         let mut buf = vec![0];\n-        assert!(r.read(buf.as_mut_slice()).is_err());\n+        assert!(r.read(&mut buf).is_err());\n     }\n \n     #[test]"}, {"sha": "6bf2a30b7b184e91aa85fe2b13b1b46173a19b57", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -131,25 +131,25 @@ impl GenericPathUnsafe for Path {\n                 v.push(SEP_BYTE);\n                 v.push_all(filename);\n                 // FIXME: this is slow\n-                self.repr = Path::normalize(v.as_slice());\n+                self.repr = Path::normalize(&v);\n             }\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n             Some(idx) if &self.repr[idx+1..] == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n-                v.push_all(self.repr.as_slice());\n+                v.push_all(&self.repr);\n                 v.push(SEP_BYTE);\n                 v.push_all(filename);\n                 // FIXME: this is slow\n-                self.repr = Path::normalize(v.as_slice());\n+                self.repr = Path::normalize(&v);\n             }\n             Some(idx) => {\n                 let mut v = Vec::with_capacity(idx + 1 + filename.len());\n                 v.push_all(&self.repr[..idx+1]);\n                 v.push_all(filename);\n                 // FIXME: this is slow\n-                self.repr = Path::normalize(v.as_slice());\n+                self.repr = Path::normalize(&v);\n             }\n         }\n         self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n@@ -162,11 +162,11 @@ impl GenericPathUnsafe for Path {\n                 self.repr = Path::normalize(path);\n             }  else {\n                 let mut v = Vec::with_capacity(self.repr.len() + path.len() + 1);\n-                v.push_all(self.repr.as_slice());\n+                v.push_all(&self.repr);\n                 v.push(SEP_BYTE);\n                 v.push_all(path);\n                 // FIXME: this is slow\n-                self.repr = Path::normalize(v.as_slice());\n+                self.repr = Path::normalize(&v);\n             }\n             self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n         }\n@@ -176,7 +176,7 @@ impl GenericPathUnsafe for Path {\n impl GenericPath for Path {\n     #[inline]\n     fn as_vec<'a>(&'a self) -> &'a [u8] {\n-        self.repr.as_slice()\n+        &self.repr\n     }\n \n     fn into_vec(self) -> Vec<u8> {\n@@ -185,10 +185,10 @@ impl GenericPath for Path {\n \n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if b\"..\" == self.repr => self.repr.as_slice(),\n+            None if b\"..\" == self.repr => &self.repr,\n             None => dot_static,\n             Some(0) => &self.repr[..1],\n-            Some(idx) if &self.repr[idx+1..] == b\"..\" => self.repr.as_slice(),\n+            Some(idx) if &self.repr[idx+1..] == b\"..\" => &self.repr,\n             Some(idx) => &self.repr[..idx]\n         }\n     }\n@@ -197,7 +197,7 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\".\" == self.repr ||\n                 b\"..\" == self.repr => None,\n-            None => Some(self.repr.as_slice()),\n+            None => Some(&self.repr),\n             Some(idx) if &self.repr[idx+1..] == b\"..\" => None,\n             Some(0) if self.repr[1..].is_empty() => None,\n             Some(idx) => Some(&self.repr[idx+1..])\n@@ -382,7 +382,7 @@ impl Path {\n     pub fn components<'a>(&'a self) -> Components<'a> {\n         let v = if self.repr[0] == SEP_BYTE {\n             &self.repr[1..]\n-        } else { self.repr.as_slice() };\n+        } else { &*self.repr };\n         let is_sep_byte: fn(&u8) -> bool = is_sep_byte; // coerce to fn ptr\n         let mut ret = v.split(is_sep_byte);\n         if v.is_empty() {\n@@ -557,14 +557,14 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let mo = path.display().as_cow();\n-                    assert_eq!(mo.as_slice(), $exp);\n+                    assert_eq!(mo, $exp);\n                 }\n             );\n             ($path:expr, $exp:expr, filename) => (\n                 {\n                     let path = Path::new($path);\n                     let mo = path.filename_display().as_cow();\n-                    assert_eq!(mo.as_slice(), $exp);\n+                    assert_eq!(mo, $exp);\n                 }\n             )\n         }"}, {"sha": "54c070e1b7db83eb507f1da9c290f526ec5f4de9", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1337,10 +1337,10 @@ mod tests {\n \n         let path = Path::new(\"foo\");\n         let mo = path.display().as_cow();\n-        assert_eq!(mo.as_slice(), \"foo\");\n+        assert_eq!(mo, \"foo\");\n         let path = Path::new(b\"\\\\\");\n         let mo = path.filename_display().as_cow();\n-        assert_eq!(mo.as_slice(), \"\");\n+        assert_eq!(mo, \"\");\n     }\n \n     #[test]"}, {"sha": "e29195b5525587df3baca7f8818b34662ddf1b1c", "filename": "src/libstd/os.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -649,7 +649,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n fn real_args() -> Vec<String> {\n     real_args_as_bytes().into_iter()\n                         .map(|v| {\n-                            String::from_utf8_lossy(v.as_slice()).into_owned()\n+                            String::from_utf8_lossy(&v).into_owned()\n                         }).collect()\n }\n \n@@ -1442,7 +1442,7 @@ mod tests {\n         let mut rng = rand::thread_rng();\n         let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10u)\n                                      .collect::<String>());\n-        assert!(getenv(n.as_slice()).is_none());\n+        assert!(getenv(&n).is_none());\n         n\n     }\n \n@@ -1454,27 +1454,27 @@ mod tests {\n     #[test]\n     fn test_setenv() {\n         let n = make_rand_name();\n-        setenv(n.as_slice(), \"VALUE\");\n-        assert_eq!(getenv(n.as_slice()), Some(\"VALUE\".to_string()));\n+        setenv(&n, \"VALUE\");\n+        assert_eq!(getenv(&n), Some(\"VALUE\".to_string()));\n     }\n \n     #[test]\n     fn test_unsetenv() {\n         let n = make_rand_name();\n-        setenv(n.as_slice(), \"VALUE\");\n-        unsetenv(n.as_slice());\n-        assert_eq!(getenv(n.as_slice()), None);\n+        setenv(&n, \"VALUE\");\n+        unsetenv(&n);\n+        assert_eq!(getenv(&n), None);\n     }\n \n     #[test]\n     #[ignore]\n     fn test_setenv_overwrite() {\n         let n = make_rand_name();\n-        setenv(n.as_slice(), \"1\");\n-        setenv(n.as_slice(), \"2\");\n-        assert_eq!(getenv(n.as_slice()), Some(\"2\".to_string()));\n-        setenv(n.as_slice(), \"\");\n-        assert_eq!(getenv(n.as_slice()), Some(\"\".to_string()));\n+        setenv(&n, \"1\");\n+        setenv(&n, \"2\");\n+        assert_eq!(getenv(&n), Some(\"2\".to_string()));\n+        setenv(&n, \"\");\n+        assert_eq!(getenv(&n), Some(\"\".to_string()));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n@@ -1489,9 +1489,9 @@ mod tests {\n             i += 1;\n         }\n         let n = make_rand_name();\n-        setenv(n.as_slice(), s.as_slice());\n+        setenv(&n, &s);\n         debug!(\"{}\", s.clone());\n-        assert_eq!(getenv(n.as_slice()), Some(s));\n+        assert_eq!(getenv(&n), Some(s));\n     }\n \n     #[test]\n@@ -1524,7 +1524,7 @@ mod tests {\n         for p in &e {\n             let (n, v) = (*p).clone();\n             debug!(\"{}\", n);\n-            let v2 = getenv(n.as_slice());\n+            let v2 = getenv(&n);\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n@@ -1536,18 +1536,18 @@ mod tests {\n     fn test_env_set_get_huge() {\n         let n = make_rand_name();\n         let s = repeat(\"x\").take(10000).collect::<String>();\n-        setenv(n.as_slice(), s.as_slice());\n-        assert_eq!(getenv(n.as_slice()), Some(s));\n-        unsetenv(n.as_slice());\n-        assert_eq!(getenv(n.as_slice()), None);\n+        setenv(&n, &s);\n+        assert_eq!(getenv(&n), Some(s));\n+        unsetenv(&n);\n+        assert_eq!(getenv(&n), None);\n     }\n \n     #[test]\n     fn test_env_setenv() {\n         let n = make_rand_name();\n \n         let mut e = env();\n-        setenv(n.as_slice(), \"VALUE\");\n+        setenv(&n, \"VALUE\");\n         assert!(!e.contains(&(n.clone(), \"VALUE\".to_string())));\n \n         e = env();\n@@ -1577,7 +1577,7 @@ mod tests {\n         assert!(os::homedir().is_none());\n \n         if let Some(s) = oldhome {\n-            setenv(\"HOME\", s.as_slice());\n+            setenv(\"HOME\", s);\n         }\n     }\n \n@@ -1606,10 +1606,10 @@ mod tests {\n         assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n \n         if let Some(s) = oldhome {\n-            setenv(\"HOME\", s.as_slice());\n+            setenv(\"HOME\", &s);\n         }\n         if let Some(s) = olduserprofile {\n-            setenv(\"USERPROFILE\", s.as_slice());\n+            setenv(\"USERPROFILE\", &s);\n         }\n     }\n "}, {"sha": "8f9e966cbb2b7a9fbe29a33d8d7ff6fad8cd4b28", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -469,7 +469,7 @@ mod test {\n                        80, 81, 82, 83, 84, 85, 86, 87];\n         for &n in &lengths {\n             let mut v = repeat(0u8).take(n).collect::<Vec<_>>();\n-            r.fill_bytes(v.as_mut_slice());\n+            r.fill_bytes(&mut v);\n \n             // use this to get nicer error messages.\n             for (i, &byte) in v.iter().enumerate() {\n@@ -619,19 +619,19 @@ mod test {\n     #[test]\n     fn test_std_rng_seeded() {\n         let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n-        let mut ra: StdRng = SeedableRng::from_seed(s.as_slice());\n-        let mut rb: StdRng = SeedableRng::from_seed(s.as_slice());\n+        let mut ra: StdRng = SeedableRng::from_seed(&*s);\n+        let mut rb: StdRng = SeedableRng::from_seed(&*s);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n                               rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n     fn test_std_rng_reseed() {\n         let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n-        let mut r: StdRng = SeedableRng::from_seed(s.as_slice());\n+        let mut r: StdRng = SeedableRng::from_seed(&*s);\n         let string1 = r.gen_ascii_chars().take(100).collect::<String>();\n \n-        r.reseed(s.as_slice());\n+        r.reseed(&s);\n \n         let string2 = r.gen_ascii_chars().take(100).collect::<String>();\n         assert_eq!(string1, string2);"}, {"sha": "f0558c33d1ec8d973ba11430443570a0cd176369", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -274,7 +274,7 @@ mod test {\n \n             // Ensure the borrowchecker works\n             match queue.peek() {\n-                Some(vec) => match vec.as_slice() {\n+                Some(vec) => match &**vec {\n                     // Note that `pop` is not allowed here due to borrow\n                     [1] => {}\n                     _ => return"}, {"sha": "ce67a584a0a5e0d313588fdd3ff640f937ec8075", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -57,7 +57,7 @@ pub fn stack_guard() -> uint {\n pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n     match thread.name() {\n-        Some(name) => unsafe { ::sys::thread::set_name(name.as_slice()); },\n+        Some(name) => unsafe { ::sys::thread::set_name(name); },\n         None => {}\n     }\n     THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{"}, {"sha": "04cba804e8df7ef2b9762eced47c07c44cf76820", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -140,7 +140,7 @@ impl ops::Deref for Wtf8Buf {\n impl fmt::Debug for Wtf8Buf {\n     #[inline]\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        self.as_slice().fmt(formatter)\n+        fmt::Debug::fmt(&**self, formatter)\n     }\n }\n \n@@ -220,7 +220,7 @@ impl Wtf8Buf {\n \n     #[inline]\n     pub fn as_slice(&self) -> &Wtf8 {\n-        unsafe { mem::transmute(self.bytes.as_slice()) }\n+        unsafe { mem::transmute(&*self.bytes) }\n     }\n \n     /// Reserves capacity for at least `additional` more bytes to be inserted\n@@ -309,7 +309,7 @@ impl Wtf8Buf {\n     /// or if `new_len` is not a code point boundary.\n     #[inline]\n     pub fn truncate(&mut self, new_len: uint) {\n-        assert!(is_code_point_boundary(self.as_slice(), new_len));\n+        assert!(is_code_point_boundary(self, new_len));\n         self.bytes.truncate(new_len)\n     }\n \n@@ -771,7 +771,7 @@ impl<'a> Iterator for EncodeWide<'a> {\n \n         let mut buf = [0u16; 2];\n         self.code_points.next().map(|code_point| {\n-            let n = encode_utf16_raw(code_point.value, buf.as_mut_slice())\n+            let n = encode_utf16_raw(code_point.value, &mut buf)\n                 .unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n@@ -798,7 +798,7 @@ impl<S: Writer + Hasher> Hash<S> for CodePoint {\n impl<S: Writer + Hasher> Hash<S> for Wtf8Buf {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n-        state.write(self.bytes.as_slice());\n+        state.write(&self.bytes);\n         0xfeu8.hash(state)\n     }\n }\n@@ -843,8 +843,8 @@ mod tests {\n \n     #[test]\n     fn code_point_to_string() {\n-        assert_eq!(format!(\"{:?}\", CodePoint::from_char('a')).as_slice(), \"U+0061\");\n-        assert_eq!(format!(\"{:?}\", CodePoint::from_char('\ud83d\udca9')).as_slice(), \"U+1F4A9\");\n+        assert_eq!(format!(\"{:?}\", CodePoint::from_char('a')), \"U+0061\");\n+        assert_eq!(format!(\"{:?}\", CodePoint::from_char('\ud83d\udca9')), \"U+1F4A9\");\n     }\n \n     #[test]\n@@ -865,142 +865,142 @@ mod tests {\n \n     #[test]\n     fn wtf8buf_new() {\n-        assert_eq!(Wtf8Buf::new().bytes.as_slice(), b\"\");\n+        assert_eq!(Wtf8Buf::new().bytes, b\"\");\n     }\n \n     #[test]\n     fn wtf8buf_from_str() {\n-        assert_eq!(Wtf8Buf::from_str(\"\").bytes.as_slice(), b\"\");\n-        assert_eq!(Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\").bytes.as_slice(),\n+        assert_eq!(Wtf8Buf::from_str(\"\").bytes, b\"\");\n+        assert_eq!(Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\").bytes,\n                    b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n     }\n \n     #[test]\n     fn wtf8buf_from_string() {\n-        assert_eq!(Wtf8Buf::from_string(String::from_str(\"\")).bytes.as_slice(), b\"\");\n-        assert_eq!(Wtf8Buf::from_string(String::from_str(\"a\u00e9 \ud83d\udca9\")).bytes.as_slice(),\n+        assert_eq!(Wtf8Buf::from_string(String::from_str(\"\")).bytes, b\"\");\n+        assert_eq!(Wtf8Buf::from_string(String::from_str(\"a\u00e9 \ud83d\udca9\")).bytes,\n                    b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n     }\n \n     #[test]\n     fn wtf8buf_from_wide() {\n-        assert_eq!(Wtf8Buf::from_wide(&[]).bytes.as_slice(), b\"\");\n+        assert_eq!(Wtf8Buf::from_wide(&[]).bytes, b\"\");\n         assert_eq!(Wtf8Buf::from_wide(\n-                      &[0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]).bytes.as_slice(),\n+                      &[0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]).bytes,\n                    b\"a\\xC3\\xA9 \\xED\\xA0\\xBD\\xF0\\x9F\\x92\\xA9\");\n     }\n \n     #[test]\n     fn wtf8buf_push_str() {\n         let mut string = Wtf8Buf::new();\n-        assert_eq!(string.bytes.as_slice(), b\"\");\n+        assert_eq!(string.bytes, b\"\");\n         string.push_str(\"a\u00e9 \ud83d\udca9\");\n-        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+        assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n     }\n \n     #[test]\n     fn wtf8buf_push_char() {\n         let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n-        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \");\n+        assert_eq!(string.bytes, b\"a\\xC3\\xA9 \");\n         string.push_char('\ud83d\udca9');\n-        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+        assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n     }\n \n     #[test]\n     fn wtf8buf_push() {\n         let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n-        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \");\n+        assert_eq!(string.bytes, b\"a\\xC3\\xA9 \");\n         string.push(CodePoint::from_char('\ud83d\udca9'));\n-        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+        assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n \n         fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n \n         let mut string = Wtf8Buf::new();\n         string.push(c(0xD83D));  // lead\n         string.push(c(0xDCA9));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n \n         let mut string = Wtf8Buf::new();\n         string.push(c(0xD83D));  // lead\n         string.push(c(0x20));  // not surrogate\n         string.push(c(0xDCA9));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+        assert_eq!(string.bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n \n         let mut string = Wtf8Buf::new();\n         string.push(c(0xD800));  // lead\n         string.push(c(0xDBFF));  // lead\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+        assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n \n         let mut string = Wtf8Buf::new();\n         string.push(c(0xD800));  // lead\n         string.push(c(0xE000));  // not surrogate\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+        assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n \n         let mut string = Wtf8Buf::new();\n         string.push(c(0xD7FF));  // not surrogate\n         string.push(c(0xDC00));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+        assert_eq!(string.bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n \n         let mut string = Wtf8Buf::new();\n         string.push(c(0x61));  // not surrogate, < 3 bytes\n         string.push(c(0xDC00));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+        assert_eq!(string.bytes, b\"\\x61\\xED\\xB0\\x80\");\n \n         let mut string = Wtf8Buf::new();\n         string.push(c(0xDC00));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+        assert_eq!(string.bytes, b\"\\xED\\xB0\\x80\");\n     }\n \n     #[test]\n     fn wtf8buf_push_wtf8() {\n         let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n-        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9\");\n+        assert_eq!(string.bytes, b\"a\\xC3\\xA9\");\n         string.push_wtf8(Wtf8::from_str(\" \ud83d\udca9\"));\n-        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+        assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n \n         fn w(value: &[u8]) -> &Wtf8 { unsafe { transmute(value) } }\n \n         let mut string = Wtf8Buf::new();\n         string.push_wtf8(w(b\"\\xED\\xA0\\xBD\"));  // lead\n         string.push_wtf8(w(b\"\\xED\\xB2\\xA9\"));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n \n         let mut string = Wtf8Buf::new();\n         string.push_wtf8(w(b\"\\xED\\xA0\\xBD\"));  // lead\n         string.push_wtf8(w(b\" \"));  // not surrogate\n         string.push_wtf8(w(b\"\\xED\\xB2\\xA9\"));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+        assert_eq!(string.bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n \n         let mut string = Wtf8Buf::new();\n         string.push_wtf8(w(b\"\\xED\\xA0\\x80\"));  // lead\n         string.push_wtf8(w(b\"\\xED\\xAF\\xBF\"));  // lead\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+        assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n \n         let mut string = Wtf8Buf::new();\n         string.push_wtf8(w(b\"\\xED\\xA0\\x80\"));  // lead\n         string.push_wtf8(w(b\"\\xEE\\x80\\x80\"));  // not surrogate\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+        assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n \n         let mut string = Wtf8Buf::new();\n         string.push_wtf8(w(b\"\\xED\\x9F\\xBF\"));  // not surrogate\n         string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+        assert_eq!(string.bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n \n         let mut string = Wtf8Buf::new();\n         string.push_wtf8(w(b\"a\"));  // not surrogate, < 3 bytes\n         string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+        assert_eq!(string.bytes, b\"\\x61\\xED\\xB0\\x80\");\n \n         let mut string = Wtf8Buf::new();\n         string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n-        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+        assert_eq!(string.bytes, b\"\\xED\\xB0\\x80\");\n     }\n \n     #[test]\n     fn wtf8buf_truncate() {\n         let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n         string.truncate(1);\n-        assert_eq!(string.bytes.as_slice(), b\"a\");\n+        assert_eq!(string.bytes, b\"a\");\n     }\n \n     #[test]\n@@ -1038,15 +1038,15 @@ mod tests {\n         fn f(values: &[u32]) -> Wtf8Buf {\n             values.iter().map(|&c| CodePoint::from_u32(c).unwrap()).collect::<Wtf8Buf>()\n         };\n-        assert_eq!(f(&[0x61, 0xE9, 0x20, 0x1F4A9]).bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+        assert_eq!(f(&[0x61, 0xE9, 0x20, 0x1F4A9]).bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n \n-        assert_eq!(f(&[0xD83D, 0xDCA9]).bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n-        assert_eq!(f(&[0xD83D, 0x20, 0xDCA9]).bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n-        assert_eq!(f(&[0xD800, 0xDBFF]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n-        assert_eq!(f(&[0xD800, 0xE000]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n-        assert_eq!(f(&[0xD7FF, 0xDC00]).bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n-        assert_eq!(f(&[0x61, 0xDC00]).bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n-        assert_eq!(f(&[0xDC00]).bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+        assert_eq!(f(&[0xD83D, 0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(f(&[0xD83D, 0x20, 0xDCA9]).bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+        assert_eq!(f(&[0xD800, 0xDBFF]).bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+        assert_eq!(f(&[0xD800, 0xE000]).bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+        assert_eq!(f(&[0xD7FF, 0xDC00]).bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+        assert_eq!(f(&[0x61, 0xDC00]).bytes, b\"\\x61\\xED\\xB0\\x80\");\n+        assert_eq!(f(&[0xDC00]).bytes, b\"\\xED\\xB0\\x80\");\n     }\n \n     #[test]\n@@ -1058,23 +1058,23 @@ mod tests {\n             string\n         };\n \n-        assert_eq!(e(&[0x61, 0xE9], &[0x20, 0x1F4A9]).bytes.as_slice(),\n+        assert_eq!(e(&[0x61, 0xE9], &[0x20, 0x1F4A9]).bytes,\n                    b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n \n-        assert_eq!(e(&[0xD83D], &[0xDCA9]).bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n-        assert_eq!(e(&[0xD83D, 0x20], &[0xDCA9]).bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n-        assert_eq!(e(&[0xD800], &[0xDBFF]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n-        assert_eq!(e(&[0xD800], &[0xE000]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n-        assert_eq!(e(&[0xD7FF], &[0xDC00]).bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n-        assert_eq!(e(&[0x61], &[0xDC00]).bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n-        assert_eq!(e(&[], &[0xDC00]).bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+        assert_eq!(e(&[0xD83D], &[0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(e(&[0xD83D, 0x20], &[0xDCA9]).bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+        assert_eq!(e(&[0xD800], &[0xDBFF]).bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+        assert_eq!(e(&[0xD800], &[0xE000]).bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+        assert_eq!(e(&[0xD7FF], &[0xDC00]).bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+        assert_eq!(e(&[0x61], &[0xDC00]).bytes, b\"\\x61\\xED\\xB0\\x80\");\n+        assert_eq!(e(&[], &[0xDC00]).bytes, b\"\\xED\\xB0\\x80\");\n     }\n \n     #[test]\n     fn wtf8buf_show() {\n         let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n         string.push(CodePoint::from_u32(0xD800).unwrap());\n-        assert_eq!(format!(\"{:?}\", string).as_slice(), r#\"\"a\u00e9 \ud83d\udca9\\u{D800}\"\"#);\n+        assert_eq!(format!(\"{:?}\", string), r#\"\"a\u00e9 \ud83d\udca9\\u{D800}\"\"#);\n     }\n \n     #[test]\n@@ -1086,7 +1086,7 @@ mod tests {\n     fn wtf8_show() {\n         let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n         string.push(CodePoint::from_u32(0xD800).unwrap());\n-        assert_eq!(format!(\"{:?}\", string.as_slice()).as_slice(), r#\"\"a\u00e9 \ud83d\udca9\\u{D800}\"\"#);\n+        assert_eq!(format!(\"{:?}\", string), r#\"\"a\u00e9 \ud83d\udca9\\u{D800}\"\"#);\n     }\n \n     #[test]"}, {"sha": "023d951dc4f8a8aad9152e24f5fc2d527b859425", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -51,7 +51,7 @@ impl Buf {\n     }\n \n     pub fn as_slice(&self) -> &Slice {\n-        unsafe { mem::transmute(self.inner.as_slice()) }\n+        unsafe { mem::transmute(&*self.inner) }\n     }\n \n     pub fn into_string(self) -> Result<String, Buf> {"}, {"sha": "eab60047aa2bf557ea515fd53903e60d8b6d9bd1", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -389,7 +389,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n         }\n         let argvec: Vec<char> = arg.chars().collect();\n         for i in 0u..argvec.len() {\n-            append_char_at(cmd, argvec.as_slice(), i);\n+            append_char_at(cmd, &argvec, i);\n         }\n         if quote {\n             cmd.push('\"');\n@@ -485,10 +485,9 @@ mod tests {\n     fn test_make_command_line() {\n         fn test_wrapper(prog: &str, args: &[&str]) -> String {\n             make_command_line(&CString::from_slice(prog.as_bytes()),\n-                              args.iter()\n-                                  .map(|a| CString::from_slice(a.as_bytes()))\n-                                  .collect::<Vec<CString>>()\n-                                  .as_slice())\n+                              &args.iter()\n+                                   .map(|a| CString::from_slice(a.as_bytes()))\n+                                   .collect::<Vec<CString>>())\n         }\n \n         assert_eq!("}, {"sha": "8a8b53090570cadcd188b6f840b41ffbe81771ed", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -104,7 +104,7 @@ impl TTY {\n                 _ => (),\n             };\n             utf16.truncate(num as uint);\n-            let utf8 = match String::from_utf16(utf16.as_slice()) {\n+            let utf8 = match String::from_utf16(&utf16) {\n                 Ok(utf8) => utf8.into_bytes(),\n                 Err(..) => return Err(invalid_encoding()),\n             };"}, {"sha": "eb967c9f4e331f31a9bb5aa88aa7ac5d2f73d179", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -156,7 +156,6 @@ use ops::{Drop, FnOnce};\n use option::Option::{self, Some, None};\n use result::Result::{Err, Ok};\n use sync::{Mutex, Condvar, Arc};\n-use str::Str;\n use string::String;\n use rt::{self, unwind};\n use old_io::{Writer, stdio};\n@@ -452,7 +451,7 @@ impl Thread {\n     /// Get the thread's name.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn name(&self) -> Option<&str> {\n-        self.inner.name.as_ref().map(|s| s.as_slice())\n+        self.inner.name.as_ref().map(|s| &**s)\n     }\n }\n \n@@ -574,7 +573,7 @@ mod test {\n     fn test_join_success() {\n         match Thread::scoped(move|| -> String {\n             \"Success!\".to_string()\n-        }).join().as_ref().map(|s| s.as_slice()) {\n+        }).join().as_ref().map(|s| &**s) {\n             result::Result::Ok(\"Success!\") => (),\n             _ => panic!()\n         }"}, {"sha": "15ea68a19ce855580f47a0bc30326d2831d79e73", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -338,7 +338,7 @@ pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::Me\n             !cfg_matches(diagnostic, cfgs, &*mis[0])\n         }\n         ast::MetaList(ref pred, _) => {\n-            diagnostic.span_err(cfg.span, format!(\"invalid predicate `{}`\", pred).as_slice());\n+            diagnostic.span_err(cfg.span, &format!(\"invalid predicate `{}`\", pred));\n             false\n         },\n         ast::MetaWord(_) | ast::MetaNameValue(..) => contains(cfgs, cfg),"}, {"sha": "eb845e463a0f1b8e1da21b4e5ebed7f6559139d7", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -27,7 +27,7 @@ struct Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate) -> ast::Crate {\n     let config = krate.config.clone();\n-    strip_items(krate, |attrs| in_cfg(diagnostic, config.as_slice(), attrs))\n+    strip_items(krate, |attrs| in_cfg(diagnostic, &config, attrs))\n }\n \n impl<F> fold::Folder for Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n@@ -132,7 +132,7 @@ fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_\n         }\n         ast::ItemEnum(def, generics) => {\n             let variants = def.variants.into_iter().filter_map(|v| {\n-                if !(cx.in_cfg)(v.node.attrs.as_slice()) {\n+                if !(cx.in_cfg)(&v.node.attrs) {\n                     None\n                 } else {\n                     Some(v.map(|Spanned {node: ast::Variant_ {id, name, attrs, kind,\n@@ -172,7 +172,7 @@ fn fold_struct<F>(cx: &mut Context<F>, def: P<ast::StructDef>) -> P<ast::StructD\n     def.map(|ast::StructDef { fields, ctor_id }| {\n         ast::StructDef {\n             fields: fields.into_iter().filter(|m| {\n-                (cx.in_cfg)(m.node.attrs.as_slice())\n+                (cx.in_cfg)(&m.node.attrs)\n             }).collect(),\n             ctor_id: ctor_id,\n         }\n@@ -223,7 +223,7 @@ fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n             node: match node {\n                 ast::ExprMatch(m, arms, source) => {\n                     ast::ExprMatch(m, arms.into_iter()\n-                                        .filter(|a| (cx.in_cfg)(a.attrs.as_slice()))\n+                                        .filter(|a| (cx.in_cfg)(&a.attrs))\n                                         .collect(), source)\n                 }\n                 _ => node\n@@ -236,31 +236,31 @@ fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n fn item_in_cfg<F>(cx: &mut Context<F>, item: &ast::Item) -> bool where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    return (cx.in_cfg)(item.attrs.as_slice());\n+    return (cx.in_cfg)(&item.attrs);\n }\n \n fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    return (cx.in_cfg)(item.attrs.as_slice());\n+    return (cx.in_cfg)(&item.attrs);\n }\n \n fn trait_method_in_cfg<F>(cx: &mut Context<F>, meth: &ast::TraitItem) -> bool where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     match *meth {\n-        ast::RequiredMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n-        ast::ProvidedMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n-        ast::TypeTraitItem(ref typ) => (cx.in_cfg)(typ.attrs.as_slice()),\n+        ast::RequiredMethod(ref meth) => (cx.in_cfg)(&meth.attrs),\n+        ast::ProvidedMethod(ref meth) => (cx.in_cfg)(&meth.attrs),\n+        ast::TypeTraitItem(ref typ) => (cx.in_cfg)(&typ.attrs),\n     }\n }\n \n fn impl_item_in_cfg<F>(cx: &mut Context<F>, impl_item: &ast::ImplItem) -> bool where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     match *impl_item {\n-        ast::MethodImplItem(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n-        ast::TypeImplItem(ref typ) => (cx.in_cfg)(typ.attrs.as_slice()),\n+        ast::MethodImplItem(ref meth) => (cx.in_cfg)(&meth.attrs),\n+        ast::TypeImplItem(ref typ) => (cx.in_cfg)(&typ.attrs),\n     }\n }\n "}, {"sha": "54689a1f77ad2dddcb9e6fa96bdff67b0de08e53", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -18,37 +18,37 @@ macro_rules! register_diagnostic {\n macro_rules! span_fatal {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n         __diagnostic_used!($code);\n-        $session.span_fatal_with_code($span, format!($($message)*).as_slice(), stringify!($code))\n+        $session.span_fatal_with_code($span, &format!($($message)*), stringify!($code))\n     })\n }\n \n #[macro_export]\n macro_rules! span_err {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n         __diagnostic_used!($code);\n-        $session.span_err_with_code($span, format!($($message)*).as_slice(), stringify!($code))\n+        $session.span_err_with_code($span, &format!($($message)*), stringify!($code))\n     })\n }\n \n #[macro_export]\n macro_rules! span_warn {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n         __diagnostic_used!($code);\n-        $session.span_warn_with_code($span, format!($($message)*).as_slice(), stringify!($code))\n+        $session.span_warn_with_code($span, &format!($($message)*), stringify!($code))\n     })\n }\n \n #[macro_export]\n macro_rules! span_note {\n     ($session:expr, $span:expr, $($message:tt)*) => ({\n-        ($session).span_note($span, format!($($message)*).as_slice())\n+        ($session).span_note($span, &format!($($message)*))\n     })\n }\n \n #[macro_export]\n macro_rules! span_help {\n     ($session:expr, $span:expr, $($message:tt)*) => ({\n-        ($session).span_help($span, format!($($message)*).as_slice())\n+        ($session).span_help($span, &format!($($message)*))\n     })\n }\n "}, {"sha": "7216602071b5c694a65cc88ee2759d0372bc7721", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -34,6 +34,6 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, cx.cfg.as_slice(), &*cfg);\n+    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &*cfg);\n     MacExpr::new(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "72eaa3e47bec6cda739043cacdd1c9b6e2a8c709", "filename": "src/libsyntax/ext/cfg_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fcfg_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fcfg_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg_attr.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -25,7 +25,7 @@ pub fn expand(cx: &mut ExtCtxt, sp: Span, mi: &ast::MetaItem, it: P<ast::Item>)\n     };\n \n     let mut out = (*it).clone();\n-    if attr::cfg_matches(&cx.parse_sess.span_diagnostic, cx.cfg.as_slice(), &**cfg) {\n+    if attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &**cfg) {\n         out.attrs.push(cx.attribute(attr.span, attr.clone()));\n     }\n "}, {"sha": "bce48747b6069243390dcf48c40ac88ad55bff73", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -28,14 +28,14 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n                 \"Copy\" => \"Copy\",\n                 \"Send\" | \"Sync\" => {\n                     return cx.span_err(span,\n-                                       format!(\"{} is an unsafe trait and it \\\n-                                                should be implemented explicitly\",\n-                                               *tname).as_slice())\n+                                       &format!(\"{} is an unsafe trait and it \\\n+                                                 should be implemented explicitly\",\n+                                                *tname))\n                 }\n                 ref tname => {\n                     cx.span_bug(span,\n-                                format!(\"expected built-in trait name but \\\n-                                         found {}\", *tname).as_slice())\n+                                &format!(\"expected built-in trait name but \\\n+                                          found {}\", *tname))\n                 }\n             }\n         },"}, {"sha": "bbca5c599b1c1199d12695cf1bcea9a61954ebb7", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -247,7 +247,7 @@ impl<'a> LifetimeBounds<'a> {\n                     mk_ty_param(cx,\n                                 span,\n                                 *name,\n-                                bounds.as_slice(),\n+                                bounds,\n                                 self_ty,\n                                 self_generics)\n                 }"}, {"sha": "eaee67f9a61746a4c06a4c8ee3eff2faf4094b5d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -664,7 +664,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                         id: ast::DUMMY_NODE_ID,\n                         span: it.span,\n                         imported_from: None,\n-                        export: attr::contains_name(it.attrs.as_slice(), \"macro_export\"),\n+                        export: attr::contains_name(&it.attrs, \"macro_export\"),\n                         use_locally: true,\n                         body: tts,\n                     };"}, {"sha": "de61bdefa5de3303f341b0ced5203380465d0ceb", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -319,11 +319,11 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                     Some(&&TtToken(_, ref tok)) => tok.clone(),\n                     Some(&&TtSequence(sp, _)) => {\n                         cx.span_err(sp,\n-                                    format!(\"`${0}:{1}` is followed by a \\\n-                                             sequence repetition, which is not \\\n-                                             allowed for `{1}` fragments\",\n-                                            name.as_str(), frag_spec.as_str())\n-                                        .as_slice());\n+                                    &format!(\"`${0}:{1}` is followed by a \\\n+                                              sequence repetition, which is not \\\n+                                              allowed for `{1}` fragments\",\n+                                             name.as_str(), frag_spec.as_str())\n+                                        );\n                         Eof\n                     },\n                     // die next iteration\n@@ -338,14 +338,14 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                     (&Eof, _) => return Some((sp, tok.clone())),\n                     (_, Ok(true)) => continue,\n                     (next, Ok(false)) => {\n-                        cx.span_err(sp, format!(\"`${0}:{1}` is followed by `{2}`, which \\\n-                                                 is not allowed for `{1}` fragments\",\n+                        cx.span_err(sp, &format!(\"`${0}:{1}` is followed by `{2}`, which \\\n+                                                  is not allowed for `{1}` fragments\",\n                                                  name.as_str(), frag_spec.as_str(),\n-                                                 token_to_string(next)).as_slice());\n+                                                 token_to_string(next)));\n                         continue\n                     },\n                     (_, Err(msg)) => {\n-                        cx.span_err(sp, msg.as_slice());\n+                        cx.span_err(sp, &msg);\n                         continue\n                     }\n                 }"}, {"sha": "36701e7e25c3f0e31fa50b74fe69f75644dcac2c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                     _ => {}\n                 }\n \n-                if attr::contains_name(i.attrs.as_slice(),\n+                if attr::contains_name(&i.attrs,\n                                        \"unsafe_destructor\") {\n                     self.gate_feature(\"unsafe_destructor\",\n                                       i.span,\n@@ -376,7 +376,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                and not portable across platforms\")\n         }\n \n-        let links_to_llvm = match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n+        let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs,\n                                                                      \"link_name\") {\n             Some(val) => val.get().starts_with(\"llvm.\"),\n             _ => false"}, {"sha": "b0ddb655882a86a9e6cb2f586db56439df971044", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -592,7 +592,7 @@ pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     Spanned {\n         node: match node {\n             MacInvocTT(p, tts, ctxt) => {\n-                MacInvocTT(fld.fold_path(p), fld.fold_tts(tts.as_slice()), ctxt)\n+                MacInvocTT(fld.fold_path(p), fld.fold_tts(&tts), ctxt)\n             }\n         },\n         span: fld.new_span(span)\n@@ -629,15 +629,15 @@ pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n                             Delimited {\n                                 delim: delimed.delim,\n                                 open_span: delimed.open_span,\n-                                tts: fld.fold_tts(delimed.tts.as_slice()),\n+                                tts: fld.fold_tts(&delimed.tts),\n                                 close_span: delimed.close_span,\n                             }\n                         ))\n         },\n         TtSequence(span, ref seq) =>\n             TtSequence(span,\n                        Rc::new(SequenceRepetition {\n-                           tts: fld.fold_tts(seq.tts.as_slice()),\n+                           tts: fld.fold_tts(&seq.tts),\n                            separator: seq.separator.clone().map(|tok| fld.fold_token(tok)),\n                            ..**seq\n                        })),\n@@ -1441,7 +1441,7 @@ mod test {\n     // this version doesn't care about getting comments or docstrings in.\n     fn fake_print_crate(s: &mut pprust::State,\n                         krate: &ast::Crate) -> old_io::IoResult<()> {\n-        s.print_mod(&krate.module, krate.attrs.as_slice())\n+        s.print_mod(&krate.module, &krate.attrs)\n     }\n \n     // change every identifier to \"zz\"\n@@ -1463,7 +1463,7 @@ mod test {\n                 let pred_val = $pred;\n                 let a_val = $a;\n                 let b_val = $b;\n-                if !(pred_val(a_val.as_slice(),b_val.as_slice())) {\n+                if !(pred_val(&a_val, &b_val)) {\n                     panic!(\"expected args satisfying {}, got {} and {}\",\n                           $predname, a_val, b_val);\n                 }"}, {"sha": "0f9a56baa170bc43b4d646f92241d35720cd067c", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -72,7 +72,7 @@ impl<T> Default for OwnedSlice<T> {\n \n impl<T: Clone> Clone for OwnedSlice<T> {\n     fn clone(&self) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(self.as_slice().to_vec())\n+        OwnedSlice::from_vec(self.to_vec())\n     }\n }\n \n@@ -84,7 +84,7 @@ impl<T> FromIterator<T> for OwnedSlice<T> {\n \n impl<T: Encodable> Encodable for OwnedSlice<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-       self.as_slice().encode(s)\n+        Encodable::encode(&**self, s)\n     }\n }\n "}, {"sha": "ecc39925a40c55b495c459b032279c178a05d3a6", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -360,7 +360,7 @@ impl<'a> StringReader<'a> {\n \n     pub fn nextnextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_usize();\n-        let s = self.filemap.src.as_slice();\n+        let s = &*self.filemap.src;\n         if offset >= s.len() { return None }\n         let str::CharRange { next, .. } = s.char_range_at(offset);\n         if next < s.len() {"}, {"sha": "6ff5c77f5079a954aa4a1314cee858953ff369a3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -454,15 +454,15 @@ pub fn str_lit(lit: &str) -> String {\n                 match c {\n                     '\\\\' => {\n                         let ch = chars.peek().unwrap_or_else(|| {\n-                            panic!(\"{}\", error(i).as_slice())\n+                            panic!(\"{}\", error(i))\n                         }).1;\n \n                         if ch == '\\n' {\n                             eat(&mut chars);\n                         } else if ch == '\\r' {\n                             chars.next();\n                             let ch = chars.peek().unwrap_or_else(|| {\n-                                panic!(\"{}\", error(i).as_slice())\n+                                panic!(\"{}\", error(i))\n                             }).1;\n \n                             if ch != '\\n' {\n@@ -480,7 +480,7 @@ pub fn str_lit(lit: &str) -> String {\n                     },\n                     '\\r' => {\n                         let ch = chars.peek().unwrap_or_else(|| {\n-                            panic!(\"{}\", error(i).as_slice())\n+                            panic!(\"{}\", error(i))\n                         }).1;\n \n                         if ch != '\\n' {\n@@ -622,11 +622,11 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n         match chars.next() {\n             Some((i, b'\\\\')) => {\n                 let em = error(i);\n-                match chars.peek().expect(em.as_slice()).1 {\n+                match chars.peek().expect(&em).1 {\n                     b'\\n' => eat(&mut chars),\n                     b'\\r' => {\n                         chars.next();\n-                        if chars.peek().expect(em.as_slice()).1 != b'\\n' {\n+                        if chars.peek().expect(&em).1 != b'\\n' {\n                             panic!(\"lexer accepted bare CR\");\n                         }\n                         eat(&mut chars);\n@@ -644,7 +644,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n             },\n             Some((i, b'\\r')) => {\n                 let em = error(i);\n-                if chars.peek().expect(em.as_slice()).1 != b'\\n' {\n+                if chars.peek().expect(&em).1 != b'\\n' {\n                     panic!(\"lexer accepted bare CR\");\n                 }\n                 chars.next();\n@@ -1200,7 +1200,7 @@ mod test {\n         let name = \"<source>\".to_string();\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n-        let doc = first_attr_value_str_by_name(item.attrs.as_slice(), \"doc\").unwrap();\n+        let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n         assert_eq!(doc.get(), \"/// doc comment\");\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n@@ -1212,7 +1212,7 @@ mod test {\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();\n-        let doc = first_attr_value_str_by_name(item.attrs.as_slice(), \"doc\").unwrap();\n+        let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n         assert_eq!(doc.get(), \"/** doc comment\\n *  with CRLF */\");\n     }\n "}, {"sha": "22174494458669bb5f2f5cafe31bda2cddc4f3b1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1681,7 +1681,7 @@ impl<'a> Parser<'a> {\n \n                     token::Str_(s) => {\n                         (true,\n-                         LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).as_slice()),\n+                         LitStr(token::intern_and_get_ident(&parse::str_lit(s.as_str())),\n                                 ast::CookedStr))\n                     }\n                     token::StrRaw(s, n) => {\n@@ -2596,7 +2596,7 @@ impl<'a> Parser<'a> {\n                         |p| p.parse_token_tree()\n                     );\n                     let (sep, repeat) = self.parse_sep_and_kleene_op();\n-                    let name_num = macro_parser::count_names(seq.as_slice());\n+                    let name_num = macro_parser::count_names(&seq);\n                     return TtSequence(mk_sp(sp.lo, seq_span.hi),\n                                       Rc::new(SequenceRepetition {\n                                           tts: seq,"}, {"sha": "fa41b0f7eef085573b46f3f9e77e9c2490559f97", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -1485,7 +1485,7 @@ impl<'a> State<'a> {\n                     token::Bracket => try!(word(&mut self.s, \"[\")),\n                     token::Brace => try!(self.bopen()),\n                 }\n-                try!(self.print_tts(tts.as_slice()));\n+                try!(self.print_tts(tts));\n                 match delim {\n                     token::Paren => self.pclose(),\n                     token::Bracket => word(&mut self.s, \"]\"),\n@@ -2502,7 +2502,7 @@ impl<'a> State<'a> {\n                                                                               ref bounds,\n                                                                               ..}) => {\n                     try!(self.print_type(&**bounded_ty));\n-                    try!(self.print_bounds(\":\", bounds.as_slice()));\n+                    try!(self.print_bounds(\":\", bounds));\n                 }\n                 &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n                                                                                 ref bounds,\n@@ -2760,7 +2760,7 @@ impl<'a> State<'a> {\n                              &format!(\"-{}\", istr)[])\n                     }\n                     ast::UnsignedIntLit(ut) => {\n-                        word(&mut self.s, ast_util::uint_ty_to_string(ut, Some(i)).as_slice())\n+                        word(&mut self.s, &ast_util::uint_ty_to_string(ut, Some(i)))\n                     }\n                     ast::UnsuffixedIntLit(ast::Plus) => {\n                         word(&mut self.s, &format!(\"{}\", i)[])\n@@ -2937,7 +2937,7 @@ impl<'a> State<'a> {\n                                 opt_unsafety: Option<ast::Unsafety>,\n                                 abi: abi::Abi,\n                                 vis: ast::Visibility) -> IoResult<()> {\n-        try!(word(&mut self.s, visibility_qualified(vis, \"\").as_slice()));\n+        try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n         try!(self.print_opt_unsafety(opt_unsafety));\n \n         if abi != abi::Rust {"}, {"sha": "b2009a7e8485480c00f418968c9f54c730a26f73", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -65,7 +65,7 @@ impl<T> SmallVector<T> {\n                 result\n             }\n             One(ref v) => slice::ref_slice(v),\n-            Many(ref vs) => vs.as_slice()\n+            Many(ref vs) => vs\n         }\n     }\n "}, {"sha": "21cb62b0a0c112818f30308c2ec7f3888906950d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -762,7 +762,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**subexpression)\n         }\n         ExprVec(ref subexpressions) => {\n-            walk_exprs(visitor, subexpressions.as_slice())\n+            walk_exprs(visitor, subexpressions)\n         }\n         ExprRepeat(ref element, ref count) => {\n             visitor.visit_expr(&**element);\n@@ -787,7 +787,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**callee_expression)\n         }\n         ExprMethodCall(_, ref types, ref arguments) => {\n-            walk_exprs(visitor, arguments.as_slice());\n+            walk_exprs(visitor, arguments);\n             for typ in types {\n                 visitor.visit_ty(&**typ)\n             }"}, {"sha": "0a1439ebee0f1e8c1edcc89cbdb97d43c7dbe775", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -80,10 +80,10 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                .strings\n                                .get(\"setaf\")\n                                .unwrap()\n-                               .as_slice(),\n+                               ,\n                            &[Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                try!(self.out.write_all(s.unwrap().as_slice()));\n+                try!(self.out.write_all(&s.unwrap()));\n                 return Ok(true)\n             }\n         }\n@@ -97,10 +97,10 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                .strings\n                                .get(\"setab\")\n                                .unwrap()\n-                               .as_slice(),\n+                               ,\n                            &[Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                try!(self.out.write_all(s.unwrap().as_slice()));\n+                try!(self.out.write_all(&s.unwrap()));\n                 return Ok(true)\n             }\n         }\n@@ -115,11 +115,11 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                 let cap = cap_for_attr(attr);\n                 let parm = self.ti.strings.get(cap);\n                 if parm.is_some() {\n-                    let s = expand(parm.unwrap().as_slice(),\n+                    let s = expand(parm.unwrap(),\n                                    &[],\n                                    &mut Variables::new());\n                     if s.is_ok() {\n-                        try!(self.out.write_all(s.unwrap().as_slice()));\n+                        try!(self.out.write_all(&s.unwrap()));\n                         return Ok(true)\n                     }\n                 }\n@@ -151,10 +151,10 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             }\n         }\n         let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_string()), |op| {\n-            expand(op.as_slice(), &[], &mut Variables::new())\n+            expand(op, &[], &mut Variables::new())\n         });\n         if s.is_ok() {\n-            return self.out.write_all(s.unwrap().as_slice())\n+            return self.out.write_all(&s.unwrap())\n         }\n         Ok(())\n     }"}, {"sha": "016dc84b23b9e22ae910d7970c7dda0e04c703eb", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -257,7 +257,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let flags = Flags::new();\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n-                        output.push_all(res.unwrap().as_slice())\n+                        output.push_all(&res.unwrap())\n                     } else { return Err(\"stack is empty\".to_string()) },\n                     ':'|'#'|' '|'.'|'0'...'9' => {\n                         let mut flags = Flags::new();\n@@ -355,7 +355,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if stack.len() > 0 {\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), *flags);\n                         if res.is_err() { return res }\n-                        output.push_all(res.unwrap().as_slice());\n+                        output.push_all(&res.unwrap());\n                         // will cause state to go to Nothing\n                         old_state = FormatPattern(*flags, *fstate);\n                     } else { return Err(\"stack is empty\".to_string()) },\n@@ -609,7 +609,7 @@ mod test {\n         {\n             let mut u8v: Vec<_> = fmt.bytes().collect();\n             u8v.extend(cap.as_bytes().iter().map(|&b| b));\n-            expand(u8v.as_slice(), params, vars)\n+            expand(&u8v, params, vars)\n         }\n \n         let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];"}, {"sha": "f3edd90b4fa5b3c15ee1c35a06c4a6bc802969db", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -105,7 +105,7 @@ impl TestName {\n     fn as_slice<'a>(&'a self) -> &'a str {\n         match *self {\n             StaticTestName(s) => s,\n-            DynTestName(ref s) => s.as_slice()\n+            DynTestName(ref s) => s\n         }\n     }\n }\n@@ -130,11 +130,11 @@ impl TestDesc {\n         match align {\n             PadNone => name,\n             PadOnLeft => {\n-                pad.push_str(name.as_slice());\n+                pad.push_str(&name);\n                 pad\n             }\n             PadOnRight => {\n-                name.push_str(pad.as_slice());\n+                name.push_str(&pad);\n                 name\n             }\n         }\n@@ -354,20 +354,19 @@ Test Attributes:\n                      test, then the test runner will ignore these tests during\n                      normal test runs. Running with --ignored will run these\n                      tests.\"#,\n-             usage = getopts::usage(message.as_slice(),\n-                                    optgroups().as_slice()));\n+             usage = getopts::usage(&message, &optgroups()));\n }\n \n // Parses command line arguments into test options\n pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let args_ = args.tail();\n     let matches =\n-        match getopts::getopts(args_.as_slice(), optgroups().as_slice()) {\n+        match getopts::getopts(args_, &optgroups()) {\n           Ok(m) => m,\n           Err(f) => return Some(Err(f.to_string()))\n         };\n \n-    if matches.opt_present(\"h\") { usage(args[0].as_slice()); return None; }\n+    if matches.opt_present(\"h\") { usage(&args[0]); return None; }\n \n     let filter = if matches.free.len() > 0 {\n         Some(matches.free[0].clone())\n@@ -389,7 +388,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         nocapture = env::var(\"RUST_TEST_NOCAPTURE\").is_some();\n     }\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| s.as_slice()) {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n         Some(\"auto\") | None => AutoColor,\n         Some(\"always\") => AlwaysColor,\n         Some(\"never\") => NeverColor,\n@@ -523,13 +522,13 @@ impl<T: Writer> ConsoleTestState<T> {\n     pub fn write_run_start(&mut self, len: uint) -> old_io::IoResult<()> {\n         self.total = len;\n         let noun = if len != 1 { \"tests\" } else { \"test\" };\n-        self.write_plain(format!(\"\\nrunning {} {}\\n\", len, noun).as_slice())\n+        self.write_plain(&format!(\"\\nrunning {} {}\\n\", len, noun))\n     }\n \n     pub fn write_test_start(&mut self, test: &TestDesc,\n                             align: NamePadding) -> old_io::IoResult<()> {\n         let name = test.padded_name(self.max_name_len, align);\n-        self.write_plain(format!(\"test {} ... \", name).as_slice())\n+        self.write_plain(&format!(\"test {} ... \", name))\n     }\n \n     pub fn write_result(&mut self, result: &TestResult) -> old_io::IoResult<()> {\n@@ -539,13 +538,12 @@ impl<T: Writer> ConsoleTestState<T> {\n             TrIgnored => self.write_ignored(),\n             TrMetrics(ref mm) => {\n                 try!(self.write_metric());\n-                self.write_plain(format!(\": {}\", mm.fmt_metrics()).as_slice())\n+                self.write_plain(&format!(\": {}\", mm.fmt_metrics()))\n             }\n             TrBench(ref bs) => {\n                 try!(self.write_bench());\n \n-                try!(self.write_plain(format!(\": {}\",\n-                                              fmt_bench_samples(bs)).as_slice()));\n+                try!(self.write_plain(&format!(\": {}\", fmt_bench_samples(bs))));\n \n                 Ok(())\n             }\n@@ -564,7 +562,7 @@ impl<T: Writer> ConsoleTestState<T> {\n                         TrIgnored => \"ignored\".to_string(),\n                         TrMetrics(ref mm) => mm.fmt_metrics(),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n-                    }, test.name.as_slice());\n+                    }, test.name);\n                 o.write_all(s.as_bytes())\n             }\n         }\n@@ -577,23 +575,21 @@ impl<T: Writer> ConsoleTestState<T> {\n         for &(ref f, ref stdout) in &self.failures {\n             failures.push(f.name.to_string());\n             if stdout.len() > 0 {\n-                fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n-                                          f.name.as_slice()).as_slice());\n-                let output = String::from_utf8_lossy(stdout.as_slice());\n-                fail_out.push_str(output.as_slice());\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                fail_out.push_str(&output);\n                 fail_out.push_str(\"\\n\");\n             }\n         }\n         if fail_out.len() > 0 {\n             try!(self.write_plain(\"\\n\"));\n-            try!(self.write_plain(fail_out.as_slice()));\n+            try!(self.write_plain(&fail_out));\n         }\n \n         try!(self.write_plain(\"\\nfailures:\\n\"));\n         failures.sort();\n         for name in &failures {\n-            try!(self.write_plain(format!(\"    {}\\n\",\n-                                          name.as_slice()).as_slice()));\n+            try!(self.write_plain(&format!(\"    {}\\n\", name)));\n         }\n         Ok(())\n     }\n@@ -615,7 +611,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         }\n         let s = format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n                         self.passed, self.failed, self.ignored, self.measured);\n-        try!(self.write_plain(s.as_slice()));\n+        try!(self.write_plain(&s));\n         return Ok(success);\n     }\n }\n@@ -648,13 +644,13 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> old_io:\n                     TrOk => st.passed += 1,\n                     TrIgnored => st.ignored += 1,\n                     TrMetrics(mm) => {\n-                        let tname = test.name.as_slice();\n+                        let tname = test.name;\n                         let MetricMap(mm) = mm;\n                         for (k,v) in &mm {\n                             st.metrics\n-                              .insert_metric(format!(\"{}.{}\",\n-                                                     tname,\n-                                                     k).as_slice(),\n+                              .insert_metric(&format!(\"{}.{}\",\n+                                                      tname,\n+                                                      k),\n                                              v.value,\n                                              v.noise);\n                         }\n@@ -686,7 +682,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> old_io:\n     match tests.iter().max_by(|t|len_if_padded(*t)) {\n         Some(t) => {\n             let n = t.desc.name.as_slice();\n-            st.max_name_len = n.len();\n+            st.max_name_len = n.as_slice().len();\n         },\n         None => {}\n     }\n@@ -1237,7 +1233,7 @@ mod tests {\n         let args = vec!(\"progname\".to_string(),\n                         \"filter\".to_string(),\n                         \"--ignored\".to_string());\n-        let opts = match parse_opts(args.as_slice()) {\n+        let opts = match parse_opts(&args) {\n             Some(Ok(o)) => o,\n             _ => panic!(\"Malformed arg in parse_ignored_flag\")\n         };"}, {"sha": "04617757465ec97a58bb913e23e409e22b299f6b", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -260,19 +260,19 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n \n     fn percentile(&self, pct: T) -> T {\n         let mut tmp = self.to_vec();\n-        local_sort(tmp.as_mut_slice());\n-        percentile_of_sorted(tmp.as_slice(), pct)\n+        local_sort(&mut tmp);\n+        percentile_of_sorted(&tmp, pct)\n     }\n \n     fn quartiles(&self) -> (T,T,T) {\n         let mut tmp = self.to_vec();\n-        local_sort(tmp.as_mut_slice());\n+        local_sort(&mut tmp);\n         let first = FromPrimitive::from_uint(25).unwrap();\n-        let a = percentile_of_sorted(tmp.as_slice(), first);\n+        let a = percentile_of_sorted(&tmp, first);\n         let secound = FromPrimitive::from_uint(50).unwrap();\n-        let b = percentile_of_sorted(tmp.as_slice(), secound);\n+        let b = percentile_of_sorted(&tmp, secound);\n         let third = FromPrimitive::from_uint(75).unwrap();\n-        let c = percentile_of_sorted(tmp.as_slice(), third);\n+        let c = percentile_of_sorted(&tmp, third);\n         (a,b,c)\n     }\n \n@@ -317,10 +317,10 @@ fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n /// See: http://en.wikipedia.org/wiki/Winsorising\n pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n     let mut tmp = samples.to_vec();\n-    local_sort(tmp.as_mut_slice());\n-    let lo = percentile_of_sorted(tmp.as_slice(), pct);\n+    local_sort(&mut tmp);\n+    let lo = percentile_of_sorted(&tmp, pct);\n     let hundred: T = FromPrimitive::from_uint(100).unwrap();\n-    let hi = percentile_of_sorted(tmp.as_slice(), hundred-pct);\n+    let hi = percentile_of_sorted(&tmp, hundred-pct);\n     for samp in samples {\n         if *samp > hi {\n             *samp = hi"}, {"sha": "15cf3986e6e80c61eeb74124afb041980fb63c96", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -527,7 +527,7 @@ impl<I> Iterator for Utf16Encoder<I> where I: Iterator<Item=char> {\n \n         let mut buf = [0u16; 2];\n         self.chars.next().map(|ch| {\n-            let n = CharExt::encode_utf16(ch, buf.as_mut_slice()).unwrap_or(0);\n+            let n = CharExt::encode_utf16(ch, &mut buf).unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n         })"}, {"sha": "6779cf997c1162236bbab3dac122b55cf5226de5", "filename": "src/test/auxiliary/plugin_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_args.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -38,7 +38,7 @@ impl TTMacroExpander for Expander {\n \n         let attr = ecx.attribute(sp, self.args.clone());\n         let src = pprust::attribute_to_string(&attr);\n-        let interned = token::intern_and_get_ident(src.as_slice());\n+        let interned = token::intern_and_get_ident(&src);\n         MacExpr::new(ecx.expr_str(sp, interned))\n     }\n }"}, {"sha": "3fe7a29256d8e1d9246c03d5b4e9ccc088ae4f1c", "filename": "src/test/auxiliary/roman_numerals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Froman_numerals.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -46,7 +46,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         }\n     };\n \n-    let mut text = text.as_slice();\n+    let mut text = &*text;\n     let mut total = 0u;\n     while !text.is_empty() {\n         match NUMERALS.iter().find(|&&(rn, _)| text.starts_with(rn)) {"}, {"sha": "d84ded25702f4b38de4abf61bb5721b6e526068a", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -25,7 +25,7 @@ impl read for int {\n \n impl read for bool {\n     fn readMaybe(s: String) -> Option<bool> {\n-        match s.as_slice() {\n+        match &*s {\n           \"true\" => Some(true),\n           \"false\" => Some(false),\n           _ => None"}, {"sha": "12c95e4c60c64beff6a75fcae565e2a0a769ef55", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -102,7 +102,7 @@ fn vector<M: MutableMap>(map: &mut M, n_keys: uint, dist: &[uint]) {\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n+    let args = args;\n     let n_keys = {\n         if args.len() == 2 {\n             args[1].parse::<uint>().unwrap()\n@@ -143,7 +143,7 @@ fn main() {\n     {\n         println!(\" Random integers:\");\n         let mut map: BTreeMap<uint,uint> = BTreeMap::new();\n-        vector(&mut map, n_keys, rand.as_slice());\n+        vector(&mut map, n_keys, &rand);\n     }\n \n     // FIXME: #9970\n@@ -162,6 +162,6 @@ fn main() {\n     {\n         println!(\" Random integers:\");\n         let mut map: HashMap<uint,uint> = HashMap::new();\n-        vector(&mut map, n_keys, rand.as_slice());\n+        vector(&mut map, n_keys, &rand);\n     }\n }"}, {"sha": "33ac8a43b437bf24dcdc17bb0641bf93b4b0f75a", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -180,7 +180,7 @@ fn empty_results() -> Results {\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n+    let args = args;\n     let num_keys = {\n         if args.len() == 2 {\n             args[1].parse::<uint>().unwrap()"}, {"sha": "991c08f60be7af05df2cff6181cb27b47f2d1d16", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -29,7 +29,7 @@ fn main() {\n \n     macro_rules! bench {\n         ($id:ident) =>\n-            (maybe_run_test(argv.as_slice(),\n+            (maybe_run_test(&argv,\n                             stringify!($id).to_string(),\n                             $id))\n     }\n@@ -94,7 +94,7 @@ fn vec_plus() {\n             v.extend(rv.into_iter());\n         } else {\n             let mut rv = rv.clone();\n-            rv.push_all(v.as_slice());\n+            rv.push_all(&v);\n             v = rv;\n         }\n         i += 1;\n@@ -110,12 +110,12 @@ fn vec_append() {\n         let rv = repeat(i).take(r.gen_range(0u, i + 1)).collect::<Vec<_>>();\n         if r.gen() {\n             let mut t = v.clone();\n-            t.push_all(rv.as_slice());\n+            t.push_all(&rv);\n             v = t;\n         }\n         else {\n             let mut t = rv.clone();\n-            t.push_all(v.as_slice());\n+            t.push_all(&v);\n             v = t;\n         }\n         i += 1;\n@@ -129,11 +129,11 @@ fn vec_push_all() {\n     for i in 0u..1500 {\n         let mut rv = repeat(i).take(r.gen_range(0u, i + 1)).collect::<Vec<_>>();\n         if r.gen() {\n-            v.push_all(rv.as_slice());\n+            v.push_all(&rv);\n         }\n         else {\n             swap(&mut v, &mut rv);\n-            v.push_all(rv.as_slice());\n+            v.push_all(&rv);\n         }\n     }\n }\n@@ -142,7 +142,7 @@ fn is_utf8_ascii() {\n     let mut v : Vec<u8> = Vec::new();\n     for _ in 0u..20000 {\n         v.push('b' as u8);\n-        if str::from_utf8(v.as_slice()).is_err() {\n+        if str::from_utf8(&v).is_err() {\n             panic!(\"from_utf8 panicked\");\n         }\n     }\n@@ -153,7 +153,7 @@ fn is_utf8_multibyte() {\n     let mut v : Vec<u8> = Vec::new();\n     for _ in 0u..5000 {\n         v.push_all(s.as_bytes());\n-        if str::from_utf8(v.as_slice()).is_err() {\n+        if str::from_utf8(&v).is_err() {\n             panic!(\"from_utf8 panicked\");\n         }\n     }"}, {"sha": "be42cb277f7a0c38fcbb8bfc05bf844acee5db24", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -103,5 +103,5 @@ fn main() {\n     };\n \n     println!(\"{:?}\", args);\n-    run(args.as_slice());\n+    run(&args);\n }"}, {"sha": "d9eea02a1769be036290df74c4e52f1c3c36b535", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -110,5 +110,5 @@ fn main() {\n     };\n \n     println!(\"{:?}\", args);\n-    run(args.as_slice());\n+    run(&args);\n }"}, {"sha": "e4e8b4a6e6e1e2a954aadf48ba360d5a27e33c5c", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -65,7 +65,7 @@ fn ping_pong_bench(n: uint, m: uint) {\n fn main() {\n \n     let args = os::args();\n-    let args = args.as_slice();\n+    let args = args;\n     let n = if args.len() == 3 {\n         args[1].parse::<uint>().unwrap()\n     } else {"}, {"sha": "13b8a5ca763ad1e5a8814c08ebdcba27d4470fa8", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -32,7 +32,7 @@ fn parfib(n: uint) -> uint {\n fn main() {\n \n     let args = os::args();\n-    let args = args.as_slice();\n+    let args = args;\n     let n = if args.len() == 2 {\n         args[1].parse::<uint>().unwrap()\n     } else {"}, {"sha": "38648b426f6cdd6fd7b6fd5e3bfd2d9543cb5164", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -85,7 +85,7 @@ fn inner(depth: i32, iterations: i32) -> String {\n \n fn main() {\n     let args = std::os::args();\n-    let args = args.as_slice();\n+    let args = args;\n     let n = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         17\n     } else if args.len() <= 1u {"}, {"sha": "30bbb3bc924db6a12c12c75a82fd62f834e678a4", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -82,7 +82,7 @@ fn show_color_list(set: Vec<Color>) -> String {\n     let mut out = String::new();\n     for col in &set {\n         out.push(' ');\n-        out.push_str(format!(\"{:?}\", col).as_slice());\n+        out.push_str(&format!(\"{:?}\", col));\n     }\n     out\n }\n@@ -230,7 +230,7 @@ fn main() {\n     let nn = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         200000\n     } else {\n-        std::os::args().as_slice()\n+        std::os::args()\n                        .get(1)\n                        .and_then(|arg| arg.parse().ok())\n                        .unwrap_or(600u)"}, {"sha": "92e1bc1a922c281043e468edaa880e0791572a67", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -180,7 +180,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n }\n \n fn main() {\n-    let n = std::os::args().as_slice()\n+    let n = std::os::args()\n         .get(1)\n         .and_then(|arg| arg.parse().ok())\n         .unwrap_or(2i32);"}, {"sha": "954bd5b2f79db8ecc19ea57d0733bcf56320916c", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -124,7 +124,7 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n         let mut buf = repeat(0u8).take(alu_len + LINE_LEN).collect::<Vec<_>>();\n         let alu: &[u8] = self.alu.as_bytes();\n \n-        copy_memory(buf.as_mut_slice(), alu);\n+        copy_memory(&mut buf, alu);\n         let buf_len = buf.len();\n         copy_memory(&mut buf[alu_len..buf_len],\n                     &alu[..LINE_LEN]);\n@@ -209,7 +209,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n+    let args = args;\n     let n = if args.len() > 1 {\n         args[1].parse::<uint>().unwrap()\n     } else {\n@@ -226,12 +226,12 @@ fn main() {\n \n     out.write_line(\">TWO IUB ambiguity codes\").unwrap();\n     let iub = sum_and_scale(&IUB);\n-    let mut random = RandomFasta::new(&mut out, iub.as_slice());\n+    let mut random = RandomFasta::new(&mut out, &iub);\n     random.make(n * 3).unwrap();\n \n     random.out.write_line(\">THREE Homo sapiens frequency\").unwrap();\n     let homo_sapiens = sum_and_scale(&HOMO_SAPIENS);\n-    random.lookup = make_lookup(homo_sapiens.as_slice());\n+    random.lookup = make_lookup(&homo_sapiens);\n     random.make(n * 5).unwrap();\n \n     random.out.write_str(\"\\n\").unwrap();"}, {"sha": "141e098745e7bdf790e639ddc1989bc00c433568", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -104,7 +104,7 @@ fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n \n fn run<W: Writer>(writer: &mut W) -> std::old_io::IoResult<()> {\n     let args = os::args();\n-    let args = args.as_slice();\n+    let args = args;\n     let n = if os::getenv(\"RUST_BENCH\").is_some() {\n         25000000\n     } else if args.len() <= 1u {"}, {"sha": "ed93594534cb4f04d999e7c5c1cba3d8697417d7", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -64,9 +64,9 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> String {\n \n    let mut buffer = String::new();\n    for &(ref k, v) in &pairs_sorted {\n-       buffer.push_str(format!(\"{:?} {:0.3}\\n\",\n-                               k.to_ascii_uppercase(),\n-                               v).as_slice());\n+       buffer.push_str(&format!(\"{:?} {:0.3}\\n\",\n+                                k.to_ascii_uppercase(),\n+                                v));\n    }\n \n    return buffer\n@@ -122,8 +122,8 @@ fn make_sequence_processor(sz: uint,\n        line = from_parent.recv().unwrap();\n        if line == Vec::new() { break; }\n \n-       carry.push_all(line.as_slice());\n-       carry = windows_with_carry(carry.as_slice(), sz, |window| {\n+       carry.push_all(&line);\n+       carry = windows_with_carry(&carry, sz, |window| {\n            update_freq(&mut freqs, window);\n            total += 1u;\n        });"}, {"sha": "474e5464293976f3bc758165ea15e9afb8bbe121", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -261,7 +261,7 @@ fn print_frequencies(frequencies: &Table, frame: uint) {\n     for entry in frequencies.iter() {\n         vector.push((entry.count, entry.code));\n     }\n-    vector.as_mut_slice().sort();\n+    vector.sort();\n \n     let mut total_count = 0;\n     for &(count, _) in &vector {\n@@ -270,7 +270,7 @@ fn print_frequencies(frequencies: &Table, frame: uint) {\n \n     for &(count, key) in vector.iter().rev() {\n         println!(\"{} {:.3}\",\n-                 key.unpack(frame).as_slice(),\n+                 key.unpack(frame),\n                  (count as f32 * 100.0) / (total_count as f32));\n     }\n     println!(\"\");\n@@ -301,11 +301,11 @@ fn main() {\n \n     let nb_freqs: Vec<_> = (1u..3).map(|i| {\n         let input = input.clone();\n-        (i, Thread::scoped(move|| generate_frequencies(input.as_slice(), i)))\n+        (i, Thread::scoped(move|| generate_frequencies(&input, i)))\n     }).collect();\n     let occ_freqs: Vec<_> = OCCURRENCES.iter().map(|&occ| {\n         let input = input.clone();\n-        Thread::scoped(move|| generate_frequencies(input.as_slice(), occ.len()))\n+        Thread::scoped(move|| generate_frequencies(&input, occ.len()))\n     }).collect();\n \n     for (i, freq) in nb_freqs {"}, {"sha": "e2d51fbf4111d43f63371143e6ea59eafb5b903f", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -124,7 +124,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n \n         Thread::scoped(move|| {\n             let mut res: Vec<u8> = Vec::with_capacity((chunk_size * w) / 8);\n-            let init_r_slice = vec_init_r.as_slice();\n+            let init_r_slice = vec_init_r;\n \n             let start = i * chunk_size;\n             let end = if i == (WORKERS - 1) {\n@@ -134,7 +134,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n             };\n \n             for &init_i in &vec_init_i[start..end] {\n-                write_line(init_i, init_r_slice, &mut res);\n+                write_line(init_i, &init_r_slice, &mut res);\n             }\n \n             res\n@@ -143,7 +143,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n \n     try!(writeln!(&mut out as &mut Writer, \"P4\\n{} {}\", w, h));\n     for res in data {\n-        try!(out.write(res.join().ok().unwrap().as_slice()));\n+        try!(out.write(&res.join().ok().unwrap()));\n     }\n     out.flush()\n }"}, {"sha": "71fe1c6affce3283d946fe95f6173c020d0f7a75", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -103,7 +103,7 @@ struct Planet {\n \n fn advance(bodies: &mut [Planet;N_BODIES], dt: f64, steps: int) {\n     for _ in 0..steps {\n-        let mut b_slice = bodies.as_mut_slice();\n+        let mut b_slice: &mut [_] = bodies;\n         loop {\n             let bi = match shift_mut_ref(&mut b_slice) {\n                 Some(bi) => bi,"}, {"sha": "a1a9fbb471a475df28f0f35eb003b611775f0ac1", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -57,7 +57,7 @@ fn parse_opts(argv: Vec<String> ) -> Config {\n     let argv = argv.iter().map(|x| x.to_string()).collect::<Vec<_>>();\n     let opt_args = &argv[1..argv.len()];\n \n-    match getopts::getopts(opt_args, opts.as_slice()) {\n+    match getopts::getopts(opt_args, &opts) {\n       Ok(ref m) => {\n           return Config {stress: m.opt_present(\"stress\")}\n       }"}, {"sha": "82887386814025d9720a24ded2898d2e000d9d36", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -251,6 +251,6 @@ fn parallel<'a, I, T, F>(iter: I, f: F)\n fn main() {\n     let mut data = read_to_end(&mut stdin_raw()).unwrap();\n     let tables = &Tables::new();\n-    parallel(mut_dna_seqs(data.as_mut_slice()), |seq| reverse_complement(seq, tables));\n-    stdout_raw().write(data.as_mut_slice()).unwrap();\n+    parallel(mut_dna_seqs(&mut data), |seq| reverse_complement(seq, tables));\n+    stdout_raw().write(&data).unwrap();\n }"}, {"sha": "24e11887065c280f3fc834bd96b0decee58231da", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -69,10 +69,10 @@ fn spectralnorm(n: uint) -> f64 {\n     let mut v = u.clone();\n     let mut tmp = v.clone();\n     for _ in 0u..10 {\n-        mult_AtAv(u.as_slice(), v.as_mut_slice(), tmp.as_mut_slice());\n-        mult_AtAv(v.as_slice(), u.as_mut_slice(), tmp.as_mut_slice());\n+        mult_AtAv(&u, &mut v, &mut tmp);\n+        mult_AtAv(&v, &mut u, &mut tmp);\n     }\n-    (dot(u.as_slice(), v.as_slice()) / dot(v.as_slice(), v.as_slice())).sqrt()\n+    (dot(&u, &v) / dot(&v, &v)).sqrt()\n }\n \n fn mult_AtAv(v: &[f64], out: &mut [f64], tmp: &mut [f64]) {"}, {"sha": "4a248384e1054848cb8ae6b1ebef0a6cda912e8e", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -63,7 +63,7 @@ impl Sudoku {\n                           .take(10).collect::<Vec<_>>();\n         for line in reader.lines() {\n             let line = line.unwrap();\n-            let comps: Vec<&str> = line.as_slice()\n+            let comps: Vec<&str> = line\n                                        .trim()\n                                        .split(',')\n                                        .collect();"}, {"sha": "b18df7f3db608b4f3bee2355d9907c16eeafa101", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -33,15 +33,15 @@ fn b() {\n     let mut p = vec!(1);\n \n     borrow(\n-        p.as_slice(),\n+        &p,\n         || p[0] = 5); //~ ERROR cannot borrow `p` as mutable\n }\n \n fn c() {\n     // Legal because the scope of the borrow does not include the\n     // modification:\n     let mut p = vec!(1);\n-    borrow(p.as_slice(), ||{});\n+    borrow(&p, ||{});\n     p[0] = 5;\n }\n "}, {"sha": "99ac86722693ab90716e32784ca9dbfb8007c7f4", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -30,7 +30,7 @@ fn defer<'r>(x: &'r [&'r str]) -> defer<'r> {\n }\n \n fn main() {\n-    let x = defer(vec!(\"Goodbye\", \"world!\").as_slice());\n+    let x = defer(&vec!(\"Goodbye\", \"world!\"));\n     //~^ ERROR borrowed value does not live long enough\n     x.x[0];\n }"}, {"sha": "f9d24130e47afdbe5f9c95588ac9a5bb62d054cf", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -21,7 +21,7 @@ pub fn main() {\n         Foo { string: \"bar\".to_string() },\n         Foo { string: \"baz\".to_string() }\n     );\n-    let x: &[Foo] = x.as_slice();\n+    let x: &[Foo] = &x;\n     match x {\n         [_, tail..] => {\n             match tail {"}, {"sha": "9341758afd82e279c7b125fe6912e16a63116623", "filename": "src/test/compile-fail/borrowck-mut-slice-of-imm-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -14,5 +14,5 @@ fn write(v: &mut [isize]) {\n \n fn main() {\n     let v = vec!(1, 2, 3);\n-    write(v.as_mut_slice()); //~ ERROR cannot borrow\n+    write(&mut v); //~ ERROR cannot borrow\n }"}, {"sha": "977c67b1c7dbd073b03c2f53b238010433c982b9", "filename": "src/test/compile-fail/borrowck-overloaded-index-autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -22,7 +22,7 @@ impl Index<String> for Foo {\n     type Output = isize;\n \n     fn index<'a>(&'a self, z: &String) -> &'a isize {\n-        if z.as_slice() == \"x\" {\n+        if *z == \"x\" {\n             &self.x\n         } else {\n             &self.y\n@@ -34,7 +34,7 @@ impl IndexMut<String> for Foo {\n     type Output = isize;\n \n     fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut isize {\n-        if z.as_slice() == \"x\" {\n+        if *z == \"x\" {\n             &mut self.x\n         } else {\n             &mut self.y"}, {"sha": "9e79154eb0c5cde893bf917e93551baef80b11c4", "filename": "src/test/compile-fail/borrowck-overloaded-index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -19,7 +19,7 @@ impl Index<String> for Foo {\n     type Output = isize;\n \n     fn index<'a>(&'a self, z: &String) -> &'a isize {\n-        if z.as_slice() == \"x\" {\n+        if *z == \"x\" {\n             &self.x\n         } else {\n             &self.y\n@@ -31,7 +31,7 @@ impl IndexMut<String> for Foo {\n     type Output = isize;\n \n     fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut isize {\n-        if z.as_slice() == \"x\" {\n+        if *z == \"x\" {\n             &mut self.x\n         } else {\n             &mut self.y"}, {"sha": "2d6a4b7d2c9df023f55075450f18727d43bf27b3", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -12,7 +12,7 @@\n \n fn a<'a>() -> &'a [isize] {\n     let vec = vec!(1, 2, 3, 4);\n-    let vec: &[isize] = vec.as_slice(); //~ ERROR does not live long enough\n+    let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let tail = match vec {\n         [_, tail..] => tail,\n         _ => panic!(\"a\")\n@@ -22,7 +22,7 @@ fn a<'a>() -> &'a [isize] {\n \n fn b<'a>() -> &'a [isize] {\n     let vec = vec!(1, 2, 3, 4);\n-    let vec: &[isize] = vec.as_slice(); //~ ERROR does not live long enough\n+    let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let init = match vec {\n         [init.., _] => init,\n         _ => panic!(\"b\")\n@@ -32,7 +32,7 @@ fn b<'a>() -> &'a [isize] {\n \n fn c<'a>() -> &'a [isize] {\n     let vec = vec!(1, 2, 3, 4);\n-    let vec: &[isize] = vec.as_slice(); //~ ERROR does not live long enough\n+    let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let slice = match vec {\n         [_, slice.., _] => slice,\n         _ => panic!(\"c\")"}, {"sha": "c1906758a5ae89586c8531770d9bbbc56abc856a", "filename": "src/test/compile-fail/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -10,7 +10,7 @@\n \n fn a() {\n     let mut v = vec!(1, 2, 3);\n-    let vb: &mut [isize] = v.as_mut_slice();\n+    let vb: &mut [isize] = &mut v;\n     match vb {\n         [_a, tail..] => {\n             v.push(tail[0] + tail[1]); //~ ERROR cannot borrow"}, {"sha": "b574507081713a04e5148e5a46e89ad08659f98f", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -22,7 +22,7 @@ fn a() {\n \n fn b() {\n     let mut vec = vec!(box 1, box 2, box 3);\n-    let vec: &mut [Box<isize>] = vec.as_mut_slice();\n+    let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n         [_b..] => {\n             vec[0] = box 4; //~ ERROR cannot assign\n@@ -32,7 +32,7 @@ fn b() {\n \n fn c() {\n     let mut vec = vec!(box 1, box 2, box 3);\n-    let vec: &mut [Box<isize>] = vec.as_mut_slice();\n+    let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n         [_a,         //~ ERROR cannot move out\n          _b..] => {  //~^ NOTE attempting to move value to here\n@@ -50,7 +50,7 @@ fn c() {\n \n fn d() {\n     let mut vec = vec!(box 1, box 2, box 3);\n-    let vec: &mut [Box<isize>] = vec.as_mut_slice();\n+    let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n         [_a..,     //~ ERROR cannot move out\n          _b] => {} //~ NOTE attempting to move value to here\n@@ -61,7 +61,7 @@ fn d() {\n \n fn e() {\n     let mut vec = vec!(box 1, box 2, box 3);\n-    let vec: &mut [Box<isize>] = vec.as_mut_slice();\n+    let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n         [_a, _b, _c] => {}  //~ ERROR cannot move out\n         //~^ NOTE attempting to move value to here"}, {"sha": "df0fee437b94ab93ef87107bd71f5eca0fd06c19", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -10,7 +10,7 @@\n \n fn a<'a>() -> &'a isize {\n     let vec = vec!(1, 2, 3, 4);\n-    let vec: &[isize] = vec.as_slice(); //~ ERROR `vec` does not live long enough\n+    let vec: &[isize] = &vec; //~ ERROR `vec` does not live long enough\n     let tail = match vec {\n         [_a, tail..] => &tail[0],\n         _ => panic!(\"foo\")"}, {"sha": "6e64e01d7410d2858315a2e6e3f4d462f8abe5f3", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -13,12 +13,12 @@ fn wants_slice(x: &str) { }\n \n fn has_uniq(x: String) {\n    wants_uniq(x);\n-   wants_slice(x.as_slice());\n+   wants_slice(&*x);\n }\n \n fn has_slice(x: &str) {\n    wants_uniq(x); //~ ERROR mismatched types\n-   wants_slice(x);\n+   wants_slice(x.as_slice());\n }\n \n fn main() {"}, {"sha": "88dd63384b7100dffa3364f49c6a763688d57358", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -11,15 +11,15 @@\n pub fn main() {\n     let v: Vec<isize> = vec!(0, 1, 2, 3, 4, 5);\n     let s: String = \"abcdef\".to_string();\n-    v.as_slice()[3us];\n-    v.as_slice()[3];\n-    v.as_slice()[3u8];  //~ERROR the trait `core::ops::Index<u8>` is not implemented\n+    v[3us];\n+    v[3];\n+    v[3u8];  //~ERROR the trait `core::ops::Index<u8>` is not implemented\n     //~^ ERROR the trait `core::ops::Index<u8>` is not implemented\n-    v.as_slice()[3i8];  //~ERROR the trait `core::ops::Index<i8>` is not implemented\n+    v[3i8];  //~ERROR the trait `core::ops::Index<i8>` is not implemented\n     //~^ ERROR the trait `core::ops::Index<i8>` is not implemented\n-    v.as_slice()[3u32]; //~ERROR the trait `core::ops::Index<u32>` is not implemented\n+    v[3u32]; //~ERROR the trait `core::ops::Index<u32>` is not implemented\n     //~^ ERROR the trait `core::ops::Index<u32>` is not implemented\n-    v.as_slice()[3i32]; //~ERROR the trait `core::ops::Index<i32>` is not implemented\n+    v[3i32]; //~ERROR the trait `core::ops::Index<i32>` is not implemented\n     //~^ ERROR the trait `core::ops::Index<i32>` is not implemented\n     s.as_bytes()[3us];\n     s.as_bytes()[3];"}, {"sha": "6dbea33d7d5d0aa59cce195851f6b1166764c740", "filename": "src/test/compile-fail/issue-11374.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -33,5 +33,5 @@ pub fn for_stdin<'a>() -> Container<'a> {\n fn main() {\n     let mut c = for_stdin();\n     let mut v = Vec::new();\n-    c.read_to(v.as_mut_slice());\n+    c.read_to(v);\n }"}, {"sha": "9a471a4341f5f1706bfc9a9458c264b1e9fbef44", "filename": "src/test/compile-fail/issue-12369.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let sl = vec![1,2,3];\n-    let v: isize = match sl.as_slice() {\n+    let v: isize = match &*sl {\n         [] => 0,\n         [a,b,c] => 3,\n         [a, rest..] => a,"}, {"sha": "13a5fa4b8af5af16ad60efb1adc04de9e764e358", "filename": "src/test/compile-fail/issue-15783.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -14,7 +14,7 @@ pub fn foo(params: Option<&[&str]>) -> usize {\n \n fn main() {\n     let name = \"Foo\";\n-    let x = Some(&[name.as_slice()]);\n+    let x = Some(&[name]);\n     let msg = foo(x);\n //~^ ERROR mismatched types\n //~| expected `core::option::Option<&[&str]>`"}, {"sha": "83e52216be29baa371506ac14f26f106294db121", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -100,7 +100,7 @@ impl TraversesWorld for Player {\n impl Debug for Player {\n     fn fmt(&self, formatter: &mut Formatter) -> Result<(), Error> {\n         formatter.write_str(\"Player{ name:\");\n-        formatter.write_str(self.name.as_slice());\n+        formatter.write_str(&self.name);\n         formatter.write_str(\" }\");\n         Ok(())\n     }"}, {"sha": "06af8ac8719e57b539496912b1a825860f4947f6", "filename": "src/test/compile-fail/lub-if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -16,14 +16,14 @@ pub fn opt_str0<'a>(maybestr: &'a Option<String>) -> &'a str {\n     if maybestr.is_none() {\n         \"(none)\"\n     } else {\n-        let s: &'a str = maybestr.as_ref().unwrap().as_slice();\n+        let s: &'a str = maybestr.as_ref().unwrap();\n         s\n     }\n }\n \n pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n     if maybestr.is_some() {\n-        let s: &'a str = maybestr.as_ref().unwrap().as_slice();\n+        let s: &'a str = maybestr.as_ref().unwrap();\n         s\n     } else {\n         \"(none)\"\n@@ -34,14 +34,14 @@ pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n     if maybestr.is_none() {\n         \"(none)\"\n     } else {\n-        let s: &'a str = maybestr.as_ref().unwrap().as_slice();\n+        let s: &'a str = maybestr.as_ref().unwrap();\n         s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n     }\n }\n \n pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n     if maybestr.is_some() {\n-        let s: &'a str = maybestr.as_ref().unwrap().as_slice();\n+        let s: &'a str = maybestr.as_ref().unwrap();\n         s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n     } else {\n         \"(none)\""}, {"sha": "1b5824964a8eb53b44a45bd5a82fb43af5e0bdc4", "filename": "src/test/compile-fail/lub-match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -15,7 +15,7 @@\n pub fn opt_str0<'a>(maybestr: &'a Option<String>) -> &'a str {\n     match *maybestr {\n         Some(ref s) => {\n-            let s: &'a str = s.as_slice();\n+            let s: &'a str = s;\n             s\n         }\n         None => \"(none)\",\n@@ -26,7 +26,7 @@ pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n     match *maybestr {\n         None => \"(none)\",\n         Some(ref s) => {\n-            let s: &'a str = s.as_slice();\n+            let s: &'a str = s;\n             s\n         }\n     }\n@@ -36,7 +36,7 @@ pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n     match *maybestr {\n         None => \"(none)\",\n         Some(ref s) => {\n-            let s: &'a str = s.as_slice();\n+            let s: &'a str = s;\n             s\n             //~^ ERROR cannot infer an appropriate lifetime\n         }\n@@ -46,7 +46,7 @@ pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n     match *maybestr {\n         Some(ref s) => {\n-            let s: &'a str = s.as_slice();\n+            let s: &'a str = s;\n             s\n             //~^ ERROR cannot infer an appropriate lifetime\n         }"}, {"sha": "2c63438cbf3af4ef6dceb833fc4f9105251441d5", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -11,7 +11,7 @@\n \n fn main() {\n     let x: Vec<(isize, isize)> = Vec::new();\n-    let x: &[(isize, isize)] = x.as_slice();\n+    let x: &[(isize, isize)] = &x;\n     match x {\n         [a, (2, 3), _] => (),\n         [(1, 2), (2, 3), b] => (), //~ ERROR unreachable pattern\n@@ -21,15 +21,15 @@ fn main() {\n     let x: Vec<String> = vec![\"foo\".to_string(),\n                               \"bar\".to_string(),\n                               \"baz\".to_string()];\n-    let x: &[String] = x.as_slice();\n+    let x: &[String] = &x;\n     match x {\n         [a, _, _, ..] => { println!(\"{}\", a); }\n         [_, _, _, _, _] => { } //~ ERROR unreachable pattern\n         _ => { }\n     }\n \n     let x: Vec<char> = vec!('a', 'b', 'c');\n-    let x: &[char] = x.as_slice();\n+    let x: &[char] = &x;\n     match x {\n         ['a', 'b', 'c', _tail..] => {}\n         ['a', 'b', 'c'] => {} //~ ERROR unreachable pattern"}, {"sha": "9ad44567a41f2371ba4510731b5137b843c419a1", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -95,7 +95,7 @@ fn f110() {\n \n fn f120() {\n     let mut x = vec!(\"hi\".to_string(), \"ho\".to_string());\n-    x.as_mut_slice().swap(0, 1);\n+    x.swap(0, 1);\n     touch(&x[0]);\n     touch(&x[1]);\n }"}, {"sha": "1dec049aed5e66ce262aa78ecf0917492e08db42", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -36,28 +36,28 @@ fn main() {\n       (t::b, t::b) => {}\n     }\n     let vec = vec!(Some(42), None, Some(21));\n-    let vec: &[Option<isize>] = vec.as_slice();\n+    let vec: &[Option<isize>] = &vec;\n     match vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n         [Some(..), None, tail..] => {}\n         [Some(..), Some(..), tail..] => {}\n         [None] => {}\n     }\n     let vec = vec!(1);\n-    let vec: &[isize] = vec.as_slice();\n+    let vec: &[isize] = &vec;\n     match vec {\n         [_, tail..] => (),\n         [] => ()\n     }\n     let vec = vec!(0.5f32);\n-    let vec: &[f32] = vec.as_slice();\n+    let vec: &[f32] = &vec;\n     match vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n         [0.1, 0.2, 0.3] => (),\n         [0.1, 0.2] => (),\n         [0.1] => (),\n         [] => ()\n     }\n     let vec = vec!(Some(42), None, Some(21));\n-    let vec: &[Option<isize>] = vec.as_slice();\n+    let vec: &[Option<isize>] = &vec;\n     match vec {\n         [Some(..), None, tail..] => {}\n         [Some(..), Some(..), tail..] => {}"}, {"sha": "323d5360029c581b44ddb3734bb98f2ce022df82", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -35,5 +35,5 @@ mod argparse {\n fn main () {\n     let f : argparse::Flag = argparse::flag(\"flag\", \"My flag\");\n     let updated_flag = f.set_desc(\"My new flag\");\n-    assert_eq!(updated_flag.desc.as_slice(), \"My new flag\");\n+    assert_eq!(updated_flag.desc, \"My new flag\");\n }"}, {"sha": "57ea607cbf623f0cdd5c0bc9b4475a4ab8afb7eb", "filename": "src/test/compile-fail/regions-pattern-typing-issue-19552.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -12,7 +12,7 @@ fn assert_send<T: Send>(_t: T) {}\n \n fn main() {\n     let line = String::new();\n-    match [line.as_slice()] { //~ ERROR `line` does not live long enough\n+    match [&*line] { //~ ERROR `line` does not live long enough\n         [ word ] => { assert_send(word); }\n     }\n }"}, {"sha": "7b426a4c0331545da4961f70a408d13627fdb7cd", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -26,7 +26,7 @@ impl Trait<&'static str> for Struct {\n \n fn main() {\n     let person = \"Fred\".to_string();\n-    let person: &str = person.as_slice();  //~ ERROR `person` does not live long enough\n+    let person: &str = &person;  //~ ERROR `person` does not live long enough\n     let s: Box<Trait<&'static str>> = box Struct { person: person };\n }\n "}, {"sha": "adc4711b49aa2367b040988f03b371e15bbd632f", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -283,9 +283,9 @@ fn main() {\n     let fixed_size_vec2 = ([0u, 1u, 2u], 0i16);\n \n     let vec1 = vec![0u, 2u, 3u];\n-    let slice1 = vec1.as_slice();\n+    let slice1 = &*vec1;\n     let vec2 = vec![Mod1::Variant2_2(Struct1)];\n-    let slice2 = vec2.as_slice();\n+    let slice2 = &*vec2;\n \n     // Trait Objects\n     let box_trait = (box 0) as Box<Trait1>;"}, {"sha": "72e9c4849c62922f2c688956447807c30e06e0a7", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -29,12 +29,12 @@ fn main() {\n            idx as uint);\n \n     // This should panic.\n-    println!(\"ov3 0x%x\",  x.as_slice()[idx]);\n+    println!(\"ov3 0x%x\",  x[idx]);\n }\n \n #[cfg(any(target_arch=\"x86_64\", target_arch = \"aarch64\"))]\n fn main() {\n     // This version just panics anyways, for symmetry on 64-bit hosts.\n     let x = vec!(1u,2u,3u);\n-    error!(\"ov3 0x%x\",  x.as_slice()[200]);\n+    error!(\"ov3 0x%x\",  x[200]);\n }"}, {"sha": "c8156b95dcfcb4d696db4a2f108a530b31a28f36", "filename": "src/test/run-make/cannot-read-embedded-idents/create_and_compile.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -17,8 +17,8 @@ use std::old_io::{File, Command};\n \n fn main() {\n     let args = os::args();\n-    let rustc = args[1].as_slice();\n-    let tmpdir = Path::new(args[2].as_slice());\n+    let rustc = &args[1];\n+    let tmpdir = Path::new(&args[2]);\n \n     let main_file = tmpdir.join(\"broken.rs\");\n     let _ = File::create(&main_file).unwrap()\n@@ -31,12 +31,12 @@ fn main() {\n     // can't exec it directly\n     let result = Command::new(\"sh\")\n         .arg(\"-c\")\n-        .arg(format!(\"{} {}\",\n-                     rustc,\n-                     main_file.as_str()\n-                     .unwrap()).as_slice())\n+        .arg(&format!(\"{} {}\",\n+                      rustc,\n+                      main_file.as_str()\n+                      .unwrap()))\n         .output().unwrap();\n-    let err = String::from_utf8_lossy(result.error.as_slice());\n+    let err = String::from_utf8_lossy(&result.error);\n \n     // positive test so that this test will be updated when the\n     // compiler changes."}, {"sha": "808417d6521eabb341ce6a27087cf76955f8c7ea", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -28,9 +28,9 @@ fn main() {\n         panic!(\"expected rustc path\");\n     }\n \n-    let tmpdir = Path::new(args[1].as_slice());\n+    let tmpdir = Path::new(&args[1]);\n \n-    let mut sysroot = Path::new(args[3].as_slice());\n+    let mut sysroot = Path::new(&args[3]);\n     sysroot.pop();\n     sysroot.pop();\n "}, {"sha": "3ede775b1197c53e12605e75b6ff39c7c1bf1d8e", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -106,7 +106,7 @@ trait SomeTrait: SuperTrait {\n     fn Method(&self, x: u32) -> u32;\n \n     fn prov(&self, x: u32) -> u32 {\n-        println(x.to_string().as_slice());\n+        println(&x.to_string());\n         42\n     }\n     fn provided_method(&self) -> u32 {\n@@ -122,7 +122,7 @@ trait SubTrait: SomeTrait {\n \n impl SomeTrait for some_fields {\n     fn Method(&self, x: u32) -> u32 {\n-        println(x.to_string().as_slice());\n+        println(&x.to_string());\n         self.field1\n     }\n }\n@@ -134,7 +134,7 @@ impl SubTrait for some_fields {}\n \n impl some_fields {\n     fn stat(x: u32) -> u32 {\n-        println(x.to_string().as_slice());\n+        println(&x.to_string());\n         42\n     }\n     fn stat2(x: &some_fields) -> u32 {\n@@ -194,30 +194,30 @@ enum SomeStructEnum {\n \n fn matchSomeEnum(val: SomeEnum) {\n     match val {\n-        SomeEnum::Ints(int1, int2) => { println((int1+int2).to_string().as_slice()); }\n-        SomeEnum::Floats(float1, float2) => { println((float2*float1).to_string().as_slice()); }\n+        SomeEnum::Ints(int1, int2) => { println(&(int1+int2).to_string()); }\n+        SomeEnum::Floats(float1, float2) => { println(&(float2*float1).to_string()); }\n         SomeEnum::Strings(_, _, s3) => { println(s3); }\n         SomeEnum::MyTypes(mt1, mt2) => {\n-            println((mt1.field1 - mt2.field1).to_string().as_slice());\n+            println(&(mt1.field1 - mt2.field1).to_string());\n         }\n     }\n }\n \n fn matchSomeStructEnum(se: SomeStructEnum) {\n     match se {\n-        SomeStructEnum::EnumStruct{a:a, ..} => println(a.to_string().as_slice()),\n-        SomeStructEnum::EnumStruct2{f1:f1, f2:f_2} => println(f_2.field1.to_string().as_slice()),\n-        SomeStructEnum::EnumStruct3{f1, ..} => println(f1.field1.to_string().as_slice()),\n+        SomeStructEnum::EnumStruct{a:a, ..} => println(&a.to_string()),\n+        SomeStructEnum::EnumStruct2{f1:f1, f2:f_2} => println(&f_2.field1.to_string()),\n+        SomeStructEnum::EnumStruct3{f1, ..} => println(&f1.field1.to_string()),\n     }\n }\n \n \n fn matchSomeStructEnum2(se: SomeStructEnum) {\n     use SomeStructEnum::*;\n     match se {\n-        EnumStruct{a: ref aaa, ..} => println(aaa.to_string().as_slice()),\n-        EnumStruct2{f1, f2: f2} => println(f1.field1.to_string().as_slice()),\n-        EnumStruct3{f1, f3: SomeEnum::Ints(_, _), f2} => println(f1.field1.to_string().as_slice()),\n+        EnumStruct{a: ref aaa, ..} => println(&aaa.to_string()),\n+        EnumStruct2{f1, f2: f2} => println(&f1.field1.to_string()),\n+        EnumStruct3{f1, f3: SomeEnum::Ints(_, _), f2} => println(&f1.field1.to_string()),\n         _ => {},\n     }\n }\n@@ -233,12 +233,12 @@ fn matchSomeOtherEnum(val: SomeOtherEnum) {\n fn hello<X: SomeTrait>((z, a) : (u32, String), ex: X) {\n     SameDir2::hello(43);\n \n-    println(yy.to_string().as_slice());\n+    println(&yy.to_string());\n     let (x, y): (u32, u32) = (5, 3);\n-    println(x.to_string().as_slice());\n-    println(z.to_string().as_slice());\n+    println(&x.to_string());\n+    println(&z.to_string());\n     let x: u32 = x;\n-    println(x.to_string().as_slice());\n+    println(&x.to_string());\n     let x = \"hello\";\n     println(x);\n \n@@ -311,7 +311,7 @@ fn main() { // foo\n     let s3: some_fields = some_fields{ field1: 55};\n     let s4: msalias::nested_struct = sub::sub2::nested_struct{ field2: 55};\n     let s4: msalias::nested_struct = sub2::nested_struct{ field2: 55};\n-    println(s2.field1.to_string().as_slice());\n+    println(&s2.field1.to_string());\n     let s5: MyType = box some_fields{ field1: 55};\n     let s = SameDir::SameStruct{name: \"Bob\".to_string()};\n     let s = SubDir::SubStruct{name:\"Bob\".to_string()};"}, {"sha": "be67e5a066acb90596256545070040c90e7b9d76", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -34,8 +34,8 @@ fn random_char() -> char {\n \n fn main() {\n     let args = os::args();\n-    let rustc = args[1].as_slice();\n-    let tmpdir = Path::new(args[2].as_slice());\n+    let rustc = &args[1];\n+    let tmpdir = Path::new(&args[2]);\n \n     let main_file = tmpdir.join(\"unicode_input_multiple_files_main.rs\");\n     {\n@@ -56,12 +56,12 @@ fn main() {\n         // can't exec it directly\n         let result = Command::new(\"sh\")\n                              .arg(\"-c\")\n-                             .arg(format!(\"{} {}\",\n-                                          rustc,\n-                                          main_file.as_str()\n-                                                   .unwrap()).as_slice())\n+                             .arg(&format!(\"{} {}\",\n+                                           rustc,\n+                                           main_file.as_str()\n+                                                    .unwrap()))\n                              .output().unwrap();\n-        let err = String::from_utf8_lossy(result.error.as_slice());\n+        let err = String::from_utf8_lossy(&result.error);\n \n         // positive test so that this test will be updated when the\n         // compiler changes."}, {"sha": "95ce57da4e110c60c977e11a2857abf305340c80", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -34,8 +34,8 @@ fn random_char() -> char {\n \n fn main() {\n     let args = os::args();\n-    let rustc = args[1].as_slice();\n-    let tmpdir = Path::new(args[2].as_slice());\n+    let rustc = &args[1];\n+    let tmpdir = Path::new(&args[2]);\n     let main_file = tmpdir.join(\"span_main.rs\");\n \n     for _ in 0u..100 {\n@@ -52,18 +52,18 @@ fn main() {\n         // can't exec it directly\n         let result = Command::new(\"sh\")\n                              .arg(\"-c\")\n-                             .arg(format!(\"{} {}\",\n-                                          rustc,\n-                                          main_file.as_str()\n-                                                   .unwrap()).as_slice())\n+                             .arg(&format!(\"{} {}\",\n+                                           rustc,\n+                                           main_file.as_str()\n+                                                    .unwrap()))\n                              .output().unwrap();\n \n-        let err = String::from_utf8_lossy(result.error.as_slice());\n+        let err = String::from_utf8_lossy(&result.error);\n \n         // the span should end the line (e.g no extra ~'s)\n         let expected_span = format!(\"^{}\\n\", repeat(\"~\").take(n - 1)\n                                                         .collect::<String>());\n-        assert!(err.contains(expected_span.as_slice()));\n+        assert!(err.contains(&expected_span));\n     }\n \n     // Test multi-column characters and tabs"}, {"sha": "57c50511604ca3f095418cac0f56ca53e264191a", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -47,7 +47,7 @@ pub fn main() {\n     assert_eq!(length(x.clone()), x.len());\n     // Call a parameterized function, with type arguments that require\n     // a borrow\n-    assert_eq!(length::<int, &[int]>(x.as_slice()), x.len());\n+    assert_eq!(length::<int, &[int]>(&*x), x.len());\n \n     // Now try it with a type that *needs* to be borrowed\n     let z = [0,1,2,3];"}, {"sha": "f21b7183d70c46c5445081f762ed18c55af6f41f", "filename": "src/test/run-pass/associated-types-conditional-dispatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -36,7 +36,7 @@ impl<'a, A, B, Lhs> MyEq<[B; 0]> for Lhs\n     where A: MyEq<B>, Lhs: Deref<Target=[A]>\n {\n     fn eq(&self, other: &[B; 0]) -> bool {\n-        MyEq::eq(&**self, other.as_slice())\n+        MyEq::eq(&**self, other)\n     }\n }\n "}, {"sha": "2cb6cf99d662e48194a48c4439bebddc44c39461", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -48,23 +48,23 @@ fn runtest(me: &str) {\n     let p = template.clone().arg(\"fail\").env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error.as_slice()).unwrap();\n+    let s = str::from_utf8(&out.error).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"foo::h\"),\n             \"bad output: {}\", s);\n \n     // Make sure the stack trace is *not* printed\n     let p = template.clone().arg(\"fail\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error.as_slice()).unwrap();\n+    let s = str::from_utf8(&out.error).unwrap();\n     assert!(!s.contains(\"stack backtrace\") && !s.contains(\"foo::h\"),\n             \"bad output2: {}\", s);\n \n     // Make sure a stack trace is printed\n     let p = template.clone().arg(\"double-fail\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error.as_slice()).unwrap();\n+    let s = str::from_utf8(&out.error).unwrap();\n     // loosened the following from double::h to double:: due to\n     // spurious failures on mac, 32bit, optimized\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"double::\"),\n@@ -75,7 +75,7 @@ fn runtest(me: &str) {\n                                 .env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error.as_slice()).unwrap();\n+    let s = str::from_utf8(&out.error).unwrap();\n     let mut i = 0;\n     for _ in 0..2 {\n         i += s[i + 10..].find_str(\"stack backtrace\").unwrap() + 10;\n@@ -86,12 +86,12 @@ fn runtest(me: &str) {\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() >= 2 && args[1].as_slice() == \"fail\" {\n+    let args = args;\n+    if args.len() >= 2 && args[1] == \"fail\" {\n         foo();\n-    } else if args.len() >= 2 && args[1].as_slice() == \"double-fail\" {\n+    } else if args.len() >= 2 && args[1] == \"double-fail\" {\n         double();\n     } else {\n-        runtest(args[0].as_slice());\n+        runtest(&args[0]);\n     }\n }"}, {"sha": "758776298e1463cc94699fc4f563dd4ecb94da23", "filename": "src/test/run-pass/bare-fn-implements-fn-mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -26,13 +26,13 @@ fn call_g<G:FnMut(String,String) -> String>(mut g: G, x: String, y: String)\n }\n \n fn g(mut x: String, y: String) -> String {\n-    x.push_str(y.as_slice());\n+    x.push_str(&y);\n     x\n }\n \n fn main() {\n     call_f(f);\n-    assert_eq!(call_g(g, \"foo\".to_string(), \"bar\".to_string()).as_slice(),\n+    assert_eq!(call_g(g, \"foo\".to_string(), \"bar\".to_string()),\n                \"foobar\");\n }\n "}, {"sha": "edf6b397ff8c8c7703a3a1bb1ade80ba8b41a9f8", "filename": "src/test/run-pass/bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbool.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -53,9 +53,9 @@ fn main() {\n     assert_eq!(!false, true);\n \n     let s = false.to_string();\n-    assert_eq!(s.as_slice(), \"false\");\n+    assert_eq!(s, \"false\");\n     let s = true.to_string();\n-    assert_eq!(s.as_slice(), \"true\");\n+    assert_eq!(s, \"true\");\n \n     assert!(true > false);\n     assert!(!(false > true));"}, {"sha": "34ad2b2def03f82a5d4de6a5838ff9064ce50931", "filename": "src/test/run-pass/borrowck-binding-mutbl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fborrowck-binding-mutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fborrowck-binding-mutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-binding-mutbl.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -19,7 +19,7 @@ pub fn main() {\n \n     match x {\n       F {f: ref mut v} => {\n-        impure(v.as_slice());\n+        impure(v);\n       }\n     }\n }"}, {"sha": "092d7c1317029be72ec0abe99ec82fcae68a08e0", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -16,7 +16,7 @@ fn want_slice(v: &[int]) -> int {\n }\n \n fn has_mut_vec(v: Vec<int> ) -> int {\n-    want_slice(v.as_slice())\n+    want_slice(&v)\n }\n \n pub fn main() {"}, {"sha": "efd932933db333504992493df3a2457ff88f6f7d", "filename": "src/test/run-pass/borrowed-ptr-pattern-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn foo(s: &String) -> bool {\n-    match s.as_slice() {\n+    match &**s {\n         \"kitty\" => true,\n         _ => false\n     }"}, {"sha": "edb3d72483b471663e7892107ba2e0e8ead5d853", "filename": "src/test/run-pass/cleanup-rvalue-temp-during-incomplete-alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -44,7 +44,7 @@ fn get_bar(x: uint) -> Vec<uint> { vec!(x * 2) }\n pub fn fails() {\n     let x = 2;\n     let mut y = Vec::new();\n-    y.push(box Conzabble::Bickwick(do_it(get_bar(x).as_slice())));\n+    y.push(box Conzabble::Bickwick(do_it(&get_bar(x))));\n }\n \n pub fn main() {"}, {"sha": "b776f098b1db2f550b7850149b1ae97cba083818", "filename": "src/test/run-pass/cleanup-shortcircuit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -24,15 +24,15 @@ use std::os;\n \n pub fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n+    let args = args;\n \n     // Here, the rvalue `\"signal\".to_string()` requires cleanup. Older versions\n     // of the code had a problem that the cleanup scope for this\n     // expression was the end of the `if`, and as the `\"signal\".to_string()`\n     // expression was never evaluated, we wound up trying to clean\n     // uninitialized memory.\n \n-    if args.len() >= 2 && args[1].as_slice() == \"signal\" {\n+    if args.len() >= 2 && args[1] == \"signal\" {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }\n     }"}, {"sha": "69bb3579720b1ccd37bb149fb5ec4f8f3a916996", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -19,6 +19,6 @@ fn bip(v: &[uint]) -> Vec<uint> {\n \n pub fn main() {\n     let mut the_vec = vec!(1u, 2, 3, 100);\n-    assert_eq!(the_vec.clone(), bar(the_vec.as_mut_slice()));\n-    assert_eq!(the_vec.clone(), bip(the_vec.as_slice()));\n+    assert_eq!(the_vec.clone(), bar(&mut the_vec));\n+    assert_eq!(the_vec.clone(), bip(&the_vec));\n }"}, {"sha": "f87f2e07c9de0f0ee2507023a37286cb905f3bee", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -21,6 +21,6 @@ fn bar(v: &mut [uint]) {\n \n pub fn main() {\n     let mut the_vec = vec!(1, 2, 3, 100);\n-    bar(the_vec.as_mut_slice());\n+    bar(&mut the_vec);\n     assert_eq!(the_vec, vec!(100, 3, 2, 1));\n }"}, {"sha": "4f97e6a20815d0014f06a8581abac69b50d8f69e", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -17,6 +17,6 @@ fn bar(v: &mut [uint]) {\n \n pub fn main() {\n     let mut the_vec = vec!(1, 2, 3, 100);\n-    bar(the_vec.as_mut_slice());\n+    bar(&mut the_vec);\n     assert_eq!(the_vec, vec!(100, 3, 2, 1));\n }"}, {"sha": "838d05cf0d53084873383d4c3cabd51529818619", "filename": "src/test/run-pass/deriving-encodable-decodable-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-box.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -25,6 +25,6 @@ struct A {\n fn main() {\n     let obj = A { foo: box [true, false] };\n     let s = json::encode(&obj).unwrap();\n-    let obj2: A = json::decode(s.as_slice()).unwrap();\n+    let obj2: A = json::decode(&s).unwrap();\n     assert!(obj.foo == obj2.foo);\n }"}, {"sha": "7d581927c30b460a1aafd7dac9182fb90a294a11", "filename": "src/test/run-pass/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -36,7 +36,7 @@ fn main() {\n         bar: RefCell::new( A { baz: 2 } )\n     };\n     let s = json::encode(&obj).unwrap();\n-    let obj2: B = json::decode(s.as_slice()).unwrap();\n+    let obj2: B = json::decode(&s).unwrap();\n     assert!(obj.foo.get() == obj2.foo.get());\n     assert!(obj.bar.borrow().baz == obj2.bar.borrow().baz);\n }"}, {"sha": "3c89900fe493bad40d3d106d3948b9cfebe9c862", "filename": "src/test/run-pass/getopts_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     let args = Vec::new();\n     let opts = vec!(optopt(\"b\", \"\", \"something\", \"SMTHNG\"));\n \n-    match getopts(args.as_slice(), opts.as_slice()) {\n+    match getopts(&args, &opts) {\n         Ok(ref m)  =>\n             assert!(!m.opt_present(\"b\")),\n         Err(ref f) => panic!(\"{}\", *f)"}, {"sha": "677038af9a9c4e0de4609f0622e812f17f377486", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -84,8 +84,7 @@ mod map_reduce {\n               ctrl_proto::mapper_done => { num_mappers -= 1; }\n               ctrl_proto::find_reducer(k, cc) => {\n                 let mut c;\n-                match reducers.get(&str::from_utf8(\n-                        k.as_slice()).unwrap().to_string()) {\n+                match reducers.get(&str::from_utf8(&k).unwrap().to_string()) {\n                   Some(&_c) => { c = _c; }\n                   None => { c = 0; }\n                 }"}, {"sha": "06294696bc937dc11ad5110487671b2d8f17ad84", "filename": "src/test/run-pass/if-let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fif-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fif-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-let.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -50,7 +50,7 @@ pub fn main() {\n     } else if let Foo::Two(_x) = foo {\n         panic!(\"bad pattern match\");\n     } else if let Foo::Three(s, _) = foo {\n-        assert_eq!(s.as_slice(), \"three\");\n+        assert_eq!(s, \"three\");\n     } else {\n         panic!(\"bad else\");\n     }"}, {"sha": "5d157d875fa4dbec76c3d25e5853c5c21da5e5f3", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -39,7 +39,7 @@ impl fmt::Display for C {\n }\n \n macro_rules! t {\n-    ($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) }\n+    ($a:expr, $b:expr) => { assert_eq!($a, $b) }\n }\n \n pub fn main() {"}, {"sha": "d87b59537df8f120968480a5940df427dfc4dd62", "filename": "src/test/run-pass/inconsistent-lifetime-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Finconsistent-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Finconsistent-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finconsistent-lifetime-mismatch.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -15,7 +15,7 @@ fn bad(a: &str, b: &str) {\n }\n \n fn good(a: &str, b: &str) {\n-    foo(&[a.as_slice(), b.as_slice()]);\n+    foo(&[a, b]);\n }\n \n fn main() {}"}, {"sha": "9150920cf2cc7e5feb79b97ea1649a3c01d50ab1", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -17,8 +17,8 @@ use std::old_io::process;\n \n pub fn main () {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() > 1 && args[1].as_slice() == \"child\" {\n+    let args = args;\n+    if args.len() > 1 && args[1] == \"child\" {\n         for _ in 0..1000 {\n             println!(\"hello?\");\n         }\n@@ -28,7 +28,7 @@ pub fn main () {\n         return;\n     }\n \n-    let mut p = process::Command::new(args[0].as_slice());\n+    let mut p = process::Command::new(&args[0]);\n     p.arg(\"child\").stdout(process::Ignored).stderr(process::Ignored);\n     println!(\"{:?}\", p.spawn().unwrap().wait());\n }"}, {"sha": "a01d2e6f1a9ed90873de03e2efd58fa2e64f1c41", "filename": "src/test/run-pass/issue-10683.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-10683.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-10683.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10683.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -13,7 +13,7 @@ use std::ascii::AsciiExt;\n static NAME: &'static str = \"hello world\";\n \n fn main() {\n-    match NAME.to_ascii_lowercase().as_slice() {\n+    match &*NAME.to_ascii_lowercase() {\n         \"foo\" => {}\n         _ => {}\n     }"}, {"sha": "12a6d9a82c7b014d2b019eeaa9df4ede82d44ddb", "filename": "src/test/run-pass/issue-11869.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-11869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-11869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11869.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -13,7 +13,7 @@ struct A {\n }\n \n fn borrow<'a>(binding: &'a A) -> &'a str {\n-    match binding.a.as_slice() {\n+    match &*binding.a {\n         \"in\" => \"in_\",\n         \"ref\" => \"ref_\",\n         ident => ident"}, {"sha": "056c86b01f7346c92ab6c179f0a7bbfebd567dc1", "filename": "src/test/run-pass/issue-13027.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13027.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -179,7 +179,7 @@ fn misc() {\n     // This test basically mimics how trace_macros! macro is implemented,\n     // which is a rare combination of vector patterns, multiple wild-card\n     // patterns and guard functions.\n-    let r = match [Foo::Bar(0, false)].as_slice() {\n+    let r = match [Foo::Bar(0, false)] {\n         [Foo::Bar(_, pred)] if pred => 1,\n         [Foo::Bar(_, pred)] if !pred => 2,\n         _ => 0,"}, {"sha": "f979235da7197bee2a207c4aa4f3dea501ff2b02", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -16,8 +16,8 @@ use std::str;\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() > 1 && args[1].as_slice() == \"child\" {\n+    let args = args;\n+    if args.len() > 1 && args[1] == \"child\" {\n         child();\n     } else {\n         parent();\n@@ -26,13 +26,13 @@ fn main() {\n \n fn parent() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    let mut p = old_io::process::Command::new(args[0].as_slice())\n+    let args = args;\n+    let mut p = old_io::process::Command::new(&args[0])\n                                      .arg(\"child\").spawn().unwrap();\n     p.stdin.as_mut().unwrap().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(out.status.success());\n-    let s = str::from_utf8(out.output.as_slice()).unwrap();\n+    let s = str::from_utf8(&out.output).unwrap();\n     assert_eq!(s, \"test1\\n\\ntest2\\n\\ntest3\\n\");\n }\n "}, {"sha": "44167ad2096decc595eb7e352de1ebeb11bc8740", "filename": "src/test/run-pass/issue-13323.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-13323.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-13323.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13323.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -21,7 +21,7 @@ impl StrWrap {\n     }\n \n     fn get_s<'a>(&'a self) -> &'a str {\n-        self.s.as_slice()\n+        &self.s\n     }\n }\n "}, {"sha": "e850ecbba6e560d6d2ad12b0ac9c0153a44f47b1", "filename": "src/test/run-pass/issue-14021.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-14021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-14021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14021.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n     let obj = UnitLikeStruct;\n     let json_str: String = json::encode(&obj).unwrap();\n \n-    let json_object = json::from_str(json_str.as_slice());\n+    let json_object = json::from_str(&json_str);\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n     let mut decoded_obj: UnitLikeStruct = Decodable::decode(&mut decoder).unwrap();\n "}, {"sha": "5f44eb7dcd23e2ed6a987e2b9b1e9a7efffbfac8", "filename": "src/test/run-pass/issue-14456.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14456.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -16,7 +16,7 @@ use std::os;\n \n fn main() {\n     let args = os::args();\n-    if args.len() > 1 && args[1].as_slice() == \"child\" {\n+    if args.len() > 1 && args[1] == \"child\" {\n         return child()\n     }\n \n@@ -32,7 +32,7 @@ fn child() {\n \n fn test() {\n     let args = os::args();\n-    let mut p = Command::new(args[0].as_slice()).arg(\"child\")\n+    let mut p = Command::new(&args[0]).arg(\"child\")\n                                      .stdin(process::Ignored)\n                                      .stdout(process::Ignored)\n                                      .stderr(process::Ignored)"}, {"sha": "ace1f00b023b58a8847ab40dae2cf496d1c98cd7", "filename": "src/test/run-pass/issue-14936.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14936.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -31,7 +31,7 @@ macro_rules! demo {\n             }\n             assert_eq!((x,y), (1,1));\n             let b: &[_] = &[\"out\", \"in\"];\n-            assert_eq!(history.as_slice(), b);\n+            assert_eq!(history, b);\n         }\n     }\n }"}, {"sha": "e5fead72bebeb44b5aa4acd15f83c2ad31bc6ce8", "filename": "src/test/run-pass/issue-14940.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14940.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -17,7 +17,7 @@ fn main() {\n         let mut out = stdio::stdout();\n         out.write(&['a' as u8; 128 * 1024]).unwrap();\n     } else {\n-        let out = Command::new(args[0].as_slice()).arg(\"child\").output();\n+        let out = Command::new(&args[0]).arg(\"child\").output();\n         let out = out.unwrap();\n         assert!(out.status.success());\n     }"}, {"sha": "24f7a6af78239a259c98d240c33464afd00e4ddb", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -17,7 +17,7 @@ use std::rand::random;\n fn main() {\n     // If we're the child, make sure we were invoked correctly\n     let args = os::args();\n-    if args.len() > 1 && args[1].as_slice() == \"child\" {\n+    if args.len() > 1 && args[1] == \"child\" {\n         // FIXME: This should check the whole `args[0]` instead of just\n         // checking that it ends_with the executable name. This\n         // is needed because of Windows, which has a different behavior.\n@@ -45,9 +45,9 @@ fn test() {\n     // Append the new directory to our own PATH.\n     let mut path = os::split_paths(os::getenv(\"PATH\").unwrap_or(String::new()));\n     path.push(child_dir.clone());\n-    let path = os::join_paths(path.as_slice()).unwrap();\n+    let path = os::join_paths(&path).unwrap();\n \n-    let child_output = Command::new(\"mytest\").env(\"PATH\", path.as_slice())\n+    let child_output = Command::new(\"mytest\").env(\"PATH\", path)\n                                              .arg(\"child\")\n                                              .output().unwrap();\n "}, {"sha": "c2bcbe045c0cc07ac5c51e59a4cbfffd1e46893b", "filename": "src/test/run-pass/issue-16783.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-16783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-16783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16783.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -10,5 +10,5 @@\n \n pub fn main() {\n     let x = [1, 2, 3];\n-    let y = x.as_slice();\n+    let y = x;\n }"}, {"sha": "3cff16409cb9b811c2b6fdf782bb18fdb7824578", "filename": "src/test/run-pass/issue-17734.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-17734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-17734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17734.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -21,6 +21,6 @@ fn main() {\n     // There is currently no safe way to construct a `Box<str>`, so improvise\n     let box_arr: Box<[u8]> = box ['h' as u8, 'e' as u8, 'l' as u8, 'l' as u8, 'o' as u8];\n     let box_str: Box<str> = unsafe { std::mem::transmute(box_arr) };\n-    assert_eq!(box_str.as_slice(), \"hello\");\n+    assert_eq!(&*box_str, \"hello\");\n     f(box_str);\n }"}, {"sha": "e5532b4550baab32c48a59b2191a8ee617f53141", "filename": "src/test/run-pass/issue-18352.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-18352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-18352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18352.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -11,7 +11,7 @@\n const X: &'static str = \"12345\";\n \n fn test(s: String) -> bool {\n-    match s.as_slice() {\n+    match &*s {\n         X => true,\n         _ => false\n     }"}, {"sha": "754412ea949381c7059b1a6d6472d9f7a76d2489", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -24,6 +24,6 @@ pub fn main() {\n     let mut table = HashMap::new();\n     table.insert(\"one\".to_string(), 1);\n     table.insert(\"two\".to_string(), 2);\n-    assert!(check_strs(format!(\"{:?}\", table).as_slice(), \"HashMap {\\\"one\\\": 1, \\\"two\\\": 2}\") ||\n-            check_strs(format!(\"{:?}\", table).as_slice(), \"HashMap {\\\"two\\\": 2, \\\"one\\\": 1}\"));\n+    assert!(check_strs(&format!(\"{:?}\", table), \"HashMap {\\\"one\\\": 1, \\\"two\\\": 2}\") ||\n+            check_strs(&format!(\"{:?}\", table), \"HashMap {\\\"two\\\": 2, \\\"one\\\": 1}\"));\n }"}, {"sha": "f4b85e03eaeac031dfb37f2e8de0f9cb7effcdbe", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -162,7 +162,7 @@ pub fn check_strs(actual: &str, expected: &str) -> bool {\n \n fn test_ascii_art_ctor() {\n     let art = AsciiArt(3, 3, '*');\n-    assert!(check_strs(art.to_string().as_slice(), \"...\\n...\\n...\"));\n+    assert!(check_strs(&art.to_string(), \"...\\n...\\n...\"));\n }\n \n \n@@ -171,15 +171,15 @@ fn test_add_pt() {\n     art.add_pt(0, 0);\n     art.add_pt(0, -10);\n     art.add_pt(1, 2);\n-    assert!(check_strs(art.to_string().as_slice(), \"*..\\n...\\n.*.\"));\n+    assert!(check_strs(&art.to_string(), \"*..\\n...\\n.*.\"));\n }\n \n \n fn test_shapes() {\n     let mut art = AsciiArt(4, 4, '*');\n     art.add_rect(Rect {top_left: Point {x: 0, y: 0}, size: Size {width: 4, height: 4}});\n     art.add_point(Point {x: 2, y: 2});\n-    assert!(check_strs(art.to_string().as_slice(), \"****\\n*..*\\n*.**\\n****\"));\n+    assert!(check_strs(&art.to_string(), \"****\\n*..*\\n*.**\\n****\"));\n }\n \n pub fn main() {"}, {"sha": "f10303e8d8479a1eb433c4dbe1122628e3a84de5", "filename": "src/test/run-pass/issue-4541.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4541.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -10,11 +10,11 @@\n \n fn parse_args() -> String {\n     let args = ::std::os::args();\n-    let args = args.as_slice();\n+    let args = args;\n     let mut n = 0;\n \n     while n < args.len() {\n-        match args[n].as_slice() {\n+        match &*args[n] {\n             \"-v\" => (),\n             s => {\n                 return s.to_string();"}, {"sha": "f87f1d8af7649fb723fdd9c707311c72059207dd", "filename": "src/test/run-pass/issue-5550.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-5550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-5550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5550.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -12,6 +12,6 @@\n \n pub fn main() {\n     let s: String = \"foobar\".to_string();\n-    let mut t: &str = s.as_slice();\n+    let mut t: &str = &s;\n     t = &t[0..3]; // for master: str::view(t, 0, 3) maybe\n }"}, {"sha": "da5338b8c3c61438bdfdf74362909e788cb94fda", "filename": "src/test/run-pass/issue-9259.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-9259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-9259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9259.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -19,5 +19,5 @@ pub fn main() {\n         a: &[\"test\".to_string()],\n         b: Some(b),\n     };\n-    assert_eq!(a.b.as_ref().unwrap()[0].as_slice(), \"foo\");\n+    assert_eq!(a.b.as_ref().unwrap()[0], \"foo\");\n }"}, {"sha": "c501420fa617a00c212fc6f5c2a609512da99d3e", "filename": "src/test/run-pass/issue-9382.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9382.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -34,15 +34,15 @@ pub fn main() {\n         bar: box 32,\n     };\n     Thing1 {\n-        baz: Vec::new().as_slice(),\n+        baz: &Vec::new(),\n         bar: box 32,\n     };\n     let _t2_fixed = Thing2 {\n         baz: &[],\n         bar: 32,\n     };\n     Thing2 {\n-        baz: Vec::new().as_slice(),\n+        baz: &Vec::new(),\n         bar: 32,\n     };\n }"}, {"sha": "15195482ed693921f39beac19f320a62450fb2a0", "filename": "src/test/run-pass/istr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fistr.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -37,19 +37,19 @@ fn test_heap_log() {\n fn test_append() {\n     let mut s = String::new();\n     s.push_str(\"a\");\n-    assert_eq!(s.as_slice(), \"a\");\n+    assert_eq!(s, \"a\");\n \n     let mut s = String::from_str(\"a\");\n     s.push_str(\"b\");\n     println!(\"{}\", s.clone());\n-    assert_eq!(s.as_slice(), \"ab\");\n+    assert_eq!(s, \"ab\");\n \n     let mut s = String::from_str(\"c\");\n     s.push_str(\"offee\");\n-    assert!(s.as_slice() == \"coffee\");\n+    assert!(s == \"coffee\");\n \n     s.push_str(\"&tea\");\n-    assert!(s.as_slice() == \"coffee&tea\");\n+    assert!(s == \"coffee&tea\");\n }\n \n pub fn main() {"}, {"sha": "3c2a3f355b412e15ecf549bba8e8318d559fc438", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -17,6 +17,6 @@ struct Refs { refs: Vec<int> , n: int }\n pub fn main() {\n     let mut e = Refs{refs: vec!(), n: 0};\n     let _f = || println!(\"{}\", e.n);\n-    let x: &[int] = e.refs.as_slice();\n+    let x: &[int] = &e.refs;\n     assert_eq!(x.len(), 0);\n }"}, {"sha": "1be0ee4a285514c4ab5c23db4f92f866a521c083", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -21,18 +21,18 @@ use std::str;\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() > 1 && args[1].as_slice() == \"child\" {\n+    let args = args;\n+    if args.len() > 1 && args[1] == \"child\" {\n         debug!(\"foo\");\n         debug!(\"bar\");\n         return\n     }\n \n-    let p = Command::new(args[0].as_slice())\n+    let p = Command::new(&args[0])\n                     .arg(\"child\")\n                     .spawn().unwrap().wait_with_output().unwrap();\n     assert!(p.status.success());\n-    let mut lines = str::from_utf8(p.error.as_slice()).unwrap().lines();\n+    let mut lines = str::from_utf8(&p.error).unwrap().lines();\n     assert!(lines.next().unwrap().contains(\"foo\"));\n     assert!(lines.next().unwrap().contains(\"bar\"));\n }"}, {"sha": "301d99a7e20b32b807b9dcce761162c782b01d47", "filename": "src/test/run-pass/match-str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fmatch-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fmatch-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-str.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -18,8 +18,8 @@ pub fn main() {\n \n     match t::tag1(\"test\".to_string()) {\n       t::tag2 => panic!(),\n-      t::tag1(ref s) if \"test\" != s.as_slice() => panic!(),\n-      t::tag1(ref s) if \"test\" == s.as_slice() => (),\n+      t::tag1(ref s) if \"test\" != &**s => panic!(),\n+      t::tag1(ref s) if \"test\" == &**s => (),\n       _ => panic!()\n     }\n "}, {"sha": "0ad600dd85d9338a1ed33c230053c369fa0098c7", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -41,7 +41,7 @@ fn main() {\n     let mut buf = [0_u8; 6];\n \n     {\n-        let mut writer = buf.as_mut_slice();\n+        let mut writer: &mut [_] = &mut buf;\n         writer.my_write(&[0, 1, 2]).unwrap();\n         writer.my_write(&[3, 4, 5]).unwrap();\n     }"}, {"sha": "cb487a34f338876dc9e60557be588322c8577b2c", "filename": "src/test/run-pass/move-out-of-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -31,5 +31,5 @@ pub fn main() {\n     sb.append(\"Hello, \");\n     sb.append(\"World!\");\n     let str = to_string(sb);\n-    assert_eq!(str.as_slice(), \"Hello, World!\");\n+    assert_eq!(str, \"Hello, World!\");\n }"}, {"sha": "7430f730f3b17d0799c24873434ea9e184128053", "filename": "src/test/run-pass/new-unicode-escapes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fnew-unicode-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fnew-unicode-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-unicode-escapes.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -18,5 +18,5 @@ pub fn main() {\n     let s = \"\\\\{20}\";\n     let mut correct_s = String::from_str(\"\\\\\");\n     correct_s.push_str(\"{20}\");\n-    assert_eq!(s, correct_s.as_slice());\n+    assert_eq!(s, correct_s);\n }"}, {"sha": "3710f1b9d3052e2a27c08e3376a44f00f8649d80", "filename": "src/test/run-pass/order-drop-with-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -60,6 +60,6 @@ fn main() {\n     }\n     unsafe {\n         let expected: &[_] = &[1, 2, 3];\n-        assert_eq!(expected, ORDER.as_slice());\n+        assert_eq!(expected, ORDER);\n     }\n }"}, {"sha": "ca9ee469e38976ec8e49f729de97a428fb17db33", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -35,13 +35,13 @@ fn recurse() {\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() > 1 && args[1].as_slice() == \"recurse\" {\n+    let args = args;\n+    if args.len() > 1 && args[1] == \"recurse\" {\n         let _t = Thread::scoped(recurse);\n     } else {\n-        let recurse = Command::new(args[0].as_slice()).arg(\"recurse\").output().unwrap();\n+        let recurse = Command::new(&args[0]).arg(\"recurse\").output().unwrap();\n         assert!(!recurse.status.success());\n-        let error = String::from_utf8_lossy(recurse.error.as_slice());\n+        let error = String::from_utf8_lossy(&recurse.error);\n         println!(\"wut\");\n         println!(\"`{}`\", error);\n         assert!(error.contains(\"has overflowed its stack\"));"}, {"sha": "fba86d74816790438fe07d986d7ccf82c49f5ee4", "filename": "src/test/run-pass/out-of-stack-no-split.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -35,13 +35,12 @@ fn recurse() {\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() > 1 && args[1].as_slice() == \"recurse\" {\n+    if args.len() > 1 && args[1] == \"recurse\" {\n         recurse();\n     } else {\n-        let recurse = Command::new(args[0].as_slice()).arg(\"recurse\").output().unwrap();\n+        let recurse = Command::new(&args[0]).arg(\"recurse\").output().unwrap();\n         assert!(!recurse.status.success());\n-        let error = String::from_utf8_lossy(recurse.error.as_slice());\n+        let error = String::from_utf8_lossy(&recurse.error);\n         assert!(error.contains(\"has overflowed its stack\"));\n     }\n }"}, {"sha": "7dfd46fb995a207706de5f9326a7c820b1e06275", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -35,20 +35,20 @@ fn loud_recurse() {\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() > 1 && args[1].as_slice() == \"silent\" {\n+    let args = args;\n+    if args.len() > 1 && args[1] == \"silent\" {\n         silent_recurse();\n-    } else if args.len() > 1 && args[1].as_slice() == \"loud\" {\n+    } else if args.len() > 1 && args[1] == \"loud\" {\n         loud_recurse();\n     } else {\n-        let silent = Command::new(args[0].as_slice()).arg(\"silent\").output().unwrap();\n+        let silent = Command::new(&args[0]).arg(\"silent\").output().unwrap();\n         assert!(!silent.status.success());\n-        let error = String::from_utf8_lossy(silent.error.as_slice());\n+        let error = String::from_utf8_lossy(&silent.error);\n         assert!(error.contains(\"has overflowed its stack\"));\n \n-        let loud = Command::new(args[0].as_slice()).arg(\"loud\").output().unwrap();\n+        let loud = Command::new(&args[0]).arg(\"loud\").output().unwrap();\n         assert!(!loud.status.success());\n-        let error = String::from_utf8_lossy(silent.error.as_slice());\n+        let error = String::from_utf8_lossy(&silent.error);\n         assert!(error.contains(\"has overflowed its stack\"));\n     }\n }"}, {"sha": "fcf0feb6e30d00652cfc4ca877bd6bd51fd51e7d", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -34,13 +34,13 @@ pub fn main() {\n     assert_eq!((i_value, *i.borrow()), (2, 5));\n \n     let s = Rc::new(\"foo\".to_string());\n-    assert_eq!(s.as_slice(), \"foo\");\n+    assert_eq!(&**s, \"foo\");\n \n     let mut_s = Rc::new(RefCell::new(String::from_str(\"foo\")));\n     mut_s.borrow_mut().push_str(\"bar\");\n     // HACK assert_eq! would panic here because it stores the LHS and RHS in two locals.\n-    assert!(mut_s.borrow().as_slice() == \"foobar\");\n-    assert!(mut_s.borrow_mut().as_slice() == \"foobar\");\n+    assert!(&**mut_s.borrow() == \"foobar\");\n+    assert!(&**mut_s.borrow_mut() == \"foobar\");\n \n     let p = Rc::new(RefCell::new(Point {x: 1, y: 2}));\n     p.borrow_mut().x = 3;"}, {"sha": "f3091b53e8badc02e5223d2b4a30feb595f0889e", "filename": "src/test/run-pass/overloaded-deref-count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -82,5 +82,5 @@ pub fn main() {\n     // Check the final states.\n     assert_eq!(*n, 2);\n     let expected: &[_] = &[1, 2];\n-    assert_eq!((*v).as_slice(), expected);\n+    assert_eq!((*v), expected);\n }"}, {"sha": "f56e7d56fe16aec00df2034f97375ea37f461eb2", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -33,13 +33,13 @@ pub fn main() {\n \n     let s = Rc::new(\"foo\".to_string());\n     assert_eq!(*s, \"foo\".to_string());\n-    assert_eq!((*s).as_slice(), \"foo\");\n+    assert_eq!((*s), \"foo\");\n \n     let mut_s = Rc::new(RefCell::new(String::from_str(\"foo\")));\n     (*(*mut_s).borrow_mut()).push_str(\"bar\");\n     // assert_eq! would panic here because it stores the LHS and RHS in two locals.\n-    assert!((*(*mut_s).borrow()).as_slice() == \"foobar\");\n-    assert!((*(*mut_s).borrow_mut()).as_slice() == \"foobar\");\n+    assert!((*(*mut_s).borrow()) == \"foobar\");\n+    assert!((*(*mut_s).borrow_mut()) == \"foobar\");\n \n     let p = Rc::new(RefCell::new(Point {x: 1, y: 2}));\n     (*(*p).borrow_mut()).x = 3;"}, {"sha": "8b99e8a947cf5877de567e44a0acad1870606c85", "filename": "src/test/run-pass/process-remove-from-env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -41,12 +41,12 @@ fn main() {\n     // restore original environment\n     match old_env {\n         None => os::unsetenv(\"RUN_TEST_NEW_ENV\"),\n-        Some(val) => os::setenv(\"RUN_TEST_NEW_ENV\", val.as_slice())\n+        Some(val) => os::setenv(\"RUN_TEST_NEW_ENV\", val)\n     }\n \n     let prog = cmd.spawn().unwrap();\n     let result = prog.wait_with_output().unwrap();\n-    let output = String::from_utf8_lossy(result.output.as_slice());\n+    let output = String::from_utf8_lossy(&result.output);\n \n     assert!(!output.contains(\"RUN_TEST_NEW_ENV\"),\n             \"found RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "15cc128d380db4db7cb62aed971fe25ce7bfb5ce", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -58,12 +58,12 @@ fn main() {\n         let p = Command::new(&child_path)\n                         .arg(arg)\n                         .cwd(&cwd)\n-                        .env_set_all(my_env.as_slice())\n+                        .env_set_all(&my_env)\n                         .spawn().unwrap().wait_with_output().unwrap();\n \n         // display the output\n-        assert!(old_io::stdout().write(p.output.as_slice()).is_ok());\n-        assert!(old_io::stderr().write(p.error.as_slice()).is_ok());\n+        assert!(old_io::stdout().write(&p.output).is_ok());\n+        assert!(old_io::stderr().write(&p.error).is_ok());\n \n         // make sure the child succeeded\n         assert!(p.status.success());\n@@ -74,7 +74,7 @@ fn main() {\n         assert!(my_cwd.ends_with_path(&Path::new(child_dir)));\n \n         // check arguments\n-        assert_eq!(my_args[1].as_slice(), arg);\n+        assert_eq!(&*my_args[1], arg);\n \n         // check environment variable\n         assert!(my_env.contains(&env));"}, {"sha": "6a5da0149947abd8225cc0b4bd02cdf745a4e480", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -24,7 +24,7 @@ fn call_sum(x: &[int]) -> int { x.sum_() }\n \n pub fn main() {\n     let x = vec!(1, 2, 3);\n-    let y = call_sum(x.as_slice());\n+    let y = call_sum(&x);\n     println!(\"y=={}\", y);\n     assert_eq!(y, 6);\n "}, {"sha": "441c9d79e79f3832c15a53942db8282068dc4fa1", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -28,7 +28,7 @@ fn main() {\n unsafe fn test_triangle() -> bool {\n     static COUNT : uint = 16;\n     let mut ascend = repeat(ptr::null_mut()).take(COUNT).collect::<Vec<_>>();\n-    let ascend = ascend.as_mut_slice();\n+    let ascend = &mut *ascend;\n     static ALIGN : uint = 1;\n \n     // Checks that `ascend` forms triangle of ascending size formed\n@@ -103,7 +103,7 @@ unsafe fn test_triangle() -> bool {\n         }\n     }\n \n-    sanity_check(ascend.as_slice());\n+    sanity_check(&*ascend);\n     test_1(ascend); // triangle -> square\n     test_2(ascend); // square -> triangle\n     test_3(ascend); // triangle -> square\n@@ -128,10 +128,10 @@ unsafe fn test_triangle() -> bool {\n             assert!(old_size < new_size);\n \n             ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n-            sanity_check(ascend.as_slice());\n+            sanity_check(&*ascend);\n \n             ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n-            sanity_check(ascend.as_slice());\n+            sanity_check(&*ascend);\n         }\n     }\n \n@@ -143,10 +143,10 @@ unsafe fn test_triangle() -> bool {\n             assert!(new_size < old_size);\n \n             ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n-            sanity_check(ascend.as_slice());\n+            sanity_check(&*ascend);\n \n             ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n-            sanity_check(ascend.as_slice());\n+            sanity_check(&*ascend);\n         }\n     }\n \n@@ -158,10 +158,10 @@ unsafe fn test_triangle() -> bool {\n             assert!(old_size < new_size);\n \n             ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n-            sanity_check(ascend.as_slice());\n+            sanity_check(&*ascend);\n \n             ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n-            sanity_check(ascend.as_slice());\n+            sanity_check(&*ascend);\n         }\n     }\n \n@@ -173,10 +173,10 @@ unsafe fn test_triangle() -> bool {\n             assert!(new_size < old_size);\n \n             ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n-            sanity_check(ascend.as_slice());\n+            sanity_check(&*ascend);\n \n             ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n-            sanity_check(ascend.as_slice());\n+            sanity_check(&*ascend);\n         }\n     }\n }"}, {"sha": "16eeb99982e91411c9504b861be391263683c8cd", "filename": "src/test/run-pass/regions-borrow-evec-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-uniq.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -15,10 +15,10 @@ fn foo(x: &[int]) -> int {\n \n pub fn main() {\n     let p = vec!(1,2,3,4,5);\n-    let r = foo(p.as_slice());\n+    let r = foo(&p);\n     assert_eq!(r, 1);\n \n     let p = vec!(5,4,3,2,1);\n-    let r = foo(p.as_slice());\n+    let r = foo(&p);\n     assert_eq!(r, 5);\n }"}, {"sha": "bcf74729fdbfba1acf7a3b7c2f5b7c6ea0c08b82", "filename": "src/test/run-pass/regions-dependent-autoslice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -20,5 +20,5 @@ fn both<'r>(v: &'r [uint]) -> &'r [uint] {\n \n pub fn main() {\n     let v = vec!(1,2,3);\n-    both(v.as_slice());\n+    both(&v);\n }"}, {"sha": "1fdf3a92a3fdbdea5fbb4bd419e122374cd0ee9c", "filename": "src/test/run-pass/regions-infer-borrow-scope-view.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -13,7 +13,7 @@ fn view<T>(x: &[T]) -> &[T] {x}\n \n pub fn main() {\n     let v = vec!(1, 2, 3);\n-    let x = view(v.as_slice());\n-    let y = view(x.as_slice());\n+    let x = view(&v);\n+    let y = view(x);\n     assert!((v[0] == x[0]) && (v[0] == y[0]));\n }"}, {"sha": "ec033b74dd1cde1714b84dbf7b37636ed9aef1a7", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -41,7 +41,7 @@ fn start(argc: int, argv: *const *const u8) -> int {\n             ffi::c_str_to_bytes(&ptr).to_vec()\n         }).collect::<Vec<_>>()\n     };\n-    let me = args[0].as_slice();\n+    let me = &*args[0];\n \n     let x: &[u8] = &[1u8];\n     pass(Command::new(me).arg(x).output().unwrap());\n@@ -59,7 +59,7 @@ fn start(argc: int, argv: *const *const u8) -> int {\n \n fn pass(output: ProcessOutput) {\n     if !output.status.success() {\n-        println!(\"{:?}\", str::from_utf8(output.output.as_slice()));\n-        println!(\"{:?}\", str::from_utf8(output.error.as_slice()));\n+        println!(\"{:?}\", str::from_utf8(&output.output));\n+        println!(\"{:?}\", str::from_utf8(&output.error));\n     }\n }"}, {"sha": "5d6657c7e12e653e9a4bd837dfb4c47b23fb345a", "filename": "src/test/run-pass/rust-log-filter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frust-log-filter.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -48,8 +48,8 @@ pub fn main() {\n         info!(\"bar foo\");\n     });\n \n-    assert_eq!(rx.recv().unwrap().as_slice(), \"foo\");\n-    assert_eq!(rx.recv().unwrap().as_slice(), \"foo bar\");\n-    assert_eq!(rx.recv().unwrap().as_slice(), \"bar foo\");\n+    assert_eq!(rx.recv().unwrap(), \"foo\");\n+    assert_eq!(rx.recv().unwrap(), \"foo bar\");\n+    assert_eq!(rx.recv().unwrap(), \"bar foo\");\n     assert!(rx.recv().is_err());\n }"}, {"sha": "a2706dca7d3ea3d0edb036e724e9f51479cb1c84", "filename": "src/test/run-pass/segfault-no-out-of-stack.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -13,13 +13,12 @@ use std::os;\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() > 1 && args[1].as_slice() == \"segfault\" {\n+    if args.len() > 1 && args[1] == \"segfault\" {\n         unsafe { *(0 as *mut int) = 1 }; // trigger a segfault\n     } else {\n-        let segfault = Command::new(args[0].as_slice()).arg(\"segfault\").output().unwrap();\n+        let segfault = Command::new(&args[0]).arg(\"segfault\").output().unwrap();\n         assert!(!segfault.status.success());\n-        let error = String::from_utf8_lossy(segfault.error.as_slice());\n+        let error = String::from_utf8_lossy(&segfault.error);\n         assert!(!error.contains(\"has overflowed its stack\"));\n     }\n }"}, {"sha": "856eb241addc3279eb8131ffb554084ebec1c781", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -15,12 +15,12 @@ use std::old_io::process::{Command, ExitSignal, ExitStatus};\n \n pub fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() >= 2 && args[1].as_slice() == \"signal\" {\n+    let args = args;\n+    if args.len() >= 2 && args[1] == \"signal\" {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }\n     } else {\n-        let status = Command::new(args[0].as_slice()).arg(\"signal\").status().unwrap();\n+        let status = Command::new(&args[0]).arg(\"signal\").status().unwrap();\n         // Windows does not have signal, so we get exit status 0xC0000028 (STATUS_BAD_STACK).\n         match status {\n             ExitSignal(_) if cfg!(unix) => {},"}, {"sha": "de8f76518fc00c0cbdbe91f0230b2ccd8214dd91", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -26,12 +26,12 @@ fn test() {\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n-    if args.len() > 1 && args[1].as_slice() == \"test\" {\n+    let args = args;\n+    if args.len() > 1 && args[1] == \"test\" {\n         return test();\n     }\n \n-    let mut p = Command::new(args[0].as_slice())\n+    let mut p = Command::new(&args[0])\n                         .arg(\"test\").spawn().unwrap();\n     assert!(p.wait().unwrap().success());\n }"}, {"sha": "475af8f2b8ef05fa70cc1f46c6013705024ac8c6", "filename": "src/test/run-pass/small-enums-with-fields.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -20,8 +20,8 @@ macro_rules! check {\n             static S: $t = $e;\n             let v: $t = $e;\n             assert_eq!(S, v);\n-            assert_eq!(format!(\"{:?}\", v).as_slice(), $s);\n-            assert_eq!(format!(\"{:?}\", S).as_slice(), $s);\n+            assert_eq!(format!(\"{:?}\", v), $s);\n+            assert_eq!(format!(\"{:?}\", S), $s);\n         });*\n     }}\n }"}, {"sha": "1dbd29a781effb127c488a3769c1a88a39dfbc5b", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -12,7 +12,7 @@ use std::mem::swap;\n \n pub fn main() {\n     let mut a: Vec<int> = vec!(0, 1, 2, 3, 4, 5, 6);\n-    a.as_mut_slice().swap(2, 4);\n+    a.swap(2, 4);\n     assert_eq!(a[2], 4);\n     assert_eq!(a[4], 2);\n     let mut n = 42;"}, {"sha": "26772a5b22c076c140adb0244b7ff98a1e7e28d2", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -44,19 +44,19 @@ struct Goldfyshe {\n }\n \n impl Pet for Catte {\n-    fn name(&self, mut blk: Box<FnMut(&str)>) { blk(self.name.as_slice()) }\n+    fn name(&self, mut blk: Box<FnMut(&str)>) { blk(&self.name) }\n     fn num_legs(&self) -> uint { 4 }\n     fn of_good_pedigree(&self) -> bool { self.num_whiskers >= 4 }\n }\n impl Pet for Dogge {\n-    fn name(&self, mut blk: Box<FnMut(&str)>) { blk(self.name.as_slice()) }\n+    fn name(&self, mut blk: Box<FnMut(&str)>) { blk(&self.name) }\n     fn num_legs(&self) -> uint { 4 }\n     fn of_good_pedigree(&self) -> bool {\n         self.bark_decibels < 70 || self.tricks_known > 20\n     }\n }\n impl Pet for Goldfyshe {\n-    fn name(&self, mut blk: Box<FnMut(&str)>) { blk(self.name.as_slice()) }\n+    fn name(&self, mut blk: Box<FnMut(&str)>) { blk(&self.name) }\n     fn num_legs(&self) -> uint { 0 }\n     fn of_good_pedigree(&self) -> bool { self.swim_speed >= 500 }\n }"}, {"sha": "d7748f247740c2457fd6febe3ef7634d42faaf1d", "filename": "src/test/run-pass/typeck_type_placeholder_1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -23,10 +23,10 @@ static CONSTEXPR: TestStruct = TestStruct{x: &413 as *const _};\n pub fn main() {\n     let x: Vec<_> = (0u..5).collect();\n     let expected: &[uint] = &[0,1,2,3,4];\n-    assert_eq!(x.as_slice(), expected);\n+    assert_eq!(x, expected);\n \n     let x = (0u..5).collect::<Vec<_>>();\n-    assert_eq!(x.as_slice(), expected);\n+    assert_eq!(x, expected);\n \n     let y: _ = \"hello\";\n     assert_eq!(y.len(), 5);"}, {"sha": "0acf736e2ab5c5e8403c0bfd2269a57e8dfa5733", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -27,5 +27,5 @@ pub fn main() {\n     }).join();\n \n     let s = x.err().unwrap().downcast::<&'static str>().ok().unwrap();\n-    assert_eq!(s.as_slice(), \"This panic should happen.\");\n+    assert_eq!(&**s, \"This panic should happen.\");\n }"}, {"sha": "64c4c17386b3253341153b4fff7a0312105d8435", "filename": "src/test/run-pass/vec-concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-concat.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n     let a: Vec<int> = vec!(1, 2, 3, 4, 5);\n     let b: Vec<int> = vec!(6, 7, 8, 9, 0);\n     let mut v: Vec<int> = a;\n-    v.push_all(b.as_slice());\n+    v.push_all(&b);\n     println!(\"{}\", v[9]);\n     assert_eq!(v[0], 1);\n     assert_eq!(v[7], 8);"}, {"sha": "d13369b1f5258f9d29dd0a08aa6bd8daa20c5575", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -68,7 +68,7 @@ pub fn main() {\n             // work out the total number of comparisons required to sort\n             // this array...\n             let mut count = 0us;\n-            main.clone().as_mut_slice().sort_by(|a, b| { count += 1; a.cmp(b) });\n+            main.clone().sort_by(|a, b| { count += 1; a.cmp(b) });\n \n             // ... and then panic on each and every single one.\n             for panic_countdown in 0..count {\n@@ -82,7 +82,7 @@ pub fn main() {\n                 let _ = Thread::scoped(move|| {\n                     let mut v = v;\n                     let mut panic_countdown = panic_countdown;\n-                    v.as_mut_slice().sort_by(|a, b| {\n+                    v.sort_by(|a, b| {\n                         if panic_countdown == 0 {\n                             panic!()\n                         }"}, {"sha": "dcbecb859e53720eaee053499769b03c0fa66447", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189930fcae287565dcef856ae8d60a83190a4b92/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=189930fcae287565dcef856ae8d60a83190a4b92", "patch": "@@ -35,7 +35,7 @@ fn find_zombies() {\n \n     // http://pubs.opengroup.org/onlinepubs/9699919799/utilities/ps.html\n     let ps_cmd_output = Command::new(\"ps\").args(&[\"-A\", \"-o\", \"pid,ppid,args\"]).output().unwrap();\n-    let ps_output = String::from_utf8_lossy(ps_cmd_output.output.as_slice());\n+    let ps_output = String::from_utf8_lossy(&ps_cmd_output.output);\n \n     for (line_no, line) in ps_output.split('\\n').enumerate() {\n         if 0 < line_no && 0 < line.len() &&\n@@ -56,7 +56,7 @@ fn main() {\n     let too_long = format!(\"/NoSuchCommand{:0300}\", 0u8);\n \n     let _failures = (0..100).map(|_| {\n-        let cmd = Command::new(too_long.as_slice());\n+        let cmd = Command::new(&too_long);\n         let failed = cmd.spawn();\n         assert!(failed.is_err(), \"Make sure the command fails to spawn(): {:?}\", cmd);\n         failed"}]}