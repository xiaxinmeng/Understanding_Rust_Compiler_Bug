{"sha": "acd718b3785afcb5cd91b991f3d942e8cfd1df4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZDcxOGIzNzg1YWZjYjVjZDkxYjk5MWYzZDk0MmU4Y2ZkMWRmNGY=", "commit": {"author": {"name": "SiegeLord", "email": "slabode@aim.com", "date": "2014-01-17T16:10:19Z"}, "committer": {"name": "SiegeLord", "email": "slabode@aim.com", "date": "2014-01-23T01:32:40Z"}, "message": "Remove the initial and trailing blank doc-comment lines", "tree": {"sha": "209c2d2980a6ec1d3a1c3a6a84d3469fa1649196", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/209c2d2980a6ec1d3a1c3a6a84d3469fa1649196"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acd718b3785afcb5cd91b991f3d942e8cfd1df4f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acd718b3785afcb5cd91b991f3d942e8cfd1df4f", "html_url": "https://github.com/rust-lang/rust/commit/acd718b3785afcb5cd91b991f3d942e8cfd1df4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acd718b3785afcb5cd91b991f3d942e8cfd1df4f/comments", "author": {"login": "SiegeLord", "id": 480550, "node_id": "MDQ6VXNlcjQ4MDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/480550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SiegeLord", "html_url": "https://github.com/SiegeLord", "followers_url": "https://api.github.com/users/SiegeLord/followers", "following_url": "https://api.github.com/users/SiegeLord/following{/other_user}", "gists_url": "https://api.github.com/users/SiegeLord/gists{/gist_id}", "starred_url": "https://api.github.com/users/SiegeLord/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SiegeLord/subscriptions", "organizations_url": "https://api.github.com/users/SiegeLord/orgs", "repos_url": "https://api.github.com/users/SiegeLord/repos", "events_url": "https://api.github.com/users/SiegeLord/events{/privacy}", "received_events_url": "https://api.github.com/users/SiegeLord/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SiegeLord", "id": 480550, "node_id": "MDQ6VXNlcjQ4MDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/480550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SiegeLord", "html_url": "https://github.com/SiegeLord", "followers_url": "https://api.github.com/users/SiegeLord/followers", "following_url": "https://api.github.com/users/SiegeLord/following{/other_user}", "gists_url": "https://api.github.com/users/SiegeLord/gists{/gist_id}", "starred_url": "https://api.github.com/users/SiegeLord/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SiegeLord/subscriptions", "organizations_url": "https://api.github.com/users/SiegeLord/orgs", "repos_url": "https://api.github.com/users/SiegeLord/repos", "events_url": "https://api.github.com/users/SiegeLord/events{/privacy}", "received_events_url": "https://api.github.com/users/SiegeLord/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c13e0de836f76f14bd019feed9a9ed3c2cdf1dc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c13e0de836f76f14bd019feed9a9ed3c2cdf1dc6", "html_url": "https://github.com/rust-lang/rust/commit/c13e0de836f76f14bd019feed9a9ed3c2cdf1dc6"}], "stats": {"total": 80, "additions": 0, "deletions": 80}, "files": [{"sha": "0af8f155c68782102c594dc75205595293f34ff9", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/acd718b3785afcb5cd91b991f3d942e8cfd1df4f/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd718b3785afcb5cd91b991f3d942e8cfd1df4f/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=acd718b3785afcb5cd91b991f3d942e8cfd1df4f", "patch": "@@ -285,20 +285,16 @@ impl Signed for f32 {\n     #[inline]\n     fn abs(&self) -> f32 { abs(*self) }\n \n-    ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    ///\n     #[inline]\n     fn abs_sub(&self, other: &f32) -> f32 { abs_sub(*self, *other) }\n \n-    ///\n     /// # Returns\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n     /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n     /// - `NAN` if the number is NaN\n-    ///\n     #[inline]\n     fn signum(&self) -> f32 {\n         if self.is_nan() { NAN } else { copysign(1.0, *self) }\n@@ -330,14 +326,12 @@ impl Round for f32 {\n     #[inline]\n     fn trunc(&self) -> f32 { trunc(*self) }\n \n-    ///\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```rust\n     /// let x = 1.65f32;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```\n-    ///\n     #[inline]\n     fn fract(&self) -> f32 { *self - self.trunc() }\n }\n@@ -490,15 +484,13 @@ impl Real for f32 {\n     #[inline]\n     fn tanh(&self) -> f32 { tanh(*self) }\n \n-    ///\n     /// Inverse hyperbolic sine\n     ///\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic sine of `self` will be returned\n     /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n     /// - `NAN` if `self` is `NAN`\n-    ///\n     #[inline]\n     fn asinh(&self) -> f32 {\n         match *self {\n@@ -507,15 +499,13 @@ impl Real for f32 {\n         }\n     }\n \n-    ///\n     /// Inverse hyperbolic cosine\n     ///\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic cosine of `self` will be returned\n     /// - `INFINITY` if `self` is `INFINITY`\n     /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    ///\n     #[inline]\n     fn acosh(&self) -> f32 {\n         match *self {\n@@ -524,7 +514,6 @@ impl Real for f32 {\n         }\n     }\n \n-    ///\n     /// Inverse hyperbolic tangent\n     ///\n     /// # Returns\n@@ -535,7 +524,6 @@ impl Real for f32 {\n     /// - `NEG_INFINITY` if `self` is `-1.0`\n     /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `INFINITY` and `NEG_INFINITY`)\n-    ///\n     #[inline]\n     fn atanh(&self) -> f32 {\n         0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n@@ -643,38 +631,30 @@ impl Float for f32 {\n         ldexp(x, exp as c_int)\n     }\n \n-    ///\n     /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n-    ///\n     #[inline]\n     fn frexp(&self) -> (f32, int) {\n         let mut exp = 0;\n         let x = frexp(*self, &mut exp);\n         (x, exp as int)\n     }\n \n-    ///\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n-    ///\n     #[inline]\n     fn exp_m1(&self) -> f32 { exp_m1(*self) }\n \n-    ///\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n-    ///\n     #[inline]\n     fn ln_1p(&self) -> f32 { ln_1p(*self) }\n \n-    ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n-    ///\n     #[inline]\n     fn mul_add(&self, a: f32, b: f32) -> f32 {\n         mul_add(*self, a, b)\n@@ -708,82 +688,71 @@ impl Float for f32 {\n // Section: String Conversions\n //\n \n-///\n /// Converts a float to a string\n ///\n /// # Arguments\n ///\n /// * num - The float value\n-///\n #[inline]\n pub fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string in hexadecimal format\n ///\n /// # Arguments\n ///\n /// * num - The float value\n-///\n #[inline]\n pub fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string in a given radix, and a flag indicating\n /// whether it's a special value\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * radix - The base to use\n-///\n #[inline]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n \n-///\n /// Converts a float to a string with exactly the number of\n /// provided significant digits\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * digits - The number of significant digits\n-///\n #[inline]\n pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string with a maximum number of\n /// significant digits\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * digits - The number of significant digits\n-///\n #[inline]\n pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string using the exponential notation with exactly the number of\n /// provided digits after the decimal point in the significand\n ///\n@@ -792,15 +761,13 @@ pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n-///\n #[inline]\n pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n     r\n }\n \n-///\n /// Converts a float to a string using the exponential notation with the maximum number of\n /// digits after the decimal point in the significand\n ///\n@@ -809,7 +776,6 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> ~str {\n /// * num - The float value\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n-///\n #[inline]\n pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n@@ -845,7 +811,6 @@ impl num::ToStrRadix for f32 {\n     }\n }\n \n-///\n /// Convert a string in base 16 to a float.\n /// Accepts a optional binary exponent.\n ///\n@@ -871,15 +836,13 @@ impl num::ToStrRadix for f32 {\n ///\n /// `None` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n-///\n #[inline]\n pub fn from_str_hex(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n impl FromStr for f32 {\n-    ///\n     /// Convert a string in base 10 to a float.\n     /// Accepts a optional decimal exponent.\n     ///\n@@ -905,7 +868,6 @@ impl FromStr for f32 {\n     ///\n     /// `None` if the string did not represent a valid number.  Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n     #[inline]\n     fn from_str(val: &str) -> Option<f32> {\n         strconv::from_str_common(val, 10u, true, true, true,\n@@ -914,7 +876,6 @@ impl FromStr for f32 {\n }\n \n impl num::FromStrRadix for f32 {\n-    ///\n     /// Convert a string in an given base to a float.\n     ///\n     /// Due to possible conflicts, this function does **not** accept\n@@ -932,7 +893,6 @@ impl num::FromStrRadix for f32 {\n     ///\n     /// `None` if the string did not represent a valid number. Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n     #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n         strconv::from_str_common(val, rdx, true, true, false,"}, {"sha": "1155a89876e5a23ef6dcb38a9ab2d9ae14f880e1", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/acd718b3785afcb5cd91b991f3d942e8cfd1df4f/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd718b3785afcb5cd91b991f3d942e8cfd1df4f/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=acd718b3785afcb5cd91b991f3d942e8cfd1df4f", "patch": "@@ -287,20 +287,16 @@ impl Signed for f64 {\n     #[inline]\n     fn abs(&self) -> f64 { abs(*self) }\n \n-    ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    ///\n     #[inline]\n     fn abs_sub(&self, other: &f64) -> f64 { abs_sub(*self, *other) }\n \n-    ///\n     /// # Returns\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n     /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n     /// - `NAN` if the number is NaN\n-    ///\n     #[inline]\n     fn signum(&self) -> f64 {\n         if self.is_nan() { NAN } else { copysign(1.0, *self) }\n@@ -332,14 +328,12 @@ impl Round for f64 {\n     #[inline]\n     fn trunc(&self) -> f64 { trunc(*self) }\n \n-    ///\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```rust\n     /// let x = 1.65f64;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```\n-    ///\n     #[inline]\n     fn fract(&self) -> f64 { *self - self.trunc() }\n }\n@@ -492,15 +486,13 @@ impl Real for f64 {\n     #[inline]\n     fn tanh(&self) -> f64 { tanh(*self) }\n \n-    ///\n     /// Inverse hyperbolic sine\n     ///\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic sine of `self` will be returned\n     /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n     /// - `NAN` if `self` is `NAN`\n-    ///\n     #[inline]\n     fn asinh(&self) -> f64 {\n         match *self {\n@@ -509,15 +501,13 @@ impl Real for f64 {\n         }\n     }\n \n-    ///\n     /// Inverse hyperbolic cosine\n     ///\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic cosine of `self` will be returned\n     /// - `INFINITY` if `self` is `INFINITY`\n     /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    ///\n     #[inline]\n     fn acosh(&self) -> f64 {\n         match *self {\n@@ -526,7 +516,6 @@ impl Real for f64 {\n         }\n     }\n \n-    ///\n     /// Inverse hyperbolic tangent\n     ///\n     /// # Returns\n@@ -537,7 +526,6 @@ impl Real for f64 {\n     /// - `NEG_INFINITY` if `self` is `-1.0`\n     /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `INFINITY` and `NEG_INFINITY`)\n-    ///\n     #[inline]\n     fn atanh(&self) -> f64 {\n         0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n@@ -645,38 +633,30 @@ impl Float for f64 {\n         ldexp(x, exp as c_int)\n     }\n \n-    ///\n     /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n-    ///\n     #[inline]\n     fn frexp(&self) -> (f64, int) {\n         let mut exp = 0;\n         let x = frexp(*self, &mut exp);\n         (x, exp as int)\n     }\n \n-    ///\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n-    ///\n     #[inline]\n     fn exp_m1(&self) -> f64 { exp_m1(*self) }\n \n-    ///\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n-    ///\n     #[inline]\n     fn ln_1p(&self) -> f64 { ln_1p(*self) }\n \n-    ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n-    ///\n     #[inline]\n     fn mul_add(&self, a: f64, b: f64) -> f64 {\n         mul_add(*self, a, b)\n@@ -710,82 +690,71 @@ impl Float for f64 {\n // Section: String Conversions\n //\n \n-///\n /// Converts a float to a string\n ///\n /// # Arguments\n ///\n /// * num - The float value\n-///\n #[inline]\n pub fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string in hexadecimal format\n ///\n /// # Arguments\n ///\n /// * num - The float value\n-///\n #[inline]\n pub fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string in a given radix, and a flag indicating\n /// whether it's a special value\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * radix - The base to use\n-///\n #[inline]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n \n-///\n /// Converts a float to a string with exactly the number of\n /// provided significant digits\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * digits - The number of significant digits\n-///\n #[inline]\n pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string with a maximum number of\n /// significant digits\n ///\n /// # Arguments\n ///\n /// * num - The float value\n /// * digits - The number of significant digits\n-///\n #[inline]\n pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n     r\n }\n \n-///\n /// Converts a float to a string using the exponential notation with exactly the number of\n /// provided digits after the decimal point in the significand\n ///\n@@ -794,15 +763,13 @@ pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n-///\n #[inline]\n pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n     r\n }\n \n-///\n /// Converts a float to a string using the exponential notation with the maximum number of\n /// digits after the decimal point in the significand\n ///\n@@ -811,7 +778,6 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> ~str {\n /// * num - The float value\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n-///\n #[inline]\n pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n@@ -847,7 +813,6 @@ impl num::ToStrRadix for f64 {\n     }\n }\n \n-///\n /// Convert a string in base 16 to a float.\n /// Accepts a optional binary exponent.\n ///\n@@ -873,15 +838,13 @@ impl num::ToStrRadix for f64 {\n ///\n /// `None` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n-///\n #[inline]\n pub fn from_str_hex(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n impl FromStr for f64 {\n-    ///\n     /// Convert a string in base 10 to a float.\n     /// Accepts a optional decimal exponent.\n     ///\n@@ -907,7 +870,6 @@ impl FromStr for f64 {\n     ///\n     /// `none` if the string did not represent a valid number.  Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n     #[inline]\n     fn from_str(val: &str) -> Option<f64> {\n         strconv::from_str_common(val, 10u, true, true, true,\n@@ -916,7 +878,6 @@ impl FromStr for f64 {\n }\n \n impl num::FromStrRadix for f64 {\n-    ///\n     /// Convert a string in an given base to a float.\n     ///\n     /// Due to possible conflicts, this function does **not** accept\n@@ -934,7 +895,6 @@ impl num::FromStrRadix for f64 {\n     ///\n     /// `None` if the string did not represent a valid number. Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n-    ///\n     #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n         strconv::from_str_common(val, rdx, true, true, false,"}]}