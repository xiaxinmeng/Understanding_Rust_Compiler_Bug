{"sha": "baa010561e5c109341e9a1ebe8a613fcae095884", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYTAxMDU2MWU1YzEwOTM0MWU5YTFlYmU4YTYxM2ZjYWUwOTU4ODQ=", "commit": {"author": {"name": "Douglas Campos", "email": "qmx@qmx.me", "date": "2017-09-19T02:49:40Z"}, "committer": {"name": "Douglas Campos", "email": "qmx@qmx.me", "date": "2017-09-30T02:34:45Z"}, "message": "copy resolve() over to librustc", "tree": {"sha": "8cfc85e8c8a351a1bb1e15a1896b7a830555420f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cfc85e8c8a351a1bb1e15a1896b7a830555420f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baa010561e5c109341e9a1ebe8a613fcae095884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baa010561e5c109341e9a1ebe8a613fcae095884", "html_url": "https://github.com/rust-lang/rust/commit/baa010561e5c109341e9a1ebe8a613fcae095884", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baa010561e5c109341e9a1ebe8a613fcae095884/comments", "author": {"login": "qmx", "id": 66734, "node_id": "MDQ6VXNlcjY2NzM0", "avatar_url": "https://avatars.githubusercontent.com/u/66734?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qmx", "html_url": "https://github.com/qmx", "followers_url": "https://api.github.com/users/qmx/followers", "following_url": "https://api.github.com/users/qmx/following{/other_user}", "gists_url": "https://api.github.com/users/qmx/gists{/gist_id}", "starred_url": "https://api.github.com/users/qmx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qmx/subscriptions", "organizations_url": "https://api.github.com/users/qmx/orgs", "repos_url": "https://api.github.com/users/qmx/repos", "events_url": "https://api.github.com/users/qmx/events{/privacy}", "received_events_url": "https://api.github.com/users/qmx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qmx", "id": 66734, "node_id": "MDQ6VXNlcjY2NzM0", "avatar_url": "https://avatars.githubusercontent.com/u/66734?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qmx", "html_url": "https://github.com/qmx", "followers_url": "https://api.github.com/users/qmx/followers", "following_url": "https://api.github.com/users/qmx/following{/other_user}", "gists_url": "https://api.github.com/users/qmx/gists{/gist_id}", "starred_url": "https://api.github.com/users/qmx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qmx/subscriptions", "organizations_url": "https://api.github.com/users/qmx/orgs", "repos_url": "https://api.github.com/users/qmx/repos", "events_url": "https://api.github.com/users/qmx/events{/privacy}", "received_events_url": "https://api.github.com/users/qmx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "html_url": "https://github.com/rust-lang/rust/commit/b7041bfab3a83702a8026fb7a18d8ea7d54cc648"}], "stats": {"total": 191, "additions": 191, "deletions": 0}, "files": [{"sha": "b14715615f22529f53518b254b3794a78010ae85", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/baa010561e5c109341e9a1ebe8a613fcae095884/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baa010561e5c109341e9a1ebe8a613fcae095884/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=baa010561e5c109341e9a1ebe8a613fcae095884", "patch": "@@ -10,6 +10,10 @@\n \n use hir::def_id::DefId;\n use ty::{self, Ty, TypeFoldable, Substs, TyCtxt};\n+use ty::subst::{Kind, Subst};\n+use traits;\n+use syntax::abi::Abi;\n+use syntax::codemap::DUMMY_SP;\n use util::ppaux;\n \n use std::fmt;\n@@ -111,4 +115,191 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     pub fn def_id(&self) -> DefId {\n         self.def.def_id()\n     }\n+\n+    /// The point where linking happens. Resolve a (def_id, substs)\n+    /// pair to an instance.\n+    pub fn resolve(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Instance<'tcx>> {\n+        let def_id = self.def_id();\n+        debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, self.substs);\n+        let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n+            debug!(\" => associated item, attempting to find impl\");\n+            let item = tcx.associated_item(def_id);\n+            resolve_associated_item(tcx, &item, trait_def_id, self.substs)\n+        } else {\n+            let ty = tcx.type_of(def_id);\n+            let item_type = tcx.trans_apply_param_substs(self.substs, &ty);\n+\n+            let def = match item_type.sty {\n+                ty::TyFnDef(..) if {\n+                    let f = item_type.fn_sig(tcx);\n+                    f.abi() == Abi::RustIntrinsic ||\n+                        f.abi() == Abi::PlatformIntrinsic\n+                } =>\n+                {\n+                    debug!(\" => intrinsic\");\n+                    ty::InstanceDef::Intrinsic(def_id)\n+                }\n+                _ => {\n+                    if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n+                        let ty = self.substs.type_at(0);\n+                        if ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All)) {\n+                            debug!(\" => nontrivial drop glue\");\n+                            ty::InstanceDef::DropGlue(def_id, Some(ty))\n+                        } else {\n+                            debug!(\" => trivial drop glue\");\n+                            ty::InstanceDef::DropGlue(def_id, None)\n+                        }\n+                    } else {\n+                        debug!(\" => free item\");\n+                        ty::InstanceDef::Item(def_id)\n+                    }\n+                }\n+            };\n+            Some(Instance { \n+                def: def,\n+                substs: self.substs \n+            })\n+        };\n+        debug!(\"resolve(def_id={:?}, substs={:?}) = {:?}\", def_id, self.substs, result);\n+        result\n+    }\n+\n+\n+}\n+\n+fn resolve_closure<'a, 'tcx>(\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   def_id: DefId,\n+                   substs: ty::ClosureSubsts<'tcx>,\n+                   requested_kind: ty::ClosureKind)\n+-> Instance<'tcx>\n+{\n+    let actual_kind = tcx.closure_kind(def_id);\n+\n+    match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n+        Ok(true) => fn_once_adapter_instance(tcx, def_id, substs),\n+        _ => Instance::new(def_id, substs.substs)\n+    }\n+}\n+\n+fn resolve_associated_item<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_item: &ty::AssociatedItem,\n+    trait_id: DefId,\n+    rcvr_substs: &'tcx Substs<'tcx>\n+    ) -> Option<Instance<'tcx>> {\n+    let def_id = trait_item.def_id;\n+    debug!(\"resolve_associated_item(trait_item={:?}, \\\n+                                    trait_id={:?}, \\\n+           rcvr_substs={:?})\",\n+           def_id, trait_id, rcvr_substs);\n+\n+    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n+    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, ty::Binder(trait_ref));\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        traits::VtableImpl(impl_data) => {\n+            let (def_id, substs) = traits::find_associated_item(\n+                tcx, trait_item, rcvr_substs, &impl_data);\n+            let substs = tcx.erase_regions(&substs);\n+            Some(ty::Instance::new(def_id, substs))\n+        }\n+        traits::VtableGenerator(closure_data) => {\n+            Some(Instance {\n+                def: ty::InstanceDef::Item(closure_data.closure_def_id),\n+                substs: closure_data.substs.substs\n+            })\n+        }\n+        traits::VtableClosure(closure_data) => {\n+            let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n+            Some(resolve_closure(tcx, closure_data.closure_def_id, closure_data.substs,\n+                                 trait_closure_kind))\n+        }\n+        traits::VtableFnPointer(ref data) => {\n+            Some(Instance {\n+                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                substs: rcvr_substs\n+            })\n+        }\n+        traits::VtableObject(ref data) => {\n+            let index = tcx.get_vtable_index_of_object_method(data, def_id);\n+            Some(Instance {\n+                def: ty::InstanceDef::Virtual(def_id, index),\n+                substs: rcvr_substs\n+            })\n+        }\n+        traits::VtableBuiltin(..) if Some(trait_id) == tcx.lang_items().clone_trait() => {\n+            Some(Instance {\n+                def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n+                substs: rcvr_substs\n+            })\n+        }\n+        _ => {\n+            None\n+        }\n+    }\n+}\n+\n+fn needs_fn_once_adapter_shim<'a, 'tcx>(actual_closure_kind: ty::ClosureKind,\n+                              trait_closure_kind: ty::ClosureKind)\n+    -> Result<bool, ()>\n+{\n+    match (actual_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+            (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+            (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+                // No adapter needed.\n+                Ok(false)\n+            }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+            (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+                // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+                // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+                // this by doing something like:\n+                //\n+                //     fn call_once(self, ...) { call_mut(&self, ...) }\n+                //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+                //\n+                // These are both the same at trans time.\n+                Ok(true)\n+            }\n+        _ => Err(()),\n+    }\n+}\n+\n+fn fn_once_adapter_instance<'a, 'tcx>(\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            closure_did: DefId,\n+                            substs: ty::ClosureSubsts<'tcx>,\n+                            ) -> Instance<'tcx> {\n+    debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n+    closure_did,\n+    substs);\n+    let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n+    let call_once = tcx.associated_items(fn_once)\n+        .find(|it| it.kind == ty::AssociatedKind::Method)\n+        .unwrap().def_id;\n+    let def = ty::InstanceDef::ClosureOnceShim { call_once };\n+\n+    let self_ty = tcx.mk_closure_from_closure_substs(\n+        closure_did, substs);\n+\n+    let sig = tcx.fn_sig(closure_did).subst(tcx, substs.substs);\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    assert_eq!(sig.inputs().len(), 1);\n+    let substs = tcx.mk_substs([\n+                               Kind::from(self_ty),\n+                               Kind::from(sig.inputs()[0]),\n+    ].iter().cloned());\n+\n+    debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n+    Instance { def, substs }\n }"}]}