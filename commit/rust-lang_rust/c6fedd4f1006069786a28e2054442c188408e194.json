{"sha": "c6fedd4f1006069786a28e2054442c188408e194", "node_id": "C_kwDOAAsO6NoAKGM2ZmVkZDRmMTAwNjA2OTc4NmEyOGUyMDU0NDQyYzE4ODQwOGUxOTQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-31T02:50:30Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-31T03:40:43Z"}, "message": "Make `MatcherPos` not derive `Clone`.\n\nIt's only used in one place, and there we clone and then make a bunch of\nmodifications. It's clearer if we duplicate more explicitly, and there's\na symmetry now between `sequence()` and `empty_sequence()`.", "tree": {"sha": "174686e7f1138783bfdccc7da00060f352bf1bba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/174686e7f1138783bfdccc7da00060f352bf1bba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6fedd4f1006069786a28e2054442c188408e194", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fedd4f1006069786a28e2054442c188408e194", "html_url": "https://github.com/rust-lang/rust/commit/c6fedd4f1006069786a28e2054442c188408e194", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6fedd4f1006069786a28e2054442c188408e194/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f68a0449ed4e49705e2ee70be6e5678aa426b206", "url": "https://api.github.com/repos/rust-lang/rust/commits/f68a0449ed4e49705e2ee70be6e5678aa426b206", "html_url": "https://github.com/rust-lang/rust/commit/f68a0449ed4e49705e2ee70be6e5678aa426b206"}], "stats": {"total": 32, "additions": 24, "deletions": 8}, "files": [{"sha": "618a213055e20452ef2dca50a0d69131692e183a", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c6fedd4f1006069786a28e2054442c188408e194/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6fedd4f1006069786a28e2054442c188408e194/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=c6fedd4f1006069786a28e2054442c188408e194", "patch": "@@ -132,7 +132,6 @@ struct Parent<'tt> {\n ///                            <-------------->   first submatcher; three tts, zero metavars\n ///                  <--------------------------> top-level matcher; two tts, one metavar\n /// ```\n-#[derive(Clone)]\n struct MatcherPos<'tt> {\n     /// The tokens that make up the current matcher. When we are within a `Sequence` or `Delimited`\n     /// submatcher, this is just the contents of that submatcher.\n@@ -177,6 +176,25 @@ impl<'tt> MatcherPos<'tt> {\n         }\n     }\n \n+    fn empty_sequence(\n+        parent_mp: &MatcherPos<'tt>,\n+        seq: &'tt SequenceRepetition,\n+        empty_matches: Lrc<NamedMatchVec>,\n+    ) -> Self {\n+        let mut mp = MatcherPos {\n+            tts: parent_mp.tts,\n+            idx: parent_mp.idx + 1,\n+            matches: parent_mp.matches.clone(), // a cheap clone\n+            seq_depth: parent_mp.seq_depth,\n+            match_cur: parent_mp.match_cur + seq.num_captures,\n+            kind: parent_mp.kind.clone(), // an expensive clone\n+        };\n+        for idx in parent_mp.match_cur..parent_mp.match_cur + seq.num_captures {\n+            mp.push_match(idx, MatchedSeq(empty_matches.clone()));\n+        }\n+        mp\n+    }\n+\n     fn sequence(\n         parent_mp: Box<MatcherPos<'tt>>,\n         seq: &'tt SequenceRepetition,\n@@ -468,13 +486,11 @@ impl<'tt> TtParser<'tt> {\n                         let op = seq.kleene.op;\n                         if op == mbe::KleeneOp::ZeroOrMore || op == mbe::KleeneOp::ZeroOrOne {\n                             // Allow for the possibility of zero matches of this sequence.\n-                            let mut new_mp = mp.clone();\n-                            new_mp.match_cur += seq.num_captures;\n-                            new_mp.idx += 1;\n-                            for idx in mp.match_cur..mp.match_cur + seq.num_captures {\n-                                new_mp.push_match(idx, MatchedSeq(self.empty_matches.clone()));\n-                            }\n-                            self.cur_mps.push(new_mp);\n+                            self.cur_mps.push(box MatcherPos::empty_sequence(\n+                                &*mp,\n+                                &seq,\n+                                self.empty_matches.clone(),\n+                            ));\n                         }\n \n                         // Allow for the possibility of one or more matches of this sequence."}]}