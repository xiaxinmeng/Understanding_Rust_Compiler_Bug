{"sha": "2a72099063b21abc84145960a14224458b6dc37c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNzIwOTkwNjNiMjFhYmM4NDE0NTk2MGExNDIyNDQ1OGI2ZGMzN2M=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-07T23:37:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-08T14:54:20Z"}, "message": "rustc: Remove uses of DVec", "tree": {"sha": "ae60325507c0bf1280698dc8fa87f71f87884796", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae60325507c0bf1280698dc8fa87f71f87884796"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a72099063b21abc84145960a14224458b6dc37c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a72099063b21abc84145960a14224458b6dc37c", "html_url": "https://github.com/rust-lang/rust/commit/2a72099063b21abc84145960a14224458b6dc37c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a72099063b21abc84145960a14224458b6dc37c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87f864292def92dc8e2fe4782c4e8cce0db0fb0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/87f864292def92dc8e2fe4782c4e8cce0db0fb0a", "html_url": "https://github.com/rust-lang/rust/commit/87f864292def92dc8e2fe4782c4e8cce0db0fb0a"}], "stats": {"total": 397, "additions": 191, "deletions": 206}, "files": [{"sha": "00cb977b50c8332e8dd62f709ac25394fbf959e9", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -19,7 +19,6 @@ use metadata::decoder;\n use metadata;\n use middle::{ty, resolve};\n \n-use core::dvec::DVec;\n use core::vec;\n use reader = std::ebml::reader;\n use syntax::ast;\n@@ -136,7 +135,7 @@ pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n \n pub fn get_method_names_if_trait(cstore: @mut cstore::CStore,\n                                  def: ast::def_id)\n-                              -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n+                              -> Option<~[(ast::ident, ast::self_ty_)]> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_method_names_if_trait(cstore.intr, cdata, def.node);\n }"}, {"sha": "4fe708d1020cd8b0a7aea70c44885bdbbe40ec80", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -22,8 +22,6 @@ use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id, parse_bounds_data};\n use middle::{ty, resolve};\n \n-use core::dvec;\n-use core::dvec::DVec;\n use core::hash::{Hash, HashUtil};\n use core::int;\n use core::io::WriterUtil;\n@@ -766,27 +764,27 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n /// Returns the supertraits of the given trait.\n pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n                     -> ~[ty::t] {\n-    let results = dvec::DVec();\n+    let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n     for reader::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n         results.push(doc_type(trait_doc, tcx, cdata));\n     }\n-    return dvec::unwrap(results);\n+    return results;\n }\n \n // If the item in question is a trait, returns its set of methods and\n // their self types. Otherwise, returns none. This overlaps in an\n // annoying way with get_trait_methods.\n pub fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n                                  node_id: ast::node_id)\n-                              -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n+                              -> Option<~[(ast::ident, ast::self_ty_)]> {\n \n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Trait {\n         return None;\n     }\n \n-    let resulting_methods = @DVec();\n+    let mut resulting_methods = ~[];\n     for reader::tagged_docs(item, tag_item_trait_method) |method| {\n         resulting_methods.push(\n             (item_name(intr, method), get_self_ty(method)));\n@@ -823,12 +821,12 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n         return None;\n     }\n \n-    let impl_method_ids = DVec();\n+    let mut impl_method_ids = ~[];\n     for reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n         impl_method_ids.push(parse_def_id(reader::doc_data(impl_method_doc)));\n     }\n \n-    let static_impl_methods = DVec();\n+    let mut static_impl_methods = ~[];\n     for impl_method_ids.each |impl_method_id| {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data);\n         let family = item_family(impl_method_doc);\n@@ -852,7 +850,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n         }\n     }\n \n-    return Some(dvec::unwrap(static_impl_methods));\n+    return Some(static_impl_methods);\n }\n \n pub fn get_item_attrs(cdata: cmd,"}, {"sha": "414aa035b549743318307de3a4f8dafd2adb5d8a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -22,7 +22,6 @@ use middle::ty;\n use middle;\n use util::ppaux::ty_to_str;\n \n-use core::dvec;\n use core::flate;\n use core::hash::{Hash, HashUtil};\n use core::int;\n@@ -857,7 +856,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         }\n       }\n       item_trait(ref generics, ref traits, ref ms) => {\n-        let provided_methods = dvec::DVec();\n+        let mut provided_methods = ~[];\n \n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n@@ -1366,13 +1365,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     if (parms.tcx.sess.meta_stats()) {\n \n-        do wr.bytes.borrow |v| {\n-            do v.each |e| {\n-                if *e == 0 {\n-                    ecx.stats.zero_bytes += 1;\n-                }\n-                true\n+        do wr.bytes.each |e| {\n+            if *e == 0 {\n+                ecx.stats.zero_bytes += 1;\n             }\n+            true\n         }\n \n         io::println(\"metadata stats:\");\n@@ -1401,7 +1398,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n         vec::slice(*bytes, 0, 8).to_vec()\n-    }) + flate::deflate_bytes(wr.bytes.check_out(|buf| buf))\n+    }) + flate::deflate_bytes(wr.bytes)\n }\n \n // Get the encoded string for a type"}, {"sha": "1be8112fc807e03c7cc09bd017e2d97a0a4cfe21", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -25,7 +25,7 @@ use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n \n-use core::{dvec, io, option, vec};\n+use core::{io, option, vec};\n use std::ebml::reader;\n use std::ebml;\n use std::serialize;\n@@ -912,11 +912,11 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    for maps.last_use_map.find(&id).each |m| {\n+    for maps.last_use_map.find(&id).each |&m| {\n         do ebml_w.tag(c::tag_table_last_use) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec((*m).get()) |id| {\n+                do ebml_w.emit_from_vec(/*bad*/ copy *m) |id| {\n                     id.encode(&ebml_w);\n                 }\n             }\n@@ -1131,8 +1131,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 let ids = val_dsr.read_to_vec(|| {\n                     xcx.tr_id(val_dsr.read_int())\n                 });\n-                let dvec = @dvec::from_vec(ids);\n-                dcx.maps.last_use_map.insert(id, dvec);\n+                dcx.maps.last_use_map.insert(id, @mut ids);\n             } else if tag == (c::tag_table_method_map as uint) {\n                 dcx.maps.method_map.insert(\n                     id,"}, {"sha": "94c266ab44fcb296c8e2056f270e500feed36ebb", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -32,7 +32,6 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{expr_repr, region_to_str};\n \n-use core::dvec;\n use core::hashmap::linear::LinearSet;\n use core::vec;\n use std::oldmap::HashMap;\n@@ -575,9 +574,8 @@ pub impl GatherLoanCtxt {\n                 req_loans.push_all(loans);\n             }\n             None => {\n-                let dvec = @dvec::from_vec(loans);\n                 let req_loan_map = self.req_maps.req_loan_map;\n-                req_loan_map.insert(scope_id, dvec);\n+                req_loan_map.insert(scope_id, @mut loans);\n             }\n         }\n     }"}, {"sha": "5462ec87014e262e98b90573c5266535c94771de", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -234,7 +234,6 @@ use middle::moves;\n use util::common::{indenter, stmt_set};\n use util::ppaux::note_and_explain_region;\n \n-use core::dvec::DVec;\n use core::io;\n use core::result::{Result, Ok, Err};\n use core::to_bytes;\n@@ -406,7 +405,7 @@ pub struct Loan {\n /// - `pure_map`: map from block/expr that must be pure to the error message\n ///   that should be reported if they are not pure\n pub struct ReqMaps {\n-    req_loan_map: HashMap<ast::node_id, @DVec<Loan>>,\n+    req_loan_map: HashMap<ast::node_id, @mut ~[Loan]>,\n     pure_map: HashMap<ast::node_id, bckerr>\n }\n "}, {"sha": "f0c06ceca989c410caa527f898f2d28d64c7d52f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -112,7 +112,6 @@ use middle::moves;\n use util::ppaux::ty_to_str;\n \n use core::cmp;\n-use core::dvec::DVec;\n use core::io::WriterUtil;\n use core::io;\n use core::ptr;\n@@ -136,7 +135,7 @@ use syntax::{visit, ast_util};\n //\n // Very subtle (#2633): borrowck will remove entries from this table\n // if it detects an outstanding loan (that is, the addr is taken).\n-pub type last_use_map = HashMap<node_id, @DVec<node_id>>;\n+pub type last_use_map = HashMap<node_id, @mut ~[node_id]>;\n \n enum Variable = uint;\n enum LiveNode = uint;\n@@ -419,13 +418,13 @@ pub impl IrMaps {\n             let v = match self.last_use_map.find(&expr_id) {\n               Some(v) => v,\n               None => {\n-                let v = @DVec();\n+                let v = @mut ~[];\n                 self.last_use_map.insert(expr_id, v);\n                 v\n               }\n             };\n \n-            (*v).push(id);\n+            v.push(id);\n           }\n           Arg(_, _, by_ref) |\n           Arg(_, _, by_val) | ImplicitRet => {\n@@ -667,7 +666,7 @@ struct Liveness {\n     users: @mut ~[Users],\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n-    loop_scope: DVec<node_id>,\n+    loop_scope: @mut ~[node_id],\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n@@ -683,7 +682,7 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n         successors: @mut vec::from_elem(ir.num_live_nodes, invalid_node()),\n         users: @mut vec::from_elem(ir.num_live_nodes * ir.num_vars,\n                                    invalid_users()),\n-        loop_scope: DVec(),\n+        loop_scope: @mut ~[],\n         break_ln: HashMap(),\n         cont_ln: HashMap()\n     }\n@@ -856,11 +855,16 @@ pub impl Liveness {\n                     self.tcx.sess.span_bug(sp, ~\"break outside loop\");\n                 }\n                 else {\n-                    self.loop_scope.last()\n+                    // FIXME(#5275): this shouldn't have to be a method...\n+                    self.last_loop_scope()\n                 }\n         }\n     }\n \n+    fn last_loop_scope(&self) -> node_id {\n+        *self.loop_scope.last()\n+    }\n+\n     fn ln_str(&self, ln: LiveNode) -> ~str {\n         do io::with_str_writer |wr| {\n             wr.write_str(~\"[ln(\");"}, {"sha": "3e3b1eb207109e851e5f48a45348a98a9c7511e5", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -21,7 +21,6 @@ use middle::typeck::{method_map, method_origin, method_param, method_self};\n use middle::typeck::{method_super};\n use middle::typeck::{method_static, method_trait};\n \n-use core::dvec::DVec;\n use core::util::ignore;\n use syntax::ast::{def_variant, expr_field, expr_method_call, expr_struct};\n use syntax::ast::{expr_unary, ident, item_struct, item_enum, item_impl};\n@@ -38,7 +37,7 @@ use syntax::visit;\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: &method_map,\n                    crate: @ast::crate) {\n-    let privileged_items = @DVec();\n+    let privileged_items = @mut ~[];\n \n     // Adds structs that are privileged to this scope.\n     let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {"}, {"sha": "12c08ffb435851a543dceaf060467d87235eee71", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -26,7 +26,6 @@ use middle::ty::{region_variance, rv_covariant, rv_invariant};\n use middle::ty::{rv_contravariant};\n use middle::ty;\n \n-use core::dvec::DVec;\n use core::vec;\n use std::oldmap::HashMap;\n use syntax::ast_map;\n@@ -395,7 +394,7 @@ pub struct region_dep {\n     id: ast::node_id\n }\n \n-pub type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n+pub type dep_map = HashMap<ast::node_id, @mut ~[region_dep]>;\n \n pub struct DetermineRpCtxt {\n     sess: Session,\n@@ -498,7 +497,7 @@ pub impl DetermineRpCtxt {\n         let vec = match self.dep_map.find(&from) {\n             Some(vec) => vec,\n             None => {\n-                let vec = @DVec();\n+                let vec = @mut ~[];\n                 let dep_map = self.dep_map;\n                 dep_map.insert(from, vec);\n                 vec"}, {"sha": "391990eed95de92d66bf61ec966b55ff9bf2c1fc", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 103, "deletions": 98, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -75,7 +75,6 @@ use syntax::visit::{visit_foreign_item, visit_item, visit_method_helper};\n use syntax::visit::{visit_mod, visit_ty, vt};\n use syntax::opt_vec::OptVec;\n \n-use core::dvec::DVec;\n use core::option::{Some, get, is_some, is_none};\n use core::str::{connect, split_str};\n use std::oldmap::HashMap;\n@@ -110,7 +109,7 @@ pub struct Impl {\n }\n \n // Trait method resolution\n-pub type TraitMap = @HashMap<node_id,@DVec<def_id>>;\n+pub type TraitMap = @HashMap<node_id,@mut ~[def_id]>;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n@@ -350,13 +349,13 @@ pub fn Rib(kind: RibKind) -> Rib {\n /// One import directive.\n pub struct ImportDirective {\n     privacy: Privacy,\n-    module_path: @DVec<ident>,\n+    module_path: ~[ident],\n     subclass: @ImportDirectiveSubclass,\n     span: span,\n }\n \n pub fn ImportDirective(privacy: Privacy,\n-                       module_path: @DVec<ident>,\n+                       +module_path: ~[ident],\n                        subclass: @ImportDirectiveSubclass,\n                        span: span)\n                     -> ImportDirective {\n@@ -458,7 +457,7 @@ pub struct Module {\n     kind: ModuleKind,\n \n     children: @HashMap<ident,@mut NameBindings>,\n-    imports: @DVec<@ImportDirective>,\n+    imports: ~[@ImportDirective],\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -496,7 +495,7 @@ pub fn Module(parent_link: ParentLink,\n         def_id: def_id,\n         kind: kind,\n         children: @HashMap(),\n-        imports: @DVec(),\n+        imports: ~[],\n         anonymous_children: @HashMap(),\n         import_resolutions: @HashMap(),\n         glob_count: 0,\n@@ -781,9 +780,9 @@ pub fn Resolver(session: Session,\n         unresolved_imports: 0,\n \n         current_module: current_module,\n-        value_ribs: @DVec(),\n-        type_ribs: @DVec(),\n-        label_ribs: @DVec(),\n+        value_ribs: ~[],\n+        type_ribs: ~[],\n+        label_ribs: ~[],\n \n         xray_context: NoXray,\n         current_trait_refs: None,\n@@ -830,20 +829,20 @@ pub struct Resolver {\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: @DVec<@Rib>,\n+    value_ribs: ~[@Rib],\n \n     // The current set of local scopes, for types.\n-    type_ribs: @DVec<@Rib>,\n+    type_ribs: ~[@Rib],\n \n     // The current set of local scopes, for labels.\n-    label_ribs: @DVec<@Rib>,\n+    label_ribs: ~[@Rib],\n \n     // Whether the current context is an X-ray context. An X-ray context is\n     // allowed to access private names of any module.\n     xray_context: XrayFlag,\n \n     // The trait that the current context can refer to.\n-    current_trait_refs: Option<@DVec<def_id>>,\n+    current_trait_refs: Option<~[def_id]>,\n \n     // The ident for the keyword \"self\".\n     self_ident: ident,\n@@ -1407,23 +1406,23 @@ pub impl Resolver {\n                     // globs and lists, the path is found directly in the AST;\n                     // for simple paths we have to munge the path a little.\n \n-                    let module_path = @DVec();\n+                    let mut module_path = ~[];\n                     match view_path.node {\n                         view_path_simple(_, full_path, _, _) => {\n                             let path_len = full_path.idents.len();\n                             fail_unless!(path_len != 0);\n \n                             for full_path.idents.eachi |i, ident| {\n                                 if i != path_len - 1 {\n-                                    (*module_path).push(*ident);\n+                                    module_path.push(*ident);\n                                 }\n                             }\n                         }\n \n                         view_path_glob(module_ident_path, _) |\n                         view_path_list(module_ident_path, _, _) => {\n                             for module_ident_path.idents.each |ident| {\n-                                (*module_path).push(*ident);\n+                                module_path.push(*ident);\n                             }\n                         }\n                     }\n@@ -1457,7 +1456,7 @@ pub impl Resolver {\n                                                              AnyNS);\n                                 self.build_import_directive(privacy,\n                                                             module_,\n-                                                            module_path,\n+                                                            copy module_path,\n                                                             subclass,\n                                                             view_path.span,\n                                                             state);\n@@ -1857,7 +1856,7 @@ pub impl Resolver {\n     fn build_import_directive(@mut self,\n                               privacy: Privacy,\n                               module_: @mut Module,\n-                              module_path: @DVec<ident>,\n+                              +module_path: ~[ident],\n                               subclass: @ImportDirectiveSubclass,\n                               span: span,\n                               state: @mut ImportState) {\n@@ -1873,7 +1872,7 @@ pub impl Resolver {\n                 debug!(\"(building import directive) building import \\\n                         directive: privacy %? %s::%s\",\n                        privacy,\n-                       self.idents_to_str(module_path.get()),\n+                       self.idents_to_str(directive.module_path),\n                        *self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target) {\n@@ -1887,7 +1886,7 @@ pub impl Resolver {\n                         let resolution = @mut ImportResolution(privacy,\n                                                                span,\n                                                                state);\n-                        let name = self.idents_to_str(module_path.get());\n+                        let name = self.idents_to_str(directive.module_path);\n                         // Don't warn about unused intrinsics because they're\n                         // automatically appended to all files\n                         if name == ~\"intrinsic::rusti\" {\n@@ -1982,13 +1981,13 @@ pub impl Resolver {\n         let import_count = module.imports.len();\n         while module.resolved_import_count < import_count {\n             let import_index = module.resolved_import_count;\n-            let import_directive = module.imports.get_elt(import_index);\n+            let import_directive = module.imports[import_index];\n             match self.resolve_import_for_module(module, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n-                    let idents = import_directive.module_path.get();\n                     let msg = fmt!(\"failed to resolve import: %s\",\n-                                   *self.import_path_to_str(idents,\n+                                   *self.import_path_to_str(\n+                                       import_directive.module_path,\n                                        *import_directive.subclass));\n                     self.session.span_err(import_directive.span, msg);\n                 }\n@@ -2005,7 +2004,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn idents_to_str(@mut self, idents: ~[ident]) -> ~str {\n+    fn idents_to_str(@mut self, idents: &[ident]) -> ~str {\n         let ident_strs = do idents.map |ident| {\n             /*bad*/ copy *self.session.str_of(*ident)\n         };\n@@ -2043,11 +2042,11 @@ pub impl Resolver {\n                                  import_directive: @ImportDirective)\n                               -> ResolveResult<()> {\n         let mut resolution_result = Failed;\n-        let module_path = import_directive.module_path;\n+        let module_path = &import_directive.module_path;\n \n         debug!(\"(resolving import for module) resolving import `%s::...` in \\\n                 `%s`\",\n-               self.idents_to_str(module_path.get()),\n+               self.idents_to_str(*module_path),\n                self.module_to_str(module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -2056,7 +2055,7 @@ pub impl Resolver {\n             Some(self.graph_root.get_module())\n         } else {\n             match self.resolve_module_path_for_import(module_,\n-                                                      module_path,\n+                                                      *module_path,\n                                                       DontUseLexicalScope,\n                                                       import_directive.span) {\n \n@@ -2574,21 +2573,21 @@ pub impl Resolver {\n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(@mut self,\n                                      module_: @mut Module,\n-                                     module_path: @DVec<ident>,\n+                                     module_path: ~[ident],\n                                      index: uint,\n                                      span: span,\n                                      mut name_search_type: NameSearchType)\n                                   -> ResolveResult<@mut Module> {\n         let mut search_module = module_;\n         let mut index = index;\n-        let module_path_len = (*module_path).len();\n+        let module_path_len = module_path.len();\n \n         // Resolve the module part of the path. This does not involve looking\n         // upward though scope chains; we simply resolve names directly in\n         // modules as we go.\n \n         while index < module_path_len {\n-            let name = (*module_path).get_elt(index);\n+            let name = module_path[index];\n             match self.resolve_name_in_module(search_module,\n                                               name,\n                                               TypeNS,\n@@ -2659,7 +2658,7 @@ pub impl Resolver {\n     /// rooted at the given module.\n     fn resolve_module_path_for_import(@mut self,\n                                       module_: @mut Module,\n-                                      module_path: @DVec<ident>,\n+                                      module_path: ~[ident],\n                                       use_lexical_scope: UseLexicalScopeFlag,\n                                       span: span)\n                                    -> ResolveResult<@mut Module> {\n@@ -2668,7 +2667,7 @@ pub impl Resolver {\n \n         debug!(\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n-               self.idents_to_str((*module_path).get()),\n+               self.idents_to_str(module_path),\n                self.module_to_str(module_));\n \n         // Resolve the module prefix, if any.\n@@ -2704,7 +2703,7 @@ pub impl Resolver {\n                         // scope and then proceed to resolve below that.\n                         let result = self.resolve_module_in_lexical_scope(\n                             module_,\n-                            module_path.get_elt(0));\n+                            module_path[0]);\n                         match result {\n                             Failed => {\n                                 self.session.span_err(span,\n@@ -2945,19 +2944,19 @@ pub impl Resolver {\n      */\n     fn resolve_module_prefix(@mut self,\n                              module_: @mut Module,\n-                             module_path: @DVec<ident>)\n+                             module_path: ~[ident])\n                           -> ResolveResult<ModulePrefixResult> {\n         let interner = self.session.parse_sess.interner;\n \n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n         let mut containing_module;\n         let mut i;\n-        if *interner.get(module_path.get_elt(0)) == ~\"self\" {\n+        if *interner.get(module_path[0]) == ~\"self\" {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 1;\n-        } else if *interner.get(module_path.get_elt(0)) == ~\"super\" {\n+        } else if *interner.get(module_path[0]) == ~\"super\" {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 0;  // We'll handle `super` below.\n@@ -2967,7 +2966,7 @@ pub impl Resolver {\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() &&\n-                *interner.get(module_path.get_elt(i)) == ~\"super\" {\n+                *interner.get(module_path[i]) == ~\"super\" {\n             debug!(\"(resolving module prefix) resolving `super` at %s\",\n                    self.module_to_str(containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n@@ -3064,7 +3063,7 @@ pub impl Resolver {\n         let index = module_.resolved_import_count;\n         let import_count = module_.imports.len();\n         if index != import_count {\n-            self.session.span_err(module_.imports.get_elt(index).span,\n+            self.session.span_err(module_.imports[index].span,\n                                   ~\"unresolved import\");\n         }\n \n@@ -3283,7 +3282,7 @@ pub impl Resolver {\n     // wrappers.\n \n     fn upvarify(@mut self,\n-                ribs: @DVec<@Rib>,\n+                ribs: &mut ~[@Rib],\n                 rib_index: uint,\n                 def_like: def_like,\n                 span: span,\n@@ -3313,9 +3312,8 @@ pub impl Resolver {\n         }\n \n         let mut rib_index = rib_index + 1;\n-        while rib_index < (*ribs).len() {\n-            let rib = (*ribs).get_elt(rib_index);\n-            match rib.kind {\n+        while rib_index < ribs.len() {\n+            match ribs[rib_index].kind {\n                 NormalRibKind => {\n                     // Nothing to do. Continue.\n                 }\n@@ -3393,22 +3391,21 @@ pub impl Resolver {\n     }\n \n     fn search_ribs(@mut self,\n-                   ribs: @DVec<@Rib>,\n+                   ribs: &mut ~[@Rib],\n                    name: ident,\n                    span: span,\n                    allow_capturing_self: AllowCapturingSelfFlag)\n                 -> Option<def_like> {\n         // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n-        let mut i = (*ribs).len();\n+        let mut i = ribs.len();\n         while i != 0 {\n             i -= 1;\n-            let rib = (*ribs).get_elt(i);\n-            match rib.bindings.find(&name) {\n+            match ribs[i].bindings.find(&name) {\n                 Some(def_like) => {\n                     return self.upvarify(ribs, i, def_like, span,\n-                                      allow_capturing_self);\n+                                         allow_capturing_self);\n                 }\n                 None => {\n                     // Continue.\n@@ -3502,7 +3499,7 @@ pub impl Resolver {\n             item_trait(ref generics, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib(NormalRibKind);\n-                (*self.type_ribs).push(self_type_rib);\n+                self.type_ribs.push(self_type_rib);\n                 self_type_rib.bindings.insert(self.type_self_ident,\n                                               dl_def(def_self_ty(item.id)));\n \n@@ -3573,7 +3570,7 @@ pub impl Resolver {\n                     }\n                 }\n \n-                (*self.type_ribs).pop();\n+                self.type_ribs.pop();\n             }\n \n             item_struct(struct_def, ref generics) => {\n@@ -3706,15 +3703,15 @@ pub impl Resolver {\n     }\n \n     fn with_label_rib(@mut self, f: fn()) {\n-        (*self.label_ribs).push(@Rib(NormalRibKind));\n+        self.label_ribs.push(@Rib(NormalRibKind));\n         f();\n-        (*self.label_ribs).pop();\n+        self.label_ribs.pop();\n     }\n \n     fn with_constant_rib(@mut self, f: fn()) {\n-        (*self.value_ribs).push(@Rib(ConstantItemRibKind));\n+        self.value_ribs.push(@Rib(ConstantItemRibKind));\n         f();\n-        (*self.value_ribs).pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_function(@mut self,\n@@ -3726,11 +3723,11 @@ pub impl Resolver {\n                         visitor: ResolveVisitor) {\n         // Create a value rib for the function.\n         let function_value_rib = @Rib(rib_kind);\n-        (*self.value_ribs).push(function_value_rib);\n+        self.value_ribs.push(function_value_rib);\n \n         // Create a label rib for the function.\n         let function_label_rib = @Rib(rib_kind);\n-        (*self.label_ribs).push(function_label_rib);\n+        self.label_ribs.push(function_label_rib);\n \n         // If this function has type parameters, add them now.\n         do self.with_type_parameter_rib(type_parameters) {\n@@ -3790,8 +3787,8 @@ pub impl Resolver {\n             debug!(\"(resolving function) leaving function\");\n         }\n \n-        (*self.label_ribs).pop();\n-        (*self.value_ribs).pop();\n+        self.label_ribs.pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_type_parameters(@mut self,\n@@ -3891,10 +3888,10 @@ pub impl Resolver {\n                                          visitor);\n \n             // Resolve the trait reference, if necessary.\n-            let original_trait_refs = self.current_trait_refs;\n+            let original_trait_refs;\n             match opt_trait_reference {\n                 Some(trait_reference) => {\n-                    let new_trait_refs = @DVec();\n+                    let mut new_trait_refs = ~[];\n                     match self.resolve_path(\n                         trait_reference.path, TypeNS, true, visitor) {\n                         None => {\n@@ -3906,13 +3903,17 @@ pub impl Resolver {\n                             self.record_def(trait_reference.ref_id, def);\n \n                             // Record the current trait reference.\n-                            (*new_trait_refs).push(def_id_of_def(def));\n+                            new_trait_refs.push(def_id_of_def(def));\n                         }\n                     }\n                     // Record the current set of trait references.\n-                    self.current_trait_refs = Some(new_trait_refs);\n+                    let mut old = Some(new_trait_refs);\n+                    self.current_trait_refs <-> old;\n+                    original_trait_refs = Some(old);\n+                }\n+                None => {\n+                    original_trait_refs = None;\n                 }\n-                None => ()\n             }\n \n             // Resolve the self type.\n@@ -3945,7 +3946,10 @@ pub impl Resolver {\n             }\n \n             // Restore the original trait references.\n-            self.current_trait_refs = original_trait_refs;\n+            match original_trait_refs {\n+                Some(r) => { self.current_trait_refs = r; }\n+                None => ()\n+            }\n         }\n     }\n \n@@ -4032,7 +4036,7 @@ pub impl Resolver {\n     }\n \n     fn resolve_arm(@mut self, arm: &arm, visitor: ResolveVisitor) {\n-        (*self.value_ribs).push(@Rib(NormalRibKind));\n+        self.value_ribs.push(@Rib(NormalRibKind));\n \n         let bindings_list = HashMap();\n         for arm.pats.each |pattern| {\n@@ -4047,12 +4051,12 @@ pub impl Resolver {\n         visit_expr_opt(arm.guard, (), visitor);\n         self.resolve_block(&arm.body, visitor);\n \n-        (*self.value_ribs).pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_block(@mut self, block: &blk, visitor: ResolveVisitor) {\n         debug!(\"(resolving block) entering block\");\n-        (*self.value_ribs).push(@Rib(NormalRibKind));\n+        self.value_ribs.push(@Rib(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n@@ -4071,7 +4075,7 @@ pub impl Resolver {\n         // Move back up.\n         self.current_module = orig_module;\n \n-        (*self.value_ribs).pop();\n+        self.value_ribs.pop();\n         debug!(\"(resolving block) leaving block\");\n     }\n \n@@ -4251,7 +4255,8 @@ pub impl Resolver {\n                                 Some(bindings_list)\n                                 if !bindings_list.contains_key(&ident)\n                                     => {\n-                                    let last_rib = (*self.value_ribs).last();\n+                                    let last_rib = self.value_ribs[\n+                                            self.value_ribs.len() - 1];\n                                     last_rib.bindings.insert(ident,\n                                                              dl_def(def));\n                                     bindings_list.insert(ident, pat_id);\n@@ -4270,7 +4275,8 @@ pub impl Resolver {\n                                   // Not bound in the same pattern: do nothing\n                                 }\n                                 None => {\n-                                    let last_rib = (*self.value_ribs).last();\n+                                    let last_rib = self.value_ribs[\n+                                            self.value_ribs.len() - 1];\n                                     last_rib.bindings.insert(ident,\n                                                              dl_def(def));\n                                 }\n@@ -4510,14 +4516,14 @@ pub impl Resolver {\n         }\n     }\n \n-    fn intern_module_part_of_path(@mut self, path: @path) -> @DVec<ident> {\n-        let module_path_idents = @DVec();\n+    fn intern_module_part_of_path(@mut self, path: @path) -> ~[ident] {\n+        let mut module_path_idents = ~[];\n         for path.idents.eachi |index, ident| {\n             if index == path.idents.len() - 1 {\n                 break;\n             }\n \n-            (*module_path_idents).push(*ident);\n+            module_path_idents.push(*ident);\n         }\n \n         return module_path_idents;\n@@ -4539,7 +4545,7 @@ pub impl Resolver {\n                 self.session.span_err(path.span,\n                                       fmt!(\"use of undeclared module `%s`\",\n                                            self.idents_to_str(\n-                                               (*module_path_idents).get())));\n+                                               module_path_idents)));\n                 return None;\n             }\n \n@@ -4587,8 +4593,8 @@ pub impl Resolver {\n             Failed => {\n                 self.session.span_err(path.span,\n                                       fmt!(\"use of undeclared module `::%s`\",\n-                                            self.idents_to_str\n-                                              ((*module_path_idents).get())));\n+                                            self.idents_to_str(\n+                                              module_path_idents)));\n                 return None;\n             }\n \n@@ -4625,12 +4631,13 @@ pub impl Resolver {\n         let mut search_result;\n         match namespace {\n             ValueNS => {\n-                search_result = self.search_ribs(self.value_ribs, ident, span,\n+                search_result = self.search_ribs(&mut self.value_ribs, ident,\n+                                                 span,\n                                                  DontAllowCapturingSelf);\n             }\n             TypeNS => {\n-                search_result = self.search_ribs(self.type_ribs, ident, span,\n-                                                 AllowCapturingSelf);\n+                search_result = self.search_ribs(&mut self.type_ribs, ident,\n+                                                 span, AllowCapturingSelf);\n             }\n         }\n \n@@ -4688,8 +4695,7 @@ pub impl Resolver {\n         let mut j = self.value_ribs.len();\n         while j != 0 {\n             j -= 1;\n-            let rib = self.value_ribs.get_elt(j);\n-            for rib.bindings.each_entry |e| {\n+            for self.value_ribs[j].bindings.each_entry |e| {\n                 vec::push(&mut maybes, copy *self.session.str_of(e.key));\n                 vec::push(&mut values, uint::max_value);\n             }\n@@ -4721,8 +4727,7 @@ pub impl Resolver {\n         let mut i = self.type_ribs.len();\n         while i != 0 {\n           i -= 1;\n-          let rib = self.type_ribs.get_elt(i);\n-          match rib.kind {\n+          match self.type_ribs[i].kind {\n             MethodRibKind(node_id, _) =>\n               for self.crate.node.module.items.each |item| {\n                 if item.id == node_id {\n@@ -4839,14 +4844,15 @@ pub impl Resolver {\n             expr_loop(_, Some(label)) => {\n                 do self.with_label_rib {\n                     let def_like = dl_def(def_label(expr.id));\n-                    self.label_ribs.last().bindings.insert(label, def_like);\n+                    let rib = self.label_ribs[self.label_ribs.len() - 1];\n+                    rib.bindings.insert(label, def_like);\n \n                     visit_expr(expr, (), visitor);\n                 }\n             }\n \n             expr_break(Some(label)) | expr_again(Some(label)) => {\n-                match self.search_ribs(self.label_ribs, label, expr.span,\n+                match self.search_ribs(&mut self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n                         self.session.span_err(expr.span,\n@@ -4873,11 +4879,11 @@ pub impl Resolver {\n         match expr.node {\n             expr_field(_, ident, _) => {\n                 let traits = self.search_for_traits_containing_method(ident);\n-                self.trait_map.insert(expr.id, traits);\n+                self.trait_map.insert(expr.id, @mut traits);\n             }\n             expr_method_call(_, ident, _, _, _) => {\n                 let traits = self.search_for_traits_containing_method(ident);\n-                self.trait_map.insert(expr.id, traits);\n+                self.trait_map.insert(expr.id, @mut traits);\n             }\n             expr_binary(add, _, _) | expr_assign_op(add, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n@@ -4948,19 +4954,19 @@ pub impl Resolver {\n \n     fn search_for_traits_containing_method(@mut self,\n                                            name: ident)\n-                                        -> @DVec<def_id> {\n+                                        -> ~[def_id] {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                *self.session.str_of(name));\n \n-        let found_traits = @DVec();\n+        let mut found_traits = ~[];\n         let mut search_module = self.current_module;\n         loop {\n             // Look for the current trait.\n             match copy self.current_trait_refs {\n                 Some(trait_def_ids) => {\n                     for trait_def_ids.each |trait_def_id| {\n                         self.add_trait_info_if_containing_method(\n-                            found_traits, *trait_def_id, name);\n+                            &mut found_traits, *trait_def_id, name);\n                     }\n                 }\n                 None => {\n@@ -4975,7 +4981,7 @@ pub impl Resolver {\n                         match def {\n                             def_ty(trait_def_id) => {\n                                 self.add_trait_info_if_containing_method(\n-                                    found_traits, trait_def_id, name);\n+                                    &mut found_traits, trait_def_id, name);\n                             }\n                             _ => {\n                                 // Continue.\n@@ -5003,7 +5009,8 @@ pub impl Resolver {\n                                     def_ty(trait_def_id) => {\n                                         let added = self.\n                                         add_trait_info_if_containing_method(\n-                                        found_traits, trait_def_id, name);\n+                                            &mut found_traits,\n+                                            trait_def_id, name);\n                                         if added {\n                                             import_resolution.state.used =\n                                                 true;\n@@ -5039,7 +5046,7 @@ pub impl Resolver {\n     }\n \n     fn add_trait_info_if_containing_method(@mut self,\n-                                           found_traits: @DVec<def_id>,\n+                                           found_traits: &mut ~[def_id],\n                                            trait_def_id: def_id,\n                                            name: ident)\n                                         -> bool {\n@@ -5056,7 +5063,7 @@ pub impl Resolver {\n                        trait_def_id.crate,\n                        trait_def_id.node,\n                        *self.session.str_of(name));\n-                (*found_traits).push(trait_def_id);\n+                found_traits.push(trait_def_id);\n                 true\n             }\n             Some(_) | None => {\n@@ -5068,9 +5075,7 @@ pub impl Resolver {\n     fn add_fixed_trait_for_expr(@mut self,\n                                 expr_id: node_id,\n                                 +trait_id: def_id) {\n-        let traits = @DVec();\n-        traits.push(trait_id);\n-        self.trait_map.insert(expr_id, traits);\n+        self.trait_map.insert(expr_id, @mut ~[trait_id]);\n     }\n \n     fn record_def(@mut self, node_id: node_id, def: def) {\n@@ -5225,7 +5230,7 @@ pub impl Resolver {\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n     fn module_to_str(@mut self, module_: @mut Module) -> ~str {\n-        let idents = DVec();\n+        let mut idents = ~[];\n         let mut current_module = module_;\n         loop {\n             match current_module.parent_link {\n@@ -5246,7 +5251,7 @@ pub impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(vec::reversed(idents.get()));\n+        return self.idents_to_str(vec::reversed(idents));\n     }\n \n     fn dump_module(@mut self, module_: @mut Module) {"}, {"sha": "8411064c57aefb26501fad3d5f6462e58a23a152", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -167,8 +167,6 @@ use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n \n-use core::dvec::DVec;\n-use core::dvec;\n use std::oldmap::HashMap;\n use syntax::ast;\n use syntax::ast::ident;\n@@ -553,7 +551,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                     // Reorder the patterns into the same order they were\n                     // specified in the struct definition. Also fill in\n                     // unspecified fields with dummy.\n-                    let reordered_patterns = dvec::DVec();\n+                    let mut reordered_patterns = ~[];\n                     for ty::lookup_struct_fields(tcx, struct_id).each\n                         |field| {\n                             match field_pats.find(|p|\n@@ -562,7 +560,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                                 Some(fp) => reordered_patterns.push(fp.pat)\n                             }\n                     }\n-                    Some(dvec::unwrap(reordered_patterns))\n+                    Some(reordered_patterns)\n                 } else {\n                     None\n                 }\n@@ -764,32 +762,32 @@ pub fn enter_region(bcx: block,\n // on a set of enum variants or a literal.\n pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n-    fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, +val: Opt) {\n+    fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], +val: Opt) {\n         if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n \n-    let found = DVec();\n-    for vec::each(m) |br| {\n+    let mut found = ~[];\n+    for m.each |br| {\n         let cur = br.pats[col];\n         match /*bad*/copy cur.node {\n             ast::pat_lit(l) => {\n-                add_to_set(ccx.tcx, &found, lit(ExprLit(l)));\n+                add_to_set(ccx.tcx, &mut found, lit(ExprLit(l)));\n             }\n             ast::pat_ident(*) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n                 // variable binding.\n                 match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n-                        add_to_set(ccx.tcx, &found,\n+                        add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n                     Some(ast::def_struct(*)) => {\n-                        add_to_set(ccx.tcx, &found,\n+                        add_to_set(ccx.tcx, &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n                     Some(ast::def_const(const_did)) => {\n-                        add_to_set(ccx.tcx, &found,\n+                        add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n                     _ => {}\n@@ -800,26 +798,26 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n                 // struct-like enum variant, or a struct.\n                 match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n-                        add_to_set(ccx.tcx, &found,\n+                        add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n                     _ => {}\n                 }\n             }\n             ast::pat_range(l1, l2) => {\n-                add_to_set(ccx.tcx, &found, range(l1, l2));\n+                add_to_set(ccx.tcx, &mut found, range(l1, l2));\n             }\n             ast::pat_vec(elems, tail) => {\n                 let opt = match tail {\n                     None => vec_len_eq(elems.len()),\n                     Some(_) => vec_len_ge(elems.len())\n                 };\n-                add_to_set(ccx.tcx, &found, opt);\n+                add_to_set(ccx.tcx, &mut found, opt);\n             }\n             _ => {}\n         }\n     }\n-    return dvec::unwrap(found);\n+    return found;\n }\n \n pub struct ExtractedBlock {\n@@ -1074,7 +1072,7 @@ pub fn compare_values(cx: block,\n \n pub fn store_non_ref_bindings(bcx: block,\n                               data: &ArmData,\n-                              opt_temp_cleanups: Option<&DVec<ValueRef>>)\n+                              opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n                            -> block {\n     /*!\n      *\n@@ -1166,8 +1164,8 @@ pub fn compile_guard(bcx: block,\n     let _indenter = indenter();\n \n     let mut bcx = bcx;\n-    let temp_cleanups = DVec();\n-    bcx = store_non_ref_bindings(bcx, data, Some(&temp_cleanups));\n+    let mut temp_cleanups = ~[];\n+    bcx = store_non_ref_bindings(bcx, data, Some(&mut temp_cleanups));\n     bcx = insert_lllocals(bcx, data, false);\n \n     let val = unpack_result!(bcx, {\n@@ -1627,7 +1625,7 @@ pub fn trans_match_inner(scope_cx: block,\n     let lldiscr = discr_datum.to_ref_llval(bcx);\n     compile_submatch(bcx, matches, ~[lldiscr], chk);\n \n-    let arm_cxs = DVec();\n+    let mut arm_cxs = ~[];\n     for arm_datas.each |arm_data| {\n         let mut bcx = arm_data.bodycx;\n \n@@ -1647,7 +1645,7 @@ pub fn trans_match_inner(scope_cx: block,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = controlflow::join_blocks(scope_cx, dvec::unwrap(arm_cxs));\n+    bcx = controlflow::join_blocks(scope_cx, arm_cxs);\n     return bcx;\n \n     fn mk_fail(bcx: block, sp: span, msg: @~str,"}, {"sha": "978b1ed16d8414afbf4c04f49e6835af738b9f18", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -29,8 +29,6 @@ use util::common::{indenter};\n \n use core::cast;\n use core::cmp;\n-use core::dvec::DVec;\n-use core::dvec;\n use core::ops;\n use core::option;\n use core::ptr::to_unsafe_ptr;\n@@ -213,7 +211,7 @@ pub enum AutoRefKind {\n // This is a map from ID of each implementation to the method info and trait\n // method ID of each of the default methods belonging to the trait that that\n // implementation implements.\n-pub type ProvidedMethodsMap = HashMap<def_id,@DVec<@ProvidedMethodInfo>>;\n+pub type ProvidedMethodsMap = HashMap<def_id,@mut ~[@ProvidedMethodInfo]>;\n \n // Stores the method info and definition ID of the associated trait method for\n // each instantiation of each provided method.\n@@ -3522,7 +3520,7 @@ pub fn trait_supertraits(cx: ctxt,\n \n     // Get the supertraits out of the metadata and create the\n     // InstantiatedTraitRef for each.\n-    let result = dvec::DVec();\n+    let mut result = ~[];\n     for csearch::get_supertraits(cx, id).each |trait_type| {\n         match get(*trait_type).sty {\n             ty_trait(def_id, ref substs, _) => {\n@@ -3539,7 +3537,7 @@ pub fn trait_supertraits(cx: ctxt,\n     }\n \n     // Unwrap and return the result.\n-    return @dvec::unwrap(result);\n+    return @result;\n }\n \n pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {"}, {"sha": "0bcbb3012cf1004b01a964e50b56b696df32f3c7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -95,7 +95,6 @@ use middle::typeck::{method_self, method_static, method_trait, method_super};\n use util::common::indenter;\n use util::ppaux::expr_repr;\n \n-use core::dvec::DVec;\n use core::result;\n use core::uint;\n use core::vec;\n@@ -127,8 +126,8 @@ pub fn lookup(\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: HashMap(),\n-        inherent_candidates: DVec(),\n-        extension_candidates: DVec(),\n+        inherent_candidates: @mut ~[],\n+        extension_candidates: @mut ~[],\n         deref_args: deref_args,\n     };\n     let mme = lcx.do_lookup(self_ty);\n@@ -145,8 +144,8 @@ pub struct LookupContext {\n     m_name: ast::ident,\n     supplied_tps: &self/[ty::t],\n     impl_dups: HashMap<def_id, ()>,\n-    inherent_candidates: DVec<Candidate>,\n-    extension_candidates: DVec<Candidate>,\n+    inherent_candidates: @mut ~[Candidate],\n+    extension_candidates: @mut ~[Candidate],\n     deref_args: check::DerefArgs,\n }\n \n@@ -188,7 +187,7 @@ pub impl LookupContext/&self {\n         self.push_inherent_candidates(self_ty);\n         self.push_extension_candidates(self_ty);\n \n-        let enum_dids = DVec();\n+        let mut enum_dids = ~[];\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;\n         loop {\n@@ -224,7 +223,7 @@ pub impl LookupContext/&self {\n                 }\n             }\n \n-            match self.deref(self_ty, &enum_dids) {\n+            match self.deref(self_ty, &mut enum_dids) {\n                 None => { break; }\n                 Some(ty) => {\n                     self_ty = ty;\n@@ -236,7 +235,7 @@ pub impl LookupContext/&self {\n         self.search_for_autosliced_method(self_ty, autoderefs)\n     }\n \n-    fn deref(ty: ty::t, enum_dids: &DVec<ast::def_id>) -> Option<ty::t> {\n+    fn deref(ty: ty::t, enum_dids: &mut ~[ast::def_id]) -> Option<ty::t> {\n         match ty::get(ty).sty {\n             ty_enum(did, _) => {\n                 // Watch out for newtype'd enums like \"enum t = @T\".\n@@ -272,7 +271,7 @@ pub impl LookupContext/&self {\n          * example, if the receiver is @@C where `C` is a struct type,\n          * we'll want to find the inherent impls for `C`. */\n \n-        let enum_dids = DVec();\n+        let mut enum_dids = ~[];\n         let mut self_ty = self_ty;\n         loop {\n             match get(self_ty).sty {\n@@ -307,7 +306,7 @@ pub impl LookupContext/&self {\n             // n.b.: Generally speaking, we only loop if we hit the\n             // fallthrough case in the match above.  The exception\n             // would be newtype enums.\n-            self_ty = match self.deref(self_ty, &enum_dids) {\n+            self_ty = match self.deref(self_ty, &mut enum_dids) {\n                 None => { return; }\n                 Some(ty) => { ty }\n             }\n@@ -330,15 +329,15 @@ pub impl LookupContext/&self {\n                 for opt_impl_infos.each |impl_infos| {\n                     for impl_infos.each |impl_info| {\n                         self.push_candidates_from_impl(\n-                            &self.extension_candidates, *impl_info);\n+                            self.extension_candidates, *impl_info);\n                     }\n                 }\n \n                 // Look for default methods.\n                 match self.tcx().provided_methods.find(trait_did) {\n                     Some(methods) => {\n                         self.push_candidates_from_provided_methods(\n-                            &self.extension_candidates, self_ty, *trait_did,\n+                            self.extension_candidates, self_ty, *trait_did,\n                             methods);\n                     }\n                     None => {}\n@@ -606,12 +605,12 @@ pub impl LookupContext/&self {\n         for opt_impl_infos.each |impl_infos| {\n             for impl_infos.each |impl_info| {\n                 self.push_candidates_from_impl(\n-                    &self.inherent_candidates, *impl_info);\n+                    self.inherent_candidates, *impl_info);\n             }\n         }\n     }\n \n-    fn push_candidates_from_impl(&self, candidates: &DVec<Candidate>,\n+    fn push_candidates_from_impl(&self, candidates: &mut ~[Candidate],\n                                  impl_info: &resolve::Impl) {\n         if !self.impl_dups.insert(impl_info.did, ()) {\n             return; // already visited\n@@ -657,10 +656,10 @@ pub impl LookupContext/&self {\n \n     fn push_candidates_from_provided_methods(\n             &self,\n-            candidates: &DVec<Candidate>,\n+            candidates: &mut ~[Candidate],\n             self_ty: ty::t,\n             trait_def_id: def_id,\n-            methods: @DVec<@ProvidedMethodInfo>) {\n+            methods: &mut ~[@ProvidedMethodInfo]) {\n         debug!(\"(pushing candidates from provided methods) considering trait \\\n                 id %d:%d\",\n                trait_def_id.crate,\n@@ -970,15 +969,15 @@ pub impl LookupContext/&self {\n         // existing code.\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, &self.inherent_candidates) {\n+        match self.consider_candidates(self_ty, self.inherent_candidates) {\n             None => {}\n             Some(mme) => {\n                 return Some(mme);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        match self.consider_candidates(self_ty, &self.extension_candidates) {\n+        match self.consider_candidates(self_ty, self.extension_candidates) {\n             None => {\n                 return None;\n             }\n@@ -990,7 +989,7 @@ pub impl LookupContext/&self {\n \n     fn consider_candidates(&self,\n                            self_ty: ty::t,\n-                           candidates: &DVec<Candidate>)\n+                           candidates: &mut ~[Candidate])\n         -> Option<method_map_entry>\n     {\n         let relevant_candidates ="}, {"sha": "3e45323807212ac77485270d26d608cd1e02d24d", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -55,7 +55,6 @@ use syntax::visit::{Visitor, SimpleVisitor};\n use syntax::visit::{visit_mod};\n use util::ppaux::ty_to_str;\n \n-use core::dvec::DVec;\n use core::result::Ok;\n use core::hashmap::linear::LinearSet;\n use core::uint;\n@@ -151,11 +150,11 @@ pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n pub struct CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    inherent_methods: HashMap<def_id,@DVec<@Impl>>,\n+    inherent_methods: HashMap<def_id,@mut ~[@Impl]>,\n \n     // Contains implementations of methods associated with a trait. For these,\n     // the associated trait must be imported at the call site.\n-    extension_methods: HashMap<def_id,@DVec<@Impl>>,\n+    extension_methods: HashMap<def_id,@mut ~[@Impl]>,\n \n }\n \n@@ -372,9 +371,8 @@ pub impl CoherenceChecker {\n                             for method `%s`\",\n                             *self.crate_context.tcx.sess.str_of(\n                                 provided_method_info.method_info.ident));\n-                    let method_infos = @DVec();\n-                    method_infos.push(provided_method_info);\n-                    pmm.insert(local_def(impl_id), method_infos);\n+                    pmm.insert(local_def(impl_id),\n+                               @mut ~[provided_method_info]);\n                 }\n             }\n         }\n@@ -386,7 +384,7 @@ pub impl CoherenceChecker {\n         match self.crate_context.coherence_info.inherent_methods\n                   .find(&base_def_id) {\n             None => {\n-                implementation_list = @DVec();\n+                implementation_list = @mut ~[];\n                 self.crate_context.coherence_info.inherent_methods\n                     .insert(base_def_id, implementation_list);\n             }\n@@ -403,7 +401,7 @@ pub impl CoherenceChecker {\n         match self.crate_context.coherence_info.extension_methods\n                   .find(&trait_id) {\n             None => {\n-                implementation_list = @DVec();\n+                implementation_list = @mut ~[];\n                 self.crate_context.coherence_info.extension_methods\n                     .insert(trait_id, implementation_list);\n             }\n@@ -741,13 +739,13 @@ pub impl CoherenceChecker {\n     // Converts an implementation in the AST to an Impl structure.\n     fn create_impl_from_item(&self, item: @item) -> @Impl {\n         fn add_provided_methods(all_methods: &mut ~[@MethodInfo],\n-                                all_provided_methods: ~[@ProvidedMethodInfo],\n-                                sess: driver::session::Session) {\n+                            all_provided_methods: &mut ~[@ProvidedMethodInfo],\n+                            sess: driver::session::Session) {\n             for all_provided_methods.each |provided_method| {\n                 debug!(\n                     \"(creating impl) adding provided method `%s` to impl\",\n                     *sess.str_of(provided_method.method_info.ident));\n-                vec::push(&mut *all_methods, provided_method.method_info);\n+                vec::push(all_methods, provided_method.method_info);\n             }\n         }\n \n@@ -790,7 +788,7 @@ pub impl CoherenceChecker {\n                             // Add all provided methods.\n                             add_provided_methods(\n                                 &mut methods,\n-                                all_provided.get(),\n+                                all_provided,\n                                 self.crate_context.tcx.sess);\n                         }\n                     }\n@@ -943,9 +941,7 @@ pub impl CoherenceChecker {\n                     trait_method_def_id: trait_method_info.def_id\n                 };\n \n-            let method_infos = @DVec();\n-            method_infos.push(provided_method_info);\n-            pmm.insert(trait_def_id, method_infos);\n+            pmm.insert(trait_def_id, @mut ~[provided_method_info]);\n         }\n     }\n "}, {"sha": "6c8bfdb041ddd4c8f2ce169aae952e8f2d884270", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -46,7 +46,6 @@ use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n use util::common::{indenter, pluralize};\n use util::ppaux;\n \n-use core::dvec;\n use core::vec;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n@@ -321,7 +320,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n-    let instantiated = dvec::DVec();\n+    let mut instantiated = ~[];\n     for trait_refs.each |trait_ref| {\n         let (did, tpt) = instantiate_trait_ref(ccx, *trait_ref, rp);\n         if instantiated.any(|other_trait: &InstantiatedTraitRef|\n@@ -334,8 +333,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n         }\n         instantiated.push(InstantiatedTraitRef { def_id: did, tpt: tpt });\n     }\n-    tcx.supertraits.insert(local_def(id),\n-                               @dvec::unwrap(instantiated));\n+    tcx.supertraits.insert(local_def(id), @instantiated);\n }\n \n /**"}, {"sha": "35c901c7528de637114309aae38f38c7dede0112", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a72099063b21abc84145960a14224458b6dc37c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=2a72099063b21abc84145960a14224458b6dc37c", "patch": "@@ -549,7 +549,6 @@ use util::ppaux::note_and_explain_region;\n \n use core::cell::{Cell, empty_cell};\n use core::cmp;\n-use core::dvec::DVec;\n use core::result::{Err, Ok, Result};\n use core::to_bytes;\n use core::uint;\n@@ -627,7 +626,7 @@ type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n-    var_spans: DVec<span>,\n+    var_spans: ~[span],\n     constraints: HashMap<Constraint, span>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n@@ -653,7 +652,7 @@ pub struct RegionVarBindings {\n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n-        var_spans: DVec(),\n+        var_spans: ~[],\n         values: empty_cell(),\n         constraints: HashMap(),\n         lubs: CombineMap(),"}]}