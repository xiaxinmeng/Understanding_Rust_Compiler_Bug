{"sha": "fb730d75d4c1c05c90419841758300b6fbf01250", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNzMwZDc1ZDRjMWMwNWM5MDQxOTg0MTc1ODMwMGI2ZmJmMDEyNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-14T06:32:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-14T06:32:20Z"}, "message": "Auto merge of #49396 - Zoxc:sync-on-disk-cache, r=michaelwoerister\n\nMake OnDiskCache thread-safer\n\nI'm not sure if `synthetic_expansion_infos` is handled correctly.\n\n`interpret_alloc_cache` and `interpret_alloc_size` seems to be wrong though, since the code may now decode two `AllocId`s in parallel. I'd like some input on how to fix that.\n\ncc @oli-obk\n\nr? @michaelwoerister", "tree": {"sha": "f5c17f938e2642906b6bf3570ad855eeb70fd78d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5c17f938e2642906b6bf3570ad855eeb70fd78d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb730d75d4c1c05c90419841758300b6fbf01250", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb730d75d4c1c05c90419841758300b6fbf01250", "html_url": "https://github.com/rust-lang/rust/commit/fb730d75d4c1c05c90419841758300b6fbf01250", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb730d75d4c1c05c90419841758300b6fbf01250/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "410e895bd5f3ca4cb29dd5731cbd75f907e0f41a", "url": "https://api.github.com/repos/rust-lang/rust/commits/410e895bd5f3ca4cb29dd5731cbd75f907e0f41a", "html_url": "https://github.com/rust-lang/rust/commit/410e895bd5f3ca4cb29dd5731cbd75f907e0f41a"}, {"sha": "807c1a0935d4acbf637601e81fc078d7d7098650", "url": "https://api.github.com/repos/rust-lang/rust/commits/807c1a0935d4acbf637601e81fc078d7d7098650", "html_url": "https://github.com/rust-lang/rust/commit/807c1a0935d4acbf637601e81fc078d7d7098650"}], "stats": {"total": 51, "additions": 25, "deletions": 26}, "files": [{"sha": "a508f33db3f771c0eab854fd3c666cf67ddc6125", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb730d75d4c1c05c90419841758300b6fbf01250/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb730d75d4c1c05c90419841758300b6fbf01250/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fb730d75d4c1c05c90419841758300b6fbf01250", "patch": "@@ -62,7 +62,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::{Lrc, Lock};\n use std::any::Any;\n use std::borrow::Borrow;\n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::cmp::Ordering;\n use std::collections::hash_map::{self, Entry};\n use std::hash::{Hash, Hasher};\n@@ -897,7 +897,7 @@ pub struct GlobalCtxt<'tcx> {\n     maybe_unused_extern_crates: Vec<(DefId, Span)>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n-    pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    pub rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n@@ -1293,7 +1293,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             hir,\n             def_path_hash_to_def_id,\n             maps: maps::Maps::new(providers),\n-            rcache: RefCell::new(FxHashMap()),\n+            rcache: Lock::new(FxHashMap()),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             crate_name: Symbol::intern(crate_name),"}, {"sha": "9ea4b21c552218dc785bf7a8a57189fd1b8af681", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fb730d75d4c1c05c90419841758300b6fbf01250/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb730d75d4c1c05c90419841758300b6fbf01250/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=fb730d75d4c1c05c90419841758300b6fbf01250", "patch": "@@ -17,7 +17,7 @@ use hir::map::definitions::DefPathHash;\n use ich::{CachingCodemapView, Fingerprint};\n use mir::{self, interpret};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n                       SpecializedDecoder, SpecializedEncoder,\n@@ -57,17 +57,17 @@ pub struct OnDiskCache<'sess> {\n \n     // This field collects all Diagnostics emitted during the current\n     // compilation session.\n-    current_diagnostics: RefCell<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n+    current_diagnostics: Lock<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n \n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n-    cnum_map: RefCell<Option<IndexVec<CrateNum, Option<CrateNum>>>>,\n+    cnum_map: Once<IndexVec<CrateNum, Option<CrateNum>>>,\n \n     codemap: &'sess CodeMap,\n     file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n \n     // These two fields caches that are populated lazily during decoding.\n-    file_index_to_file: RefCell<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n-    synthetic_expansion_infos: RefCell<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    file_index_to_file: Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n+    synthetic_expansion_infos: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n     // `serialized_data`.\n@@ -140,14 +140,14 @@ impl<'sess> OnDiskCache<'sess> {\n         OnDiskCache {\n             serialized_data: data,\n             file_index_to_stable_id: footer.file_index_to_stable_id,\n-            file_index_to_file: RefCell::new(FxHashMap()),\n+            file_index_to_file: Lock::new(FxHashMap()),\n             prev_cnums: footer.prev_cnums,\n-            cnum_map: RefCell::new(None),\n+            cnum_map: Once::new(),\n             codemap: sess.codemap(),\n-            current_diagnostics: RefCell::new(FxHashMap()),\n+            current_diagnostics: Lock::new(FxHashMap()),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n-            synthetic_expansion_infos: RefCell::new(FxHashMap()),\n+            synthetic_expansion_infos: Lock::new(FxHashMap()),\n             interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n             interpret_alloc_size: RefCell::new(FxHashMap::default()),\n         }\n@@ -157,14 +157,14 @@ impl<'sess> OnDiskCache<'sess> {\n         OnDiskCache {\n             serialized_data: Vec::new(),\n             file_index_to_stable_id: FxHashMap(),\n-            file_index_to_file: RefCell::new(FxHashMap()),\n+            file_index_to_file: Lock::new(FxHashMap()),\n             prev_cnums: vec![],\n-            cnum_map: RefCell::new(None),\n+            cnum_map: Once::new(),\n             codemap,\n-            current_diagnostics: RefCell::new(FxHashMap()),\n+            current_diagnostics: Lock::new(FxHashMap()),\n             query_result_index: FxHashMap(),\n             prev_diagnostics_index: FxHashMap(),\n-            synthetic_expansion_infos: RefCell::new(FxHashMap()),\n+            synthetic_expansion_infos: Lock::new(FxHashMap()),\n             interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n             interpret_alloc_size: RefCell::new(FxHashMap::default()),\n         }\n@@ -383,18 +383,16 @@ impl<'sess> OnDiskCache<'sess> {\n             return None\n         };\n \n-        // Initialize the cnum_map if it is not initialized yet.\n-        if self.cnum_map.borrow().is_none() {\n-            let mut cnum_map = self.cnum_map.borrow_mut();\n-            *cnum_map = Some(Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n-        }\n-        let cnum_map = self.cnum_map.borrow();\n+        // Initialize the cnum_map using the value from the thread which finishes the closure first\n+        self.cnum_map.init_nonlocking_same(|| {\n+            Self::compute_cnum_map(tcx, &self.prev_cnums[..])\n+        });\n \n         let mut decoder = CacheDecoder {\n             tcx,\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n             codemap: self.codemap,\n-            cnum_map: cnum_map.as_ref().unwrap(),\n+            cnum_map: self.cnum_map.get(),\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n             synthetic_expansion_infos: &self.synthetic_expansion_infos,\n@@ -458,8 +456,8 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     opaque: opaque::Decoder<'x>,\n     codemap: &'x CodeMap,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n-    synthetic_expansion_infos: &'x RefCell<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n-    file_index_to_file: &'x RefCell<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n+    synthetic_expansion_infos: &'x Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    file_index_to_file: &'x Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n     file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n     interpret_alloc_cache: &'x RefCell<FxHashMap<usize, interpret::AllocId>>,\n     interpret_alloc_size: &'x RefCell<FxHashMap<usize, usize>>,\n@@ -557,7 +555,8 @@ impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx,\n         }\n \n         let ty = or_insert_with(self)?;\n-        tcx.rcache.borrow_mut().insert(cache_key, ty);\n+        // This may overwrite the entry, but it should overwrite with the same value\n+        tcx.rcache.borrow_mut().insert_same(cache_key, ty);\n         Ok(ty)\n     }\n "}]}