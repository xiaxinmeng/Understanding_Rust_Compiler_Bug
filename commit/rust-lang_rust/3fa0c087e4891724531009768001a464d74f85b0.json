{"sha": "3fa0c087e4891724531009768001a464d74f85b0", "node_id": "C_kwDOAAsO6NoAKDNmYTBjMDg3ZTQ4OTE3MjQ1MzEwMDk3NjgwMDFhNDY0ZDc0Zjg1YjA", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2023-05-03T23:42:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-03T23:42:48Z"}, "message": "Rollup merge of #105695 - joboet:remove_generic_parker, r=m-ou-se\n\nReplace generic thread parker with explicit no-op parker\n\nWith #98391 merged, all platforms supporting threads now have their own parking implementations. Therefore, the generic implementation can be removed. On the remaining platforms (really just WASM without atomics), parking is not supported, so calls to `thread::park` now return instantly, which is [allowed by their API](https://doc.rust-lang.org/nightly/std/thread/fn.park.html). This is a change in behaviour, as spurious wakeups do not currently occur since all platforms guard against them. It is invalid to depend on this, but I'm still going to tag this as libs-api for confirmation.\n\n````@rustbot```` label +T-libs +T-libs-api +A-atomic\n\nr? rust-lang/libs", "tree": {"sha": "5b53f080840e3e9e2c2bfceeee7e6b1c7a815f78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b53f080840e3e9e2c2bfceeee7e6b1c7a815f78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fa0c087e4891724531009768001a464d74f85b0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkUvF4CRBK7hj4Ov3rIwAAFLMIAH9MD7LPfXuf2YEDa8vHomzP\nG9kjS7APJ+QDUnlvvaD4d0QbTacvBv0mXMYded7RNfqfxLuLJtt1Jq8TkgdHOu8Y\nuJ8v9TbnVNDi1ouA7TD3A7CkTFSjBXpinQsZjyR26nOX5h9r9eJIrnWVW6YGvDfq\nMfHWHI9TXgwWYM3srDTNCQQwypIk6bVoNFzNhTFEVvaJmKwCVfrtyHRGOldNCBXc\njs3IKkQp6w35N4nWdrsXMWCc1W0/995VoOOqZ9U7chezaDamgbUCAQFFtJuM6e42\nZfPT2cEOee6c/L18y2Qu9Xg7sHvnfZTcrwBl1GXzy1RkMzqPsKrOOCm6fSfAa4w=\n=M1CC\n-----END PGP SIGNATURE-----\n", "payload": "tree 5b53f080840e3e9e2c2bfceeee7e6b1c7a815f78\nparent 38bbc3989570f51f0652f0aad4b3b675dfe09824\nparent 9622cdee1ad9657dd93d67a9ffdbc16e196ee4fa\nauthor Manish Goregaokar <manishsmail@gmail.com> 1683157368 -0700\ncommitter GitHub <noreply@github.com> 1683157368 -0700\n\nRollup merge of #105695 - joboet:remove_generic_parker, r=m-ou-se\n\nReplace generic thread parker with explicit no-op parker\n\nWith #98391 merged, all platforms supporting threads now have their own parking implementations. Therefore, the generic implementation can be removed. On the remaining platforms (really just WASM without atomics), parking is not supported, so calls to `thread::park` now return instantly, which is [allowed by their API](https://doc.rust-lang.org/nightly/std/thread/fn.park.html). This is a change in behaviour, as spurious wakeups do not currently occur since all platforms guard against them. It is invalid to depend on this, but I'm still going to tag this as libs-api for confirmation.\n\n````@rustbot```` label +T-libs +T-libs-api +A-atomic\n\nr? rust-lang/libs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa0c087e4891724531009768001a464d74f85b0", "html_url": "https://github.com/rust-lang/rust/commit/3fa0c087e4891724531009768001a464d74f85b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fa0c087e4891724531009768001a464d74f85b0/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38bbc3989570f51f0652f0aad4b3b675dfe09824", "url": "https://api.github.com/repos/rust-lang/rust/commits/38bbc3989570f51f0652f0aad4b3b675dfe09824", "html_url": "https://github.com/rust-lang/rust/commit/38bbc3989570f51f0652f0aad4b3b675dfe09824"}, {"sha": "9622cdee1ad9657dd93d67a9ffdbc16e196ee4fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/9622cdee1ad9657dd93d67a9ffdbc16e196ee4fa", "html_url": "https://github.com/rust-lang/rust/commit/9622cdee1ad9657dd93d67a9ffdbc16e196ee4fa"}], "stats": {"total": 146, "additions": 17, "deletions": 129}, "files": [{"sha": "e1a38de64711697ae347d31bb2b1faa45cef5eca", "filename": "library/std/src/sys/unsupported/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs?ref=3fa0c087e4891724531009768001a464d74f85b0", "patch": "@@ -22,6 +22,7 @@ pub mod thread;\n #[cfg(target_thread_local)]\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub mod thread_parking;\n pub mod time;\n \n mod common;"}, {"sha": "197078bb1867371a9b97a3c8d09de717ae163ee8", "filename": "library/std/src/sys/unsupported/thread_parking.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fthread_parking.rs?ref=3fa0c087e4891724531009768001a464d74f85b0", "patch": "@@ -0,0 +1,11 @@\n+use crate::pin::Pin;\n+use crate::time::Duration;\n+\n+pub struct Parker {}\n+\n+impl Parker {\n+    pub unsafe fn new_in_place(_parker: *mut Parker) {}\n+    pub unsafe fn park(self: Pin<&Self>) {}\n+    pub unsafe fn park_timeout(self: Pin<&Self>, _dur: Duration) {}\n+    pub fn unpark(self: Pin<&Self>) {}\n+}"}, {"sha": "a2223708024801102d47f45caa5586e8ce957135", "filename": "library/std/src/sys/wasi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs?ref=3fa0c087e4891724531009768001a464d74f85b0", "patch": "@@ -47,6 +47,8 @@ pub mod thread;\n pub mod thread_local_dtor;\n #[path = \"../unsupported/thread_local_key.rs\"]\n pub mod thread_local_key;\n+#[path = \"../unsupported/thread_parking.rs\"]\n+pub mod thread_parking;\n pub mod time;\n \n cfg_if::cfg_if! {"}, {"sha": "6c05b56e1bfc00189e0e712fc8a3f5b6fc606bb2", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=3fa0c087e4891724531009768001a464d74f85b0", "patch": "@@ -70,6 +70,8 @@ cfg_if::cfg_if! {\n         pub mod once;\n         #[path = \"../unsupported/thread.rs\"]\n         pub mod thread;\n+        #[path = \"../unsupported/thread_parking.rs\"]\n+        pub mod thread_parking;\n     }\n }\n "}, {"sha": "3209bffe353ed81b775a8b7869789824d1a052b1", "filename": "library/std/src/sys_common/thread_parking/generic.rs", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -1,125 +0,0 @@\n-//! Parker implementation based on a Mutex and Condvar.\n-\n-use crate::pin::Pin;\n-use crate::sync::atomic::AtomicUsize;\n-use crate::sync::atomic::Ordering::SeqCst;\n-use crate::sync::{Condvar, Mutex};\n-use crate::time::Duration;\n-\n-const EMPTY: usize = 0;\n-const PARKED: usize = 1;\n-const NOTIFIED: usize = 2;\n-\n-pub struct Parker {\n-    state: AtomicUsize,\n-    lock: Mutex<()>,\n-    cvar: Condvar,\n-}\n-\n-impl Parker {\n-    /// Construct the generic parker. The UNIX parker implementation\n-    /// requires this to happen in-place.\n-    pub unsafe fn new_in_place(parker: *mut Parker) {\n-        parker.write(Parker {\n-            state: AtomicUsize::new(EMPTY),\n-            lock: Mutex::new(()),\n-            cvar: Condvar::new(),\n-        });\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        // If we were previously notified then we consume this notification and\n-        // return quickly.\n-        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n-            return;\n-        }\n-\n-        // Otherwise we need to coordinate going to sleep\n-        let mut m = self.lock.lock().unwrap();\n-        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n-            Ok(_) => {}\n-            Err(NOTIFIED) => {\n-                // We must read here, even though we know it will be `NOTIFIED`.\n-                // This is because `unpark` may have been called again since we read\n-                // `NOTIFIED` in the `compare_exchange` above. We must perform an\n-                // acquire operation that synchronizes with that `unpark` to observe\n-                // any writes it made before the call to unpark. To do that we must\n-                // read from the write it made to `state`.\n-                let old = self.state.swap(EMPTY, SeqCst);\n-                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n-                return;\n-            } // should consume this notification, so prohibit spurious wakeups in next park.\n-            Err(_) => panic!(\"inconsistent park state\"),\n-        }\n-        loop {\n-            m = self.cvar.wait(m).unwrap();\n-            match self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n-                Ok(_) => return, // got a notification\n-                Err(_) => {}     // spurious wakeup, go back to sleep\n-            }\n-        }\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        // Like `park` above we have a fast path for an already-notified thread, and\n-        // afterwards we start coordinating for a sleep.\n-        // return quickly.\n-        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n-            return;\n-        }\n-        let m = self.lock.lock().unwrap();\n-        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n-            Ok(_) => {}\n-            Err(NOTIFIED) => {\n-                // We must read again here, see `park`.\n-                let old = self.state.swap(EMPTY, SeqCst);\n-                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n-                return;\n-            } // should consume this notification, so prohibit spurious wakeups in next park.\n-            Err(_) => panic!(\"inconsistent park_timeout state\"),\n-        }\n-\n-        // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n-        // from a notification we just want to unconditionally set the state back to\n-        // empty, either consuming a notification or un-flagging ourselves as\n-        // parked.\n-        let (_m, _result) = self.cvar.wait_timeout(m, dur).unwrap();\n-        match self.state.swap(EMPTY, SeqCst) {\n-            NOTIFIED => {} // got a notification, hurray!\n-            PARKED => {}   // no notification, alas\n-            n => panic!(\"inconsistent park_timeout state: {n}\"),\n-        }\n-    }\n-\n-    // This implementation doesn't require `Pin`, but other implementations do.\n-    pub fn unpark(self: Pin<&Self>) {\n-        // To ensure the unparked thread will observe any writes we made\n-        // before this call, we must perform a release operation that `park`\n-        // can synchronize with. To do that we must write `NOTIFIED` even if\n-        // `state` is already `NOTIFIED`. That is why this must be a swap\n-        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n-        // on failure.\n-        match self.state.swap(NOTIFIED, SeqCst) {\n-            EMPTY => return,    // no one was waiting\n-            NOTIFIED => return, // already unparked\n-            PARKED => {}        // gotta go wake someone up\n-            _ => panic!(\"inconsistent state in unpark\"),\n-        }\n-\n-        // There is a period between when the parked thread sets `state` to\n-        // `PARKED` (or last checked `state` in the case of a spurious wake\n-        // up) and when it actually waits on `cvar`. If we were to notify\n-        // during this period it would be ignored and then when the parked\n-        // thread went to sleep it would never wake up. Fortunately, it has\n-        // `lock` locked at this stage so we can acquire `lock` to wait until\n-        // it is ready to receive the notification.\n-        //\n-        // Releasing `lock` before the call to `notify_one` means that when the\n-        // parked thread wakes it doesn't get woken only to have to wait for us\n-        // to release `lock`.\n-        drop(self.lock.lock().unwrap());\n-        self.cvar.notify_one()\n-    }\n-}"}, {"sha": "c4d3f9ea2f4272a406dd24197b2145068b118f1c", "filename": "library/std/src/sys_common/thread_parking/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa0c087e4891724531009768001a464d74f85b0/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs?ref=3fa0c087e4891724531009768001a464d74f85b0", "patch": "@@ -18,10 +18,7 @@ cfg_if::cfg_if! {\n     ))] {\n         mod id;\n         pub use id::Parker;\n-    } else if #[cfg(any(windows, target_family = \"unix\"))] {\n-        pub use crate::sys::thread_parking::Parker;\n     } else {\n-        mod generic;\n-        pub use generic::Parker;\n+        pub use crate::sys::thread_parking::Parker;\n     }\n }"}]}