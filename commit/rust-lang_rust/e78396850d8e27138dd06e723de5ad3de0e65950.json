{"sha": "e78396850d8e27138dd06e723de5ad3de0e65950", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ODM5Njg1MGQ4ZTI3MTM4ZGQwNmU3MjNkZTVhZDNkZTBlNjU5NTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-01T07:13:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-01T07:15:04Z"}, "message": "Merge remote-tracking branch 'brson/mainthread'\n\nConflicts:\n\tsrc/rt/rust_sched_loop.cpp\n\tsrc/rt/rust_shape.cpp\n\tsrc/rt/rust_task.cpp", "tree": {"sha": "3768b6007a00186902b099efe24bf5ee82195cb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3768b6007a00186902b099efe24bf5ee82195cb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e78396850d8e27138dd06e723de5ad3de0e65950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e78396850d8e27138dd06e723de5ad3de0e65950", "html_url": "https://github.com/rust-lang/rust/commit/e78396850d8e27138dd06e723de5ad3de0e65950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e78396850d8e27138dd06e723de5ad3de0e65950/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21064637ed8b8259d1305f21ace12c40b9561706", "url": "https://api.github.com/repos/rust-lang/rust/commits/21064637ed8b8259d1305f21ace12c40b9561706", "html_url": "https://github.com/rust-lang/rust/commit/21064637ed8b8259d1305f21ace12c40b9561706"}, {"sha": "de47fcfdf9404d53940099f5e7810bdb2bf37af3", "url": "https://api.github.com/repos/rust-lang/rust/commits/de47fcfdf9404d53940099f5e7810bdb2bf37af3", "html_url": "https://github.com/rust-lang/rust/commit/de47fcfdf9404d53940099f5e7810bdb2bf37af3"}], "stats": {"total": 837, "additions": 577, "deletions": 260}, "files": [{"sha": "eee3f9cf3ea5be754220832abd841ca7a2ad36a1", "filename": "mk/rt.mk", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -50,8 +50,11 @@ RUNTIME_CS_$(1) := \\\n               rt/rust_builtin.cpp \\\n               rt/rust_run_program.cpp \\\n               rt/rust_env.cpp \\\n-              rt/rust_task_thread.cpp \\\n+              rt/rust_sched_loop.cpp \\\n+              rt/rust_sched_launcher.cpp \\\n+              rt/rust_sched_driver.cpp \\\n               rt/rust_scheduler.cpp \\\n+              rt/rust_sched_reaper.cpp \\\n               rt/rust_task.cpp \\\n               rt/rust_stack.cpp \\\n               rt/rust_port.cpp \\"}, {"sha": "e2d6cec94dd4d5cd7de30c307257d5f89e2b1395", "filename": "src/etc/x86.supp", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Fetc%2Fx86.supp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Fetc%2Fx86.supp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fx86.supp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -389,6 +389,34 @@\n    fun:uv_loop_delete\n }\n \n+{\n+   lock_and_signal-probably-threadsafe-access-outside-of-lock\n+   Helgrind:Race\n+   fun:_ZN15lock_and_signal27lock_held_by_current_threadEv\n+   ...\n+}  \n+\n+{\n+   lock_and_signal-probably-threadsafe-access-outside-of-lock2\n+   Helgrind:Race\n+   fun:_ZN15lock_and_signal6unlockEv\n+   ...\n+}\n+\n+{\n+   lock_and_signal-probably-threadsafe-access-outside-of-lock3\n+   Helgrind:Race\n+   fun:_ZN15lock_and_signal4lockEv\n+   ...\n+}\n+\n+{\n+   lock_and_signal-probably-threadsafe-access-outside-of-lock4\n+   Helgrind:Race\n+   fun:_ZN15lock_and_signal4waitEv\n+   ...\n+}\n+\n {\n    uv-async-send-does-racy-things\n    Helgrind:Race"}, {"sha": "00657f8ec0aadd9e58c3660869b3dce23e92cce5", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -80,21 +80,20 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     rust_sched_id sched_id = kernel->create_scheduler(env->num_sched_threads);\n     rust_scheduler *sched = kernel->get_scheduler_by_id(sched_id);\n     rust_task *root_task = sched->create_task(NULL, \"main\");\n-    rust_task_thread *thread = root_task->thread;\n     command_line_args *args\n         = new (kernel, \"main command line args\")\n         command_line_args(root_task, argc, argv);\n \n-    DLOG(thread, dom, \"startup: %d args in 0x%\" PRIxPTR,\n+    LOG(root_task, dom, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);\n     for (int i = 0; i < args->argc; i++) {\n-        DLOG(thread, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n+        LOG(root_task, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n     root_task->start((spawn_fn)main_fn, NULL, args->args);\n     root_task = NULL;\n \n-    int ret = kernel->wait_for_schedulers();\n+    int ret = kernel->wait_for_exit();\n     delete args;\n     delete kernel;\n     delete srv;"}, {"sha": "aa1f1ce1e6a84625666a26b2d28a719cbf9f73c6", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -1,7 +1,7 @@\n /* Native builtins. */\n \n #include \"rust_internal.h\"\n-#include \"rust_task_thread.h\"\n+#include \"rust_sched_loop.h\"\n #include \"rust_task.h\"\n #include \"rust_util.h\"\n #include \"rust_scheduler.h\"\n@@ -22,7 +22,7 @@ extern char **environ;\n \n extern \"C\" CDECL rust_str*\n last_os_error() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     LOG(task, task, \"last_os_error()\");\n \n@@ -65,7 +65,7 @@ last_os_error() {\n \n extern \"C\" CDECL rust_str *\n rust_getcwd() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, task, \"rust_getcwd()\");\n \n     char cbuf[BUF_BYTES];\n@@ -85,7 +85,7 @@ rust_getcwd() {\n #if defined(__WIN32__)\n extern \"C\" CDECL rust_vec *\n rust_env_pairs() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     size_t envc = 0;\n     LPTCH ch = GetEnvironmentStringsA();\n     LPTCH c;\n@@ -111,7 +111,7 @@ rust_env_pairs() {\n #else\n extern \"C\" CDECL rust_vec *\n rust_env_pairs() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n #ifdef __APPLE__\n     char **environ = *_NSGetEnviron();\n #endif\n@@ -133,21 +133,21 @@ refcount(intptr_t *v) {\n \n extern \"C\" CDECL void\n unsupervise() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->unsupervise();\n }\n \n extern \"C\" CDECL void\n vec_reserve_shared(type_desc* ty, rust_vec** vp,\n                    size_t n_elts) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     reserve_vec_exact(task, vp, n_elts * ty->size);\n }\n \n extern \"C\" CDECL void\n str_reserve_shared(rust_vec** sp,\n                    size_t n_elts) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     reserve_vec_exact(task, sp, n_elts + 1);\n }\n \n@@ -157,7 +157,7 @@ str_reserve_shared(rust_vec** sp,\n  */\n extern \"C\" CDECL rust_vec*\n vec_from_buf_shared(type_desc *ty, void *ptr, size_t count) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     size_t fill = ty->size * count;\n     rust_vec* v = (rust_vec*)task->kernel->malloc(fill + sizeof(rust_vec),\n                                                     \"vec_from_buf\");\n@@ -168,7 +168,7 @@ vec_from_buf_shared(type_desc *ty, void *ptr, size_t count) {\n \n extern \"C\" CDECL void\n rust_str_push(rust_vec** sp, uint8_t byte) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     size_t fill = (*sp)->fill;\n     reserve_vec(task, sp, fill + 1);\n     (*sp)->data[fill-1] = byte;\n@@ -178,8 +178,8 @@ rust_str_push(rust_vec** sp, uint8_t byte) {\n \n extern \"C\" CDECL void *\n rand_new() {\n-    rust_task *task = rust_task_thread::get_task();\n-    rust_task_thread *thread = task->thread;\n+    rust_task *task = rust_sched_loop::get_task();\n+    rust_sched_loop *thread = task->sched_loop;\n     randctx *rctx = (randctx *) task->malloc(sizeof(randctx), \"randctx\");\n     if (!rctx) {\n         task->fail();\n@@ -196,7 +196,7 @@ rand_next(randctx *rctx) {\n \n extern \"C\" CDECL void\n rand_free(randctx *rctx) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->free(rctx);\n }\n \n@@ -242,22 +242,22 @@ debug_abi_2(floats f) {\n static void\n debug_tydesc_helper(type_desc *t)\n {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"  size %\" PRIdPTR \", align %\" PRIdPTR\n         \", first_param 0x%\" PRIxPTR,\n         t->size, t->align, t->first_param);\n }\n \n extern \"C\" CDECL void\n debug_tydesc(type_desc *t) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_tydesc\");\n     debug_tydesc_helper(t);\n }\n \n extern \"C\" CDECL void\n debug_opaque(type_desc *t, uint8_t *front) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_opaque\");\n     debug_tydesc_helper(t);\n     // FIXME may want to actually account for alignment.  `front` may not\n@@ -277,7 +277,7 @@ struct rust_box {\n \n extern \"C\" CDECL void\n debug_box(type_desc *t, rust_box *box) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_box(0x%\" PRIxPTR \")\", box);\n     debug_tydesc_helper(t);\n     LOG(task, stdlib, \"  refcount %\" PRIdPTR,\n@@ -294,7 +294,7 @@ struct rust_tag {\n \n extern \"C\" CDECL void\n debug_tag(type_desc *t, rust_tag *tag) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     LOG(task, stdlib, \"debug_tag\");\n     debug_tydesc_helper(t);\n@@ -312,7 +312,7 @@ struct rust_fn {\n \n extern \"C\" CDECL void\n debug_fn(type_desc *t, rust_fn *fn) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_fn\");\n     debug_tydesc_helper(t);\n     LOG(task, stdlib, \"  thunk at 0x%\" PRIxPTR, fn->thunk);\n@@ -326,7 +326,7 @@ extern \"C\" CDECL void *\n debug_ptrcast(type_desc *from_ty,\n               type_desc *to_ty,\n               void *ptr) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_ptrcast from\");\n     debug_tydesc_helper(from_ty);\n     LOG(task, stdlib, \"to\");\n@@ -336,13 +336,13 @@ debug_ptrcast(type_desc *from_ty,\n \n extern \"C\" CDECL void *\n debug_get_stk_seg() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return task->stk;\n }\n \n extern \"C\" CDECL rust_vec*\n rust_list_files(rust_str *path) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     array_list<rust_str*> strings;\n #if defined(__WIN32__)\n     WIN32_FIND_DATA FindFileData;\n@@ -443,21 +443,21 @@ precise_time_ns(uint64_t *ns) {\n \n extern \"C\" CDECL rust_sched_id\n rust_get_sched_id() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return task->sched->get_id();\n }\n \n extern \"C\" CDECL rust_sched_id\n rust_new_sched(uintptr_t threads) {\n-    rust_task *task = rust_task_thread::get_task();\n-    A(task->thread, threads > 0,\n+    rust_task *task = rust_sched_loop::get_task();\n+    A(task->sched_loop, threads > 0,\n       \"Can't create a scheduler with no threads, silly!\");\n     return task->kernel->create_scheduler(threads);\n }\n \n extern \"C\" CDECL rust_task_id\n get_task_id() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return task->id;\n }\n \n@@ -468,13 +468,13 @@ new_task_common(rust_scheduler *sched, rust_task *parent) {\n \n extern \"C\" CDECL rust_task*\n new_task() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return new_task_common(task->sched, task);\n }\n \n extern \"C\" CDECL rust_task*\n rust_new_task_in_sched(rust_sched_id id) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     rust_scheduler *sched = task->kernel->get_scheduler_by_id(id);\n     // FIXME: What if we didn't get the scheduler?\n     return new_task_common(sched, task);\n@@ -487,7 +487,7 @@ rust_task_config_notify(rust_task *target, rust_port_id *port) {\n \n extern \"C\" rust_task *\n rust_get_task() {\n-    return rust_task_thread::get_task();\n+    return rust_sched_loop::get_task();\n }\n \n extern \"C\" CDECL void\n@@ -497,13 +497,13 @@ start_task(rust_task *target, fn_env_pair *f) {\n \n extern \"C\" CDECL int\n sched_threads() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return task->sched->number_of_threads();\n }\n \n extern \"C\" CDECL rust_port*\n new_port(size_t unit_sz) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, comm, \"new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n         (uintptr_t) task, task->name, unit_sz);\n     // port starts with refcount == 1\n@@ -512,7 +512,7 @@ new_port(size_t unit_sz) {\n \n extern \"C\" CDECL void\n rust_port_begin_detach(rust_port *port, uintptr_t *yield) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, comm, \"rust_port_detach(0x%\" PRIxPTR \")\", (uintptr_t) port);\n     port->begin_detach(yield);\n }\n@@ -524,7 +524,7 @@ rust_port_end_detach(rust_port *port) {\n \n extern \"C\" CDECL void\n del_port(rust_port *port) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, comm, \"del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n     delete port;\n }\n@@ -542,7 +542,7 @@ get_port_id(rust_port *port) {\n extern \"C\" CDECL uintptr_t\n rust_port_id_send(type_desc *t, rust_port_id target_port_id, void *sptr) {\n     bool sent = false;\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     LOG(task, comm, \"rust_port_id*_send port: 0x%\" PRIxPTR,\n         (uintptr_t) target_port_id);\n@@ -573,14 +573,14 @@ port_recv(uintptr_t *dptr, rust_port *port, uintptr_t *yield) {\n extern \"C\" CDECL void\n rust_port_select(rust_port **dptr, rust_port **ports,\n                  size_t n_ports, uintptr_t *yield) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     rust_port_selector *selector = task->get_port_selector();\n     selector->select(task, dptr, ports, n_ports, yield);\n }\n \n extern \"C\" CDECL void\n rust_set_exit_status(intptr_t code) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->kernel->set_exit_status((int)code);\n }\n \n@@ -595,7 +595,7 @@ extern void log_console_off(rust_env *env);\n \n extern \"C\" CDECL void\n rust_log_console_off() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     log_console_off(task->kernel->env);\n }\n \n@@ -606,36 +606,36 @@ rust_dbg_lock_create() {\n \n extern \"C\" CDECL void\n rust_dbg_lock_destroy(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     delete lock;\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_lock(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     lock->lock();\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_unlock(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     lock->unlock();\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_wait(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     lock->wait();\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_signal(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     lock->signal();\n }\n "}, {"sha": "0b9102b8ff79a9616f7c2eacec8d46b042181f43", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -10,7 +10,7 @@\n #include \"sync/lock_and_signal.h\"\n #include \"sync/lock_free_queue.h\"\n \n-struct rust_task_thread;\n+struct rust_sched_loop;\n struct rust_task;\n class rust_log;\n class rust_port;\n@@ -110,7 +110,7 @@ struct rust_cond { };\n #include \"rust_srv.h\"\n #include \"rust_log.h\"\n #include \"rust_kernel.h\"\n-#include \"rust_task_thread.h\"\n+#include \"rust_sched_loop.h\"\n \n typedef void CDECL (glue_fn)(void *, void *,\n                              const type_desc **, void *);"}, {"sha": "c7625537f408e3600191676b949ff3c70bf8d486", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -17,6 +17,7 @@ rust_kernel::rust_kernel(rust_srv *srv) :\n     max_port_id(0),\n     rval(0),\n     max_sched_id(0),\n+    sched_reaper(this),\n     env(srv->env)\n {\n }\n@@ -62,6 +63,9 @@ rust_kernel::create_scheduler(size_t num_threads) {\n     rust_scheduler *sched;\n     {\n         scoped_lock with(sched_lock);\n+        // If this is the first scheduler then we need to launch\n+        // the scheduler reaper.\n+        bool start_reaper = sched_table.empty();\n         id = max_sched_id++;\n         K(srv, id != INTPTR_MAX, \"Hit the maximum scheduler id\");\n         sched = new (this, \"rust_scheduler\")\n@@ -70,6 +74,9 @@ rust_kernel::create_scheduler(size_t num_threads) {\n             .insert(std::pair<rust_sched_id,\n                               rust_scheduler*>(id, sched)).second;\n         A(this, is_new, \"Reusing a sched id?\");\n+        if (start_reaper) {\n+            sched_reaper.start();\n+        }\n     }\n     sched->start_task_threads();\n     return id;\n@@ -97,12 +104,12 @@ rust_kernel::release_scheduler_id(rust_sched_id id) {\n }\n \n /*\n-Called on the main thread to wait for the kernel to exit. This function is\n-also used to join on every terminating scheduler thread, so that we can be\n-sure they have completely exited before the process exits.  If we don't join\n-them then we can see valgrind errors due to un-freed pthread memory.\n+Called by rust_sched_reaper to join every every terminating scheduler thread,\n+so that we can be sure they have completely exited before the process exits.\n+If we don't join them then we can see valgrind errors due to un-freed pthread\n+memory.\n  */\n-int\n+void\n rust_kernel::wait_for_schedulers()\n {\n     scoped_lock with(sched_lock);\n@@ -121,6 +128,12 @@ rust_kernel::wait_for_schedulers()\n             sched_lock.wait();\n         }\n     }\n+}\n+\n+/* Called on the main thread to wait for the kernel to exit */\n+int\n+rust_kernel::wait_for_exit() {\n+    sched_reaper.join();\n     return rval;\n }\n "}, {"sha": "78548917ee5e5cf88e0ffbdddf078e1f378d1f31", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -6,6 +6,7 @@\n #include <vector>\n #include \"memory_region.h\"\n #include \"rust_log.h\"\n+#include \"rust_sched_reaper.h\"\n \n struct rust_task_thread;\n class rust_scheduler;\n@@ -46,6 +47,8 @@ class rust_kernel {\n     // A list of scheduler ids that are ready to exit\n     std::vector<rust_sched_id> join_list;\n \n+    rust_sched_reaper sched_reaper;\n+\n public:\n \n     struct rust_env *env;\n@@ -66,7 +69,8 @@ class rust_kernel {\n     rust_scheduler* get_scheduler_by_id(rust_sched_id id);\n     // Called by a scheduler to indicate that it is terminating\n     void release_scheduler_id(rust_sched_id id);\n-    int wait_for_schedulers();\n+    void wait_for_schedulers();\n+    int wait_for_exit();\n \n #ifdef __WIN32__\n     void win32_require(LPCTSTR fn, BOOL ok);"}, {"sha": "ce40eaa3a475e6730794479b520df3b9f9fd8930", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -40,9 +40,9 @@ log_console_off(rust_env *env) {\n     }\n }\n \n-rust_log::rust_log(rust_srv *srv, rust_task_thread *thread) :\n+rust_log::rust_log(rust_srv *srv, rust_sched_loop *sched_loop) :\n     _srv(srv),\n-    _thread(thread) {\n+    _sched_loop(sched_loop) {\n }\n \n rust_log::~rust_log() {\n@@ -122,12 +122,12 @@ rust_log::trace_ln(rust_task *task, uint32_t level, char *message) {\n #endif\n \n     char prefix[BUF_BYTES] = \"\";\n-    if (_thread && _thread->name) {\n+    if (_sched_loop && _sched_loop-.name) {\n         append_string(prefix, \"%04\" PRIxPTR \":%.10s:\",\n-                      thread_id, _thread->name);\n+                      thread_id, _sched_loop->name);\n     } else {\n         append_string(prefix, \"%04\" PRIxPTR \":0x%08\" PRIxPTR \":\",\n-                      thread_id, (uintptr_t) _thread);\n+                      thread_id, (uintptr_t) _sched_loop);\n     }\n     if (task) {\n         if (task->name) {"}, {"sha": "77449a516d0fcff2083f1e72190e73e332b019ca", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -8,18 +8,18 @@ const uint32_t log_info = 2;\n const uint32_t log_debug = 3;\n \n #define LOG(task, field, ...)                                   \\\n-    DLOG_LVL(log_debug, task, task->thread, field, __VA_ARGS__)\n+    DLOG_LVL(log_debug, task, task->sched_loop, field, __VA_ARGS__)\n #define LOG_ERR(task, field, ...)                               \\\n-    DLOG_LVL(log_err, task, task->thread, field, __VA_ARGS__)\n-#define DLOG(thread, field, ...)                                   \\\n-    DLOG_LVL(log_debug, NULL, thread, field, __VA_ARGS__)\n-#define DLOG_ERR(thread, field, ...)                               \\\n-    DLOG_LVL(log_err, NULL, thread, field, __VA_ARGS__)\n-#define LOGPTR(thread, msg, ptrval)                                \\\n-    DLOG_LVL(log_debug, NULL, thread, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n-#define DLOG_LVL(lvl, task, thread, field, ...)                    \\\n+    DLOG_LVL(log_err, task, task->sched_loop, field, __VA_ARGS__)\n+#define DLOG(sched_loop, field, ...)                                   \\\n+    DLOG_LVL(log_debug, NULL, sched_loop, field, __VA_ARGS__)\n+#define DLOG_ERR(sched_loop, field, ...)                               \\\n+    DLOG_LVL(log_err, NULL, sched_loop, field, __VA_ARGS__)\n+#define LOGPTR(sched_loop, msg, ptrval)                                \\\n+    DLOG_LVL(log_debug, NULL, sched_loop, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n+#define DLOG_LVL(lvl, task, sched_loop, field, ...)                    \\\n     do {                                                        \\\n-        rust_task_thread* _d_ = thread;                            \\\n+        rust_sched_loop* _d_ = sched_loop;                      \\\n         if (log_rt_##field >= lvl && _d_->log_lvl >= lvl) {     \\\n             _d_->log(task, lvl, __VA_ARGS__);                   \\\n         }                                                       \\\n@@ -34,13 +34,13 @@ const uint32_t log_debug = 3;\n         }                                                     \\\n     } while (0)\n \n-struct rust_task_thread;\n+struct rust_sched_loop;\n struct rust_task;\n \n class rust_log {\n \n public:\n-    rust_log(rust_srv *srv, rust_task_thread *thread);\n+    rust_log(rust_srv *srv, rust_sched_loop *sched_loop);\n     virtual ~rust_log();\n \n     void trace_ln(rust_task *task, uint32_t level, char *message);\n@@ -49,7 +49,7 @@ class rust_log {\n \n private:\n     rust_srv *_srv;\n-    rust_task_thread *_thread;\n+    rust_sched_loop *_sched_loop;\n     bool _use_labels;\n     void trace_ln(rust_task *task, char *message);\n };"}, {"sha": "81913d90f3cfd0c11ab89b0cc750ba183e82d5f2", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -51,7 +51,7 @@ void rust_port::end_detach() {\n     // Just take the lock to make sure that the thread that signaled\n     // the detach_cond isn't still holding it\n     scoped_lock with(ref_lock);\n-    I(task->thread, ref_count == 0);\n+    I(task->sched_loop, ref_count == 0);\n }\n \n void rust_port::send(void *sptr) {"}, {"sha": "520fe680fa4a4c1f1a8170f0834b0a7710f5c2f0", "filename": "src/rt/rust_port_selector.cpp", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_port_selector.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_port_selector.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -10,12 +10,12 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n                            rust_port **ports,\n                            size_t n_ports, uintptr_t *yield) {\n \n-    I(task->thread, this->ports == NULL);\n-    I(task->thread, this->n_ports == 0);\n-    I(task->thread, dptr != NULL);\n-    I(task->thread, ports != NULL);\n-    I(task->thread, n_ports != 0);\n-    I(task->thread, yield != NULL);\n+    I(task->sched_loop, this->ports == NULL);\n+    I(task->sched_loop, this->n_ports == 0);\n+    I(task->sched_loop, dptr != NULL);\n+    I(task->sched_loop, ports != NULL);\n+    I(task->sched_loop, n_ports != 0);\n+    I(task->sched_loop, yield != NULL);\n \n     *yield = false;\n     size_t locks_taken = 0;\n@@ -27,11 +27,11 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n     // message.\n \n     // Start looking for ports from a different index each time.\n-    size_t j = isaac_rand(&task->thread->rctx);\n+    size_t j = isaac_rand(&task->sched_loop->rctx);\n     for (size_t i = 0; i < n_ports; i++) {\n         size_t k = (i + j) % n_ports;\n         rust_port *port = ports[k];\n-        I(task->thread, port != NULL);\n+        I(task->sched_loop, port != NULL);\n \n         port->lock.lock();\n         locks_taken++;\n@@ -46,7 +46,7 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n     if (!found_msg) {\n         this->ports = ports;\n         this->n_ports = n_ports;\n-        I(task->thread, task->rendezvous_ptr == NULL);\n+        I(task->sched_loop, task->rendezvous_ptr == NULL);\n         task->rendezvous_ptr = (uintptr_t*)dptr;\n         task->block(this, \"waiting for select rendezvous\");\n \n@@ -69,6 +69,8 @@ void\n rust_port_selector::msg_sent_on(rust_port *port) {\n     rust_task *task = port->task;\n \n+    port->lock.must_not_have_lock();\n+\n     // Prevent two ports from trying to wake up the task\n     // simultaneously\n     scoped_lock with(rendezvous_lock);"}, {"sha": "dd9ca9e7f10648e0293f5232713d7a3a172838dc", "filename": "src/rt/rust_sched_driver.cpp", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_driver.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_driver.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_driver.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -0,0 +1,46 @@\n+#include <assert.h>\n+#include \"rust_internal.h\"\n+#include \"rust_sched_driver.h\"\n+#include \"rust_sched_loop.h\"\n+\n+rust_sched_driver::rust_sched_driver(rust_sched_loop *sched_loop)\n+    : sched_loop(sched_loop),\n+      signalled(false) {\n+\n+    assert(sched_loop != NULL);\n+    sched_loop->on_pump_loop(this);\n+}\n+\n+/**\n+ * Starts the main scheduler loop which performs task scheduling for this\n+ * domain.\n+ *\n+ * Returns once no more tasks can be scheduled and all task ref_counts\n+ * drop to zero.\n+ */\n+void\n+rust_sched_driver::start_main_loop() {\n+    assert(sched_loop != NULL);\n+\n+    rust_sched_loop_state state = sched_loop_state_keep_going;\n+    while (state != sched_loop_state_exit) {\n+        DLOG(sched_loop, dom, \"pumping scheduler\");\n+        state = sched_loop->run_single_turn();\n+\n+        if (state == sched_loop_state_block) {\n+            scoped_lock with(lock);\n+            if (!signalled) {\n+                DLOG(sched_loop, dom, \"blocking scheduler\");\n+                lock.wait();\n+            }\n+            signalled = false;\n+        }\n+    }\n+}\n+\n+void\n+rust_sched_driver::signal() {\n+    scoped_lock with(lock);\n+    signalled = true;\n+    lock.signal();\n+}"}, {"sha": "c8dae9ca7b819a359bc1337979f7af1b5b8caf57", "filename": "src/rt/rust_sched_driver.h", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_driver.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_driver.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_driver.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -0,0 +1,23 @@\n+#ifndef RUST_SCHED_DRIVER_H\n+#define RUST_SCHED_DRIVER_H\n+\n+#include \"sync/lock_and_signal.h\"\n+#include \"rust_signal.h\"\n+\n+struct rust_sched_loop;\n+\n+class rust_sched_driver : public rust_signal {\n+private:\n+    rust_sched_loop *sched_loop;\n+    lock_and_signal lock;\n+    bool signalled;\n+\n+public:\n+    rust_sched_driver(rust_sched_loop *sched_loop);\n+\n+    void start_main_loop();\n+\n+    virtual void signal();\n+};\n+\n+#endif /* RUST_SCHED_DRIVER_H */"}, {"sha": "424922edd8f486129a7cd3bf121174c1d9597d87", "filename": "src/rt/rust_sched_launcher.cpp", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_launcher.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_launcher.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -0,0 +1,18 @@\n+#include \"rust_sched_launcher.h\"\n+#include \"rust_scheduler.h\"\n+\n+const size_t SCHED_STACK_SIZE = 1024*100;\n+\n+rust_sched_launcher::rust_sched_launcher(rust_scheduler *sched,\n+                                         rust_srv *srv, int id)\n+    : kernel(sched->kernel),\n+      sched_loop(sched, srv, id),\n+      driver(&sched_loop) {\n+}\n+\n+rust_thread_sched_launcher::rust_thread_sched_launcher(rust_scheduler *sched,\n+                                                       rust_srv *srv, int id)\n+    : rust_sched_launcher(sched, srv, id),\n+      rust_thread(SCHED_STACK_SIZE) {\n+}\n+"}, {"sha": "ea35dc27a22c28fdcc65c0a037a4a8616f76f330", "filename": "src/rt/rust_sched_launcher.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_launcher.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_launcher.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -0,0 +1,37 @@\n+#ifndef RUST_SCHED_LAUNCHER_H\n+#define RUST_SCHED_LAUNCHER_H\n+\n+#include \"rust_internal.h\"\n+#include \"sync/rust_thread.h\"\n+#include \"rust_sched_driver.h\"\n+\n+class rust_sched_launcher : public kernel_owned<rust_sched_launcher> {\n+public:\n+    rust_kernel *kernel;\n+\n+private:\n+    rust_sched_loop sched_loop;\n+\n+protected:\n+    rust_sched_driver driver;\n+\n+public:\n+    rust_sched_launcher(rust_scheduler *sched, rust_srv *srv, int id);\n+\n+    virtual void start() = 0;\n+    virtual void run()  = 0;\n+    virtual void join() = 0;\n+    rust_sched_loop *get_loop() { return &sched_loop; }\n+};\n+\n+class rust_thread_sched_launcher\n+  :public rust_sched_launcher,\n+   private rust_thread {\n+public:\n+    rust_thread_sched_launcher(rust_scheduler *sched, rust_srv *srv, int id);\n+    virtual void start() { rust_thread::start(); }\n+    virtual void run() { driver.start_main_loop(); }\n+    virtual void join() { rust_thread::join(); }\n+};\n+\n+#endif // RUST_SCHED_LAUNCHER_H"}, {"sha": "6a9668f418e557f641a29ca72317cd687fc76d62", "filename": "src/rt/rust_sched_loop.cpp", "status": "renamed", "additions": 72, "deletions": 59, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -8,25 +8,24 @@\n #include \"rust_scheduler.h\"\n \n #ifndef _WIN32\n-pthread_key_t rust_task_thread::task_key;\n+pthread_key_t rust_sched_loop::task_key;\n #else\n-DWORD rust_task_thread::task_key;\n+DWORD rust_sched_loop::task_key;\n #endif\n \n-const size_t SCHED_STACK_SIZE = 1024*100;\n const size_t C_STACK_SIZE = 1024*1024;\n \n-bool rust_task_thread::tls_initialized = false;\n+bool rust_sched_loop::tls_initialized = false;\n \n-rust_task_thread::rust_task_thread(rust_scheduler *sched,\n+rust_sched_loop::rust_sched_loop(rust_scheduler *sched,\n                                    rust_srv *srv,\n                                    int id) :\n-    rust_thread(SCHED_STACK_SIZE),\n     _log(srv, this),\n     id(id),\n     should_exit(false),\n     cached_c_stack(NULL),\n     dead_task(NULL),\n+    pump_signal(NULL),\n     kernel(sched->kernel),\n     sched(sched),\n     srv(srv),\n@@ -44,7 +43,8 @@ rust_task_thread::rust_task_thread(rust_scheduler *sched,\n }\n \n void\n-rust_task_thread::activate(rust_task *task) {\n+rust_sched_loop::activate(rust_task *task) {\n+    lock.must_have_lock();\n     task->ctx.next = &c_context;\n     DLOG(this, task, \"descheduling...\");\n     lock.unlock();\n@@ -57,7 +57,7 @@ rust_task_thread::activate(rust_task *task) {\n }\n \n void\n-rust_task_thread::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n+rust_sched_loop::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n     char buf[BUF_BYTES];\n     va_list args;\n     va_start(args, fmt);\n@@ -67,14 +67,14 @@ rust_task_thread::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n }\n \n void\n-rust_task_thread::fail() {\n+rust_sched_loop::fail() {\n     log(NULL, log_err, \"domain %s @0x%\" PRIxPTR \" root task failed\",\n         name, this);\n     kernel->fail();\n }\n \n void\n-rust_task_thread::kill_all_tasks() {\n+rust_sched_loop::kill_all_tasks() {\n     std::vector<rust_task*> all_tasks;\n \n     {\n@@ -100,15 +100,17 @@ rust_task_thread::kill_all_tasks() {\n }\n \n size_t\n-rust_task_thread::number_of_live_tasks() {\n+rust_sched_loop::number_of_live_tasks() {\n     return running_tasks.length() + blocked_tasks.length();\n }\n \n /**\n  * Delete any dead tasks.\n  */\n void\n-rust_task_thread::reap_dead_tasks() {\n+rust_sched_loop::reap_dead_tasks() {\n+    lock.must_have_lock();\n+\n     if (dead_task == NULL) {\n         return;\n     }\n@@ -126,7 +128,7 @@ rust_task_thread::reap_dead_tasks() {\n }\n \n void\n-rust_task_thread::release_task(rust_task *task) {\n+rust_sched_loop::release_task(rust_task *task) {\n     // Nobody should have a ref to the task at this point\n     I(this, task->get_ref_count() == 0);\n     // Now delete the task, which will require using this thread's\n@@ -145,7 +147,8 @@ rust_task_thread::release_task(rust_task *task) {\n  * Returns NULL if no tasks can be scheduled.\n  */\n rust_task *\n-rust_task_thread::schedule_task() {\n+rust_sched_loop::schedule_task() {\n+    lock.must_have_lock();\n     I(this, this);\n     // FIXME: in the face of failing tasks, this is not always right.\n     // I(this, n_live_tasks() > 0);\n@@ -161,7 +164,7 @@ rust_task_thread::schedule_task() {\n }\n \n void\n-rust_task_thread::log_state() {\n+rust_sched_loop::log_state() {\n     if (log_rt_task < log_debug) return;\n \n     if (!running_tasks.is_empty()) {\n@@ -184,20 +187,31 @@ rust_task_thread::log_state() {\n         }\n     }\n }\n-/**\n- * Starts the main scheduler loop which performs task scheduling for this\n- * domain.\n- *\n- * Returns once no more tasks can be scheduled and all task ref_counts\n- * drop to zero.\n- */\n+\n void\n-rust_task_thread::start_main_loop() {\n+rust_sched_loop::on_pump_loop(rust_signal *signal) {\n+    I(this, pump_signal == NULL);\n+    I(this, signal != NULL);\n+    pump_signal = signal;\n+}\n+\n+void\n+rust_sched_loop::pump_loop() {\n+    I(this, pump_signal != NULL);\n+    pump_signal->signal();\n+}\n+\n+rust_sched_loop_state\n+rust_sched_loop::run_single_turn() {\n+    DLOG(this, task,\n+         \"scheduler %d resuming ...\", id);\n+\n     lock.lock();\n \n-    DLOG(this, dom, \"started domain loop %d\", id);\n+    if (!should_exit) {\n+        A(this, dead_task == NULL,\n+          \"Tasks should only die after running\");\n \n-    while (!should_exit) {\n         DLOG(this, dom, \"worker %d, number_of_live_tasks = %d\",\n              id, number_of_live_tasks());\n \n@@ -208,12 +222,9 @@ rust_task_thread::start_main_loop() {\n             DLOG(this, task,\n                  \"all tasks are blocked, scheduler id %d yielding ...\",\n                  id);\n-            lock.wait();\n-            A(this, dead_task == NULL,\n-              \"Tasks should only die after running\");\n-            DLOG(this, task,\n-                 \"scheduler %d resuming ...\", id);\n-            continue;\n+\n+            lock.unlock();\n+            return sched_loop_state_block;\n         }\n \n         I(this, scheduled_task->running());\n@@ -241,25 +252,31 @@ rust_task_thread::start_main_loop() {\n              id);\n \n         reap_dead_tasks();\n-    }\n \n-    A(this, running_tasks.is_empty(), \"Should have no running tasks\");\n-    A(this, blocked_tasks.is_empty(), \"Should have no blocked tasks\");\n-    A(this, dead_task == NULL, \"Should have no dead tasks\");\n+        lock.unlock();\n+        return sched_loop_state_keep_going;\n+    } else {\n+        A(this, running_tasks.is_empty(), \"Should have no running tasks\");\n+        A(this, blocked_tasks.is_empty(), \"Should have no blocked tasks\");\n+        A(this, dead_task == NULL, \"Should have no dead tasks\");\n \n-    DLOG(this, dom, \"finished main-loop %d\", id);\n+        DLOG(this, dom, \"finished main-loop %d\", id);\n \n-    lock.unlock();\n+        lock.unlock();\n \n-    I(this, !extra_c_stack);\n-    if (cached_c_stack) {\n-        destroy_stack(kernel->region(), cached_c_stack);\n-        cached_c_stack = NULL;\n+        I(this, !extra_c_stack);\n+        if (cached_c_stack) {\n+            destroy_stack(kernel->region(), cached_c_stack);\n+            cached_c_stack = NULL;\n+        }\n+\n+        sched->release_task_thread();\n+        return sched_loop_state_exit;\n     }\n }\n \n rust_task *\n-rust_task_thread::create_task(rust_task *spawner, const char *name) {\n+rust_sched_loop::create_task(rust_task *spawner, const char *name) {\n     rust_task *task =\n         new (this->kernel, \"rust_task\")\n         rust_task (this, task_state_newborn,\n@@ -272,7 +289,7 @@ rust_task_thread::create_task(rust_task *spawner, const char *name) {\n }\n \n rust_task_list *\n-rust_task_thread::state_list(rust_task_state state) {\n+rust_sched_loop::state_list(rust_task_state state) {\n     switch (state) {\n     case task_state_running:\n         return &running_tasks;\n@@ -284,7 +301,7 @@ rust_task_thread::state_list(rust_task_state state) {\n }\n \n const char *\n-rust_task_thread::state_name(rust_task_state state) {\n+rust_sched_loop::state_name(rust_task_state state) {\n     switch (state) {\n     case task_state_newborn:\n         return \"newborn\";\n@@ -301,7 +318,7 @@ rust_task_thread::state_name(rust_task_state state) {\n }\n \n void\n-rust_task_thread::transition(rust_task *task,\n+rust_sched_loop::transition(rust_task *task,\n                              rust_task_state src, rust_task_state dst,\n                              rust_cond *cond, const char* cond_name) {\n     scoped_lock with(lock);\n@@ -324,65 +341,61 @@ rust_task_thread::transition(rust_task *task,\n     }\n     task->set_state(dst, cond, cond_name);\n \n-    lock.signal();\n-}\n-\n-void rust_task_thread::run() {\n-    this->start_main_loop();\n-    sched->release_task_thread();\n+    pump_loop();\n }\n \n #ifndef _WIN32\n void\n-rust_task_thread::init_tls() {\n+rust_sched_loop::init_tls() {\n     int result = pthread_key_create(&task_key, NULL);\n     assert(!result && \"Couldn't create the TLS key!\");\n     tls_initialized = true;\n }\n \n void\n-rust_task_thread::place_task_in_tls(rust_task *task) {\n+rust_sched_loop::place_task_in_tls(rust_task *task) {\n     int result = pthread_setspecific(task_key, task);\n     assert(!result && \"Couldn't place the task in TLS!\");\n     task->record_stack_limit();\n }\n #else\n void\n-rust_task_thread::init_tls() {\n+rust_sched_loop::init_tls() {\n     task_key = TlsAlloc();\n     assert(task_key != TLS_OUT_OF_INDEXES && \"Couldn't create the TLS key!\");\n     tls_initialized = true;\n }\n \n void\n-rust_task_thread::place_task_in_tls(rust_task *task) {\n+rust_sched_loop::place_task_in_tls(rust_task *task) {\n     BOOL result = TlsSetValue(task_key, task);\n     assert(result && \"Couldn't place the task in TLS!\");\n     task->record_stack_limit();\n }\n #endif\n \n void\n-rust_task_thread::exit() {\n+rust_sched_loop::exit() {\n     scoped_lock with(lock);\n+    DLOG(this, dom, \"Requesting exit for thread %d\", id);\n     should_exit = true;\n-    lock.signal();\n+    pump_loop();\n }\n \n // Before activating each task, make sure we have a C stack available.\n // It needs to be allocated ahead of time (while we're on our own\n // stack), because once we're on the Rust stack we won't have enough\n // room to do the allocation\n void\n-rust_task_thread::prepare_c_stack(rust_task *task) {\n+rust_sched_loop::prepare_c_stack(rust_task *task) {\n     I(this, !extra_c_stack);\n     if (!cached_c_stack && !task->have_c_stack()) {\n         cached_c_stack = create_stack(kernel->region(), C_STACK_SIZE);\n     }\n }\n \n void\n-rust_task_thread::unprepare_c_stack() {\n+rust_sched_loop::unprepare_c_stack() {\n     if (extra_c_stack) {\n         destroy_stack(kernel->region(), extra_c_stack);\n         extra_c_stack = NULL;", "previous_filename": "src/rt/rust_task_thread.cpp"}, {"sha": "e89e9a6313b85de1bfe190c157d62327ebcff57d", "filename": "src/rt/rust_sched_loop.h", "status": "renamed", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -1,28 +1,33 @@\n-#ifndef RUST_TASK_THREAD_H\n-#define RUST_TASK_THREAD_H\n+#ifndef RUST_SCHED_LOOP_H\n+#define RUST_SCHED_LOOP_H\n \n #include \"rust_internal.h\"\n-#include \"sync/rust_thread.h\"\n #include \"rust_stack.h\"\n+#include \"rust_signal.h\"\n #include \"context.h\"\n \n-#ifndef _WIN32\n-#include <pthread.h>\n-#else\n-#include <windows.h>\n-#endif\n-\n enum rust_task_state {\n     task_state_newborn,\n     task_state_running,\n     task_state_blocked,\n     task_state_dead\n };\n \n+/*\n+The result of every turn of the scheduler loop. Instructs the loop\n+driver how to proceed.\n+ */\n+enum rust_sched_loop_state {\n+    sched_loop_state_keep_going,\n+    sched_loop_state_block,\n+    sched_loop_state_exit\n+};\n+\n+struct rust_task;\n+\n typedef indexed_list<rust_task> rust_task_list;\n \n-struct rust_task_thread : public kernel_owned<rust_task_thread>,\n-                        rust_thread\n+struct rust_sched_loop\n {\n private:\n \n@@ -51,12 +56,16 @@ struct rust_task_thread : public kernel_owned<rust_task_thread>,\n     rust_task_list blocked_tasks;\n     rust_task *dead_task;\n \n+    rust_signal *pump_signal;\n+\n     void prepare_c_stack(rust_task *task);\n     void unprepare_c_stack();\n \n     rust_task_list *state_list(rust_task_state state);\n     const char *state_name(rust_task_state state);\n \n+    void pump_loop();\n+\n public:\n     rust_kernel *kernel;\n     rust_scheduler *sched;\n@@ -75,12 +84,13 @@ struct rust_task_thread : public kernel_owned<rust_task_thread>,\n \n     randctx rctx;\n \n+    // FIXME: Neither of these are used\n     int32_t list_index;\n     const char *const name;\n \n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain.\n-    rust_task_thread(rust_scheduler *sched, rust_srv *srv, int id);\n+    rust_sched_loop(rust_scheduler *sched, rust_srv *srv, int id);\n     void activate(rust_task *task);\n     void log(rust_task *task, uint32_t level, char const *fmt, ...);\n     rust_log & get_log();\n@@ -91,7 +101,8 @@ struct rust_task_thread : public kernel_owned<rust_task_thread>,\n     void reap_dead_tasks();\n     rust_task *schedule_task();\n \n-    void start_main_loop();\n+    void on_pump_loop(rust_signal *signal);\n+    rust_sched_loop_state run_single_turn();\n \n     void log_state();\n \n@@ -103,8 +114,6 @@ struct rust_task_thread : public kernel_owned<rust_task_thread>,\n                     rust_task_state src, rust_task_state dst,\n                     rust_cond *cond, const char* cond_name);\n \n-    virtual void run();\n-\n     void init_tls();\n     void place_task_in_tls(rust_task *task);\n \n@@ -122,7 +131,7 @@ struct rust_task_thread : public kernel_owned<rust_task_thread>,\n };\n \n inline rust_log &\n-rust_task_thread::get_log() {\n+rust_sched_loop::get_log() {\n     return _log;\n }\n \n@@ -131,7 +140,7 @@ rust_task_thread::get_log() {\n #ifndef __WIN32__\n \n inline rust_task *\n-rust_task_thread::get_task() {\n+rust_sched_loop::get_task() {\n     if (!tls_initialized)\n         return NULL;\n     rust_task *task = reinterpret_cast<rust_task *>\n@@ -143,7 +152,7 @@ rust_task_thread::get_task() {\n #else\n \n inline rust_task *\n-rust_task_thread::get_task() {\n+rust_sched_loop::get_task() {\n     if (!tls_initialized)\n         return NULL;\n     rust_task *task = reinterpret_cast<rust_task *>(TlsGetValue(task_key));\n@@ -155,7 +164,7 @@ rust_task_thread::get_task() {\n \n // NB: Runs on the Rust stack\n inline stk_seg *\n-rust_task_thread::borrow_c_stack() {\n+rust_sched_loop::borrow_c_stack() {\n     I(this, cached_c_stack);\n     stk_seg *your_stack;\n     if (extra_c_stack) {\n@@ -170,7 +179,7 @@ rust_task_thread::borrow_c_stack() {\n \n // NB: Runs on the Rust stack\n inline void\n-rust_task_thread::return_c_stack(stk_seg *stack) {\n+rust_sched_loop::return_c_stack(stk_seg *stack) {\n     I(this, !extra_c_stack);\n     if (!cached_c_stack) {\n         cached_c_stack = stack;\n@@ -191,4 +200,4 @@ rust_task_thread::return_c_stack(stk_seg *stack) {\n // End:\n //\n \n-#endif /* RUST_TASK_THREAD_H */\n+#endif /* RUST_SCHED_LOOP_H */", "previous_filename": "src/rt/rust_task_thread.h"}, {"sha": "f2897859f231c3c29e2a3c6dddbcc81b51049237", "filename": "src/rt/rust_sched_reaper.cpp", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_reaper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_reaper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_reaper.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -0,0 +1,15 @@\n+#include \"rust_internal.h\"\n+#include \"rust_kernel.h\"\n+#include \"rust_sched_reaper.h\"\n+\n+// NB: We're using a very small stack here\n+const size_t STACK_SIZE = 1024*20;\n+\n+rust_sched_reaper::rust_sched_reaper(rust_kernel *kernel)\n+    : rust_thread(STACK_SIZE), kernel(kernel) {\n+}\n+\n+void\n+rust_sched_reaper::run() {\n+    kernel->wait_for_schedulers();\n+}"}, {"sha": "6b43038312d4f53fc763bccf80e77bdf516cca64", "filename": "src/rt/rust_sched_reaper.h", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_reaper.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_sched_reaper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_reaper.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -0,0 +1,17 @@\n+#ifndef RUST_SCHED_REAPER_H\n+#define RUST_SCHED_REAPER_H\n+\n+#include \"sync/rust_thread.h\"\n+\n+class rust_kernel;\n+\n+/* Responsible for joining with rust_schedulers */\n+class rust_sched_reaper : public rust_thread {\n+private:\n+    rust_kernel *kernel;\n+public:\n+    rust_sched_reaper(rust_kernel *kernel);\n+    virtual void run();\n+};\n+\n+#endif /* RUST_SCHED_REAPER_H */"}, {"sha": "40d62c76849894efd1bd606e6444007712053a39", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -1,5 +1,6 @@\n #include \"rust_scheduler.h\"\n #include \"rust_util.h\"\n+#include \"rust_sched_launcher.h\"\n \n rust_scheduler::rust_scheduler(rust_kernel *kernel,\n                                rust_srv *srv,\n@@ -21,21 +22,21 @@ rust_scheduler::~rust_scheduler() {\n     destroy_task_threads();\n }\n \n-rust_task_thread *\n+rust_sched_launcher *\n rust_scheduler::create_task_thread(int id) {\n     rust_srv *srv = this->srv->clone();\n-    rust_task_thread *thread =\n-        new (kernel, \"rust_task_thread\") rust_task_thread(this, srv, id);\n-    KLOG(kernel, kern, \"created task thread: \" PTR \", id: %d, index: %d\",\n-          thread, id, thread->list_index);\n+    rust_sched_launcher *thread =\n+        new (kernel, \"rust_thread_sched_launcher\")\n+        rust_thread_sched_launcher(this, srv, id);\n+    KLOG(kernel, kern, \"created task thread: \" PTR \", id: %d\",\n+          thread, id);\n     return thread;\n }\n \n void\n-rust_scheduler::destroy_task_thread(rust_task_thread *thread) {\n-    KLOG(kernel, kern, \"deleting task thread: \" PTR \", name: %s, index: %d\",\n-        thread, thread->name, thread->list_index);\n-    rust_srv *srv = thread->srv;\n+rust_scheduler::destroy_task_thread(rust_sched_launcher *thread) {\n+    KLOG(kernel, kern, \"deleting task thread: \" PTR, thread);\n+    rust_srv *srv = thread->get_loop()->srv;\n     delete thread;\n     delete srv;\n }\n@@ -60,7 +61,7 @@ void\n rust_scheduler::start_task_threads()\n {\n     for(size_t i = 0; i < num_threads; ++i) {\n-        rust_task_thread *thread = threads[i];\n+        rust_sched_launcher *thread = threads[i];\n         thread->start();\n     }\n }\n@@ -69,16 +70,16 @@ void\n rust_scheduler::join_task_threads()\n {\n     for(size_t i = 0; i < num_threads; ++i) {\n-        rust_task_thread *thread = threads[i];\n+        rust_sched_launcher *thread = threads[i];\n         thread->join();\n     }\n }\n \n void\n rust_scheduler::kill_all_tasks() {\n     for(size_t i = 0; i < num_threads; ++i) {\n-        rust_task_thread *thread = threads[i];\n-        thread->kill_all_tasks();\n+        rust_sched_launcher *thread = threads[i];\n+        thread->get_loop()->kill_all_tasks();\n     }\n }\n \n@@ -92,8 +93,8 @@ rust_scheduler::create_task(rust_task *spawner, const char *name) {\n         if (cur_thread >= num_threads)\n             cur_thread = 0;\n     }\n-    rust_task_thread *thread = threads[thread_no];\n-    return thread->create_task(spawner, name);\n+    rust_sched_launcher *thread = threads[thread_no];\n+    return thread->get_loop()->create_task(spawner, name);\n }\n \n void\n@@ -118,7 +119,7 @@ rust_scheduler::exit() {\n     // scheduler will get destroyed, and our fields will cease to exist.\n     size_t current_num_threads = num_threads;\n     for(size_t i = 0; i < current_num_threads; ++i) {\n-        threads[i]->exit();\n+        threads[i]->get_loop()->exit();\n     }\n }\n "}, {"sha": "722a7e168fbba1fb276647d3810a0a20db4a8292", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -3,6 +3,8 @@\n \n #include \"rust_internal.h\"\n \n+class rust_sched_launcher;\n+\n class rust_scheduler : public kernel_owned<rust_scheduler> {\n     // FIXME: Make these private\n public:\n@@ -17,7 +19,7 @@ class rust_scheduler : public kernel_owned<rust_scheduler> {\n     // When this hits zero we'll tell the threads to exit\n     uintptr_t live_tasks;\n \n-    array_list<rust_task_thread *> threads;\n+    array_list<rust_sched_launcher *> threads;\n     const size_t num_threads;\n     size_t cur_thread;\n \n@@ -26,8 +28,8 @@ class rust_scheduler : public kernel_owned<rust_scheduler> {\n     void create_task_threads();\n     void destroy_task_threads();\n \n-    rust_task_thread *create_task_thread(int id);\n-    void destroy_task_thread(rust_task_thread *thread);\n+    rust_sched_launcher *create_task_thread(int id);\n+    void destroy_task_thread(rust_sched_launcher *thread);\n \n     void exit();\n "}, {"sha": "acf44836f28304433de7ae46a31c6ac24c776d44", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -552,7 +552,7 @@ extern \"C\" void\n shape_cmp_type(int8_t *result, const type_desc *tydesc,\n                const type_desc **subtydescs, uint8_t *data_0,\n                uint8_t *data_1, uint8_t cmp_type) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     shape::arena arena;\n \n     // FIXME: This may well be broken when comparing two closures or objects\n@@ -573,7 +573,7 @@ shape_cmp_type(int8_t *result, const type_desc *tydesc,\n \n extern \"C\" rust_str *\n shape_log_str(const type_desc *tydesc, uint8_t *data) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     shape::arena arena;\n     shape::type_param *params =\n@@ -591,7 +591,7 @@ shape_log_str(const type_desc *tydesc, uint8_t *data) {\n \n extern \"C\" void\n shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     shape::arena arena;\n     shape::type_param *params =\n@@ -603,6 +603,6 @@ shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n \n     log.walk();\n \n-    task->thread->log(task, level, \"%s\", ss.str().c_str());\n+    task->sched_loop->log(task, level, \"%s\", ss.str().c_str());\n }\n "}, {"sha": "3f27f1fad97c9eed849c27e4c29232118601d8a4", "filename": "src/rt/rust_signal.h", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_signal.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -0,0 +1,10 @@\n+#ifndef RUST_SIGNAL_H\n+#define RUST_SIGNAL_H\n+\n+// Just an abstrict class that reperesents something that can be signalled\n+class rust_signal {\n+public:\n+    virtual void signal() = 0;\n+};\n+\n+#endif /* RUST_SIGNAL_H */"}, {"sha": "15f8e19be1dd4f46ecbd74ba86f7e2f52a601d10", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -13,21 +13,21 @@\n #include \"rust_upcall.h\"\n \n // Tasks\n-rust_task::rust_task(rust_task_thread *thread, rust_task_state state,\n+rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n                      rust_task *spawner, const char *name,\n                      size_t init_stack_sz) :\n     ref_count(1),\n     id(0),\n     notify_enabled(false),\n     stk(NULL),\n     runtime_sp(0),\n-    sched(thread->sched),\n-    thread(thread),\n-    kernel(thread->kernel),\n+    sched(sched_loop->sched),\n+    sched_loop(sched_loop),\n+    kernel(sched_loop->kernel),\n     name(name),\n     list_index(-1),\n     rendezvous_ptr(0),\n-    local_region(&thread->srv->local_region),\n+    local_region(&sched_loop->srv->local_region),\n     boxed(&local_region),\n     unwinding(false),\n     propagate_failure(true),\n@@ -43,8 +43,8 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_state state,\n     next_rust_sp(0),\n     supervisor(spawner)\n {\n-    LOGPTR(thread, \"new task\", (uintptr_t)this);\n-    DLOG(thread, task, \"sizeof(task) = %d (0x%x)\",\n+    LOGPTR(sched_loop, \"new task\", (uintptr_t)this);\n+    DLOG(sched_loop, task, \"sizeof(task) = %d (0x%x)\",\n          sizeof *this, sizeof *this);\n \n     new_stack(init_stack_sz);\n@@ -57,7 +57,7 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_state state,\n void\n rust_task::delete_this()\n {\n-    DLOG(thread, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n+    DLOG(sched_loop, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n          name, (uintptr_t)this, ref_count);\n \n     // FIXME: We should do this when the task exits, not in the destructor\n@@ -70,10 +70,10 @@ rust_task::delete_this()\n \n     /* FIXME: tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n-    I(thread, ref_count == 0); // ||\n+    I(sched_loop, ref_count == 0); // ||\n     //   (ref_count == 1 && this == sched->root_task));\n \n-    thread->release_task(this);\n+    sched_loop->release_task(this);\n }\n \n struct spawn_args {\n@@ -125,7 +125,7 @@ cleanup_task(cleanup_args *args) {\n #ifndef __WIN32__\n         task->conclude_failure();\n #else\n-        A(task->thread, false, \"Shouldn't happen\");\n+        A(task->sched_loop, false, \"Shouldn't happen\");\n #endif\n     }\n }\n@@ -141,7 +141,7 @@ void task_start_wrapper(spawn_args *a)\n         // must have void return type, we can safely pass 0.\n         a->f(0, a->envptr, a->argptr);\n     } catch (rust_task *ex) {\n-        A(task->thread, ex == task,\n+        A(task->sched_loop, ex == task,\n           \"Expected this task to be thrown for unwinding\");\n         threw_exception = true;\n \n@@ -155,7 +155,7 @@ void task_start_wrapper(spawn_args *a)\n     }\n \n     // We should have returned any C stack by now\n-    I(task->thread, task->c_stack == NULL);\n+    I(task->sched_loop, task->c_stack == NULL);\n \n     rust_opaque_box* env = a->envptr;\n     if(env) {\n@@ -181,7 +181,7 @@ rust_task::start(spawn_fn spawnee_fn,\n         \" with env 0x%\" PRIxPTR \" and arg 0x%\" PRIxPTR,\n         spawnee_fn, envptr, argptr);\n \n-    I(thread, stk->data != NULL);\n+    I(sched_loop, stk->data != NULL);\n \n     char *sp = (char *)stk->end;\n \n@@ -212,14 +212,15 @@ rust_task::must_fail_from_being_killed() {\n \n bool\n rust_task::must_fail_from_being_killed_unlocked() {\n+    kill_lock.must_have_lock();\n     return killed && !reentered_rust_stack;\n }\n \n // Only run this on the rust stack\n void\n rust_task::yield(bool *killed) {\n     if (must_fail_from_being_killed()) {\n-        I(thread, !blocked());\n+        I(sched_loop, !blocked());\n         *killed = true;\n     }\n \n@@ -263,7 +264,7 @@ bool rust_task_is_unwinding(rust_task *rt) {\n void\n rust_task::fail() {\n     // See note in ::kill() regarding who should call this.\n-    DLOG(thread, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n+    DLOG(sched_loop, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n     backtrace();\n     unwinding = true;\n #ifndef __WIN32__\n@@ -272,7 +273,7 @@ rust_task::fail() {\n     die();\n     conclude_failure();\n     // FIXME: Need unwinding on windows. This will end up aborting\n-    thread->fail();\n+    sched_loop->fail();\n #endif\n }\n \n@@ -285,22 +286,22 @@ void\n rust_task::fail_parent() {\n     scoped_lock with(supervisor_lock);\n     if (supervisor) {\n-        DLOG(thread, task,\n+        DLOG(sched_loop, task,\n              \"task %s @0x%\" PRIxPTR\n              \" propagating failure to supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n         supervisor->kill();\n     }\n     if (NULL == supervisor && propagate_failure)\n-        thread->fail();\n+        sched_loop->fail();\n }\n \n void\n rust_task::unsupervise()\n {\n     scoped_lock with(supervisor_lock);\n     if (supervisor) {\n-        DLOG(thread, task,\n+        DLOG(sched_loop, task,\n              \"task %s @0x%\" PRIxPTR\n              \" disconnecting from supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n@@ -365,7 +366,7 @@ rust_task::free(void *p)\n void\n rust_task::transition(rust_task_state src, rust_task_state dst,\n                       rust_cond *cond, const char* cond_name) {\n-    thread->transition(this, src, dst, cond, cond_name);\n+    sched_loop->transition(this, src, dst, cond, cond_name);\n }\n \n void\n@@ -388,8 +389,8 @@ rust_task::block(rust_cond *on, const char* name) {\n \n     LOG(this, task, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n                          (uintptr_t) on, (uintptr_t) cond);\n-    A(thread, cond == NULL, \"Cannot block an already blocked task.\");\n-    A(thread, on != NULL, \"Cannot block on a NULL object.\");\n+    A(sched_loop, cond == NULL, \"Cannot block an already blocked task.\");\n+    A(sched_loop, on != NULL, \"Cannot block on a NULL object.\");\n \n     transition(task_state_running, task_state_blocked, on, name);\n \n@@ -398,10 +399,10 @@ rust_task::block(rust_cond *on, const char* name) {\n \n void\n rust_task::wakeup(rust_cond *from) {\n-    A(thread, cond != NULL, \"Cannot wake up unblocked task.\");\n+    A(sched_loop, cond != NULL, \"Cannot wake up unblocked task.\");\n     LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n                         (uintptr_t) cond, (uintptr_t) from);\n-    A(thread, cond == from,\n+    A(sched_loop, cond == from,\n       \"Cannot wake up blocked task on wrong condition.\");\n \n     transition(task_state_blocked, task_state_running, NULL, \"none\");\n@@ -461,13 +462,13 @@ rust_task::get_next_stack_size(size_t min, size_t current, size_t requested) {\n     sz = std::max(sz, next);\n \n     LOG(this, mem, \"next stack size: %\" PRIdPTR, sz);\n-    I(thread, requested <= sz);\n+    I(sched_loop, requested <= sz);\n     return sz;\n }\n \n void\n rust_task::free_stack(stk_seg *stk) {\n-    LOGPTR(thread, \"freeing stk segment\", (uintptr_t)stk);\n+    LOGPTR(sched_loop, \"freeing stk segment\", (uintptr_t)stk);\n     total_stack_sz -= user_stack_size(stk);\n     destroy_stack(&local_region, stk);\n }\n@@ -485,7 +486,7 @@ rust_task::new_stack(size_t requested_sz) {\n     }\n \n     // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n-    size_t min_sz = thread->min_stack_size;\n+    size_t min_sz = sched_loop->min_stack_size;\n \n     // Try to reuse an existing stack segment\n     while (stk != NULL && stk->next != NULL) {\n@@ -514,21 +515,21 @@ rust_task::new_stack(size_t requested_sz) {\n     size_t rust_stk_sz = get_next_stack_size(min_sz,\n                                              current_sz, requested_sz);\n \n-    if (total_stack_sz + rust_stk_sz > thread->env->max_stack_size) {\n+    if (total_stack_sz + rust_stk_sz > sched_loop->env->max_stack_size) {\n         LOG_ERR(this, task, \"task %\" PRIxPTR \" ran out of stack\", this);\n         fail();\n     }\n \n     size_t sz = rust_stk_sz + RED_ZONE_SIZE;\n     stk_seg *new_stk = create_stack(&local_region, sz);\n-    LOGPTR(thread, \"new stk\", (uintptr_t)new_stk);\n+    LOGPTR(sched_loop, \"new stk\", (uintptr_t)new_stk);\n     new_stk->task = this;\n     new_stk->next = NULL;\n     new_stk->prev = stk;\n     if (stk) {\n         stk->next = new_stk;\n     }\n-    LOGPTR(thread, \"stk end\", new_stk->end);\n+    LOGPTR(sched_loop, \"stk end\", new_stk->end);\n \n     stk = new_stk;\n     total_stack_sz += user_stack_size(new_stk);\n@@ -538,7 +539,7 @@ void\n rust_task::cleanup_after_turn() {\n     // Delete any spare stack segments that were left\n     // behind by calls to prev_stack\n-    I(thread, stk);\n+    I(sched_loop, stk);\n     while (stk->next) {\n         stk_seg *new_next = stk->next->next;\n         free_stack(stk->next);\n@@ -568,7 +569,7 @@ reset_stack_limit_on_c_stack(reset_args *args) {\n     uintptr_t sp = args->sp;\n     while (!sp_in_stk_seg(sp, task->stk)) {\n         task->stk = task->stk->prev;\n-        A(task->thread, task->stk != NULL,\n+        A(task->sched_loop, task->stk != NULL,\n           \"Failed to find the current stack\");\n     }\n     task->record_stack_limit();\n@@ -597,10 +598,10 @@ rust_task::check_stack_canary() {\n \n void\n rust_task::delete_all_stacks() {\n-    I(thread, !on_rust_stack());\n+    I(sched_loop, !on_rust_stack());\n     // Delete all the stacks. There may be more than one if the task failed\n     // and no landing pads stopped to clean up.\n-    I(thread, stk->next == NULL);\n+    I(sched_loop, stk->next == NULL);\n     while (stk != NULL) {\n         stk_seg *prev = stk->prev;\n         free_stack(stk);"}, {"sha": "f1c7ae0269985e3ba28695a03351a050a19792d7", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -112,7 +112,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     stk_seg *stk;\n     uintptr_t runtime_sp;      // Runtime sp while task running.\n     rust_scheduler *sched;\n-    rust_task_thread *thread;\n+    rust_sched_loop *sched_loop;\n \n     // Fields known only to the runtime.\n     rust_kernel *kernel;\n@@ -191,7 +191,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n public:\n \n     // Only a pointer to 'name' is kept, so it must live as long as this task.\n-    rust_task(rust_task_thread *thread,\n+    rust_task(rust_sched_loop *sched_loop,\n               rust_task_state state,\n               rust_task *spawner,\n               const char *name,\n@@ -312,7 +312,7 @@ rust_task::call_on_c_stack(void *args, void *fn_ptr) {\n     bool borrowed_a_c_stack = false;\n     uintptr_t sp;\n     if (c_stack == NULL) {\n-        c_stack = thread->borrow_c_stack();\n+        c_stack = sched_loop->borrow_c_stack();\n         next_c_sp = align_down(c_stack->end);\n         sp = next_c_sp;\n         borrowed_a_c_stack = true;\n@@ -335,8 +335,8 @@ inline void\n rust_task::call_on_rust_stack(void *args, void *fn_ptr) {\n     // Too expensive to check\n     // I(thread, !on_rust_stack());\n-    A(thread, get_sp_limit() != 0, \"Stack must be configured\");\n-    I(thread, next_rust_sp);\n+    A(sched_loop, get_sp_limit() != 0, \"Stack must be configured\");\n+    I(sched_loop, next_rust_sp);\n \n     bool had_reentered_rust_stack = reentered_rust_stack;\n     reentered_rust_stack = true;\n@@ -358,8 +358,8 @@ inline void\n rust_task::return_c_stack() {\n     // Too expensive to check\n     // I(thread, on_rust_stack());\n-    I(thread, c_stack != NULL);\n-    thread->return_c_stack(c_stack);\n+    I(sched_loop, c_stack != NULL);\n+    sched_loop->return_c_stack(c_stack);\n     c_stack = NULL;\n     next_c_sp = 0;\n }\n@@ -368,7 +368,7 @@ rust_task::return_c_stack() {\n inline void *\n rust_task::next_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n     new_stack_fast(stk_sz + args_sz);\n-    A(thread, stk->end - (uintptr_t)stk->data >= stk_sz + args_sz,\n+    A(sched_loop, stk->end - (uintptr_t)stk->data >= stk_sz + args_sz,\n       \"Did not receive enough stack\");\n     uint8_t *new_sp = (uint8_t*)stk->end;\n     // Push the function arguments to the new stack\n@@ -407,7 +407,7 @@ new_stack_slow(new_stack_args *args);\n inline void\n rust_task::new_stack_fast(size_t requested_sz) {\n     // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n-    size_t min_sz = thread->min_stack_size;\n+    size_t min_sz = sched_loop->min_stack_size;\n \n     // Try to reuse an existing stack segment\n     if (stk != NULL && stk->next != NULL) {\n@@ -438,8 +438,8 @@ record_sp_limit(void *limit);\n \n inline void\n rust_task::record_stack_limit() {\n-    I(thread, stk);\n-    A(thread,\n+    I(sched_loop, stk);\n+    A(sched_loop,\n       (uintptr_t)stk->end - RED_ZONE_SIZE\n       - (uintptr_t)stk->data >= LIMIT_OFFSET,\n       \"Stack size must be greater than LIMIT_OFFSET\");"}, {"sha": "def10eb9b210b1425c248c978352c735e6505d03", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -8,7 +8,7 @@\n \n #include \"rust_cc.h\"\n #include \"rust_internal.h\"\n-#include \"rust_task_thread.h\"\n+#include \"rust_sched_loop.h\"\n #include \"rust_unwind.h\"\n #include \"rust_upcall.h\"\n #include \"rust_util.h\"\n@@ -47,7 +47,7 @@ static void check_stack_alignment() { }\n inline void\n call_upcall_on_c_stack(void *args, void *fn_ptr) {\n     check_stack_alignment();\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->call_on_c_stack(args, fn_ptr);\n }\n \n@@ -62,7 +62,7 @@ extern \"C\" void record_sp_limit(void *limit);\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     // FIXME (1226) - The shim functions generated by rustc contain the\n     // morestack prologue, so we need to let them know they have enough\n@@ -85,7 +85,7 @@ upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_rust_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     // FIXME: Because of the hack in the other function that disables the\n     // stack limit when entering the C stack, here we restore the stack limit\n@@ -116,7 +116,7 @@ struct s_fail_args {\n \n extern \"C\" CDECL void\n upcall_s_fail(s_fail_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n     LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR,\n             args->expr, args->file, args->line);\n@@ -142,7 +142,7 @@ struct s_malloc_args {\n \n extern \"C\" CDECL void\n upcall_s_malloc(s_malloc_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem, \"upcall malloc(0x%\" PRIxPTR \")\", args->td);\n@@ -179,11 +179,11 @@ struct s_free_args {\n \n extern \"C\" CDECL void\n upcall_s_free(s_free_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n-    rust_task_thread *thread = task->thread;\n-    DLOG(thread, mem,\n+    rust_sched_loop *sched_loop = task->sched_loop;\n+    DLOG(sched_loop, mem,\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n              (uintptr_t)args->ptr);\n \n@@ -225,7 +225,7 @@ struct s_shared_malloc_args {\n \n extern \"C\" CDECL void\n upcall_s_shared_malloc(s_shared_malloc_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem, \"upcall shared_malloc(%\" PRIdPTR \")\", args->nbytes);\n@@ -253,11 +253,11 @@ struct s_shared_free_args {\n \n extern \"C\" CDECL void\n upcall_s_shared_free(s_shared_free_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n-    rust_task_thread *thread = task->thread;\n-    DLOG(thread, mem,\n+    rust_sched_loop *sched_loop = task->sched_loop;\n+    DLOG(sched_loop, mem,\n              \"upcall shared_free(0x%\" PRIxPTR\")\",\n              (uintptr_t)args->ptr);\n     task->kernel->free(args->ptr);\n@@ -277,7 +277,7 @@ struct s_shared_realloc_args {\n \n extern \"C\" CDECL void\n upcall_s_shared_realloc(s_shared_realloc_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n     args->retval = task->kernel->realloc(args->ptr, args->size);\n }\n@@ -298,7 +298,7 @@ struct s_vec_grow_args {\n \n extern \"C\" CDECL void\n upcall_s_vec_grow(s_vec_grow_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n     reserve_vec(task, args->vp, args->new_sz);\n     (*args->vp)->fill = args->new_sz;\n@@ -320,7 +320,7 @@ extern \"C\" CDECL void\n upcall_s_str_concat(s_str_concat_args *args) {\n     rust_vec *lhs = args->lhs;\n     rust_vec *rhs = args->rhs;\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     size_t fill = lhs->fill + rhs->fill - 1;\n     rust_vec* v = (rust_vec*)task->kernel->malloc(fill + sizeof(rust_vec),\n                                                   \"str_concat\");\n@@ -377,7 +377,7 @@ upcall_rust_personality(int version,\n     s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n                                     version, actions, exception_class,\n                                     ue_header, context};\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     // The personality function is run on the stack of the\n     // last function that threw or landed, which is going\n@@ -463,7 +463,7 @@ upcall_del_stack() {\n // needs to acquire the value of the stack pointer\n extern \"C\" CDECL void\n upcall_reset_stack_limit() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->reset_stack_limit();\n }\n "}, {"sha": "d759ed84ef342e70b87b9ab68e442b4535b27eb9", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -20,13 +20,13 @@ struct handle_data {\n // helpers\n static void*\n current_kernel_malloc(size_t size, const char* tag) {\n-  void* ptr = rust_task_thread::get_task()->kernel->malloc(size, tag);\n+  void* ptr = rust_sched_loop::get_task()->kernel->malloc(size, tag);\n   return ptr;\n }\n \n static void\n current_kernel_free(void* ptr) {\n-  rust_task_thread::get_task()->kernel->free(ptr);\n+  rust_sched_loop::get_task()->kernel->free(ptr);\n }\n \n static handle_data*"}, {"sha": "7500a9c3a19d24dca5b4a9b8f13ba1f9323c6c55", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -10,8 +10,15 @@\n \n #include \"lock_and_signal.h\"\n \n+// FIXME: This is not a portable way of specifying an invalid pthread_t\n+#define INVALID_THREAD 0\n+\n+\n #if defined(__WIN32__)\n lock_and_signal::lock_and_signal()\n+#if defined(DEBUG_LOCKS)\n+    : _holding_thread(INVALID_THREAD)\n+#endif\n {\n     _event = CreateEvent(NULL, FALSE, FALSE, NULL);\n \n@@ -31,6 +38,9 @@ lock_and_signal::lock_and_signal()\n \n #else\n lock_and_signal::lock_and_signal()\n+#if defined(DEBUG_LOCKS)\n+    : _holding_thread(INVALID_THREAD)\n+#endif\n {\n     CHECKED(pthread_cond_init(&_cond, NULL));\n     CHECKED(pthread_mutex_init(&_mutex, NULL));\n@@ -48,14 +58,25 @@ lock_and_signal::~lock_and_signal() {\n }\n \n void lock_and_signal::lock() {\n+    must_not_have_lock();\n #if defined(__WIN32__)\n     EnterCriticalSection(&_cs);\n+#if defined(DEBUG_LOCKS)\n+    _holding_thread = GetCurrentThreadId();\n+#endif\n #else\n     CHECKED(pthread_mutex_lock(&_mutex));\n+#if defined(DEBUG_LOCKS)\n+    _holding_thread = pthread_self();\n+#endif\n #endif\n }\n \n void lock_and_signal::unlock() {\n+    must_have_lock();\n+#if defined(DEBUG_LOCKS)\n+    _holding_thread = INVALID_THREAD;\n+#endif\n #if defined(__WIN32__)\n     LeaveCriticalSection(&_cs);\n #else\n@@ -67,12 +88,24 @@ void lock_and_signal::unlock() {\n  * Wait indefinitely until condition is signaled.\n  */\n void lock_and_signal::wait() {\n+    must_have_lock();\n+#if defined(DEBUG_LOCKS)\n+    _holding_thread = INVALID_THREAD;\n+#endif\n #if defined(__WIN32__)\n     LeaveCriticalSection(&_cs);\n     WaitForSingleObject(_event, INFINITE);\n     EnterCriticalSection(&_cs);\n+    must_not_be_locked();\n+#if defined(DEBUG_LOCKS)\n+    _holding_thread = GetCurrentThreadId();\n+#endif\n #else\n     CHECKED(pthread_cond_wait(&_cond, &_mutex));\n+    must_not_be_locked();\n+#if defined(DEBUG_LOCKS)\n+    _holding_thread = pthread_self();\n+#endif\n #endif\n }\n \n@@ -87,6 +120,32 @@ void lock_and_signal::signal() {\n #endif\n }\n \n+#if defined(DEBUG_LOCKS)\n+bool lock_and_signal::lock_held_by_current_thread()\n+{\n+#if defined(__WIN32__)\n+    return _holding_thread == GetCurrentThreadId();\n+#else\n+    return pthread_equal(_holding_thread, pthread_self());\n+#endif\n+}\n+#endif\n+\n+#if defined(DEBUG_LOCKS)\n+void lock_and_signal::must_have_lock() {\n+    assert(lock_held_by_current_thread() && \"must have lock\");\n+}\n+void lock_and_signal::must_not_have_lock() {\n+    assert(!lock_held_by_current_thread() && \"must not have lock\");\n+}\n+void lock_and_signal::must_not_be_locked() {\n+}\n+#else\n+void lock_and_signal::must_have_lock() { }\n+void lock_and_signal::must_not_have_lock() { }\n+void lock_and_signal::must_not_be_locked() { }\n+#endif\n+\n scoped_lock::scoped_lock(lock_and_signal &lock)\n     : lock(lock)\n {"}, {"sha": "fae9b1c24ea3e692b95fc9df17f68cdb28da7c34", "filename": "src/rt/sync/lock_and_signal.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Fsync%2Flock_and_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Fsync%2Flock_and_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -2,15 +2,31 @@\n #ifndef LOCK_AND_SIGNAL_H\n #define LOCK_AND_SIGNAL_H\n \n+#ifndef RUST_NDEBUG\n+#define DEBUG_LOCKS\n+#endif\n+\n class lock_and_signal {\n #if defined(__WIN32__)\n     HANDLE _event;\n     CRITICAL_SECTION _cs;\n+#if defined(DEBUG_LOCKS)\n+    DWORD _holding_thread;\n+#endif\n #else\n     pthread_cond_t _cond;\n     pthread_mutex_t _mutex;\n+#if defined(DEBUG_LOCKS)\n+    pthread_t _holding_thread;\n+#endif\n #endif\n \n+#if defined(DEBUG_LOCKS)\n+    bool lock_held_by_current_thread();\n+#endif\n+\n+    void must_not_be_locked();\n+\n public:\n     lock_and_signal();\n     virtual ~lock_and_signal();\n@@ -19,6 +35,9 @@ class lock_and_signal {\n     void unlock();\n     void wait();\n     void signal();\n+\n+    void must_have_lock();\n+    void must_not_have_lock();\n };\n \n class scoped_lock {"}, {"sha": "1a483b658c0da214bc3bb672563dd74473ac5e1e", "filename": "src/rt/sync/rust_thread.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Fsync%2Frust_thread.h", "raw_url": "https://github.com/rust-lang/rust/raw/e78396850d8e27138dd06e723de5ad3de0e65950/src%2Frt%2Fsync%2Frust_thread.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Frust_thread.h?ref=e78396850d8e27138dd06e723de5ad3de0e65950", "patch": "@@ -20,9 +20,7 @@ class rust_thread {\n \n     void start();\n \n-    virtual void run() {\n-        return;\n-    }\n+    virtual void run() = 0;\n \n     void join();\n     void detach();"}]}