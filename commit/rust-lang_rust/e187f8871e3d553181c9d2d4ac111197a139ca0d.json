{"sha": "e187f8871e3d553181c9d2d4ac111197a139ca0d", "node_id": "C_kwDOAAsO6NoAKGUxODdmODg3MWUzZDU1MzE4MWM5ZDJkNGFjMTExMTk3YTEzOWNhMGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-26T06:23:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-26T06:23:14Z"}, "message": "Auto merge of #107314 - matthiaskrgr:rollup-j40lnlj, r=matthiaskrgr\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #106407 (Improve proc macro attribute diagnostics)\n - #106960 (Teach parser to understand fake anonymous enum syntax)\n - #107085 (Custom MIR: Support binary and unary operations)\n - #107086 (Print PID holding bootstrap build lock on Linux)\n - #107175 (Fix escaping inference var ICE in `point_at_expr_source_of_inferred_type`)\n - #107204 (suggest qualifying bare associated constants)\n - #107248 (abi: add AddressSpace field to Primitive::Pointer )\n - #107272 (Implement ObjectSafe and WF in the new solver)\n - #107285 (Implement `Generator` and `Future` in the new solver)\n - #107286 (ICE in new solver if we see an inference variable)\n - #107313 (Add Style Team Triagebot config)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "36a4e98886543b61b772a7214906e1d09d1b2b46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36a4e98886543b61b772a7214906e1d09d1b2b46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e187f8871e3d553181c9d2d4ac111197a139ca0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e187f8871e3d553181c9d2d4ac111197a139ca0d", "html_url": "https://github.com/rust-lang/rust/commit/e187f8871e3d553181c9d2d4ac111197a139ca0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e187f8871e3d553181c9d2d4ac111197a139ca0d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "885bf628879310b885721e1fdd91ea2cbca9311f", "url": "https://api.github.com/repos/rust-lang/rust/commits/885bf628879310b885721e1fdd91ea2cbca9311f", "html_url": "https://github.com/rust-lang/rust/commit/885bf628879310b885721e1fdd91ea2cbca9311f"}, {"sha": "267d6265e20749b0ddd792523cac165ae1703974", "url": "https://api.github.com/repos/rust-lang/rust/commits/267d6265e20749b0ddd792523cac165ae1703974", "html_url": "https://github.com/rust-lang/rust/commit/267d6265e20749b0ddd792523cac165ae1703974"}], "stats": {"total": 2013, "additions": 1676, "deletions": 337}, "files": [{"sha": "6298d1e366bc62728c1679aabb7b984aa8eb75dd", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -351,7 +351,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap 4.1.3\",\n+ \"clap 4.1.4\",\n  \"crates-io\",\n  \"curl\",\n  \"curl-sys\",\n@@ -655,9 +655,9 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"4.1.3\"\n+version = \"4.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d8d93d855ce6a0aa87b8473ef9169482f40abaa2e9e0993024c35c902cbd5920\"\n+checksum = \"f13b9c79b5d1dd500d20ef541215a6423c75829ef43117e1b4d17fd8af0b5d76\"\n dependencies = [\n  \"bitflags\",\n  \"clap_derive 4.1.0\",\n@@ -675,7 +675,7 @@ version = \"4.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"10861370d2ba66b0f5989f83ebf35db6421713fd92351790e7fdd6c36774c56b\"\n dependencies = [\n- \"clap 4.1.3\",\n+ \"clap 4.1.4\",\n ]\n \n [[package]]\n@@ -2294,7 +2294,7 @@ name = \"jsondoclint\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap 4.1.3\",\n+ \"clap 4.1.4\",\n  \"fs-err\",\n  \"rustdoc-json-types\",\n  \"serde\",\n@@ -2557,7 +2557,7 @@ dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap 4.1.3\",\n+ \"clap 4.1.4\",\n  \"clap_complete\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.10.0\",\n@@ -3528,7 +3528,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 4.1.3\",\n+ \"clap 4.1.4\",\n  \"env_logger 0.7.1\",\n  \"mdbook\",\n ]"}, {"sha": "fe65ad9c6cb0e9bde1aaff6e4801ef2f2b8c964a", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -267,6 +267,9 @@ impl TargetDataLayout {\n                 [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n                 [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n                 [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n+                // FIXME(erikdesjardins): we should be parsing nonzero address spaces\n+                // this will require replacing TargetDataLayout::{pointer_size,pointer_align}\n+                // with e.g. `fn pointer_size_in(AddressSpace)`\n                 [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n                     dl.pointer_size = size(s, p)?;\n                     dl.pointer_align = align(a, p)?;\n@@ -861,7 +864,7 @@ pub enum Primitive {\n     Int(Integer, bool),\n     F32,\n     F64,\n-    Pointer,\n+    Pointer(AddressSpace),\n }\n \n impl Primitive {\n@@ -872,7 +875,10 @@ impl Primitive {\n             Int(i, _) => i.size(),\n             F32 => Size::from_bits(32),\n             F64 => Size::from_bits(64),\n-            Pointer => dl.pointer_size,\n+            // FIXME(erikdesjardins): ignoring address space is technically wrong, pointers in\n+            // different address spaces can have different sizes\n+            // (but TargetDataLayout doesn't currently parse that part of the DL string)\n+            Pointer(_) => dl.pointer_size,\n         }\n     }\n \n@@ -883,26 +889,12 @@ impl Primitive {\n             Int(i, _) => i.align(dl),\n             F32 => dl.f32_align,\n             F64 => dl.f64_align,\n-            Pointer => dl.pointer_align,\n+            // FIXME(erikdesjardins): ignoring address space is technically wrong, pointers in\n+            // different address spaces can have different alignments\n+            // (but TargetDataLayout doesn't currently parse that part of the DL string)\n+            Pointer(_) => dl.pointer_align,\n         }\n     }\n-\n-    // FIXME(eddyb) remove, it's trivial thanks to `matches!`.\n-    #[inline]\n-    pub fn is_float(self) -> bool {\n-        matches!(self, F32 | F64)\n-    }\n-\n-    // FIXME(eddyb) remove, it's completely unused.\n-    #[inline]\n-    pub fn is_int(self) -> bool {\n-        matches!(self, Int(..))\n-    }\n-\n-    #[inline]\n-    pub fn is_ptr(self) -> bool {\n-        matches!(self, Pointer)\n-    }\n }\n \n /// Inclusive wrap-around range of valid values, that is, if\n@@ -1188,7 +1180,8 @@ impl FieldsShape {\n /// An identifier that specifies the address space that some operation\n /// should operate on. Special address spaces have an effect on code generation,\n /// depending on the target and the address spaces it implements.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n pub struct AddressSpace(pub u32);\n \n impl AddressSpace {\n@@ -1468,7 +1461,6 @@ pub struct PointeeInfo {\n     pub size: Size,\n     pub align: Align,\n     pub safe: Option<PointerKind>,\n-    pub address_space: AddressSpace,\n }\n \n /// Used in `might_permit_raw_init` to indicate the kind of initialisation"}, {"sha": "feb5187536ffa5cbf97869f9334f6fcc69b0068d", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -400,8 +400,8 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Ref);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Tup(tuple_element_types) => {\n-            walk_list!(visitor, visit_ty, tuple_element_types);\n+        TyKind::Tup(tys) => {\n+            walk_list!(visitor, visit_ty, tys);\n         }\n         TyKind::BareFn(function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);"}, {"sha": "63ed10cdfcc59f59216c4f30d68eee45b4091d3f", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -35,7 +35,8 @@ pub(crate) fn scalar_to_clif_type(tcx: TyCtxt<'_>, scalar: Scalar) -> Type {\n         },\n         Primitive::F32 => types::F32,\n         Primitive::F64 => types::F64,\n-        Primitive::Pointer => pointer_ty(tcx),\n+        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+        Primitive::Pointer(_) => pointer_ty(tcx),\n     }\n }\n "}, {"sha": "e88c12716ecd3d240da161bd05e7c7900067a39b", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -709,7 +709,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         bx.range_metadata(load, vr);\n                     }\n                 }\n-                abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n+                abi::Pointer(_) if vr.start < vr.end && !vr.contains(0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}"}, {"sha": "c939da9cec3c21346be0ed6b5db214830bb858b1", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -211,7 +211,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 let base_addr = self.const_bitcast(base_addr, self.usize_type);\n                 let offset = self.context.new_rvalue_from_long(self.usize_type, offset.bytes() as i64);\n                 let ptr = self.const_bitcast(base_addr + offset, ptr_type);\n-                if layout.primitive() != Pointer {\n+                if !matches!(layout.primitive(), Pointer(_)) {\n                     self.const_bitcast(ptr.dereference(None).to_rvalue(), ty)\n                 }\n                 else {"}, {"sha": "dc41cb761b59c44b9e60d2567d3b5b5b276a315f", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -322,13 +322,16 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n             )\n             .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n+\n+        let address_space = cx.tcx.global_alloc(alloc_id).address_space(cx);\n+\n         llvals.push(cx.scalar_to_backend(\n             InterpScalar::from_pointer(\n                 interpret::Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            abi::Scalar::Initialized { value: Primitive::Pointer, valid_range: WrappingRange::full(dl.pointer_size) },\n-            cx.type_i8p(),\n+            abi::Scalar::Initialized { value: Primitive::Pointer(address_space), valid_range: WrappingRange::full(dl.pointer_size) },\n+            cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;\n     }"}, {"sha": "1326af670cde4e4cc78f3eb1e48eabb79eaf39bb", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -253,7 +253,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             Int(i, false) => cx.type_from_unsigned_integer(i),\n             F32 => cx.type_f32(),\n             F64 => cx.type_f64(),\n-            Pointer => {\n+            Pointer(address_space) => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee =\n                     if let Some(pointee) = self.pointee_info_at(cx, offset) {\n@@ -262,7 +262,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                     else {\n                         cx.type_i8()\n                     };\n-                cx.type_ptr_to(pointee)\n+                cx.type_ptr_to_ext(pointee, address_space)\n             }\n         }\n     }"}, {"sha": "d9f8170a3cffa0617172e93f5d0d5d4a0038efdd", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -849,14 +849,16 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n /// Helper function to get the LLVM type for a Scalar. Pointers are returned as\n /// the equivalent integer type.\n fn llvm_asm_scalar_type<'ll>(cx: &CodegenCx<'ll, '_>, scalar: Scalar) -> &'ll Type {\n+    let dl = &cx.tcx.data_layout;\n     match scalar.primitive() {\n         Primitive::Int(Integer::I8, _) => cx.type_i8(),\n         Primitive::Int(Integer::I16, _) => cx.type_i16(),\n         Primitive::Int(Integer::I32, _) => cx.type_i32(),\n         Primitive::Int(Integer::I64, _) => cx.type_i64(),\n         Primitive::F32 => cx.type_f32(),\n         Primitive::F64 => cx.type_f64(),\n-        Primitive::Pointer => cx.type_isize(),\n+        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+        Primitive::Pointer(_) => cx.type_from_integer(dl.ptr_sized_integer()),\n         _ => unreachable!(),\n     }\n }\n@@ -868,6 +870,7 @@ fn llvm_fixup_input<'ll, 'tcx>(\n     reg: InlineAsmRegClass,\n     layout: &TyAndLayout<'tcx>,\n ) -> &'ll Value {\n+    let dl = &bx.tcx.data_layout;\n     match (reg, layout.abi) {\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n             if let Primitive::Int(Integer::I8, _) = s.primitive() {\n@@ -881,8 +884,10 @@ fn llvm_fixup_input<'ll, 'tcx>(\n             let elem_ty = llvm_asm_scalar_type(bx.cx, s);\n             let count = 16 / layout.size.bytes();\n             let vec_ty = bx.cx.type_vector(elem_ty, count);\n-            if let Primitive::Pointer = s.primitive() {\n-                value = bx.ptrtoint(value, bx.cx.type_isize());\n+            // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+            if let Primitive::Pointer(_) = s.primitive() {\n+                let t = bx.type_from_integer(dl.ptr_sized_integer());\n+                value = bx.ptrtoint(value, t);\n             }\n             bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n         }\n@@ -958,7 +963,7 @@ fn llvm_fixup_output<'ll, 'tcx>(\n         }\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n             value = bx.extract_element(value, bx.const_i32(0));\n-            if let Primitive::Pointer = s.primitive() {\n+            if let Primitive::Pointer(_) = s.primitive() {\n                 value = bx.inttoptr(value, layout.llvm_type(bx.cx));\n             }\n             value"}, {"sha": "0f33b98548984877a230edeb0004e8ba403e7132", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -511,7 +511,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         bx.range_metadata(load, scalar.valid_range(bx));\n                     }\n                 }\n-                abi::Pointer => {\n+                abi::Pointer(_) => {\n                     if !scalar.valid_range(bx).contains(0) {\n                         bx.nonnull_metadata(load);\n                     }"}, {"sha": "edb1c160626ea7cf3a24b89e9d61541bbd887b17", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -236,7 +236,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             Scalar::Int(int) => {\n                 let data = int.assert_bits(layout.size(self));\n                 let llval = self.const_uint_big(self.type_ix(bitsize), data);\n-                if layout.primitive() == Pointer {\n+                if matches!(layout.primitive(), Pointer(_)) {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)\n@@ -284,7 +284,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         1,\n                     )\n                 };\n-                if layout.primitive() != Pointer {\n+                if !matches!(layout.primitive(), Pointer(_)) {\n                     unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)"}, {"sha": "cad3c5d87b73c6bf445a15a08bf8f99702f40e2f", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -13,17 +13,15 @@ use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ConstAllocation, ErrorHandled, GlobalAlloc, InitChunk, Pointer,\n+    read_target_uint, Allocation, ConstAllocation, ErrorHandled, InitChunk, Pointer,\n     Scalar as InterpScalar,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::Lto;\n-use rustc_target::abi::{\n-    AddressSpace, Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange,\n-};\n+use rustc_target::abi::{Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange};\n use std::ops::Range;\n \n pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n@@ -98,20 +96,15 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n \n-        let address_space = match cx.tcx.global_alloc(alloc_id) {\n-            GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n-            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) | GlobalAlloc::VTable(..) => {\n-                AddressSpace::DATA\n-            }\n-        };\n+        let address_space = cx.tcx.global_alloc(alloc_id).address_space(cx);\n \n         llvals.push(cx.scalar_to_backend(\n             InterpScalar::from_pointer(\n                 Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n             Scalar::Initialized {\n-                value: Primitive::Pointer,\n+                value: Primitive::Pointer(address_space),\n                 valid_range: WrappingRange::full(dl.pointer_size),\n             },\n             cx.type_i8p_ext(address_space),"}, {"sha": "54e850f25996b0d1894b038e197480f581ab630e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -122,7 +122,8 @@ fn tag_base_type<'ll, 'tcx>(\n                 Primitive::Int(t, _) => t,\n                 Primitive::F32 => Integer::I32,\n                 Primitive::F64 => Integer::I64,\n-                Primitive::Pointer => {\n+                // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                Primitive::Pointer(_) => {\n                     // If the niche is the NULL value of a reference, then `discr_enum_ty` will be\n                     // a RawPtr. CodeView doesn't know what to do with enums whose base type is a\n                     // pointer so we fix this up to just be `usize`."}, {"sha": "dd89c4c59c14d83e0ac639f5557e628b26ac17ff", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -149,7 +149,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                                     emit_va_arg(self, args[0], ret_ty)\n                                 }\n                             }\n-                            Primitive::F64 | Primitive::Pointer => {\n+                            Primitive::F64 | Primitive::Pointer(_) => {\n                                 emit_va_arg(self, args[0], ret_ty)\n                             }\n                             // `va_arg` should never be used with the return type f32."}, {"sha": "c73d233b767a41cb20720ebd1696a7a9ec0f04b0", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Ty, TypeVisitable};\n-use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n+use rustc_target::abi::{Abi, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{PointeeInfo, Scalar, Size, TyAbiInterface, Variants};\n use smallvec::{smallvec, SmallVec};\n@@ -312,14 +312,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             Int(i, _) => cx.type_from_integer(i),\n             F32 => cx.type_f32(),\n             F64 => cx.type_f64(),\n-            Pointer => {\n+            Pointer(address_space) => {\n                 // If we know the alignment, pick something better than i8.\n-                let (pointee, address_space) =\n-                    if let Some(pointee) = self.pointee_info_at(cx, offset) {\n-                        (cx.type_pointee_for_align(pointee.align), pointee.address_space)\n-                    } else {\n-                        (cx.type_i8(), AddressSpace::DATA)\n-                    };\n+                let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n+                    cx.type_pointee_for_align(pointee.align)\n+                } else {\n+                    cx.type_i8()\n+                };\n                 cx.type_ptr_to_ext(pointee, address_space)\n             }\n         }"}, {"sha": "2848ec1370670b2315c17d7424d17b9165ab4273", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -1801,8 +1801,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         match (src.layout.abi, dst.layout.abi) {\n             (abi::Abi::Scalar(src_scalar), abi::Abi::Scalar(dst_scalar)) => {\n                 // HACK(eddyb) LLVM doesn't like `bitcast`s between pointers and non-pointers.\n-                let src_is_ptr = src_scalar.primitive() == abi::Pointer;\n-                let dst_is_ptr = dst_scalar.primitive() == abi::Pointer;\n+                let src_is_ptr = matches!(src_scalar.primitive(), abi::Pointer(_));\n+                let dst_is_ptr = matches!(dst_scalar.primitive(), abi::Pointer(_));\n                 if src_is_ptr == dst_is_ptr {\n                     assert_eq!(src.layout.size, dst.layout.size);\n "}, {"sha": "cf02f59f67b97c3470c281d511ed4ade1390ec84", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, FieldsShape, Int, TagEncoding};\n+use rustc_target::abi::{Abi, Align, FieldsShape, Int, Pointer, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n #[derive(Copy, Clone, Debug)]\n@@ -209,6 +209,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         cast_to: Ty<'tcx>,\n     ) -> V {\n+        let dl = &bx.tcx().data_layout;\n         let cast_to_layout = bx.cx().layout_of(cast_to);\n         let cast_to_size = cast_to_layout.layout.size();\n         let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n@@ -250,12 +251,14 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n                 // Cast to an integer so we don't have to treat a pointer as a\n                 // special case.\n-                let (tag, tag_llty) = if tag_scalar.primitive().is_ptr() {\n-                    let t = bx.type_isize();\n-                    let tag = bx.ptrtoint(tag_imm, t);\n-                    (tag, t)\n-                } else {\n-                    (tag_imm, bx.cx().immediate_backend_type(tag_op.layout))\n+                let (tag, tag_llty) = match tag_scalar.primitive() {\n+                    // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                    Pointer(_) => {\n+                        let t = bx.type_from_integer(dl.ptr_sized_integer());\n+                        let tag = bx.ptrtoint(tag_imm, t);\n+                        (tag, t)\n+                    }\n+                    _ => (tag_imm, bx.cx().immediate_backend_type(tag_op.layout)),\n                 };\n \n                 let tag_size = tag_scalar.size(bx.cx());"}, {"sha": "a1b3985dce4e6ecfa27ff80b225e28e28f1d9d91", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -319,7 +319,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n                 let scalar = alloc.read_scalar(\n                     alloc_range(Size::ZERO, size),\n-                    /*read_provenance*/ s.is_ptr(),\n+                    /*read_provenance*/ matches!(s, abi::Pointer(_)),\n                 )?;\n                 Some(ImmTy { imm: scalar.into(), layout: mplace.layout })\n             }\n@@ -335,11 +335,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n                 let a_val = alloc.read_scalar(\n                     alloc_range(Size::ZERO, a_size),\n-                    /*read_provenance*/ a.is_ptr(),\n+                    /*read_provenance*/ matches!(a, abi::Pointer(_)),\n                 )?;\n                 let b_val = alloc.read_scalar(\n                     alloc_range(b_offset, b_size),\n-                    /*read_provenance*/ b.is_ptr(),\n+                    /*read_provenance*/ matches!(b, abi::Pointer(_)),\n                 )?;\n                 Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout })\n             }"}, {"sha": "0c2ab3d08f9dea13d6b1da74a346e231f40c9f6f", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -710,3 +710,24 @@ passes_ignored_derived_impls =\n       [one] trait {$trait_list}, but this is\n      *[other] traits {$trait_list}, but these are\n     } intentionally ignored during dead code analysis\n+\n+passes_proc_macro_typeerror = mismatched {$kind} signature\n+    .label = found {$found}, expected type `proc_macro::TokenStream`\n+    .note = {$kind}s must have a signature of `{$expected_signature}`\n+\n+passes_proc_macro_diff_arg_count = mismatched {$kind} signature\n+    .label = found unexpected {$count ->\n+      [one] argument\n+     *[other] arguments\n+    }\n+    .note = {$kind}s must have a signature of `{$expected_signature}`\n+\n+passes_proc_macro_missing_args = mismatched {$kind} signature\n+    .label = {$kind} must have {$expected_input_count ->\n+      [one] one argument\n+     *[other] two arguments\n+    } of type `proc_macro::TokenStream`\n+\n+passes_proc_macro_invalid_abi = proc macro functions may not be `extern \"{$abi}\"`\n+\n+passes_proc_macro_unsafe = proc macro functions may not be `unsafe`"}, {"sha": "a7b6a5c0331fc9722e126952c4198d309c27e86c", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_floating_point_literal(err, expr, expected)\n             || self.note_result_coercion(err, expr, expected, expr_ty);\n         if !suggested {\n-            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected);\n+            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected, expr.span);\n         }\n     }\n \n@@ -222,6 +222,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         found: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        mismatch_span: Span,\n     ) -> bool {\n         let map = self.tcx.hir();\n \n@@ -270,7 +271,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             lt_op: |_| self.tcx.lifetimes.re_erased,\n             ct_op: |c| c,\n             ty_op: |t| match *t.kind() {\n-                ty::Infer(ty::TyVar(vid)) => self.tcx.mk_ty_infer(ty::TyVar(self.root_var(vid))),\n+                ty::Infer(ty::TyVar(_)) => self.tcx.mk_ty_var(ty::TyVid::from_u32(0)),\n                 ty::Infer(ty::IntVar(_)) => {\n                     self.tcx.mk_ty_infer(ty::IntVar(ty::IntVid { index: 0 }))\n                 }\n@@ -281,7 +282,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         };\n         let mut prev = eraser.fold_ty(ty);\n-        let mut prev_span = None;\n+        let mut prev_span: Option<Span> = None;\n \n         for binding in expr_finder.uses {\n             // In every expression where the binding is referenced, we will look at that\n@@ -333,13 +334,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // inferred in this method call.\n                             let arg = &args[i];\n                             let arg_ty = self.node_ty(arg.hir_id);\n-                            err.span_label(\n-                                arg.span,\n-                                &format!(\n-                                    \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n-                                     inferred as `{ty}`\",\n-                                ),\n-                            );\n+                            if !arg.span.overlaps(mismatch_span) {\n+                                err.span_label(\n+                                    arg.span,\n+                                    &format!(\n+                                        \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n+                                        inferred as `{ty}`\",\n+                                    ),\n+                                );\n+                            }\n                             param_args.insert(param_ty, (arg, arg_ty));\n                         }\n                     }\n@@ -382,12 +385,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && self.can_eq(self.param_env, ty, found).is_ok()\n                 {\n                     // We only point at the first place where the found type was inferred.\n+                    if !segment.ident.span.overlaps(mismatch_span) {\n                     err.span_label(\n                         segment.ident.span,\n                         with_forced_trimmed_paths!(format!(\n                             \"here the type of `{ident}` is inferred to be `{ty}`\",\n                         )),\n-                    );\n+                    );}\n                     break;\n                 } else if !param_args.is_empty() {\n                     break;\n@@ -406,12 +410,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // We use the *previous* span because if the type is known *here* it means\n                     // it was *evaluated earlier*. We don't do this for method calls because we\n                     // evaluate the method's self type eagerly, but not in any other case.\n-                    err.span_label(\n-                        span,\n-                        with_forced_trimmed_paths!(format!(\n-                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                        )),\n-                    );\n+                    if !span.overlaps(mismatch_span) {\n+                        err.span_label(\n+                            span,\n+                            with_forced_trimmed_paths!(format!(\n+                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                            )),\n+                        );\n+                    }\n                     break;\n                 }\n                 prev = ty;"}, {"sha": "e78c76d5dde7031337b15a34272520d5438cebff", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -808,7 +808,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: full_call_span,\n                 });\n-                self.point_at_expr_source_of_inferred_type(&mut err, rcvr, expected, callee_ty);\n+                self.point_at_expr_source_of_inferred_type(\n+                    &mut err,\n+                    rcvr,\n+                    expected,\n+                    callee_ty,\n+                    provided_arg_span,\n+                );\n             }\n             // Call out where the function is defined\n             self.label_fn_like("}, {"sha": "2c76582f2ec8fbd14b9b911b4f922498a747b4d0", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -38,6 +38,7 @@ fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_transmute(&self, from: Ty<'tcx>, to: Ty<'tcx>, hir_id: HirId) {\n         let tcx = self.tcx;\n+        let dl = &tcx.data_layout;\n         let span = tcx.hir().span(hir_id);\n         let normalize = |ty| {\n             let ty = self.resolve_vars_if_possible(ty);\n@@ -69,7 +70,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Special-case transmuting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n             let from = unpack_option_like(tcx, from);\n-            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer.size(&tcx) {\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer(dl.instruction_address_space).size(&tcx) {\n                 struct_span_err!(tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n                     .note(&format!(\"source type: {from}\"))\n                     .note(&format!(\"target type: {to}\"))"}, {"sha": "b0975616b6151546773253fb88af57da891f678f", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -110,7 +110,7 @@ use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_serialize::{Decodable, Encodable};\n-use rustc_target::abi::Endian;\n+use rustc_target::abi::{AddressSpace, Endian, HasDataLayout};\n \n use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -438,6 +438,17 @@ impl<'tcx> GlobalAlloc<'tcx> {\n             _ => bug!(\"expected vtable, got {:?}\", self),\n         }\n     }\n+\n+    /// The address space that this `GlobalAlloc` should be placed in.\n+    #[inline]\n+    pub fn address_space(&self, cx: &impl HasDataLayout) -> AddressSpace {\n+        match self {\n+            GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n+            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) | GlobalAlloc::VTable(..) => {\n+                AddressSpace::DATA\n+            }\n+        }\n+    }\n }\n \n pub(crate) struct AllocMap<'tcx> {"}, {"sha": "66b9d96e69577606abaec0bd90a1c0be9a723761", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 110, "deletions": 112, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -128,7 +128,8 @@ impl PrimitiveExt for Primitive {\n             Int(i, signed) => i.to_ty(tcx, signed),\n             F32 => tcx.types.f32,\n             F64 => tcx.types.f64,\n-            Pointer => tcx.mk_mut_ptr(tcx.mk_unit()),\n+            // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+            Pointer(_) => tcx.mk_mut_ptr(tcx.mk_unit()),\n         }\n     }\n \n@@ -138,7 +139,11 @@ impl PrimitiveExt for Primitive {\n     fn to_int_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n-            Pointer => tcx.types.usize,\n+            // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+            Pointer(_) => {\n+                let signed = false;\n+                tcx.data_layout().ptr_sized_integer().to_ty(tcx, signed)\n+            }\n             F32 | F64 => bug!(\"floats do not have an int type\"),\n         }\n     }\n@@ -812,132 +817,125 @@ where\n         let tcx = cx.tcx();\n         let param_env = cx.param_env();\n \n-        let addr_space_of_ty = |ty: Ty<'tcx>| {\n-            if ty.is_fn() { cx.data_layout().instruction_address_space } else { AddressSpace::DATA }\n-        };\n-\n-        let pointee_info = match *this.ty.kind() {\n-            ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n-                    size: layout.size,\n-                    align: layout.align.abi,\n-                    safe: None,\n-                    address_space: addr_space_of_ty(mt.ty),\n-                })\n-            }\n-            ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n-                tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| PointeeInfo {\n-                    size: layout.size,\n-                    align: layout.align.abi,\n-                    safe: None,\n-                    address_space: cx.data_layout().instruction_address_space,\n-                })\n-            }\n-            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n-                let address_space = addr_space_of_ty(ty);\n-                let kind = if tcx.sess.opts.optimize == OptLevel::No {\n-                    // Use conservative pointer kind if not optimizing. This saves us the\n-                    // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n-                    // attributes in LLVM have compile-time cost even in unoptimized builds).\n-                    PointerKind::SharedMutable\n-                } else {\n-                    match mt {\n-                        hir::Mutability::Not => {\n-                            if ty.is_freeze(tcx, cx.param_env()) {\n-                                PointerKind::Frozen\n-                            } else {\n-                                PointerKind::SharedMutable\n+        let pointee_info =\n+            match *this.ty.kind() {\n+                ty::RawPtr(mt) if offset.bytes() == 0 => {\n+                    tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: None,\n+                    })\n+                }\n+                ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n+                    tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| {\n+                        PointeeInfo { size: layout.size, align: layout.align.abi, safe: None }\n+                    })\n+                }\n+                ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n+                    let kind = if tcx.sess.opts.optimize == OptLevel::No {\n+                        // Use conservative pointer kind if not optimizing. This saves us the\n+                        // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n+                        // attributes in LLVM have compile-time cost even in unoptimized builds).\n+                        PointerKind::SharedMutable\n+                    } else {\n+                        match mt {\n+                            hir::Mutability::Not => {\n+                                if ty.is_freeze(tcx, cx.param_env()) {\n+                                    PointerKind::Frozen\n+                                } else {\n+                                    PointerKind::SharedMutable\n+                                }\n                             }\n-                        }\n-                        hir::Mutability::Mut => {\n-                            // References to self-referential structures should not be considered\n-                            // noalias, as another pointer to the structure can be obtained, that\n-                            // is not based-on the original reference. We consider all !Unpin\n-                            // types to be potentially self-referential here.\n-                            if ty.is_unpin(tcx, cx.param_env()) {\n-                                PointerKind::UniqueBorrowed\n-                            } else {\n-                                PointerKind::UniqueBorrowedPinned\n+                            hir::Mutability::Mut => {\n+                                // References to self-referential structures should not be considered\n+                                // noalias, as another pointer to the structure can be obtained, that\n+                                // is not based-on the original reference. We consider all !Unpin\n+                                // types to be potentially self-referential here.\n+                                if ty.is_unpin(tcx, cx.param_env()) {\n+                                    PointerKind::UniqueBorrowed\n+                                } else {\n+                                    PointerKind::UniqueBorrowedPinned\n+                                }\n                             }\n                         }\n-                    }\n-                };\n+                    };\n \n-                tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n-                    size: layout.size,\n-                    align: layout.align.abi,\n-                    safe: Some(kind),\n-                    address_space,\n-                })\n-            }\n+                    tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: Some(kind),\n+                    })\n+                }\n \n-            _ => {\n-                let mut data_variant = match this.variants {\n-                    // Within the discriminant field, only the niche itself is\n-                    // always initialized, so we only check for a pointer at its\n-                    // offset.\n-                    //\n-                    // If the niche is a pointer, it's either valid (according\n-                    // to its type), or null (which the niche field's scalar\n-                    // validity range encodes). This allows using\n-                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n-                    // this will continue to work as long as we don't start\n-                    // using more niches than just null (e.g., the first page of\n-                    // the address space, or unaligned pointers).\n-                    Variants::Multiple {\n-                        tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n-                        tag_field,\n-                        ..\n-                    } if this.fields.offset(tag_field) == offset => {\n-                        Some(this.for_variant(cx, untagged_variant))\n-                    }\n-                    _ => Some(this),\n-                };\n+                _ => {\n+                    let mut data_variant = match this.variants {\n+                        // Within the discriminant field, only the niche itself is\n+                        // always initialized, so we only check for a pointer at its\n+                        // offset.\n+                        //\n+                        // If the niche is a pointer, it's either valid (according\n+                        // to its type), or null (which the niche field's scalar\n+                        // validity range encodes). This allows using\n+                        // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n+                        // this will continue to work as long as we don't start\n+                        // using more niches than just null (e.g., the first page of\n+                        // the address space, or unaligned pointers).\n+                        Variants::Multiple {\n+                            tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n+                            tag_field,\n+                            ..\n+                        } if this.fields.offset(tag_field) == offset => {\n+                            Some(this.for_variant(cx, untagged_variant))\n+                        }\n+                        _ => Some(this),\n+                    };\n \n-                if let Some(variant) = data_variant {\n-                    // We're not interested in any unions.\n-                    if let FieldsShape::Union(_) = variant.fields {\n-                        data_variant = None;\n+                    if let Some(variant) = data_variant {\n+                        // We're not interested in any unions.\n+                        if let FieldsShape::Union(_) = variant.fields {\n+                            data_variant = None;\n+                        }\n                     }\n-                }\n \n-                let mut result = None;\n-\n-                if let Some(variant) = data_variant {\n-                    let ptr_end = offset + Pointer.size(cx);\n-                    for i in 0..variant.fields.count() {\n-                        let field_start = variant.fields.offset(i);\n-                        if field_start <= offset {\n-                            let field = variant.field(cx, i);\n-                            result = field.to_result().ok().and_then(|field| {\n-                                if ptr_end <= field_start + field.size {\n-                                    // We found the right field, look inside it.\n-                                    let field_info =\n-                                        field.pointee_info_at(cx, offset - field_start);\n-                                    field_info\n-                                } else {\n-                                    None\n+                    let mut result = None;\n+\n+                    if let Some(variant) = data_variant {\n+                        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                        // (requires passing in the expected address space from the caller)\n+                        let ptr_end = offset + Pointer(AddressSpace::DATA).size(cx);\n+                        for i in 0..variant.fields.count() {\n+                            let field_start = variant.fields.offset(i);\n+                            if field_start <= offset {\n+                                let field = variant.field(cx, i);\n+                                result = field.to_result().ok().and_then(|field| {\n+                                    if ptr_end <= field_start + field.size {\n+                                        // We found the right field, look inside it.\n+                                        let field_info =\n+                                            field.pointee_info_at(cx, offset - field_start);\n+                                        field_info\n+                                    } else {\n+                                        None\n+                                    }\n+                                });\n+                                if result.is_some() {\n+                                    break;\n                                 }\n-                            });\n-                            if result.is_some() {\n-                                break;\n                             }\n                         }\n                     }\n-                }\n \n-                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n-                if let Some(ref mut pointee) = result {\n-                    if let ty::Adt(def, _) = this.ty.kind() {\n-                        if def.is_box() && offset.bytes() == 0 {\n-                            pointee.safe = Some(PointerKind::UniqueOwned);\n+                    // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n+                    if let Some(ref mut pointee) = result {\n+                        if let ty::Adt(def, _) = this.ty.kind() {\n+                            if def.is_box() && offset.bytes() == 0 {\n+                                pointee.safe = Some(PointerKind::UniqueOwned);\n+                            }\n                         }\n                     }\n-                }\n \n-                result\n-            }\n-        };\n+                    result\n+                }\n+            };\n \n         debug!(\n             \"pointee_info_at (offset={:?}, type kind: {:?}) => {:?}\","}, {"sha": "9840b95feefde42e52779b82f6b139f75b86feb3", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -147,6 +147,12 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             ExprKind::AddressOf { mutability, arg } => Ok(\n                 Rvalue::AddressOf(*mutability, self.parse_place(*arg)?)\n             ),\n+            ExprKind::Binary { op, lhs, rhs } =>  Ok(\n+                Rvalue::BinaryOp(*op, Box::new((self.parse_operand(*lhs)?, self.parse_operand(*rhs)?)))\n+            ),\n+            ExprKind::Unary { op, arg } => Ok(\n+                Rvalue::UnaryOp(*op, self.parse_operand(*arg)?)\n+            ),\n             _ => self.parse_operand(expr_id).map(Rvalue::Use),\n         )\n     }"}, {"sha": "eda7046c748e5f52121854349a3fa6f903e502d2", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -2372,7 +2372,7 @@ impl<'a> Parser<'a> {\n \n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n+    pub(crate) fn maybe_recover_colon_colon_in_pat_typo_or_anon_enum(\n         &mut self,\n         mut first_pat: P<Pat>,\n         expected: Expected,\n@@ -2383,26 +2383,41 @@ impl<'a> Parser<'a> {\n         if !matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n             || !self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n         {\n+            let mut snapshot_type = self.create_snapshot_for_diagnostic();\n+            snapshot_type.bump(); // `:`\n+            match snapshot_type.parse_ty() {\n+                Err(inner_err) => {\n+                    inner_err.cancel();\n+                }\n+                Ok(ty) => {\n+                    let Err(mut err) = self.expected_one_of_not_found(&[], &[]) else {\n+                        return first_pat;\n+                    };\n+                    err.span_label(ty.span, \"specifying the type of a pattern isn't supported\");\n+                    self.restore_snapshot(snapshot_type);\n+                    let span = first_pat.span.to(ty.span);\n+                    first_pat = self.mk_pat(span, PatKind::Wild);\n+                    err.emit();\n+                }\n+            }\n             return first_pat;\n         }\n         // The pattern looks like it might be a path with a `::` -> `:` typo:\n         // `match foo { bar:baz => {} }`\n-        let span = self.token.span;\n+        let colon_span = self.token.span;\n         // We only emit \"unexpected `:`\" error here if we can successfully parse the\n         // whole pattern correctly in that case.\n-        let snapshot = self.create_snapshot_for_diagnostic();\n+        let mut snapshot_pat = self.create_snapshot_for_diagnostic();\n+        let mut snapshot_type = self.create_snapshot_for_diagnostic();\n \n         // Create error for \"unexpected `:`\".\n         match self.expected_one_of_not_found(&[], &[]) {\n             Err(mut err) => {\n-                self.bump(); // Skip the `:`.\n-                match self.parse_pat_no_top_alt(expected) {\n+                snapshot_pat.bump(); // Skip the `:`.\n+                snapshot_type.bump(); // Skip the `:`.\n+                match snapshot_pat.parse_pat_no_top_alt(expected) {\n                     Err(inner_err) => {\n-                        // Carry on as if we had not done anything, callers will emit a\n-                        // reasonable error.\n                         inner_err.cancel();\n-                        err.cancel();\n-                        self.restore_snapshot(snapshot);\n                     }\n                     Ok(mut pat) => {\n                         // We've parsed the rest of the pattern.\n@@ -2466,22 +2481,33 @@ impl<'a> Parser<'a> {\n                             _ => {}\n                         }\n                         if show_sugg {\n-                            err.span_suggestion(\n-                                span,\n+                            err.span_suggestion_verbose(\n+                                colon_span.until(self.look_ahead(1, |t| t.span)),\n                                 \"maybe write a path separator here\",\n                                 \"::\",\n                                 Applicability::MaybeIncorrect,\n                             );\n                         } else {\n                             first_pat = self.mk_pat(new_span, PatKind::Wild);\n                         }\n-                        err.emit();\n+                        self.restore_snapshot(snapshot_pat);\n                     }\n                 }\n+                match snapshot_type.parse_ty() {\n+                    Err(inner_err) => {\n+                        inner_err.cancel();\n+                    }\n+                    Ok(ty) => {\n+                        err.span_label(ty.span, \"specifying the type of a pattern isn't supported\");\n+                        self.restore_snapshot(snapshot_type);\n+                        let new_span = first_pat.span.to(ty.span);\n+                        first_pat = self.mk_pat(new_span, PatKind::Wild);\n+                    }\n+                }\n+                err.emit();\n             }\n             _ => {\n                 // Carry on as if we had not done anything. This should be unreachable.\n-                self.restore_snapshot(snapshot);\n             }\n         };\n         first_pat"}, {"sha": "e5411538eea220ce5ff179026be98d677b08dc67", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -116,7 +116,8 @@ impl<'a> Parser<'a> {\n \n             // Check if the user wrote `foo:bar` instead of `foo::bar`.\n             if ra == RecoverColon::Yes {\n-                first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, expected);\n+                first_pat =\n+                    self.maybe_recover_colon_colon_in_pat_typo_or_anon_enum(first_pat, expected);\n             }\n \n             if let Some(leading_vert_span) = leading_vert_span {"}, {"sha": "25de0a9e75014ae019b680aedaf410e4563bcc5d", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -11,6 +11,7 @@ use rustc_ast::{\n     self as ast, BareFnTy, FnRetTy, GenericBound, GenericBounds, GenericParam, Generics, Lifetime,\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n };\n+use rustc_ast_pretty::pprust;\n use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -43,17 +44,24 @@ pub(super) enum AllowPlus {\n     No,\n }\n \n-#[derive(PartialEq)]\n+#[derive(PartialEq, Clone, Copy)]\n pub(super) enum RecoverQPath {\n     Yes,\n     No,\n }\n \n+#[derive(PartialEq, Clone, Copy)]\n pub(super) enum RecoverQuestionMark {\n     Yes,\n     No,\n }\n \n+#[derive(PartialEq, Clone, Copy)]\n+pub(super) enum RecoverAnonEnum {\n+    Yes,\n+    No,\n+}\n+\n /// Signals whether parsing a type should recover `->`.\n ///\n /// More specifically, when parsing a function like:\n@@ -86,7 +94,7 @@ impl RecoverReturnSign {\n }\n \n // Is `...` (`CVarArgs`) legal at this level of type parsing?\n-#[derive(PartialEq)]\n+#[derive(PartialEq, Clone, Copy)]\n enum AllowCVariadic {\n     Yes,\n     No,\n@@ -111,6 +119,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -125,6 +134,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             Some(ty_params),\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -139,6 +149,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::Yes,\n         )\n     }\n \n@@ -156,6 +167,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -169,6 +181,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::No,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -180,6 +193,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::No,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -192,6 +206,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::OnlyFatArrow,\n             None,\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -211,6 +226,7 @@ impl<'a> Parser<'a> {\n                 recover_return_sign,\n                 None,\n                 RecoverQuestionMark::Yes,\n+                RecoverAnonEnum::Yes,\n             )?;\n             FnRetTy::Ty(ty)\n         } else if recover_return_sign.can_recover(&self.token.kind) {\n@@ -232,6 +248,7 @@ impl<'a> Parser<'a> {\n                 recover_return_sign,\n                 None,\n                 RecoverQuestionMark::Yes,\n+                RecoverAnonEnum::Yes,\n             )?;\n             FnRetTy::Ty(ty)\n         } else {\n@@ -247,6 +264,7 @@ impl<'a> Parser<'a> {\n         recover_return_sign: RecoverReturnSign,\n         ty_generics: Option<&Generics>,\n         recover_question_mark: RecoverQuestionMark,\n+        recover_anon_enum: RecoverAnonEnum,\n     ) -> PResult<'a, P<Ty>> {\n         let allow_qpath_recovery = recover_qpath == RecoverQPath::Yes;\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n@@ -325,14 +343,55 @@ impl<'a> Parser<'a> {\n         let mut ty = self.mk_ty(span, kind);\n \n         // Try to recover from use of `+` with incorrect priority.\n-        if matches!(allow_plus, AllowPlus::Yes) {\n+        if allow_plus == AllowPlus::Yes {\n             self.maybe_recover_from_bad_type_plus(&ty)?;\n         } else {\n             self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty);\n         }\n-        if let RecoverQuestionMark::Yes = recover_question_mark {\n+        if RecoverQuestionMark::Yes == recover_question_mark {\n             ty = self.maybe_recover_from_question_mark(ty);\n         }\n+        if recover_anon_enum == RecoverAnonEnum::Yes\n+            && self.check_noexpect(&token::BinOp(token::Or))\n+            && self.look_ahead(1, |t| t.can_begin_type())\n+        {\n+            let mut pipes = vec![self.token.span];\n+            let mut types = vec![ty];\n+            loop {\n+                if !self.eat(&token::BinOp(token::Or)) {\n+                    break;\n+                }\n+                pipes.push(self.prev_token.span);\n+                types.push(self.parse_ty_common(\n+                    allow_plus,\n+                    allow_c_variadic,\n+                    recover_qpath,\n+                    recover_return_sign,\n+                    ty_generics,\n+                    recover_question_mark,\n+                    RecoverAnonEnum::No,\n+                )?);\n+            }\n+            let mut err = self.struct_span_err(pipes, \"anonymous enums are not supported\");\n+            for ty in &types {\n+                err.span_label(ty.span, \"\");\n+            }\n+            err.help(&format!(\n+                \"create a named `enum` and use it here instead:\\nenum Name {{\\n{}\\n}}\",\n+                types\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, t)| format!(\n+                        \"    Variant{}({}),\",\n+                        i + 1, // Lets not confuse people with zero-indexing :)\n+                        pprust::to_string(|s| s.print_type(&t)),\n+                    ))\n+                    .collect::<Vec<_>>()\n+                    .join(\"\\n\"),\n+            ));\n+            err.emit();\n+            return Ok(self.mk_ty(lo.to(self.prev_token.span), TyKind::Err));\n+        }\n         if allow_qpath_recovery { self.maybe_recover_from_bad_qpath(ty) } else { Ok(ty) }\n     }\n "}, {"sha": "42329853259459ead163c2e4e7c70fc28084be19", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 140, "deletions": 6, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -6,11 +6,12 @@\n \n use crate::errors::{\n     self, AttrApplication, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel, ObjectLifetimeErr,\n-    OnlyHasEffectOn, TransparentIncompatible, UnrecognizedReprHint,\n+    OnlyHasEffectOn, ProcMacroDiffArguments, ProcMacroInvalidAbi, ProcMacroMissingArguments,\n+    ProcMacroTypeError, ProcMacroUnsafe, TransparentIncompatible, UnrecognizedReprHint,\n };\n use rustc_ast::{ast, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{fluent, Applicability, MultiSpan};\n+use rustc_errors::{fluent, Applicability, IntoDiagnosticArg, MultiSpan};\n use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n@@ -19,18 +20,20 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{\n     self, FnSig, ForeignItem, HirId, Item, ItemKind, TraitItem, CRATE_HIR_ID, CRATE_OWNER_ID,\n };\n-use rustc_hir::{MethodKind, Target};\n+use rustc_hir::{MethodKind, Target, Unsafety};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_session::lint::builtin::{\n     CONFLICTING_REPR_HINTS, INVALID_DOC_ATTRIBUTES, UNUSED_ATTRIBUTES,\n };\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n+use std::cell::Cell;\n use std::collections::hash_map::Entry;\n \n pub(crate) fn target_from_impl_item<'tcx>(\n@@ -62,8 +65,29 @@ enum ItemLike<'tcx> {\n     ForeignItem,\n }\n \n+#[derive(Copy, Clone)]\n+pub(crate) enum ProcMacroKind {\n+    FunctionLike,\n+    Derive,\n+    Attribute,\n+}\n+\n+impl IntoDiagnosticArg for ProcMacroKind {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        match self {\n+            ProcMacroKind::Attribute => \"attribute proc macro\",\n+            ProcMacroKind::Derive => \"derive proc macro\",\n+            ProcMacroKind::FunctionLike => \"function-like proc macro\",\n+        }\n+        .into_diagnostic_arg()\n+    }\n+}\n+\n struct CheckAttrVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n+\n+    // Whether or not this visitor should abort after finding errors\n+    abort: Cell<bool>,\n }\n \n impl CheckAttrVisitor<'_> {\n@@ -173,7 +197,7 @@ impl CheckAttrVisitor<'_> {\n                 sym::path => self.check_generic_attr(hir_id, attr, target, Target::Mod),\n                 sym::plugin_registrar => self.check_plugin_registrar(hir_id, attr, target),\n                 sym::macro_export => self.check_macro_export(hir_id, attr, target),\n-                sym::ignore | sym::should_panic | sym::proc_macro_derive => {\n+                sym::ignore | sym::should_panic => {\n                     self.check_generic_attr(hir_id, attr, target, Target::Fn)\n                 }\n                 sym::automatically_derived => {\n@@ -183,6 +207,16 @@ impl CheckAttrVisitor<'_> {\n                     self.check_generic_attr(hir_id, attr, target, Target::Mod)\n                 }\n                 sym::rustc_object_lifetime_default => self.check_object_lifetime_default(hir_id),\n+                sym::proc_macro => {\n+                    self.check_proc_macro(hir_id, target, ProcMacroKind::FunctionLike)\n+                }\n+                sym::proc_macro_attribute => {\n+                    self.check_proc_macro(hir_id, target, ProcMacroKind::Attribute);\n+                }\n+                sym::proc_macro_derive => {\n+                    self.check_generic_attr(hir_id, attr, target, Target::Fn);\n+                    self.check_proc_macro(hir_id, target, ProcMacroKind::Derive)\n+                }\n                 _ => {}\n             }\n \n@@ -2063,6 +2097,103 @@ impl CheckAttrVisitor<'_> {\n             errors::Unused { attr_span: attr.span, note },\n         );\n     }\n+\n+    /// A best effort attempt to create an error for a mismatching proc macro signature.\n+    ///\n+    /// If this best effort goes wrong, it will just emit a worse error later (see #102923)\n+    fn check_proc_macro(&self, hir_id: HirId, target: Target, kind: ProcMacroKind) {\n+        let expected_input_count = match kind {\n+            ProcMacroKind::Attribute => 2,\n+            ProcMacroKind::Derive | ProcMacroKind::FunctionLike => 1,\n+        };\n+\n+        let expected_signature = match kind {\n+            ProcMacroKind::Attribute => \"fn(TokenStream, TokenStream) -> TokenStream\",\n+            ProcMacroKind::Derive | ProcMacroKind::FunctionLike => \"fn(TokenStream) -> TokenStream\",\n+        };\n+\n+        let tcx = self.tcx;\n+        if target == Target::Fn {\n+            let Some(tokenstream) = tcx.get_diagnostic_item(sym::TokenStream) else {return};\n+            let tokenstream = tcx.type_of(tokenstream);\n+\n+            let id = hir_id.expect_owner();\n+            let hir_sig = tcx.hir().fn_sig_by_hir_id(hir_id).unwrap();\n+\n+            let sig = tcx.liberate_late_bound_regions(id.to_def_id(), tcx.fn_sig(id));\n+            let sig = tcx.normalize_erasing_regions(ParamEnv::empty(), sig);\n+\n+            // We don't currently require that the function signature is equal to\n+            // `fn(TokenStream) -> TokenStream`, but instead monomorphizes to\n+            // `fn(TokenStream) -> TokenStream` after some substitution of generic arguments.\n+            //\n+            // Properly checking this means pulling in additional `rustc` crates, so we don't.\n+            let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n+\n+            if sig.abi != Abi::Rust {\n+                tcx.sess.emit_err(ProcMacroInvalidAbi { span: hir_sig.span, abi: sig.abi.name() });\n+                self.abort.set(true);\n+            }\n+\n+            if sig.unsafety == Unsafety::Unsafe {\n+                tcx.sess.emit_err(ProcMacroUnsafe { span: hir_sig.span });\n+                self.abort.set(true);\n+            }\n+\n+            let output = sig.output();\n+\n+            // Typecheck the output\n+            if !drcx.types_may_unify(output, tokenstream) {\n+                tcx.sess.emit_err(ProcMacroTypeError {\n+                    span: hir_sig.decl.output.span(),\n+                    found: output,\n+                    kind,\n+                    expected_signature,\n+                });\n+                self.abort.set(true);\n+            }\n+\n+            if sig.inputs().len() < expected_input_count {\n+                tcx.sess.emit_err(ProcMacroMissingArguments {\n+                    expected_input_count,\n+                    span: hir_sig.span,\n+                    kind,\n+                    expected_signature,\n+                });\n+                self.abort.set(true);\n+            }\n+\n+            // Check that the inputs are correct, if there are enough.\n+            if sig.inputs().len() >= expected_input_count {\n+                for (arg, input) in\n+                    sig.inputs().iter().zip(hir_sig.decl.inputs).take(expected_input_count)\n+                {\n+                    if !drcx.types_may_unify(*arg, tokenstream) {\n+                        tcx.sess.emit_err(ProcMacroTypeError {\n+                            span: input.span,\n+                            found: *arg,\n+                            kind,\n+                            expected_signature,\n+                        });\n+                        self.abort.set(true);\n+                    }\n+                }\n+            }\n+\n+            // Check that there are not too many arguments\n+            let body_id = tcx.hir().body_owned_by(id.def_id);\n+            let excess = tcx.hir().body(body_id).params.get(expected_input_count..);\n+            if let Some(excess @ [begin @ end] | excess @ [begin, .., end]) = excess {\n+                tcx.sess.emit_err(ProcMacroDiffArguments {\n+                    span: begin.span.to(end.span),\n+                    count: excess.len(),\n+                    kind,\n+                    expected_signature,\n+                });\n+                self.abort.set(true);\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n@@ -2225,12 +2356,15 @@ fn check_non_exported_macro_for_invalid_attrs(tcx: TyCtxt<'_>, item: &Item<'_>)\n }\n \n fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    let check_attr_visitor = &mut CheckAttrVisitor { tcx };\n+    let check_attr_visitor = &mut CheckAttrVisitor { tcx, abort: Cell::new(false) };\n     tcx.hir().visit_item_likes_in_module(module_def_id, check_attr_visitor);\n     if module_def_id.is_top_level_module() {\n         check_attr_visitor.check_attributes(CRATE_HIR_ID, DUMMY_SP, Target::Mod, None);\n         check_invalid_crate_level_attr(tcx, tcx.hir().krate_attrs());\n     }\n+    if check_attr_visitor.abort.get() {\n+        tcx.sess.abort_if_errors()\n+    }\n }\n \n pub(crate) fn provide(providers: &mut Providers) {"}, {"sha": "9e05ad22e624172681d1b249710a71f669297cbf", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -12,6 +12,7 @@ use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_middle::ty::{MainDefinition, Ty};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n \n+use crate::check_attr::ProcMacroKind;\n use crate::lang_items::Duplicate;\n \n #[derive(Diagnostic)]\n@@ -1515,3 +1516,52 @@ pub struct ChangeFieldsToBeOfUnitType {\n     #[suggestion_part(code = \"()\")]\n     pub spans: Vec<Span>,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_proc_macro_typeerror)]\n+#[note]\n+pub(crate) struct ProcMacroTypeError<'tcx> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub found: Ty<'tcx>,\n+    pub kind: ProcMacroKind,\n+    pub expected_signature: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_proc_macro_diff_arg_count)]\n+pub(crate) struct ProcMacroDiffArguments {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub count: usize,\n+    pub kind: ProcMacroKind,\n+    pub expected_signature: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_proc_macro_missing_args)]\n+pub(crate) struct ProcMacroMissingArguments {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub expected_input_count: usize,\n+    pub kind: ProcMacroKind,\n+    pub expected_signature: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_proc_macro_invalid_abi)]\n+pub(crate) struct ProcMacroInvalidAbi {\n+    #[primary_span]\n+    pub span: Span,\n+    pub abi: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_proc_macro_unsafe)]\n+pub(crate) struct ProcMacroUnsafe {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "37beff37c1fb9d988c33ae968afa86fb96370603", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -227,20 +227,27 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     && let Some(FnCtxt::Assoc(_)) = fn_kind.ctxt()\n                     && let Some(items) = self.diagnostic_metadata.current_impl_items\n                     && let Some(item) = items.iter().find(|i| {\n-                        if let AssocItemKind::Fn(_) = &i.kind && i.ident.name == item_str.name\n+                        if let AssocItemKind::Fn(..) | AssocItemKind::Const(..) = &i.kind\n+                            && i.ident.name == item_str.name\n                         {\n                             debug!(?item_str.name);\n                             return true\n                         }\n                         false\n                     })\n-                    && let AssocItemKind::Fn(fn_) = &item.kind\n                 {\n-                    debug!(?fn_);\n-                    let self_sugg = if fn_.sig.decl.has_self() { \"self.\" } else { \"Self::\" };\n+                    let self_sugg = match &item.kind {\n+                        AssocItemKind::Fn(fn_) if fn_.sig.decl.has_self() => \"self.\",\n+                        _ => \"Self::\",\n+                    };\n+\n                     Some((\n                         item_span.shrink_to_lo(),\n-                        \"consider using the associated function\",\n+                        match &item.kind {\n+                            AssocItemKind::Fn(..) => \"consider using the associated function\",\n+                            AssocItemKind::Const(..) => \"consider using the associated constant\",\n+                            _ => unreachable!(\"item kind was filtered above\"),\n+                        },\n                         self_sugg.to_string()\n                     ))\n                 } else {"}, {"sha": "2bccd46b08fcf799f191a95282791ff8421e4892", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -288,6 +288,7 @@ symbols! {\n         Target,\n         ToOwned,\n         ToString,\n+        TokenStream,\n         Try,\n         TryCaptureGeneric,\n         TryCapturePrintable,"}, {"sha": "247256f076ba9b195c6cbe1286387b4ba7a9c3f8", "filename": "compiler/rustc_target/src/abi/call/loongarch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -39,7 +39,7 @@ where\n {\n     match arg_layout.abi {\n         Abi::Scalar(scalar) => match scalar.primitive() {\n-            abi::Int(..) | abi::Pointer => {\n+            abi::Int(..) | abi::Pointer(_) => {\n                 if arg_layout.size.bits() > xlen {\n                     return Err(CannotUseFpConv);\n                 }"}, {"sha": "a0730fbb650dc9b4527882bbe232afa1ed17201b", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -346,7 +346,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             // The primitive for this algorithm.\n             Abi::Scalar(scalar) => {\n                 let kind = match scalar.primitive() {\n-                    abi::Int(..) | abi::Pointer => RegKind::Integer,\n+                    abi::Int(..) | abi::Pointer(_) => RegKind::Integer,\n                     abi::F32 | abi::F64 => RegKind::Float,\n                 };\n                 Ok(HomogeneousAggregate::Homogeneous(Reg { kind, size: self.size }))"}, {"sha": "d90dce2a08785cbd2e6995bfb5f16fd9acc77f7d", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -45,7 +45,7 @@ where\n {\n     match arg_layout.abi {\n         Abi::Scalar(scalar) => match scalar.primitive() {\n-            abi::Int(..) | abi::Pointer => {\n+            abi::Int(..) | abi::Pointer(_) => {\n                 if arg_layout.size.bits() > xlen {\n                     return Err(CannotUseFpConv);\n                 }"}, {"sha": "cbed5b4afc134931a0ba5851f90218399775b5b4", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -20,7 +20,7 @@ where\n {\n     let dl = cx.data_layout();\n \n-    if !scalar.primitive().is_float() {\n+    if !matches!(scalar.primitive(), abi::F32 | abi::F64) {\n         return data;\n     }\n \n@@ -83,11 +83,11 @@ where\n         (abi::F32, _) => offset += Reg::f32().size,\n         (_, abi::F64) => offset += Reg::f64().size,\n         (abi::Int(i, _signed), _) => offset += i.size(),\n-        (abi::Pointer, _) => offset += Reg::i64().size,\n+        (abi::Pointer(_), _) => offset += Reg::i64().size,\n         _ => {}\n     }\n \n-    if (offset.bytes() % 4) != 0 && scalar2.primitive().is_float() {\n+    if (offset.bytes() % 4) != 0 && matches!(scalar2.primitive(), abi::F32 | abi::F64) {\n         offset += Size::from_bytes(4 - (offset.bytes() % 4));\n     }\n     data = arg_scalar(cx, scalar2, offset, data);"}, {"sha": "9427f27d1b7bb327893a287c1d83db37822159b3", "filename": "compiler/rustc_target/src/abi/call/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -50,7 +50,7 @@ where\n             Abi::Uninhabited => return Ok(()),\n \n             Abi::Scalar(scalar) => match scalar.primitive() {\n-                abi::Int(..) | abi::Pointer => Class::Int,\n+                abi::Int(..) | abi::Pointer(_) => Class::Int,\n                 abi::F32 | abi::F64 => Class::Sse,\n             },\n "}, {"sha": "39761baf1bc2919401d823dc4d17aaae56d59195", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -129,7 +129,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         C: HasDataLayout,\n     {\n         match self.abi {\n-            Abi::Scalar(scalar) => scalar.primitive().is_float(),\n+            Abi::Scalar(scalar) => matches!(scalar.primitive(), F32 | F64),\n             Abi::Aggregate { .. } => {\n                 if self.fields.count() == 1 && self.fields.offset(0).bytes() == 0 {\n                     self.field(cx, 0).is_single_fp_element(cx)"}, {"sha": "d23b550621e17421ce179a63a98a4445ec4f3402", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -138,6 +138,16 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_future_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_generator_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -266,6 +276,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_tuple_candidate(self, goal)\n         } else if lang_items.pointee_trait() == Some(trait_def_id) {\n             G::consider_builtin_pointee_candidate(self, goal)\n+        } else if lang_items.future_trait() == Some(trait_def_id) {\n+            G::consider_builtin_future_candidate(self, goal)\n+        } else if lang_items.gen_trait() == Some(trait_def_id) {\n+            G::consider_builtin_generator_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };\n@@ -321,9 +335,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             | ty::Tuple(_)\n             | ty::Param(_)\n             | ty::Placeholder(..)\n-            | ty::Infer(_)\n+            | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Error(_) => return,\n-            ty::Bound(..) => bug!(\"unexpected bound type: {goal:?}\"),\n+            ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_))\n+            | ty::Bound(..) => bug!(\"unexpected self type for `{goal:?}`\"),\n             ty::Alias(_, alias_ty) => alias_ty,\n         };\n \n@@ -371,9 +386,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             | ty::Tuple(_)\n             | ty::Param(_)\n             | ty::Placeholder(..)\n-            | ty::Infer(_)\n+            | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Error(_) => return,\n-            ty::Bound(..) => bug!(\"unexpected bound type: {goal:?}\"),\n+            ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_))\n+            | ty::Bound(..) => bug!(\"unexpected self type for `{goal:?}`\"),\n             ty::Dynamic(bounds, ..) => bounds,\n         };\n "}, {"sha": "278024b22760a754a8634d5cd16b58f583948da6", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 57, "deletions": 10, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -1,13 +1,14 @@\n use std::mem;\n \n-use super::{Certainty, InferCtxtEvalExt};\n-use rustc_infer::{\n-    infer::InferCtxt,\n-    traits::{\n-        query::NoSolution, FulfillmentError, FulfillmentErrorCode, PredicateObligation,\n-        SelectionError, TraitEngine,\n-    },\n+use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::{\n+    query::NoSolution, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n+    PredicateObligation, SelectionError, TraitEngine,\n };\n+use rustc_middle::ty;\n+use rustc_middle::ty::error::{ExpectedFound, TypeError};\n+\n+use super::{Certainty, InferCtxtEvalExt};\n \n /// A trait engine using the new trait solver.\n ///\n@@ -70,9 +71,55 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n                             obligation: obligation.clone(),\n-                            code: FulfillmentErrorCode::CodeSelectionError(\n-                                SelectionError::Unimplemented,\n-                            ),\n+                            code: match goal.predicate.kind().skip_binder() {\n+                                ty::PredicateKind::Clause(ty::Clause::Projection(_)) => {\n+                                    FulfillmentErrorCode::CodeProjectionError(\n+                                        // FIXME: This could be a `Sorts` if the term is a type\n+                                        MismatchedProjectionTypes { err: TypeError::Mismatch },\n+                                    )\n+                                }\n+                                ty::PredicateKind::Subtype(pred) => {\n+                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                        goal.predicate.kind().rebind((pred.a, pred.b)),\n+                                    );\n+                                    let expected_found = ExpectedFound::new(true, a, b);\n+                                    FulfillmentErrorCode::CodeSubtypeError(\n+                                        expected_found,\n+                                        TypeError::Sorts(expected_found),\n+                                    )\n+                                }\n+                                ty::PredicateKind::Coerce(pred) => {\n+                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                        goal.predicate.kind().rebind((pred.a, pred.b)),\n+                                    );\n+                                    let expected_found = ExpectedFound::new(false, a, b);\n+                                    FulfillmentErrorCode::CodeSubtypeError(\n+                                        expected_found,\n+                                        TypeError::Sorts(expected_found),\n+                                    )\n+                                }\n+                                ty::PredicateKind::ConstEquate(a, b) => {\n+                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                        goal.predicate.kind().rebind((a, b)),\n+                                    );\n+                                    let expected_found = ExpectedFound::new(true, a, b);\n+                                    FulfillmentErrorCode::CodeConstEquateError(\n+                                        expected_found,\n+                                        TypeError::ConstMismatch(expected_found),\n+                                    )\n+                                }\n+                                ty::PredicateKind::Clause(_)\n+                                | ty::PredicateKind::WellFormed(_)\n+                                | ty::PredicateKind::ObjectSafe(_)\n+                                | ty::PredicateKind::ClosureKind(_, _, _)\n+                                | ty::PredicateKind::ConstEvaluatable(_)\n+                                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n+                                | ty::PredicateKind::Ambiguous => {\n+                                    FulfillmentErrorCode::CodeSelectionError(\n+                                        SelectionError::Unimplemented,\n+                                    )\n+                                }\n+                            },\n                             root_obligation: obligation,\n                         });\n                         continue;"}, {"sha": "f44648c95d742530298274dc3467dc6645e127e6", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -277,12 +277,15 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                         param_env,\n                         predicate: (def_id, substs, kind),\n                     }),\n+                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                    self.compute_object_safe_goal(trait_def_id)\n+                }\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n+                }\n                 ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::AMBIGUOUS),\n                 // FIXME: implement these predicates :)\n-                ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::ObjectSafe(_)\n-                | ty::PredicateKind::ConstEvaluatable(_)\n-                | ty::PredicateKind::ConstEquate(_, _) => {\n+                ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n                     self.make_canonical_response(Certainty::Yes)\n                 }\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n@@ -362,6 +365,32 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             Err(NoSolution)\n         }\n     }\n+\n+    fn compute_object_safe_goal(&mut self, trait_def_id: DefId) -> QueryResult<'tcx> {\n+        if self.tcx().is_object_safe(trait_def_id) {\n+            self.make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n+    fn compute_well_formed_goal(\n+        &mut self,\n+        goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        self.infcx.probe(|_| {\n+            match crate::traits::wf::unnormalized_obligations(\n+                self.infcx,\n+                goal.param_env,\n+                goal.predicate,\n+            ) {\n+                Some(obligations) => self.evaluate_all_and_make_canonical_response(\n+                    obligations.into_iter().map(|o| o.into()).collect(),\n+                ),\n+                None => self.make_canonical_response(Certainty::AMBIGUOUS),\n+            }\n+        })\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "b583705ac43693a6619c1776ce1df2efe37bea02", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ProjectionPredicate, TypeSuperVisitable, TypeVisitor};\n use rustc_middle::ty::{ToPredicate, TypeVisitable};\n-use rustc_span::DUMMY_SP;\n+use rustc_span::{sym, DUMMY_SP};\n use std::iter;\n use std::ops::ControlFlow;\n \n@@ -427,7 +427,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         .subst(tcx, &[ty::GenericArg::from(goal.predicate.self_ty())])\n                 }\n \n-                ty::Infer(ty::TyVar(..)) | ty::Alias(_, _) | ty::Param(_) | ty::Placeholder(..) => {\n+                ty::Alias(_, _) | ty::Param(_) | ty::Placeholder(..) => {\n                     // FIXME(ptr_metadata): It would also be possible to return a `Ok(Ambig)` with no constraints.\n                     let sized_predicate = ty::Binder::dummy(tcx.at(DUMMY_SP).mk_trait_ref(\n                         LangItem::Sized,\n@@ -470,7 +470,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                     }\n                 },\n \n-                ty::Infer(ty::FreshTy(..) | ty::FreshIntTy(..) | ty::FreshFloatTy(..))\n+                ty::Infer(\n+                    ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_),\n+                )\n                 | ty::Bound(..) => bug!(\n                     \"unexpected self ty `{:?}` when normalizing `<T as Pointee>::Metadata`\",\n                     goal.predicate.self_ty()\n@@ -482,6 +484,73 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             ecx.evaluate_all_and_make_canonical_response(nested_goals)\n         })\n     }\n+\n+    fn consider_builtin_future_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let self_ty = goal.predicate.self_ty();\n+        let ty::Generator(def_id, substs, _) = *self_ty.kind() else {\n+            return Err(NoSolution);\n+        };\n+\n+        // Generators are not futures unless they come from `async` desugaring\n+        let tcx = ecx.tcx();\n+        if !tcx.generator_is_async(def_id) {\n+            return Err(NoSolution);\n+        }\n+\n+        let term = substs.as_generator().return_ty().into();\n+\n+        Self::consider_assumption(\n+            ecx,\n+            goal,\n+            ty::Binder::dummy(ty::ProjectionPredicate {\n+                projection_ty: ecx.tcx().mk_alias_ty(goal.predicate.def_id(), [self_ty]),\n+                term,\n+            })\n+            .to_predicate(tcx),\n+        )\n+    }\n+\n+    fn consider_builtin_generator_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let self_ty = goal.predicate.self_ty();\n+        let ty::Generator(def_id, substs, _) = *self_ty.kind() else {\n+            return Err(NoSolution);\n+        };\n+\n+        // `async`-desugared generators do not implement the generator trait\n+        let tcx = ecx.tcx();\n+        if tcx.generator_is_async(def_id) {\n+            return Err(NoSolution);\n+        }\n+\n+        let generator = substs.as_generator();\n+\n+        let name = tcx.associated_item(goal.predicate.def_id()).name;\n+        let term = if name == sym::Return {\n+            generator.return_ty().into()\n+        } else if name == sym::Yield {\n+            generator.yield_ty().into()\n+        } else {\n+            bug!(\"unexpected associated item `<{self_ty} as Generator>::{name}`\")\n+        };\n+\n+        Self::consider_assumption(\n+            ecx,\n+            goal,\n+            ty::Binder::dummy(ty::ProjectionPredicate {\n+                projection_ty: ecx\n+                    .tcx()\n+                    .mk_alias_ty(goal.predicate.def_id(), [self_ty, generator.resume_ty()]),\n+                term,\n+            })\n+            .to_predicate(tcx),\n+        )\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "d74857dc4b4803bac6b418941d6e9122dd1fae3b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -192,6 +192,50 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         ecx.make_canonical_response(Certainty::Yes)\n     }\n+\n+    fn consider_builtin_future_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let ty::Generator(def_id, _, _) = *goal.predicate.self_ty().kind() else {\n+            return Err(NoSolution);\n+        };\n+\n+        // Generators are not futures unless they come from `async` desugaring\n+        let tcx = ecx.tcx();\n+        if !tcx.generator_is_async(def_id) {\n+            return Err(NoSolution);\n+        }\n+\n+        // Async generator unconditionally implement `Future`\n+        ecx.make_canonical_response(Certainty::Yes)\n+    }\n+\n+    fn consider_builtin_generator_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let self_ty = goal.predicate.self_ty();\n+        let ty::Generator(def_id, substs, _) = *self_ty.kind() else {\n+            return Err(NoSolution);\n+        };\n+\n+        // `async`-desugared generators do not implement the generator trait\n+        let tcx = ecx.tcx();\n+        if tcx.generator_is_async(def_id) {\n+            return Err(NoSolution);\n+        }\n+\n+        let generator = substs.as_generator();\n+        Self::consider_assumption(\n+            ecx,\n+            goal,\n+            ty::Binder::dummy(\n+                tcx.mk_trait_ref(goal.predicate.def_id(), [self_ty, generator.resume_ty()]),\n+            )\n+            .to_predicate(tcx),\n+        )\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "c2a19372f18c4f97e352ec7d426820fc2901752c", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -24,15 +24,16 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         | ty::Never\n         | ty::Char => Ok(vec![]),\n \n-        ty::Placeholder(..)\n-        | ty::Dynamic(..)\n+        ty::Dynamic(..)\n         | ty::Param(..)\n         | ty::Foreign(..)\n         | ty::Alias(ty::Projection, ..)\n-        | ty::Bound(..)\n-        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n+        | ty::Placeholder(..) => Err(NoSolution),\n \n-        ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+        ty::Bound(..)\n+        | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+            bug!(\"unexpected type `{ty}`\")\n+        }\n \n         ty::RawPtr(ty::TypeAndMut { ty: element_ty, .. }) | ty::Ref(_, element_ty, _) => {\n             Ok(vec![element_ty])\n@@ -99,11 +100,12 @@ pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n         | ty::Foreign(..)\n         | ty::Alias(..)\n         | ty::Param(_)\n-        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n+        | ty::Placeholder(..) => Err(NoSolution),\n \n-        ty::Placeholder(..)\n-        | ty::Bound(..)\n-        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+        ty::Bound(..)\n+        | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+            bug!(\"unexpected type `{ty}`\")\n+        }\n \n         ty::Tuple(tys) => Ok(tys.to_vec()),\n \n@@ -148,11 +150,12 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n         | ty::Adt(_, _)\n         | ty::Alias(_, _)\n         | ty::Param(_)\n-        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n+        | ty::Placeholder(..) => Err(NoSolution),\n \n-        ty::Placeholder(..)\n-        | ty::Bound(..)\n-        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+        ty::Bound(..)\n+        | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+            bug!(\"unexpected type `{ty}`\")\n+        }\n \n         ty::Tuple(tys) => Ok(tys.to_vec()),\n \n@@ -173,6 +176,7 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n     }\n }\n \n+// Returns a binder of the tupled inputs types and output type from a builtin callable type.\n pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     self_ty: Ty<'tcx>,\n@@ -215,9 +219,13 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n         | ty::Tuple(_)\n         | ty::Alias(_, _)\n         | ty::Param(_)\n-        | ty::Placeholder(_)\n-        | ty::Bound(_, _)\n-        | ty::Infer(_)\n+        | ty::Placeholder(..)\n+        | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n         | ty::Error(_) => Err(NoSolution),\n+\n+        ty::Bound(..)\n+        | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+            bug!(\"unexpected type `{self_ty}`\")\n+        }\n     }\n }"}, {"sha": "767e31ddf781a9666bde067a1162e10ada3f478a", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -4,8 +4,8 @@ use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n-use rustc_span::def_id::{DefId, LocalDefId};\n-use rustc_span::Span;\n+use rustc_span::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n+use rustc_span::{Span, DUMMY_SP};\n \n use std::iter;\n /// Returns the set of obligations needed to make `arg` well-formed.\n@@ -75,6 +75,34 @@ pub fn obligations<'tcx>(\n     Some(result)\n }\n \n+/// Compute the predicates that are required for a type to be well-formed.\n+///\n+/// This is only intended to be used in the new solver, since it does not\n+/// take into account recursion depth or proper error-reporting spans.\n+pub fn unnormalized_obligations<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    arg: GenericArg<'tcx>,\n+) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n+    if let ty::GenericArgKind::Lifetime(..) = arg.unpack() {\n+        return Some(vec![]);\n+    }\n+\n+    debug_assert_eq!(arg, infcx.resolve_vars_if_possible(arg));\n+\n+    let mut wf = WfPredicates {\n+        tcx: infcx.tcx,\n+        param_env,\n+        body_id: CRATE_DEF_ID,\n+        span: DUMMY_SP,\n+        out: vec![],\n+        recursion_depth: 0,\n+        item: None,\n+    };\n+    wf.compute(arg);\n+    Some(wf.out)\n+}\n+\n /// Returns the obligations that make this trait reference\n /// well-formed. For example, if there is a trait `Set` defined like\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF"}, {"sha": "e47e68e0670b9475a19080561dade3f4098940c3", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -244,7 +244,7 @@ fn adjust_for_rust_scalar<'tcx>(\n     }\n \n     // Only pointer types handled below.\n-    let Scalar::Initialized { value: Pointer, valid_range} = scalar else { return };\n+    let Scalar::Initialized { value: Pointer(_), valid_range} = scalar else { return };\n \n     if !valid_range.contains(0) {\n         attrs.set(ArgAttribute::NonNull);\n@@ -479,7 +479,7 @@ fn fn_abi_adjust_for_abi<'tcx>(\n             }\n \n             let size = arg.layout.size;\n-            if arg.layout.is_unsized() || size > Pointer.size(cx) {\n+            if arg.layout.is_unsized() || size > Pointer(AddressSpace::DATA).size(cx) {\n                 arg.make_indirect();\n             } else {\n                 // We want to pass small aggregates as immediates, but using"}, {"sha": "0f25579c7bfa19f8fc609ce9adabd167f9e37116", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -134,7 +134,7 @@ fn layout_of_uncached<'tcx>(\n             ty::FloatTy::F64 => F64,\n         }),\n         ty::FnPtr(_) => {\n-            let mut ptr = scalar_unit(Pointer);\n+            let mut ptr = scalar_unit(Pointer(dl.instruction_address_space));\n             ptr.valid_range_mut().start = 1;\n             tcx.intern_layout(LayoutS::scalar(cx, ptr))\n         }\n@@ -144,7 +144,7 @@ fn layout_of_uncached<'tcx>(\n \n         // Potentially-wide pointers.\n         ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-            let mut data_ptr = scalar_unit(Pointer);\n+            let mut data_ptr = scalar_unit(Pointer(AddressSpace::DATA));\n             if !ty.is_unsafe_ptr() {\n                 data_ptr.valid_range_mut().start = 1;\n             }\n@@ -178,7 +178,7 @@ fn layout_of_uncached<'tcx>(\n                     }\n                     ty::Slice(_) | ty::Str => scalar_unit(Int(dl.ptr_sized_integer(), false)),\n                     ty::Dynamic(..) => {\n-                        let mut vtable = scalar_unit(Pointer);\n+                        let mut vtable = scalar_unit(Pointer(AddressSpace::DATA));\n                         vtable.valid_range_mut().start = 1;\n                         vtable\n                     }\n@@ -195,7 +195,7 @@ fn layout_of_uncached<'tcx>(\n         ty::Dynamic(_, _, ty::DynStar) => {\n             let mut data = scalar_unit(Int(dl.ptr_sized_integer(), false));\n             data.valid_range_mut().start = 0;\n-            let mut vtable = scalar_unit(Pointer);\n+            let mut vtable = scalar_unit(Pointer(AddressSpace::DATA));\n             vtable.valid_range_mut().start = 1;\n             tcx.intern_layout(cx.scalar_pair(data, vtable))\n         }"}, {"sha": "8bff40c279aaa4ce2b9761c9a78ae32bfa93d6aa", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -74,6 +74,7 @@ pub fn is_available() -> bool {\n ///\n /// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n /// and `#[proc_macro_derive]` definitions.\n+#[rustc_diagnostic_item = \"TokenStream\"]\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #[derive(Clone)]\n pub struct TokenStream(Option<bridge::client::TokenStream>);"}, {"sha": "3856bb64fb310331f44899dcd940708335e4e24c", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -16,12 +16,17 @@ fn main() {\n     let mut build_lock;\n     let _build_lock_guard;\n     if cfg!(any(unix, windows)) {\n-        build_lock = fd_lock::RwLock::new(t!(std::fs::File::create(config.out.join(\"lock\"))));\n+        let path = config.out.join(\"lock\");\n+        build_lock = fd_lock::RwLock::new(t!(std::fs::File::create(&path)));\n         _build_lock_guard = match build_lock.try_write() {\n             Ok(lock) => lock,\n             err => {\n-                println!(\"warning: build directory locked, waiting for lock\");\n                 drop(err);\n+                if let Some(pid) = get_lock_owner(&path) {\n+                    println!(\"warning: build directory locked by process {pid}, waiting for lock\");\n+                } else {\n+                    println!(\"warning: build directory locked, waiting for lock\");\n+                }\n                 t!(build_lock.write())\n             }\n         };\n@@ -98,3 +103,30 @@ fn check_version(config: &Config) -> Option<String> {\n \n     Some(msg)\n }\n+\n+/// Get the PID of the process which took the write lock by\n+/// parsing `/proc/locks`.\n+#[cfg(target_os = \"linux\")]\n+fn get_lock_owner(f: &std::path::Path) -> Option<u64> {\n+    use std::fs::File;\n+    use std::io::{BufRead, BufReader};\n+    use std::os::unix::fs::MetadataExt;\n+\n+    let lock_inode = std::fs::metadata(f).ok()?.ino();\n+    let lockfile = File::open(\"/proc/locks\").ok()?;\n+    BufReader::new(lockfile).lines().find_map(|line| {\n+        //                       pid--vvvvvv       vvvvvvv--- inode\n+        // 21: FLOCK  ADVISORY  WRITE 359238 08:02:3719774 0 EOF\n+        let line = line.ok()?;\n+        let parts = line.split_whitespace().collect::<Vec<_>>();\n+        let (pid, inode) = (parts[4].parse::<u64>().ok()?, &parts[5]);\n+        let inode = inode.rsplit_once(':')?.1.parse::<u64>().ok()?;\n+        if inode == lock_inode { Some(pid) } else { None }\n+    })\n+}\n+\n+#[cfg(not(target_os = \"linux\"))]\n+fn get_lock_owner(_: &std::path::Path) -> Option<u64> {\n+    // FIXME: Implement on other OS's\n+    None\n+}"}, {"sha": "bc11e1081244ad84017d516a76acf4272afab19a", "filename": "tests/codegen/avr/avr-func-addrspace.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Favr%2Favr-func-addrspace.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -109,3 +109,28 @@ pub unsafe fn transmute_fn_ptr_to_data(x: fn()) -> *const () {\n     // as long as it doesn't cause a verifier error by using `bitcast`.\n     transmute(x)\n }\n+\n+pub enum Either<T, U> { A(T), B(U) }\n+\n+// Previously, we would codegen this as passing/returning a scalar pair of `{ i8, ptr }`,\n+// with the `ptr` field representing both `&i32` and `fn()` depending on the variant.\n+// This is incorrect, because `fn()` should be `ptr addrspace(1)`, not `ptr`.\n+\n+// CHECK: define{{.+}}void @should_not_combine_addrspace({{.+\\*|ptr}}{{.+}}sret{{.+}}%0, {{.+\\*|ptr}}{{.+}}%x)\n+#[no_mangle]\n+#[inline(never)]\n+pub fn should_not_combine_addrspace(x: Either<&i32, fn()>) -> Either<&i32, fn()> {\n+    x\n+}\n+\n+// The incorrectness described above would result in us producing (after optimizations)\n+// a `ptrtoint`/`inttoptr` roundtrip to convert from `ptr` to `ptr addrspace(1)`.\n+\n+// CHECK-LABEL: @call_with_fn_ptr\n+#[no_mangle]\n+pub fn call_with_fn_ptr<'a>(f: fn()) -> Either<&'a i32, fn()> {\n+    // CHECK-NOT: ptrtoint\n+    // CHECK-NOT: inttoptr\n+    // CHECK: call addrspace(1) void @should_not_combine_addrspace\n+    should_not_combine_addrspace(Either::B(f))\n+}"}, {"sha": "a0c5f1b40dbb72957fccd3bfb94d64d2add4de86", "filename": "tests/mir-opt/building/custom/operators.f.built.after.mir", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.f.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.f.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.f.built.after.mir?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,26 @@\n+// MIR for `f` after built\n+\n+fn f(_1: i32, _2: bool) -> i32 {\n+    let mut _0: i32;                     // return place in scope 0 at $DIR/operators.rs:+0:30: +0:33\n+\n+    bb0: {\n+        _1 = Neg(_1);                    // scope 0 at $DIR/operators.rs:+2:9: +2:15\n+        _2 = Not(_2);                    // scope 0 at $DIR/operators.rs:+3:9: +3:15\n+        _1 = Add(_1, _1);                // scope 0 at $DIR/operators.rs:+4:9: +4:18\n+        _1 = Sub(_1, _1);                // scope 0 at $DIR/operators.rs:+5:9: +5:18\n+        _1 = Mul(_1, _1);                // scope 0 at $DIR/operators.rs:+6:9: +6:18\n+        _1 = Div(_1, _1);                // scope 0 at $DIR/operators.rs:+7:9: +7:18\n+        _1 = Rem(_1, _1);                // scope 0 at $DIR/operators.rs:+8:9: +8:18\n+        _1 = BitXor(_1, _1);             // scope 0 at $DIR/operators.rs:+9:9: +9:18\n+        _1 = BitAnd(_1, _1);             // scope 0 at $DIR/operators.rs:+10:9: +10:18\n+        _1 = Shl(_1, _1);                // scope 0 at $DIR/operators.rs:+11:9: +11:19\n+        _1 = Shr(_1, _1);                // scope 0 at $DIR/operators.rs:+12:9: +12:19\n+        _2 = Eq(_1, _1);                 // scope 0 at $DIR/operators.rs:+13:9: +13:19\n+        _2 = Lt(_1, _1);                 // scope 0 at $DIR/operators.rs:+14:9: +14:18\n+        _2 = Le(_1, _1);                 // scope 0 at $DIR/operators.rs:+15:9: +15:19\n+        _2 = Ge(_1, _1);                 // scope 0 at $DIR/operators.rs:+16:9: +16:19\n+        _2 = Gt(_1, _1);                 // scope 0 at $DIR/operators.rs:+17:9: +17:18\n+        _0 = _1;                         // scope 0 at $DIR/operators.rs:+18:9: +18:16\n+        return;                          // scope 0 at $DIR/operators.rs:+19:9: +19:17\n+    }\n+}"}, {"sha": "51f80c66392a10046f7b295b76b4d6a5d993d836", "filename": "tests/mir-opt/building/custom/operators.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,28 @@\n+// compile-flags: --crate-type=lib\n+#![feature(custom_mir, core_intrinsics, inline_const)]\n+use std::intrinsics::mir::*;\n+\n+// EMIT_MIR operators.f.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+pub fn f(a: i32, b: bool) -> i32 {\n+    mir!({\n+        a = -a;\n+        b = !b;\n+        a = a + a;\n+        a = a - a;\n+        a = a * a;\n+        a = a / a;\n+        a = a % a;\n+        a = a ^ a;\n+        a = a & a;\n+        a = a << a;\n+        a = a >> a;\n+        b = a == a;\n+        b = a < a;\n+        b = a <= a;\n+        b = a >= a;\n+        b = a > a;\n+        RET = a;\n+        Return()\n+    })\n+}"}, {"sha": "56b8a3d43bedf674eb4a879fea8252e8f2f9273e", "filename": "tests/ui/parser/anon-enums.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Fanon-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Fanon-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fanon-enums.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,17 @@\n+fn foo(x: bool | i32) -> i32 | f64 {\n+//~^ ERROR anonymous enums are not supported\n+//~| ERROR anonymous enums are not supported\n+    match x {\n+        x: i32 => x, //~ ERROR expected\n+        true => 42.,\n+        false => 0.333,\n+    }\n+}\n+\n+fn main() {\n+    match foo(true) {\n+        42: i32 => (), //~ ERROR expected\n+        _: f64 => (), //~ ERROR expected\n+        x: i32 => (), //~ ERROR expected\n+    }\n+}"}, {"sha": "841582256609121d41403607a0fe2d2a1b43c65c", "filename": "tests/ui/parser/anon-enums.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Fanon-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Fanon-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fanon-enums.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,68 @@\n+error: anonymous enums are not supported\n+  --> $DIR/anon-enums.rs:1:16\n+   |\n+LL | fn foo(x: bool | i32) -> i32 | f64 {\n+   |           ---- ^ ---\n+   |\n+   = help: create a named `enum` and use it here instead:\n+           enum Name {\n+               Variant1(bool),\n+               Variant2(i32),\n+           }\n+\n+error: anonymous enums are not supported\n+  --> $DIR/anon-enums.rs:1:30\n+   |\n+LL | fn foo(x: bool | i32) -> i32 | f64 {\n+   |                          --- ^ ---\n+   |\n+   = help: create a named `enum` and use it here instead:\n+           enum Name {\n+               Variant1(i32),\n+               Variant2(f64),\n+           }\n+\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/anon-enums.rs:5:10\n+   |\n+LL |         x: i32 => x,\n+   |          ^ --- specifying the type of a pattern isn't supported\n+   |          |\n+   |          expected one of `@` or `|`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         x::i32 => x,\n+   |          ~~\n+\n+error: expected one of `...`, `..=`, `..`, or `|`, found `:`\n+  --> $DIR/anon-enums.rs:13:11\n+   |\n+LL |         42: i32 => (),\n+   |           ^ --- specifying the type of a pattern isn't supported\n+   |           |\n+   |           expected one of `...`, `..=`, `..`, or `|`\n+\n+error: expected `|`, found `:`\n+  --> $DIR/anon-enums.rs:14:10\n+   |\n+LL |         _: f64 => (),\n+   |          ^ --- specifying the type of a pattern isn't supported\n+   |          |\n+   |          expected `|`\n+\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/anon-enums.rs:15:10\n+   |\n+LL |         x: i32 => (),\n+   |          ^ --- specifying the type of a pattern isn't supported\n+   |          |\n+   |          expected one of `@` or `|`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         x::i32 => (),\n+   |          ~~\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "38fe8dee2382915c6b3d0f02bb8867046a2bced5", "filename": "tests/ui/parser/fake-anon-enums-in-macros.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Ffake-anon-enums-in-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Ffake-anon-enums-in-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Ffake-anon-enums-in-macros.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,20 @@\n+// build-pass\n+macro_rules! check_ty {\n+    ($Z:ty) => { compile_error!(\"triggered\"); };\n+    ($X:ty | $Y:ty) => { $X };\n+}\n+\n+macro_rules! check {\n+    ($Z:ty) => { compile_error!(\"triggered\"); };\n+    ($X:ty | $Y:ty) => { };\n+}\n+\n+check! { i32 | u8 }\n+\n+fn foo(x: check_ty! { i32 | u8 }) -> check_ty! { i32 | u8 } {\n+    x\n+}\n+fn main() {\n+    let x: check_ty! { i32 | u8 } = 42;\n+    let _: check_ty! { i32 | u8 } = foo(x);\n+}"}, {"sha": "e1ea38f2795df698983f335bbf6b77f13d29dad1", "filename": "tests/ui/parser/issues/issue-87086-colon-path-sep.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -68,7 +68,6 @@ fn main() {\n         Foo:Bar::Baz => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n-        //~| ERROR: failed to resolve: `Bar` is a variant, not a module\n     }\n     match myfoo {\n         Foo::Bar => {}"}, {"sha": "63b072ac4cdc68c6c4f9ec8734f49945c45de38e", "filename": "tests/ui/parser/issues/issue-87086-colon-path-sep.stderr", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -2,89 +2,118 @@ error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:17:12\n    |\n LL |         Foo:Bar => {}\n-   |            ^\n+   |            ^--- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         Foo::Bar => {}\n+   |            ~~\n \n error: expected one of `!`, `(`, `...`, `..=`, `..`, `::`, `{`, or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:23:17\n    |\n LL |         qux::Foo:Bar => {}\n-   |                 ^\n+   |                 ^--- specifying the type of a pattern isn't supported\n    |                 |\n    |                 expected one of 8 possible tokens\n-   |                 help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         qux::Foo::Bar => {}\n+   |                 ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:29:12\n    |\n LL |         qux:Foo::Baz => {}\n-   |            ^\n+   |            ^-------- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         qux::Foo::Baz => {}\n+   |            ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:35:12\n    |\n LL |         qux: Foo::Baz if true => {}\n-   |            ^\n+   |            ^ -------- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         qux::Foo::Baz if true => {}\n+   |            ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:40:15\n    |\n LL |     if let Foo:Bar = f() {\n-   |               ^\n+   |               ^--- specifying the type of a pattern isn't supported\n    |               |\n    |               expected one of `@` or `|`\n-   |               help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |     if let Foo::Bar = f() {\n+   |               ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:48:16\n    |\n LL |         ref qux: Foo::Baz => {}\n-   |                ^\n+   |                ^ -------- specifying the type of a pattern isn't supported\n    |                |\n    |                expected one of `@` or `|`\n-   |                help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         ref qux::Foo::Baz => {}\n+   |                ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:57:16\n    |\n LL |         mut qux: Foo::Baz => {}\n-   |                ^\n+   |                ^ -------- specifying the type of a pattern isn't supported\n    |                |\n    |                expected one of `@` or `|`\n-   |                help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         mut qux::Foo::Baz => {}\n+   |                ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:68:12\n    |\n LL |         Foo:Bar::Baz => {}\n-   |            ^\n+   |            ^-------- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         Foo::Bar::Baz => {}\n+   |            ~~\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:75:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:74:12\n    |\n LL |         Foo:Bar => {}\n-   |            ^\n+   |            ^--- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n-\n-error[E0433]: failed to resolve: `Bar` is a variant, not a module\n-  --> $DIR/issue-87086-colon-path-sep.rs:68:13\n    |\n-LL |         Foo:Bar::Baz => {}\n-   |             ^^^ `Bar` is a variant, not a module\n+help: maybe write a path separator here\n+   |\n+LL |         Foo::Bar => {}\n+   |            ~~\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 9 previous errors\n \n-For more information about this error, try `rustc --explain E0433`."}, {"sha": "8685087611248be845055ef7b14b00f6cd4fdea6", "filename": "tests/ui/proc-macro/allowed-signatures.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fallowed-signatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fallowed-signatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fallowed-signatures.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![allow(private_in_public)]\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn foo<T>(t: T) -> TokenStream {\n+  TokenStream::new()\n+}\n+\n+trait Project {\n+    type Assoc;\n+}\n+\n+impl Project for () {\n+    type Assoc = TokenStream;\n+}\n+\n+#[proc_macro]\n+pub fn uwu(_input: <() as Project>::Assoc) -> <() as Project>::Assoc {\n+    TokenStream::new()\n+}"}, {"sha": "873660a5b3ab989c5f3bd42b838df81a52f9193a", "filename": "tests/ui/proc-macro/proc-macro-abi.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fproc-macro-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fproc-macro-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fproc-macro-abi.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,31 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![allow(warnings)]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub extern \"C\" fn abi(a: TokenStream) -> TokenStream {\n+    //~^ ERROR proc macro functions may not be `extern \"C\"`\n+    a\n+}\n+\n+#[proc_macro]\n+pub extern \"system\" fn abi2(a: TokenStream) -> TokenStream {\n+    //~^ ERROR proc macro functions may not be `extern \"system\"`\n+    a\n+}\n+\n+#[proc_macro]\n+pub extern fn abi3(a: TokenStream) -> TokenStream {\n+    //~^ ERROR proc macro functions may not be `extern \"C\"`\n+    a\n+}\n+\n+#[proc_macro]\n+pub extern \"Rust\" fn abi4(a: TokenStream) -> TokenStream {\n+    a\n+}"}, {"sha": "9a781be0996dde492ddaf7da02decfeb9f78b33f", "filename": "tests/ui/proc-macro/proc-macro-abi.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fproc-macro-abi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fproc-macro-abi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fproc-macro-abi.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,20 @@\n+error: proc macro functions may not be `extern \"C\"`\n+  --> $DIR/proc-macro-abi.rs:11:1\n+   |\n+LL | pub extern \"C\" fn abi(a: TokenStream) -> TokenStream {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: proc macro functions may not be `extern \"system\"`\n+  --> $DIR/proc-macro-abi.rs:17:1\n+   |\n+LL | pub extern \"system\" fn abi2(a: TokenStream) -> TokenStream {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: proc macro functions may not be `extern \"C\"`\n+  --> $DIR/proc-macro-abi.rs:23:1\n+   |\n+LL | pub extern fn abi3(a: TokenStream) -> TokenStream {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "51abc8e7d3edb0f1378f70cb19f9b746aa14ad83", "filename": "tests/ui/proc-macro/signature-proc-macro-attribute.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-attribute.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,32 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn bad_input(input: String) -> TokenStream {\n+    //~^ ERROR mismatched attribute proc macro signature\n+    ::proc_macro::TokenStream::new()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn bad_output(input: TokenStream) -> String {\n+    //~^ ERROR mismatched attribute proc macro signature\n+    //~| ERROR mismatched attribute proc macro signature\n+    String::from(\"blah\")\n+}\n+\n+#[proc_macro_attribute]\n+pub fn bad_everything(input: String) -> String {\n+    //~^ ERROR mismatched attribute proc macro signature\n+    //~| ERROR mismatched attribute proc macro signature\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn too_many(a: TokenStream, b: TokenStream, c: String) -> TokenStream {\n+    //~^ ERROR mismatched attribute proc macro signature\n+}"}, {"sha": "abf7a6f3ce9229d9bfeabc419852d035c6ee64da", "filename": "tests/ui/proc-macro/signature-proc-macro-attribute.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-attribute.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,42 @@\n+error: mismatched attribute proc macro signature\n+  --> $DIR/signature-proc-macro-attribute.rs:10:1\n+   |\n+LL | pub fn bad_input(input: String) -> TokenStream {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attribute proc macro must have two arguments of type `proc_macro::TokenStream`\n+\n+error: mismatched attribute proc macro signature\n+  --> $DIR/signature-proc-macro-attribute.rs:16:42\n+   |\n+LL | pub fn bad_output(input: TokenStream) -> String {\n+   |                                          ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: attribute proc macros must have a signature of `fn(TokenStream, TokenStream) -> TokenStream`\n+\n+error: mismatched attribute proc macro signature\n+  --> $DIR/signature-proc-macro-attribute.rs:16:1\n+   |\n+LL | pub fn bad_output(input: TokenStream) -> String {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attribute proc macro must have two arguments of type `proc_macro::TokenStream`\n+\n+error: mismatched attribute proc macro signature\n+  --> $DIR/signature-proc-macro-attribute.rs:23:41\n+   |\n+LL | pub fn bad_everything(input: String) -> String {\n+   |                                         ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: attribute proc macros must have a signature of `fn(TokenStream, TokenStream) -> TokenStream`\n+\n+error: mismatched attribute proc macro signature\n+  --> $DIR/signature-proc-macro-attribute.rs:23:1\n+   |\n+LL | pub fn bad_everything(input: String) -> String {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attribute proc macro must have two arguments of type `proc_macro::TokenStream`\n+\n+error: mismatched attribute proc macro signature\n+  --> $DIR/signature-proc-macro-attribute.rs:30:49\n+   |\n+LL | pub fn too_many(a: TokenStream, b: TokenStream, c: String) -> TokenStream {\n+   |                                                 ^^^^^^^^^ found unexpected argument\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "f2fd824b675b68741653c8a0bb4c7c67a340f2a3", "filename": "tests/ui/proc-macro/signature-proc-macro-derive.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-derive.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,31 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Blah)]\n+pub fn bad_input(input: String) -> TokenStream {\n+    //~^ ERROR mismatched derive proc macro signature\n+    TokenStream::new()\n+}\n+\n+#[proc_macro_derive(Bleh)]\n+pub fn bad_output(input: TokenStream) -> String {\n+    //~^ ERROR mismatched derive proc macro signature\n+    String::from(\"blah\")\n+}\n+\n+#[proc_macro_derive(Bluh)]\n+pub fn bad_everything(input: String) -> String {\n+    //~^ ERROR mismatched derive proc macro signature\n+    //~| ERROR mismatched derive proc macro signature\n+    input\n+}\n+\n+#[proc_macro_derive(Blih)]\n+pub fn too_many(a: TokenStream, b: TokenStream, c: String) -> TokenStream {\n+    //~^ ERROR mismatched derive proc macro signature\n+}"}, {"sha": "a358ae277037f106bbdd95c979444b477df9f834", "filename": "tests/ui/proc-macro/signature-proc-macro-derive.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro-derive.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,40 @@\n+error: mismatched derive proc macro signature\n+  --> $DIR/signature-proc-macro-derive.rs:10:25\n+   |\n+LL | pub fn bad_input(input: String) -> TokenStream {\n+   |                         ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: derive proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched derive proc macro signature\n+  --> $DIR/signature-proc-macro-derive.rs:16:42\n+   |\n+LL | pub fn bad_output(input: TokenStream) -> String {\n+   |                                          ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: derive proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched derive proc macro signature\n+  --> $DIR/signature-proc-macro-derive.rs:22:41\n+   |\n+LL | pub fn bad_everything(input: String) -> String {\n+   |                                         ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: derive proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched derive proc macro signature\n+  --> $DIR/signature-proc-macro-derive.rs:22:30\n+   |\n+LL | pub fn bad_everything(input: String) -> String {\n+   |                              ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: derive proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched derive proc macro signature\n+  --> $DIR/signature-proc-macro-derive.rs:29:33\n+   |\n+LL | pub fn too_many(a: TokenStream, b: TokenStream, c: String) -> TokenStream {\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^ found unexpected arguments\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "54770aacd1a980728cf77e096b85742872017cb7", "filename": "tests/ui/proc-macro/signature-proc-macro.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,31 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn bad_input(input: String) -> TokenStream {\n+    //~^ ERROR mismatched function-like proc macro signature\n+    ::proc_macro::TokenStream::new()\n+}\n+\n+#[proc_macro]\n+pub fn bad_output(input: TokenStream) -> String {\n+    //~^ ERROR mismatched function-like proc macro signature\n+    String::from(\"blah\")\n+}\n+\n+#[proc_macro]\n+pub fn bad_everything(input: String) -> String {\n+    //~^ ERROR mismatched function-like proc macro signature\n+    //~| ERROR mismatched function-like proc macro signature\n+    input\n+}\n+\n+#[proc_macro]\n+pub fn too_many(a: TokenStream, b: TokenStream, c: String) -> TokenStream {\n+    //~^ ERROR mismatched function-like proc macro signature\n+}"}, {"sha": "4b14a54e6750318fc13b57274188f574e1af5a08", "filename": "tests/ui/proc-macro/signature-proc-macro.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fsignature-proc-macro.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,40 @@\n+error: mismatched function-like proc macro signature\n+  --> $DIR/signature-proc-macro.rs:10:25\n+   |\n+LL | pub fn bad_input(input: String) -> TokenStream {\n+   |                         ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: function-like proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched function-like proc macro signature\n+  --> $DIR/signature-proc-macro.rs:16:42\n+   |\n+LL | pub fn bad_output(input: TokenStream) -> String {\n+   |                                          ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: function-like proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched function-like proc macro signature\n+  --> $DIR/signature-proc-macro.rs:22:41\n+   |\n+LL | pub fn bad_everything(input: String) -> String {\n+   |                                         ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: function-like proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched function-like proc macro signature\n+  --> $DIR/signature-proc-macro.rs:22:30\n+   |\n+LL | pub fn bad_everything(input: String) -> String {\n+   |                              ^^^^^^ found std::string::String, expected type `proc_macro::TokenStream`\n+   |\n+   = note: function-like proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched function-like proc macro signature\n+  --> $DIR/signature-proc-macro.rs:29:33\n+   |\n+LL | pub fn too_many(a: TokenStream, b: TokenStream, c: String) -> TokenStream {\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^ found unexpected arguments\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "11187aa31bd8071c6047c1568bf7ac7373bbc30b", "filename": "tests/ui/proc-macro/signature.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fsignature.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -8,6 +8,10 @@ extern crate proc_macro;\n \n #[proc_macro_derive(A)]\n pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n-    //~^ ERROR: expected a `Fn<(proc_macro::TokenStream,)>` closure, found `unsafe extern \"C\" fn\n+    //~^ ERROR: mismatched derive proc macro signature\n+    //~| mismatched derive proc macro signature\n+    //~| mismatched derive proc macro signature\n+    //~| proc macro functions may not be `extern\n+    //~| proc macro functions may not be `unsafe\n     loop {}\n }"}, {"sha": "3dbe3f22a0df89310dbcb24e8fdb51e021e50754", "filename": "tests/ui/proc-macro/signature.stderr", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fproc-macro%2Fsignature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fsignature.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -1,20 +1,36 @@\n-error[E0277]: expected a `Fn<(proc_macro::TokenStream,)>` closure, found `unsafe extern \"C\" fn(i32, u32) -> u32 {foo}`\n+error: proc macro functions may not be `extern \"C\"`\n   --> $DIR/signature.rs:10:1\n    |\n-LL | / pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n-LL | |\n-LL | |     loop {}\n-LL | | }\n-   | | ^\n-   | | |\n-   | |_call the function in a closure: `|| unsafe { /* code */ }`\n-   |   required by a bound introduced by this call\n+LL | pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: proc macro functions may not be `unsafe`\n+  --> $DIR/signature.rs:10:1\n+   |\n+LL | pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mismatched derive proc macro signature\n+  --> $DIR/signature.rs:10:49\n+   |\n+LL | pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n+   |                                                 ^^^ found u32, expected type `proc_macro::TokenStream`\n+   |\n+   = note: derive proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched derive proc macro signature\n+  --> $DIR/signature.rs:10:33\n+   |\n+LL | pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n+   |                                 ^^^ found i32, expected type `proc_macro::TokenStream`\n+   |\n+   = note: derive proc macros must have a signature of `fn(TokenStream) -> TokenStream`\n+\n+error: mismatched derive proc macro signature\n+  --> $DIR/signature.rs:10:38\n    |\n-   = help: the trait `Fn<(proc_macro::TokenStream,)>` is not implemented for fn item `unsafe extern \"C\" fn(i32, u32) -> u32 {foo}`\n-   = note: unsafe function cannot be called generically without an unsafe block\n-note: required by a bound in `ProcMacro::custom_derive`\n-  --> $SRC_DIR/proc_macro/src/bridge/client.rs:LL:COL\n+LL | pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n+   |                                      ^^^^^^ found unexpected argument\n \n-error: aborting due to previous error\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "95070ec601cd49cad61b522cc23db1849c97e5b6", "filename": "tests/ui/suggestions/assoc-const-without-self.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fsuggestions%2Fassoc-const-without-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fsuggestions%2Fassoc-const-without-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fassoc-const-without-self.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,11 @@\n+struct Foo;\n+\n+impl Foo {\n+    const A_CONST: usize = 1;\n+\n+    fn foo() -> usize {\n+        A_CONST //~ ERROR cannot find value `A_CONST` in this scope\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "88d72da70cb9b99789b546e7ae53b235c5afa71a", "filename": "tests/ui/suggestions/assoc-const-without-self.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fsuggestions%2Fassoc-const-without-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Fsuggestions%2Fassoc-const-without-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fassoc-const-without-self.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,14 @@\n+error[E0425]: cannot find value `A_CONST` in this scope\n+  --> $DIR/assoc-const-without-self.rs:7:9\n+   |\n+LL |         A_CONST\n+   |         ^^^^^^^ not found in this scope\n+   |\n+help: consider using the associated constant\n+   |\n+LL |         Self::A_CONST\n+   |         ++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "b395c23ae00572d7ee65a74ecfa71fe6a3dceb8a", "filename": "tests/ui/traits/new-solver/async.fail.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.fail.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,17 @@\n+error[E0271]: expected `[async block@$DIR/async.rs:12:17: 12:25]` to be a future that resolves to `i32`, but it resolves to `()`\n+  --> $DIR/async.rs:12:17\n+   |\n+LL |     needs_async(async {});\n+   |     ----------- ^^^^^^^^ expected `i32`, found `()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `needs_async`\n+  --> $DIR/async.rs:8:31\n+   |\n+LL | fn needs_async(_: impl Future<Output = i32>) {}\n+   |                               ^^^^^^^^^^^^ required by this bound in `needs_async`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "195cc35cad2adb9be9f383868b59066c1a9eee3c", "filename": "tests/ui/traits/new-solver/async.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fasync.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Ztrait-solver=next\n+// edition: 2021\n+// revisions: pass fail\n+//[pass] check-pass\n+\n+use std::future::Future;\n+\n+fn needs_async(_: impl Future<Output = i32>) {}\n+\n+#[cfg(fail)]\n+fn main() {\n+    needs_async(async {});\n+    //[fail]~^ ERROR to be a future that resolves to `i32`, but it resolves to `()`\n+}\n+\n+#[cfg(pass)]\n+fn main() {\n+    needs_async(async { 1i32 });\n+}"}, {"sha": "d94d41e3587b6572162e2122fc22c7fb4222eb0b", "filename": "tests/ui/traits/new-solver/generator.fail.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.fail.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,64 @@\n+error[E0277]: the trait bound `[generator@$DIR/generator.rs:18:21: 18:23]: Generator<A>` is not satisfied\n+  --> $DIR/generator.rs:18:21\n+   |\n+LL |       needs_generator(|| {\n+   |  _____---------------_^\n+   | |     |\n+   | |     required by a bound introduced by this call\n+LL | |\n+LL | |\n+LL | |\n+LL | |         yield ();\n+LL | |     });\n+   | |_____^ the trait `Generator<A>` is not implemented for `[generator@$DIR/generator.rs:18:21: 18:23]`\n+   |\n+note: required by a bound in `needs_generator`\n+  --> $DIR/generator.rs:14:28\n+   |\n+LL | fn needs_generator(_: impl Generator<A, Yield = B, Return = C>) {}\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `needs_generator`\n+\n+error[E0271]: type mismatch resolving `<[generator@$DIR/generator.rs:18:21: 18:23] as Generator<A>>::Yield == B`\n+  --> $DIR/generator.rs:18:21\n+   |\n+LL |       needs_generator(|| {\n+   |  _____---------------_^\n+   | |     |\n+   | |     required by a bound introduced by this call\n+LL | |\n+LL | |\n+LL | |\n+LL | |         yield ();\n+LL | |     });\n+   | |_____^ types differ\n+   |\n+note: required by a bound in `needs_generator`\n+  --> $DIR/generator.rs:14:41\n+   |\n+LL | fn needs_generator(_: impl Generator<A, Yield = B, Return = C>) {}\n+   |                                         ^^^^^^^^^ required by this bound in `needs_generator`\n+\n+error[E0271]: type mismatch resolving `<[generator@$DIR/generator.rs:18:21: 18:23] as Generator<A>>::Return == C`\n+  --> $DIR/generator.rs:18:21\n+   |\n+LL |       needs_generator(|| {\n+   |  _____---------------_^\n+   | |     |\n+   | |     required by a bound introduced by this call\n+LL | |\n+LL | |\n+LL | |\n+LL | |         yield ();\n+LL | |     });\n+   | |_____^ types differ\n+   |\n+note: required by a bound in `needs_generator`\n+  --> $DIR/generator.rs:14:52\n+   |\n+LL | fn needs_generator(_: impl Generator<A, Yield = B, Return = C>) {}\n+   |                                                    ^^^^^^^^^^ required by this bound in `needs_generator`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0271, E0277.\n+For more information about an error, try `rustc --explain E0271`."}, {"sha": "364373ca8be7172f35bade6e744e586c96258d1a", "filename": "tests/ui/traits/new-solver/generator.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fgenerator.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,32 @@\n+// compile-flags: -Ztrait-solver=next\n+// edition: 2021\n+// revisions: pass fail\n+//[pass] check-pass\n+\n+#![feature(generator_trait, generators)]\n+\n+use std::ops::Generator;\n+\n+struct A;\n+struct B;\n+struct C;\n+\n+fn needs_generator(_: impl Generator<A, Yield = B, Return = C>) {}\n+\n+#[cfg(fail)]\n+fn main() {\n+    needs_generator(|| {\n+        //[fail]~^ ERROR Generator<A>` is not satisfied\n+        //[fail]~| ERROR as Generator<A>>::Yield == B`\n+        //[fail]~| ERROR as Generator<A>>::Return == C`\n+        yield ();\n+    });\n+}\n+\n+#[cfg(pass)]\n+fn main() {\n+    needs_generator(|_: A| {\n+        let _: A = yield B;\n+        C\n+    })\n+}"}, {"sha": "a807f030cfce46d1de90db77a9efde8b1deca935", "filename": "tests/ui/typeck/bad-type-in-vec-push.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.rs?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,20 @@\n+// The error message here still is pretty confusing.\n+\n+fn main() {\n+    let mut result = vec![1];\n+    // The type of `result` is constrained to be `Vec<{integer}>` here.\n+    // But the logic we use to find what expression constrains a type\n+    // is not sophisticated enough to know this.\n+\n+    let mut vector = Vec::new();\n+    vector.sort();\n+    result.push(vector);\n+    //~^ ERROR mismatched types\n+    // So it thinks that the type of `result` is constrained here.\n+}\n+\n+fn example2() {\n+    let mut x = vec![1];\n+    x.push(\"\");\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "e4c99ec8e701f99a1f72792c438a9626c947886a", "filename": "tests/ui/typeck/bad-type-in-vec-push.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -0,0 +1,29 @@\n+error[E0308]: mismatched types\n+  --> $DIR/bad-type-in-vec-push.rs:11:17\n+   |\n+LL |     vector.sort();\n+   |     ------ here the type of `vector` is inferred to be `Vec<_>`\n+LL |     result.push(vector);\n+   |            ---- ^^^^^^ expected integer, found struct `Vec`\n+   |            |\n+   |            arguments to this method are incorrect\n+   |\n+   = note: expected type `{integer}`\n+            found struct `Vec<_>`\n+note: associated function defined here\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+\n+error[E0308]: mismatched types\n+  --> $DIR/bad-type-in-vec-push.rs:18:12\n+   |\n+LL |     x.push(\"\");\n+   |       ---- ^^ expected integer, found `&str`\n+   |       |\n+   |       arguments to this method are incorrect\n+   |\n+note: associated function defined here\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "79958729fc521ed1ada06422e092a769384d2377", "filename": "triagebot.toml", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e187f8871e3d553181c9d2d4ac111197a139ca0d/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e187f8871e3d553181c9d2d4ac111197a139ca0d/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=e187f8871e3d553181c9d2d4ac111197a139ca0d", "patch": "@@ -456,6 +456,9 @@ These commits modify **compiler targets**.\n (See the [Target Tier Policy](https://doc.rust-lang.org/nightly/rustc/target-tier-policy.html).)\n \"\"\"\n \n+[mentions.\"src/doc/style-guide\"]\n+cc = [\"@rust-lang/style\"]\n+\n [assign]\n warn_non_default_branch = true\n contributing_url = \"https://rustc-dev-guide.rust-lang.org/contributing.html\"\n@@ -560,6 +563,12 @@ ast_lowering = [\n fallback = [\n     \"@Mark-Simulacrum\"\n ]\n+style-team = [\n+    \"@calebcartwright\",\n+    \"@compiler-errors\",\n+    \"@joshtriplett\",\n+    \"@yaahc\",\n+]\n \n [assign.owners]\n \"/.github/workflows\" =                       [\"infra-ci\"]\n@@ -604,6 +613,7 @@ fallback = [\n \"/src/doc/rust-by-example\" =                 [\"@ehuss\"]\n \"/src/doc/rustc-dev-guide\" =                 [\"@ehuss\"]\n \"/src/doc/rustdoc\" =                         [\"rustdoc\"]\n+\"/src/doc/style-guide\" =                     [\"style-team\"]\n \"/src/etc\" =                                 [\"@Mark-Simulacrum\"]\n \"/src/librustdoc\" =                          [\"rustdoc\"]\n \"/src/llvm-project\" =                        [\"@cuviper\"]"}]}