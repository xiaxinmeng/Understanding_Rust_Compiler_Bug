{"sha": "31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "node_id": "C_kwDOAAsO6NoAKDMxYjE3NDExYTZjZDVjNGIzNmNkZTZmZjAwOGRlMWQzZWMxMjhhYzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-30T22:29:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-30T22:29:40Z"}, "message": "Auto merge of #9510 - Alexendoo:lintcheck-server2, r=matthiaskrgr\n\nAdd `cargo lintcheck --recursive` to check dependencies of crates\n\nr? `@matthiaskrgr`\n\nThis just adds the mode without changing how a regular run works\n\nTakes a fair bit longer to run than a `-j4` or regular run\n\n```\ncargo lintcheck -j4  468.33s user 43.78s system 290% cpu 2:56.42 total\ncargo lintcheck  428.81s user 41.85s system 199% cpu 3:55.37 total\ncargo lintcheck --recursive  679.83s user 45.01s system 210% cpu 5:43.72 total\n```\n\nBut finds more results:\n\n<details>\n<summary>Stats</summary>\n<pre><code>clippy::explicit_counter_loop 0 =&gt; 1\nclippy::needless_question_mark 0 =&gt; 3\nclippy::unnecessary_cast 0 =&gt; 2\nclippy::to_string_in_format_args 0 =&gt; 4\nclippy::deprecated_cfg_attr 0 =&gt; 23\nclippy::redundant_closure 0 =&gt; 9\nclippy::drop_copy 0 =&gt; 4\nclippy::double_must_use 0 =&gt; 1\nclippy::transmute_num_to_bytes 0 =&gt; 9\nclippy::bind_instead_of_map 0 =&gt; 14\nclippy::float_cmp 0 =&gt; 16\nclippy::is_digit_ascii_radix 0 =&gt; 16\nclippy::manual_swap 0 =&gt; 1\nclippy::needless_match 0 =&gt; 2\nclippy::vec_init_then_push 0 =&gt; 1\nclippy::never_loop 0 =&gt; 1\nclippy::option_map_or_none 0 =&gt; 4\nclippy::tabs_in_doc_comments 0 =&gt; 1\nclippy::naive_bytecount 0 =&gt; 1\nclippy::collapsible_if 0 =&gt; 24\nclippy::copy_iterator 0 =&gt; 5\nclippy::unused_io_amount 0 =&gt; 2\nclippy::result_large_err 0 =&gt; 141\nclippy::useless_conversion 0 =&gt; 24\nclippy::flat_map_option 0 =&gt; 8\nclippy::useless_format 0 =&gt; 2\nclippy::module_inception 0 =&gt; 1\nclippy::drop_ref 0 =&gt; 2\nclippy::unnecessary_fold 0 =&gt; 2\nclippy::neg_multiply 0 =&gt; 1\nclippy::while_let_loop 0 =&gt; 6\nclippy::missing_inline_in_public_items 0 =&gt; 37\nclippy::unnecessary_mut_passed 0 =&gt; 1\nunknown_lints 0 =&gt; 15\nclippy::wildcard_dependencies 0 =&gt; 3\nclippy::same_item_push 0 =&gt; 2\nclippy::useless_asref 0 =&gt; 1\nclippy::unnecessary_unwrap 0 =&gt; 4\nclippy::iter_not_returning_iterator 0 =&gt; 5\nclippy::comparison_to_empty 0 =&gt; 10\nclippy::ref_option_ref 0 =&gt; 4\nclippy::unused_peekable 0 =&gt; 1\nclippy::needless_range_loop 0 =&gt; 8\nclippy::absurd_extreme_comparisons 0 =&gt; 2\nclippy::unnecessary_operation 0 =&gt; 2\nclippy::for_kv_map 0 =&gt; 5\nclippy::unnecessary_owned_empty_strings 0 =&gt; 3\nclippy::transmutes_expressible_as_ptr_casts 0 =&gt; 1\nclippy::toplevel_ref_arg 0 =&gt; 2\nclippy::uninit_vec 0 =&gt; 3\nclippy::filter_next 0 =&gt; 1\nclippy::wildcard_in_or_patterns 0 =&gt; 6\nclippy::cast_ptr_alignment 0 =&gt; 48\nclippy::manual_memcpy 0 =&gt; 1\nclippy::assign_op_pattern 0 =&gt; 313\nclippy::unnecessary_lazy_evaluations 0 =&gt; 14\nclippy::println_empty_string 0 =&gt; 2\nclippy::redundant_pattern 0 =&gt; 2\nclippy::declare_interior_mutable_const 0 =&gt; 8\nclippy::large_stack_arrays 0 =&gt; 4\nclippy::match_bool 0 =&gt; 4\nclippy::unicode_not_nfc 0 =&gt; 2075\nclippy::inconsistent_digit_grouping 0 =&gt; 4\nclippy::no_effect_underscore_binding 0 =&gt; 2\nclippy::let_and_return 0 =&gt; 5\nclippy::transmute_ptr_to_ref 0 =&gt; 12\nclippy::op_ref 0 =&gt; 13\nclippy::unnecessary_join 0 =&gt; 4\nclippy::into_iter_on_ref 0 =&gt; 13\nclippy::from_str_radix_10 0 =&gt; 7\nclippy::ptr_offset_with_cast 0 =&gt; 48\nclippy::erasing_op 0 =&gt; 1\nclippy::swap_ptr_to_ref 0 =&gt; 3\nclippy::needless_bitwise_bool 0 =&gt; 2\nclippy::extend_with_drain 0 =&gt; 19\nclippy::only_used_in_recursion 0 =&gt; 4\nclippy::needless_late_init 0 =&gt; 8\nclippy::excessive_precision 0 =&gt; 1959\nclippy::match_ref_pats 0 =&gt; 10\nclippy::unit_arg 0 =&gt; 20\nclippy::bool_comparison 0 =&gt; 4\nclippy::bool_assert_comparison 0 =&gt; 1\nclippy::eq_op 0 =&gt; 6\nclippy::cast_abs_to_unsigned 0 =&gt; 6\nclippy::format_in_format_args 0 =&gt; 1\nclippy::iter_cloned_collect 0 =&gt; 4\nclippy::ptr_eq 0 =&gt; 3\nclippy::needless_bool 0 =&gt; 5\nclippy::transmute_ptr_to_ptr 0 =&gt; 16\nclippy::needless_option_take 0 =&gt; 2\nclippy::flat_map_identity 0 =&gt; 1\nclippy::needless_splitn 0 =&gt; 2\nclippy::blocks_in_if_conditions 0 =&gt; 1\nclippy::write_literal 0 =&gt; 1\nclippy::manual_split_once 0 =&gt; 1\nclippy::result_unit_err 0 =&gt; 36\nclippy::unused_unit 0 =&gt; 11\nclippy::single_match 0 =&gt; 22\nclippy::manual_find 0 =&gt; 3\nclippy::derive_ord_xor_partial_ord 0 =&gt; 6\nclippy::char_lit_as_u8 0 =&gt; 2\nclippy::let_unit_value 0 =&gt; 2\nclippy::needless_continue 0 =&gt; 19\nclippy::zero_sized_map_values 0 =&gt; 4\nclippy::needless_arbitrary_self_type 0 =&gt; 6\nclippy::partialeq_to_none 0 =&gt; 11\nclippy::partialeq_ne_impl 0 =&gt; 1\nclippy::invalid_upcast_comparisons 0 =&gt; 1\nclippy::mut_range_bound 0 =&gt; 4\nclippy::match_result_ok 0 =&gt; 2\nclippy::ptr_arg 0 =&gt; 8\nclippy::iter_nth_zero 0 =&gt; 18\nclippy::needless_for_each 0 =&gt; 1\nclippy::manual_unwrap_or 0 =&gt; 1\nclippy::transmute_int_to_float 0 =&gt; 6\nclippy::cast_slice_from_raw_parts 0 =&gt; 1\nclippy::match_wild_err_arm 0 =&gt; 2\nclippy::match_like_matches_macro 4 =&gt; 116\nclippy::enum_glob_use 50 =&gt; 380\nclippy::get_first 3 =&gt; 33\nclippy::needless_doctest_main 10 =&gt; 26\nclippy::struct_excessive_bools 19 =&gt; 51\nclippy::cast_possible_wrap 46 =&gt; 538\nclippy::manual_string_new 10 =&gt; 27\nclippy::match_same_arms 53 =&gt; 1039\nclippy::manual_non_exhaustive 1 =&gt; 33\nclippy::redundant_pattern_matching 2 =&gt; 13\nclippy::new_without_default 5 =&gt; 73\nclippy::option_as_ref_deref 2 =&gt; 9\nclippy::unwrap_or_else_default 2 =&gt; 4\nclippy::case_sensitive_file_extension_comparisons 6 =&gt; 9\nclippy::cast_precision_loss 45 =&gt; 110\nclippy::needless_pass_by_value 26 =&gt; 187\nclippy::redundant_closure_for_method_calls 170 =&gt; 539\nclippy::let_underscore_drop 33 =&gt; 133\nclippy::single_match_else 51 =&gt; 138\nclippy::needless_borrow 24 =&gt; 382\nclippy::redundant_else 37 =&gt; 151\nclippy::type_complexity 2 =&gt; 22\nclippy::ptr_as_ptr 93 =&gt; 1135\nclippy::needless_lifetimes 7 =&gt; 100\nclippy::single_char_add_str 2 =&gt; 22\nclippy::similar_names 99 =&gt; 352\nclippy::cargo_common_metadata 25 =&gt; 276\nclippy::int_plus_one 1 =&gt; 2\nclippy::missing_safety_doc 9 =&gt; 152\nclippy::redundant_slicing 2 =&gt; 13\nclippy::mut_mut 2 =&gt; 17\nclippy::derive_partial_eq_without_eq 8 =&gt; 141\nclippy::derive_hash_xor_eq 2 =&gt; 20\nclippy::from_iter_instead_of_collect 2 =&gt; 17\nclippy::verbose_bit_mask 1 =&gt; 8\nclippy::too_many_lines 58 =&gt; 162\nclippy::module_name_repetitions 178 =&gt; 1104\nclippy::explicit_into_iter_loop 12 =&gt; 32\nclippy::cast_lossless 45 =&gt; 478\nclippy::many_single_char_names 9 =&gt; 23\nclippy::unnested_or_patterns 27 =&gt; 127\nclippy::upper_case_acronyms 5 =&gt; 29\nclippy::needless_return 5 =&gt; 97\nclippy::precedence 1 =&gt; 11\nclippy::len_zero 2 =&gt; 70\nclippy::manual_strip 2 =&gt; 30\nclippy::derivable_impls 2 =&gt; 12\nclippy::unused_self 20 =&gt; 187\nclippy::enum_variant_names 1 =&gt; 6\nclippy::self_named_constructors 1 =&gt; 3\nclippy::explicit_auto_deref 19 =&gt; 314\nclippy::semicolon_if_nothing_returned 137 =&gt; 1861\nclippy::should_implement_trait 1 =&gt; 7\nclippy::expl_impl_clone_on_copy 159 =&gt; 1318\nclippy::stable_sort_primitive 4 =&gt; 12\nclippy::mem_replace_with_default 7 =&gt; 46\nclippy::borrow_deref_ref 5 =&gt; 140\nclippy::large_enum_variant 1 =&gt; 4\nclippy::map_unwrap_or 30 =&gt; 203\nclippy::zero_ptr 3 =&gt; 25\nclippy::filter_map_next 2 =&gt; 6\nclippy::identity_op 5 =&gt; 76\nclippy::checked_conversions 1 =&gt; 8\nclippy::len_without_is_empty 9 =&gt; 47\nclippy::missing_errors_doc 372 =&gt; 2333\nclippy::fn_params_excessive_bools 3 =&gt; 7\nclippy::single_component_path_imports 6 =&gt; 28\nclippy::unreadable_literal 366 =&gt; 9814\nclippy::field_reassign_with_default 1 =&gt; 5\nclippy::redundant_clone 1 =&gt; 8\nclippy::cloned_instead_of_copied 36 =&gt; 78\nclippy::too_many_arguments 4 =&gt; 22\nclippy::option_map_unit_fn 7 =&gt; 9\nclippy::extra_unused_lifetimes 1 =&gt; 24\nclippy::unnecessary_wraps 26 =&gt; 128\nclippy::used_underscore_binding 1 =&gt; 50\nclippy::inconsistent_struct_constructor 2 =&gt; 7\nclippy::manual_range_contains 9 =&gt; 120\nclippy::map_clone 7 =&gt; 46\nclippy::cast_slice_different_sizes 1 =&gt; 4\nclippy::missing_panics_doc 114 =&gt; 603\nrenamed_and_removed_lints 3 =&gt; 9\nclippy::items_after_statements 155 =&gt; 309\nclippy::inefficient_to_string 5 =&gt; 6\nclippy::comparison_chain 1 =&gt; 19\nclippy::crate_in_macro_def 3 =&gt; 6\nclippy::write_with_newline 2 =&gt; 36\nclippy::manual_saturating_arithmetic 1 =&gt; 2\nclippy::clone_on_copy 1 =&gt; 86\nclippy::negative_feature_names 3 =&gt; 16\nclippy::redundant_field_names 112 =&gt; 1013\nclippy::from_over_into 2 =&gt; 28\nclippy::wildcard_imports 178 =&gt; 376\nclippy::unusual_byte_groupings 19 =&gt; 65\nclippy::option_option 2 =&gt; 10\nclippy::nonminimal_bool 1 =&gt; 17\nclippy::borrow_as_ptr 2 =&gt; 172\nclippy::redundant_static_lifetimes 24 =&gt; 1701\nclippy::or_fun_call 1 =&gt; 63\nclippy::single_char_pattern 3 =&gt; 79\nclippy::explicit_iter_loop 72 =&gt; 148\nclippy::collapsible_else_if 2 =&gt; 27\nclippy::manual_str_repeat 1 =&gt; 6\nclippy::if_same_then_else 3 =&gt; 31\nclippy::while_let_on_iterator 4 =&gt; 28\nclippy::multiple_crate_versions 5 =&gt; 19\nclippy::cast_possible_truncation 115 =&gt; 1172\nclippy::explicit_deref_methods 1 =&gt; 38\nclippy::default_trait_access 48 =&gt; 130\nclippy::question_mark 2 =&gt; 28\nclippy::must_use_candidate 612 =&gt; 5369\nclippy::manual_map 1 =&gt; 12\nclippy::bool_to_int_with_if 2 =&gt; 15\nclippy::doc_markdown 202 =&gt; 1709\nclippy::cast_sign_loss 60 =&gt; 477\nclippy::wrong_self_convention 11 =&gt; 45\nclippy::transmute_float_to_int 6 =&gt; 18\nclippy::return_self_not_must_use 66 =&gt; 736\nclippy::range_plus_one 1 =&gt; 36\nclippy::manual_assert 11 =&gt; 62\nclippy::trivially_copy_pass_by_ref 40 =&gt; 189\nclippy::match_on_vec_items 2 =&gt; 7\nclippy::inline_always 59 =&gt; 1079\nclippy::if_not_else 31 =&gt; 205\nclippy::implicit_clone 10 =&gt; 32\nclippy::match_wildcard_for_single_variants 16 =&gt; 101\nclippy::doc_link_with_quotes 7 =&gt; 35\nclippy::redundant_feature_names 4 =&gt; 41\n</code></pre></details>\n\nchangelog: none", "tree": {"sha": "535340407dc55a2b7119b8fd8b0c1738dbd4f9ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/535340407dc55a2b7119b8fd8b0c1738dbd4f9ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "html_url": "https://github.com/rust-lang/rust/commit/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a78551bb14733216f734660d0598d392a6c5db20", "url": "https://api.github.com/repos/rust-lang/rust/commits/a78551bb14733216f734660d0598d392a6c5db20", "html_url": "https://github.com/rust-lang/rust/commit/a78551bb14733216f734660d0598d392a6c5db20"}, {"sha": "fc77d91469244bbba292d6746d7f206dbba812b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc77d91469244bbba292d6746d7f206dbba812b5", "html_url": "https://github.com/rust-lang/rust/commit/fc77d91469244bbba292d6746d7f206dbba812b5"}], "stats": {"total": 394, "additions": 339, "deletions": 55}, "files": [{"sha": "de31c16b819ef1f4d55ef5d8a4685325c379f4fc", "filename": "lintcheck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FCargo.toml?ref=31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "patch": "@@ -12,9 +12,11 @@ publish = false\n [dependencies]\n cargo_metadata = \"0.14\"\n clap = \"3.2\"\n+crossbeam-channel = \"0.5.6\"\n flate2 = \"1.0\"\n rayon = \"1.5.1\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0.85\"\n tar = \"0.4\"\n toml = \"0.5\"\n ureq = \"2.2\""}, {"sha": "6142de5e3130ec690934dce83af8aeee3c01d2c1", "filename": "lintcheck/README.md", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FREADME.md?ref=31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "patch": "@@ -69,9 +69,27 @@ is checked.\n is explicitly specified in the options.\n \n ### Fix mode\n-You can run `./lintcheck/target/debug/lintcheck --fix` which will run Clippy with `--fix` and\n+You can run `cargo lintcheck --fix` which will run Clippy with `--fix` and\n print a warning if Clippy's suggestions fail to apply (if the resulting code does not build).  \n This lets us spot bad suggestions or false positives automatically in some cases.  \n \n Please note that the target dir should be cleaned afterwards since clippy will modify\n the downloaded sources which can lead to unexpected results when running lintcheck again afterwards.\n+\n+### Recursive mode\n+You can run `cargo lintcheck --recursive` to also run Clippy on the dependencies\n+of the crates listed in the crates source `.toml`. e.g. adding `rand 0.8.5`\n+would also lint `rand_core`, `rand_chacha`, etc.\n+\n+Particularly slow crates in the dependency graph can be ignored using\n+`recursive.ignore`:\n+\n+```toml\n+[crates]\n+cargo = {name = \"cargo\", versions = ['0.64.0']}\n+\n+[recursive]\n+ignore = [\n+    \"unicode-normalization\",\n+]\n+```"}, {"sha": "52f7fee47b616e578e4b78be944adc1117e6a977", "filename": "lintcheck/lintcheck_crates.toml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Flintcheck_crates.toml", "raw_url": "https://github.com/rust-lang/rust/raw/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Flintcheck_crates.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Flintcheck_crates.toml?ref=31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "patch": "@@ -33,3 +33,11 @@ cfg-expr = {name = \"cfg-expr\", versions = ['0.7.1']}\n puffin = {name = \"puffin\", git_url = \"https://github.com/EmbarkStudios/puffin\", git_hash = \"02dd4a3\"}\n rpmalloc = {name = \"rpmalloc\", versions = ['0.2.0']}\n tame-oidc = {name = \"tame-oidc\", versions = ['0.1.0']}\n+\n+[recursive]\n+ignore = [\n+    # Takes ~30s to lint\n+    \"combine\",\n+    # Has 1.2 million `clippy::match_same_arms`s\n+    \"unicode-normalization\",\n+]"}, {"sha": "b344db634f612c6a4950e93cc79440db6ad89907", "filename": "lintcheck/src/config.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fconfig.rs?ref=31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "patch": "@@ -34,11 +34,16 @@ fn get_clap_config() -> ArgMatches {\n             Arg::new(\"markdown\")\n                 .long(\"markdown\")\n                 .help(\"Change the reports table to use markdown links\"),\n+            Arg::new(\"recursive\")\n+                .long(\"--recursive\")\n+                .help(\"Run clippy on the dependencies of crates specified in crates-toml\")\n+                .conflicts_with(\"threads\")\n+                .conflicts_with(\"fix\"),\n         ])\n         .get_matches()\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub(crate) struct LintcheckConfig {\n     /// max number of jobs to spawn (default 1)\n     pub max_jobs: usize,\n@@ -54,6 +59,8 @@ pub(crate) struct LintcheckConfig {\n     pub lint_filter: Vec<String>,\n     /// Indicate if the output should support markdown syntax\n     pub markdown: bool,\n+    /// Run clippy on the dependencies of crates\n+    pub recursive: bool,\n }\n \n impl LintcheckConfig {\n@@ -119,6 +126,7 @@ impl LintcheckConfig {\n             fix: clap_config.contains_id(\"fix\"),\n             lint_filter,\n             markdown,\n+            recursive: clap_config.contains_id(\"recursive\"),\n         }\n     }\n }"}, {"sha": "63221bab32d313fde2b44db339d6d835d789b224", "filename": "lintcheck/src/driver.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fdriver.rs?ref=31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "patch": "@@ -0,0 +1,67 @@\n+use crate::recursive::{deserialize_line, serialize_line, DriverInfo};\n+\n+use std::io::{self, BufReader, Write};\n+use std::net::TcpStream;\n+use std::process::{self, Command, Stdio};\n+use std::{env, mem};\n+\n+/// 1. Sends [DriverInfo] to the [crate::recursive::LintcheckServer] running on `addr`\n+/// 2. Receives [bool] from the server, if `false` returns `None`\n+/// 3. Otherwise sends the stderr of running `clippy-driver` to the server\n+fn run_clippy(addr: &str) -> Option<i32> {\n+    let driver_info = DriverInfo {\n+        package_name: env::var(\"CARGO_PKG_NAME\").ok()?,\n+        crate_name: env::var(\"CARGO_CRATE_NAME\").ok()?,\n+        version: env::var(\"CARGO_PKG_VERSION\").ok()?,\n+    };\n+\n+    let mut stream = BufReader::new(TcpStream::connect(addr).unwrap());\n+\n+    serialize_line(&driver_info, stream.get_mut());\n+\n+    let should_run = deserialize_line::<bool, _>(&mut stream);\n+    if !should_run {\n+        return None;\n+    }\n+\n+    // Remove --cap-lints allow so that clippy runs and lints are emitted\n+    let mut include_next = true;\n+    let args = env::args().skip(1).filter(|arg| match arg.as_str() {\n+        \"--cap-lints=allow\" => false,\n+        \"--cap-lints\" => {\n+            include_next = false;\n+            false\n+        },\n+        _ => mem::replace(&mut include_next, true),\n+    });\n+\n+    let output = Command::new(env::var(\"CLIPPY_DRIVER\").expect(\"missing env CLIPPY_DRIVER\"))\n+        .args(args)\n+        .stdout(Stdio::inherit())\n+        .output()\n+        .expect(\"failed to run clippy-driver\");\n+\n+    stream\n+        .get_mut()\n+        .write_all(&output.stderr)\n+        .unwrap_or_else(|e| panic!(\"{e:?} in {driver_info:?}\"));\n+\n+    match output.status.code() {\n+        Some(0) => Some(0),\n+        code => {\n+            io::stderr().write_all(&output.stderr).unwrap();\n+            Some(code.expect(\"killed by signal\"))\n+        },\n+    }\n+}\n+\n+pub fn drive(addr: &str) {\n+    process::exit(run_clippy(addr).unwrap_or_else(|| {\n+        Command::new(\"rustc\")\n+            .args(env::args_os().skip(2))\n+            .status()\n+            .unwrap()\n+            .code()\n+            .unwrap()\n+    }))\n+}"}, {"sha": "cc2b3e1acec7104e6d63249172fe5f6a6cba336c", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 111, "deletions": 53, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "patch": "@@ -8,43 +8,44 @@\n #![allow(clippy::collapsible_else_if)]\n \n mod config;\n+mod driver;\n+mod recursive;\n \n-use config::LintcheckConfig;\n+use crate::config::LintcheckConfig;\n+use crate::recursive::LintcheckServer;\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::env;\n+use std::env::consts::EXE_SUFFIX;\n use std::fmt::Write as _;\n-use std::fs::write;\n+use std::fs;\n use std::io::ErrorKind;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread;\n use std::time::Duration;\n \n-use cargo_metadata::diagnostic::DiagnosticLevel;\n+use cargo_metadata::diagnostic::{Diagnostic, DiagnosticLevel};\n use cargo_metadata::Message;\n use rayon::prelude::*;\n use serde::{Deserialize, Serialize};\n use walkdir::{DirEntry, WalkDir};\n \n-#[cfg(not(windows))]\n-const CLIPPY_DRIVER_PATH: &str = \"target/debug/clippy-driver\";\n-#[cfg(not(windows))]\n-const CARGO_CLIPPY_PATH: &str = \"target/debug/cargo-clippy\";\n-\n-#[cfg(windows)]\n-const CLIPPY_DRIVER_PATH: &str = \"target/debug/clippy-driver.exe\";\n-#[cfg(windows)]\n-const CARGO_CLIPPY_PATH: &str = \"target/debug/cargo-clippy.exe\";\n-\n const LINTCHECK_DOWNLOADS: &str = \"target/lintcheck/downloads\";\n const LINTCHECK_SOURCES: &str = \"target/lintcheck/sources\";\n \n /// List of sources to check, loaded from a .toml file\n #[derive(Debug, Serialize, Deserialize)]\n struct SourceList {\n     crates: HashMap<String, TomlCrate>,\n+    #[serde(default)]\n+    recursive: RecursiveOptions,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Default)]\n+struct RecursiveOptions {\n+    ignore: HashSet<String>,\n }\n \n /// A crate source stored inside the .toml\n@@ -105,12 +106,7 @@ struct ClippyWarning {\n \n #[allow(unused)]\n impl ClippyWarning {\n-    fn new(cargo_message: Message, krate: &Crate) -> Option<Self> {\n-        let diag = match cargo_message {\n-            Message::CompilerMessage(message) => message.message,\n-            _ => return None,\n-        };\n-\n+    fn new(diag: Diagnostic, crate_name: &str, crate_version: &str) -> Option<Self> {\n         let lint_type = diag.code?.code;\n         if !(lint_type.contains(\"clippy\") || diag.message.contains(\"clippy\"))\n             || diag.message.contains(\"could not read cargo metadata\")\n@@ -124,12 +120,12 @@ impl ClippyWarning {\n             Ok(stripped) => format!(\"$CARGO_HOME/{}\", stripped.display()),\n             Err(_) => format!(\n                 \"target/lintcheck/sources/{}-{}/{}\",\n-                krate.name, krate.version, span.file_name\n+                crate_name, crate_version, span.file_name\n             ),\n         };\n \n         Some(Self {\n-            crate_name: krate.name.clone(),\n+            crate_name: crate_name.to_owned(),\n             file,\n             line: span.line_start,\n             column: span.column_start,\n@@ -142,16 +138,14 @@ impl ClippyWarning {\n     fn to_output(&self, markdown: bool) -> String {\n         let file_with_pos = format!(\"{}:{}:{}\", &self.file, &self.line, &self.column);\n         if markdown {\n-            let lint = format!(\"`{}`\", self.lint_type);\n-\n             let mut file = self.file.clone();\n             if !file.starts_with('$') {\n                 file.insert_str(0, \"../\");\n             }\n \n             let mut output = String::from(\"| \");\n             let _ = write!(output, \"[`{}`]({}#L{})\", file_with_pos, file, self.line);\n-            let _ = write!(output, r#\" | {:<50} | \"{}\" |\"#, lint, self.message);\n+            let _ = write!(output, r#\" | `{:<50}` | \"{}\" |\"#, self.lint_type, self.message);\n             output.push('\\n');\n             output\n         } else {\n@@ -243,6 +237,7 @@ impl CrateSource {\n                 }\n                 // check out the commit/branch/whatever\n                 if !Command::new(\"git\")\n+                    .args([\"-c\", \"advice.detachedHead=false\"])\n                     .arg(\"checkout\")\n                     .arg(commit)\n                     .current_dir(&repo_path)\n@@ -309,10 +304,12 @@ impl Crate {\n     fn run_clippy_lints(\n         &self,\n         cargo_clippy_path: &Path,\n+        clippy_driver_path: &Path,\n         target_dir_index: &AtomicUsize,\n         total_crates_to_lint: usize,\n         config: &LintcheckConfig,\n         lint_filter: &Vec<String>,\n+        server: &Option<LintcheckServer>,\n     ) -> Vec<ClippyWarning> {\n         // advance the atomic index by one\n         let index = target_dir_index.fetch_add(1, Ordering::SeqCst);\n@@ -336,36 +333,67 @@ impl Crate {\n \n         let shared_target_dir = clippy_project_root().join(\"target/lintcheck/shared_target_dir\");\n \n-        let mut args = if config.fix {\n+        let mut cargo_clippy_args = if config.fix {\n             vec![\"--fix\", \"--\"]\n         } else {\n             vec![\"--\", \"--message-format=json\", \"--\"]\n         };\n \n+        let mut clippy_args = Vec::<&str>::new();\n         if let Some(options) = &self.options {\n             for opt in options {\n-                args.push(opt);\n+                clippy_args.push(opt);\n             }\n         } else {\n-            args.extend(&[\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n+            clippy_args.extend(&[\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n         }\n \n         if lint_filter.is_empty() {\n-            args.push(\"--cap-lints=warn\");\n+            clippy_args.push(\"--cap-lints=warn\");\n         } else {\n-            args.push(\"--cap-lints=allow\");\n-            args.extend(lint_filter.iter().map(|filter| filter.as_str()))\n+            clippy_args.push(\"--cap-lints=allow\");\n+            clippy_args.extend(lint_filter.iter().map(|filter| filter.as_str()))\n+        }\n+\n+        if let Some(server) = server {\n+            let target = shared_target_dir.join(\"recursive\");\n+\n+            // `cargo clippy` is a wrapper around `cargo check` that mainly sets `RUSTC_WORKSPACE_WRAPPER` to\n+            // `clippy-driver`. We do the same thing here with a couple changes:\n+            //\n+            // `RUSTC_WRAPPER` is used instead of `RUSTC_WORKSPACE_WRAPPER` so that we can lint all crate\n+            // dependencies rather than only workspace members\n+            //\n+            // The wrapper is set to the `lintcheck` so we can force enable linting and ignore certain crates\n+            // (see `crate::driver`)\n+            let status = Command::new(\"cargo\")\n+                .arg(\"check\")\n+                .arg(\"--quiet\")\n+                .current_dir(&self.path)\n+                .env(\"CLIPPY_ARGS\", clippy_args.join(\"__CLIPPY_HACKERY__\"))\n+                .env(\"CARGO_TARGET_DIR\", target)\n+                .env(\"RUSTC_WRAPPER\", env::current_exe().unwrap())\n+                // Pass the absolute path so `crate::driver` can find `clippy-driver`, as it's executed in various\n+                // different working directories\n+                .env(\"CLIPPY_DRIVER\", clippy_driver_path)\n+                .env(\"LINTCHECK_SERVER\", server.local_addr.to_string())\n+                .status()\n+                .expect(\"failed to run cargo\");\n+\n+            assert_eq!(status.code(), Some(0));\n+\n+            return Vec::new();\n         }\n \n-        let all_output = std::process::Command::new(&cargo_clippy_path)\n+        cargo_clippy_args.extend(clippy_args);\n+\n+        let all_output = Command::new(&cargo_clippy_path)\n             // use the looping index to create individual target dirs\n             .env(\n                 \"CARGO_TARGET_DIR\",\n                 shared_target_dir.join(format!(\"_{:?}\", thread_index)),\n             )\n-            // lint warnings will look like this:\n-            // src/cargo/ops/cargo_compile.rs:127:35: warning: usage of `FromIterator::from_iter`\n-            .args(&args)\n+            .args(&cargo_clippy_args)\n             .current_dir(&self.path)\n             .output()\n             .unwrap_or_else(|error| {\n@@ -404,7 +432,10 @@ impl Crate {\n \n         // get all clippy warnings and ICEs\n         let warnings: Vec<ClippyWarning> = Message::parse_stream(stdout.as_bytes())\n-            .filter_map(|msg| ClippyWarning::new(msg.unwrap(), &self))\n+            .filter_map(|msg| match msg {\n+                Ok(Message::CompilerMessage(message)) => ClippyWarning::new(message.message, &self.name, &self.version),\n+                _ => None,\n+            })\n             .collect();\n \n         warnings\n@@ -423,8 +454,8 @@ fn build_clippy() {\n     }\n }\n \n-/// Read a `toml` file and return a list of `CrateSources` that we want to check with clippy\n-fn read_crates(toml_path: &Path) -> Vec<CrateSource> {\n+/// Read a `lintcheck_crates.toml` file\n+fn read_crates(toml_path: &Path) -> (Vec<CrateSource>, RecursiveOptions) {\n     let toml_content: String =\n         std::fs::read_to_string(&toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n     let crate_list: SourceList =\n@@ -484,7 +515,7 @@ fn read_crates(toml_path: &Path) -> Vec<CrateSource> {\n     // sort the crates\n     crate_sources.sort();\n \n-    crate_sources\n+    (crate_sources, crate_list.recursive)\n }\n \n /// Generate a short list of occurring lints-types and their count\n@@ -516,20 +547,20 @@ fn gather_stats(clippy_warnings: &[ClippyWarning]) -> (String, HashMap<&String,\n \n /// check if the latest modification of the logfile is older than the modification date of the\n /// clippy binary, if this is true, we should clean the lintchec shared target directory and recheck\n-fn lintcheck_needs_rerun(lintcheck_logs_path: &Path) -> bool {\n+fn lintcheck_needs_rerun(lintcheck_logs_path: &Path, paths: [&Path; 2]) -> bool {\n     if !lintcheck_logs_path.exists() {\n         return true;\n     }\n \n     let clippy_modified: std::time::SystemTime = {\n-        let mut times = [CLIPPY_DRIVER_PATH, CARGO_CLIPPY_PATH].iter().map(|p| {\n+        let [cargo, driver] = paths.map(|p| {\n             std::fs::metadata(p)\n                 .expect(\"failed to get metadata of file\")\n                 .modified()\n                 .expect(\"failed to get modification date\")\n         });\n         // the oldest modification of either of the binaries\n-        std::cmp::max(times.next().unwrap(), times.next().unwrap())\n+        std::cmp::max(cargo, driver)\n     };\n \n     let logs_modified: std::time::SystemTime = std::fs::metadata(lintcheck_logs_path)\n@@ -543,6 +574,11 @@ fn lintcheck_needs_rerun(lintcheck_logs_path: &Path) -> bool {\n }\n \n fn main() {\n+    // We're being executed as a `RUSTC_WRAPPER` as part of `--recursive`\n+    if let Ok(addr) = env::var(\"LINTCHECK_SERVER\") {\n+        driver::drive(&addr);\n+    }\n+\n     // assert that we launch lintcheck from the repo root (via cargo lintcheck)\n     if std::fs::metadata(\"lintcheck/Cargo.toml\").is_err() {\n         eprintln!(\"lintcheck needs to be run from clippy's repo root!\\nUse `cargo lintcheck` alternatively.\");\n@@ -555,9 +591,15 @@ fn main() {\n     build_clippy();\n     println!(\"Done compiling\");\n \n+    let cargo_clippy_path = fs::canonicalize(format!(\"target/debug/cargo-clippy{EXE_SUFFIX}\")).unwrap();\n+    let clippy_driver_path = fs::canonicalize(format!(\"target/debug/clippy-driver{EXE_SUFFIX}\")).unwrap();\n+\n     // if the clippy bin is newer than our logs, throw away target dirs to force clippy to\n     // refresh the logs\n-    if lintcheck_needs_rerun(&config.lintcheck_results_path) {\n+    if lintcheck_needs_rerun(\n+        &config.lintcheck_results_path,\n+        [&cargo_clippy_path, &clippy_driver_path],\n+    ) {\n         let shared_target_dir = \"target/lintcheck/shared_target_dir\";\n         // if we get an Err here, the shared target dir probably does simply not exist\n         if let Ok(metadata) = std::fs::metadata(&shared_target_dir) {\n@@ -569,18 +611,14 @@ fn main() {\n         }\n     }\n \n-    let cargo_clippy_path: PathBuf = PathBuf::from(CARGO_CLIPPY_PATH)\n-        .canonicalize()\n-        .expect(\"failed to canonicalize path to clippy binary\");\n-\n     // assert that clippy is found\n     assert!(\n         cargo_clippy_path.is_file(),\n         \"target/debug/cargo-clippy binary not found! {}\",\n         cargo_clippy_path.display()\n     );\n \n-    let clippy_ver = std::process::Command::new(CARGO_CLIPPY_PATH)\n+    let clippy_ver = std::process::Command::new(&cargo_clippy_path)\n         .arg(\"--version\")\n         .output()\n         .map(|o| String::from_utf8_lossy(&o.stdout).into_owned())\n@@ -589,7 +627,7 @@ fn main() {\n     // download and extract the crates, then run clippy on them and collect clippy's warnings\n     // flatten into one big list of warnings\n \n-    let crates = read_crates(&config.sources_toml_path);\n+    let (crates, recursive_options) = read_crates(&config.sources_toml_path);\n     let old_stats = read_stats_from_file(&config.lintcheck_results_path);\n \n     let counter = AtomicUsize::new(1);\n@@ -639,11 +677,31 @@ fn main() {\n         .build_global()\n         .unwrap();\n \n-    let clippy_warnings: Vec<ClippyWarning> = crates\n+    let server = config.recursive.then(|| {\n+        let _ = fs::remove_dir_all(\"target/lintcheck/shared_target_dir/recursive\");\n+\n+        LintcheckServer::spawn(recursive_options)\n+    });\n+\n+    let mut clippy_warnings: Vec<ClippyWarning> = crates\n         .par_iter()\n-        .flat_map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, crates.len(), &config, &lint_filter))\n+        .flat_map(|krate| {\n+            krate.run_clippy_lints(\n+                &cargo_clippy_path,\n+                &clippy_driver_path,\n+                &counter,\n+                crates.len(),\n+                &config,\n+                &lint_filter,\n+                &server,\n+            )\n+        })\n         .collect();\n \n+    if let Some(server) = server {\n+        clippy_warnings.extend(server.warnings());\n+    }\n+\n     // if we are in --fix mode, don't change the log files, terminate here\n     if config.fix {\n         return;\n@@ -681,8 +739,8 @@ fn main() {\n     }\n \n     println!(\"Writing logs to {}\", config.lintcheck_results_path.display());\n-    std::fs::create_dir_all(config.lintcheck_results_path.parent().unwrap()).unwrap();\n-    write(&config.lintcheck_results_path, text).unwrap();\n+    fs::create_dir_all(config.lintcheck_results_path.parent().unwrap()).unwrap();\n+    fs::write(&config.lintcheck_results_path, text).unwrap();\n \n     print_stats(old_stats, new_stats, &config.lint_filter);\n }"}, {"sha": "67dcfc2b199c4a2f1f191e041a72a280d16da1f7", "filename": "lintcheck/src/recursive.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Fsrc%2Frecursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b17411a6cd5c4b36cde6ff008de1d3ec128ac4/lintcheck%2Fsrc%2Frecursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Frecursive.rs?ref=31b17411a6cd5c4b36cde6ff008de1d3ec128ac4", "patch": "@@ -0,0 +1,123 @@\n+//! In `--recursive` mode we set the `lintcheck` binary as the `RUSTC_WRAPPER` of `cargo check`,\n+//! this allows [crate::driver] to be run for every dependency. The driver connects to\n+//! [LintcheckServer] to ask if it should be skipped, and if not sends the stderr of running clippy\n+//! on the crate to the server\n+\n+use crate::ClippyWarning;\n+use crate::RecursiveOptions;\n+\n+use std::collections::HashSet;\n+use std::io::{BufRead, BufReader, Read, Write};\n+use std::net::{SocketAddr, TcpListener, TcpStream};\n+use std::sync::{Arc, Mutex};\n+use std::thread;\n+\n+use cargo_metadata::diagnostic::Diagnostic;\n+use crossbeam_channel::{Receiver, Sender};\n+use serde::de::DeserializeOwned;\n+use serde::{Deserialize, Serialize};\n+\n+#[derive(Debug, Eq, Hash, PartialEq, Clone, Serialize, Deserialize)]\n+pub(crate) struct DriverInfo {\n+    pub package_name: String,\n+    pub crate_name: String,\n+    pub version: String,\n+}\n+\n+pub(crate) fn serialize_line<T, W>(value: &T, writer: &mut W)\n+where\n+    T: Serialize,\n+    W: Write,\n+{\n+    let mut buf = serde_json::to_vec(&value).expect(\"failed to serialize\");\n+    buf.push(b'\\n');\n+    writer.write_all(&buf).expect(\"write_all failed\");\n+}\n+\n+pub(crate) fn deserialize_line<T, R>(reader: &mut R) -> T\n+where\n+    T: DeserializeOwned,\n+    R: BufRead,\n+{\n+    let mut string = String::new();\n+    reader.read_line(&mut string).expect(\"read_line failed\");\n+    serde_json::from_str(&string).expect(\"failed to deserialize\")\n+}\n+\n+fn process_stream(\n+    stream: TcpStream,\n+    sender: &Sender<ClippyWarning>,\n+    options: &RecursiveOptions,\n+    seen: &Mutex<HashSet<DriverInfo>>,\n+) {\n+    let mut stream = BufReader::new(stream);\n+\n+    let driver_info: DriverInfo = deserialize_line(&mut stream);\n+\n+    let unseen = seen.lock().unwrap().insert(driver_info.clone());\n+    let ignored = options.ignore.contains(&driver_info.package_name);\n+    let should_run = unseen && !ignored;\n+\n+    serialize_line(&should_run, stream.get_mut());\n+\n+    let mut stderr = String::new();\n+    stream.read_to_string(&mut stderr).unwrap();\n+\n+    let messages = stderr\n+        .lines()\n+        .filter_map(|json_msg| serde_json::from_str::<Diagnostic>(json_msg).ok())\n+        .filter_map(|diag| ClippyWarning::new(diag, &driver_info.package_name, &driver_info.version));\n+\n+    for message in messages {\n+        sender.send(message).unwrap();\n+    }\n+}\n+\n+pub(crate) struct LintcheckServer {\n+    pub local_addr: SocketAddr,\n+    receiver: Receiver<ClippyWarning>,\n+    sender: Arc<Sender<ClippyWarning>>,\n+}\n+\n+impl LintcheckServer {\n+    pub fn spawn(options: RecursiveOptions) -> Self {\n+        let listener = TcpListener::bind(\"localhost:0\").unwrap();\n+        let local_addr = listener.local_addr().unwrap();\n+\n+        let (sender, receiver) = crossbeam_channel::unbounded::<ClippyWarning>();\n+        let sender = Arc::new(sender);\n+        // The spawned threads hold a `Weak<Sender>` so that they don't keep the channel connected\n+        // indefinitely\n+        let sender_weak = Arc::downgrade(&sender);\n+\n+        // Ignore dependencies multiple times, e.g. for when it's both checked and compiled for a\n+        // build dependency\n+        let seen = Mutex::default();\n+\n+        thread::spawn(move || {\n+            thread::scope(|s| {\n+                s.spawn(|| {\n+                    while let Ok((stream, _)) = listener.accept() {\n+                        let sender = sender_weak.upgrade().expect(\"received connection after server closed\");\n+                        let options = &options;\n+                        let seen = &seen;\n+                        s.spawn(move || process_stream(stream, &sender, options, seen));\n+                    }\n+                });\n+            });\n+        });\n+\n+        Self {\n+            local_addr,\n+            sender,\n+            receiver,\n+        }\n+    }\n+\n+    pub fn warnings(self) -> impl Iterator<Item = ClippyWarning> {\n+        // causes the channel to become disconnected so that the receiver iterator ends\n+        drop(self.sender);\n+\n+        self.receiver.into_iter()\n+    }\n+}"}]}