{"sha": "7548cb42735807ff423a4af7414542558e2d83dd", "node_id": "C_kwDOAAsO6NoAKDc1NDhjYjQyNzM1ODA3ZmY0MjNhNGFmNzQxNDU0MjU1OGUyZDgzZGQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-10T12:32:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-10T12:32:03Z"}, "message": "Merge #10508\n\n10508: internal: move some tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "1e12a9218e653666f9c3618087d041649542450f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e12a9218e653666f9c3618087d041649542450f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7548cb42735807ff423a4af7414542558e2d83dd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhYt1DCRBK7hj4Ov3rIwAA/qUIAGm74GztMYWQgJahvh9xD9Gl\nCKSzIzi34PJQ6iAra86vS09uGdS+6FGQhLKAsPhx/6XDPr96/uen0MbIINUtngUW\nD6FGMcChGZD66jMQPuQFBfnF0jALX8cpJFaUWisqo9LpwY4+/6EaIMIqp8URFBX8\nggBS+OYW5fmYQMJ4qm69AeJ88u7nnSEkpqRuf1yKHJZ8x7GHK3n3IFp3q24CbJ58\nP3opkNWG4OIEj5+CVa/WQ5qDt4xiSedu/+hKPBEKRdYQ96aMGaxEQNAKCAqaiura\nDjJ6pFNjGvIQPWGgLnb1rTQcOsyhTXiFCoWElQ+qNrXh6ZKxsg+XpdIBZFPzvWE=\n=0mHO\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e12a9218e653666f9c3618087d041649542450f\nparent 93c52f5d2399c8e0a23bf50ff660400019d09751\nparent e5acf650d0ec90058fa0ab378e1ae5dae903c98e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1633869123 +0000\ncommitter GitHub <noreply@github.com> 1633869123 +0000\n\nMerge #10508\n\n10508: internal: move some tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7548cb42735807ff423a4af7414542558e2d83dd", "html_url": "https://github.com/rust-lang/rust/commit/7548cb42735807ff423a4af7414542558e2d83dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7548cb42735807ff423a4af7414542558e2d83dd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93c52f5d2399c8e0a23bf50ff660400019d09751", "url": "https://api.github.com/repos/rust-lang/rust/commits/93c52f5d2399c8e0a23bf50ff660400019d09751", "html_url": "https://github.com/rust-lang/rust/commit/93c52f5d2399c8e0a23bf50ff660400019d09751"}, {"sha": "e5acf650d0ec90058fa0ab378e1ae5dae903c98e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5acf650d0ec90058fa0ab378e1ae5dae903c98e", "html_url": "https://github.com/rust-lang/rust/commit/e5acf650d0ec90058fa0ab378e1ae5dae903c98e"}], "stats": {"total": 3167, "additions": 1688, "deletions": 1479}, "files": [{"sha": "c317dc27a58350cae02bf3dd99e8b7c1f753add2", "filename": "crates/hir_def/src/macro_expansion_tests.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs?ref=7548cb42735807ff423a4af7414542558e2d83dd", "patch": "@@ -10,6 +10,7 @@\n //! and harder to understand.\n \n mod mbe;\n+mod builtin;\n \n use std::{iter, ops::Range};\n \n@@ -20,14 +21,15 @@ use stdx::format_to;\n use syntax::{\n     ast::{self, edit::IndentLevel},\n     AstNode,\n-    SyntaxKind::{EOF, IDENT, LIFETIME_IDENT},\n+    SyntaxKind::{COMMENT, EOF, IDENT, LIFETIME_IDENT},\n     SyntaxNode, T,\n };\n \n use crate::{\n     db::DefDatabase, nameres::ModuleSource, resolver::HasResolver, test_db::TestDB, AsMacroCall,\n };\n \n+#[track_caller]\n fn check(ra_fixture: &str, mut expect: Expect) {\n     let db = TestDB::with_files(ra_fixture);\n     let krate = db.crate_graph().iter().next().unwrap();\n@@ -44,37 +46,54 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n     let mut expansions = Vec::new();\n     for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n         let macro_call = InFile::new(source.file_id, &macro_call);\n+        let mut error = None;\n         let macro_call_id = macro_call\n             .as_call_id_with_errors(\n                 &db,\n                 krate,\n                 |path| resolver.resolve_path_as_macro(&db, &path),\n-                &mut |err| panic!(\"{}\", err),\n+                &mut |err| error = Some(err),\n             )\n             .unwrap()\n             .unwrap();\n         let macro_file = MacroFile { macro_call_id };\n-        let expansion_result = db.parse_macro_expansion(macro_file);\n+        let mut expansion_result = db.parse_macro_expansion(macro_file);\n+        expansion_result.err = expansion_result.err.or(error);\n         expansions.push((macro_call.value.clone(), expansion_result));\n     }\n \n     let mut expanded_text = source_file.to_string();\n     for (call, exp) in expansions.into_iter().rev() {\n+        let mut tree = false;\n+        let mut expect_errors = false;\n+        for comment in call.syntax().children_with_tokens().filter(|it| it.kind() == COMMENT) {\n+            tree |= comment.to_string().contains(\"+tree\");\n+            expect_errors |= comment.to_string().contains(\"+errors\");\n+        }\n+\n         let mut expn_text = String::new();\n         if let Some(err) = exp.err {\n             format_to!(expn_text, \"/* error: {} */\", err);\n         }\n         if let Some((parse, _token_map)) = exp.value {\n-            assert!(\n-                parse.errors().is_empty(),\n-                \"parse errors in expansion: \\n{:#?}\",\n-                parse.errors()\n-            );\n+            if expect_errors {\n+                assert!(!parse.errors().is_empty(), \"no parse errors in expansion\");\n+                for e in parse.errors() {\n+                    format_to!(expn_text, \"/* parse error: {} */\\n\", e);\n+                }\n+            } else {\n+                assert!(\n+                    parse.errors().is_empty(),\n+                    \"parse errors in expansion: \\n{:#?}\",\n+                    parse.errors()\n+                );\n+            }\n             let pp = pretty_print_macro_expansion(parse.syntax_node());\n             let indent = IndentLevel::from_node(call.syntax());\n             let pp = reindent(indent, pp);\n             format_to!(expn_text, \"{}\", pp);\n-            if call.to_string().contains(\"// +tree\") {\n+\n+            if tree {\n                 let tree = format!(\"{:#?}\", parse.syntax_node())\n                     .split_inclusive(\"\\n\")\n                     .map(|line| format!(\"// {}\", line))\n@@ -129,6 +148,8 @@ fn pretty_print_macro_expansion(expn: SyntaxNode) -> String {\n             (T![->], _) | (_, T![->]) => \" \",\n             (T![&&], _) | (_, T![&&]) => \" \",\n             (T![,], _) => \" \",\n+            (T![:], IDENT | T!['(']) => \" \",\n+            (T![:], _) if curr_kind.is_keyword() => \" \",\n             (T![fn], T!['(']) => \"\",\n             (T![']'], _) if curr_kind.is_keyword() => \" \",\n             (T![']'], T![#]) => \"\\n\","}, {"sha": "6982116522c6ce6fddfc6b7355ed73b391e49a7f", "filename": "crates/hir_def/src/macro_expansion_tests/builtin.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin.rs?ref=7548cb42735807ff423a4af7414542558e2d83dd", "patch": "@@ -0,0 +1,332 @@\n+//! Tests for builtin macros (see `builtin_macro.rs` in `hir_expand`).\n+\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn test_column_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! column {() => {}}\n+\n+fn main() { column!(); }\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! column {() => {}}\n+\n+fn main() { 0; }\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_line_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! line {() => {}}\n+\n+fn main() { line!() }\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! line {() => {}}\n+\n+fn main() { 0 }\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_stringify_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! stringify {() => {}}\n+\n+fn main() {\n+    stringify!(\n+        a\n+        b\n+        c\n+    );\n+}\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! stringify {() => {}}\n+\n+fn main() {\n+    \"a b c\";\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_env_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! env {() => {}}\n+\n+fn main() { env!(\"TEST_ENV_VAR\"); }\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! env {() => {}}\n+\n+fn main() { \"__RA_UNIMPLEMENTED__\"; }\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_option_env_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! option_env {() => {}}\n+\n+fn main() { option_env!(\"TEST_ENV_VAR\"); }\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! option_env {() => {}}\n+\n+fn main() { std::option::Option::None:: < &str>; }\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_file_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! file {() => {}}\n+\n+fn main() { file!(); }\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! file {() => {}}\n+\n+fn main() { \"\"; }\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_assert_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! assert {\n+    ($cond:expr) => ({ /* compiler built-in */ });\n+    ($cond:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    assert!(true, \"{} {:?}\", arg1(a, b, c), arg2);\n+}\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! assert {\n+    ($cond:expr) => ({ /* compiler built-in */ });\n+    ($cond:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+     {\n+        if !true {\n+            $crate::panic!(\"{} {:?}\", arg1(a, b, c), arg2);\n+        }\n+    };\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_compile_error_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! compile_error {\n+    ($msg:expr) => ({ /* compiler built-in */ });\n+    ($msg:expr,) => ({ /* compiler built-in */ })\n+}\n+\n+// This expands to nothing (since it's in item position), but emits an error.\n+compile_error!(\"error!\");\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! compile_error {\n+    ($msg:expr) => ({ /* compiler built-in */ });\n+    ($msg:expr,) => ({ /* compiler built-in */ })\n+}\n+\n+/* error: error! */\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_format_args_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    format_args!(\"{} {:?}\", arg1(a, b, c), arg2);\n+}\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    unsafe {\n+        std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(arg1(a, b, c)), std::fmt::Display::fmt), std::fmt::ArgumentV1::new(&(arg2), std::fmt::Display::fmt), ])\n+    };\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_format_args_expand_with_comma_exprs() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    format_args!(\"{} {:?}\", a::<A,B>(), b);\n+}\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    unsafe {\n+        std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(a::<A, B>()), std::fmt::Display::fmt), std::fmt::ArgumentV1::new(&(b), std::fmt::Display::fmt), ])\n+    };\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_format_args_expand_with_broken_member_access() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    let _ =\n+        // +errors\n+        format_args!(\"{} {:?}\", a.);\n+}\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    let _ =\n+        /* parse error: expected field name or number */\n+unsafe {\n+            std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(a.), std::fmt::Display::fmt), ])\n+        };\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_include_bytes_expand() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! include_bytes {\n+    ($file:expr) => {{ /* compiler built-in */ }};\n+    ($file:expr,) => {{ /* compiler built-in */ }};\n+}\n+\n+fn main() { include_bytes(\"foo\"); }\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! include_bytes {\n+    ($file:expr) => {{ /* compiler built-in */ }};\n+    ($file:expr,) => {{ /* compiler built-in */ }};\n+}\n+\n+fn main() { include_bytes(\"foo\"); }\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_concat_expand() {\n+    check(\n+        r##\"\n+#[rustc_builtin_macro]\n+macro_rules! concat {}\n+\n+fn main() { concat!(\"foo\", \"r\", 0, r#\"bar\"#, \"\\n\", false); }\n+\"##,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! concat {}\n+\n+fn main() { \"foor0bar\\nfalse\"; }\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_concat_idents_expand() {\n+    check(\n+        r##\"\n+#[rustc_builtin_macro]\n+macro_rules! concat_idents {}\n+\n+fn main() { concat_idents!(foo, bar); }\n+\"##,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! concat_idents {}\n+\n+fn main() { foobar; }\n+\"##]],\n+    );\n+}"}, {"sha": "1da0110fe261afe4e94573914194fb3f372e33b5", "filename": "crates/hir_def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 333, "deletions": 6, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=7548cb42735807ff423a4af7414542558e2d83dd", "patch": "@@ -4,6 +4,7 @@\n mod tt_conversion;\n mod matching;\n mod meta_syntax;\n+mod regression;\n \n use expect_test::expect;\n \n@@ -35,12 +36,12 @@ macro_rules! impl_froms {\n     }\n }\n impl From<Leaf> for TokenTree {\n-    fn from(it:Leaf) -> TokenTree {\n+    fn from(it: Leaf) -> TokenTree {\n         TokenTree::Leaf(it)\n     }\n }\n impl From<Subtree> for TokenTree {\n-    fn from(it:Subtree) -> TokenTree {\n+    fn from(it: Subtree) -> TokenTree {\n         TokenTree::Subtree(it)\n     }\n }\n@@ -433,10 +434,10 @@ macro_rules! structs {\n }\n \n struct Foo {\n-    field:u32\n+    field: u32\n }\n struct Bar {\n-    field:u32\n+    field: u32\n }\n // MACRO_ITEMS@0..40\n //   STRUCT@0..20\n@@ -906,8 +907,8 @@ extern crate a;\n mod b;\n mod c {}\n use d;\n-const E:i32 = 0;\n-static F:i32 = 0;\n+const E: i32 = 0;\n+static F: i32 = 0;\n impl G {}\n struct H;\n enum I {\n@@ -1119,3 +1120,329 @@ ok!();\n \"#]],\n     );\n }\n+\n+#[test]\n+fn test_underscore() {\n+    check(\n+        r#\"\n+macro_rules! m { ($_:tt) => { ok!(); } }\n+m! { => }\n+\"#,\n+        expect![[r#\"\n+macro_rules! m { ($_:tt) => { ok!(); } }\n+ok!();\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_underscore_not_greedily() {\n+    check(\n+        r#\"\n+// `_` overlaps with `$a:ident` but rustc matches it under the `_` token.\n+macro_rules! m1 {\n+    ($($a:ident)* _) => { ok!(); }\n+}\n+m1![a b c d _];\n+\n+// `_ => ou` overlaps with `$a:expr => $b:ident` but rustc matches it under `_ => $c:expr`.\n+macro_rules! m2 {\n+    ($($a:expr => $b:ident)* _ => $c:expr) => { ok!(); }\n+}\n+m2![a => b c => d _ => ou]\n+\"#,\n+        expect![[r#\"\n+// `_` overlaps with `$a:ident` but rustc matches it under the `_` token.\n+macro_rules! m1 {\n+    ($($a:ident)* _) => { ok!(); }\n+}\n+ok!();\n+\n+// `_ => ou` overlaps with `$a:expr => $b:ident` but rustc matches it under `_ => $c:expr`.\n+macro_rules! m2 {\n+    ($($a:expr => $b:ident)* _ => $c:expr) => { ok!(); }\n+}\n+ok!();\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_underscore_flavors() {\n+    check(\n+        r#\"\n+macro_rules! m1 { ($a:ty) => { ok!(); } }\n+m1![_];\n+\n+macro_rules! m2 { ($a:lifetime) => { ok!(); } }\n+m2!['_];\n+\"#,\n+        expect![[r#\"\n+macro_rules! m1 { ($a:ty) => { ok!(); } }\n+ok!();\n+\n+macro_rules! m2 { ($a:lifetime) => { ok!(); } }\n+ok!();\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_vertical_bar_with_pat() {\n+    check(\n+        r#\"\n+macro_rules! m { (|$pat:pat| ) => { ok!(); } }\n+m! { |x| }\n+ \"#,\n+        expect![[r#\"\n+macro_rules! m { (|$pat:pat| ) => { ok!(); } }\n+ok!();\n+ \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_dollar_crate_lhs_is_not_meta() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($crate) => { err!(); };\n+    () => { ok!(); };\n+}\n+m!{}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($crate) => { err!(); };\n+    () => { ok!(); };\n+}\n+ok!();\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_lifetime() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($lt:lifetime) => { struct Ref<$lt>{ s: &$ lt str } }\n+}\n+m! {'a}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($lt:lifetime) => { struct Ref<$lt>{ s: &$ lt str } }\n+}\n+struct Ref<'a> {\n+    s: &'a str\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_literal() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($type:ty, $lit:literal) => { const VALUE: $type = $ lit; };\n+}\n+m!(u8, 0);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($type:ty, $lit:literal) => { const VALUE: $type = $ lit; };\n+}\n+const VALUE: u8 = 0;\n+\"#]],\n+    );\n+\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($type:ty, $lit:literal) => { const VALUE: $ type = $ lit; };\n+}\n+m!(i32, -1);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($type:ty, $lit:literal) => { const VALUE: $ type = $ lit; };\n+}\n+const VALUE: i32 = -1;\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_boolean_is_ident() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($lit0:literal, $lit1:literal) => { const VALUE: (bool, bool) = ($lit0, $lit1); };\n+}\n+m!(true, false);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($lit0:literal, $lit1:literal) => { const VALUE: (bool, bool) = ($lit0, $lit1); };\n+}\n+const VALUE: (bool, bool) = (true , false );\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_vis() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($vis:vis $name:ident) => { $vis fn $name() {} }\n+}\n+m!(pub foo);\n+m!(foo);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($vis:vis $name:ident) => { $vis fn $name() {} }\n+}\n+pub fn foo() {}\n+fn foo() {}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_inner_macro_rules() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($a:ident, $b:ident, $c:tt) => {\n+        macro_rules! inner {\n+            ($bi:ident) => { fn $bi() -> u8 { $c } }\n+        }\n+\n+        inner!($a);\n+        fn $b() -> u8 { $c }\n+    }\n+}\n+m!(x, y, 1);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($a:ident, $b:ident, $c:tt) => {\n+        macro_rules! inner {\n+            ($bi:ident) => { fn $bi() -> u8 { $c } }\n+        }\n+\n+        inner!($a);\n+        fn $b() -> u8 { $c }\n+    }\n+}\n+macro_rules !inner {\n+    ($bi: ident) = > {\n+        fn $bi()-> u8 {\n+            1\n+        }\n+    }\n+}\n+inner!(x);\n+fn y() -> u8 {\n+    1\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_expr_after_path_colons() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($k:expr) => { fn f() { K::$k; } }\n+}\n+// +tree +errors\n+m!(C(\"0\"));\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($k:expr) => { fn f() { K::$k; } }\n+}\n+/* parse error: expected identifier */\n+/* parse error: expected SEMICOLON */\n+fn f() {\n+    K::C(\"0\");\n+}\n+// MACRO_ITEMS@0..17\n+//   FN@0..17\n+//     FN_KW@0..2 \"fn\"\n+//     NAME@2..3\n+//       IDENT@2..3 \"f\"\n+//     PARAM_LIST@3..5\n+//       L_PAREN@3..4 \"(\"\n+//       R_PAREN@4..5 \")\"\n+//     BLOCK_EXPR@5..17\n+//       STMT_LIST@5..17\n+//         L_CURLY@5..6 \"{\"\n+//         EXPR_STMT@6..9\n+//           PATH_EXPR@6..9\n+//             PATH@6..9\n+//               PATH@6..7\n+//                 PATH_SEGMENT@6..7\n+//                   NAME_REF@6..7\n+//                     IDENT@6..7 \"K\"\n+//               COLON2@7..9 \"::\"\n+//         EXPR_STMT@9..16\n+//           CALL_EXPR@9..15\n+//             PATH_EXPR@9..10\n+//               PATH@9..10\n+//                 PATH_SEGMENT@9..10\n+//                   NAME_REF@9..10\n+//                     IDENT@9..10 \"C\"\n+//             ARG_LIST@10..15\n+//               L_PAREN@10..11 \"(\"\n+//               LITERAL@11..14\n+//                 STRING@11..14 \"\\\"0\\\"\"\n+//               R_PAREN@14..15 \")\"\n+//           SEMICOLON@15..16 \";\"\n+//         R_CURLY@16..17 \"}\"\n+\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_match_is_not_greedy() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($($i:ident $(,)*),*) => {};\n+}\n+foo!(a,b);\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($($i:ident $(,)*),*) => {};\n+}\n+\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expr_interpolation() {\n+    check(\n+        r#\"\n+macro_rules! m { ($expr:expr) => { map($expr) } }\n+fn f() {\n+    let _ = m!(x + foo);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m { ($expr:expr) => { map($expr) } }\n+fn f() {\n+    let _ = map(x+foo);\n+}\n+\"#]],\n+    )\n+}"}, {"sha": "9fb6d96b7254d1cfdae89e603bf641d941a3243b", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/matching.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs?ref=7548cb42735807ff423a4af7414542558e2d83dd", "patch": "@@ -23,3 +23,30 @@ literal!();\n \"#]],\n     )\n }\n+\n+#[test]\n+fn test_expand_bad_literal() {\n+    check(\n+        r#\"\n+macro_rules! m { ($i:literal) => {}; }\n+m!(&k\");\n+\"#,\n+        expect![[r#\"\n+macro_rules! m { ($i:literal) => {}; }\n+/* error: Failed to lower macro args to token tree */\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_empty_comments() {\n+    check(\n+        r#\"\n+macro_rules! m{ ($fmt:expr) => (); }\n+m!(/**/);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m{ ($fmt:expr) => (); }\n+/* error: expected Expr */\n+\"#]],\n+    );\n+}"}, {"sha": "dd5effa3683aaaaa56890684b76a3850bef58c6b", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/meta_syntax.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs?ref=7548cb42735807ff423a4af7414542558e2d83dd", "patch": "@@ -77,3 +77,64 @@ macro_rules! f3 { ($i:_) => () }\n \"#]],\n     )\n }\n+\n+#[test]\n+fn test_rustc_issue_57597() {\n+    // <https://github.com/rust-lang/rust/blob/master/src/test/ui/issues/issue-57597.rs>\n+    check(\n+        r#\"\n+macro_rules! m0 { ($($($i:ident)?)+) => {}; }\n+macro_rules! m1 { ($($($i:ident)?)*) => {}; }\n+macro_rules! m2 { ($($($i:ident)?)?) => {}; }\n+macro_rules! m3 { ($($($($i:ident)?)?)?) => {}; }\n+macro_rules! m4 { ($($($($i:ident)*)?)?) => {}; }\n+macro_rules! m5 { ($($($($i:ident)?)*)?) => {}; }\n+macro_rules! m6 { ($($($($i:ident)?)?)*) => {}; }\n+macro_rules! m7 { ($($($($i:ident)*)*)?) => {}; }\n+macro_rules! m8 { ($($($($i:ident)?)*)*) => {}; }\n+macro_rules! m9 { ($($($($i:ident)?)*)+) => {}; }\n+macro_rules! mA { ($($($($i:ident)+)?)*) => {}; }\n+macro_rules! mB { ($($($($i:ident)+)*)?) => {}; }\n+\n+m0!();\n+m1!();\n+m2!();\n+m3!();\n+m4!();\n+m5!();\n+m6!();\n+m7!();\n+m8!();\n+m9!();\n+mA!();\n+mB!();\n+    \"#,\n+        expect![[r#\"\n+macro_rules! m0 { ($($($i:ident)?)+) => {}; }\n+macro_rules! m1 { ($($($i:ident)?)*) => {}; }\n+macro_rules! m2 { ($($($i:ident)?)?) => {}; }\n+macro_rules! m3 { ($($($($i:ident)?)?)?) => {}; }\n+macro_rules! m4 { ($($($($i:ident)*)?)?) => {}; }\n+macro_rules! m5 { ($($($($i:ident)?)*)?) => {}; }\n+macro_rules! m6 { ($($($($i:ident)?)?)*) => {}; }\n+macro_rules! m7 { ($($($($i:ident)*)*)?) => {}; }\n+macro_rules! m8 { ($($($($i:ident)?)*)*) => {}; }\n+macro_rules! m9 { ($($($($i:ident)?)*)+) => {}; }\n+macro_rules! mA { ($($($($i:ident)+)?)*) => {}; }\n+macro_rules! mB { ($($($($i:ident)+)*)?) => {}; }\n+\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+/* error: invalid macro definition: empty token tree in repetition */\n+    \"#]],\n+    );\n+}"}, {"sha": "563fe5058850547ffcf70eb7ca6aacac368fe2f3", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/regression.rs", "status": "added", "additions": 902, "deletions": 0, "changes": 902, "blob_url": "https://github.com/rust-lang/rust/blob/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=7548cb42735807ff423a4af7414542558e2d83dd", "patch": "@@ -0,0 +1,902 @@\n+//! Real world regressions and issues, not particularly minimized.\n+//!\n+//! While it's OK to just dump large macros here, it's preferable to come up\n+//! with a minimal example for the program and put a specific test to the parent\n+//! directory.\n+\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn test_vec() {\n+    check(\n+        r#\"\n+macro_rules! vec {\n+   ($($item:expr),*) => {{\n+           let mut v = Vec::new();\n+           $( v.push($item); )*\n+           v\n+    }};\n+}\n+fn main() {\n+    vec!();\n+    vec![1u32,2];\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! vec {\n+   ($($item:expr),*) => {{\n+           let mut v = Vec::new();\n+           $( v.push($item); )*\n+           v\n+    }};\n+}\n+fn main() {\n+     {\n+        let mut v = Vec::new();\n+        v\n+    };\n+     {\n+        let mut v = Vec::new();\n+        v.push(1u32);\n+        v.push(2);\n+        v\n+    };\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_winapi_struct() {\n+    // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/macros.rs#L366\n+\n+    check(\n+        r#\"\n+macro_rules! STRUCT {\n+    ($(#[$attrs:meta])* struct $name:ident {\n+        $($field:ident: $ftype:ty,)+\n+    }) => (\n+        #[repr(C)] #[derive(Copy)] $(#[$attrs])*\n+        pub struct $name {\n+            $(pub $field: $ftype,)+\n+        }\n+        impl Clone for $name {\n+            #[inline]\n+            fn clone(&self) -> $name { *self }\n+        }\n+        #[cfg(feature = \"impl-default\")]\n+        impl Default for $name {\n+            #[inline]\n+            fn default() -> $name { unsafe { $crate::_core::mem::zeroed() } }\n+        }\n+    );\n+}\n+\n+// from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/shared/d3d9caps.rs\n+STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\n+\n+STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\n+\"#,\n+        expect![[r##\"\n+macro_rules! STRUCT {\n+    ($(#[$attrs:meta])* struct $name:ident {\n+        $($field:ident: $ftype:ty,)+\n+    }) => (\n+        #[repr(C)] #[derive(Copy)] $(#[$attrs])*\n+        pub struct $name {\n+            $(pub $field: $ftype,)+\n+        }\n+        impl Clone for $name {\n+            #[inline]\n+            fn clone(&self) -> $name { *self }\n+        }\n+        #[cfg(feature = \"impl-default\")]\n+        impl Default for $name {\n+            #[inline]\n+            fn default() -> $name { unsafe { $crate::_core::mem::zeroed() } }\n+        }\n+    );\n+}\n+\n+#[repr(C)]\n+#[derive(Copy)] pub struct D3DVSHADERCAPS2_0 {\n+    pub Caps: u8,\n+}\n+impl Clone for D3DVSHADERCAPS2_0 {\n+    #[inline] fn clone(&self ) -> D3DVSHADERCAPS2_0 {\n+        *self\n+    }\n+}\n+#[cfg(feature = \"impl-default\")] impl Default for D3DVSHADERCAPS2_0 {\n+    #[inline] fn default() -> D3DVSHADERCAPS2_0 {\n+        unsafe {\n+            $crate::_core::mem::zeroed()\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+#[derive(Copy)]\n+#[cfg_attr(target_arch = \"x86\", repr(packed))] pub struct D3DCONTENTPROTECTIONCAPS {\n+    pub Caps: u8,\n+}\n+impl Clone for D3DCONTENTPROTECTIONCAPS {\n+    #[inline] fn clone(&self ) -> D3DCONTENTPROTECTIONCAPS {\n+        *self\n+    }\n+}\n+#[cfg(feature = \"impl-default\")] impl Default for D3DCONTENTPROTECTIONCAPS {\n+    #[inline] fn default() -> D3DCONTENTPROTECTIONCAPS {\n+        unsafe {\n+            $crate::_core::mem::zeroed()\n+        }\n+    }\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_int_base() {\n+    check(\n+        r#\"\n+macro_rules! int_base {\n+    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl fmt::$Trait for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                $Radix.fmt_int(*self as $U, f)\n+            }\n+        }\n+    }\n+}\n+int_base!{Binary for isize as usize -> Binary}\n+\"#,\n+        expect![[r##\"\n+macro_rules! int_base {\n+    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl fmt::$Trait for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                $Radix.fmt_int(*self as $U, f)\n+            }\n+        }\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")] impl fmt::Binary for isize {\n+    fn fmt(&self , f: &mut fmt::Formatter< '_>) -> fmt::Result {\n+        Binary.fmt_int(*self as usize, f)\n+    }\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_generate_pattern_iterators() {\n+    // From <https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs>.\n+    check(\n+        r#\"\n+macro_rules! generate_pattern_iterators {\n+    { double ended; with $(#[$common_stability_attribute:meta])*,\n+                        $forward_iterator:ident,\n+                        $reverse_iterator:ident, $iterty:ty\n+    } => { ok!(); }\n+}\n+generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str );\n+\"#,\n+        expect![[r##\"\n+macro_rules! generate_pattern_iterators {\n+    { double ended; with $(#[$common_stability_attribute:meta])*,\n+                        $forward_iterator:ident,\n+                        $reverse_iterator:ident, $iterty:ty\n+    } => { ok!(); }\n+}\n+ok!();\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_impl_fn_for_zst() {\n+    // From <https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs>.\n+    check(\n+        r#\"\n+macro_rules! impl_fn_for_zst  {\n+    {$( $( #[$attr: meta] )*\n+    struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n+        |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty $body: block;\n+    )+} => {$(\n+        $( #[$attr] )*\n+        struct $Name;\n+\n+        impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n+            #[inline]\n+            extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                $body\n+            }\n+        }\n+\n+        impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n+            #[inline]\n+            extern \"rust-call\" fn call_mut(\n+                &mut self,\n+                ($( $arg, )*): ($( $ArgTy, )*)\n+            ) -> $ReturnTy {\n+                Fn::call(&*self, ($( $arg, )*))\n+            }\n+        }\n+\n+        impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n+            type Output = $ReturnTy;\n+\n+            #[inline]\n+            extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                Fn::call(&self, ($( $arg, )*))\n+            }\n+        }\n+    )+}\n+}\n+\n+impl_fn_for_zst !   {\n+    #[derive(Clone)]\n+    struct CharEscapeDebugContinue impl Fn = |c: char| -> char::EscapeDebug {\n+        c.escape_debug_ext(false)\n+    };\n+\n+    #[derive(Clone)]\n+    struct CharEscapeUnicode impl Fn = |c: char| -> char::EscapeUnicode {\n+        c.escape_unicode()\n+    };\n+\n+    #[derive(Clone)]\n+    struct CharEscapeDefault impl Fn = |c: char| -> char::EscapeDefault {\n+        c.escape_default()\n+    };\n+}\n+\n+\"#,\n+        expect![[r##\"\n+macro_rules! impl_fn_for_zst  {\n+    {$( $( #[$attr: meta] )*\n+    struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n+        |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty $body: block;\n+    )+} => {$(\n+        $( #[$attr] )*\n+        struct $Name;\n+\n+        impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n+            #[inline]\n+            extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                $body\n+            }\n+        }\n+\n+        impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n+            #[inline]\n+            extern \"rust-call\" fn call_mut(\n+                &mut self,\n+                ($( $arg, )*): ($( $ArgTy, )*)\n+            ) -> $ReturnTy {\n+                Fn::call(&*self, ($( $arg, )*))\n+            }\n+        }\n+\n+        impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n+            type Output = $ReturnTy;\n+\n+            #[inline]\n+            extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                Fn::call(&self, ($( $arg, )*))\n+            }\n+        }\n+    )+}\n+}\n+\n+#[derive(Clone)] struct CharEscapeDebugContinue;\n+impl Fn<(char, )> for CharEscapeDebugContinue {\n+    #[inline] extern \"rust-call\"fn call(&self , (c, ): (char, )) -> char::EscapeDebug { {\n+            c.escape_debug_ext(false )\n+        }\n+    }\n+}\n+impl FnMut<(char, )> for CharEscapeDebugContinue {\n+    #[inline] extern \"rust-call\"fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDebug {\n+        Fn::call(&*self , (c, ))\n+    }\n+}\n+impl FnOnce<(char, )> for CharEscapeDebugContinue {\n+    type Output = char::EscapeDebug;\n+    #[inline] extern \"rust-call\"fn call_once(self , (c, ): (char, )) -> char::EscapeDebug {\n+        Fn::call(&self , (c, ))\n+    }\n+}\n+#[derive(Clone)] struct CharEscapeUnicode;\n+impl Fn<(char, )> for CharEscapeUnicode {\n+    #[inline] extern \"rust-call\"fn call(&self , (c, ): (char, )) -> char::EscapeUnicode { {\n+            c.escape_unicode()\n+        }\n+    }\n+}\n+impl FnMut<(char, )> for CharEscapeUnicode {\n+    #[inline] extern \"rust-call\"fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeUnicode {\n+        Fn::call(&*self , (c, ))\n+    }\n+}\n+impl FnOnce<(char, )> for CharEscapeUnicode {\n+    type Output = char::EscapeUnicode;\n+    #[inline] extern \"rust-call\"fn call_once(self , (c, ): (char, )) -> char::EscapeUnicode {\n+        Fn::call(&self , (c, ))\n+    }\n+}\n+#[derive(Clone)] struct CharEscapeDefault;\n+impl Fn<(char, )> for CharEscapeDefault {\n+    #[inline] extern \"rust-call\"fn call(&self , (c, ): (char, )) -> char::EscapeDefault { {\n+            c.escape_default()\n+        }\n+    }\n+}\n+impl FnMut<(char, )> for CharEscapeDefault {\n+    #[inline] extern \"rust-call\"fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDefault {\n+        Fn::call(&*self , (c, ))\n+    }\n+}\n+impl FnOnce<(char, )> for CharEscapeDefault {\n+    type Output = char::EscapeDefault;\n+    #[inline] extern \"rust-call\"fn call_once(self , (c, ): (char, )) -> char::EscapeDefault {\n+        Fn::call(&self , (c, ))\n+    }\n+}\n+\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_impl_nonzero_fmt() {\n+    // From <https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12>.\n+    check(\n+        r#\"\n+macro_rules! impl_nonzero_fmt {\n+    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => { ok!(); }\n+}\n+impl_nonzero_fmt! {\n+    #[stable(feature= \"nonzero\",since=\"1.28.0\")]\n+    (Debug, Display, Binary, Octal, LowerHex, UpperHex) for NonZeroU8\n+}\n+\"#,\n+        expect![[r##\"\n+macro_rules! impl_nonzero_fmt {\n+    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => { ok!(); }\n+}\n+ok!();\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_cfg_if_items() {\n+    // From <https://github.com/rust-lang/rust/blob/33fe1131cadba69d317156847be9a402b89f11bb/src/libstd/macros.rs#L986>.\n+    check(\n+        r#\"\n+macro_rules! __cfg_if_items {\n+    (($($not:meta,)*) ; ) => {};\n+    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+            __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n+    }\n+}\n+__cfg_if_items! {\n+    (rustdoc,);\n+    ( () (\n+           #[ cfg(any(target_os = \"redox\", unix))]\n+           #[ stable(feature = \"rust1\", since = \"1.0.0\")]\n+           pub use sys::ext as unix;\n+\n+           #[cfg(windows)]\n+           #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+           pub use sys::ext as windows;\n+\n+           #[cfg(any(target_os = \"linux\", target_os = \"l4re\"))]\n+           pub mod linux;\n+    )),\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! __cfg_if_items {\n+    (($($not:meta,)*) ; ) => {};\n+    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+            __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n+    }\n+}\n+__cfg_if_items! {\n+    (rustdoc, );\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_cfg_if_main() {\n+    // From <https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src/libpanic_unwind/macros.rs#L9>.\n+    check(\n+        r#\"\n+macro_rules! cfg_if {\n+    ($(if #[cfg($($meta:meta),*)] { $($it:item)* } )else* else { $($it2:item)* })\n+    => {\n+        __cfg_if_items! {\n+            () ;\n+            $( ( ($($meta),*) ($($it)*) ), )*\n+            ( () ($($it2)*) ),\n+        }\n+    };\n+\n+    // Internal macro to Apply a cfg attribute to a list of items\n+    (@__apply $m:meta, $($it:item)*) => { $(#[$m] $it)* };\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_env = \"msvc\")] {\n+        // no extra unwinder support needed\n+    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n+        // no unwinder on the system!\n+    } else {\n+        mod libunwind;\n+        pub use libunwind::*;\n+    }\n+}\n+\n+cfg_if! {\n+    @__apply cfg(all(not(any(not(any(target_os = \"solaris\", target_os = \"illumos\")))))),\n+}\n+\"#,\n+        expect![[r##\"\n+macro_rules! cfg_if {\n+    ($(if #[cfg($($meta:meta),*)] { $($it:item)* } )else* else { $($it2:item)* })\n+    => {\n+        __cfg_if_items! {\n+            () ;\n+            $( ( ($($meta),*) ($($it)*) ), )*\n+            ( () ($($it2)*) ),\n+        }\n+    };\n+\n+    // Internal macro to Apply a cfg attribute to a list of items\n+    (@__apply $m:meta, $($it:item)*) => { $(#[$m] $it)* };\n+}\n+\n+__cfg_if_items! {\n+    ();\n+    ((target_env = \"msvc\")()), ((all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))()), (()(mod libunwind;\n+    pub use libunwind::*;\n+    )),\n+}\n+\n+\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_proptest_arbitrary() {\n+    // From <https://github.com/AltSysrq/proptest/blob/d1c4b049337d2f75dd6f49a095115f7c532e5129/proptest/src/arbitrary/macros.rs#L16>.\n+    check(\n+        r#\"\n+macro_rules! arbitrary {\n+    ([$($bounds : tt)*] $typ: ty, $strat: ty, $params: ty;\n+        $args: ident => $logic: expr) => {\n+        impl<$($bounds)*> $crate::arbitrary::Arbitrary for $typ {\n+            type Parameters = $params;\n+            type Strategy = $strat;\n+            fn arbitrary_with($args: Self::Parameters) -> Self::Strategy {\n+                $logic\n+            }\n+        }\n+    };\n+}\n+\n+arbitrary!(\n+    [A:Arbitrary]\n+    Vec<A> ,\n+    VecStrategy<A::Strategy>,\n+    RangedParams1<A::Parameters>;\n+    args =>   {\n+        let product_unpack![range, a] = args;\n+        vec(any_with::<A>(a), range)\n+    }\n+);\n+\"#,\n+        expect![[r#\"\n+macro_rules! arbitrary {\n+    ([$($bounds : tt)*] $typ: ty, $strat: ty, $params: ty;\n+        $args: ident => $logic: expr) => {\n+        impl<$($bounds)*> $crate::arbitrary::Arbitrary for $typ {\n+            type Parameters = $params;\n+            type Strategy = $strat;\n+            fn arbitrary_with($args: Self::Parameters) -> Self::Strategy {\n+                $logic\n+            }\n+        }\n+    };\n+}\n+\n+impl <A: Arbitrary> $crate::arbitrary::Arbitrary for Vec<A> {\n+    type Parameters = RangedParams1<A::Parameters>;\n+    type Strategy = VecStrategy<A::Strategy>;\n+    fn arbitrary_with(args: Self::Parameters) -> Self::Strategy { {\n+            let product_unpack![range, a] = args;\n+            vec(any_with::<A>(a), range)\n+        }\n+    }\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_old_ridl() {\n+    // This is from winapi 2.8, which do not have a link from github.\n+    check(\n+        r#\"\n+#[macro_export]\n+macro_rules! RIDL {\n+    (interface $interface:ident ($vtbl:ident) : $pinterface:ident ($pvtbl:ident)\n+        {$(\n+            fn $method:ident(&mut self $(,$p:ident : $t:ty)*) -> $rtr:ty\n+        ),+}\n+    ) => {\n+        impl $interface {\n+            $(pub unsafe fn $method(&mut self) -> $rtr {\n+                ((*self.lpVtbl).$method)(self $(,$p)*)\n+            })+\n+        }\n+    };\n+}\n+\n+RIDL!{interface ID3D11Asynchronous(ID3D11AsynchronousVtbl): ID3D11DeviceChild(ID3D11DeviceChildVtbl) {\n+    fn GetDataSize(&mut self) -> UINT\n+}}\n+\"#,\n+        expect![[r##\"\n+#[macro_export]\n+macro_rules! RIDL {\n+    (interface $interface:ident ($vtbl:ident) : $pinterface:ident ($pvtbl:ident)\n+        {$(\n+            fn $method:ident(&mut self $(,$p:ident : $t:ty)*) -> $rtr:ty\n+        ),+}\n+    ) => {\n+        impl $interface {\n+            $(pub unsafe fn $method(&mut self) -> $rtr {\n+                ((*self.lpVtbl).$method)(self $(,$p)*)\n+            })+\n+        }\n+    };\n+}\n+\n+impl ID3D11Asynchronous {\n+    pub unsafe fn GetDataSize(&mut self ) -> UINT {\n+        ((*self .lpVtbl).GetDataSize)(self )\n+    }\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_quick_error() {\n+    check(\n+        r#\"\n+macro_rules! quick_error {\n+    (SORT [enum $name:ident $( #[$meta:meta] )*]\n+        items [$($( #[$imeta:meta] )*\n+                  => $iitem:ident: $imode:tt [$( $ivar:ident: $ityp:ty ),*]\n+                                {$( $ifuncs:tt )*} )* ]\n+        buf [ ]\n+        queue [ ]\n+    ) => {\n+        quick_error!(ENUMINITION [enum $name $( #[$meta] )*]\n+            body []\n+            queue [$(\n+                $( #[$imeta] )*\n+                =>\n+                $iitem: $imode [$( $ivar: $ityp ),*]\n+            )*]\n+        );\n+    };\n+}\n+quick_error ! (\n+    SORT\n+    [enum Wrapped #[derive(Debug)]]\n+    items [\n+        => One: UNIT [] {}\n+        => Two: TUPLE [s :String] {display (\"two: {}\" , s) from ()} ]\n+    buf [ ]\n+    queue [ ]\n+);\n+\n+\"#,\n+        expect![[r##\"\n+macro_rules! quick_error {\n+    (SORT [enum $name:ident $( #[$meta:meta] )*]\n+        items [$($( #[$imeta:meta] )*\n+                  => $iitem:ident: $imode:tt [$( $ivar:ident: $ityp:ty ),*]\n+                                {$( $ifuncs:tt )*} )* ]\n+        buf [ ]\n+        queue [ ]\n+    ) => {\n+        quick_error!(ENUMINITION [enum $name $( #[$meta] )*]\n+            body []\n+            queue [$(\n+                $( #[$imeta] )*\n+                =>\n+                $iitem: $imode [$( $ivar: $ityp ),*]\n+            )*]\n+        );\n+    };\n+}\n+quick_error!(ENUMINITION[enum Wrapped#[derive(Debug)]]body[]queue[ = > One: UNIT[] = > Two: TUPLE[s: String]]);\n+\n+\"##]],\n+    )\n+}\n+\n+#[test]\n+fn test_empty_repeat_vars_in_empty_repeat_vars() {\n+    check(\n+        r#\"\n+macro_rules! delegate_impl {\n+    ([$self_type:ident, $self_wrap:ty, $self_map:ident]\n+     pub trait $name:ident $(: $sup:ident)* $(+ $more_sup:ident)* {\n+\n+        $(\n+        @escape [type $assoc_name_ext:ident]\n+        )*\n+        $(\n+        @section type\n+        $(\n+            $(#[$_assoc_attr:meta])*\n+            type $assoc_name:ident $(: $assoc_bound:ty)*;\n+        )+\n+        )*\n+        $(\n+        @section self\n+        $(\n+            $(#[$_method_attr:meta])*\n+            fn $method_name:ident(self $(: $self_selftype:ty)* $(,$marg:ident : $marg_ty:ty)*) -> $mret:ty;\n+        )+\n+        )*\n+        $(\n+        @section nodelegate\n+        $($tail:tt)*\n+        )*\n+    }) => {\n+        impl<> $name for $self_wrap where $self_type: $name {\n+            $(\n+            $(\n+                fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) -> $mret {\n+                    $self_map!(self).$method_name($($marg),*)\n+                }\n+            )*\n+            )*\n+        }\n+    }\n+}\n+delegate_impl ! {\n+    [G, &'a mut G, deref] pub trait Data: GraphBase {@section type type NodeWeight;}\n+}\n+\"#,\n+        expect![[r##\"\n+macro_rules! delegate_impl {\n+    ([$self_type:ident, $self_wrap:ty, $self_map:ident]\n+     pub trait $name:ident $(: $sup:ident)* $(+ $more_sup:ident)* {\n+\n+        $(\n+        @escape [type $assoc_name_ext:ident]\n+        )*\n+        $(\n+        @section type\n+        $(\n+            $(#[$_assoc_attr:meta])*\n+            type $assoc_name:ident $(: $assoc_bound:ty)*;\n+        )+\n+        )*\n+        $(\n+        @section self\n+        $(\n+            $(#[$_method_attr:meta])*\n+            fn $method_name:ident(self $(: $self_selftype:ty)* $(,$marg:ident : $marg_ty:ty)*) -> $mret:ty;\n+        )+\n+        )*\n+        $(\n+        @section nodelegate\n+        $($tail:tt)*\n+        )*\n+    }) => {\n+        impl<> $name for $self_wrap where $self_type: $name {\n+            $(\n+            $(\n+                fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) -> $mret {\n+                    $self_map!(self).$method_name($($marg),*)\n+                }\n+            )*\n+            )*\n+        }\n+    }\n+}\n+impl <> Data for & 'amut G where G: Data {}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_issue_2520() {\n+    check(\n+        r#\"\n+macro_rules! my_macro {\n+    {\n+        ( $(\n+            $( [] $sname:ident : $stype:ty  )?\n+            $( [$expr:expr] $nname:ident : $ntype:ty  )?\n+        ),* )\n+    } => {ok!(\n+        Test {\n+            $(\n+                $( $sname, )?\n+            )*\n+        }\n+    );};\n+}\n+\n+my_macro! {\n+    ([] p1: u32, [|_| S0K0] s: S0K0, [] k0: i32)\n+}\n+    \"#,\n+        expect![[r#\"\n+macro_rules! my_macro {\n+    {\n+        ( $(\n+            $( [] $sname:ident : $stype:ty  )?\n+            $( [$expr:expr] $nname:ident : $ntype:ty  )?\n+        ),* )\n+    } => {ok!(\n+        Test {\n+            $(\n+                $( $sname, )?\n+            )*\n+        }\n+    );};\n+}\n+\n+ok!(Test {\n+    p1, k0,\n+}\n+);\n+    \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_repeat_bad_var() {\n+    // FIXME: the second rule of the macro should be removed and an error about\n+    // `$( $c )+` raised\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($( $b:ident )+) => { ok!($( $c )+); };\n+    ($( $b:ident )+) => { ok!($( $b )+); }\n+}\n+\n+foo!(b0 b1);\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($( $b:ident )+) => { ok!($( $c )+); };\n+    ($( $b:ident )+) => { ok!($( $b )+); }\n+}\n+\n+ok!(b0 b1);\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_issue_3861() {\n+    // This is should (and does) produce a parse error. It used to infinite loop\n+    // instead.\n+    check(\n+        r#\"\n+macro_rules! rgb_color {\n+    ($p:expr, $t:ty) => {\n+        pub fn new() {\n+            let _ = 0 as $t << $p;\n+        }\n+    };\n+}\n+// +tree +errors\n+rgb_color!(8 + 8, u32);\n+\"#,\n+        expect![[r#\"\n+macro_rules! rgb_color {\n+    ($p:expr, $t:ty) => {\n+        pub fn new() {\n+            let _ = 0 as $t << $p;\n+        }\n+    };\n+}\n+/* parse error: expected type */\n+/* parse error: expected R_ANGLE */\n+/* parse error: expected COMMA */\n+/* parse error: expected R_ANGLE */\n+/* parse error: expected SEMICOLON */\n+pub fn new() {\n+    let _ = 0as u32<<8+8;\n+}\n+// MACRO_ITEMS@0..29\n+//   FN@0..29\n+//     VISIBILITY@0..3\n+//       PUB_KW@0..3 \"pub\"\n+//     FN_KW@3..5 \"fn\"\n+//     NAME@5..8\n+//       IDENT@5..8 \"new\"\n+//     PARAM_LIST@8..10\n+//       L_PAREN@8..9 \"(\"\n+//       R_PAREN@9..10 \")\"\n+//     BLOCK_EXPR@10..29\n+//       STMT_LIST@10..29\n+//         L_CURLY@10..11 \"{\"\n+//         LET_STMT@11..24\n+//           LET_KW@11..14 \"let\"\n+//           WILDCARD_PAT@14..15\n+//             UNDERSCORE@14..15 \"_\"\n+//           EQ@15..16 \"=\"\n+//           CAST_EXPR@16..24\n+//             LITERAL@16..17\n+//               INT_NUMBER@16..17 \"0\"\n+//             AS_KW@17..19 \"as\"\n+//             PATH_TYPE@19..24\n+//               PATH@19..24\n+//                 PATH_SEGMENT@19..24\n+//                   NAME_REF@19..22\n+//                     IDENT@19..22 \"u32\"\n+//                   GENERIC_ARG_LIST@22..24\n+//                     L_ANGLE@22..23 \"<\"\n+//                     TYPE_ARG@23..24\n+//                       PATH_TYPE@23..24\n+//                         PATH@23..24\n+//                           PATH_SEGMENT@23..24\n+//                             L_ANGLE@23..24 \"<\"\n+//         EXPR_STMT@24..28\n+//           BIN_EXPR@24..27\n+//             LITERAL@24..25\n+//               INT_NUMBER@24..25 \"8\"\n+//             PLUS@25..26 \"+\"\n+//             LITERAL@26..27\n+//               INT_NUMBER@26..27 \"8\"\n+//           SEMICOLON@27..28 \";\"\n+//         R_CURLY@28..29 \"}\"\n+\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_no_space_after_semi_colon() {\n+    check(\n+        r#\"\n+macro_rules! with_std {\n+    ($($i:item)*) => ($(#[cfg(feature = \"std\")]$i)*)\n+}\n+\n+with_std! {mod m;mod f;}\n+\"#,\n+        expect![[r##\"\n+macro_rules! with_std {\n+    ($($i:item)*) => ($(#[cfg(feature = \"std\")]$i)*)\n+}\n+\n+#[cfg(feature = \"std\")] mod m;\n+#[cfg(feature = \"std\")] mod f;\n+\"##]],\n+    )\n+}"}, {"sha": "4b801eb2a154ce5e55e2a8ddc2f0a8150a327175", "filename": "crates/hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 0, "deletions": 301, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=7548cb42735807ff423a4af7414542558e2d83dd", "patch": "@@ -565,304 +565,3 @@ fn option_env_expand(\n \n     ExpandResult::ok(Some(ExpandedEager::new(expanded)))\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::sync::Arc;\n-\n-    use base_db::{fixture::WithFixture, SourceDatabase};\n-    use expect_test::{expect, Expect};\n-    use syntax::ast::HasName;\n-\n-    use crate::{\n-        name::AsName, test_db::TestDB, AstNode, EagerCallInfo, ExpandTo, MacroCallId,\n-        MacroCallKind, MacroCallLoc,\n-    };\n-\n-    use super::*;\n-\n-    fn expand_builtin_macro(ra_fixture: &str) -> String {\n-        let (db, file_id) = TestDB::with_single_file(ra_fixture);\n-        let parsed = db.parse(file_id);\n-        let mut macro_rules: Vec<_> =\n-            parsed.syntax_node().descendants().filter_map(ast::MacroRules::cast).collect();\n-        let mut macro_calls: Vec<_> =\n-            parsed.syntax_node().descendants().filter_map(ast::MacroCall::cast).collect();\n-\n-        let ast_id_map = db.ast_id_map(file_id.into());\n-\n-        assert_eq!(macro_rules.len(), 1, \"test must contain exactly 1 `macro_rules!`\");\n-        assert_eq!(macro_calls.len(), 1, \"test must contain exactly 1 macro call\");\n-        let macro_rules = ast::Macro::from(macro_rules.pop().unwrap());\n-        let macro_call = macro_calls.pop().unwrap();\n-\n-        let expander = find_by_name(&macro_rules.name().unwrap().as_name()).unwrap();\n-        let ast_id = AstId::new(file_id.into(), ast_id_map.ast_id(&macro_rules));\n-\n-        let krate = CrateId(0);\n-        let file_id = match expander {\n-            Either::Left(expander) => {\n-                // the first one should be a macro_rules\n-                let def = MacroDefId {\n-                    krate: CrateId(0),\n-                    kind: MacroDefKind::BuiltIn(expander, ast_id),\n-                    local_inner: false,\n-                };\n-\n-                let loc = MacroCallLoc {\n-                    def,\n-                    krate,\n-                    eager: None,\n-                    kind: MacroCallKind::FnLike {\n-                        ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_call)),\n-                        expand_to: ExpandTo::Expr,\n-                    },\n-                };\n-\n-                let id: MacroCallId = db.intern_macro(loc);\n-                id.as_file()\n-            }\n-            Either::Right(expander) => {\n-                // the first one should be a macro_rules\n-                let def = MacroDefId {\n-                    krate,\n-                    kind: MacroDefKind::BuiltInEager(expander, ast_id),\n-                    local_inner: false,\n-                };\n-\n-                let args = macro_call.token_tree().unwrap();\n-                let parsed_args = mbe::syntax_node_to_token_tree(args.syntax()).0;\n-                let call_id = AstId::new(file_id.into(), ast_id_map.ast_id(&macro_call));\n-\n-                let arg_id = db.intern_macro(MacroCallLoc {\n-                    def,\n-                    krate,\n-                    eager: Some(EagerCallInfo {\n-                        arg_or_expansion: Arc::new(parsed_args.clone()),\n-                        included_file: None,\n-                    }),\n-                    kind: MacroCallKind::FnLike { ast_id: call_id, expand_to: ExpandTo::Expr },\n-                });\n-\n-                let expanded = expander.expand(&db, arg_id, &parsed_args).value.unwrap();\n-                let expand_to = crate::ExpandTo::from_call_site(&macro_call);\n-                let loc = MacroCallLoc {\n-                    def,\n-                    krate,\n-                    eager: Some(EagerCallInfo {\n-                        arg_or_expansion: Arc::new(expanded.subtree),\n-                        included_file: expanded.included_file,\n-                    }),\n-                    kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n-                };\n-\n-                let id: MacroCallId = db.intern_macro(loc);\n-                id.as_file()\n-            }\n-        };\n-\n-        db.parse_or_expand(file_id).unwrap().to_string()\n-    }\n-\n-    fn check_expansion(ra_fixture: &str, expect: Expect) {\n-        let expansion = expand_builtin_macro(ra_fixture);\n-        expect.assert_eq(&expansion);\n-    }\n-\n-    #[test]\n-    fn test_column_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! column {() => {}}\n-            column!()\n-            \"#,\n-            expect![[\"0\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_line_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! line {() => {}}\n-            line!()\n-            \"#,\n-            expect![[\"0\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_stringify_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! stringify {() => {}}\n-            stringify!(\n-                a\n-                b\n-                c\n-            )\n-            \"#,\n-            expect![[\"\\\"a b c\\\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_env_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! env {() => {}}\n-            env!(\"TEST_ENV_VAR\")\n-            \"#,\n-            expect![[\"\\\"__RA_UNIMPLEMENTED__\\\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_option_env_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! option_env {() => {}}\n-            option_env!(\"TEST_ENV_VAR\")\n-            \"#,\n-            expect![[\"std::option::Option::None:: < &str>\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_file_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! file {() => {}}\n-            file!()\n-            \"#,\n-            expect![[r#\"\"\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_assert_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! assert {\n-                ($cond:expr) => ({ /* compiler built-in */ });\n-                ($cond:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n-            }\n-            assert!(true, \"{} {:?}\", arg1(a, b, c), arg2);\n-            \"#,\n-            expect![[r#\"{if!true{$crate::panic!(\"{} {:?}\",arg1(a,b,c),arg2);}}\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_compile_error_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! compile_error {\n-                ($msg:expr) => ({ /* compiler built-in */ });\n-                ($msg:expr,) => ({ /* compiler built-in */ })\n-            }\n-            compile_error!(\"error!\");\n-            \"#,\n-            // This expands to nothing (since it's in item position), but emits an error.\n-            expect![[\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_format_args_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! format_args {\n-                ($fmt:expr) => ({ /* compiler built-in */ });\n-                ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n-            }\n-            format_args!(\"{} {:?}\", arg1(a, b, c), arg2);\n-            \"#,\n-            expect![[\n-                r#\"unsafe{std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(arg1(a,b,c)),std::fmt::Display::fmt),std::fmt::ArgumentV1::new(&(arg2),std::fmt::Display::fmt),])}\"#\n-            ]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_format_args_expand_with_comma_exprs() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! format_args {\n-                ($fmt:expr) => ({ /* compiler built-in */ });\n-                ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n-            }\n-            format_args!(\"{} {:?}\", a::<A,B>(), b);\n-            \"#,\n-            expect![[\n-                r#\"unsafe{std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(a::<A,B>()),std::fmt::Display::fmt),std::fmt::ArgumentV1::new(&(b),std::fmt::Display::fmt),])}\"#\n-            ]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_format_args_expand_with_broken_member_access() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! format_args {\n-                ($fmt:expr) => ({ /* compiler built-in */ });\n-                ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n-            }\n-            format_args!(\"{} {:?}\", a.);\n-            \"#,\n-            expect![[\n-                r#\"unsafe{std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(a.),std::fmt::Display::fmt),])}\"#\n-            ]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_include_bytes_expand() {\n-        check_expansion(\n-            r#\"\n-            #[rustc_builtin_macro]\n-            macro_rules! include_bytes {\n-                ($file:expr) => {{ /* compiler built-in */ }};\n-                ($file:expr,) => {{ /* compiler built-in */ }};\n-            }\n-            include_bytes(\"foo\");\n-            \"#,\n-            expect![[r#\"b\"\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_concat_expand() {\n-        check_expansion(\n-            r##\"\n-            #[rustc_builtin_macro]\n-            macro_rules! concat {}\n-            concat!(\"foo\", \"r\", 0, r#\"bar\"#, \"\\n\", false);\n-            \"##,\n-            expect![[r#\"\"foor0bar\\nfalse\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_concat_idents_expand() {\n-        check_expansion(\n-            r##\"\n-            #[rustc_builtin_macro]\n-            macro_rules! concat_idents {}\n-            concat_idents!(foo, bar);\n-            \"##,\n-            expect![[r#\"foobar\"#]],\n-        );\n-    }\n-}"}, {"sha": "f4d7e60595939d319e574986c31dd13beca88417", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 2, "deletions": 212, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=7548cb42735807ff423a4af7414542558e2d83dd", "patch": "@@ -1,219 +1,9 @@\n-mod expand;\n+use std::iter;\n \n-use std::{fmt::Write, iter};\n-\n-use syntax::{ast, AstNode, NodeOrToken, SyntaxNode, WalkEvent};\n-use test_utils::assert_eq_text;\n-\n-use crate::ParserEntryPoint;\n+use syntax::{ast, AstNode};\n \n use super::*;\n \n-pub(crate) struct MacroFixture {\n-    rules: MacroRules,\n-}\n-\n-pub(crate) struct MacroFixture2 {\n-    rules: MacroDef,\n-}\n-\n-macro_rules! impl_fixture {\n-    ($name:ident) => {\n-        impl $name {\n-            pub(crate) fn expand_tt(&self, invocation: &str) -> tt::Subtree {\n-                self.try_expand_tt(invocation).unwrap()\n-            }\n-\n-            fn try_expand_tt(&self, invocation: &str) -> Result<tt::Subtree, ExpandError> {\n-                let source_file = ast::SourceFile::parse(invocation).tree();\n-                let macro_invocation =\n-                    source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-                let (invocation_tt, _) =\n-                    syntax_node_to_token_tree(macro_invocation.token_tree().unwrap().syntax());\n-\n-                self.rules.expand(&invocation_tt).result()\n-            }\n-\n-            #[allow(unused)]\n-            fn assert_expand_err(&self, invocation: &str, err: &ExpandError) {\n-                assert_eq!(self.try_expand_tt(invocation).as_ref(), Err(err));\n-            }\n-\n-            #[allow(unused)]\n-            fn expand_items(&self, invocation: &str) -> SyntaxNode {\n-                let expanded = self.expand_tt(invocation);\n-                token_tree_to_syntax_node(&expanded, ParserEntryPoint::Items)\n-                    .unwrap()\n-                    .0\n-                    .syntax_node()\n-            }\n-\n-            #[allow(unused)]\n-            fn expand_statements(&self, invocation: &str) -> SyntaxNode {\n-                let expanded = self.expand_tt(invocation);\n-                token_tree_to_syntax_node(&expanded, ParserEntryPoint::Statements)\n-                    .unwrap()\n-                    .0\n-                    .syntax_node()\n-            }\n-\n-            #[allow(unused)]\n-            fn expand_expr(&self, invocation: &str) -> SyntaxNode {\n-                let expanded = self.expand_tt(invocation);\n-                token_tree_to_syntax_node(&expanded, ParserEntryPoint::Expr)\n-                    .unwrap()\n-                    .0\n-                    .syntax_node()\n-            }\n-\n-            #[allow(unused)]\n-            fn assert_expand_tt(&self, invocation: &str, expected: &str) {\n-                let expansion = self.expand_tt(invocation);\n-                assert_eq!(expansion.to_string(), expected);\n-            }\n-\n-            #[allow(unused)]\n-            fn assert_expand(&self, invocation: &str, expected: &str) {\n-                let expansion = self.expand_tt(invocation);\n-                let actual = format!(\"{:?}\", expansion);\n-                test_utils::assert_eq_text!(&expected.trim(), &actual.trim());\n-            }\n-\n-            #[allow(unused)]\n-            fn assert_expand_items(&self, invocation: &str, expected: &str) -> &$name {\n-                self.assert_expansion(ParserEntryPoint::Items, invocation, expected);\n-                self\n-            }\n-\n-            #[allow(unused)]\n-            fn assert_expand_statements(&self, invocation: &str, expected: &str) -> &$name {\n-                self.assert_expansion(ParserEntryPoint::Statements, invocation, expected);\n-                self\n-            }\n-\n-            fn assert_expansion(&self, kind: ParserEntryPoint, invocation: &str, expected: &str) {\n-                let expanded = self.expand_tt(invocation);\n-                assert_eq!(expanded.to_string(), expected);\n-\n-                let expected = expected.replace(\"$crate\", \"C_C__C\");\n-\n-                // wrap the given text to a macro call\n-                let expected = {\n-                    let wrapped = format!(\"wrap_macro!( {} )\", expected);\n-                    let wrapped = ast::SourceFile::parse(&wrapped);\n-                    let wrapped = wrapped\n-                        .tree()\n-                        .syntax()\n-                        .descendants()\n-                        .find_map(ast::TokenTree::cast)\n-                        .unwrap();\n-                    let mut wrapped = syntax_node_to_token_tree(wrapped.syntax()).0;\n-                    wrapped.delimiter = None;\n-                    wrapped\n-                };\n-\n-                let expanded_tree =\n-                    token_tree_to_syntax_node(&expanded, kind).unwrap().0.syntax_node();\n-                let expanded_tree = debug_dump_ignore_spaces(&expanded_tree).trim().to_string();\n-\n-                let expected_tree =\n-                    token_tree_to_syntax_node(&expected, kind).unwrap().0.syntax_node();\n-                let expected_tree = debug_dump_ignore_spaces(&expected_tree).trim().to_string();\n-\n-                let expected_tree = expected_tree.replace(\"C_C__C\", \"$crate\");\n-                assert_eq!(\n-                    expanded_tree, expected_tree,\n-                    \"\\nleft:\\n{}\\nright:\\n{}\",\n-                    expanded_tree, expected_tree,\n-                );\n-            }\n-        }\n-    };\n-}\n-\n-impl_fixture!(MacroFixture);\n-impl_fixture!(MacroFixture2);\n-\n-pub(crate) fn parse_macro(ra_fixture: &str) -> MacroFixture {\n-    let definition_tt = parse_macro_rules_to_tt(ra_fixture);\n-    let rules = MacroRules::parse(&definition_tt).unwrap();\n-    MacroFixture { rules }\n-}\n-\n-pub(crate) fn parse_macro_error(ra_fixture: &str) -> ParseError {\n-    let definition_tt = parse_macro_rules_to_tt(ra_fixture);\n-\n-    match MacroRules::parse(&definition_tt) {\n-        Ok(_) => panic!(\"Expect error\"),\n-        Err(err) => err,\n-    }\n-}\n-\n-pub(crate) fn parse_to_token_tree_by_syntax(ra_fixture: &str) -> tt::Subtree {\n-    let source_file = ast::SourceFile::parse(ra_fixture).ok().unwrap();\n-    let tt = syntax_node_to_token_tree(source_file.syntax()).0;\n-\n-    let parsed = parse_to_token_tree(ra_fixture).unwrap().0;\n-    assert_eq!(tt, parsed);\n-\n-    parsed\n-}\n-\n-fn parse_macro_rules_to_tt(ra_fixture: &str) -> tt::Subtree {\n-    let source_file = ast::SourceFile::parse(ra_fixture).ok().unwrap();\n-    let macro_definition =\n-        source_file.syntax().descendants().find_map(ast::MacroRules::cast).unwrap();\n-\n-    let (definition_tt, _) =\n-        syntax_node_to_token_tree(macro_definition.token_tree().unwrap().syntax());\n-\n-    let parsed = parse_to_token_tree(\n-        &ra_fixture[macro_definition.token_tree().unwrap().syntax().text_range()],\n-    )\n-    .unwrap()\n-    .0;\n-    assert_eq!(definition_tt, parsed);\n-\n-    definition_tt\n-}\n-\n-fn debug_dump_ignore_spaces(node: &syntax::SyntaxNode) -> String {\n-    let mut level = 0;\n-    let mut buf = String::new();\n-    macro_rules! indent {\n-        () => {\n-            for _ in 0..level {\n-                buf.push_str(\"  \");\n-            }\n-        };\n-    }\n-\n-    for event in node.preorder_with_tokens() {\n-        match event {\n-            WalkEvent::Enter(element) => {\n-                match element {\n-                    NodeOrToken::Node(node) => {\n-                        indent!();\n-                        writeln!(buf, \"{:?}\", node.kind()).unwrap();\n-                    }\n-                    NodeOrToken::Token(token) => match token.kind() {\n-                        syntax::SyntaxKind::WHITESPACE => {}\n-                        _ => {\n-                            indent!();\n-                            writeln!(buf, \"{:?}\", token.kind()).unwrap();\n-                        }\n-                    },\n-                }\n-                level += 1;\n-            }\n-            WalkEvent::Leave(_) => level -= 1,\n-        }\n-    }\n-\n-    buf\n-}\n-\n #[test]\n fn test_node_to_tt_censor() {\n     use syntax::ast::{HasAttrs, HasModuleItem};"}, {"sha": "15a718402911abc6d95f62a8966caefbf13e6468", "filename": "crates/mbe/src/tests/expand.rs", "status": "removed", "additions": 0, "deletions": 951, "changes": 951, "blob_url": "https://github.com/rust-lang/rust/blob/93c52f5d2399c8e0a23bf50ff660400019d09751/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c52f5d2399c8e0a23bf50ff660400019d09751/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs?ref=93c52f5d2399c8e0a23bf50ff660400019d09751", "patch": "@@ -1,951 +0,0 @@\n-use ::parser::ParserEntryPoint;\n-use syntax::{\n-    SyntaxKind::{ERROR, IDENT},\n-    T,\n-};\n-use test_utils::assert_eq_text;\n-\n-use super::*;\n-\n-// Good first issue (although a slightly challenging one):\n-//\n-// * Pick a random test from here\n-//   https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n-// * Port the test to rust and add it to this module\n-// * Make it pass :-)\n-\n-#[test]\n-fn test_token_id_shift() {\n-    let expansion = parse_macro(\n-        r#\"\n-macro_rules! foobar {\n-    ($e:ident) => { foo bar $e }\n-}\n-\"#,\n-    )\n-    .expand_tt(\"foobar!(baz);\");\n-\n-    fn get_id(t: &tt::TokenTree) -> Option<u32> {\n-        if let tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) = t {\n-            return Some(ident.id.0);\n-        }\n-        None\n-    }\n-\n-    assert_eq!(expansion.token_trees.len(), 3);\n-    // {($e:ident) => { foo bar $e }}\n-    // 012345      67 8 9   T   12\n-    assert_eq!(get_id(&expansion.token_trees[0]), Some(9));\n-    assert_eq!(get_id(&expansion.token_trees[1]), Some(10));\n-\n-    // The input args of macro call include parentheses:\n-    // (baz)\n-    // So baz should be 12+1+1\n-    assert_eq!(get_id(&expansion.token_trees[2]), Some(14));\n-}\n-\n-#[test]\n-fn test_token_map() {\n-    let expanded = parse_macro(\n-        r#\"\n-macro_rules! foobar {\n-    ($e:ident) => { fn $e() {} }\n-}\n-\"#,\n-    )\n-    .expand_tt(\"foobar!(baz);\");\n-\n-    let (node, token_map) = token_tree_to_syntax_node(&expanded, ParserEntryPoint::Items).unwrap();\n-    let content = node.syntax_node().to_string();\n-\n-    let get_text = |id, kind| -> String {\n-        content[token_map.first_range_by_token(id, kind).unwrap()].to_string()\n-    };\n-\n-    assert_eq!(expanded.token_trees.len(), 4);\n-    // {($e:ident) => { fn $e() {} }}\n-    // 012345      67 8 9  T12  3\n-\n-    assert_eq!(get_text(tt::TokenId(9), IDENT), \"fn\");\n-    assert_eq!(get_text(tt::TokenId(12), T!['(']), \"(\");\n-    assert_eq!(get_text(tt::TokenId(13), T!['{']), \"{\");\n-}\n-\n-fn to_subtree(tt: &tt::TokenTree) -> &tt::Subtree {\n-    if let tt::TokenTree::Subtree(subtree) = tt {\n-        return subtree;\n-    }\n-    unreachable!(\"It is not a subtree\");\n-}\n-\n-fn to_punct(tt: &tt::TokenTree) -> &tt::Punct {\n-    if let tt::TokenTree::Leaf(tt::Leaf::Punct(lit)) = tt {\n-        return lit;\n-    }\n-    unreachable!(\"It is not a Punct\");\n-}\n-\n-#[test]\n-fn test_attr_to_token_tree() {\n-    let expansion = parse_to_token_tree_by_syntax(\n-        r#\"\n-            #[derive(Copy)]\n-            struct Foo;\n-            \"#,\n-    );\n-\n-    assert_eq!(to_punct(&expansion.token_trees[0]).char, '#');\n-    assert_eq!(\n-        to_subtree(&expansion.token_trees[1]).delimiter_kind(),\n-        Some(tt::DelimiterKind::Bracket)\n-    );\n-}\n-\n-#[test]\n-fn test_underscore() {\n-    parse_macro(\n-        r#\"\n-            macro_rules! foo {\n-                 ($_:tt) => { 0 }\n-            }\n-    \"#,\n-    )\n-    .assert_expand_items(r#\"foo! { => }\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_underscore_not_greedily() {\n-    parse_macro(\n-        r#\"\n-macro_rules! q {\n-    ($($a:ident)* _) => {0};\n-}\n-\"#,\n-    )\n-    // `_` overlaps with `$a:ident` but rustc matches it under the `_` token\n-    .assert_expand_items(r#\"q![a b c d _]\"#, r#\"0\"#);\n-\n-    parse_macro(\n-        r#\"\n-macro_rules! q {\n-    ($($a:expr => $b:ident)* _ => $c:expr) => {0};\n-}\n-\"#,\n-    )\n-    // `_ => ou` overlaps with `$a:expr => $b:ident` but rustc matches it under `_ => $c:expr`\n-    .assert_expand_items(r#\"q![a => b c => d _ => ou]\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_underscore_as_type() {\n-    parse_macro(\n-        r#\"\n-macro_rules! q {\n-    ($a:ty) => {0};\n-}\n-\"#,\n-    )\n-    // Underscore is a type\n-    .assert_expand_items(r#\"q![_]\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_underscore_lifetime() {\n-    parse_macro(r#\"macro_rules! q { ($a:lifetime) => {0}; }\"#)\n-        .assert_expand_items(r#\"q!['_]\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_vertical_bar_with_pat() {\n-    parse_macro(\n-        r#\"\n-            macro_rules! foo {\n-                 (| $pat:pat | ) => { 0 }\n-            }\n-    \"#,\n-    )\n-    .assert_expand_items(r#\"foo! { | x | }\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_dollar_crate_lhs_is_not_meta() {\n-    parse_macro(\n-        r#\"\n-macro_rules! foo {\n-    ($crate) => {};\n-    () => {0};\n-}\n-    \"#,\n-    )\n-    .assert_expand_items(r#\"foo!{}\"#, r#\"0\"#);\n-}\n-\n-#[test]\n-fn test_lifetime() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($ lt:lifetime) => { struct Ref<$ lt>{ s: &$ lt str } }\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!{'a}\"#, r#\"struct Ref <'a > {s : &'a str}\"#);\n-}\n-\n-#[test]\n-fn test_literal() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($ type:ty , $ lit:literal) => { const VALUE: $ type = $ lit;};\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!(u8,0);\"#, r#\"const VALUE : u8 = 0 ;\"#);\n-\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($ type:ty , $ lit:literal) => { const VALUE: $ type = $ lit;};\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!(i32,-1);\"#, r#\"const VALUE : i32 = - 1 ;\"#);\n-}\n-\n-#[test]\n-fn test_boolean_is_ident() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($lit0:literal, $lit1:literal) => { const VALUE: (bool,bool) = ($lit0,$lit1); };\n-        }\n-\"#,\n-    )\n-    .assert_expand(\n-        r#\"foo!(true,false);\"#,\n-        r#\"\n-SUBTREE $\n-  IDENT   const 14\n-  IDENT   VALUE 15\n-  PUNCH   : [alone] 16\n-  SUBTREE () 17\n-    IDENT   bool 18\n-    PUNCH   , [alone] 19\n-    IDENT   bool 20\n-  PUNCH   = [alone] 21\n-  SUBTREE () 22\n-    IDENT   true 29\n-    PUNCH   , [joint] 25\n-    IDENT   false 31\n-  PUNCH   ; [alone] 28\n-\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_vis() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-              ($ vis:vis $ name:ident) => { $ vis fn $ name() {}};\n-        }\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!(pub foo);\"#, r#\"pub fn foo () {}\"#)\n-    // test optional cases\n-    .assert_expand_items(r#\"foo!(foo);\"#, r#\"fn foo () {}\"#);\n-}\n-\n-#[test]\n-fn test_inner_macro_rules() {\n-    parse_macro(\n-        r#\"\n-macro_rules! foo {\n-    ($a:ident, $b:ident, $c:tt) => {\n-\n-        macro_rules! bar {\n-            ($bi:ident) => {\n-                fn $bi() -> u8 {$c}\n-            }\n-        }\n-\n-        bar!($a);\n-        fn $b() -> u8 {$c}\n-    }\n-}\n-\"#,\n-    ).\n-    assert_expand_items(\n-        r#\"foo!(x,y, 1);\"#,\n-        r#\"macro_rules ! bar {($ bi : ident) => {fn $ bi () -> u8 {1}}} bar ! (x) ; fn y () -> u8 {1}\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_expr_after_path_colons() {\n-    assert!(parse_macro(\n-        r#\"\n-macro_rules! m {\n-    ($k:expr) => {\n-            f(K::$k);\n-       }\n-}\n-\"#,\n-    )\n-    .expand_statements(r#\"m!(C(\"0\"))\"#)\n-    .descendants()\n-    .any(|token| token.kind() == ERROR));\n-}\n-\n-#[test]\n-fn test_match_is_not_greedy() {\n-    parse_macro(\n-        r#\"\n-macro_rules! foo {\n-    ($($i:ident $(,)*),*) => {};\n-}\n-\"#,\n-    )\n-    .assert_expand_items(r#\"foo!(a,b);\"#, r#\"\"#);\n-}\n-\n-// The following tests are based on real world situations\n-#[test]\n-fn test_vec() {\n-    let fixture = parse_macro(\n-        r#\"\n-         macro_rules! vec {\n-            ($($item:expr),*) => {\n-                {\n-                    let mut v = Vec::new();\n-                    $(\n-                        v.push($item);\n-                    )*\n-                    v\n-                }\n-            };\n-}\n-\"#,\n-    );\n-    fixture\n-        .assert_expand_items(r#\"vec!();\"#, r#\"{let mut v = Vec :: new () ; v}\"#)\n-        .assert_expand_items(\n-            r#\"vec![1u32,2];\"#,\n-            r#\"{let mut v = Vec :: new () ; v . push (1u32) ; v . push (2) ; v}\"#,\n-        );\n-\n-    let tree = fixture.expand_expr(r#\"vec![1u32,2];\"#);\n-\n-    assert_eq_text!(\n-        &format!(\"{:#?}\", tree),\n-        r#\"BLOCK_EXPR@0..45\n-  STMT_LIST@0..45\n-    L_CURLY@0..1 \"{\"\n-    LET_STMT@1..20\n-      LET_KW@1..4 \"let\"\n-      IDENT_PAT@4..8\n-        MUT_KW@4..7 \"mut\"\n-        NAME@7..8\n-          IDENT@7..8 \"v\"\n-      EQ@8..9 \"=\"\n-      CALL_EXPR@9..19\n-        PATH_EXPR@9..17\n-          PATH@9..17\n-            PATH@9..12\n-              PATH_SEGMENT@9..12\n-                NAME_REF@9..12\n-                  IDENT@9..12 \"Vec\"\n-            COLON2@12..14 \"::\"\n-            PATH_SEGMENT@14..17\n-              NAME_REF@14..17\n-                IDENT@14..17 \"new\"\n-        ARG_LIST@17..19\n-          L_PAREN@17..18 \"(\"\n-          R_PAREN@18..19 \")\"\n-      SEMICOLON@19..20 \";\"\n-    EXPR_STMT@20..33\n-      METHOD_CALL_EXPR@20..32\n-        PATH_EXPR@20..21\n-          PATH@20..21\n-            PATH_SEGMENT@20..21\n-              NAME_REF@20..21\n-                IDENT@20..21 \"v\"\n-        DOT@21..22 \".\"\n-        NAME_REF@22..26\n-          IDENT@22..26 \"push\"\n-        ARG_LIST@26..32\n-          L_PAREN@26..27 \"(\"\n-          LITERAL@27..31\n-            INT_NUMBER@27..31 \"1u32\"\n-          R_PAREN@31..32 \")\"\n-      SEMICOLON@32..33 \";\"\n-    EXPR_STMT@33..43\n-      METHOD_CALL_EXPR@33..42\n-        PATH_EXPR@33..34\n-          PATH@33..34\n-            PATH_SEGMENT@33..34\n-              NAME_REF@33..34\n-                IDENT@33..34 \"v\"\n-        DOT@34..35 \".\"\n-        NAME_REF@35..39\n-          IDENT@35..39 \"push\"\n-        ARG_LIST@39..42\n-          L_PAREN@39..40 \"(\"\n-          LITERAL@40..41\n-            INT_NUMBER@40..41 \"2\"\n-          R_PAREN@41..42 \")\"\n-      SEMICOLON@42..43 \";\"\n-    PATH_EXPR@43..44\n-      PATH@43..44\n-        PATH_SEGMENT@43..44\n-          NAME_REF@43..44\n-            IDENT@43..44 \"v\"\n-    R_CURLY@44..45 \"}\"\n-\"#\n-    );\n-}\n-\n-#[test]\n-fn test_winapi_struct() {\n-    // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/macros.rs#L366\n-\n-    parse_macro(\n-        r#\"\n-macro_rules! STRUCT {\n-    ($(#[$attrs:meta])* struct $name:ident {\n-        $($field:ident: $ftype:ty,)+\n-    }) => (\n-        #[repr(C)] #[derive(Copy)] $(#[$attrs])*\n-        pub struct $name {\n-            $(pub $field: $ftype,)+\n-        }\n-        impl Clone for $name {\n-            #[inline]\n-            fn clone(&self) -> $name { *self }\n-        }\n-        #[cfg(feature = \"impl-default\")]\n-        impl Default for $name {\n-            #[inline]\n-            fn default() -> $name { unsafe { $crate::_core::mem::zeroed() } }\n-        }\n-    );\n-}\n-\"#,\n-    ).\n-    // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/shared/d3d9caps.rs\n-    assert_expand_items(r#\"STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\"#,\n-        \"# [repr (C)] # [derive (Copy)] pub struct D3DVSHADERCAPS2_0 {pub Caps : u8 ,} impl Clone for D3DVSHADERCAPS2_0 {# [inline] fn clone (& self) -> D3DVSHADERCAPS2_0 {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DVSHADERCAPS2_0 {# [inline] fn default () -> D3DVSHADERCAPS2_0 {unsafe {$crate :: _core :: mem :: zeroed ()}}}\"\n-    )\n-    .assert_expand_items(r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#,\n-        \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\"\n-    );\n-}\n-\n-#[test]\n-fn test_int_base() {\n-    parse_macro(\n-        r#\"\n-macro_rules! int_base {\n-    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl fmt::$Trait for $T {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                $Radix.fmt_int(*self as $U, f)\n-            }\n-        }\n-    }\n-}\n-\"#,\n-    ).assert_expand_items(r#\" int_base!{Binary for isize as usize -> Binary}\"#,\n-        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt ::Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n-    );\n-}\n-\n-#[test]\n-fn test_generate_pattern_iterators() {\n-    // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs\n-    parse_macro(\n-        r#\"\n-macro_rules! generate_pattern_iterators {\n-        { double ended; with $(#[$common_stability_attribute:meta])*,\n-                           $forward_iterator:ident,\n-                           $reverse_iterator:ident, $iterty:ty\n-        } => {\n-            fn foo(){}\n-        }\n-}\n-\"#,\n-    ).assert_expand_items(\n-        r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str );\"#,\n-        \"fn foo () {}\",\n-    );\n-}\n-\n-#[test]\n-fn test_impl_fn_for_zst() {\n-    // from https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs\n-    parse_macro(\n-        r#\"\n-macro_rules! impl_fn_for_zst  {\n-        {  $( $( #[$attr: meta] )*\n-        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n-            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n-$body: block; )+\n-        } => {\n-           $(\n-            $( #[$attr] )*\n-            struct $Name;\n-\n-            impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n-                #[inline]\n-                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n-                    $body\n-                }\n-            }\n-\n-            impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n-                #[inline]\n-                extern \"rust-call\" fn call_mut(\n-                    &mut self,\n-                    ($( $arg, )*): ($( $ArgTy, )*)\n-                ) -> $ReturnTy {\n-                    Fn::call(&*self, ($( $arg, )*))\n-                }\n-            }\n-\n-            impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n-                type Output = $ReturnTy;\n-\n-                #[inline]\n-                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n-                    Fn::call(&self, ($( $arg, )*))\n-                }\n-            }\n-        )+\n-}\n-        }\n-\"#,\n-    ).assert_expand_items(r#\"\n-impl_fn_for_zst !   {\n-     # [ derive ( Clone ) ]\n-     struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   {\n-         c . escape_debug_ext ( false )\n-     } ;\n-\n-     # [ derive ( Clone ) ]\n-     struct   CharEscapeUnicode   impl   Fn   =   | c :   char |   ->   char :: EscapeUnicode   {\n-         c . escape_unicode ( )\n-     } ;\n-     # [ derive ( Clone ) ]\n-     struct   CharEscapeDefault   impl   Fn   =   | c :   char |   ->   char :: EscapeDefault   {\n-         c . escape_default ( )\n-     } ;\n- }\n-\"#,\n-        \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\"\n-    );\n-}\n-\n-#[test]\n-fn test_impl_nonzero_fmt() {\n-    // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n-    parse_macro(\n-        r#\"\n-        macro_rules! impl_nonzero_fmt {\n-            ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n-                fn foo () {}\n-            }\n-        }\n-\"#,\n-    ).assert_expand_items(\n-        r#\"impl_nonzero_fmt! { # [stable(feature= \"nonzero\",since=\"1.28.0\")] (Debug,Display,Binary,Octal,LowerHex,UpperHex) for NonZeroU8}\"#,\n-        \"fn foo () {}\",\n-    );\n-}\n-\n-#[test]\n-fn test_cfg_if_items() {\n-    // from https://github.com/rust-lang/rust/blob/33fe1131cadba69d317156847be9a402b89f11bb/src/libstd/macros.rs#L986\n-    parse_macro(\n-        r#\"\n-        macro_rules! __cfg_if_items {\n-            (($($not:meta,)*) ; ) => {};\n-            (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-                 __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n-            }\n-        }\n-\"#,\n-    ).assert_expand_items(\n-        r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,\n-        \"__cfg_if_items ! {(rustdoc ,) ;}\",\n-    );\n-}\n-\n-#[test]\n-fn test_cfg_if_main() {\n-    // from https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src/libpanic_unwind/macros.rs#L9\n-    parse_macro(\n-        r#\"\n-        macro_rules! cfg_if {\n-            ($(\n-                if #[cfg($($meta:meta),*)] { $($it:item)* }\n-            ) else * else {\n-                $($it2:item)*\n-            }) => {\n-                __cfg_if_items! {\n-                    () ;\n-                    $( ( ($($meta),*) ($($it)*) ), )*\n-                    ( () ($($it2)*) ),\n-                }\n-            };\n-\n-            // Internal macro to Apply a cfg attribute to a list of items\n-            (@__apply $m:meta, $($it:item)*) => {\n-                $(#[$m] $it)*\n-            };\n-        }\n-\"#,\n-    ).assert_expand_items(r#\"\n-cfg_if !   {\n-     if   # [ cfg ( target_env   =   \"msvc\" ) ]   {\n-         // no extra unwinder support needed\n-     }   else   if   # [ cfg ( all ( target_arch   =   \"wasm32\" ,   not ( target_os   =   \"emscripten\" ) ) ) ]   {\n-         // no unwinder on the system!\n-     }   else   {\n-         mod   libunwind ;\n-         pub   use   libunwind :: * ;\n-     }\n- }\n-\"#,\n-        \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\"\n-    ).assert_expand_items(\n-        r#\"\n-cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" , target_os = \"illumos\" ) ) ) ) ) ) , }\n-\"#,\n-        \"\",\n-    );\n-}\n-\n-#[test]\n-fn test_proptest_arbitrary() {\n-    // from https://github.com/AltSysrq/proptest/blob/d1c4b049337d2f75dd6f49a095115f7c532e5129/proptest/src/arbitrary/macros.rs#L16\n-    parse_macro(\n-        r#\"\n-macro_rules! arbitrary {\n-    ([$($bounds : tt)*] $typ: ty, $strat: ty, $params: ty;\n-        $args: ident => $logic: expr) => {\n-        impl<$($bounds)*> $crate::arbitrary::Arbitrary for $typ {\n-            type Parameters = $params;\n-            type Strategy = $strat;\n-            fn arbitrary_with($args: Self::Parameters) -> Self::Strategy {\n-                $logic\n-            }\n-        }\n-    };\n-\n-}\"#,\n-    ).assert_expand_items(r#\"arbitrary !   ( [ A : Arbitrary ]\n-        Vec < A > ,\n-        VecStrategy < A :: Strategy > ,\n-        RangedParams1 < A :: Parameters > ;\n-        args =>   { let product_unpack !   [ range , a ] = args ; vec ( any_with :: < A >   ( a ) , range ) }\n-    ) ;\"#,\n-    \"impl <A : Arbitrary > $crate :: arbitrary :: Arbitrary for Vec < A > {type Parameters = RangedParams1 < A :: Parameters > ; type Strategy = VecStrategy < A :: Strategy > ; fn arbitrary_with (args : Self :: Parameters) -> Self :: Strategy {{let product_unpack ! [range , a] = args ; vec (any_with :: < A > (a) , range)}}}\"\n-    );\n-}\n-\n-#[test]\n-fn test_old_ridl() {\n-    // This is from winapi 2.8, which do not have a link from github\n-    //\n-    let expanded = parse_macro(\n-        r#\"\n-#[macro_export]\n-macro_rules! RIDL {\n-    (interface $interface:ident ($vtbl:ident) : $pinterface:ident ($pvtbl:ident)\n-        {$(\n-            fn $method:ident(&mut self $(,$p:ident : $t:ty)*) -> $rtr:ty\n-        ),+}\n-    ) => {\n-        impl $interface {\n-            $(pub unsafe fn $method(&mut self) -> $rtr {\n-                ((*self.lpVtbl).$method)(self $(,$p)*)\n-            })+\n-        }\n-    };\n-}\"#,\n-    ).expand_tt(r#\"\n-    RIDL!{interface ID3D11Asynchronous(ID3D11AsynchronousVtbl): ID3D11DeviceChild(ID3D11DeviceChildVtbl) {\n-        fn GetDataSize(&mut self) -> UINT\n-    }}\"#);\n-\n-    assert_eq!(expanded.to_string(), \"impl ID3D11Asynchronous {pub unsafe fn GetDataSize (& mut self) -> UINT {((* self . lpVtbl) .GetDataSize) (self)}}\");\n-}\n-\n-#[test]\n-fn test_quick_error() {\n-    let expanded = parse_macro(\n-        r#\"\n-macro_rules! quick_error {\n-\n- (SORT [enum $name:ident $( #[$meta:meta] )*]\n-        items [$($( #[$imeta:meta] )*\n-                  => $iitem:ident: $imode:tt [$( $ivar:ident: $ityp:ty ),*]\n-                                {$( $ifuncs:tt )*} )* ]\n-        buf [ ]\n-        queue [ ]\n-    ) => {\n-        quick_error!(ENUMINITION [enum $name $( #[$meta] )*]\n-            body []\n-            queue [$(\n-                $( #[$imeta] )*\n-                =>\n-                $iitem: $imode [$( $ivar: $ityp ),*]\n-            )*]\n-        );\n-};\n-\n-}\n-\"#,\n-    )\n-    .expand_tt(\n-        r#\"\n-quick_error ! (SORT [enum Wrapped # [derive (Debug)]] items [\n-        => One : UNIT [] {}\n-        => Two : TUPLE [s :String] {display (\"two: {}\" , s) from ()}\n-    ] buf [] queue []) ;\n-\"#,\n-    );\n-\n-    assert_eq!(expanded.to_string(), \"quick_error ! (ENUMINITION [enum Wrapped # [derive (Debug)]] body [] queue [=> One : UNIT [] => Two : TUPLE [s : String]]) ;\");\n-}\n-\n-#[test]\n-fn test_empty_repeat_vars_in_empty_repeat_vars() {\n-    parse_macro(\n-        r#\"\n-macro_rules! delegate_impl {\n-    ([$self_type:ident, $self_wrap:ty, $self_map:ident]\n-     pub trait $name:ident $(: $sup:ident)* $(+ $more_sup:ident)* {\n-\n-        $(\n-        @escape [type $assoc_name_ext:ident]\n-        )*\n-        $(\n-        @section type\n-        $(\n-            $(#[$_assoc_attr:meta])*\n-            type $assoc_name:ident $(: $assoc_bound:ty)*;\n-        )+\n-        )*\n-        $(\n-        @section self\n-        $(\n-            $(#[$_method_attr:meta])*\n-            fn $method_name:ident(self $(: $self_selftype:ty)* $(,$marg:ident : $marg_ty:ty)*) -> $mret:ty;\n-        )+\n-        )*\n-        $(\n-        @section nodelegate\n-        $($tail:tt)*\n-        )*\n-    }) => {\n-        impl<> $name for $self_wrap where $self_type: $name {\n-            $(\n-            $(\n-                fn $method_name(self $(: $self_selftype)* $(,$marg: $marg_ty)*) -> $mret {\n-                    $self_map!(self).$method_name($($marg),*)\n-                }\n-            )*\n-            )*\n-        }\n-    }\n-}\n-\"#,\n-    ).assert_expand_items(\n-        r#\"delegate_impl ! {[G , & 'a mut G , deref] pub trait Data : GraphBase {@ section type type NodeWeight ;}}\"#,\n-        \"impl <> Data for & \\'a mut G where G : Data {}\",\n-    );\n-}\n-\n-#[test]\n-fn expr_interpolation() {\n-    let expanded = parse_macro(\n-        r#\"\n-        macro_rules! id {\n-            ($expr:expr) => {\n-                map($expr)\n-            }\n-        }\n-        \"#,\n-    )\n-    .expand_expr(\"id!(x + foo);\");\n-\n-    assert_eq!(expanded.to_string(), \"map(x+foo)\");\n-}\n-\n-#[test]\n-fn test_issue_2520() {\n-    let macro_fixture = parse_macro(\n-        r#\"\n-        macro_rules! my_macro {\n-            {\n-                ( $(\n-                    $( [] $sname:ident : $stype:ty  )?\n-                    $( [$expr:expr] $nname:ident : $ntype:ty  )?\n-                ),* )\n-            } => {\n-                Test {\n-                    $(\n-                        $( $sname, )?\n-                    )*\n-                }\n-            };\n-        }\n-    \"#,\n-    );\n-\n-    macro_fixture.assert_expand_items(\n-        r#\"my_macro ! {\n-            ([] p1 : u32 , [|_| S0K0] s : S0K0 , [] k0 : i32)\n-        }\"#,\n-        \"Test {p1 , k0 ,}\",\n-    );\n-}\n-\n-#[test]\n-fn test_issue_3861() {\n-    let macro_fixture = parse_macro(\n-        r#\"\n-        macro_rules! rgb_color {\n-            ($p:expr, $t: ty) => {\n-                pub fn new() {\n-                    let _ = 0 as $t << $p;\n-                }\n-            };\n-        }\n-    \"#,\n-    );\n-\n-    macro_fixture.expand_items(r#\"rgb_color!(8 + 8, u32);\"#);\n-}\n-\n-#[test]\n-fn test_repeat_bad_var() {\n-    // FIXME: the second rule of the macro should be removed and an error about\n-    // `$( $c )+` raised\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo {\n-            ($( $b:ident )+) => {\n-                $( $c )+\n-            };\n-            ($( $b:ident )+) => {\n-                $( $b )+\n-            }\n-        }\n-    \"#,\n-    )\n-    .assert_expand_items(\"foo!(b0 b1);\", \"b0 b1\");\n-}\n-\n-#[test]\n-fn test_no_space_after_semi_colon() {\n-    let expanded = parse_macro(\n-        r#\"\n-        macro_rules! with_std { ($($i:item)*) => ($(#[cfg(feature = \"std\")]$i)*) }\n-    \"#,\n-    )\n-    .expand_items(r#\"with_std! {mod m;mod f;}\"#);\n-\n-    let dump = format!(\"{:#?}\", expanded);\n-    assert_eq_text!(\n-        r###\"MACRO_ITEMS@0..52\n-  MODULE@0..26\n-    ATTR@0..21\n-      POUND@0..1 \"#\"\n-      L_BRACK@1..2 \"[\"\n-      META@2..20\n-        PATH@2..5\n-          PATH_SEGMENT@2..5\n-            NAME_REF@2..5\n-              IDENT@2..5 \"cfg\"\n-        TOKEN_TREE@5..20\n-          L_PAREN@5..6 \"(\"\n-          IDENT@6..13 \"feature\"\n-          EQ@13..14 \"=\"\n-          STRING@14..19 \"\\\"std\\\"\"\n-          R_PAREN@19..20 \")\"\n-      R_BRACK@20..21 \"]\"\n-    MOD_KW@21..24 \"mod\"\n-    NAME@24..25\n-      IDENT@24..25 \"m\"\n-    SEMICOLON@25..26 \";\"\n-  MODULE@26..52\n-    ATTR@26..47\n-      POUND@26..27 \"#\"\n-      L_BRACK@27..28 \"[\"\n-      META@28..46\n-        PATH@28..31\n-          PATH_SEGMENT@28..31\n-            NAME_REF@28..31\n-              IDENT@28..31 \"cfg\"\n-        TOKEN_TREE@31..46\n-          L_PAREN@31..32 \"(\"\n-          IDENT@32..39 \"feature\"\n-          EQ@39..40 \"=\"\n-          STRING@40..45 \"\\\"std\\\"\"\n-          R_PAREN@45..46 \")\"\n-      R_BRACK@46..47 \"]\"\n-    MOD_KW@47..50 \"mod\"\n-    NAME@50..51\n-      IDENT@50..51 \"f\"\n-    SEMICOLON@51..52 \";\"\"###,\n-        dump.trim()\n-    );\n-}\n-\n-// https://github.com/rust-lang/rust/blob/master/src/test/ui/issues/issue-57597.rs\n-#[test]\n-fn test_rustc_issue_57597() {\n-    fn test_error(fixture: &str) {\n-        assert_eq!(parse_macro_error(fixture), ParseError::RepetitionEmptyTokenTree);\n-    }\n-\n-    test_error(\"macro_rules! foo { ($($($i:ident)?)+) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($i:ident)?)*) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($i:ident)?)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)?)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)*)?)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)*)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)?)*) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)*)*)?) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)*)*) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)?)*)+) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)+)?)*) => {}; }\");\n-    test_error(\"macro_rules! foo { ($($($($i:ident)+)*)?) => {}; }\");\n-}\n-\n-#[test]\n-fn test_expand_bad_literal() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! foo { ($i:literal) => {}; }\n-    \"#,\n-    )\n-    .assert_expand_err(r#\"foo!(&k\");\"#, &ExpandError::BindingError(\"\".into()));\n-}\n-\n-#[test]\n-fn test_empty_comments() {\n-    parse_macro(\n-        r#\"\n-        macro_rules! one_arg_macro { ($fmt:expr) => (); }\n-    \"#,\n-    )\n-    .assert_expand_err(\n-        r#\"one_arg_macro!(/**/)\"#,\n-        &ExpandError::BindingError(\"expected Expr\".into()),\n-    );\n-}"}, {"sha": "3d303a1237d08a07dd2a84bc1c7daf1da4bfada5", "filename": "crates/test_utils/src/fixture.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7548cb42735807ff423a4af7414542558e2d83dd/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Ffixture.rs?ref=7548cb42735807ff423a4af7414542558e2d83dd", "patch": "@@ -147,6 +147,7 @@ impl Fixture {\n                 if line.starts_with(\"// \")\n                     && line.contains(':')\n                     && !line.contains(\"::\")\n+                    && !line.contains(\".\")\n                     && line.chars().all(|it| !it.is_uppercase())\n                 {\n                     panic!(\"looks like invalid metadata line: {:?}\", line);"}]}