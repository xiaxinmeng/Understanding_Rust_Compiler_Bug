{"sha": "f0e76772720f825b751965b4ff22b843c89c4062", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZTc2NzcyNzIwZjgyNWI3NTE5NjViNGZmMjJiODQzYzg5YzQwNjI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-24T10:27:31Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-24T10:27:31Z"}, "message": "Return Def from resolve()", "tree": {"sha": "f7923977387e49cfdcded8b72b0922aae4077256", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7923977387e49cfdcded8b72b0922aae4077256"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0e76772720f825b751965b4ff22b843c89c4062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0e76772720f825b751965b4ff22b843c89c4062", "html_url": "https://github.com/rust-lang/rust/commit/f0e76772720f825b751965b4ff22b843c89c4062", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0e76772720f825b751965b4ff22b843c89c4062/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b26b7472b6c33b39d2dd12d20d1e92622261859", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b26b7472b6c33b39d2dd12d20d1e92622261859", "html_url": "https://github.com/rust-lang/rust/commit/6b26b7472b6c33b39d2dd12d20d1e92622261859"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "7835cc175a8e6779e2ed459ad9bf1421429cca75", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f0e76772720f825b751965b4ff22b843c89c4062/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e76772720f825b751965b4ff22b843c89c4062/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f0e76772720f825b751965b4ff22b843c89c4062", "patch": "@@ -894,15 +894,15 @@ fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n \n /// Resolve a given string as a path, along with whether or not it is\n /// in the value namespace\n-fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<hir::Path, ()> {\n+fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<Def, ()> {\n     // In case we're in a module, try to resolve the relative\n     // path\n     if let Some(id) = cx.mod_ids.borrow().last() {\n         cx.resolver.borrow_mut()\n                    .with_scope(*id, |resolver| {\n                         resolver.resolve_str_path_error(DUMMY_SP,\n                                                         &path_str, is_val)\n-                    })\n+                    }).map(|path| path.def)\n     } else {\n         Err(())\n     }\n@@ -991,8 +991,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n \n                     match kind {\n                         PathKind::Value => {\n-                            if let Ok(path) = resolve(cx, path_str, true) {\n-                                path.def\n+                            if let Ok(def) = resolve(cx, path_str, true) {\n+                                def\n                             } else {\n                                 // this could just be a normal link or a broken link\n                                 // we could potentially check if something is\n@@ -1001,8 +1001,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n                             }\n                         }\n                         PathKind::Type => {\n-                            if let Ok(path) = resolve(cx, path_str, false) {\n-                                path.def\n+                            if let Ok(def) = resolve(cx, path_str, false) {\n+                                def\n                             } else {\n                                 // this could just be a normal link\n                                 continue;\n@@ -1011,42 +1011,42 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         PathKind::Unknown => {\n                             // try everything!\n                             if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                                if let Ok(type_path) = resolve(cx, path_str, false) {\n+                                if let Ok(type_def) = resolve(cx, path_str, false) {\n                                     let (type_kind, article, type_disambig)\n-                                        = type_ns_kind(type_path.def, path_str);\n+                                        = type_ns_kind(type_def, path_str);\n                                     ambiguity_error(cx, &attrs, path_str,\n                                                     article, type_kind, &type_disambig,\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                     continue;\n-                                } else if let Ok(value_path) = resolve(cx, path_str, true) {\n+                                } else if let Ok(value_def) = resolve(cx, path_str, true) {\n                                     let (value_kind, value_disambig)\n-                                        = value_ns_kind(value_path.def, path_str)\n+                                        = value_ns_kind(value_def, path_str)\n                                             .expect(\"struct and mod cases should have been \\\n                                                      caught in previous branch\");\n                                     ambiguity_error(cx, &attrs, path_str,\n                                                     \"a\", value_kind, &value_disambig,\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                 }\n                                 macro_def\n-                            } else if let Ok(type_path) = resolve(cx, path_str, false) {\n+                            } else if let Ok(type_def) = resolve(cx, path_str, false) {\n                                 // It is imperative we search for not-a-value first\n                                 // Otherwise we will find struct ctors for when we are looking\n                                 // for structs, and the link won't work.\n                                 // if there is something in both namespaces\n-                                if let Ok(value_path) = resolve(cx, path_str, true) {\n-                                    let kind = value_ns_kind(value_path.def, path_str);\n+                                if let Ok(value_def) = resolve(cx, path_str, true) {\n+                                    let kind = value_ns_kind(value_def, path_str);\n                                     if let Some((value_kind, value_disambig)) = kind {\n                                         let (type_kind, article, type_disambig)\n-                                            = type_ns_kind(type_path.def, path_str);\n+                                            = type_ns_kind(type_def, path_str);\n                                         ambiguity_error(cx, &attrs, path_str,\n                                                         article, type_kind, &type_disambig,\n                                                         \"a\", value_kind, &value_disambig);\n                                         continue;\n                                     }\n                                 }\n-                                type_path.def\n-                            } else if let Ok(value_path) = resolve(cx, path_str, true) {\n-                                value_path.def\n+                                type_def\n+                            } else if let Ok(value_def) = resolve(cx, path_str, true) {\n+                                value_def\n                             } else {\n                                 // this could just be a normal link\n                                 continue;"}]}