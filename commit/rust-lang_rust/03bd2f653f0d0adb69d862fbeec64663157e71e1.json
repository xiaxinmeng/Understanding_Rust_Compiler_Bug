{"sha": "03bd2f653f0d0adb69d862fbeec64663157e71e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYmQyZjY1M2YwZDBhZGI2OWQ4NjJmYmVlYzY0NjYzMTU3ZTcxZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-10T00:51:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-10T00:51:14Z"}, "message": "Auto merge of #60683 - Centril:rollup-p05qh5d, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #59348 (Clean up and add tests for slice drop shims)\n - #60188 (Identify when a stmt could have been parsed as an expr)\n - #60234 (std: Derive `Default` for `io::Cursor`)\n - #60618 (Comment ext::tt::transcribe)\n - #60648 (Skip codegen for one UI test with long file path)\n - #60671 (remove unneeded `extern crate`s from build tools)\n - #60675 (Remove the old await! macro)\n - #60676 (Fix async desugaring providing wrong input to procedural macros.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3067cec05b04e1d4e72aef71a9be0d1a5f83affc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3067cec05b04e1d4e72aef71a9be0d1a5f83affc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03bd2f653f0d0adb69d862fbeec64663157e71e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03bd2f653f0d0adb69d862fbeec64663157e71e1", "html_url": "https://github.com/rust-lang/rust/commit/03bd2f653f0d0adb69d862fbeec64663157e71e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03bd2f653f0d0adb69d862fbeec64663157e71e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adcd4aa8d07945d5ef09129b05e8e1ff1bcce58e", "url": "https://api.github.com/repos/rust-lang/rust/commits/adcd4aa8d07945d5ef09129b05e8e1ff1bcce58e", "html_url": "https://github.com/rust-lang/rust/commit/adcd4aa8d07945d5ef09129b05e8e1ff1bcce58e"}, {"sha": "45b09453dbf120cc23d889435aac3ed7d2ec8eb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/45b09453dbf120cc23d889435aac3ed7d2ec8eb7", "html_url": "https://github.com/rust-lang/rust/commit/45b09453dbf120cc23d889435aac3ed7d2ec8eb7"}], "stats": {"total": 1112, "additions": 818, "deletions": 294}, "files": [{"sha": "f6334e9bdb8155c6c03f5de9613a7ccd5d9ad53d", "filename": "Cargo.lock", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -29,7 +29,7 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"html5ever 0.22.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"maplit 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tendril 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -170,13 +170,12 @@ dependencies = [\n  \"cmake 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pretty_assertions 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -192,7 +191,6 @@ name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -266,7 +264,7 @@ dependencies = [\n  \"ignore 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"im-rc 12.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libgit2-sys 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -374,7 +372,7 @@ dependencies = [\n  \"clippy_lints 0.0.212\",\n  \"compiletest_rs 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-workspace-hack 1.0.0\",\n  \"rustc_tools_util 0.1.1\",\n@@ -394,7 +392,7 @@ dependencies = [\n  \"cargo_metadata 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"if_chain 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -465,14 +463,13 @@ dependencies = [\n  \"env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustfix 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -592,7 +589,7 @@ dependencies = [\n  \"arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-utils 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -606,7 +603,7 @@ dependencies = [\n  \"arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -751,7 +748,7 @@ name = \"elasticlunr-rs\"\n version = \"2.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1032,7 +1029,7 @@ name = \"handlebars\"\n version = \"0.32.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1047,7 +1044,7 @@ name = \"handlebars\"\n version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest_derive 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1143,7 +1140,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-channel 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"globset 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1169,7 +1166,7 @@ dependencies = [\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1265,7 +1262,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"lazy_static\"\n-version = \"1.2.0\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1354,7 +1351,7 @@ name = \"log_settings\"\n version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1441,7 +1438,7 @@ dependencies = [\n  \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"handlebars 0.32.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"open 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1469,7 +1466,7 @@ dependencies = [\n  \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"handlebars 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"open 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1703,7 +1700,7 @@ dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"foreign-types 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1971,7 +1968,7 @@ dependencies = [\n  \"bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2045,7 +2042,7 @@ dependencies = [\n  \"derive_more 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"humantime 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-syntax 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2141,7 +2138,7 @@ version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2243,7 +2240,7 @@ dependencies = [\n  \"home 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jsonrpc-core 10.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-codec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-types 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2349,7 +2346,7 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"measureme 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2402,7 +2399,7 @@ dependencies = [\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-graphviz 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2532,7 +2529,7 @@ version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2543,7 +2540,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2702,7 +2699,7 @@ dependencies = [\n  \"ena 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3097,7 +3094,7 @@ dependencies = [\n  \"getopts 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ignore 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-rustc_target 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3143,7 +3140,7 @@ name = \"schannel\"\n version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3313,7 +3310,7 @@ name = \"string_cache\"\n version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"new_debug_unreachable 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"phf_shared 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"precomputed-hash 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3404,7 +3401,7 @@ name = \"syntax\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -3549,7 +3546,7 @@ name = \"thread_local\"\n version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3558,7 +3555,6 @@ version = \"0.1.0\"\n dependencies = [\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3664,7 +3660,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-utils 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mio 0.6.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3783,7 +3779,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"is-match 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -3795,7 +3791,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"is-match 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -4160,7 +4156,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum jsonrpc-core 10.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a5152c3fda235dfd68341b3edf4121bc4428642c93acbd6de88c26bf95fc5d7\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73\"\n-\"checksum lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a374c89b9db55895453a74c1e38861d9deec0b01b405a82516e9d5de4820dea1\"\n+\"checksum lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14\"\n \"checksum lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \"checksum libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c6785aa7dd976f5fbf3b71cfd9cd49d7f783c1ff565a858d71031c6c313aa5c6\"\n \"checksum libgit2-sys 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48441cb35dc255da8ae72825689a95368bf510659ae1ad55dc4aa88cb1789bf1\""}, {"sha": "589ee9276a5a3be6a406e19d495bfa1de7b5e4b9", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -42,11 +42,10 @@ num_cpus = \"1.0\"\n getopts = \"0.2.19\"\n cc = \"1.0.35\"\n libc = \"0.2\"\n-serde = \"1.0.8\"\n-serde_derive = \"1.0.8\"\n+serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n toml = \"0.4\"\n-lazy_static = \"0.2\"\n+lazy_static = \"1.3.0\"\n time = \"0.1\"\n petgraph = \"0.4.13\"\n "}, {"sha": "51663e93169822fb1e15b6eb3f3e35338b00075a", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -11,6 +11,8 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{Duration, Instant};\n \n+use build_helper::t;\n+\n use crate::cache::{Cache, Interned, INTERNER};\n use crate::check;\n use crate::compile;\n@@ -1308,6 +1310,8 @@ mod __test {\n     use crate::config::Config;\n     use std::thread;\n \n+    use pretty_assertions::assert_eq;\n+\n     fn configure(host: &[&str], target: &[&str]) -> Config {\n         let mut config = Config::default_opts();\n         // don't save toolstates"}, {"sha": "f137a7b8cc28118f4380bb9d0ae92dbcdfc295c0", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -13,6 +13,8 @@ use std::path::{Path, PathBuf};\n use std::sync::Mutex;\n use std::cmp::{PartialOrd, Ord, Ordering};\n \n+use lazy_static::lazy_static;\n+\n use crate::builder::Step;\n \n pub struct Interned<T>(usize, PhantomData<*const T>);"}, {"sha": "73be8bfed8e8821e5730895e7d1315c707409214", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -9,6 +9,8 @@ use std::fs;\n use std::io::{self, ErrorKind};\n use std::path::Path;\n \n+use build_helper::t;\n+\n use crate::Build;\n \n pub fn clean(build: &Build, all: bool) {"}, {"sha": "9c4e856f0b88b3a34da0ab7ce45a59452a080400", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -15,8 +15,9 @@ use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio, exit};\n use std::str;\n \n-use build_helper::{output, mtime, up_to_date};\n+use build_helper::{output, mtime, t, up_to_date};\n use filetime::FileTime;\n+use serde::Deserialize;\n use serde_json;\n \n use crate::dist;"}, {"sha": "b1d009a674066974415de9c2782f08351a4a8e9c", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -10,8 +10,10 @@ use std::path::{Path, PathBuf};\n use std::process;\n use std::cmp;\n \n+use build_helper::t;\n use num_cpus;\n use toml;\n+use serde::Deserialize;\n use crate::cache::{INTERNER, Interned};\n use crate::flags::Flags;\n pub use crate::flags::Subcommand;"}, {"sha": "b0616ff66918cbbf82711ca893f689bcf88bf9f0", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -14,7 +14,7 @@ use std::io::Write;\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n-use build_helper::output;\n+use build_helper::{output, t};\n \n use crate::{Compiler, Mode, LLVM_TOOLS};\n use crate::channel;"}, {"sha": "9c3a17bff6b7a619e240a94c29ddb8517d1ff43b", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -13,7 +13,7 @@ use std::io;\n use std::path::{PathBuf, Path};\n \n use crate::Mode;\n-use build_helper::up_to_date;\n+use build_helper::{t, up_to_date};\n \n use crate::util::symlink_dir;\n use crate::builder::{Builder, Compiler, RunConfig, ShouldRun, Step};"}, {"sha": "deda30b6bbd9beb1263219ccd4ec0b098cd1b64e", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -8,6 +8,8 @@ use std::fs;\n use std::path::{Path, PathBuf, Component};\n use std::process::Command;\n \n+use build_helper::t;\n+\n use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};"}, {"sha": "ca4489655ca7b46c77d6adf4eca7667e78d4b4c1", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -108,17 +108,6 @@\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n \n-#[macro_use]\n-extern crate build_helper;\n-#[macro_use]\n-extern crate serde_derive;\n-#[macro_use]\n-extern crate lazy_static;\n-\n-#[cfg(test)]\n-#[macro_use]\n-extern crate pretty_assertions;\n-\n use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::env;\n@@ -134,7 +123,9 @@ use std::os::unix::fs::symlink as symlink_file;\n #[cfg(windows)]\n use std::os::windows::fs::symlink_file;\n \n-use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n+use build_helper::{\n+    mtime, output, run_silent, run_suppressed, t, try_run_silent, try_run_suppressed,\n+};\n use filetime::FileTime;\n \n use crate::util::{exe, libdir, OutputFolder, CiEnv};"}, {"sha": "4a71fd2ce0bd2c64cc184ed8c96c682e0f53db1a", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -4,6 +4,7 @@ use std::path::PathBuf;\n use std::collections::HashSet;\n \n use build_helper::output;\n+use serde::Deserialize;\n use serde_json;\n \n use crate::{Build, Crate};"}, {"sha": "5777331b9bfd5b9ae67b0544ee4cba6136168fe0", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -14,7 +14,7 @@ use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-use build_helper::output;\n+use build_helper::{output, t};\n use cmake;\n use cc;\n "}, {"sha": "dc65fb9b79706b579f23935a445576676a63aa70", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -15,7 +15,7 @@ use std::fs;\n use std::path::PathBuf;\n use std::process::Command;\n \n-use build_helper::output;\n+use build_helper::{output, t};\n \n use crate::Build;\n "}, {"sha": "a3d96836aad54129f3edd057c309d25741eca68c", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -11,7 +11,7 @@ use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-use build_helper::{self, output};\n+use build_helper::{self, output, t};\n \n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};"}, {"sha": "edcd68d010e8451a44cdbd5259b221715608ba6f", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -4,6 +4,8 @@ use std::path::PathBuf;\n use std::process::{Command, exit};\n use std::collections::HashSet;\n \n+use build_helper::t;\n+\n use crate::Mode;\n use crate::Compiler;\n use crate::builder::{Step, RunConfig, ShouldRun, Builder};"}, {"sha": "e86209be91fe17c0d4e198b920980199a830116a", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -1,3 +1,5 @@\n+use serde::{Deserialize, Serialize};\n+\n #[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]\n #[serde(rename_all = \"kebab-case\")]\n /// Whether a tool can be compiled, tested or neither"}, {"sha": "a162c65672f8251771ffe2bf2a0c80a570a7dd95", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -11,6 +11,8 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n \n+use build_helper::t;\n+\n use crate::config::Config;\n use crate::builder::Builder;\n "}, {"sha": "4d5707560b0480539ff52b5dfcbae8a0eae521b9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -50,7 +50,6 @@ use errors::Applicability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_data_structures::sync::Lrc;\n \n use std::collections::{BTreeSet, BTreeMap};\n use std::mem;\n@@ -59,10 +58,10 @@ use syntax::attr;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::source_map::{self, respan, CompilerDesugaringKind, Spanned};\n+use syntax::source_map::{respan, CompilerDesugaringKind, Spanned};\n use syntax::std_inject;\n use syntax::symbol::{keywords, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n@@ -854,27 +853,6 @@ impl<'a> LoweringContext<'a> {\n         Ident::with_empty_ctxt(Symbol::gensym(s))\n     }\n \n-    /// Reuses the span but adds information like the kind of the desugaring and features that are\n-    /// allowed inside this span.\n-    fn mark_span_with_reason(\n-        &self,\n-        reason: CompilerDesugaringKind,\n-        span: Span,\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-    ) -> Span {\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(source_map::ExpnInfo {\n-            call_site: span,\n-            def_site: Some(span),\n-            format: source_map::CompilerDesugaring(reason),\n-            allow_internal_unstable,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: source_map::hygiene::default_edition(),\n-        });\n-        span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n-    }\n-\n     fn with_anonymous_lifetime_mode<R>(\n         &mut self,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n@@ -1162,7 +1140,7 @@ impl<'a> LoweringContext<'a> {\n             attrs: ThinVec::new(),\n         };\n \n-        let unstable_span = self.mark_span_with_reason(\n+        let unstable_span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n             Some(vec![\n@@ -1569,7 +1547,7 @@ impl<'a> LoweringContext<'a> {\n         // desugaring that explicitly states that we don't want to track that.\n         // Not tracking it makes lints in rustc and clippy very fragile as\n         // frequently opened issues show.\n-        let exist_ty_span = self.mark_span_with_reason(\n+        let exist_ty_span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::ExistentialReturnType,\n             span,\n             None,\n@@ -2443,7 +2421,7 @@ impl<'a> LoweringContext<'a> {\n     ) -> hir::FunctionRetTy {\n         let span = output.span();\n \n-        let exist_ty_span = self.mark_span_with_reason(\n+        let exist_ty_span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n             None,\n@@ -4179,7 +4157,7 @@ impl<'a> LoweringContext<'a> {\n             }),\n             ExprKind::TryBlock(ref body) => {\n                 self.with_catch_scope(body.id, |this| {\n-                    let unstable_span = this.mark_span_with_reason(\n+                    let unstable_span = this.sess.source_map().mark_span_with_reason(\n                         CompilerDesugaringKind::TryBlock,\n                         body.span,\n                         Some(vec![\n@@ -4612,7 +4590,7 @@ impl<'a> LoweringContext<'a> {\n                 // expand <head>\n                 let mut head = self.lower_expr(head);\n                 let head_sp = head.span;\n-                let desugared_span = self.mark_span_with_reason(\n+                let desugared_span = self.sess.source_map().mark_span_with_reason(\n                     CompilerDesugaringKind::ForLoop,\n                     head_sp,\n                     None,\n@@ -4773,15 +4751,15 @@ impl<'a> LoweringContext<'a> {\n                 //                 return Try::from_error(From::from(err)),\n                 // }\n \n-                let unstable_span = self.mark_span_with_reason(\n+                let unstable_span = self.sess.source_map().mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     e.span,\n                     Some(vec![\n                         Symbol::intern(\"try_trait\")\n                     ].into()),\n                 );\n                 let try_span = self.sess.source_map().end_point(e.span);\n-                let try_span = self.mark_span_with_reason(\n+                let try_span = self.sess.source_map().mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     try_span,\n                     Some(vec![\n@@ -5566,12 +5544,12 @@ impl<'a> LoweringContext<'a> {\n             );\n             self.sess.abort_if_errors();\n         }\n-        let span = self.mark_span_with_reason(\n+        let span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n             None,\n         );\n-        let gen_future_span = self.mark_span_with_reason(\n+        let gen_future_span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n             Some(vec![Symbol::intern(\"gen_future\")].into()),"}, {"sha": "98ca7c32675c8b09e1ea0e1083090df7b9c326f7", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 65, "deletions": 57, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -10,7 +10,7 @@ use rustc::ty::util::IntTypeExt;\n use rustc_data_structures::indexed_vec::Idx;\n use crate::util::patch::MirPatch;\n \n-use std::u32;\n+use std::convert::TryInto;\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum DropFlagState {\n@@ -545,10 +545,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         self.elaborator.patch().new_block(result)\n     }\n \n-    /// create a loop that drops an array:\n-    ///\n-\n+    /// Create a loop that drops an array:\n     ///\n+    /// ```text\n     /// loop-block:\n     ///    can_go = cur == length_or_end\n     ///    if can_go then succ else drop-block\n@@ -561,15 +560,16 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///        cur = cur + 1\n     ///    }\n     ///    drop(ptr)\n-    fn drop_loop(&mut self,\n-                 succ: BasicBlock,\n-                 cur: Local,\n-                 length_or_end: &Place<'tcx>,\n-                 ety: Ty<'tcx>,\n-                 unwind: Unwind,\n-                 ptr_based: bool)\n-                 -> BasicBlock\n-    {\n+    /// ```\n+    fn drop_loop(\n+        &mut self,\n+        succ: BasicBlock,\n+        cur: Local,\n+        length_or_end: &Place<'tcx>,\n+        ety: Ty<'tcx>,\n+        unwind: Unwind,\n+        ptr_based: bool,\n+    ) -> BasicBlock {\n         let copy = |place: &Place<'tcx>| Operand::Copy(place.clone());\n         let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n         let tcx = self.tcx();\n@@ -591,13 +591,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     elem: ProjectionElem::Deref,\n                 }))\n              ),\n-             Rvalue::BinaryOp(BinOp::Offset, copy(&Place::Base(PlaceBase::Local(cur))), one))\n+             Rvalue::BinaryOp(BinOp::Offset, move_(&Place::Base(PlaceBase::Local(cur))), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.lifetimes.re_erased,\n                  BorrowKind::Mut { allow_two_phase_borrow: false },\n                  self.place.clone().index(cur)),\n-             Rvalue::BinaryOp(BinOp::Add, copy(&Place::Base(PlaceBase::Local(cur))), one))\n+             Rvalue::BinaryOp(BinOp::Add, move_(&Place::Base(PlaceBase::Local(cur))), one))\n         };\n \n         let drop_block = BasicBlockData {\n@@ -647,9 +647,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         // }\n \n         if let Some(size) = opt_size {\n-            assert!(size <= (u32::MAX as u64),\n-                    \"move out check doesn't implemented for array bigger then u32\");\n-            let size = size as u32;\n+            let size: u32 = size.try_into().unwrap_or_else(|_| {\n+                bug!(\"move out check isn't implemented for array sizes bigger than u32::MAX\");\n+            });\n             let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size).map(|i| {\n                 (self.place.clone().elem(ProjectionElem::ConstantIndex{\n                     offset: i,\n@@ -667,33 +667,42 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n         let tcx = self.tcx();\n-        let size = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n-        let size_is_zero = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.bool)));\n+        let elem_size = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n+        let len = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n+\n+        static USIZE_SWITCH_ZERO: &[u128] = &[0];\n+\n         let base_block = BasicBlockData {\n             statements: vec![\n-                self.assign(size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n-                self.assign(size_is_zero, Rvalue::BinaryOp(BinOp::Eq,\n-                                                           move_(size),\n-                                                           self.constant_usize(0)))\n+                self.assign(elem_size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n+                self.assign(len, Rvalue::Len(self.place.clone())),\n             ],\n             is_cleanup: self.unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n-                kind: TerminatorKind::if_(\n-                    tcx,\n-                    move_(size_is_zero),\n-                    self.drop_loop_pair(ety, false),\n-                    self.drop_loop_pair(ety, true)\n-                )\n+                kind: TerminatorKind::SwitchInt {\n+                    discr: move_(elem_size),\n+                    switch_ty: tcx.types.usize,\n+                    values: From::from(USIZE_SWITCH_ZERO),\n+                    targets: vec![\n+                        self.drop_loop_pair(ety, false, len.clone()),\n+                        self.drop_loop_pair(ety, true, len.clone()),\n+                    ],\n+                },\n             })\n         };\n         self.elaborator.patch().new_block(base_block)\n     }\n \n-    // create a pair of drop-loops of `place`, which drops its contents\n-    // even in the case of 1 panic. If `ptr_based`, create a pointer loop,\n-    // otherwise create an index loop.\n-    fn drop_loop_pair(&mut self, ety: Ty<'tcx>, ptr_based: bool) -> BasicBlock {\n+    /// Ceates a pair of drop-loops of `place`, which drops its contents, even\n+    /// in the case of 1 panic. If `ptr_based`, creates a pointer loop,\n+    /// otherwise create an index loop.\n+    fn drop_loop_pair(\n+        &mut self,\n+        ety: Ty<'tcx>,\n+        ptr_based: bool,\n+        length: Place<'tcx>,\n+    ) -> BasicBlock {\n         debug!(\"drop_loop_pair({:?}, {:?})\", ety, ptr_based);\n         let tcx = self.tcx();\n         let iter_ty = if ptr_based {\n@@ -703,7 +712,6 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         };\n \n         let cur = self.new_temp(iter_ty);\n-        let length = Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n         let length_or_end = if ptr_based {\n             // FIXME check if we want to make it return a `Place` directly\n             // if all use sites want a `Place::Base` anyway.\n@@ -722,41 +730,41 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                            ptr_based)\n         });\n \n-        let succ = self.succ; // FIXME(#43234)\n         let loop_block = self.drop_loop(\n-            succ,\n+            self.succ,\n             cur,\n             &length_or_end,\n             ety,\n             unwind,\n             ptr_based);\n \n         let cur = Place::Base(PlaceBase::Local(cur));\n-        let zero = self.constant_usize(0);\n-        let mut drop_block_stmts = vec![];\n-        drop_block_stmts.push(self.assign(&length, Rvalue::Len(self.place.clone())));\n-        if ptr_based {\n+        let drop_block_stmts = if ptr_based {\n             let tmp_ty = tcx.mk_mut_ptr(self.place_ty(self.place));\n             let tmp = Place::Base(PlaceBase::Local(self.new_temp(tmp_ty)));\n             // tmp = &mut P;\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n-            drop_block_stmts.push(self.assign(&tmp, Rvalue::Ref(\n-                tcx.lifetimes.re_erased,\n-                BorrowKind::Mut { allow_two_phase_borrow: false },\n-                self.place.clone()\n-            )));\n-            drop_block_stmts.push(self.assign(&cur, Rvalue::Cast(\n-                CastKind::Misc, Operand::Move(tmp), iter_ty\n-            )));\n-            drop_block_stmts.push(self.assign(&length_or_end,\n-                Rvalue::BinaryOp(BinOp::Offset,\n-                     Operand::Copy(cur), Operand::Move(length)\n-            )));\n+            vec![\n+                self.assign(&tmp, Rvalue::Ref(\n+                    tcx.lifetimes.re_erased,\n+                    BorrowKind::Mut { allow_two_phase_borrow: false },\n+                    self.place.clone()\n+                )),\n+                self.assign(\n+                    &cur,\n+                    Rvalue::Cast(CastKind::Misc, Operand::Move(tmp), iter_ty),\n+                ),\n+                self.assign(\n+                    &length_or_end,\n+                    Rvalue::BinaryOp(BinOp::Offset, Operand::Copy(cur), Operand::Move(length)\n+                )),\n+            ]\n         } else {\n-            // index = 0 (length already pushed)\n-            drop_block_stmts.push(self.assign(&cur, Rvalue::Use(zero)));\n-        }\n+            // cur = 0 (length already pushed)\n+            let zero = self.constant_usize(0);\n+            vec![self.assign(&cur, Rvalue::Use(zero))]\n+        };\n         let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n             statements: drop_block_stmts,\n             is_cleanup: unwind.is_cleanup(),\n@@ -768,7 +776,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         // FIXME(#34708): handle partially-dropped array/slice elements.\n         let reset_block = self.drop_flag_reset_block(DropFlagMode::Deep, drop_block, unwind);\n-        self.drop_flag_test_block(reset_block, succ, unwind)\n+        self.drop_flag_test_block(reset_block, self.succ, unwind)\n     }\n \n     /// The slow-path - create an \"open\", elaborated drop for a type"}, {"sha": "965f52be31cde4762c86f37794db7d817ba4d812", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -4168,9 +4168,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 oprnd_t = self.make_overloaded_place_return_type(method).ty;\n                                 self.write_method_call(expr.hir_id, method);\n                             } else {\n-                                type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n-                                                   \"type `{}` cannot be dereferenced\",\n-                                                   oprnd_t).emit();\n+                                let mut err = type_error_struct!(\n+                                    tcx.sess,\n+                                    expr.span,\n+                                    oprnd_t,\n+                                    E0614,\n+                                    \"type `{}` cannot be dereferenced\",\n+                                    oprnd_t,\n+                                );\n+                                let sp = tcx.sess.source_map().start_point(expr.span);\n+                                if let Some(sp) = tcx.sess.parse_sess.ambiguous_block_expr_parse\n+                                    .borrow().get(&sp)\n+                                {\n+                                    tcx.sess.parse_sess.expr_parentheses_needed(\n+                                        &mut err,\n+                                        *sp,\n+                                        None,\n+                                    );\n+                                }\n+                                err.emit();\n                                 oprnd_t = tcx.types.err;\n                             }\n                         }"}, {"sha": "a94176e71000567d21681ccbfee0d3c7a4b13b88", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -72,7 +72,7 @@ use core::convert::TryInto;\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Default)]\n pub struct Cursor<T> {\n     inner: T,\n     pos: u64,"}, {"sha": "03aebeda47c4851f707c2d2ffb39682e166c4dcf", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -357,29 +357,6 @@ macro_rules! dbg {\n     };\n }\n \n-/// Awaits the completion of an async call.\n-#[macro_export]\n-#[unstable(feature = \"await_macro\", issue = \"50547\")]\n-#[allow_internal_unstable(gen_future, generators)]\n-#[allow_internal_unsafe]\n-macro_rules! r#await {\n-    ($e:expr) => { {\n-        let mut pinned = $e;\n-        loop {\n-            if let $crate::task::Poll::Ready(x) =\n-                $crate::future::poll_with_tls_context(unsafe {\n-                    $crate::pin::Pin::new_unchecked(&mut pinned)\n-                })\n-            {\n-                break x;\n-            }\n-            // FIXME(cramertj) prior to stabilizing await, we have to ensure that this\n-            // can't be used to create a generator on stable via `|| await!()`.\n-            yield\n-        }\n-    } }\n-}\n-\n /// Selects the first successful receive event from a number of receivers.\n ///\n /// This macro is used to wait for the first event to occur on a number of"}, {"sha": "084a69f4cda0f97b6ec56ae08cbb6b82a348ff12", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -554,7 +554,10 @@ fn inner_parse_loop<'root, 'tt>(\n             match item.top_elts.get_tt(idx) {\n                 // Need to descend into a sequence\n                 TokenTree::Sequence(sp, seq) => {\n-                    // Examine the case where there are 0 matches of this sequence\n+                    // Examine the case where there are 0 matches of this sequence. We are\n+                    // implicitly disallowing OneOrMore from having 0 matches here. Thus, that will\n+                    // result in a \"no rules expected token\" error by virtue of this matcher not\n+                    // working.\n                     if seq.op == quoted::KleeneOp::ZeroOrMore\n                         || seq.op == quoted::KleeneOp::ZeroOrOne\n                     {"}, {"sha": "a53cc2fe66173ecdce8ce9f25c3eea713f31efc5", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -151,7 +151,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt<'_>,\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = transcribe(cx, Some(named_matches), rhs);\n+                let mut tts = transcribe(cx, &named_matches, rhs);\n \n                 // Replace all the tokens for the corresponding positions in the macro, to maintain\n                 // proper positions in error reporting, while maintaining the macro_backtrace."}, {"sha": "ed8395f11ad5089c3557ea964ff748e81c280631", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -73,6 +73,7 @@ pub enum KleeneOp {\n     ZeroOrMore,\n     /// Kleene plus (`+`) for one or more repetitions\n     OneOrMore,\n+    /// Kleene optional (`?`) for zero or one reptitions\n     ZeroOrOne,\n }\n "}, {"sha": "0cefcf1ce034b7603c690a43087a79d65fd49a21", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 188, "deletions": 67, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -1,10 +1,10 @@\n use crate::ast::Ident;\n use crate::ext::base::ExtCtxt;\n use crate::ext::expand::Marker;\n-use crate::ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n+use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n use crate::ext::tt::quoted;\n use crate::mut_visit::noop_visit_tt;\n-use crate::parse::token::{self, Token, NtTT};\n+use crate::parse::token::{self, NtTT, Token};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n use smallvec::{smallvec, SmallVec};\n@@ -13,24 +13,16 @@ use syntax_pos::DUMMY_SP;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n-use std::ops::Add;\n use std::rc::Rc;\n \n-// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n+/// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n-    Delimited {\n-        forest: Lrc<quoted::Delimited>,\n-        idx: usize,\n-        span: DelimSpan,\n-    },\n-    Sequence {\n-        forest: Lrc<quoted::SequenceRepetition>,\n-        idx: usize,\n-        sep: Option<Token>,\n-    },\n+    Delimited { forest: Lrc<quoted::Delimited>, idx: usize, span: DelimSpan },\n+    Sequence { forest: Lrc<quoted::SequenceRepetition>, idx: usize, sep: Option<Token> },\n }\n \n impl Frame {\n+    /// Construct a new frame around the delimited set of tokens.\n     fn new(tts: Vec<quoted::TokenTree>) -> Frame {\n         let forest = Lrc::new(quoted::Delimited { delim: token::NoDelim, tts: tts });\n         Frame::Delimited { forest: forest, idx: 0, span: DelimSpan::dummy() }\n@@ -54,84 +46,161 @@ impl Iterator for Frame {\n     }\n }\n \n-/// This can do Macro-By-Example transcription. On the other hand, if\n-/// `src` contains no `TokenTree::{Sequence, MetaVar, MetaVarDecl}`s, `interp` can\n-/// (and should) be None.\n-pub fn transcribe(cx: &ExtCtxt<'_>,\n-                  interp: Option<FxHashMap<Ident, Rc<NamedMatch>>>,\n-                  src: Vec<quoted::TokenTree>)\n-                  -> TokenStream {\n+/// This can do Macro-By-Example transcription.\n+/// - `interp` is a map of meta-variables to the tokens (non-terminals) they matched in the\n+///   invocation. We are assuming we already know there is a match.\n+/// - `src` is the RHS of the MBE, that is, the \"example\" we are filling in.\n+///\n+/// For example,\n+///\n+/// ```rust\n+/// macro_rules! foo {\n+///     ($id:ident) => { println!(\"{}\", stringify!($id)); }\n+/// }\n+///\n+/// foo!(bar);\n+/// ```\n+///\n+/// `interp` would contain `$id => bar` and `src` would contain `println!(\"{}\", stringify!($id));`.\n+///\n+/// `transcribe` would return a `TokenStream` containing `println!(\"{}\", stringify!(bar));`.\n+///\n+/// Along the way, we do some additional error checking.\n+pub fn transcribe(\n+    cx: &ExtCtxt<'_>,\n+    interp: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    src: Vec<quoted::TokenTree>,\n+) -> TokenStream {\n+    // Nothing for us to transcribe...\n+    if src.is_empty() {\n+        return TokenStream::empty();\n+    }\n+\n+    // We descend into the RHS (`src`), expanding things as we go. This stack contains the things\n+    // we have yet to expand/are still expanding. We start the stack off with the whole RHS.\n     let mut stack: SmallVec<[Frame; 1]> = smallvec![Frame::new(src)];\n-    let interpolations = interp.unwrap_or_else(FxHashMap::default); /* just a convenience */\n+\n+    // As we descend in the RHS, we will need to be able to match nested sequences of matchers.\n+    // `repeats` keeps track of where we are in matching at each level, with the last element being\n+    // the most deeply nested sequence. This is used as a stack.\n     let mut repeats = Vec::new();\n+\n+    // `result` contains resulting token stream from the TokenTree we just finished processing. At\n+    // the end, this will contain the full result of transcription, but at arbitrary points during\n+    // `transcribe`, `result` will contain subsets of the final result.\n+    //\n+    // Specifically, as we descend into each TokenTree, we will push the existing results onto the\n+    // `result_stack` and clear `results`. We will then produce the results of transcribing the\n+    // TokenTree into `results`. Then, as we unwind back out of the `TokenTree`, we will pop the\n+    // `result_stack` and append `results` too it to produce the new `results` up to that point.\n+    //\n+    // Thus, if we try to pop the `result_stack` and it is empty, we have reached the top-level\n+    // again, and we are done transcribing.\n     let mut result: Vec<TreeAndJoint> = Vec::new();\n     let mut result_stack = Vec::new();\n \n     loop {\n+        // Look at the last frame on the stack.\n         let tree = if let Some(tree) = stack.last_mut().unwrap().next() {\n+            // If it still has a TokenTree we have not looked at yet, use that tree.\n             tree\n-        } else {\n+        }\n+        // The else-case never produces a value for `tree` (it `continue`s or `return`s).\n+        else {\n+            // Otherwise, if we have just reached the end of a sequence and we can keep repeating,\n+            // go back to the beginning of the sequence.\n             if let Frame::Sequence { ref mut idx, ref sep, .. } = *stack.last_mut().unwrap() {\n                 let (ref mut repeat_idx, repeat_len) = *repeats.last_mut().unwrap();\n                 *repeat_idx += 1;\n                 if *repeat_idx < repeat_len {\n                     *idx = 0;\n                     if let Some(sep) = sep.clone() {\n-                        // repeat same span, I guess\n                         let prev_span = match result.last() {\n                             Some((tt, _)) => tt.span(),\n                             None => DUMMY_SP,\n                         };\n                         result.push(TokenTree::Token(prev_span, sep).into());\n                     }\n-                    continue\n+                    continue;\n                 }\n             }\n \n+            // We are done with the top of the stack. Pop it. Depending on what it was, we do\n+            // different things. Note that the outermost item must be the delimited, wrapped RHS\n+            // that was passed in originally to `transcribe`.\n             match stack.pop().unwrap() {\n+                // Done with a sequence. Pop from repeats.\n                 Frame::Sequence { .. } => {\n                     repeats.pop();\n                 }\n+\n+                // We are done processing a Delimited. If this is the top-level delimited, we are\n+                // done. Otherwise, we unwind the result_stack to append what we have produced to\n+                // any previous results.\n                 Frame::Delimited { forest, span, .. } => {\n                     if result_stack.is_empty() {\n+                        // No results left to compute! We are back at the top-level.\n                         return TokenStream::new(result);\n                     }\n-                    let tree = TokenTree::Delimited(\n-                        span,\n-                        forest.delim,\n-                        TokenStream::new(result).into(),\n-                    );\n+\n+                    // Step back into the parent Delimited.\n+                    let tree =\n+                        TokenTree::Delimited(span, forest.delim, TokenStream::new(result).into());\n                     result = result_stack.pop().unwrap();\n                     result.push(tree.into());\n                 }\n             }\n-            continue\n+            continue;\n         };\n \n+        // At this point, we know we are in the middle of a TokenTree (the last one on `stack`).\n+        // `tree` contains the next `TokenTree` to be processed.\n         match tree {\n-            quoted::TokenTree::Sequence(sp, seq) => {\n-                // FIXME(pcwalton): Bad copy.\n-                match lockstep_iter_size(&quoted::TokenTree::Sequence(sp, seq.clone()),\n-                                         &interpolations,\n-                                         &repeats) {\n+            // We are descending into a sequence. We first make sure that the matchers in the RHS\n+            // and the matches in `interp` have the same shape. Otherwise, either the caller or the\n+            // macro writer has made a mistake.\n+            seq @ quoted::TokenTree::Sequence(..) => {\n+                match lockstep_iter_size(&seq, interp, &repeats) {\n                     LockstepIterSize::Unconstrained => {\n-                        cx.span_fatal(sp.entire(), /* blame macro writer */\n-                            \"attempted to repeat an expression \\\n-                             containing no syntax \\\n-                             variables matched as repeating at this depth\");\n+                        cx.span_fatal(\n+                            seq.span(), /* blame macro writer */\n+                            \"attempted to repeat an expression containing no syntax variables \\\n+                             matched as repeating at this depth\",\n+                        );\n                     }\n+\n                     LockstepIterSize::Contradiction(ref msg) => {\n+                        // FIXME: this should be impossible. I (mark-i-m) believe it would\n+                        // represent a bug in the macro_parser.\n                         // FIXME #2887 blame macro invoker instead\n-                        cx.span_fatal(sp.entire(), &msg[..]);\n+                        cx.span_fatal(seq.span(), &msg[..]);\n                     }\n+\n                     LockstepIterSize::Constraint(len, _) => {\n+                        // We do this to avoid an extra clone above. We know that this is a\n+                        // sequence already.\n+                        let (sp, seq) = if let quoted::TokenTree::Sequence(sp, seq) = seq {\n+                            (sp, seq)\n+                        } else {\n+                            unreachable!()\n+                        };\n+\n+                        // Is the repetition empty?\n                         if len == 0 {\n                             if seq.op == quoted::KleeneOp::OneOrMore {\n+                                // FIXME: this should be impossible because we check for this in\n+                                // macro_parser.rs\n                                 // FIXME #2887 blame invoker\n                                 cx.span_fatal(sp.entire(), \"this must repeat at least once\");\n                             }\n                         } else {\n+                            // 0 is the initial counter (we have done 0 repretitions so far). `len`\n+                            //   is the total number of reptitions we should generate.\n                             repeats.push((0, len));\n+\n+                            // The first time we encounter the sequence we push it to the stack. It\n+                            // then gets reused (see the beginning of the loop) until we are done\n+                            // repeating.\n                             stack.push(Frame::Sequence {\n                                 idx: 0,\n                                 sep: seq.separator.clone(),\n@@ -141,10 +210,16 @@ pub fn transcribe(cx: &ExtCtxt<'_>,\n                     }\n                 }\n             }\n-            // FIXME #2887: think about span stuff here\n+\n+            // Replace the meta-var with the matched token tree from the invocation.\n             quoted::TokenTree::MetaVar(mut sp, ident) => {\n-                if let Some(cur_matched) = lookup_cur_matched(ident, &interpolations, &repeats) {\n+                // Find the matched nonterminal from the macro invocation, and use it to replace\n+                // the meta-var.\n+                if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n                     if let MatchedNonterminal(ref nt) = *cur_matched {\n+                        // FIXME #2887: why do we apply a mark when matching a token tree meta-var\n+                        // (e.g. `$x:tt`), but not when we are matching any other type of token\n+                        // tree?\n                         if let NtTT(ref tt) = **nt {\n                             result.push(tt.clone().into());\n                         } else {\n@@ -153,37 +228,60 @@ pub fn transcribe(cx: &ExtCtxt<'_>,\n                             result.push(token.into());\n                         }\n                     } else {\n-                        cx.span_fatal(sp, /* blame the macro writer */\n-                            &format!(\"variable '{}' is still repeating at this depth\", ident));\n+                        // We were unable to descend far enough. This is an error.\n+                        cx.span_fatal(\n+                            sp, /* blame the macro writer */\n+                            &format!(\"variable '{}' is still repeating at this depth\", ident),\n+                        );\n                     }\n                 } else {\n+                    // If we aren't able to match the meta-var, we push it back into the result but\n+                    // with modified syntax context. (I believe this supports nested macros).\n                     let ident =\n                         Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.mark));\n                     sp = sp.apply_mark(cx.current_expansion.mark);\n                     result.push(TokenTree::Token(sp, token::Dollar).into());\n                     result.push(TokenTree::Token(sp, token::Token::from_ast_ident(ident)).into());\n                 }\n             }\n+\n+            // If we are entering a new delimiter, we push its contents to the `stack` to be\n+            // processed, and we push all of the currently produced results to the `result_stack`.\n+            // We will produce all of the results of the inside of the `Delimited` and then we will\n+            // jump back out of the Delimited, pop the result_stack and add the new results back to\n+            // the previous results (from outside the Delimited).\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n                 span = span.apply_mark(cx.current_expansion.mark);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span: span });\n                 result_stack.push(mem::replace(&mut result, Vec::new()));\n             }\n+\n+            // Nothing much to do here. Just push the token to the result, being careful to\n+            // preserve syntax context.\n             quoted::TokenTree::Token(sp, tok) => {\n                 let mut marker = Marker(cx.current_expansion.mark);\n                 let mut tt = TokenTree::Token(sp, tok);\n                 noop_visit_tt(&mut tt, &mut marker);\n                 result.push(tt.into());\n             }\n+\n+            // There should be no meta-var declarations in the invocation of a macro.\n             quoted::TokenTree::MetaVarDecl(..) => panic!(\"unexpected `TokenTree::MetaVarDecl\"),\n         }\n     }\n }\n \n-fn lookup_cur_matched(ident: Ident,\n-                      interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n-                      repeats: &[(usize, usize)])\n-                      -> Option<Rc<NamedMatch>> {\n+/// Lookup the meta-var named `ident` and return the matched token tree from the invocation using\n+/// the set of matches `interpolations`.\n+///\n+/// See the definition of `repeats` in the `transcribe` function. `repeats` is used to descend\n+/// into the right place in nested matchers. If we attempt to descend too far, the macro writer has\n+/// made a mistake, and we return `None`.\n+fn lookup_cur_matched(\n+    ident: Ident,\n+    interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    repeats: &[(usize, usize)],\n+) -> Option<Rc<NamedMatch>> {\n     interpolations.get(&ident).map(|matched| {\n         let mut matched = matched.clone();\n         for &(idx, _) in repeats {\n@@ -198,17 +296,30 @@ fn lookup_cur_matched(ident: Ident,\n     })\n }\n \n+/// An accumulator over a TokenTree to be used with `fold`. During transcription, we need to make\n+/// sure that the size of each sequence and all of its nested sequences are the same as the sizes\n+/// of all the matched (nested) sequences in the macro invocation. If they don't match, somebody\n+/// has made a mistake (either the macro writer or caller).\n #[derive(Clone)]\n enum LockstepIterSize {\n+    /// No constraints on length of matcher. This is true for any TokenTree variants except a\n+    /// `MetaVar` with an actual `MatchedSeq` (as opposed to a `MatchedNonterminal`).\n     Unconstrained,\n+\n+    /// A `MetaVar` with an actual `MatchedSeq`. The length of the match and the name of the\n+    /// meta-var are returned.\n     Constraint(usize, Ident),\n+\n+    /// Two `Constraint`s on the same sequence had different lengths. This is an error.\n     Contradiction(String),\n }\n \n-impl Add for LockstepIterSize {\n-    type Output = LockstepIterSize;\n-\n-    fn add(self, other: LockstepIterSize) -> LockstepIterSize {\n+impl LockstepIterSize {\n+    /// Find incompatibilities in matcher/invocation sizes.\n+    /// - `Unconstrained` is compatible with everything.\n+    /// - `Contradiction` is incompatible with everything.\n+    /// - `Constraint(len)` is only compatible with other constraints of the same length.\n+    fn with(self, other: LockstepIterSize) -> LockstepIterSize {\n         match self {\n             LockstepIterSize::Unconstrained => other,\n             LockstepIterSize::Contradiction(_) => self,\n@@ -217,40 +328,50 @@ impl Add for LockstepIterSize {\n                 LockstepIterSize::Contradiction(_) => other,\n                 LockstepIterSize::Constraint(r_len, _) if l_len == r_len => self,\n                 LockstepIterSize::Constraint(r_len, r_id) => {\n-                    let msg = format!(\"inconsistent lockstep iteration: \\\n-                                       '{}' has {} items, but '{}' has {}\",\n-                                      l_id, l_len, r_id, r_len);\n+                    let msg = format!(\n+                        \"inconsistent lockstep iteration: \\\n+                         '{}' has {} items, but '{}' has {}\",\n+                        l_id, l_len, r_id, r_len\n+                    );\n                     LockstepIterSize::Contradiction(msg)\n                 }\n             },\n         }\n     }\n }\n \n-fn lockstep_iter_size(tree: &quoted::TokenTree,\n-                      interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n-                      repeats: &[(usize, usize)])\n-                      -> LockstepIterSize {\n+/// Given a `tree`, make sure that all sequences have the same length as the matches for the\n+/// appropriate meta-vars in `interpolations`.\n+///\n+/// Note that if `repeats` does not match the exact correct depth of a meta-var,\n+/// `lookup_cur_matched` will return `None`, which is why this still works even in the presnece of\n+/// multiple nested matcher sequences.\n+fn lockstep_iter_size(\n+    tree: &quoted::TokenTree,\n+    interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    repeats: &[(usize, usize)],\n+) -> LockstepIterSize {\n     use quoted::TokenTree;\n     match *tree {\n         TokenTree::Delimited(_, ref delimed) => {\n             delimed.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n-                size + lockstep_iter_size(tt, interpolations, repeats)\n+                size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n-        },\n+        }\n         TokenTree::Sequence(_, ref seq) => {\n             seq.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n-                size + lockstep_iter_size(tt, interpolations, repeats)\n+                size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n-        },\n-        TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) =>\n+        }\n+        TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {\n             match lookup_cur_matched(name, interpolations, repeats) {\n                 Some(matched) => match *matched {\n                     MatchedNonterminal(_) => LockstepIterSize::Unconstrained,\n                     MatchedSeq(ref ads, _) => LockstepIterSize::Constraint(ads.len(), name),\n                 },\n-                _ => LockstepIterSize::Unconstrained\n-            },\n+                _ => LockstepIterSize::Unconstrained,\n+            }\n+        }\n         TokenTree::Token(..) => LockstepIterSize::Unconstrained,\n     }\n }"}, {"sha": "2882acb0e780c9fffffe6409adcaa79286535a96", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -1598,7 +1598,7 @@ mod tests {\n     use std::io;\n     use std::path::PathBuf;\n     use syntax_pos::{BytePos, Span, NO_EXPANSION};\n-    use rustc_data_structures::fx::FxHashSet;\n+    use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n     use rustc_data_structures::sync::Lock;\n \n     fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n@@ -1617,6 +1617,7 @@ mod tests {\n             raw_identifier_spans: Lock::new(Vec::new()),\n             registered_diagnostics: Lock::new(ErrorMap::new()),\n             buffered_lints: Lock::new(vec![]),\n+            ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n         }\n     }\n "}, {"sha": "be44b964ba5a7f1819236766cd66eab2af4895ce", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -11,12 +11,12 @@ use crate::tokenstream::{TokenStream, TokenTree};\n use crate::diagnostics::plugin::ErrorMap;\n use crate::print::pprust::token_to_string;\n \n-use errors::{FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n+use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::{Lrc, Lock};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use log::debug;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use std::borrow::Cow;\n use std::path::{Path, PathBuf};\n use std::str;\n@@ -52,6 +52,10 @@ pub struct ParseSess {\n     included_mod_stack: Lock<Vec<PathBuf>>,\n     source_map: Lrc<SourceMap>,\n     pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n+    /// Contains the spans of block expressions that could have been incomplete based on the\n+    /// operation token that followed it, but that the parser cannot identify without further\n+    /// analysis.\n+    pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n }\n \n impl ParseSess {\n@@ -75,6 +79,7 @@ impl ParseSess {\n             included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n+            ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n         }\n     }\n \n@@ -98,6 +103,24 @@ impl ParseSess {\n             });\n         });\n     }\n+\n+    /// Extend an error with a suggestion to wrap an expression with parentheses to allow the\n+    /// parser to continue parsing the following operation as part of the same expression.\n+    pub fn expr_parentheses_needed(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        span: Span,\n+        alt_snippet: Option<String>,\n+    ) {\n+        if let Some(snippet) = self.source_map().span_to_snippet(span).ok().or(alt_snippet) {\n+            err.span_suggestion(\n+                span,\n+                \"parentheses are required to parse this as an expression\",\n+                format!(\"({})\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n }\n \n #[derive(Clone)]"}, {"sha": "d97d1e2f0f4eec67407b05b72b662bd39dd8e6c8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 66, "deletions": 14, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -50,7 +50,10 @@ use crate::symbol::{Symbol, keywords};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n-use syntax_pos::{Span, MultiSpan, BytePos, FileName};\n+use syntax_pos::{\n+    Span, MultiSpan, BytePos, FileName,\n+    hygiene::CompilerDesugaringKind,\n+};\n use log::{debug, trace};\n \n use std::borrow::Cow;\n@@ -186,6 +189,7 @@ enum PrevTokenKind {\n     Interpolated,\n     Eof,\n     Ident,\n+    BitOr,\n     Other,\n }\n \n@@ -1375,6 +1379,7 @@ impl<'a> Parser<'a> {\n             token::DocComment(..) => PrevTokenKind::DocComment,\n             token::Comma => PrevTokenKind::Comma,\n             token::BinOp(token::Plus) => PrevTokenKind::Plus,\n+            token::BinOp(token::Or) => PrevTokenKind::BitOr,\n             token::Interpolated(..) => PrevTokenKind::Interpolated,\n             token::Eof => PrevTokenKind::Eof,\n             token::Ident(..) => PrevTokenKind::Ident,\n@@ -2806,6 +2811,12 @@ impl<'a> Parser<'a> {\n                             let msg = format!(\"expected expression, found {}\",\n                                               self.this_token_descr());\n                             let mut err = self.fatal(&msg);\n+                            let sp = self.sess.source_map().start_point(self.span);\n+                            if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow()\n+                                .get(&sp)\n+                            {\n+                                self.sess.expr_parentheses_needed(&mut err, *sp, None);\n+                            }\n                             err.span_label(self.span, \"expected expression\");\n                             return Err(err);\n                         }\n@@ -2845,7 +2856,7 @@ impl<'a> Parser<'a> {\n                     \"struct literals are not allowed here\",\n                 );\n                 err.multipart_suggestion(\n-                    \"surround the struct literal with parenthesis\",\n+                    \"surround the struct literal with parentheses\",\n                     vec![\n                         (lo.shrink_to_lo(), \"(\".to_string()),\n                         (expr.span.shrink_to_hi(), \")\".to_string()),\n@@ -3506,9 +3517,42 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        if self.expr_is_complete(&lhs) {\n-            // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n-            return Ok(lhs);\n+        match (self.expr_is_complete(&lhs), AssocOp::from_token(&self.token)) {\n+            (true, None) => {\n+                // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n+                return Ok(lhs);\n+            }\n+            (false, _) => {} // continue parsing the expression\n+            // An exhaustive check is done in the following block, but these are checked first\n+            // because they *are* ambiguous but also reasonable looking incorrect syntax, so we\n+            // want to keep their span info to improve diagnostics in these cases in a later stage.\n+            (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n+            (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n+            (true, Some(AssocOp::Add)) => { // `{ 42 } + 42\n+                // These cases are ambiguous and can't be identified in the parser alone\n+                let sp = self.sess.source_map().start_point(self.span);\n+                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n+                return Ok(lhs);\n+            }\n+            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => {\n+                return Ok(lhs);\n+            }\n+            (true, Some(_)) => {\n+                // We've found an expression that would be parsed as a statement, but the next\n+                // token implies this should be parsed as an expression.\n+                // For example: `if let Some(x) = x { x } else { 0 } / 2`\n+                let mut err = self.sess.span_diagnostic.struct_span_err(self.span, &format!(\n+                    \"expected expression, found `{}`\",\n+                    pprust::token_to_string(&self.token),\n+                ));\n+                err.span_label(self.span, \"expected expression\");\n+                self.sess.expr_parentheses_needed(\n+                    &mut err,\n+                    lhs.span,\n+                    Some(pprust::expr_to_string(&lhs),\n+                ));\n+                err.emit();\n+            }\n         }\n         self.expected_tokens.push(TokenType::Operator);\n         while let Some(op) = AssocOp::from_token(&self.token) {\n@@ -4819,6 +4863,10 @@ impl<'a> Parser<'a> {\n                         );\n                         let mut err = self.fatal(&msg);\n                         err.span_label(self.span, format!(\"expected {}\", expected));\n+                        let sp = self.sess.source_map().start_point(self.span);\n+                        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+                            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n+                        }\n                         return Err(err);\n                     }\n                 }\n@@ -8727,6 +8775,10 @@ impl<'a> Parser<'a> {\n     /// The arguments of the function are replaced in HIR lowering with the arguments created by\n     /// this function and the statements created here are inserted at the top of the closure body.\n     fn construct_async_arguments(&mut self, asyncness: &mut Spanned<IsAsync>, decl: &mut FnDecl) {\n+        // FIXME(davidtwco): This function should really live in the HIR lowering but because\n+        // the types constructed here need to be used in parts of resolve so that the correct\n+        // locals are considered upvars, it is currently easier for it to live here in the parser,\n+        // where it can be constructed once.\n         if let IsAsync::Async { ref mut arguments, .. } = asyncness.node {\n             for (index, input) in decl.inputs.iter_mut().enumerate() {\n                 let id = ast::DUMMY_NODE_ID;\n@@ -8741,6 +8793,15 @@ impl<'a> Parser<'a> {\n                 // statement.\n                 let (binding_mode, ident, is_simple_pattern) = match input.pat.node {\n                     PatKind::Ident(binding_mode @ BindingMode::ByValue(_), ident, _) => {\n+                        // Simple patterns like this don't have a generated argument, but they are\n+                        // moved into the closure with a statement, so any `mut` bindings on the\n+                        // argument will be unused. This binding mode can't be removed, because\n+                        // this would affect the input to procedural macros, but they can have\n+                        // their span marked as being the result of a compiler desugaring so\n+                        // that they aren't linted against.\n+                        input.pat.span = self.sess.source_map().mark_span_with_reason(\n+                            CompilerDesugaringKind::Async, span, None);\n+\n                         (binding_mode, ident, true)\n                     }\n                     _ => (BindingMode::ByValue(Mutability::Mutable), ident, false),\n@@ -8810,15 +8871,6 @@ impl<'a> Parser<'a> {\n                     })\n                 };\n \n-                // Remove mutability from arguments. If this is not a simple pattern,\n-                // those arguments are replaced by `__argN`, so there is no need to do this.\n-                if let PatKind::Ident(BindingMode::ByValue(mutability @ Mutability::Mutable), ..) =\n-                    &mut input.pat.node\n-                {\n-                    assert!(is_simple_pattern);\n-                    *mutability = Mutability::Immutable;\n-                }\n-\n                 let move_stmt = Stmt { id, node: StmtKind::Local(P(move_local)), span };\n                 arguments.push(AsyncArgument { ident, arg, pat_stmt, move_stmt });\n             }"}, {"sha": "215618bd09ca375538e98701de332977dad45e3d", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -930,6 +930,27 @@ impl SourceMap {\n \n         None\n     }\n+\n+    /// Reuses the span but adds information like the kind of the desugaring and features that are\n+    /// allowed inside this span.\n+    pub fn mark_span_with_reason(\n+        &self,\n+        reason: hygiene::CompilerDesugaringKind,\n+        span: Span,\n+        allow_internal_unstable: Option<Lrc<[symbol::Symbol]>>,\n+    ) -> Span {\n+        let mark = Mark::fresh(Mark::root());\n+        mark.set_expn_info(ExpnInfo {\n+            call_site: span,\n+            def_site: Some(span),\n+            format: CompilerDesugaring(reason),\n+            allow_internal_unstable,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            edition: hygiene::default_edition(),\n+        });\n+        span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n+    }\n }\n \n impl SourceMapper for SourceMap {"}, {"sha": "86e89945afe068cad1b4fef80a6a6f74e0a64871", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -207,6 +207,31 @@ impl AssocOp {\n             ObsoleteInPlace | Assign | AssignOp(_) | As | DotDot | DotDotEq | Colon => None\n         }\n     }\n+\n+    /// This operator could be used to follow a block unambiguously.\n+    ///\n+    /// This is used for error recovery at the moment, providing a suggestion to wrap blocks with\n+    /// parentheses while having a high degree of confidence on the correctness of the suggestion.\n+    pub fn can_continue_expr_unambiguously(&self) -> bool {\n+        use AssocOp::*;\n+        match self {\n+            BitXor | // `{ 42 } ^ 3`\n+            Assign | // `{ 42 } = { 42 }`\n+            Divide | // `{ 42 } / 42`\n+            Modulus | // `{ 42 } % 2`\n+            ShiftRight | // `{ 42 } >> 2`\n+            LessEqual | // `{ 42 } <= 3`\n+            Greater | // `{ 42 } > 3`\n+            GreaterEqual | // `{ 42 } >= 3`\n+            AssignOp(_) | // `{ 42 } +=`\n+            LAnd | // `{ 42 } &&foo`\n+            As | // `{ 42 } as usize`\n+            // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n+            // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery.\n+            Colon => true, // `{ 42 }: usize`\n+            _ => false,\n+        }\n+    }\n }\n \n pub const PREC_RESET: i8 = -100;"}, {"sha": "754fad51b21e78faf35ffbdb57e6326efad9e46f", "filename": "src/test/mir-opt/slice-drop-shim.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -0,0 +1,88 @@\n+fn main() {\n+    std::ptr::drop_in_place::<[String]> as unsafe fn(_);\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.ptr-real_drop_in_place.[std__string__String].AddMovesForPackedDrops.before.mir\n+// let mut _2: usize;\n+// let mut _3: usize;\n+// let mut _4: usize;\n+// let mut _5: &mut std::string::String;\n+// let mut _6: bool;\n+// let mut _7: &mut std::string::String;\n+// let mut _8: bool;\n+// let mut _9: *mut std::string::String;\n+// let mut _10: *mut std::string::String;\n+// let mut _11: &mut std::string::String;\n+// let mut _12: bool;\n+// let mut _13: &mut std::string::String;\n+// let mut _14: bool;\n+// let mut _15: *mut [std::string::String];\n+// bb0: {\n+//     goto -> bb15;\n+// }\n+// bb1: {\n+//     return;\n+// }\n+// bb2 (cleanup): {\n+//     resume;\n+// }\n+// bb3 (cleanup): {\n+//     _5 = &mut (*_1)[_4];\n+//     _4 = Add(move _4, const 1usize);\n+//     drop((*_5)) -> bb4;\n+// }\n+// bb4 (cleanup): {\n+//     _6 = Eq(_4, _3);\n+//     switchInt(move _6) -> [false: bb3, otherwise: bb2];\n+// }\n+// bb5: {\n+//     _7 = &mut (*_1)[_4];\n+//     _4 = Add(move _4, const 1usize);\n+//     drop((*_7)) -> [return: bb6, unwind: bb4];\n+// }\n+// bb6: {\n+//     _8 = Eq(_4, _3);\n+//     switchInt(move _8) -> [false: bb5, otherwise: bb1];\n+// }\n+// bb7: {\n+//     _4 = const 0usize;\n+//     goto -> bb6;\n+// }\n+// bb8: {\n+//     goto -> bb7;\n+// }\n+// bb9 (cleanup): {\n+//     _11 = &mut (*_9);\n+//     _9 = Offset(move _9, const 1usize);\n+//     drop((*_11)) -> bb10;\n+// }\n+// bb10 (cleanup): {\n+//     _12 = Eq(_9, _10);\n+//     switchInt(move _12) -> [false: bb9, otherwise: bb2];\n+// }\n+// bb11: {\n+//     _13 = &mut (*_9);\n+//     _9 = Offset(move _9, const 1usize);\n+//     drop((*_13)) -> [return: bb12, unwind: bb10];\n+// }\n+// bb12: {\n+//     _14 = Eq(_9, _10);\n+//     switchInt(move _14) -> [false: bb11, otherwise: bb1];\n+// }\n+// bb13: {\n+//     _15 = &mut (*_1);\n+//     _9 = move _15 as *mut std::string::String (Misc);\n+//     _10 = Offset(_9, move _3);\n+//     goto -> bb12;\n+// }\n+// bb14: {\n+//     goto -> bb13;\n+// }\n+// bb15: {\n+//     _2 = SizeOf(std::string::String);\n+//     _3 = Len((*_1));\n+//     switchInt(move _2) -> [0usize: bb8, otherwise: bb14];\n+// }\n+// END rustc.ptr-real_drop_in_place.[std__string__String].AddMovesForPackedDrops.before.mir"}, {"sha": "680c6e55e5668decc40438ef77b98e1cedec4ecd", "filename": "src/test/ui/async-await/auxiliary/issue-60674.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fasync-await%2Fauxiliary%2Fissue-60674.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fasync-await%2Fauxiliary%2Fissue-60674.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fauxiliary%2Fissue-60674.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -0,0 +1,12 @@\n+// force-host\n+// no-prefer-dynamic\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn attr(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    println!(\"{}\", input);\n+    TokenStream::new()\n+}"}, {"sha": "37e356e5baf483a45d538e0fbe6abd5eddade587", "filename": "src/test/ui/async-await/issue-60674.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -0,0 +1,14 @@\n+// aux-build:issue-60674.rs\n+// compile-pass\n+// edition:2018\n+#![feature(async_await)]\n+\n+// This is a regression test that ensures that `mut` patterns are not lost when provided as input\n+// to a proc macro.\n+\n+extern crate issue_60674;\n+\n+#[issue_60674::attr]\n+async fn f(mut x: u8) {}\n+\n+fn main() {}"}, {"sha": "a93944db1c5916e81dfc8d4494bcf2ead9648eab", "filename": "src/test/ui/async-await/issue-60674.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.stdout?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -0,0 +1 @@\n+async fn f(mut x: u8) { }"}, {"sha": "ec240003f91822e6eaa23e120aa98e854bf1800f", "filename": "src/test/ui/error-codes/E0423.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -3,7 +3,7 @@ error: struct literals are not allowed here\n    |\n LL |     if let S { x: _x, y: 2 } = S { x: 1, y: 2 } { println!(\"Ok\"); }\n    |                                ^^^^^^^^^^^^^^^^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     if let S { x: _x, y: 2 } = (S { x: 1, y: 2 }) { println!(\"Ok\"); }\n    |                                ^                ^\n@@ -19,7 +19,7 @@ error: struct literals are not allowed here\n    |\n LL |     for _ in std::ops::Range { start: 0, end: 10 } {}\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     for _ in (std::ops::Range { start: 0, end: 10 }) {}\n    |              ^                                     ^"}, {"sha": "5a008ad26b44461e47994e40357f48df53b35e2b", "filename": "src/test/ui/nll/closure-requirements/region-lbr1-does-outlive-lbr2-because-implied-bound.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-outlive-lbr2-because-implied-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-outlive-lbr2-because-implied-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-outlive-lbr2-because-implied-bound.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -3,8 +3,7 @@\n \n // compile-flags:-Zborrowck=mir -Zverbose\n // compile-pass\n-\n-#![allow(warnings)]\n+// skip-codegen\n \n fn foo<'a, 'b>(x: &'a &'b u32) -> &'a u32 {\n     &**x"}, {"sha": "1ce6f9c25034f811a881b80033d0156aba8cc0fa", "filename": "src/test/ui/parser/expr-as-stmt.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.fixed?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![allow(unused_must_use)]\n+\n+fn foo() -> i32 {\n+    ({2}) + {2} //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+}\n+\n+fn bar() -> i32 {\n+    ({2}) + 2 //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+}\n+\n+fn zul() -> u32 {\n+    let foo = 3;\n+    ({ 42 }) + foo; //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+    32\n+}\n+\n+fn baz() -> i32 {\n+    ({ 3 }) * 3 //~ ERROR type `{integer}` cannot be dereferenced\n+    //~^ ERROR mismatched types\n+}\n+\n+fn qux(a: Option<u32>, b: Option<u32>) -> bool {\n+    (if let Some(x) = a { true } else { false })\n+    && //~ ERROR expected expression\n+    if let Some(y) = a { true } else { false }\n+}\n+\n+fn moo(x: u32) -> bool {\n+    (match x {\n+        _ => 1,\n+    }) > 0 //~ ERROR expected expression\n+}\n+\n+fn main() {}"}, {"sha": "b526c17488eaf72ee218a67bbda59cf5e50d9303", "filename": "src/test/ui/parser/expr-as-stmt.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![allow(unused_must_use)]\n+\n+fn foo() -> i32 {\n+    {2} + {2} //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+}\n+\n+fn bar() -> i32 {\n+    {2} + 2 //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+}\n+\n+fn zul() -> u32 {\n+    let foo = 3;\n+    { 42 } + foo; //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+    32\n+}\n+\n+fn baz() -> i32 {\n+    { 3 } * 3 //~ ERROR type `{integer}` cannot be dereferenced\n+    //~^ ERROR mismatched types\n+}\n+\n+fn qux(a: Option<u32>, b: Option<u32>) -> bool {\n+    if let Some(x) = a { true } else { false }\n+    && //~ ERROR expected expression\n+    if let Some(y) = a { true } else { false }\n+}\n+\n+fn moo(x: u32) -> bool {\n+    match x {\n+        _ => 1,\n+    } > 0 //~ ERROR expected expression\n+}\n+\n+fn main() {}"}, {"sha": "a11209998a7d50b0e7ffdc2653df794f0ea175da", "filename": "src/test/ui/parser/expr-as-stmt.stderr", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -0,0 +1,92 @@\n+error: expected expression, found `+`\n+  --> $DIR/expr-as-stmt.rs:7:9\n+   |\n+LL |     {2} + {2}\n+   |     --- ^ expected expression\n+   |     |\n+   |     help: parentheses are required to parse this as an expression: `({2})`\n+\n+error: expected expression, found `+`\n+  --> $DIR/expr-as-stmt.rs:12:9\n+   |\n+LL |     {2} + 2\n+   |     --- ^ expected expression\n+   |     |\n+   |     help: parentheses are required to parse this as an expression: `({2})`\n+\n+error: expected expression, found `+`\n+  --> $DIR/expr-as-stmt.rs:18:12\n+   |\n+LL |     { 42 } + foo;\n+   |     ------ ^ expected expression\n+   |     |\n+   |     help: parentheses are required to parse this as an expression: `({ 42 })`\n+\n+error: expected expression, found `&&`\n+  --> $DIR/expr-as-stmt.rs:30:5\n+   |\n+LL |     if let Some(x) = a { true } else { false }\n+   |     ------------------------------------------ help: parentheses are required to parse this as an expression: `(if let Some(x) = a { true } else { false })`\n+LL |     &&\n+   |     ^^ expected expression\n+\n+error: expected expression, found `>`\n+  --> $DIR/expr-as-stmt.rs:37:7\n+   |\n+LL |     } > 0\n+   |       ^ expected expression\n+help: parentheses are required to parse this as an expression\n+   |\n+LL |     (match x {\n+LL |         _ => 1,\n+LL |     }) > 0\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/expr-as-stmt.rs:7:6\n+   |\n+LL |     {2} + {2}\n+   |      ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/expr-as-stmt.rs:12:6\n+   |\n+LL |     {2} + 2\n+   |      ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/expr-as-stmt.rs:18:7\n+   |\n+LL |     { 42 } + foo;\n+   |       ^^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/expr-as-stmt.rs:24:7\n+   |\n+LL |     { 3 } * 3\n+   |       ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error[E0614]: type `{integer}` cannot be dereferenced\n+  --> $DIR/expr-as-stmt.rs:24:11\n+   |\n+LL |     { 3 } * 3\n+   |     ----- ^^^\n+   |     |\n+   |     help: parentheses are required to parse this as an expression: `({ 3 })`\n+\n+error: aborting due to 10 previous errors\n+\n+Some errors have detailed explanations: E0308, E0614.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "56c917c7462f2e2d838edd6c73639bdf893a9fad", "filename": "src/test/ui/parser/match-arrows-block-then-binop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fmatch-arrows-block-then-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fmatch-arrows-block-then-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmatch-arrows-block-then-binop.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n-\n-    match 0 {\n+    let _ = match 0 {\n       0 => {\n+        0\n       } + 5 //~ ERROR expected pattern, found `+`\n-    }\n+    };\n }"}, {"sha": "bb7df30783acd40945491941e974d3bbb1be50b5", "filename": "src/test/ui/parser/match-arrows-block-then-binop.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fmatch-arrows-block-then-binop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fmatch-arrows-block-then-binop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmatch-arrows-block-then-binop.stderr?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -3,6 +3,12 @@ error: expected pattern, found `+`\n    |\n LL |       } + 5\n    |         ^ expected pattern\n+help: parentheses are required to parse this as an expression\n+   |\n+LL |       0 => ({\n+LL |         0\n+LL |       }) + 5\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "29af72a5d23d0ae06c8f2a5a1874dea3db4383b9", "filename": "src/test/ui/parser/struct-literal-in-for.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -6,7 +6,7 @@ LL |       for x in Foo {\n LL | |         x: 3\n LL | |     }.hi() {\n    | |_____^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     for x in (Foo {\n LL |         x: 3"}, {"sha": "e76c1cb45dd4e0e8bdf03ad5c74d27e6df032a5e", "filename": "src/test/ui/parser/struct-literal-in-if.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.stderr?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -6,7 +6,7 @@ LL |       if Foo {\n LL | |         x: 3\n LL | |     }.hi() {\n    | |_____^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     if (Foo {\n LL |         x: 3"}, {"sha": "95b0882b7aeb5ec466533ac0eb8f77d71963e314", "filename": "src/test/ui/parser/struct-literal-in-match-discriminant.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-match-discriminant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-match-discriminant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-match-discriminant.stderr?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -6,7 +6,7 @@ LL |       match Foo {\n LL | |         x: 3\n LL | |     } {\n    | |_____^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     match (Foo {\n LL |         x: 3"}, {"sha": "acd31b477dc27d7f431cb6045f45c0ac76f97ab1", "filename": "src/test/ui/parser/struct-literal-in-while.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.stderr?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -6,7 +6,7 @@ LL |       while Foo {\n LL | |         x: 3\n LL | |     }.hi() {\n    | |_____^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     while (Foo {\n LL |         x: 3"}, {"sha": "24078074161e6f08744e7d7bbf46c7a24c53c4b5", "filename": "src/test/ui/parser/struct-literal-restrictions-in-lamda.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -6,7 +6,7 @@ LL |       while || Foo {\n LL | |         x: 3\n LL | |     }.hi() {\n    | |_____^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     while || (Foo {\n LL |         x: 3"}, {"sha": "f91b9d7dce60fda07a9042bbf9b8ab9e0b4e61e8", "filename": "src/test/ui/struct-literal-variant-in-if.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -3,7 +3,7 @@ error: struct literals are not allowed here\n    |\n LL |     if x == E::I { field1: true, field2: 42 } {}\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     if x == (E::I { field1: true, field2: 42 }) {}\n    |             ^                                 ^\n@@ -13,7 +13,7 @@ error: struct literals are not allowed here\n    |\n LL |     if x == E::V { field: false } {}\n    |             ^^^^^^^^^^^^^^^^^^^^^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     if x == (E::V { field: false }) {}\n    |             ^                     ^\n@@ -23,7 +23,7 @@ error: struct literals are not allowed here\n    |\n LL |     if x == E::J { field: -42 } {}\n    |             ^^^^^^^^^^^^^^^^^^^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     if x == (E::J { field: -42 }) {}\n    |             ^                   ^\n@@ -33,7 +33,7 @@ error: struct literals are not allowed here\n    |\n LL |     if x == E::K { field: \"\" } {}\n    |             ^^^^^^^^^^^^^^^^^^\n-help: surround the struct literal with parenthesis\n+help: surround the struct literal with parentheses\n    |\n LL |     if x == (E::K { field: \"\" }) {}\n    |             ^                  ^"}, {"sha": "63b6399bb9034e28daa466e59825593b10e1f443", "filename": "src/tools/build-manifest/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FCargo.toml?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -7,4 +7,3 @@ edition = \"2018\"\n [dependencies]\n toml = \"0.4\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n-serde_derive = \"1.0\""}, {"sha": "336d7e32024b7748a5f596a491956cd95f5cafab", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -11,9 +11,8 @@ filetime = \"0.2\"\n getopts = \"0.2\"\n log = \"0.4\"\n regex = \"1.0\"\n-serde = \"1.0\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\"\n-serde_derive = \"1.0\"\n rustfix = \"0.4.1\"\n lazy_static = \"1.0\"\n walkdir = \"2\""}, {"sha": "5b3936ffc1e3b716c9942d1f285aba7802c86b61", "filename": "src/tools/compiletest/src/errors.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -7,6 +7,8 @@ use std::io::BufReader;\n use std::path::Path;\n use std::str::FromStr;\n \n+use log::*;\n+\n #[derive(Clone, Debug, PartialEq)]\n pub enum ErrorKind {\n     Help,"}, {"sha": "dbc477585cbfc0b6e30f0e2d63f864f3df986447", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -4,6 +4,8 @@ use std::io::prelude::*;\n use std::io::BufReader;\n use std::path::{Path, PathBuf};\n \n+use log::*;\n+\n use crate::common::{self, CompareMode, Config, Mode};\n use crate::util;\n "}, {"sha": "02b09e21ff0226e5bf9d3c27a80eecba9d0980ef", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -3,6 +3,7 @@\n \n use crate::errors::{Error, ErrorKind};\n use crate::runtest::ProcRes;\n+use serde::Deserialize;\n use serde_json;\n use std::path::{Path, PathBuf};\n use std::str::FromStr;"}, {"sha": "e253934e566a725b253850f071a1acc01b200b5a", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -3,14 +3,6 @@\n #![feature(vec_remove_item)]\n #![deny(warnings, rust_2018_idioms)]\n \n-#[cfg(unix)]\n-extern crate libc;\n-#[macro_use]\n-extern crate log;\n-#[macro_use]\n-extern crate lazy_static;\n-#[macro_use]\n-extern crate serde_derive;\n extern crate test;\n \n use crate::common::CompareMode;\n@@ -30,6 +22,7 @@ use crate::util::logv;\n use walkdir::WalkDir;\n use env_logger;\n use getopts;\n+use log::*;\n \n use self::header::{EarlyProps, Ignore};\n "}, {"sha": "3689946c055e56976f3ee1fb78d3011d1cfaff32", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -29,6 +29,9 @@ use std::path::{Path, PathBuf};\n use std::process::{Child, Command, ExitStatus, Output, Stdio};\n use std::str;\n \n+use lazy_static::lazy_static;\n+use log::*;\n+\n use crate::extract_gdb_version;\n use crate::is_android_gdb_target;\n "}, {"sha": "adc1224bcd36738b42be469dfe3cf32d59d557c5", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -3,6 +3,8 @@ use std::env;\n use std::path::PathBuf;\n use crate::common::Config;\n \n+use log::*;\n+\n /// Conversion table from triple OS name to Rust SYSNAME\n const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"android\", \"android\"),"}, {"sha": "eeac6cfbb30e0cda50192c8d915a51e722347403", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -6,6 +6,5 @@ edition = \"2018\"\n \n [dependencies]\n regex = \"1\"\n-serde = \"1.0.8\"\n-serde_derive = \"1.0.8\"\n+serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\""}, {"sha": "8626ba060bf713f66ddc37332d9774db9681340b", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03bd2f653f0d0adb69d862fbeec64663157e71e1/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=03bd2f653f0d0adb69d862fbeec64663157e71e1", "patch": "@@ -5,7 +5,7 @@ use std::fs;\n use std::path::Path;\n use std::process::Command;\n \n-use serde_derive::Deserialize;\n+use serde::Deserialize;\n use serde_json;\n \n const LICENSES: &[&str] = &["}]}