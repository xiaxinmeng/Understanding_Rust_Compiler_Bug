{"sha": "d5ab347d5ca8e678297e10ef72ea702e624e7610", "node_id": "C_kwDOAAsO6NoAKGQ1YWIzNDdkNWNhOGU2NzgyOTdlMTBlZjcyZWE3MDJlNjI0ZTc2MTA", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-03-14T10:29:18Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-03-14T10:29:18Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "e3f490255c96b7ae2cb07533d34aff3ac3652ecc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3f490255c96b7ae2cb07533d34aff3ac3652ecc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5ab347d5ca8e678297e10ef72ea702e624e7610", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmIvGQEACgkQHKDfKvWd\naKVgGA//QipGHaJKctojbe7PVH4EMjAWYxHnGQo9sQd7ROFq1ufuZ9pxzvNzmW7D\nhrf4/3u07F0fnSyxnPJBiDlgg1PZi46bBuIhPVoXDw0tivdKEUu0/exGlLSZ29zr\nZeAfHS5KPYxw7yEkN2gzxOCYgLTmOxAmsZJpaf8Q7i61cPDgwM9sXFUFB9pJ8rHX\nMeEf/fHtpm2Eaq+SenAcaaSJT+VOeeELI0Ae4JA93vbr26q0P5BmOm6Dnqiib8KC\nUF1HkL/spbTBSBREkmBmXmi697SgaIunHAkUJ3IaM4CAdnxin3VFKuaR2vbR+kv/\nPuQme+zF16KxwsoylSJsDT5hDX1MYYMnYxgTSdZLL61L0DwXw02C2rTk5+LymA1I\nZNv+Ul/Ee86MMEK+c3ISaZJc8BaQOKq26EKpGOGHxwdZoh2aldHvt8uCNpFNg9ZO\niCsmn5atMYzkhy2lA3mk1TmAJa7Sl4jF4hVqt59QxgFAMFOVgE/U3DfoV5WT4U+T\nvo2Bh+hTXzWttf8ztXoaoa7/LHrm4o3HIUtH3+ATWjVqQ1CYYscBjumLDLuyVoDi\n8lyOTrlBP2XFD1qD3cBBjknfi7sNbFrhKfdAFeK+8RPmqqieABFA+3MwHEJtqdau\n8+yySCzPdsX9+Zw0E4jTMCDDCr7YFjB6d5YE0hgAxO4HS6QZruE=\n=qApn\n-----END PGP SIGNATURE-----", "payload": "tree e3f490255c96b7ae2cb07533d34aff3ac3652ecc\nparent e1102312608f7d41160a37a3f7e60f88f87c046f\nparent e2e492c10e8690814b6ab6df080ffe732b23b7fc\nauthor flip1995 <philipp.krones@embecosm.com> 1647253758 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1647253758 +0100\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ab347d5ca8e678297e10ef72ea702e624e7610", "html_url": "https://github.com/rust-lang/rust/commit/d5ab347d5ca8e678297e10ef72ea702e624e7610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5ab347d5ca8e678297e10ef72ea702e624e7610/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1102312608f7d41160a37a3f7e60f88f87c046f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1102312608f7d41160a37a3f7e60f88f87c046f", "html_url": "https://github.com/rust-lang/rust/commit/e1102312608f7d41160a37a3f7e60f88f87c046f"}, {"sha": "e2e492c10e8690814b6ab6df080ffe732b23b7fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e492c10e8690814b6ab6df080ffe732b23b7fc", "html_url": "https://github.com/rust-lang/rust/commit/e2e492c10e8690814b6ab6df080ffe732b23b7fc"}], "stats": {"total": 3718, "additions": 3375, "deletions": 343}, "files": [{"sha": "cd83bc9642b60c73ee1529c492512b993f251fab", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -74,10 +74,3 @@ jobs:\n       run: bash .github/driver.sh\n       env:\n         OS: ${{ runner.os }}\n-\n-    - name: Test cargo dev new lint\n-      run: |\n-        cargo dev new_lint --name new_early_pass --pass early\n-        cargo dev new_lint --name new_late_pass --pass late\n-        cargo check\n-        git reset --hard HEAD"}, {"sha": "f571485e6d389befdf909d2f9ab5fa7bf25db69a", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -143,13 +143,6 @@ jobs:\n       env:\n         OS: ${{ runner.os }}\n \n-    - name: Test cargo dev new lint\n-      run: |\n-        cargo dev new_lint --name new_early_pass --pass early\n-        cargo dev new_lint --name new_late_pass --pass late\n-        cargo check\n-        git reset --hard HEAD\n-\n   integration_build:\n     needs: changelog\n     runs-on: ubuntu-latest"}, {"sha": "5dfab1d2ebc402495477e11fd70daa13372d38ce", "filename": ".github/workflows/clippy_dev.yml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_dev.yml?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -36,6 +36,13 @@ jobs:\n     - name: Test fmt\n       run: cargo dev fmt --check\n \n+    - name: Test cargo dev new lint\n+      run: |\n+        cargo dev new_lint --name new_early_pass --pass early\n+        cargo dev new_lint --name new_late_pass --pass late\n+        cargo check\n+        git reset --hard HEAD\n+\n   # These jobs doesn't actually test anything, but they're only used to tell\n   # bors the build completed, as there is no practical way to detect when a\n   # workflow is successful listening to webhooks only."}, {"sha": "2bc393d60425678b7fe69e4949fc1d0df97901d4", "filename": "CHANGELOG.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -3042,6 +3042,7 @@ Released 2018-09-13\n <!-- lint disable no-unused-definitions -->\n <!-- begin autogenerated links to lint list -->\n [`absurd_extreme_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n+[`allow_attributes_without_reason`]: https://rust-lang.github.io/rust-clippy/master/index.html#allow_attributes_without_reason\n [`almost_swapped`]: https://rust-lang.github.io/rust-clippy/master/index.html#almost_swapped\n [`approx_constant`]: https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n [`as_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_conversions\n@@ -3076,6 +3077,7 @@ Released 2018-09-13\n [`cast_ptr_alignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_ptr_alignment\n [`cast_ref_to_mut`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_ref_to_mut\n [`cast_sign_loss`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_sign_loss\n+[`cast_slice_different_sizes`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_slice_different_sizes\n [`char_lit_as_u8`]: https://rust-lang.github.io/rust-clippy/master/index.html#char_lit_as_u8\n [`chars_last_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_last_cmp\n [`chars_next_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_next_cmp\n@@ -3225,6 +3227,7 @@ Released 2018-09-13\n [`iter_nth_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth_zero\n [`iter_overeager_cloned`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_overeager_cloned\n [`iter_skip_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_skip_next\n+[`iter_with_drain`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_with_drain\n [`iterator_step_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iterator_step_by_zero\n [`just_underscores_and_digits`]: https://rust-lang.github.io/rust-clippy/master/index.html#just_underscores_and_digits\n [`large_const_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_const_arrays\n@@ -3297,6 +3300,7 @@ Released 2018-09-13\n [`missing_inline_in_public_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_inline_in_public_items\n [`missing_panics_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc\n [`missing_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc\n+[`missing_spin_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_spin_loop\n [`mistyped_literal_suffixes`]: https://rust-lang.github.io/rust-clippy/master/index.html#mistyped_literal_suffixes\n [`mixed_case_hex_literals`]: https://rust-lang.github.io/rust-clippy/master/index.html#mixed_case_hex_literals\n [`mod_module_files`]: https://rust-lang.github.io/rust-clippy/master/index.html#mod_module_files\n@@ -3327,6 +3331,7 @@ Released 2018-09-13\n [`needless_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_for_each\n [`needless_late_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_late_init\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n+[`needless_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_match\n [`needless_option_as_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_option_as_deref\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n [`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n@@ -3351,6 +3356,7 @@ Released 2018-09-13\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`octal_escapes`]: https://rust-lang.github.io/rust-clippy/master/index.html#octal_escapes\n [`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n+[`only_used_in_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n@@ -3498,6 +3504,7 @@ Released 2018-09-13\n [`unit_return_expecting_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_return_expecting_ord\n [`unnecessary_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n [`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n+[`unnecessary_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_find_map\n [`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n [`unnecessary_lazy_evaluations`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed"}, {"sha": "123af23881b623ffd7ba83b8f1a259db3fa49b40", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -50,7 +50,7 @@ syn = { version = \"1.0\", features = [\"full\"] }\n futures = \"0.3\"\n parking_lot = \"0.11.2\"\n tokio = { version = \"1\", features = [\"io-util\"] }\n-num_cpus = \"1.13\"\n+rustc-semver = \"1.1\"\n \n [build-dependencies]\n rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }"}, {"sha": "d0b03c0a9c276e644e89c6bfa22499cfdce7e052", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -255,7 +255,38 @@ declare_clippy_lint! {\n     \"usage of `cfg(operating_system)` instead of `cfg(target_os = \\\"operating_system\\\")`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for attributes that allow lints without a reason.\n+    ///\n+    /// (This requires the `lint_reasons` feature)\n+    ///\n+    /// ### Why is this bad?\n+    /// Allowing a lint should always have a reason. This reason should be documented to\n+    /// ensure that others understand the reasoning\n+    ///\n+    /// ### Example\n+    /// Bad:\n+    /// ```rust\n+    /// #![feature(lint_reasons)]\n+    ///\n+    /// #![allow(clippy::some_lint)]\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #![feature(lint_reasons)]\n+    ///\n+    /// #![allow(clippy::some_lint, reason = \"False positive rust-lang/rust-clippy#1002020\")]\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub ALLOW_ATTRIBUTES_WITHOUT_REASON,\n+    restriction,\n+    \"ensures that all `allow` and `expect` attributes have a reason\"\n+}\n+\n declare_lint_pass!(Attributes => [\n+    ALLOW_ATTRIBUTES_WITHOUT_REASON,\n     INLINE_ALWAYS,\n     DEPRECATED_SEMVER,\n     USELESS_ATTRIBUTE,\n@@ -269,6 +300,9 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                 if is_lint_level(ident.name) {\n                     check_clippy_lint_names(cx, ident.name, items);\n                 }\n+                if matches!(ident.name, sym::allow | sym::expect) {\n+                    check_lint_reason(cx, ident.name, items, attr);\n+                }\n                 if items.is_empty() || !attr.has_name(sym::deprecated) {\n                     return;\n                 }\n@@ -404,6 +438,30 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, name: Symbol, items: &[NestedMe\n     }\n }\n \n+fn check_lint_reason(cx: &LateContext<'_>, name: Symbol, items: &[NestedMetaItem], attr: &'_ Attribute) {\n+    // Check for the feature\n+    if !cx.tcx.sess.features_untracked().lint_reasons {\n+        return;\n+    }\n+\n+    // Check if the reason is present\n+    if let Some(item) = items.last().and_then(NestedMetaItem::meta_item)\n+        && let MetaItemKind::NameValue(_) = &item.kind\n+        && item.path == sym::reason\n+    {\n+        return;\n+    }\n+\n+    span_lint_and_help(\n+        cx,\n+        ALLOW_ATTRIBUTES_WITHOUT_REASON,\n+        attr.span,\n+        &format!(\"`{}` attribute without specifying a reason\", name.as_str()),\n+        None,\n+        \"try adding a reason at the end with `, reason = \\\"..\\\"`\",\n+    );\n+}\n+\n fn is_relevant_item(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if let ItemKind::Fn(_, _, eid) = item.kind {\n         is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n@@ -659,5 +717,5 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n }\n \n fn is_lint_level(symbol: Symbol) -> bool {\n-    matches!(symbol, sym::allow | sym::warn | sym::deny | sym::forbid)\n+    matches!(symbol, sym::allow | sym::expect | sym::warn | sym::deny | sym::forbid)\n }"}, {"sha": "3608c1654d5c71196b209cc0c1c47617a16556b8", "filename": "clippy_lints/src/casts/cast_slice_different_sizes.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,117 @@\n+use clippy_utils::{diagnostics::span_lint_and_then, meets_msrv, msrvs, source::snippet_opt};\n+use if_chain::if_chain;\n+use rustc_ast::Mutability;\n+use rustc_hir::{Expr, ExprKind, Node};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, layout::LayoutOf, Ty, TypeAndMut};\n+use rustc_semver::RustcVersion;\n+\n+use super::CAST_SLICE_DIFFERENT_SIZES;\n+\n+fn is_child_of_cast(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let map = cx.tcx.hir();\n+    if_chain! {\n+        if let Some(parent_id) = map.find_parent_node(expr.hir_id);\n+        if let Some(parent) = map.find(parent_id);\n+        then {\n+            let expr = match parent {\n+                Node::Block(block) => {\n+                    if let Some(parent_expr) = block.expr {\n+                        parent_expr\n+                    } else {\n+                        return false;\n+                    }\n+                },\n+                Node::Expr(expr) => expr,\n+                _ => return false,\n+            };\n+\n+            matches!(expr.kind, ExprKind::Cast(..))\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVersion>) {\n+    // suggestion is invalid if `ptr::slice_from_raw_parts` does not exist\n+    if !meets_msrv(msrv.as_ref(), &msrvs::PTR_SLICE_RAW_PARTS) {\n+        return;\n+    }\n+\n+    // if this cast is the child of another cast expression then don't emit something for it, the full\n+    // chain will be analyzed\n+    if is_child_of_cast(cx, expr) {\n+        return;\n+    }\n+\n+    if let Some((from_slice_ty, to_slice_ty)) = expr_cast_chain_tys(cx, expr) {\n+        if let (Ok(from_layout), Ok(to_layout)) = (cx.layout_of(from_slice_ty.ty), cx.layout_of(to_slice_ty.ty)) {\n+            let from_size = from_layout.size.bytes();\n+            let to_size = to_layout.size.bytes();\n+            if from_size != to_size && from_size != 0 && to_size != 0 {\n+                span_lint_and_then(\n+                    cx,\n+                    CAST_SLICE_DIFFERENT_SIZES,\n+                    expr.span,\n+                    &format!(\n+                        \"casting between raw pointers to `[{}]` (element size {}) and `[{}]` (element size {}) does not adjust the count\",\n+                        from_slice_ty, from_size, to_slice_ty, to_size,\n+                    ),\n+                    |diag| {\n+                        let cast_expr = match expr.kind {\n+                            ExprKind::Cast(cast_expr, ..) => cast_expr,\n+                            _ => unreachable!(\"expr should be a cast as checked by expr_cast_chain_tys\"),\n+                        };\n+                        let ptr_snippet = snippet_opt(cx, cast_expr.span).unwrap();\n+\n+                        let (mutbl_fn_str, mutbl_ptr_str) = match to_slice_ty.mutbl {\n+                            Mutability::Mut => (\"_mut\", \"mut\"),\n+                            Mutability::Not => (\"\", \"const\"),\n+                        };\n+                        let sugg = format!(\n+                            \"core::ptr::slice_from_raw_parts{mutbl_fn_str}({ptr_snippet} as *{mutbl_ptr_str} {to_slice_ty}, ..)\"\n+                        );\n+\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            &format!(\"replace with `ptr::slice_from_raw_parts{mutbl_fn_str}`\"),\n+                            sugg,\n+                            rustc_errors::Applicability::HasPlaceholders,\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns the type T of the pointed to *const [T] or *mut [T] and the mutability of the slice if\n+/// the type is one of those slices\n+fn get_raw_slice_ty_mut(ty: Ty<'_>) -> Option<TypeAndMut<'_>> {\n+    match ty.kind() {\n+        ty::RawPtr(TypeAndMut { ty: slice_ty, mutbl }) => match slice_ty.kind() {\n+            ty::Slice(ty) => Some(TypeAndMut { ty: *ty, mutbl: *mutbl }),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+/// Returns the pair (original ptr T, final ptr U) if the expression is composed of casts\n+/// Returns None if the expr is not a Cast\n+fn expr_cast_chain_tys<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<(TypeAndMut<'tcx>, TypeAndMut<'tcx>)> {\n+    if let ExprKind::Cast(cast_expr, _cast_to_hir_ty) = expr.peel_blocks().kind {\n+        let cast_to = cx.typeck_results().expr_ty(expr);\n+        let to_slice_ty = get_raw_slice_ty_mut(cast_to)?;\n+        if let Some((inner_from_ty, _inner_to_ty)) = expr_cast_chain_tys(cx, cast_expr) {\n+            Some((inner_from_ty, to_slice_ty))\n+        } else {\n+            let cast_from = cx.typeck_results().expr_ty(cast_expr);\n+            let from_slice_ty = get_raw_slice_ty_mut(cast_from)?;\n+            Some((from_slice_ty, to_slice_ty))\n+        }\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "6a0eabd089d021b3165d8a09b9922ea596fe9820", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -5,6 +5,7 @@ mod cast_precision_loss;\n mod cast_ptr_alignment;\n mod cast_ref_to_mut;\n mod cast_sign_loss;\n+mod cast_slice_different_sizes;\n mod char_lit_as_u8;\n mod fn_to_numeric_cast;\n mod fn_to_numeric_cast_any;\n@@ -409,6 +410,50 @@ declare_clippy_lint! {\n     \"casts from an enum type to an integral type which will truncate the value\"\n }\n \n+declare_clippy_lint! {\n+    /// Checks for `as` casts between raw pointers to slices with differently sized elements.\n+    ///\n+    /// ### Why is this bad?\n+    /// The produced raw pointer to a slice does not update its length metadata. The produced\n+    /// pointer will point to a different number of bytes than the original pointer because the\n+    /// length metadata of a raw slice pointer is in elements rather than bytes.\n+    /// Producing a slice reference from the raw pointer will either create a slice with\n+    /// less data (which can be surprising) or create a slice with more data and cause Undefined Behavior.\n+    ///\n+    /// ### Example\n+    /// // Missing data\n+    /// ```rust\n+    /// let a = [1_i32, 2, 3, 4];\n+    /// let p = &a as *const [i32] as *const [u8];\n+    /// unsafe {\n+    ///     println!(\"{:?}\", &*p);\n+    /// }\n+    /// ```\n+    /// // Undefined Behavior (note: also potential alignment issues)\n+    /// ```rust\n+    /// let a = [1_u8, 2, 3, 4];\n+    /// let p = &a as *const [u8] as *const [u32];\n+    /// unsafe {\n+    ///     println!(\"{:?}\", &*p);\n+    /// }\n+    /// ```\n+    /// Instead use `ptr::slice_from_raw_parts` to construct a slice from a data pointer and the correct length\n+    /// ```rust\n+    /// let a = [1_i32, 2, 3, 4];\n+    /// let old_ptr = &a as *const [i32];\n+    /// // The data pointer is cast to a pointer to the target `u8` not `[u8]`\n+    /// // The length comes from the known length of 4 i32s times the 4 bytes per i32\n+    /// let new_ptr = core::ptr::slice_from_raw_parts(old_ptr as *const u8, 16);\n+    /// unsafe {\n+    ///     println!(\"{:?}\", &*new_ptr);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub CAST_SLICE_DIFFERENT_SIZES,\n+    correctness,\n+    \"casting using `as` between raw pointers to slices of types with different sizes\"\n+}\n+\n pub struct Casts {\n     msrv: Option<RustcVersion>,\n }\n@@ -428,6 +473,7 @@ impl_lint_pass!(Casts => [\n     CAST_LOSSLESS,\n     CAST_REF_TO_MUT,\n     CAST_PTR_ALIGNMENT,\n+    CAST_SLICE_DIFFERENT_SIZES,\n     UNNECESSARY_CAST,\n     FN_TO_NUMERIC_CAST_ANY,\n     FN_TO_NUMERIC_CAST,\n@@ -478,6 +524,8 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n         cast_ref_to_mut::check(cx, expr);\n         cast_ptr_alignment::check(cx, expr);\n         char_lit_as_u8::check(cx, expr);\n+        ptr_as_ptr::check(cx, expr, &self.msrv);\n+        cast_slice_different_sizes::check(cx, expr, &self.msrv);\n     }\n \n     extract_msrv_attr!(LateContext);"}, {"sha": "a0e5d30263316b88921d4b9671991106b4b4f510", "filename": "clippy_lints/src/dbg_macro.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdbg_macro.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_in_test_function;\n use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n@@ -35,6 +36,10 @@ impl LateLintPass<'_> for DbgMacro {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n         if cx.tcx.is_diagnostic_item(sym::dbg_macro, macro_call.def_id) {\n+            // we make an exception for test code\n+            if is_in_test_function(cx.tcx, expr.hir_id) {\n+                return;\n+            }\n             let mut applicability = Applicability::MachineApplicable;\n             let suggestion = match expr.peel_drop_temps().kind {\n                 // dbg!()"}, {"sha": "23bca5a0eabb2c10e680e85f6bdda842207c486f", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -25,6 +25,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(booleans::NONMINIMAL_BOOL),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n     LintId::of(casts::CAST_REF_TO_MUT),\n+    LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::FN_TO_NUMERIC_CAST),\n     LintId::of(casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n@@ -109,6 +110,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(loops::ITER_NEXT_LOOP),\n     LintId::of(loops::MANUAL_FLATTEN),\n     LintId::of(loops::MANUAL_MEMCPY),\n+    LintId::of(loops::MISSING_SPIN_LOOP),\n     LintId::of(loops::MUT_RANGE_BOUND),\n     LintId::of(loops::NEEDLESS_COLLECT),\n     LintId::of(loops::NEEDLESS_RANGE_LOOP),\n@@ -136,6 +138,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(matches::MATCH_OVERLAPPING_ARM),\n     LintId::of(matches::MATCH_REF_PATS),\n     LintId::of(matches::MATCH_SINGLE_BINDING),\n+    LintId::of(matches::NEEDLESS_MATCH),\n     LintId::of(matches::REDUNDANT_PATTERN_MATCHING),\n     LintId::of(matches::SINGLE_MATCH),\n     LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n@@ -163,6 +166,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::ITER_NTH_ZERO),\n     LintId::of(methods::ITER_OVEREAGER_CLONED),\n     LintId::of(methods::ITER_SKIP_NEXT),\n+    LintId::of(methods::ITER_WITH_DRAIN),\n     LintId::of(methods::MANUAL_FILTER_MAP),\n     LintId::of(methods::MANUAL_FIND_MAP),\n     LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n@@ -189,6 +193,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::SUSPICIOUS_SPLITN),\n     LintId::of(methods::UNINIT_ASSUMED_INIT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n+    LintId::of(methods::UNNECESSARY_FIND_MAP),\n     LintId::of(methods::UNNECESSARY_FOLD),\n     LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n     LintId::of(methods::UNNECESSARY_TO_OWNED),\n@@ -231,6 +236,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),"}, {"sha": "68d6c6ce5f7dad5d9377fa8e993c64f5cfd463f2", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -30,6 +30,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_SINGLE_BINDING),\n+    LintId::of(matches::NEEDLESS_MATCH),\n     LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n     LintId::of(methods::BIND_INSTEAD_OF_MAP),\n     LintId::of(methods::CLONE_ON_COPY),\n@@ -49,6 +50,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SKIP_WHILE_NEXT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n+    LintId::of(methods::UNNECESSARY_FIND_MAP),\n     LintId::of(methods::USELESS_ASREF),\n     LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n     LintId::of(misc_early::UNNEEDED_WILDCARD_PATTERN),\n@@ -63,6 +65,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n     LintId::of(no_effect::NO_EFFECT),\n     LintId::of(no_effect::UNNECESSARY_OPERATION),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),"}, {"sha": "df63f84463dba27345e320748c0b8117dff9d840", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -13,6 +13,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n     LintId::of(booleans::LOGIC_BUG),\n     LintId::of(casts::CAST_REF_TO_MUT),\n+    LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n     LintId::of(copies::IFS_SAME_COND),\n     LintId::of(copies::IF_SAME_THEN_ELSE),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),"}, {"sha": "4778f4fdfa76c365a40d4d1a325516d86ff8ef6c", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -14,6 +14,7 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n     LintId::of(utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n     LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n+    LintId::of(utils::internal_lints::MISSING_MSRV_ATTR_IMPL),\n     LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n     LintId::of(utils::internal_lints::PRODUCE_ICE),\n     LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),"}, {"sha": "1a45763a86965de9050347d75ad3f43fda627a4d", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -26,6 +26,8 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n+    utils::internal_lints::MISSING_MSRV_ATTR_IMPL,\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::PRODUCE_ICE,\n@@ -42,6 +44,7 @@ store.register_lints(&[\n     assign_ops::ASSIGN_OP_PATTERN,\n     assign_ops::MISREFACTORED_ASSIGN_OP,\n     async_yields_async::ASYNC_YIELDS_ASYNC,\n+    attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON,\n     attrs::BLANKET_CLIPPY_RESTRICTION_LINTS,\n     attrs::DEPRECATED_CFG_ATTR,\n     attrs::DEPRECATED_SEMVER,\n@@ -75,6 +78,7 @@ store.register_lints(&[\n     casts::CAST_PTR_ALIGNMENT,\n     casts::CAST_REF_TO_MUT,\n     casts::CAST_SIGN_LOSS,\n+    casts::CAST_SLICE_DIFFERENT_SIZES,\n     casts::CHAR_LIT_AS_U8,\n     casts::FN_TO_NUMERIC_CAST,\n     casts::FN_TO_NUMERIC_CAST_ANY,\n@@ -219,6 +223,7 @@ store.register_lints(&[\n     loops::ITER_NEXT_LOOP,\n     loops::MANUAL_FLATTEN,\n     loops::MANUAL_MEMCPY,\n+    loops::MISSING_SPIN_LOOP,\n     loops::MUT_RANGE_BOUND,\n     loops::NEEDLESS_COLLECT,\n     loops::NEEDLESS_RANGE_LOOP,\n@@ -255,6 +260,7 @@ store.register_lints(&[\n     matches::MATCH_SINGLE_BINDING,\n     matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n     matches::MATCH_WILD_ERR_ARM,\n+    matches::NEEDLESS_MATCH,\n     matches::REDUNDANT_PATTERN_MATCHING,\n     matches::REST_PAT_IN_FULLY_BOUND_STRUCTS,\n     matches::SINGLE_MATCH,\n@@ -296,6 +302,7 @@ store.register_lints(&[\n     methods::ITER_NTH_ZERO,\n     methods::ITER_OVEREAGER_CLONED,\n     methods::ITER_SKIP_NEXT,\n+    methods::ITER_WITH_DRAIN,\n     methods::MANUAL_FILTER_MAP,\n     methods::MANUAL_FIND_MAP,\n     methods::MANUAL_SATURATING_ARITHMETIC,\n@@ -323,6 +330,7 @@ store.register_lints(&[\n     methods::SUSPICIOUS_SPLITN,\n     methods::UNINIT_ASSUMED_INIT,\n     methods::UNNECESSARY_FILTER_MAP,\n+    methods::UNNECESSARY_FIND_MAP,\n     methods::UNNECESSARY_FOLD,\n     methods::UNNECESSARY_LAZY_EVALUATIONS,\n     methods::UNNECESSARY_TO_OWNED,\n@@ -392,6 +400,7 @@ store.register_lints(&[\n     non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY,\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n     octal_escapes::OCTAL_ESCAPES,\n+    only_used_in_recursion::ONLY_USED_IN_RECURSION,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,"}, {"sha": "6e9c0ee33a12dec66b8accbf3647ddd610e039f9", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -10,11 +10,13 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(large_const_arrays::LARGE_CONST_ARRAYS),\n     LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n     LintId::of(loops::MANUAL_MEMCPY),\n+    LintId::of(loops::MISSING_SPIN_LOOP),\n     LintId::of(loops::NEEDLESS_COLLECT),\n     LintId::of(methods::EXPECT_FUN_CALL),\n     LintId::of(methods::EXTEND_WITH_DRAIN),\n     LintId::of(methods::ITER_NTH),\n     LintId::of(methods::ITER_OVEREAGER_CLONED),\n+    LintId::of(methods::ITER_WITH_DRAIN),\n     LintId::of(methods::MANUAL_STR_REPEAT),\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::SINGLE_CHAR_PATTERN),"}, {"sha": "4e30fc381975135ba3c678078173390dcb9e95a9", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -8,6 +8,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(as_conversions::AS_CONVERSIONS),\n     LintId::of(asm_syntax::INLINE_ASM_X86_ATT_SYNTAX),\n     LintId::of(asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n+    LintId::of(attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON),\n     LintId::of(casts::FN_TO_NUMERIC_CAST_ANY),\n     LintId::of(create_dir::CREATE_DIR),\n     LintId::of(dbg_macro::DBG_MACRO),"}, {"sha": "504235d0d1ef00b40bf5b8f948514b86827a1c40", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -318,6 +318,7 @@ mod non_octal_unix_permissions;\n mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n mod octal_escapes;\n+mod only_used_in_recursion;\n mod open_options;\n mod option_env_unwrap;\n mod option_if_let_else;\n@@ -505,6 +506,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|| Box::new(utils::internal_lints::LintWithoutLintPass::default()));\n         store.register_late_pass(|| Box::new(utils::internal_lints::MatchTypeOnDiagItem));\n         store.register_late_pass(|| Box::new(utils::internal_lints::OuterExpnDataPass));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }\n \n     store.register_late_pass(|| Box::new(utils::author::Author));\n@@ -856,6 +858,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(borrow_as_ptr::BorrowAsPtr::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n+    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n     store.register_late_pass(|| Box::new(dbg_macro::DbgMacro));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n     store.register_late_pass(move || {"}, {"sha": "0696afa39225f52281ba9dc01463e212d70117de", "filename": "clippy_lints/src/loops/missing_spin_loop.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,56 @@\n+use super::MISSING_SPIN_LOOP;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_no_std_crate;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Block, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::sym;\n+\n+fn unpack_cond<'tcx>(cond: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    match &cond.kind {\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: Some(e),\n+                ..\n+            },\n+            _,\n+        )\n+        | ExprKind::Unary(_, e) => unpack_cond(e),\n+        ExprKind::Binary(_, l, r) => {\n+            let l = unpack_cond(l);\n+            if let ExprKind::MethodCall(..) = l.kind {\n+                l\n+            } else {\n+                unpack_cond(r)\n+            }\n+        },\n+        _ => cond,\n+    }\n+}\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, body: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Block(Block { stmts: [], expr: None, ..}, _) = body.kind;\n+        if let ExprKind::MethodCall(method, [callee, ..], _) = unpack_cond(cond).kind;\n+        if [sym::load, sym::compare_exchange, sym::compare_exchange_weak].contains(&method.ident.name);\n+        if let ty::Adt(def, _substs) = cx.typeck_results().expr_ty(callee).kind();\n+        if cx.tcx.is_diagnostic_item(sym::AtomicBool, def.did());\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                MISSING_SPIN_LOOP,\n+                body.span,\n+                \"busy-waiting loop should at least have a spin loop hint\",\n+                \"try this\",\n+                (if is_no_std_crate(cx) {\n+                    \"{ core::hint::spin_loop() }\"\n+                } else {\n+                    \"{ std::hint::spin_loop() }\"\n+                }).into(),\n+                Applicability::MachineApplicable\n+            );\n+        }\n+    }\n+}"}, {"sha": "f029067d36715f91cc7a33097e8b799dec51be7c", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -7,6 +7,7 @@ mod for_loops_over_fallibles;\n mod iter_next_loop;\n mod manual_flatten;\n mod manual_memcpy;\n+mod missing_spin_loop;\n mod mut_range_bound;\n mod needless_collect;\n mod needless_range_loop;\n@@ -560,6 +561,42 @@ declare_clippy_lint! {\n     \"for loops over `Option`s or `Result`s with a single expression can be simplified\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for empty spin loops\n+    ///\n+    /// ### Why is this bad?\n+    /// The loop body should have something like `thread::park()` or at least\n+    /// `std::hint::spin_loop()` to avoid needlessly burning cycles and conserve\n+    /// energy. Perhaps even better use an actual lock, if possible.\n+    ///\n+    /// ### Known problems\n+    /// This lint doesn't currently trigger on `while let` or\n+    /// `loop { match .. { .. } }` loops, which would be considered idiomatic in\n+    /// combination with e.g. `AtomicBool::compare_exchange_weak`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```ignore\n+    /// use core::sync::atomic::{AtomicBool, Ordering};\n+    /// let b = AtomicBool::new(true);\n+    /// // give a ref to `b` to another thread,wait for it to become false\n+    /// while b.load(Ordering::Acquire) {};\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,no_run\n+    ///# use core::sync::atomic::{AtomicBool, Ordering};\n+    ///# let b = AtomicBool::new(true);\n+    /// while b.load(Ordering::Acquire) {\n+    ///     std::hint::spin_loop()\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.59.0\"]\n+    pub MISSING_SPIN_LOOP,\n+    perf,\n+    \"An empty busy waiting loop\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     MANUAL_FLATTEN,\n@@ -579,6 +616,7 @@ declare_lint_pass!(Loops => [\n     WHILE_IMMUTABLE_CONDITION,\n     SAME_ITEM_PUSH,\n     SINGLE_ELEMENT_LOOP,\n+    MISSING_SPIN_LOOP,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -628,6 +666,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n             while_immutable_condition::check(cx, condition, body);\n+            missing_spin_loop::check(cx, condition, body);\n         }\n \n         needless_collect::check(expr, cx);"}, {"sha": "76c5cfadc2c1a9f931beec847dc5768aa7c6cfd4", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -35,7 +35,8 @@ struct PathAndSpan {\n     span: Span,\n }\n \n-/// `MacroRefData` includes the name of the macro.\n+/// `MacroRefData` includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n #[derive(Debug, Clone)]\n pub struct MacroRefData {\n     name: String,"}, {"sha": "ff85623acf49b85eabdd4c4eb4e399e9537ceefa", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -16,6 +16,7 @@ mod match_same_arms;\n mod match_single_binding;\n mod match_wild_enum;\n mod match_wild_err_arm;\n+mod needless_match;\n mod overlapping_arms;\n mod redundant_pattern_match;\n mod rest_pat_in_fully_bound_struct;\n@@ -566,6 +567,49 @@ declare_clippy_lint! {\n     \"`match` with identical arm bodies\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary `match` or match-like `if let` returns for `Option` and `Result`\n+    /// when function signatures are the same.\n+    ///\n+    /// ### Why is this bad?\n+    /// This `match` block does nothing and might not be what the coder intended.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// fn foo() -> Result<(), i32> {\n+    ///     match result {\n+    ///         Ok(val) => Ok(val),\n+    ///         Err(err) => Err(err),\n+    ///     }\n+    /// }\n+    ///\n+    /// fn bar() -> Option<i32> {\n+    ///     if let Some(val) = option {\n+    ///         Some(val)\n+    ///     } else {\n+    ///         None\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be replaced as\n+    ///\n+    /// ```rust,ignore\n+    /// fn foo() -> Result<(), i32> {\n+    ///     result\n+    /// }\n+    ///\n+    /// fn bar() -> Option<i32> {\n+    ///     option\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub NEEDLESS_MATCH,\n+    complexity,\n+    \"`match` or match-like `if let` that are unnecessary\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -599,6 +643,7 @@ impl_lint_pass!(Matches => [\n     REDUNDANT_PATTERN_MATCHING,\n     MATCH_LIKE_MATCHES_MACRO,\n     MATCH_SAME_ARMS,\n+    NEEDLESS_MATCH,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -622,6 +667,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     overlapping_arms::check(cx, ex, arms);\n                     match_wild_enum::check(cx, ex, arms);\n                     match_as_ref::check(cx, ex, arms, expr);\n+                    needless_match::check_match(cx, ex, arms);\n \n                     if self.infallible_destructuring_match_linted {\n                         self.infallible_destructuring_match_linted = false;\n@@ -640,6 +686,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 match_like_matches::check(cx, expr);\n             }\n             redundant_pattern_match::check(cx, expr);\n+            needless_match::check(cx, expr);\n         }\n     }\n "}, {"sha": "76131d307d777e10e262cba3971b4b890a6c8c49", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,197 @@\n+use super::NEEDLESS_MATCH;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{eq_expr_value, get_parent_expr, higher, is_else_clause, is_lang_ctor, peel_blocks_with_stmt};\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::OptionNone;\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, Pat, PatKind, Path, PathSegment, QPath, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n+    // This is for avoiding collision with `match_single_binding`.\n+    if arms.len() < 2 {\n+        return;\n+    }\n+\n+    for arm in arms {\n+        if let PatKind::Wild = arm.pat.kind {\n+            let ret_expr = strip_return(arm.body);\n+            if !eq_expr_value(cx, ex, ret_expr) {\n+                return;\n+            }\n+        } else if !pat_same_as_expr(arm.pat, arm.body) {\n+            return;\n+        }\n+    }\n+\n+    if let Some(match_expr) = get_parent_expr(cx, ex) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            NEEDLESS_MATCH,\n+            match_expr.span,\n+            \"this match expression is unnecessary\",\n+            \"replace it with\",\n+            snippet_with_applicability(cx, ex.span, \"..\", &mut applicability).to_string(),\n+            applicability,\n+        );\n+    }\n+}\n+\n+/// Check for nop `if let` expression that assembled as unnecessary match\n+///\n+/// ```rust,ignore\n+/// if let Some(a) = option {\n+///     Some(a)\n+/// } else {\n+///     None\n+/// }\n+/// ```\n+/// OR\n+/// ```rust,ignore\n+/// if let SomeEnum::A = some_enum {\n+///     SomeEnum::A\n+/// } else if let SomeEnum::B = some_enum {\n+///     SomeEnum::B\n+/// } else {\n+///     some_enum\n+/// }\n+/// ```\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n+    if_chain! {\n+        if let Some(ref if_let) = higher::IfLet::hir(cx, ex);\n+        if !is_else_clause(cx.tcx, ex);\n+        if check_if_let(cx, if_let);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_MATCH,\n+                ex.span,\n+                \"this if-let expression is unnecessary\",\n+                \"replace it with\",\n+                snippet_with_applicability(cx, if_let.let_expr.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n+    if let Some(if_else) = if_let.if_else {\n+        if !pat_same_as_expr(if_let.let_pat, peel_blocks_with_stmt(if_let.if_then)) {\n+            return false;\n+        }\n+\n+        // Recurrsively check for each `else if let` phrase,\n+        if let Some(ref nested_if_let) = higher::IfLet::hir(cx, if_else) {\n+            return check_if_let(cx, nested_if_let);\n+        }\n+\n+        if matches!(if_else.kind, ExprKind::Block(..)) {\n+            let else_expr = peel_blocks_with_stmt(if_else);\n+            let ret = strip_return(else_expr);\n+            let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n+            if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n+                if let ExprKind::Path(ref qpath) = ret.kind {\n+                    return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n+                }\n+            } else {\n+                return eq_expr_value(cx, if_let.let_expr, ret);\n+            }\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+/// Strip `return` keyword if the expression type is `ExprKind::Ret`.\n+fn strip_return<'hir>(expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    if let ExprKind::Ret(Some(ret)) = expr.kind {\n+        ret\n+    } else {\n+        expr\n+    }\n+}\n+\n+fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n+    let expr = strip_return(expr);\n+    match (&pat.kind, &expr.kind) {\n+        // Example: `Some(val) => Some(val)`\n+        (\n+            PatKind::TupleStruct(QPath::Resolved(_, path), [first_pat, ..], _),\n+            ExprKind::Call(call_expr, [first_param, ..]),\n+        ) => {\n+            if let ExprKind::Path(QPath::Resolved(_, call_path)) = call_expr.kind {\n+                if has_identical_segments(path.segments, call_path.segments)\n+                    && has_same_non_ref_symbol(first_pat, first_param)\n+                {\n+                    return true;\n+                }\n+            }\n+        },\n+        // Example: `val => val`, or `ref val => *val`\n+        (PatKind::Binding(annot, _, pat_ident, _), _) => {\n+            let new_expr = if let (\n+                BindingAnnotation::Ref | BindingAnnotation::RefMut,\n+                ExprKind::Unary(UnOp::Deref, operand_expr),\n+            ) = (annot, &expr.kind)\n+            {\n+                operand_expr\n+            } else {\n+                expr\n+            };\n+\n+            if let ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: [first_seg, ..],\n+                    ..\n+                },\n+            )) = new_expr.kind\n+            {\n+                return pat_ident.name == first_seg.ident.name;\n+            }\n+        },\n+        // Example: `Custom::TypeA => Custom::TypeB`, or `None => None`\n+        (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {\n+            return has_identical_segments(p_path.segments, e_path.segments);\n+        },\n+        // Example: `5 => 5`\n+        (PatKind::Lit(pat_lit_expr), ExprKind::Lit(expr_spanned)) => {\n+            if let ExprKind::Lit(pat_spanned) = &pat_lit_expr.kind {\n+                return pat_spanned.node == expr_spanned.node;\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    false\n+}\n+\n+fn has_identical_segments(left_segs: &[PathSegment<'_>], right_segs: &[PathSegment<'_>]) -> bool {\n+    if left_segs.len() != right_segs.len() {\n+        return false;\n+    }\n+    for i in 0..left_segs.len() {\n+        if left_segs[i].ident.name != right_segs[i].ident.name {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn has_same_non_ref_symbol(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n+    if_chain! {\n+        if let PatKind::Binding(annot, _, pat_ident, _) = pat.kind;\n+        if !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n+        if let ExprKind::Path(QPath::Resolved(_, Path {segments: [first_seg, ..], .. })) = expr.kind;\n+        then {\n+            return pat_ident.name == first_seg.ident.name;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "958c3773087b6aa70f19636f445a847e07fd99e5", "filename": "clippy_lints/src/methods/iter_with_drain.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,72 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_integer_const;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{\n+    higher::{self, Range},\n+    SpanlessEq,\n+};\n+use rustc_ast::ast::RangeLimits;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::Span;\n+\n+use super::ITER_WITH_DRAIN;\n+\n+const DRAIN_TYPES: &[Symbol] = &[sym::Vec, sym::VecDeque];\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, arg: &Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+    if let Some(drained_type) = DRAIN_TYPES.iter().find(|&&sym| is_type_diagnostic_item(cx, ty, sym)) {\n+        // Refuse to emit `into_iter` suggestion on draining struct fields due\n+        // to the strong possibility of processing unmovable field.\n+        if let ExprKind::Field(..) = recv.kind {\n+            return;\n+        }\n+\n+        if let Some(range) = higher::Range::hir(arg) {\n+            let left_full = match range {\n+                Range { start: Some(start), .. } if is_integer_const(cx, start, 0) => true,\n+                Range { start: None, .. } => true,\n+                _ => false,\n+            };\n+            let full = left_full\n+                && match range {\n+                    Range {\n+                        end: Some(end),\n+                        limits: RangeLimits::HalfOpen,\n+                        ..\n+                    } => {\n+                        // `x.drain(..x.len())` call\n+                        if_chain! {\n+                            if let ExprKind::MethodCall(len_path, len_args, _) = end.kind;\n+                            if len_path.ident.name == sym::len && len_args.len() == 1;\n+                            if let ExprKind::Path(QPath::Resolved(_, drain_path)) = recv.kind;\n+                            if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n+                            if SpanlessEq::new(cx).eq_path(drain_path, len_path);\n+                            then { true }\n+                            else { false }\n+                        }\n+                    },\n+                    Range {\n+                        end: None,\n+                        limits: RangeLimits::HalfOpen,\n+                        ..\n+                    } => true,\n+                    _ => false,\n+                };\n+            if full {\n+                span_lint_and_sugg(\n+                    cx,\n+                    ITER_WITH_DRAIN,\n+                    span.with_hi(expr.span.hi()),\n+                    &format!(\"`drain(..)` used on a `{}`\", drained_type),\n+                    \"try this\",\n+                    \"into_iter()\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "5edd22cd14c7dff6c73ddb2bff1df676691b8e9a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -32,6 +32,7 @@ mod iter_nth;\n mod iter_nth_zero;\n mod iter_overeager_cloned;\n mod iter_skip_next;\n+mod iter_with_drain;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n mod manual_str_repeat;\n@@ -1118,6 +1119,31 @@ declare_clippy_lint! {\n     \"using `.skip(x).next()` on an iterator\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for use of `.drain(..)` on `Vec` and `VecDeque` for iteration.\n+    ///\n+    /// ### Why is this bad?\n+    /// `.into_iter()` is simpler with better performance.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut foo = vec![0, 1, 2, 3];\n+    /// let bar: HashSet<usize> = foo.drain(..).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let foo = vec![0, 1, 2, 3];\n+    /// let bar: HashSet<usize> = foo.into_iter().collect();\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub ITER_WITH_DRAIN,\n+    perf,\n+    \"replace `.drain(..)` with `.into_iter()`\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for use of `.get().unwrap()` (or\n@@ -1309,7 +1335,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `filter_map` calls which could be replaced by `filter` or `map`.\n+    /// Checks for `filter_map` calls that could be replaced by `filter` or `map`.\n     /// More specifically it checks if the closure provided is only performing one of the\n     /// filter or map operations and suggests the appropriate option.\n     ///\n@@ -1337,6 +1363,36 @@ declare_clippy_lint! {\n     \"using `filter_map` when a more succinct alternative exists\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `find_map` calls that could be replaced by `find` or `map`. More\n+    /// specifically it checks if the closure provided is only performing one of the\n+    /// find or map operations and suggests the appropriate option.\n+    ///\n+    /// ### Why is this bad?\n+    /// Complexity. The intent is also clearer if only a single\n+    /// operation is being performed.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let _ = (0..3).find_map(|x| if x > 2 { Some(x) } else { None });\n+    ///\n+    /// // As there is no transformation of the argument this could be written as:\n+    /// let _ = (0..3).find(|&x| x > 2);\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// let _ = (0..4).find_map(|x| Some(x + 1));\n+    ///\n+    /// // As there is no conditional check on the argument this could be written as:\n+    /// let _ = (0..4).map(|x| x + 1).next();\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub UNNECESSARY_FIND_MAP,\n+    complexity,\n+    \"using `find_map` when a more succinct alternative exists\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for `into_iter` calls on references which should be replaced by `iter`\n@@ -2017,9 +2073,11 @@ impl_lint_pass!(Methods => [\n     GET_UNWRAP,\n     STRING_EXTEND_CHARS,\n     ITER_CLONED_COLLECT,\n+    ITER_WITH_DRAIN,\n     USELESS_ASREF,\n     UNNECESSARY_FOLD,\n     UNNECESSARY_FILTER_MAP,\n+    UNNECESSARY_FIND_MAP,\n     INTO_ITER_ON_REF,\n     SUSPICIOUS_MAP,\n     UNINIT_ASSUMED_INIT,\n@@ -2296,6 +2354,9 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n                 _ => {},\n             },\n+            (\"drain\", [arg]) => {\n+                iter_with_drain::check(cx, expr, recv, span, arg);\n+            },\n             (\"expect\", [_]) => match method_call(recv) {\n                 Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n                 _ => expect_used::check(cx, expr, recv),\n@@ -2305,9 +2366,12 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 extend_with_drain::check(cx, expr, recv, arg);\n             },\n             (\"filter_map\", [arg]) => {\n-                unnecessary_filter_map::check(cx, expr, arg);\n+                unnecessary_filter_map::check(cx, expr, arg, name);\n                 filter_map_identity::check(cx, expr, arg, span);\n             },\n+            (\"find_map\", [arg]) => {\n+                unnecessary_filter_map::check(cx, expr, arg, name);\n+            },\n             (\"flat_map\", [arg]) => {\n                 flat_map_identity::check(cx, expr, arg, span);\n                 flat_map_option::check(cx, expr, arg, span);"}, {"sha": "2a5ab6e625c111ae0bec3d204db34d7f5c6653f0", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -14,18 +14,15 @@ use super::RESULT_MAP_OR_INTO_OPTION;\n \n // The expression inside a closure may or may not have surrounding braces\n // which causes problems when generating a suggestion.\n-fn reduce_unit_expression<'a>(\n-    cx: &LateContext<'_>,\n-    expr: &'a hir::Expr<'_>,\n-) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n+fn reduce_unit_expression<'a>(expr: &'a hir::Expr<'_>) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n     match expr.kind {\n         hir::ExprKind::Call(func, arg_char) => Some((func, arg_char)),\n         hir::ExprKind::Block(block, _) => {\n             match (block.stmts, block.expr) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n                     // reduce `|x| { x + 1 }` to `|x| x + 1`\n-                    reduce_unit_expression(cx, inner_expr)\n+                    reduce_unit_expression(inner_expr)\n                 },\n                 _ => None,\n             }\n@@ -77,7 +74,7 @@ pub(super) fn check<'tcx>(\n         if let hir::ExprKind::Closure(_, _, id, span, _) = map_arg.kind;\n             let arg_snippet = snippet(cx, span, \"..\");\n             let body = cx.tcx.hir().body(id);\n-                if let Some((func, [arg_char])) = reduce_unit_expression(cx, &body.value);\n+                if let Some((func, [arg_char])) = reduce_unit_expression(&body.value);\n                 if let Some(id) = path_def_id(cx, func).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n                 if Some(id) == cx.tcx.lang_items().option_some_variant();\n                 then {"}, {"sha": "2fda254ca98e99ddf1820a790842ab0af2163a16", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,4 +1,6 @@\n+use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n use rustc_hir as hir;\n@@ -9,8 +11,9 @@ use rustc_middle::ty;\n use rustc_span::sym;\n \n use super::UNNECESSARY_FILTER_MAP;\n+use super::UNNECESSARY_FIND_MAP;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, name: &str) {\n     if !is_trait_method(cx, expr, sym::Iterator) {\n         return;\n     }\n@@ -20,6 +23,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         let arg_id = body.params[0].pat.hir_id;\n         let mutates_arg =\n             mutated_variables(&body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n+        let (clone_or_copy_needed, _) = clone_or_copy_needed(cx, body.params[0].pat, &body.value);\n \n         let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, &body.value);\n \n@@ -28,13 +32,15 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         found_mapping |= return_visitor.found_mapping;\n         found_filtering |= return_visitor.found_filtering;\n \n+        let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n-            \"map\"\n-        } else if !found_mapping && !mutates_arg {\n-            let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n+            if name == \"filter_map\" { \"map\" } else { \"map(..).next()\" }\n+        } else if !found_mapping && !mutates_arg && (!clone_or_copy_needed || is_copy(cx, in_ty)) {\n             match cx.typeck_results().expr_ty(&body.value).kind() {\n-                ty::Adt(adt, subst) if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) && in_ty == subst.type_at(0) => {\n-                    \"filter\"\n+                ty::Adt(adt, subst)\n+                    if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) && in_ty == subst.type_at(0) =>\n+                {\n+                    if name == \"filter_map\" { \"filter\" } else { \"find\" }\n                 },\n                 _ => return,\n             }\n@@ -43,9 +49,13 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         };\n         span_lint(\n             cx,\n-            UNNECESSARY_FILTER_MAP,\n+            if name == \"filter_map\" {\n+                UNNECESSARY_FILTER_MAP\n+            } else {\n+                UNNECESSARY_FIND_MAP\n+            },\n             expr.span,\n-            &format!(\"this `.filter_map` can be written more simply using `.{}`\", sugg),\n+            &format!(\"this `.{}` can be written more simply using `.{}`\", name, sugg),\n         );\n     }\n }"}, {"sha": "7a39557ad5757971a1bdcfddc31697232184f29e", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 3, "deletions": 88, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,14 +1,12 @@\n+use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n-use clippy_utils::{fn_def_id, get_parent_expr, path_to_local_id, usage};\n+use clippy_utils::{fn_def_id, get_parent_expr};\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, HirId, LangItem, Mutability, Pat};\n+use rustc_hir::{def_id::DefId, Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty;\n use rustc_span::{sym, Symbol};\n \n use super::UNNECESSARY_TO_OWNED;\n@@ -100,89 +98,6 @@ pub fn check_for_loop_iter(\n     false\n }\n \n-/// The core logic of `check_for_loop_iter` above, this function wraps a use of\n-/// `CloneOrCopyVisitor`.\n-fn clone_or_copy_needed<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &Pat<'tcx>,\n-    body: &'tcx Expr<'tcx>,\n-) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n-    let mut visitor = CloneOrCopyVisitor {\n-        cx,\n-        binding_hir_ids: pat_bindings(pat),\n-        clone_or_copy_needed: false,\n-        addr_of_exprs: Vec::new(),\n-    };\n-    visitor.visit_expr(body);\n-    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n-}\n-\n-/// Returns a vector of all `HirId`s bound by the pattern.\n-fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n-    let mut collector = usage::ParamBindingIdCollector {\n-        binding_hir_ids: Vec::new(),\n-    };\n-    collector.visit_pat(pat);\n-    collector.binding_hir_ids\n-}\n-\n-/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n-/// operations performed on `binding_hir_ids` are:\n-/// * to take non-mutable references to them\n-/// * to use them as non-mutable `&self` in method calls\n-/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n-/// when `CloneOrCopyVisitor` is done visiting.\n-struct CloneOrCopyVisitor<'cx, 'tcx> {\n-    cx: &'cx LateContext<'tcx>,\n-    binding_hir_ids: Vec<HirId>,\n-    clone_or_copy_needed: bool,\n-    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n-    type NestedFilter = nested_filter::OnlyBodies;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.cx.tcx.hir()\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        walk_expr(self, expr);\n-        if self.is_binding(expr) {\n-            if let Some(parent) = get_parent_expr(self.cx, expr) {\n-                match parent.kind {\n-                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n-                        self.addr_of_exprs.push(parent);\n-                        return;\n-                    },\n-                    ExprKind::MethodCall(_, args, _) => {\n-                        if_chain! {\n-                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n-                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n-                            let method_ty = self.cx.tcx.type_of(method_def_id);\n-                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n-                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n-                            then {\n-                                return;\n-                            }\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-            self.clone_or_copy_needed = true;\n-        }\n-    }\n-}\n-\n-impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n-    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n-        self.binding_hir_ids\n-            .iter()\n-            .any(|hir_id| path_to_local_id(expr, *hir_id))\n-    }\n-}\n-\n /// Returns true if the named method is `IntoIterator::into_iter`.\n pub fn is_into_iter(cx: &LateContext<'_>, callee_def_id: DefId) -> bool {\n     cx.tcx.lang_items().require(LangItem::IntoIterIntoIter) == Ok(callee_def_id)"}, {"sha": "3015531e8439327c1337e21e89acb6367fb437fa", "filename": "clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,10 +1,14 @@\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_parent_expr, path_to_local_id, usage};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, HirId, Mutability, Pat};\n use rustc_lint::LateContext;\n+use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n \n@@ -79,3 +83,86 @@ pub(super) fn get_hint_if_single_char_arg(\n         }\n     }\n }\n+\n+/// The core logic of `check_for_loop_iter` in `unnecessary_iter_cloned.rs`, this function wraps a\n+/// use of `CloneOrCopyVisitor`.\n+pub(super) fn clone_or_copy_needed<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'tcx>,\n+    body: &'tcx Expr<'tcx>,\n+) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n+    let mut visitor = CloneOrCopyVisitor {\n+        cx,\n+        binding_hir_ids: pat_bindings(pat),\n+        clone_or_copy_needed: false,\n+        addr_of_exprs: Vec::new(),\n+    };\n+    visitor.visit_expr(body);\n+    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n+}\n+\n+/// Returns a vector of all `HirId`s bound by the pattern.\n+fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n+    let mut collector = usage::ParamBindingIdCollector {\n+        binding_hir_ids: Vec::new(),\n+    };\n+    collector.visit_pat(pat);\n+    collector.binding_hir_ids\n+}\n+\n+/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n+/// operations performed on `binding_hir_ids` are:\n+/// * to take non-mutable references to them\n+/// * to use them as non-mutable `&self` in method calls\n+/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n+/// when `CloneOrCopyVisitor` is done visiting.\n+struct CloneOrCopyVisitor<'cx, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    binding_hir_ids: Vec<HirId>,\n+    clone_or_copy_needed: bool,\n+    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n+    type NestedFilter = nested_filter::OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        walk_expr(self, expr);\n+        if self.is_binding(expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.kind {\n+                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n+                        self.addr_of_exprs.push(parent);\n+                        return;\n+                    },\n+                    ExprKind::MethodCall(_, args, _) => {\n+                        if_chain! {\n+                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n+                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n+                            let method_ty = self.cx.tcx.type_of(method_def_id);\n+                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n+                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n+                            then {\n+                                return;\n+                            }\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            }\n+            self.clone_or_copy_needed = true;\n+        }\n+    }\n+}\n+\n+impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n+    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n+        self.binding_hir_ids\n+            .iter()\n+            .any(|hir_id| path_to_local_id(expr, *hir_id))\n+    }\n+}"}, {"sha": "db6aab0671bd08d7a58a9a0a02675072d6d45c7e", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -7,7 +7,8 @@\n \n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n@@ -57,6 +58,20 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n+    fn has_include(meta: Option<MetaItem>) -> bool {\n+        if_chain! {\n+            if let Some(meta) = meta;\n+            if let MetaItemKind::List(list) = meta.kind;\n+            if let Some(meta) = list.get(0);\n+            if let Some(name) = meta.ident();\n+            then {\n+                name.name == sym::include\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n@@ -80,7 +95,9 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs.iter().any(|a| a.doc_str().is_some());\n+        let has_doc = attrs\n+            .iter()\n+            .any(|a| a.doc_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "4ba68c8eacd2474f7cbb00c27212e21793f771cf", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -92,10 +92,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "5eb7b0f0521e0a81be4e76f1e035bbdda1332698", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -199,7 +199,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                     let sugg = |diag: &mut Diagnostic| {\n                         if let ty::Adt(def, ..) = ty.kind() {\n                             if let Some(span) = cx.tcx.hir().span_if_local(def.did()) {\n-                                if can_type_implement_copy(cx.tcx, cx.param_env, ty, traits::ObligationCause::dummy_with_span(span)).is_ok() {\n+                                if can_type_implement_copy(\n+                                    cx.tcx,\n+                                    cx.param_env,\n+                                    ty,\n+                                    traits::ObligationCause::dummy_with_span(span),\n+                                ).is_ok() {\n                                     diag.span_help(span, \"consider marking this type as `Copy`\");\n                                 }\n                             }"}, {"sha": "b828d9334ee0e9e28d5f6a4d5d866edde7a218f6", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "added", "additions": 668, "deletions": 0, "changes": 668, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,668 @@\n+use std::collections::VecDeque;\n+\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use itertools::{izip, Itertools};\n+use rustc_ast::{walk_list, Label, Mutability};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n+use rustc_hir::{\n+    Arm, Block, Body, Expr, ExprKind, Guard, HirId, ImplicitSelfKind, Let, Local, Pat, PatKind, Path, PathSegment,\n+    QPath, Stmt, StmtKind, TyKind, UnOp,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_middle::ty::{Ty, TyCtxt, TypeckResults};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::kw;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for arguments that are only used in recursion with no side-effects.\n+    ///\n+    /// ### Why is this bad?\n+    /// It could contain a useless calculation and can make function simpler.\n+    ///\n+    /// The arguments can be involved in calculations and assignments but as long as\n+    /// the calculations have no side-effects (function calls or mutating dereference)\n+    /// and the assigned variables are also only in recursion, it is useless.\n+    ///\n+    /// ### Known problems\n+    /// In some cases, this would not catch all useless arguments.\n+    ///\n+    /// ```rust\n+    /// fn foo(a: usize, b: usize) -> usize {\n+    ///     let f = |x| x + 1;\n+    ///\n+    ///     if a == 0 {\n+    ///         1\n+    ///     } else {\n+    ///         foo(a - 1, f(b))\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// For example, the argument `b` is only used in recursion, but the lint would not catch it.\n+    ///\n+    /// List of some examples that can not be caught:\n+    /// - binary operation of non-primitive types\n+    /// - closure usage\n+    /// - some `break` relative operations\n+    /// - struct pattern binding\n+    ///\n+    /// Also, when you recurse the function name with path segments, it is not possible to detect.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn f(a: usize, b: usize) -> usize {\n+    ///     if a == 0 {\n+    ///         1\n+    ///     } else {\n+    ///         f(a - 1, b + 1)\n+    ///     }\n+    /// }\n+    /// # fn main() {\n+    /// #     print!(\"{}\", f(1, 1));\n+    /// # }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn f(a: usize) -> usize {\n+    ///     if a == 0 {\n+    ///         1\n+    ///     } else {\n+    ///         f(a - 1)\n+    ///     }\n+    /// }\n+    /// # fn main() {\n+    /// #     print!(\"{}\", f(1));\n+    /// # }\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub ONLY_USED_IN_RECURSION,\n+    complexity,\n+    \"arguments that is only used in recursion can be removed\"\n+}\n+declare_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n+\n+impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx rustc_hir::FnDecl<'tcx>,\n+        body: &'tcx Body<'tcx>,\n+        _: Span,\n+        id: HirId,\n+    ) {\n+        if let FnKind::ItemFn(ident, ..) | FnKind::Method(ident, ..) = kind {\n+            let def_id = id.owner.to_def_id();\n+            let data = cx.tcx.def_path(def_id).data;\n+\n+            if data.len() > 1 {\n+                match data.get(data.len() - 2) {\n+                    Some(DisambiguatedDefPathData {\n+                        data: DefPathData::Impl,\n+                        disambiguator,\n+                    }) if *disambiguator != 0 => return,\n+                    _ => {},\n+                }\n+            }\n+\n+            let has_self = !matches!(decl.implicit_self, ImplicitSelfKind::None);\n+\n+            let ty_res = cx.typeck_results();\n+            let param_span = body\n+                .params\n+                .iter()\n+                .flat_map(|param| {\n+                    let mut v = Vec::new();\n+                    param.pat.each_binding(|_, hir_id, span, ident| {\n+                        v.push((hir_id, span, ident));\n+                    });\n+                    v\n+                })\n+                .skip(if has_self { 1 } else { 0 })\n+                .filter(|(_, _, ident)| !ident.name.as_str().starts_with('_'))\n+                .collect_vec();\n+\n+            let params = body.params.iter().map(|param| param.pat).collect();\n+\n+            let mut visitor = SideEffectVisit {\n+                graph: FxHashMap::default(),\n+                has_side_effect: FxHashSet::default(),\n+                ret_vars: Vec::new(),\n+                contains_side_effect: false,\n+                break_vars: FxHashMap::default(),\n+                params,\n+                fn_ident: ident,\n+                fn_def_id: def_id,\n+                is_method: matches!(kind, FnKind::Method(..)),\n+                has_self,\n+                ty_res,\n+                ty_ctx: cx.tcx,\n+            };\n+\n+            visitor.visit_expr(&body.value);\n+            let vars = std::mem::take(&mut visitor.ret_vars);\n+            // this would set the return variables to side effect\n+            visitor.add_side_effect(vars);\n+\n+            let mut queue = visitor.has_side_effect.iter().copied().collect::<VecDeque<_>>();\n+\n+            // a simple BFS to check all the variables that have side effect\n+            while let Some(id) = queue.pop_front() {\n+                if let Some(next) = visitor.graph.get(&id) {\n+                    for i in next {\n+                        if !visitor.has_side_effect.contains(i) {\n+                            visitor.has_side_effect.insert(*i);\n+                            queue.push_back(*i);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            for (id, span, ident) in param_span {\n+                // if the variable is not used in recursion, it would be marked as unused\n+                if !visitor.has_side_effect.contains(&id) {\n+                    let mut queue = VecDeque::new();\n+                    let mut visited = FxHashSet::default();\n+\n+                    queue.push_back(id);\n+\n+                    // a simple BFS to check the graph can reach to itself\n+                    // if it can't, it means the variable is never used in recursion\n+                    while let Some(id) = queue.pop_front() {\n+                        if let Some(next) = visitor.graph.get(&id) {\n+                            for i in next {\n+                                if !visited.contains(i) {\n+                                    visited.insert(id);\n+                                    queue.push_back(*i);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    if visited.contains(&id) {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            ONLY_USED_IN_RECURSION,\n+                            span,\n+                            \"parameter is only used in recursion\",\n+                            \"if this is intentional, prefix with an underscore\",\n+                            format!(\"_{}\", ident.name.as_str()),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn is_primitive(ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n+        ty::Ref(_, t, _) => is_primitive(*t),\n+        _ => false,\n+    }\n+}\n+\n+pub fn is_array(ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Array(..) | ty::Slice(..) => true,\n+        ty::Ref(_, t, _) => is_array(*t),\n+        _ => false,\n+    }\n+}\n+\n+/// This builds the graph of side effect.\n+/// The edge `a -> b` means if `a` has side effect, `b` will have side effect.\n+///\n+/// There are some exmaple in following code:\n+/// ```rust, ignore\n+/// let b = 1;\n+/// let a = b; // a -> b\n+/// let (c, d) = (a, b); // c -> b, d -> b\n+///\n+/// let e = if a == 0 { // e -> a\n+///     c // e -> c\n+/// } else {\n+///     d // e -> d\n+/// };\n+/// ```\n+pub struct SideEffectVisit<'tcx> {\n+    graph: FxHashMap<HirId, FxHashSet<HirId>>,\n+    has_side_effect: FxHashSet<HirId>,\n+    // bool for if the variable was dereferenced from mutable reference\n+    ret_vars: Vec<(HirId, bool)>,\n+    contains_side_effect: bool,\n+    // break label\n+    break_vars: FxHashMap<Ident, Vec<(HirId, bool)>>,\n+    params: Vec<&'tcx Pat<'tcx>>,\n+    fn_ident: Ident,\n+    fn_def_id: DefId,\n+    is_method: bool,\n+    has_self: bool,\n+    ty_res: &'tcx TypeckResults<'tcx>,\n+    ty_ctx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n+    fn visit_block(&mut self, b: &'tcx Block<'tcx>) {\n+        b.stmts.iter().for_each(|stmt| {\n+            self.visit_stmt(stmt);\n+            self.ret_vars.clear();\n+        });\n+        walk_list!(self, visit_expr, b.expr);\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n+        match s.kind {\n+            StmtKind::Local(Local {\n+                pat, init: Some(init), ..\n+            }) => {\n+                self.visit_pat_expr(pat, init, false);\n+                self.ret_vars.clear();\n+            },\n+            StmtKind::Item(i) => {\n+                let item = self.ty_ctx.hir().item(i);\n+                self.visit_item(item);\n+                self.ret_vars.clear();\n+            },\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => {\n+                self.visit_expr(e);\n+                self.ret_vars.clear();\n+            },\n+            StmtKind::Local(_) => {},\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        match ex.kind {\n+            ExprKind::Array(exprs) | ExprKind::Tup(exprs) => {\n+                self.ret_vars = exprs\n+                    .iter()\n+                    .flat_map(|expr| {\n+                        self.visit_expr(expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+            },\n+            ExprKind::Call(callee, args) => self.visit_fn(callee, args),\n+            ExprKind::MethodCall(path, args, _) => self.visit_method_call(path, args),\n+            ExprKind::Binary(_, lhs, rhs) => {\n+                self.visit_bin_op(lhs, rhs);\n+            },\n+            ExprKind::Unary(op, expr) => self.visit_un_op(op, expr),\n+            ExprKind::Let(Let { pat, init, .. }) => self.visit_pat_expr(pat, init, false),\n+            ExprKind::If(bind, then_expr, else_expr) => {\n+                self.visit_if(bind, then_expr, else_expr);\n+            },\n+            ExprKind::Match(expr, arms, _) => self.visit_match(expr, arms),\n+            // since analysing the closure is not easy, just set all variables in it to side-effect\n+            ExprKind::Closure(_, _, body_id, _, _) => {\n+                let body = self.ty_ctx.hir().body(body_id);\n+                self.visit_body(body);\n+                let vars = std::mem::take(&mut self.ret_vars);\n+                self.add_side_effect(vars);\n+            },\n+            ExprKind::Loop(block, label, _, _) | ExprKind::Block(block, label) => {\n+                self.visit_block_label(block, label);\n+            },\n+            ExprKind::Assign(bind, expr, _) => {\n+                self.visit_assign(bind, expr);\n+            },\n+            ExprKind::AssignOp(_, bind, expr) => {\n+                self.visit_assign(bind, expr);\n+                self.visit_bin_op(bind, expr);\n+            },\n+            ExprKind::Field(expr, _) => {\n+                self.visit_expr(expr);\n+                if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+                }\n+            },\n+            ExprKind::Index(expr, index) => {\n+                self.visit_expr(expr);\n+                let mut vars = std::mem::take(&mut self.ret_vars);\n+                self.visit_expr(index);\n+                self.ret_vars.append(&mut vars);\n+\n+                if !is_array(self.ty_res.expr_ty(expr)) {\n+                    self.add_side_effect(self.ret_vars.clone());\n+                } else if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+                }\n+            },\n+            ExprKind::Break(dest, Some(expr)) => {\n+                self.visit_expr(expr);\n+                if let Some(label) = dest.label {\n+                    self.break_vars\n+                        .entry(label.ident)\n+                        .or_insert(Vec::new())\n+                        .append(&mut self.ret_vars);\n+                }\n+                self.contains_side_effect = true;\n+            },\n+            ExprKind::Ret(Some(expr)) => {\n+                self.visit_expr(expr);\n+                let vars = std::mem::take(&mut self.ret_vars);\n+                self.add_side_effect(vars);\n+                self.contains_side_effect = true;\n+            },\n+            ExprKind::Break(_, None) | ExprKind::Continue(_) | ExprKind::Ret(None) => {\n+                self.contains_side_effect = true;\n+            },\n+            ExprKind::Struct(_, exprs, expr) => {\n+                let mut ret_vars = exprs\n+                    .iter()\n+                    .flat_map(|field| {\n+                        self.visit_expr(field.expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+\n+                walk_list!(self, visit_expr, expr);\n+                self.ret_vars.append(&mut ret_vars);\n+            },\n+            _ => walk_expr(self, ex),\n+        }\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx Path<'tcx>, _id: HirId) {\n+        if let Res::Local(id) = path.res {\n+            self.ret_vars.push((id, false));\n+        }\n+    }\n+}\n+\n+impl<'tcx> SideEffectVisit<'tcx> {\n+    fn visit_assign(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n+        // Just support array and tuple unwrapping for now.\n+        //\n+        // ex) `(a, b) = (c, d);`\n+        // The graph would look like this:\n+        //   a -> c\n+        //   b -> d\n+        //\n+        // This would minimize the connection of the side-effect graph.\n+        match (&lhs.kind, &rhs.kind) {\n+            (ExprKind::Array(lhs), ExprKind::Array(rhs)) | (ExprKind::Tup(lhs), ExprKind::Tup(rhs)) => {\n+                // if not, it is a compile error\n+                debug_assert!(lhs.len() == rhs.len());\n+                izip!(*lhs, *rhs).for_each(|(lhs, rhs)| self.visit_assign(lhs, rhs));\n+            },\n+            // in other assigns, we have to connect all each other\n+            // because they can be connected somehow\n+            _ => {\n+                self.visit_expr(lhs);\n+                let lhs_vars = std::mem::take(&mut self.ret_vars);\n+                self.visit_expr(rhs);\n+                let rhs_vars = std::mem::take(&mut self.ret_vars);\n+                self.connect_assign(&lhs_vars, &rhs_vars, false);\n+            },\n+        }\n+    }\n+\n+    fn visit_block_label(&mut self, block: &'tcx Block<'tcx>, label: Option<Label>) {\n+        self.visit_block(block);\n+        let _ = label.and_then(|label| {\n+            self.break_vars\n+                .remove(&label.ident)\n+                .map(|mut break_vars| self.ret_vars.append(&mut break_vars))\n+        });\n+    }\n+\n+    fn visit_bin_op(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n+        self.visit_expr(lhs);\n+        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n+        self.visit_expr(rhs);\n+        self.ret_vars.append(&mut ret_vars);\n+\n+        // the binary operation between non primitive values are overloaded operators\n+        // so they can have side-effects\n+        if !is_primitive(self.ty_res.expr_ty(lhs)) || !is_primitive(self.ty_res.expr_ty(rhs)) {\n+            self.ret_vars.iter().for_each(|id| {\n+                self.has_side_effect.insert(id.0);\n+            });\n+            self.contains_side_effect = true;\n+        }\n+    }\n+\n+    fn visit_un_op(&mut self, op: UnOp, expr: &'tcx Expr<'tcx>) {\n+        self.visit_expr(expr);\n+        let ty = self.ty_res.expr_ty(expr);\n+        // dereferencing a reference has no side-effect\n+        if !is_primitive(ty) && !matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(..))) {\n+            self.add_side_effect(self.ret_vars.clone());\n+        }\n+\n+        if matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(_, _, Mutability::Mut))) {\n+            self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+        }\n+    }\n+\n+    fn visit_pat_expr(&mut self, pat: &'tcx Pat<'tcx>, expr: &'tcx Expr<'tcx>, connect_self: bool) {\n+        match (&pat.kind, &expr.kind) {\n+            (PatKind::Tuple(pats, _), ExprKind::Tup(exprs)) => {\n+                self.ret_vars = izip!(*pats, *exprs)\n+                    .flat_map(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr, connect_self);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+            },\n+            (PatKind::Slice(front_exprs, _, back_exprs), ExprKind::Array(exprs)) => {\n+                let mut vars = izip!(*front_exprs, *exprs)\n+                    .flat_map(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr, connect_self);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+                self.ret_vars = izip!(back_exprs.iter().rev(), exprs.iter().rev())\n+                    .flat_map(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr, connect_self);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+                self.ret_vars.append(&mut vars);\n+            },\n+            _ => {\n+                let mut lhs_vars = Vec::new();\n+                pat.each_binding(|_, id, _, _| lhs_vars.push((id, false)));\n+                self.visit_expr(expr);\n+                let rhs_vars = std::mem::take(&mut self.ret_vars);\n+                self.connect_assign(&lhs_vars, &rhs_vars, connect_self);\n+                self.ret_vars = rhs_vars;\n+            },\n+        }\n+    }\n+\n+    fn visit_fn(&mut self, callee: &'tcx Expr<'tcx>, args: &'tcx [Expr<'tcx>]) {\n+        self.visit_expr(callee);\n+        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n+        self.add_side_effect(ret_vars.clone());\n+\n+        let mut is_recursive = false;\n+\n+        if_chain! {\n+            if !self.has_self;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = callee.kind;\n+            if let Res::Def(DefKind::Fn, def_id) = path.res;\n+            if self.fn_def_id == def_id;\n+            then {\n+                is_recursive = true;\n+            }\n+        }\n+\n+        if_chain! {\n+            if !self.has_self && self.is_method;\n+            if let ExprKind::Path(QPath::TypeRelative(ty, segment)) = callee.kind;\n+            if segment.ident == self.fn_ident;\n+            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n+            if let Res::SelfTy{ .. } = path.res;\n+            then {\n+                is_recursive = true;\n+            }\n+        }\n+\n+        if is_recursive {\n+            izip!(self.params.clone(), args).for_each(|(pat, expr)| {\n+                self.visit_pat_expr(pat, expr, true);\n+                self.ret_vars.clear();\n+            });\n+        } else {\n+            // This would set arguments used in closure that does not have side-effect.\n+            // Closure itself can be detected whether there is a side-effect, but the\n+            // value of variable that is holding closure can change.\n+            // So, we just check the variables.\n+            self.ret_vars = args\n+                .iter()\n+                .flat_map(|expr| {\n+                    self.visit_expr(expr);\n+                    std::mem::take(&mut self.ret_vars)\n+                })\n+                .collect_vec()\n+                .into_iter()\n+                .map(|id| {\n+                    self.has_side_effect.insert(id.0);\n+                    id\n+                })\n+                .collect();\n+            self.contains_side_effect = true;\n+        }\n+\n+        self.ret_vars.append(&mut ret_vars);\n+    }\n+\n+    fn visit_method_call(&mut self, path: &'tcx PathSegment<'tcx>, args: &'tcx [Expr<'tcx>]) {\n+        if_chain! {\n+            if self.is_method;\n+            if path.ident == self.fn_ident;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = args.first().unwrap().kind;\n+            if let Res::Local(..) = path.res;\n+            let ident = path.segments.last().unwrap().ident;\n+            if ident.name == kw::SelfLower;\n+            then {\n+                izip!(self.params.clone(), args.iter())\n+                    .for_each(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr, true);\n+                        self.ret_vars.clear();\n+                    });\n+            } else {\n+                self.ret_vars = args\n+                    .iter()\n+                    .flat_map(|expr| {\n+                        self.visit_expr(expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect_vec()\n+                    .into_iter()\n+                    .map(|a| {\n+                        self.has_side_effect.insert(a.0);\n+                        a\n+                    })\n+                    .collect();\n+                self.contains_side_effect = true;\n+            }\n+        }\n+    }\n+\n+    fn visit_if(&mut self, bind: &'tcx Expr<'tcx>, then_expr: &'tcx Expr<'tcx>, else_expr: Option<&'tcx Expr<'tcx>>) {\n+        let contains_side_effect = self.contains_side_effect;\n+        self.contains_side_effect = false;\n+        self.visit_expr(bind);\n+        let mut vars = std::mem::take(&mut self.ret_vars);\n+        self.visit_expr(then_expr);\n+        let mut then_vars = std::mem::take(&mut self.ret_vars);\n+        walk_list!(self, visit_expr, else_expr);\n+        if self.contains_side_effect {\n+            self.add_side_effect(vars.clone());\n+        }\n+        self.contains_side_effect |= contains_side_effect;\n+        self.ret_vars.append(&mut vars);\n+        self.ret_vars.append(&mut then_vars);\n+    }\n+\n+    fn visit_match(&mut self, expr: &'tcx Expr<'tcx>, arms: &'tcx [Arm<'tcx>]) {\n+        self.visit_expr(expr);\n+        let mut expr_vars = std::mem::take(&mut self.ret_vars);\n+        self.ret_vars = arms\n+            .iter()\n+            .flat_map(|arm| {\n+                let contains_side_effect = self.contains_side_effect;\n+                self.contains_side_effect = false;\n+                // this would visit `expr` multiple times\n+                // but couldn't think of a better way\n+                self.visit_pat_expr(arm.pat, expr, false);\n+                let mut vars = std::mem::take(&mut self.ret_vars);\n+                let _ = arm.guard.as_ref().map(|guard| {\n+                    self.visit_expr(match guard {\n+                        Guard::If(expr) | Guard::IfLet(_, expr) => expr,\n+                    });\n+                    vars.append(&mut self.ret_vars);\n+                });\n+                self.visit_expr(arm.body);\n+                if self.contains_side_effect {\n+                    self.add_side_effect(vars.clone());\n+                    self.add_side_effect(expr_vars.clone());\n+                }\n+                self.contains_side_effect |= contains_side_effect;\n+                vars.append(&mut self.ret_vars);\n+                vars\n+            })\n+            .collect();\n+        self.ret_vars.append(&mut expr_vars);\n+    }\n+\n+    fn connect_assign(&mut self, lhs: &[(HirId, bool)], rhs: &[(HirId, bool)], connect_self: bool) {\n+        // if mutable dereference is on assignment it can have side-effect\n+        // (this can lead to parameter mutable dereference and change the original value)\n+        // too hard to detect whether this value is from parameter, so this would all\n+        // check mutable dereference assignment to side effect\n+        lhs.iter().filter(|(_, b)| *b).for_each(|(id, _)| {\n+            self.has_side_effect.insert(*id);\n+            self.contains_side_effect = true;\n+        });\n+\n+        // there is no connection\n+        if lhs.is_empty() || rhs.is_empty() {\n+            return;\n+        }\n+\n+        // by connected rhs in cycle, the connections would decrease\n+        // from `n * m` to `n + m`\n+        // where `n` and `m` are length of `lhs` and `rhs`.\n+\n+        // unwrap is possible since rhs is not empty\n+        let rhs_first = rhs.first().unwrap();\n+        for (id, _) in lhs.iter() {\n+            if connect_self || *id != rhs_first.0 {\n+                self.graph\n+                    .entry(*id)\n+                    .or_insert_with(FxHashSet::default)\n+                    .insert(rhs_first.0);\n+            }\n+        }\n+\n+        let rhs = rhs.iter();\n+        izip!(rhs.clone().cycle().skip(1), rhs).for_each(|(from, to)| {\n+            if connect_self || from.0 != to.0 {\n+                self.graph.entry(from.0).or_insert_with(FxHashSet::default).insert(to.0);\n+            }\n+        });\n+    }\n+\n+    fn add_side_effect(&mut self, v: Vec<(HirId, bool)>) {\n+        for (id, _) in v {\n+            self.has_side_effect.insert(id);\n+            self.contains_side_effect = true;\n+        }\n+    }\n+}"}, {"sha": "899568a933f7afe196b890a5f81e146aca01ec2a", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -123,7 +123,7 @@ impl QuestionMark {\n     }\n \n     fn result_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n-        Self::is_result(cx, expr) && Self::expression_returns_unmodified_err(cx, nested_expr, expr)\n+        Self::is_result(cx, expr) && Self::expression_returns_unmodified_err(nested_expr, expr)\n     }\n \n     fn option_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n@@ -156,9 +156,9 @@ impl QuestionMark {\n         }\n     }\n \n-    fn expression_returns_unmodified_err(cx: &LateContext<'_>, expr: &Expr<'_>, cond_expr: &Expr<'_>) -> bool {\n+    fn expression_returns_unmodified_err(expr: &Expr<'_>, cond_expr: &Expr<'_>) -> bool {\n         match peel_blocks_with_stmt(expr).kind {\n-            ExprKind::Ret(Some(ret_expr)) => Self::expression_returns_unmodified_err(cx, ret_expr, cond_expr),\n+            ExprKind::Ret(Some(ret_expr)) => Self::expression_returns_unmodified_err(ret_expr, cond_expr),\n             ExprKind::Path(_) => path_to_local(expr).is_some() && path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n         }"}, {"sha": "e213c208794c1d4d0dd43c6a995de040b99bfa9a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -330,7 +330,7 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;\n         if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n-        if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n+        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n         then {\n             span_lint(cx,\n                 RANGE_ZIP_WITH_LEN,"}, {"sha": "1507c75ff612314236bb2b2ed5be935a9fa9088e", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{has_drop, is_copy, is_type_diagnostic_item, walk_ptrs_ty_depth};\n use clippy_utils::{fn_has_unsatisfiable_preds, match_def_path, paths};\n use if_chain::if_chain;\n-use rustc_data_structures::{fx::FxHashMap, transitive_relation::TransitiveRelation};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{def_id, Body, FnDecl, HirId};\n@@ -512,7 +512,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeStorageLive {\n /// For example, `b = &a; c = &a;` will make `b` and (transitively) `c`\n /// possible borrowers of `a`.\n struct PossibleBorrowerVisitor<'a, 'tcx> {\n-    possible_borrower: TransitiveRelation<mir::Local>,\n+    possible_borrower: TransitiveRelation,\n     body: &'a mir::Body<'tcx>,\n     cx: &'a LateContext<'tcx>,\n     possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n@@ -543,18 +543,10 @@ impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n                 continue;\n             }\n \n-            let borrowers = self.possible_borrower.reachable_from(row);\n+            let mut borrowers = self.possible_borrower.reachable_from(row, self.body.local_decls.len());\n+            borrowers.remove(mir::Local::from_usize(0));\n             if !borrowers.is_empty() {\n-                let mut bs = HybridBitSet::new_empty(self.body.local_decls.len());\n-                for c in borrowers {\n-                    if c != mir::Local::from_usize(0) {\n-                        bs.insert(c);\n-                    }\n-                }\n-\n-                if !bs.is_empty() {\n-                    map.insert(row, bs);\n-                }\n+                map.insert(row, borrowers);\n             }\n         }\n \n@@ -644,7 +636,7 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n /// For exampel, `_1 = &mut _2` generate _1: {_2,...}\n /// Known Problems: not sure all borrowed are tracked\n struct PossibleOriginVisitor<'a, 'tcx> {\n-    possible_origin: TransitiveRelation<mir::Local>,\n+    possible_origin: TransitiveRelation,\n     body: &'a mir::Body<'tcx>,\n }\n \n@@ -663,18 +655,10 @@ impl<'a, 'tcx> PossibleOriginVisitor<'a, 'tcx> {\n                 continue;\n             }\n \n-            let borrowers = self.possible_origin.reachable_from(row);\n+            let mut borrowers = self.possible_origin.reachable_from(row, self.body.local_decls.len());\n+            borrowers.remove(mir::Local::from_usize(0));\n             if !borrowers.is_empty() {\n-                let mut bs = HybridBitSet::new_empty(self.body.local_decls.len());\n-                for c in borrowers {\n-                    if c != mir::Local::from_usize(0) {\n-                        bs.insert(c);\n-                    }\n-                }\n-\n-                if !bs.is_empty() {\n-                    map.insert(row, bs);\n-                }\n+                map.insert(row, borrowers);\n             }\n         }\n         map\n@@ -766,3 +750,28 @@ impl PossibleBorrowerMap<'_, '_> {\n         self.maybe_live.contains(local)\n     }\n }\n+\n+#[derive(Default)]\n+struct TransitiveRelation {\n+    relations: FxHashMap<mir::Local, Vec<mir::Local>>,\n+}\n+impl TransitiveRelation {\n+    fn add(&mut self, a: mir::Local, b: mir::Local) {\n+        self.relations.entry(a).or_default().push(b);\n+    }\n+\n+    fn reachable_from(&self, a: mir::Local, domain_size: usize) -> HybridBitSet<mir::Local> {\n+        let mut seen = HybridBitSet::new_empty(domain_size);\n+        let mut stack = vec![a];\n+        while let Some(u) = stack.pop() {\n+            if let Some(edges) = self.relations.get(&u) {\n+                for &v in edges {\n+                    if seen.insert(v) {\n+                        stack.push(v);\n+                    }\n+                }\n+            }\n+        }\n+        seen\n+    }\n+}"}, {"sha": "940a8428f77950c5900103f27daf2d1799f0a07f", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -399,9 +399,9 @@ fn if_statment_binops(kind: &ExprKind) -> Option<Vec<BinaryOp<'_>>> {\n \n fn append_opt_vecs<A>(target_opt: Option<Vec<A>>, source_opt: Option<Vec<A>>) -> Option<Vec<A>> {\n     match (target_opt, source_opt) {\n-        (Some(mut target), Some(mut source)) => {\n+        (Some(mut target), Some(source)) => {\n             target.reserve(source.len());\n-            for op in source.drain(..) {\n+            for op in source {\n                 target.push(op);\n             }\n             Some(target)\n@@ -436,9 +436,9 @@ fn chained_binops_helper<'expr>(left_outer: &'expr Expr, right_outer: &'expr Exp\n             chained_binops_helper(left_left, left_right),\n             chained_binops_helper(right_left, right_right),\n         ) {\n-            (Some(mut left_ops), Some(mut right_ops)) => {\n+            (Some(mut left_ops), Some(right_ops)) => {\n                 left_ops.reserve(right_ops.len());\n-                for op in right_ops.drain(..) {\n+                for op in right_ops {\n                     left_ops.push(op);\n                 }\n                 Some(left_ops)"}, {"sha": "23cb9d40dfdc9143cd4eb34cdfee83956579e618", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -364,6 +364,10 @@ declare_clippy_lint! {\n     /// ### Why is this bad?\n     /// The results of such a transmute are not defined.\n     ///\n+    /// ### Known problems\n+    /// This lint has had multiple problems in the past and was moved to `nursery`. See issue\n+    /// [#8496](https://github.com/rust-lang/rust-clippy/issues/8496) for more details.\n+    ///\n     /// ### Example\n     /// ```rust\n     /// struct Foo<T>(u32, T);"}, {"sha": "d371cafb16b13e017d8cdf7b160193753543636c", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -67,59 +67,51 @@ struct SortByKeyDetection {\n \n /// Detect if the two expressions are mirrored (identical, except one\n /// contains a and the other replaces it with b)\n-fn mirrored_exprs(\n-    cx: &LateContext<'_>,\n-    a_expr: &Expr<'_>,\n-    a_ident: &Ident,\n-    b_expr: &Expr<'_>,\n-    b_ident: &Ident,\n-) -> bool {\n+fn mirrored_exprs(a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident: &Ident) -> bool {\n     match (&a_expr.kind, &b_expr.kind) {\n         // Two boxes with mirrored contents\n         (ExprKind::Box(left_expr), ExprKind::Box(right_expr)) => {\n-            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+            mirrored_exprs(left_expr, a_ident, right_expr, b_ident)\n         },\n         // Two arrays with mirrored contents\n         (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs)) => {\n-            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // The two exprs are function calls.\n         // Check to see that the function itself and its arguments are mirrored\n         (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args)) => {\n-            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n-                && iter::zip(*left_args, *right_args)\n-                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            mirrored_exprs(left_expr, a_ident, right_expr, b_ident)\n+                && iter::zip(*left_args, *right_args).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n         (ExprKind::MethodCall(left_segment, left_args, _), ExprKind::MethodCall(right_segment, right_args, _)) => {\n             left_segment.ident == right_segment.ident\n-                && iter::zip(*left_args, *right_args)\n-                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+                && iter::zip(*left_args, *right_args).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // Two tuples with mirrored contents\n         (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => {\n-            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // Two binary ops, which are the same operation and which have mirrored arguments\n         (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right)) => {\n             left_op.node == right_op.node\n-                && mirrored_exprs(cx, left_left, a_ident, right_left, b_ident)\n-                && mirrored_exprs(cx, left_right, a_ident, right_right, b_ident)\n+                && mirrored_exprs(left_left, a_ident, right_left, b_ident)\n+                && mirrored_exprs(left_right, a_ident, right_right, b_ident)\n         },\n         // Two unary ops, which are the same operation and which have the same argument\n         (ExprKind::Unary(left_op, left_expr), ExprKind::Unary(right_op, right_expr)) => {\n-            left_op == right_op && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+            left_op == right_op && mirrored_exprs(left_expr, a_ident, right_expr, b_ident)\n         },\n         // The two exprs are literals of some kind\n         (ExprKind::Lit(left_lit), ExprKind::Lit(right_lit)) => left_lit.node == right_lit.node,\n-        (ExprKind::Cast(left, _), ExprKind::Cast(right, _)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n+        (ExprKind::Cast(left, _), ExprKind::Cast(right, _)) => mirrored_exprs(left, a_ident, right, b_ident),\n         (ExprKind::DropTemps(left_block), ExprKind::DropTemps(right_block)) => {\n-            mirrored_exprs(cx, left_block, a_ident, right_block, b_ident)\n+            mirrored_exprs(left_block, a_ident, right_block, b_ident)\n         },\n         (ExprKind::Field(left_expr, left_ident), ExprKind::Field(right_expr, right_ident)) => {\n-            left_ident.name == right_ident.name && mirrored_exprs(cx, left_expr, a_ident, right_expr, right_ident)\n+            left_ident.name == right_ident.name && mirrored_exprs(left_expr, a_ident, right_expr, right_ident)\n         },\n         // Two paths: either one is a and the other is b, or they're identical to each other\n         (\n@@ -151,11 +143,9 @@ fn mirrored_exprs(\n         (\n             ExprKind::AddrOf(left_kind, Mutability::Not, left_expr),\n             ExprKind::AddrOf(right_kind, Mutability::Not, right_expr),\n-        ) => left_kind == right_kind && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n-        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr)) => {\n-            mirrored_exprs(cx, a_expr, a_ident, right_expr, b_ident)\n-        },\n-        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _) => mirrored_exprs(cx, left_expr, a_ident, b_expr, b_ident),\n+        ) => left_kind == right_kind && mirrored_exprs(left_expr, a_ident, right_expr, b_ident),\n+        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr)) => mirrored_exprs(a_expr, a_ident, right_expr, b_ident),\n+        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _) => mirrored_exprs(left_expr, a_ident, b_expr, b_ident),\n         _ => false,\n     }\n }\n@@ -176,14 +166,13 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n         if method_path.ident.name == sym::cmp;\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n-                cx,\n                 left_expr,\n                 left_ident,\n                 right_expr,\n                 right_ident\n             ) {\n                 (Sugg::hir(cx, left_expr, \"..\").to_string(), left_ident.name.to_string(), false)\n-            } else if mirrored_exprs(cx, left_expr, right_ident, right_expr, left_ident) {\n+            } else if mirrored_exprs(left_expr, right_ident, right_expr, left_ident) {\n                 (Sugg::hir(cx, left_expr, \"..\").to_string(), right_ident.name.to_string(), true)\n             } else {\n                 return None;\n@@ -239,7 +228,7 @@ impl LateLintPass<'_> for UnnecessarySortBy {\n                     if trigger.unstable { \"_unstable\" } else { \"\" },\n                     trigger.closure_arg,\n                     if trigger.reverse {\n-                        format!(\"Reverse({})\", trigger.closure_body)\n+                        format!(\"std::cmp::Reverse({})\", trigger.closure_body)\n                     } else {\n                         trigger.closure_body.to_string()\n                     },"}, {"sha": "09d671e11184d6e2e456909b3326af74b6ce3c04", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -9,7 +9,8 @@ use rustc_hir::{\n     def::{CtorOf, DefKind, Res},\n     def_id::LocalDefId,\n     intravisit::{walk_inf, walk_ty, Visitor},\n-    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Path, QPath, TyKind,\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Pat, PatKind, Path, QPath,\n+    TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_semver::RustcVersion;\n@@ -252,6 +253,22 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n         }\n     }\n \n+    fn check_pat(&mut self, cx: &LateContext<'_>, pat: &Pat<'_>) {\n+        if_chain! {\n+            if !pat.span.from_expansion();\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n+            if let Some(&StackItem::Check { impl_id, .. }) = self.stack.last();\n+            if let PatKind::Path(QPath::Resolved(_, path)) = pat.kind;\n+            if !matches!(path.res, Res::SelfTy { .. } | Res::Def(DefKind::TyParam, _));\n+            if cx.typeck_results().pat_ty(pat) == cx.tcx.type_of(impl_id);\n+            if let [first, ..] = path.segments;\n+            if let Some(hir_id) = first.hir_id;\n+            then {\n+                span_lint(cx, cx.tcx.hir().span(hir_id));\n+            }\n+        }\n+    }\n+\n     extract_msrv_attr!(LateContext);\n }\n "}, {"sha": "b3b241392fed5d172d7f2649236feeb0318d352d", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -25,7 +25,7 @@ use rustc_hir::{\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::mir::interpret::ConstValue;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, subst::GenericArgKind};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Spanned;\n@@ -337,6 +337,15 @@ declare_clippy_lint! {\n     \"found clippy lint without `clippy::version` attribute\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check that the `extract_msrv_attr!` macro is used, when a lint has a MSRV.\n+    ///\n+    pub MISSING_MSRV_ATTR_IMPL,\n+    internal,\n+    \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -1314,3 +1323,46 @@ fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: S\n         span.parent(),\n     )\n }\n+\n+declare_lint_pass!(MsrvAttrImpl => [MISSING_MSRV_ATTR_IMPL]);\n+\n+impl LateLintPass<'_> for MsrvAttrImpl {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n+        if_chain! {\n+            if let hir::ItemKind::Impl(hir::Impl {\n+                of_trait: Some(lint_pass_trait_ref),\n+                self_ty,\n+                items,\n+                ..\n+            }) = &item.kind;\n+            if let Some(lint_pass_trait_def_id) = lint_pass_trait_ref.trait_def_id();\n+            let is_late_pass = match_def_path(cx, lint_pass_trait_def_id, &paths::LATE_LINT_PASS);\n+            if is_late_pass || match_def_path(cx, lint_pass_trait_def_id, &paths::EARLY_LINT_PASS);\n+            let self_ty = hir_ty_to_ty(cx.tcx, self_ty);\n+            if let ty::Adt(self_ty_def, _) = self_ty.kind();\n+            if self_ty_def.is_struct();\n+            if self_ty_def.all_fields().any(|f| {\n+                cx.tcx\n+                    .type_of(f.did)\n+                    .walk()\n+                    .filter(|t| matches!(t.unpack(), GenericArgKind::Type(_)))\n+                    .any(|t| match_type(cx, t.expect_ty(), &paths::RUSTC_VERSION))\n+            });\n+            if !items.iter().any(|item| item.ident.name == sym!(enter_lint_attrs));\n+            then {\n+                let context = if is_late_pass { \"LateContext\" } else { \"EarlyContext\" };\n+                let lint_pass = if is_late_pass { \"LateLintPass\" } else { \"EarlyLintPass\" };\n+                let span = cx.sess().source_map().span_through_char(item.span, '{');\n+                span_lint_and_sugg(\n+                    cx,\n+                    MISSING_MSRV_ATTR_IMPL,\n+                    span,\n+                    &format!(\"`extract_msrv_attr!` macro missing from `{lint_pass}` implementation\"),\n+                    &format!(\"add `extract_msrv_attr!({context})` to the `{lint_pass}` implementation\"),\n+                    format!(\"{}\\n    extract_msrv_attr!({context});\", snippet(cx, span, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "a617422bbeb0457d42b136b5fd690bec2dbbc54b", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -473,7 +473,7 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n     /// ```\n     fn check_expr(&mut self, cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>) {\n         if let Some(args) = match_lint_emission(cx, expr) {\n-            let mut emission_info = extract_emission_info(cx, args);\n+            let emission_info = extract_emission_info(cx, args);\n             if emission_info.is_empty() {\n                 // See:\n                 // - src/misc.rs:734:9\n@@ -483,7 +483,7 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n                 return;\n             }\n \n-            for (lint_name, applicability, is_multi_part) in emission_info.drain(..) {\n+            for (lint_name, applicability, is_multi_part) in emission_info {\n                 let app_info = self.applicability_info.entry(lint_name).or_default();\n                 app_info.applicability = applicability;\n                 app_info.is_multi_part_suggestion = is_multi_part;\n@@ -693,7 +693,7 @@ fn extract_emission_info<'hir>(\n     }\n \n     lints\n-        .drain(..)\n+        .into_iter()\n         .map(|lint_name| (lint_name, applicability, multi_part))\n         .collect()\n }"}, {"sha": "532bd810a2e30fd852ad0f55d432840ea3504044", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -7,7 +7,7 @@ use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n use rustc_ast::ast::{Expr, ExprKind, Impl, Item, ItemKind, MacCall, Path, StrLit, StrStyle};\n use rustc_ast::token::{self, LitKind};\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_lexer::unescape::{self, EscapeError};\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_parse::parser;\n@@ -534,7 +534,7 @@ impl Write {\n             match parser\n                 .parse_expr()\n                 .map(rustc_ast::ptr::P::into_inner)\n-                .map_err(|e| e.cancel())\n+                .map_err(DiagnosticBuilder::cancel)\n             {\n                 // write!(e, ...)\n                 Ok(p) if parser.eat(&token::Comma) => Some(p),\n@@ -563,7 +563,7 @@ impl Write {\n             }\n \n             let comma_span = parser.prev_token.span;\n-            let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|err| err.cancel()) {\n+            let token_expr = if let Ok(expr) = parser.parse_expr().map_err(DiagnosticBuilder::cancel) {\n                 expr\n             } else {\n                 return (Some(fmtstr), None);"}, {"sha": "3fce4987679ad595b4479511cccf95a77ba32ffd", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -279,8 +279,22 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n         (ForeignMod(l), ForeignMod(r)) => {\n             both(&l.abi, &r.abi, eq_str_lit) && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))\n         },\n-        (TyAlias(box ast::TyAlias { defaultness: ld, generics: lg, bounds: lb, ty: lt, .. }),\n-         TyAlias(box ast::TyAlias { defaultness: rd, generics: rg, bounds: rb, ty: rt, .. })) => {\n+        (\n+            TyAlias(box ast::TyAlias {\n+                defaultness: ld,\n+                generics: lg,\n+                bounds: lb,\n+                ty: lt,\n+                ..\n+            }),\n+            TyAlias(box ast::TyAlias {\n+                defaultness: rd,\n+                generics: rg,\n+                bounds: rb,\n+                ty: rt,\n+                ..\n+            }),\n+        ) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n                 && over(lb, rb, eq_generic_bound)\n@@ -370,8 +384,22 @@ pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n         ) => {\n             eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n         },\n-        (TyAlias(box ast::TyAlias { defaultness: ld, generics: lg, bounds: lb, ty: lt, .. }),\n-         TyAlias(box ast::TyAlias { defaultness: rd, generics: rg, bounds: rb, ty: rt, .. })) => {\n+        (\n+            TyAlias(box ast::TyAlias {\n+                defaultness: ld,\n+                generics: lg,\n+                bounds: lb,\n+                ty: lt,\n+                ..\n+            }),\n+            TyAlias(box ast::TyAlias {\n+                defaultness: rd,\n+                generics: rg,\n+                bounds: rb,\n+                ty: rt,\n+                ..\n+            }),\n+        ) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n                 && over(lb, rb, eq_generic_bound)\n@@ -402,8 +430,22 @@ pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n         ) => {\n             eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n         },\n-        (TyAlias(box ast::TyAlias { defaultness: ld, generics: lg, bounds: lb, ty: lt, .. }),\n-         TyAlias(box ast::TyAlias { defaultness: rd, generics: rg, bounds: rb, ty: rt, .. })) => {\n+        (\n+            TyAlias(box ast::TyAlias {\n+                defaultness: ld,\n+                generics: lg,\n+                bounds: lb,\n+                ty: lt,\n+                ..\n+            }),\n+            TyAlias(box ast::TyAlias {\n+                defaultness: rd,\n+                generics: rg,\n+                bounds: rb,\n+                ty: rt,\n+                ..\n+            }),\n+        ) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n                 && over(lb, rb, eq_generic_bound)"}, {"sha": "1d6f7acab139bf8c7b2f31cb2da8ad0f59564ae7", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -593,7 +593,8 @@ pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty().kind() {\n             ty::Ref(_, tam, _) => match tam.kind() {\n                 ty::Str => String::from_utf8(\n-                    data.inner().inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n+                    data.inner()\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n                         .to_owned(),\n                 )\n                 .ok()\n@@ -605,7 +606,8 @@ pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n         ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty().kind() {\n             ty::Array(sub_type, len) => match sub_type.kind() {\n                 ty::Float(FloatTy::F32) => match miri_to_const(*len) {\n-                    Some(Constant::Int(len)) => alloc.inner()\n+                    Some(Constant::Int(len)) => alloc\n+                        .inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n                         .to_owned()\n                         .chunks(4)\n@@ -619,7 +621,8 @@ pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n                     _ => None,\n                 },\n                 ty::Float(FloatTy::F64) => match miri_to_const(*len) {\n-                    Some(Constant::Int(len)) => alloc.inner()\n+                    Some(Constant::Int(len)) => alloc\n+                        .inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n                         .to_owned()\n                         .chunks(8)"}, {"sha": "00594f4d42addb594875349a2e6e2e031e24423a", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -74,6 +74,10 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         self.inter_expr().eq_expr(left, right)\n     }\n \n+    pub fn eq_path(&mut self, left: &Path<'_>, right: &Path<'_>) -> bool {\n+        self.inter_expr().eq_path(left, right)\n+    }\n+\n     pub fn eq_path_segment(&mut self, left: &PathSegment<'_>, right: &PathSegment<'_>) -> bool {\n         self.inter_expr().eq_path_segment(left, right)\n     }\n@@ -362,7 +366,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n         }\n     }\n \n-    fn eq_path(&mut self, left: &Path<'_>, right: &Path<'_>) -> bool {\n+    pub fn eq_path(&mut self, left: &Path<'_>, right: &Path<'_>) -> bool {\n         match (left.res, right.res) {\n             (Res::Local(l), Res::Local(r)) => l == r || self.locals.get(&l) == Some(&r),\n             (Res::Local(_), _) | (_, Res::Local(_)) => false,"}, {"sha": "fce93153d96ec1841eae99b5ec3b584e22c2e261", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -20,7 +20,7 @@ msrv_aliases! {\n     1,46,0 { CONST_IF_MATCH }\n     1,45,0 { STR_STRIP_PREFIX }\n     1,43,0 { LOG2_10, LOG10_2 }\n-    1,42,0 { MATCHES_MACRO, SLICE_PATTERNS }\n+    1,42,0 { MATCHES_MACRO, SLICE_PATTERNS, PTR_SLICE_RAW_PARTS }\n     1,41,0 { RE_REBALANCING_COHERENCE, RESULT_MAP_OR_ELSE }\n     1,40,0 { MEM_TAKE, NON_EXHAUSTIVE, OPTION_AS_DEREF }\n     1,38,0 { POINTER_CAST }"}, {"sha": "6f56f8d51365a9407e2a36ce6205ac6a1719c789", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -32,6 +32,8 @@ pub const DIR_BUILDER: [&str; 3] = [\"std\", \"fs\", \"DirBuilder\"];\n pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n #[cfg(feature = \"internal\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n+#[cfg(feature = \"internal\")]\n+pub const EARLY_LINT_PASS: [&str; 3] = [\"rustc_lint\", \"passes\", \"EarlyLintPass\"];\n pub const EXIT: [&str; 3] = [\"std\", \"process\", \"exit\"];\n pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n pub const F64_EPSILON: [&str; 4] = [\"core\", \"f64\", \"<impl f64>\", \"EPSILON\"];\n@@ -67,6 +69,8 @@ pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal\")]\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n #[cfg(feature = \"internal\")]\n+pub const LATE_LINT_PASS: [&str; 3] = [\"rustc_lint\", \"passes\", \"LateLintPass\"];\n+#[cfg(feature = \"internal\")]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MUTEX_GUARD: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"MutexGuard\"];\n pub const OPEN_OPTIONS: [&str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n@@ -126,6 +130,8 @@ pub const REGEX_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"unicode\", \"RegexSet\",\n pub const RESULT: [&str; 3] = [\"core\", \"result\", \"Result\"];\n pub const RESULT_ERR: [&str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n pub const RESULT_OK: [&str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n+#[cfg(feature = \"internal\")]\n+pub const RUSTC_VERSION: [&str; 2] = [\"rustc_semver\", \"RustcVersion\"];\n pub const RWLOCK_READ_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockReadGuard\"];\n pub const RWLOCK_WRITE_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const SERDE_DESERIALIZE: [&str; 3] = [\"serde\", \"de\", \"Deserialize\"];"}, {"sha": "e3fc76f4e1a26b16754cb1318df3745a8b1989a0", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -294,7 +294,11 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n /// Returns `false` if the `LangItem` is not defined.\n pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).map_or(false, |li| li == adt.did()),\n+        ty::Adt(adt, _) => cx\n+            .tcx\n+            .lang_items()\n+            .require(lang_item)\n+            .map_or(false, |li| li == adt.did()),\n         _ => false,\n     }\n }"}, {"sha": "10d39762043ea0e03b4cb89405c82f2a04661aa8", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -2,6 +2,6 @@ max_width = 120\n comment_width = 100\n match_block_trailing_comma = true\n wrap_comments = true\n-edition = \"2018\"\n+edition = \"2021\"\n error_on_line_overflow = true\n version = \"Two\""}, {"sha": "c9710e3db8e8d264e956dc8cb8e2eb04f07911dd", "filename": "tests/compile-test.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -34,6 +34,7 @@ static TEST_DEPENDENCIES: &[&str] = &[\n     \"syn\",\n     \"tokio\",\n     \"parking_lot\",\n+    \"rustc_semver\",\n ];\n \n // Test dependencies may need an `extern crate` here to ensure that they show up\n@@ -53,6 +54,8 @@ extern crate parking_lot;\n #[allow(unused_extern_crates)]\n extern crate quote;\n #[allow(unused_extern_crates)]\n+extern crate rustc_semver;\n+#[allow(unused_extern_crates)]\n extern crate syn;\n #[allow(unused_extern_crates)]\n extern crate tokio;\n@@ -165,7 +168,11 @@ fn run_ui() {\n     let _threads = VarGuard::set(\n         \"RUST_TEST_THREADS\",\n         // if RUST_TEST_THREADS is set, adhere to it, otherwise override it\n-        env::var(\"RUST_TEST_THREADS\").unwrap_or_else(|_| num_cpus::get().to_string()),\n+        env::var(\"RUST_TEST_THREADS\").unwrap_or_else(|_| {\n+            std::thread::available_parallelism()\n+                .map_or(1, std::num::NonZeroUsize::get)\n+                .to_string()\n+        }),\n     );\n     compiletest::run_tests(&config);\n }"}, {"sha": "900a8fffd4080cc9a6894c502b2b968ef0f1ff5a", "filename": "tests/ui-internal/invalid_msrv_attr_impl.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui-internal%2Finvalid_msrv_attr_impl.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui-internal%2Finvalid_msrv_attr_impl.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finvalid_msrv_attr_impl.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+\n+#![deny(clippy::internal)]\n+#![allow(clippy::missing_clippy_version_attribute)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_ast;\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+#[macro_use]\n+extern crate rustc_session;\n+use clippy_utils::extract_msrv_attr;\n+use rustc_hir::Expr;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+\n+declare_lint! {\n+    pub TEST_LINT,\n+    Warn,\n+    \"\"\n+}\n+\n+struct Pass {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl_lint_pass!(Pass => [TEST_LINT]);\n+\n+impl LateLintPass<'_> for Pass {\n+    extract_msrv_attr!(LateContext);\n+    fn check_expr(&mut self, _: &LateContext<'_>, _: &Expr<'_>) {}\n+}\n+\n+impl EarlyLintPass for Pass {\n+    extract_msrv_attr!(EarlyContext);\n+    fn check_expr(&mut self, _: &EarlyContext<'_>, _: &rustc_ast::Expr) {}\n+}\n+\n+fn main() {}"}, {"sha": "4bc8164db67b016513dfcba17210d10403894382", "filename": "tests/ui-internal/invalid_msrv_attr_impl.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui-internal%2Finvalid_msrv_attr_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui-internal%2Finvalid_msrv_attr_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finvalid_msrv_attr_impl.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,38 @@\n+// run-rustfix\n+\n+#![deny(clippy::internal)]\n+#![allow(clippy::missing_clippy_version_attribute)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_ast;\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+#[macro_use]\n+extern crate rustc_session;\n+use clippy_utils::extract_msrv_attr;\n+use rustc_hir::Expr;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+\n+declare_lint! {\n+    pub TEST_LINT,\n+    Warn,\n+    \"\"\n+}\n+\n+struct Pass {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl_lint_pass!(Pass => [TEST_LINT]);\n+\n+impl LateLintPass<'_> for Pass {\n+    fn check_expr(&mut self, _: &LateContext<'_>, _: &Expr<'_>) {}\n+}\n+\n+impl EarlyLintPass for Pass {\n+    fn check_expr(&mut self, _: &EarlyContext<'_>, _: &rustc_ast::Expr) {}\n+}\n+\n+fn main() {}"}, {"sha": "ddc06f0be1b3a005f5e6b128a4d9778c132e2063", "filename": "tests/ui-internal/invalid_msrv_attr_impl.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui-internal%2Finvalid_msrv_attr_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui-internal%2Finvalid_msrv_attr_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finvalid_msrv_attr_impl.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,32 @@\n+error: `extract_msrv_attr!` macro missing from `LateLintPass` implementation\n+  --> $DIR/invalid_msrv_attr_impl.rs:30:1\n+   |\n+LL | impl LateLintPass<'_> for Pass {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/invalid_msrv_attr_impl.rs:3:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::missing_msrv_attr_impl)]` implied by `#[deny(clippy::internal)]`\n+help: add `extract_msrv_attr!(LateContext)` to the `LateLintPass` implementation\n+   |\n+LL + impl LateLintPass<'_> for Pass {\n+LL +     extract_msrv_attr!(LateContext);\n+   |\n+\n+error: `extract_msrv_attr!` macro missing from `EarlyLintPass` implementation\n+  --> $DIR/invalid_msrv_attr_impl.rs:34:1\n+   |\n+LL | impl EarlyLintPass for Pass {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: add `extract_msrv_attr!(EarlyContext)` to the `EarlyLintPass` implementation\n+   |\n+LL + impl EarlyLintPass for Pass {\n+LL +     extract_msrv_attr!(EarlyContext);\n+   |\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "1a0d4e886576e07695ecb5083bdf456b10163e0d", "filename": "tests/ui/allow_attributes_without_reason.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fallow_attributes_without_reason.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fallow_attributes_without_reason.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fallow_attributes_without_reason.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,14 @@\n+#![feature(lint_reasons)]\n+#![deny(clippy::allow_attributes_without_reason)]\n+\n+// These should trigger the lint\n+#[allow(dead_code)]\n+#[allow(dead_code, deprecated)]\n+// These should be fine\n+#[allow(dead_code, reason = \"This should be allowed\")]\n+#[warn(dyn_drop, reason = \"Warnings can also have reasons\")]\n+#[warn(deref_nullptr)]\n+#[deny(deref_nullptr)]\n+#[forbid(deref_nullptr)]\n+\n+fn main() {}"}, {"sha": "cd040a144aaca8c35c299a4f9dca1a9e507c08fe", "filename": "tests/ui/allow_attributes_without_reason.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fallow_attributes_without_reason.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fallow_attributes_without_reason.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fallow_attributes_without_reason.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,23 @@\n+error: `allow` attribute without specifying a reason\n+  --> $DIR/allow_attributes_without_reason.rs:5:1\n+   |\n+LL | #[allow(dead_code)]\n+   | ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/allow_attributes_without_reason.rs:2:9\n+   |\n+LL | #![deny(clippy::allow_attributes_without_reason)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: try adding a reason at the end with `, reason = \"..\"`\n+\n+error: `allow` attribute without specifying a reason\n+  --> $DIR/allow_attributes_without_reason.rs:6:1\n+   |\n+LL | #[allow(dead_code, deprecated)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try adding a reason at the end with `, reason = \"..\"`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "cfe1cca2eba9490ffb277a4d18dc21a71910ffeb", "filename": "tests/ui/cast_slice_different_sizes.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fcast_slice_different_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fcast_slice_different_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_slice_different_sizes.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,39 @@\n+fn main() {\n+    let x: [i32; 3] = [1_i32, 2, 3];\n+    let r_x = &x;\n+    // Check casting through multiple bindings\n+    // Because it's separate, it does not check the cast back to something of the same size\n+    let a = r_x as *const [i32];\n+    let b = a as *const [u8];\n+    let c = b as *const [u32];\n+\n+    // loses data\n+    let loss = r_x as *const [i32] as *const [u8];\n+\n+    // Cast back to same size but different type loses no data, just type conversion\n+    // This is weird code but there's no reason for this lint specifically to fire *twice* on it\n+    let restore = r_x as *const [i32] as *const [u8] as *const [u32];\n+\n+    // Check casting through blocks is detected\n+    let loss_block_1 = { r_x as *const [i32] } as *const [u8];\n+    let loss_block_2 = {\n+        let _ = ();\n+        r_x as *const [i32]\n+    } as *const [u8];\n+\n+    // Check that resores of the same size are detected through blocks\n+    let restore_block_1 = { r_x as *const [i32] } as *const [u8] as *const [u32];\n+    let restore_block_2 = { ({ r_x as *const [i32] }) as *const [u8] } as *const [u32];\n+    let restore_block_3 = {\n+        let _ = ();\n+        ({\n+            let _ = ();\n+            r_x as *const [i32]\n+        }) as *const [u8]\n+    } as *const [u32];\n+\n+    // Check that the result of a long chain of casts is detected\n+    let long_chain_loss = r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const [u8];\n+    let long_chain_restore =\n+        r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const [u8] as *const [u32];\n+}"}, {"sha": "a37cec7cb3be0935e00772d85edc5d339e45005c", "filename": "tests/ui/cast_slice_different_sizes.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fcast_slice_different_sizes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fcast_slice_different_sizes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_slice_different_sizes.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,52 @@\n+error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:7:13\n+   |\n+LL |     let b = a as *const [u8];\n+   |             ^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(a as *const u8, ..)`\n+   |\n+   = note: `#[deny(clippy::cast_slice_different_sizes)]` on by default\n+\n+error: casting between raw pointers to `[u8]` (element size 1) and `[u32]` (element size 4) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:8:13\n+   |\n+LL |     let c = b as *const [u32];\n+   |             ^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(b as *const u32, ..)`\n+\n+error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:11:16\n+   |\n+LL |     let loss = r_x as *const [i32] as *const [u8];\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(r_x as *const [i32] as *const u8, ..)`\n+\n+error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:18:24\n+   |\n+LL |     let loss_block_1 = { r_x as *const [i32] } as *const [u8];\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts({ r_x as *const [i32] } as *const u8, ..)`\n+\n+error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:19:24\n+   |\n+LL |       let loss_block_2 = {\n+   |  ________________________^\n+LL | |         let _ = ();\n+LL | |         r_x as *const [i32]\n+LL | |     } as *const [u8];\n+   | |____________________^\n+   |\n+help: replace with `ptr::slice_from_raw_parts`\n+   |\n+LL ~     let loss_block_2 = core::ptr::slice_from_raw_parts({\n+LL +         let _ = ();\n+LL +         r_x as *const [i32]\n+LL ~     } as *const u8, ..);\n+   |\n+\n+error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:36:27\n+   |\n+LL |     let long_chain_loss = r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const [u8];\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const u8, ..)`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "4a5c597dda51fa3304afafe4174630eb62655db2", "filename": "tests/ui/crate_level_checks/no_std_main_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fcrate_level_checks%2Fno_std_main_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fcrate_level_checks%2Fno_std_main_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrate_level_checks%2Fno_std_main_recursion.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -12,12 +12,12 @@ static N: AtomicUsize = AtomicUsize::new(0);\n \n #[warn(clippy::main_recursion)]\n #[start]\n-fn main(argc: isize, argv: *const *const u8) -> isize {\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n     let x = N.load(Ordering::Relaxed);\n     N.store(x + 1, Ordering::Relaxed);\n \n     if x < 3 {\n-        main(argc, argv);\n+        main(_argc, _argv);\n     }\n \n     0"}, {"sha": "baf01174b6764b8663d97593018db1549480e9ea", "filename": "tests/ui/dbg_macro.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdbg_macro.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: --test\n #![warn(clippy::dbg_macro)]\n \n fn foo(n: u32) -> u32 {\n@@ -40,3 +41,8 @@ mod issue7274 {\n         dbg!(2);\n     });\n }\n+\n+#[test]\n+pub fn issue8481() {\n+    dbg!(1);\n+}"}, {"sha": "a3e7a7162e51dff7516e79451764518e33e6f6bf", "filename": "tests/ui/dbg_macro.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fdbg_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fdbg_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdbg_macro.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,5 +1,5 @@\n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:4:22\n+  --> $DIR/dbg_macro.rs:5:22\n    |\n LL |     if let Some(n) = dbg!(n.checked_sub(4)) { n } else { n }\n    |                      ^^^^^^^^^^^^^^^^^^^^^^\n@@ -11,7 +11,7 @@ LL |     if let Some(n) = n.checked_sub(4) { n } else { n }\n    |                      ~~~~~~~~~~~~~~~~\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:8:8\n+  --> $DIR/dbg_macro.rs:9:8\n    |\n LL |     if dbg!(n <= 1) {\n    |        ^^^^^^^^^^^^\n@@ -22,7 +22,7 @@ LL |     if n <= 1 {\n    |        ~~~~~~\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:9:9\n+  --> $DIR/dbg_macro.rs:10:9\n    |\n LL |         dbg!(1)\n    |         ^^^^^^^\n@@ -33,7 +33,7 @@ LL |         1\n    |\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:11:9\n+  --> $DIR/dbg_macro.rs:12:9\n    |\n LL |         dbg!(n * factorial(n - 1))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -44,7 +44,7 @@ LL |         n * factorial(n - 1)\n    |\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:16:5\n+  --> $DIR/dbg_macro.rs:17:5\n    |\n LL |     dbg!(42);\n    |     ^^^^^^^^\n@@ -55,7 +55,7 @@ LL |     42;\n    |     ~~\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:17:5\n+  --> $DIR/dbg_macro.rs:18:5\n    |\n LL |     dbg!(dbg!(dbg!(42)));\n    |     ^^^^^^^^^^^^^^^^^^^^\n@@ -66,7 +66,7 @@ LL |     dbg!(dbg!(42));\n    |     ~~~~~~~~~~~~~~\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:18:14\n+  --> $DIR/dbg_macro.rs:19:14\n    |\n LL |     foo(3) + dbg!(factorial(4));\n    |              ^^^^^^^^^^^^^^^^^^\n@@ -77,7 +77,7 @@ LL |     foo(3) + factorial(4);\n    |              ~~~~~~~~~~~~\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:19:5\n+  --> $DIR/dbg_macro.rs:20:5\n    |\n LL |     dbg!(1, 2, dbg!(3, 4));\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n@@ -88,7 +88,7 @@ LL |     (1, 2, dbg!(3, 4));\n    |     ~~~~~~~~~~~~~~~~~~\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:20:5\n+  --> $DIR/dbg_macro.rs:21:5\n    |\n LL |     dbg!(1, 2, 3, 4, 5);\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -99,7 +99,7 @@ LL |     (1, 2, 3, 4, 5);\n    |     ~~~~~~~~~~~~~~~\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:40:9\n+  --> $DIR/dbg_macro.rs:41:9\n    |\n LL |         dbg!(2);\n    |         ^^^^^^^"}, {"sha": "71ebad24c16ea0b622f9d02a044c4f17ce5fbd21", "filename": "tests/ui/extend_with_drain.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fextend_with_drain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fextend_with_drain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextend_with_drain.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,11 +1,11 @@\n // run-rustfix\n #![warn(clippy::extend_with_drain)]\n+#![allow(clippy::iter_with_drain)]\n use std::collections::BinaryHeap;\n fn main() {\n     //gets linted\n     let mut vec1 = vec![0u8; 1024];\n     let mut vec2: std::vec::Vec<u8> = Vec::new();\n-\n     vec2.append(&mut vec1);\n \n     let mut vec3 = vec![0u8; 1024];\n@@ -17,7 +17,7 @@ fn main() {\n \n     vec11.append(&mut return_vector());\n \n-    //won't get linted it dosen't move the entire content of a vec into another\n+    //won't get linted it doesn't move the entire content of a vec into another\n     let mut test1 = vec![0u8, 10];\n     let mut test2: std::vec::Vec<u8> = Vec::new();\n "}, {"sha": "e9f011abb0e837f301fd44682fb7fccb7c0d02a1", "filename": "tests/ui/extend_with_drain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fextend_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fextend_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextend_with_drain.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,11 +1,11 @@\n // run-rustfix\n #![warn(clippy::extend_with_drain)]\n+#![allow(clippy::iter_with_drain)]\n use std::collections::BinaryHeap;\n fn main() {\n     //gets linted\n     let mut vec1 = vec![0u8; 1024];\n     let mut vec2: std::vec::Vec<u8> = Vec::new();\n-\n     vec2.extend(vec1.drain(..));\n \n     let mut vec3 = vec![0u8; 1024];\n@@ -17,7 +17,7 @@ fn main() {\n \n     vec11.extend(return_vector().drain(..));\n \n-    //won't get linted it dosen't move the entire content of a vec into another\n+    //won't get linted it doesn't move the entire content of a vec into another\n     let mut test1 = vec![0u8, 10];\n     let mut test2: std::vec::Vec<u8> = Vec::new();\n "}, {"sha": "aea4dba9dd5a0166a422fb921b3efffb183c4684", "filename": "tests/ui/iter_with_drain.fixed", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fiter_with_drain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fiter_with_drain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_with_drain.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+// will emits unused mut warnings after fixing\n+#![allow(unused_mut)]\n+// will emits needless collect warnings after fixing\n+#![allow(clippy::needless_collect)]\n+#![warn(clippy::iter_with_drain)]\n+use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\n+\n+fn full() {\n+    let mut a = vec![\"aaa\".to_string(), \"bbb\".to_string()];\n+    let mut a: BinaryHeap<_> = a.into_iter().collect();\n+    let mut a: HashSet<_> = a.drain().collect();\n+    let mut a: VecDeque<_> = a.drain().collect();\n+    let mut a: Vec<_> = a.into_iter().collect();\n+    let mut a: HashMap<_, _> = a.into_iter().map(|x| (x.clone(), x)).collect();\n+    let _: Vec<(String, String)> = a.drain().collect();\n+}\n+\n+fn closed() {\n+    let mut a = vec![\"aaa\".to_string(), \"bbb\".to_string()];\n+    let mut a: BinaryHeap<_> = a.into_iter().collect();\n+    let mut a: HashSet<_> = a.drain().collect();\n+    let mut a: VecDeque<_> = a.drain().collect();\n+    let mut a: Vec<_> = a.into_iter().collect();\n+    let mut a: HashMap<_, _> = a.into_iter().map(|x| (x.clone(), x)).collect();\n+    let _: Vec<(String, String)> = a.drain().collect();\n+}\n+\n+fn should_not_help() {\n+    let mut a = vec![\"aaa\".to_string(), \"bbb\".to_string()];\n+    let mut a: BinaryHeap<_> = a.drain(1..).collect();\n+    let mut a: HashSet<_> = a.drain().collect();\n+    let mut a: VecDeque<_> = a.drain().collect();\n+    let mut a: Vec<_> = a.drain(..a.len() - 1).collect();\n+    let mut a: HashMap<_, _> = a.drain(1..a.len() - 1).map(|x| (x.clone(), x)).collect();\n+    let _: Vec<(String, String)> = a.drain().collect();\n+\n+    let mut b = vec![\"aaa\".to_string(), \"bbb\".to_string()];\n+    let _: Vec<_> = b.drain(0..a.len()).collect();\n+}\n+\n+#[derive(Default)]\n+struct Bomb {\n+    fire: Vec<u8>,\n+}\n+\n+fn should_not_help_0(bomb: &mut Bomb) {\n+    let _: Vec<u8> = bomb.fire.drain(..).collect();\n+}\n+\n+fn main() {\n+    full();\n+    closed();\n+    should_not_help();\n+    should_not_help_0(&mut Bomb::default());\n+}"}, {"sha": "271878cffb44ccc8fcd7f1644ec24bbc6bc92dd7", "filename": "tests/ui/iter_with_drain.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_with_drain.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+// will emits unused mut warnings after fixing\n+#![allow(unused_mut)]\n+// will emits needless collect warnings after fixing\n+#![allow(clippy::needless_collect)]\n+#![warn(clippy::iter_with_drain)]\n+use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\n+\n+fn full() {\n+    let mut a = vec![\"aaa\".to_string(), \"bbb\".to_string()];\n+    let mut a: BinaryHeap<_> = a.drain(..).collect();\n+    let mut a: HashSet<_> = a.drain().collect();\n+    let mut a: VecDeque<_> = a.drain().collect();\n+    let mut a: Vec<_> = a.drain(..).collect();\n+    let mut a: HashMap<_, _> = a.drain(..).map(|x| (x.clone(), x)).collect();\n+    let _: Vec<(String, String)> = a.drain().collect();\n+}\n+\n+fn closed() {\n+    let mut a = vec![\"aaa\".to_string(), \"bbb\".to_string()];\n+    let mut a: BinaryHeap<_> = a.drain(0..).collect();\n+    let mut a: HashSet<_> = a.drain().collect();\n+    let mut a: VecDeque<_> = a.drain().collect();\n+    let mut a: Vec<_> = a.drain(..a.len()).collect();\n+    let mut a: HashMap<_, _> = a.drain(0..a.len()).map(|x| (x.clone(), x)).collect();\n+    let _: Vec<(String, String)> = a.drain().collect();\n+}\n+\n+fn should_not_help() {\n+    let mut a = vec![\"aaa\".to_string(), \"bbb\".to_string()];\n+    let mut a: BinaryHeap<_> = a.drain(1..).collect();\n+    let mut a: HashSet<_> = a.drain().collect();\n+    let mut a: VecDeque<_> = a.drain().collect();\n+    let mut a: Vec<_> = a.drain(..a.len() - 1).collect();\n+    let mut a: HashMap<_, _> = a.drain(1..a.len() - 1).map(|x| (x.clone(), x)).collect();\n+    let _: Vec<(String, String)> = a.drain().collect();\n+\n+    let mut b = vec![\"aaa\".to_string(), \"bbb\".to_string()];\n+    let _: Vec<_> = b.drain(0..a.len()).collect();\n+}\n+\n+#[derive(Default)]\n+struct Bomb {\n+    fire: Vec<u8>,\n+}\n+\n+fn should_not_help_0(bomb: &mut Bomb) {\n+    let _: Vec<u8> = bomb.fire.drain(..).collect();\n+}\n+\n+fn main() {\n+    full();\n+    closed();\n+    should_not_help();\n+    should_not_help_0(&mut Bomb::default());\n+}"}, {"sha": "aa394439fa624c4d5d9d012fd0f056be251921c9", "filename": "tests/ui/iter_with_drain.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fiter_with_drain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fiter_with_drain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_with_drain.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,40 @@\n+error: `drain(..)` used on a `Vec`\n+  --> $DIR/iter_with_drain.rs:11:34\n+   |\n+LL |     let mut a: BinaryHeap<_> = a.drain(..).collect();\n+   |                                  ^^^^^^^^^ help: try this: `into_iter()`\n+   |\n+   = note: `-D clippy::iter-with-drain` implied by `-D warnings`\n+\n+error: `drain(..)` used on a `VecDeque`\n+  --> $DIR/iter_with_drain.rs:14:27\n+   |\n+LL |     let mut a: Vec<_> = a.drain(..).collect();\n+   |                           ^^^^^^^^^ help: try this: `into_iter()`\n+\n+error: `drain(..)` used on a `Vec`\n+  --> $DIR/iter_with_drain.rs:15:34\n+   |\n+LL |     let mut a: HashMap<_, _> = a.drain(..).map(|x| (x.clone(), x)).collect();\n+   |                                  ^^^^^^^^^ help: try this: `into_iter()`\n+\n+error: `drain(..)` used on a `Vec`\n+  --> $DIR/iter_with_drain.rs:21:34\n+   |\n+LL |     let mut a: BinaryHeap<_> = a.drain(0..).collect();\n+   |                                  ^^^^^^^^^^ help: try this: `into_iter()`\n+\n+error: `drain(..)` used on a `VecDeque`\n+  --> $DIR/iter_with_drain.rs:24:27\n+   |\n+LL |     let mut a: Vec<_> = a.drain(..a.len()).collect();\n+   |                           ^^^^^^^^^^^^^^^^ help: try this: `into_iter()`\n+\n+error: `drain(..)` used on a `Vec`\n+  --> $DIR/iter_with_drain.rs:25:34\n+   |\n+LL |     let mut a: HashMap<_, _> = a.drain(0..a.len()).map(|x| (x.clone(), x)).collect();\n+   |                                  ^^^^^^^^^^^^^^^^^ help: try this: `into_iter()`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "fc6a7abca0ebda5ea92eabdbdf406efbd0e8d59e", "filename": "tests/ui/manual_map_option.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -148,6 +148,7 @@ fn main() {\n \n     // #7077\n     let s = &String::new();\n+    #[allow(clippy::needless_match)]\n     let _: Option<&str> = match Some(s) {\n         Some(s) => Some(s),\n         None => None,"}, {"sha": "16508270f64d9f015fc39d89c4e8f05ea99b0ae7", "filename": "tests/ui/manual_map_option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -214,6 +214,7 @@ fn main() {\n \n     // #7077\n     let s = &String::new();\n+    #[allow(clippy::needless_match)]\n     let _: Option<&str> = match Some(s) {\n         Some(s) => Some(s),\n         None => None,"}, {"sha": "aa89e04d26eb26291feae2a2b108cff221508889", "filename": "tests/ui/missing_spin_loop.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_spin_loop.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+#![warn(clippy::missing_spin_loop)]\n+#![allow(clippy::bool_comparison)]\n+#![allow(unused_braces)]\n+\n+use core::sync::atomic::{AtomicBool, Ordering};\n+\n+fn main() {\n+    let b = AtomicBool::new(true);\n+    // Those should lint\n+    while b.load(Ordering::Acquire) { std::hint::spin_loop() }\n+\n+    while !b.load(Ordering::SeqCst) { std::hint::spin_loop() }\n+\n+    while b.load(Ordering::Acquire) == false { std::hint::spin_loop() }\n+\n+    while { true == b.load(Ordering::Acquire) } { std::hint::spin_loop() }\n+\n+    while b.compare_exchange(true, false, Ordering::Acquire, Ordering::Relaxed) != Ok(true) { std::hint::spin_loop() }\n+\n+    while Ok(false) != b.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed) { std::hint::spin_loop() }\n+\n+    // This is OK, as the body is not empty\n+    while b.load(Ordering::Acquire) {\n+        std::hint::spin_loop()\n+    }\n+    // TODO: also match on loop+match or while let\n+}"}, {"sha": "88745e4773248af2db57048fd567812143c0228c", "filename": "tests/ui/missing_spin_loop.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_spin_loop.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+#![warn(clippy::missing_spin_loop)]\n+#![allow(clippy::bool_comparison)]\n+#![allow(unused_braces)]\n+\n+use core::sync::atomic::{AtomicBool, Ordering};\n+\n+fn main() {\n+    let b = AtomicBool::new(true);\n+    // Those should lint\n+    while b.load(Ordering::Acquire) {}\n+\n+    while !b.load(Ordering::SeqCst) {}\n+\n+    while b.load(Ordering::Acquire) == false {}\n+\n+    while { true == b.load(Ordering::Acquire) } {}\n+\n+    while b.compare_exchange(true, false, Ordering::Acquire, Ordering::Relaxed) != Ok(true) {}\n+\n+    while Ok(false) != b.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed) {}\n+\n+    // This is OK, as the body is not empty\n+    while b.load(Ordering::Acquire) {\n+        std::hint::spin_loop()\n+    }\n+    // TODO: also match on loop+match or while let\n+}"}, {"sha": "485da00dc6407a442d2eb6eb580515e6626876ed", "filename": "tests/ui/missing_spin_loop.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_spin_loop.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,40 @@\n+error: busy-waiting loop should at least have a spin loop hint\n+  --> $DIR/missing_spin_loop.rs:11:37\n+   |\n+LL |     while b.load(Ordering::Acquire) {}\n+   |                                     ^^ help: try this: `{ std::hint::spin_loop() }`\n+   |\n+   = note: `-D clippy::missing-spin-loop` implied by `-D warnings`\n+\n+error: busy-waiting loop should at least have a spin loop hint\n+  --> $DIR/missing_spin_loop.rs:13:37\n+   |\n+LL |     while !b.load(Ordering::SeqCst) {}\n+   |                                     ^^ help: try this: `{ std::hint::spin_loop() }`\n+\n+error: busy-waiting loop should at least have a spin loop hint\n+  --> $DIR/missing_spin_loop.rs:15:46\n+   |\n+LL |     while b.load(Ordering::Acquire) == false {}\n+   |                                              ^^ help: try this: `{ std::hint::spin_loop() }`\n+\n+error: busy-waiting loop should at least have a spin loop hint\n+  --> $DIR/missing_spin_loop.rs:17:49\n+   |\n+LL |     while { true == b.load(Ordering::Acquire) } {}\n+   |                                                 ^^ help: try this: `{ std::hint::spin_loop() }`\n+\n+error: busy-waiting loop should at least have a spin loop hint\n+  --> $DIR/missing_spin_loop.rs:19:93\n+   |\n+LL |     while b.compare_exchange(true, false, Ordering::Acquire, Ordering::Relaxed) != Ok(true) {}\n+   |                                                                                             ^^ help: try this: `{ std::hint::spin_loop() }`\n+\n+error: busy-waiting loop should at least have a spin loop hint\n+  --> $DIR/missing_spin_loop.rs:21:94\n+   |\n+LL |     while Ok(false) != b.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed) {}\n+   |                                                                                              ^^ help: try this: `{ std::hint::spin_loop() }`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "bb4b4795516ec6e8b3872be87e6245c79e1ec800", "filename": "tests/ui/missing_spin_loop_no_std.fixed", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop_no_std.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop_no_std.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_spin_loop_no_std.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,23 @@\n+// run-rustfix\n+#![warn(clippy::missing_spin_loop)]\n+#![feature(lang_items, start, libc)]\n+#![no_std]\n+\n+use core::sync::atomic::{AtomicBool, Ordering};\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    // This should trigger the lint\n+    let b = AtomicBool::new(true);\n+    // This should lint with `core::hint::spin_loop()`\n+    while b.load(Ordering::Acquire) { core::hint::spin_loop() }\n+    0\n+}\n+\n+#[panic_handler]\n+fn panic(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"eh_personality\"]\n+extern \"C\" fn eh_personality() {}"}, {"sha": "a19bc72baf8d1739191a21b32ca7945a478965b4", "filename": "tests/ui/missing_spin_loop_no_std.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop_no_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop_no_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_spin_loop_no_std.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,23 @@\n+// run-rustfix\n+#![warn(clippy::missing_spin_loop)]\n+#![feature(lang_items, start, libc)]\n+#![no_std]\n+\n+use core::sync::atomic::{AtomicBool, Ordering};\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    // This should trigger the lint\n+    let b = AtomicBool::new(true);\n+    // This should lint with `core::hint::spin_loop()`\n+    while b.load(Ordering::Acquire) {}\n+    0\n+}\n+\n+#[panic_handler]\n+fn panic(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"eh_personality\"]\n+extern \"C\" fn eh_personality() {}"}, {"sha": "2b3b6873c3c41ad31eb4b099535e0606de93a5df", "filename": "tests/ui/missing_spin_loop_no_std.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop_no_std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fmissing_spin_loop_no_std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_spin_loop_no_std.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,10 @@\n+error: busy-waiting loop should at least have a spin loop hint\n+  --> $DIR/missing_spin_loop_no_std.rs:13:37\n+   |\n+LL |     while b.load(Ordering::Acquire) {}\n+   |                                     ^^ help: try this: `{ core::hint::spin_loop() }`\n+   |\n+   = note: `-D clippy::missing-spin-loop` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "ece18ad737fdad5264a22085a2dcfb94003a83b8", "filename": "tests/ui/needless_match.fixed", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fneedless_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fneedless_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,83 @@\n+// run-rustfix\n+#![warn(clippy::needless_match)]\n+#![allow(clippy::manual_map)]\n+#![allow(dead_code)]\n+\n+#[derive(Clone, Copy)]\n+enum Choice {\n+    A,\n+    B,\n+    C,\n+    D,\n+}\n+\n+#[allow(unused_mut)]\n+fn useless_match() {\n+    let mut i = 10;\n+    let _: i32 = i;\n+    let _: i32 = i;\n+    let mut _i_mut = i;\n+\n+    let s = \"test\";\n+    let _: &str = s;\n+}\n+\n+fn custom_type_match(se: Choice) {\n+    let _: Choice = se;\n+    // Don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::A,\n+        Choice::B => Choice::B,\n+        _ => Choice::C,\n+    };\n+    // Mingled, don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::B,\n+        Choice::B => Choice::C,\n+        Choice::C => Choice::D,\n+        Choice::D => Choice::A,\n+    };\n+}\n+\n+fn option_match(x: Option<i32>) {\n+    let _: Option<i32> = x;\n+    // Don't trigger, this is the case for manual_map_option\n+    let _: Option<i32> = match x {\n+        Some(a) => Some(-a),\n+        None => None,\n+    };\n+}\n+\n+fn func_ret_err<T>(err: T) -> Result<i32, T> {\n+    Err(err)\n+}\n+\n+fn result_match() {\n+    let _: Result<i32, i32> = Ok(1);\n+    let _: Result<i32, i32> = func_ret_err(0_i32);\n+}\n+\n+fn if_let_option() -> Option<i32> {\n+    Some(1)\n+}\n+\n+fn if_let_result(x: Result<(), i32>) {\n+    let _: Result<(), i32> = x;\n+    let _: Result<(), i32> = x;\n+    // Input type mismatch, don't trigger\n+    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n+}\n+\n+fn if_let_custom_enum(x: Choice) {\n+    let _: Choice = x;\n+    // Don't trigger\n+    let _: Choice = if let Choice::A = x {\n+        Choice::A\n+    } else if true {\n+        Choice::B\n+    } else {\n+        x\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "36649de35a6030f91a1716c9d23844689981fccf", "filename": "tests/ui/needless_match.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,122 @@\n+// run-rustfix\n+#![warn(clippy::needless_match)]\n+#![allow(clippy::manual_map)]\n+#![allow(dead_code)]\n+\n+#[derive(Clone, Copy)]\n+enum Choice {\n+    A,\n+    B,\n+    C,\n+    D,\n+}\n+\n+#[allow(unused_mut)]\n+fn useless_match() {\n+    let mut i = 10;\n+    let _: i32 = match i {\n+        0 => 0,\n+        1 => 1,\n+        2 => 2,\n+        _ => i,\n+    };\n+    let _: i32 = match i {\n+        0 => 0,\n+        1 => 1,\n+        ref i => *i,\n+    };\n+    let mut _i_mut = match i {\n+        0 => 0,\n+        1 => 1,\n+        ref mut i => *i,\n+    };\n+\n+    let s = \"test\";\n+    let _: &str = match s {\n+        \"a\" => \"a\",\n+        \"b\" => \"b\",\n+        s => s,\n+    };\n+}\n+\n+fn custom_type_match(se: Choice) {\n+    let _: Choice = match se {\n+        Choice::A => Choice::A,\n+        Choice::B => Choice::B,\n+        Choice::C => Choice::C,\n+        Choice::D => Choice::D,\n+    };\n+    // Don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::A,\n+        Choice::B => Choice::B,\n+        _ => Choice::C,\n+    };\n+    // Mingled, don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::B,\n+        Choice::B => Choice::C,\n+        Choice::C => Choice::D,\n+        Choice::D => Choice::A,\n+    };\n+}\n+\n+fn option_match(x: Option<i32>) {\n+    let _: Option<i32> = match x {\n+        Some(a) => Some(a),\n+        None => None,\n+    };\n+    // Don't trigger, this is the case for manual_map_option\n+    let _: Option<i32> = match x {\n+        Some(a) => Some(-a),\n+        None => None,\n+    };\n+}\n+\n+fn func_ret_err<T>(err: T) -> Result<i32, T> {\n+    Err(err)\n+}\n+\n+fn result_match() {\n+    let _: Result<i32, i32> = match Ok(1) {\n+        Ok(a) => Ok(a),\n+        Err(err) => Err(err),\n+    };\n+    let _: Result<i32, i32> = match func_ret_err(0_i32) {\n+        Err(err) => Err(err),\n+        Ok(a) => Ok(a),\n+    };\n+}\n+\n+fn if_let_option() -> Option<i32> {\n+    if let Some(a) = Some(1) { Some(a) } else { None }\n+}\n+\n+fn if_let_result(x: Result<(), i32>) {\n+    let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n+    let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n+    // Input type mismatch, don't trigger\n+    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n+}\n+\n+fn if_let_custom_enum(x: Choice) {\n+    let _: Choice = if let Choice::A = x {\n+        Choice::A\n+    } else if let Choice::B = x {\n+        Choice::B\n+    } else if let Choice::C = x {\n+        Choice::C\n+    } else {\n+        x\n+    };\n+    // Don't trigger\n+    let _: Choice = if let Choice::A = x {\n+        Choice::A\n+    } else if true {\n+        Choice::B\n+    } else {\n+        x\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "ad1525406ade7abd6029b8f85278520b478c768e", "filename": "tests/ui/needless_match.stderr", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fneedless_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fneedless_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,122 @@\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:17:18\n+   |\n+LL |       let _: i32 = match i {\n+   |  __________________^\n+LL | |         0 => 0,\n+LL | |         1 => 1,\n+LL | |         2 => 2,\n+LL | |         _ => i,\n+LL | |     };\n+   | |_____^ help: replace it with: `i`\n+   |\n+   = note: `-D clippy::needless-match` implied by `-D warnings`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:23:18\n+   |\n+LL |       let _: i32 = match i {\n+   |  __________________^\n+LL | |         0 => 0,\n+LL | |         1 => 1,\n+LL | |         ref i => *i,\n+LL | |     };\n+   | |_____^ help: replace it with: `i`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:28:22\n+   |\n+LL |       let mut _i_mut = match i {\n+   |  ______________________^\n+LL | |         0 => 0,\n+LL | |         1 => 1,\n+LL | |         ref mut i => *i,\n+LL | |     };\n+   | |_____^ help: replace it with: `i`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:35:19\n+   |\n+LL |       let _: &str = match s {\n+   |  ___________________^\n+LL | |         \"a\" => \"a\",\n+LL | |         \"b\" => \"b\",\n+LL | |         s => s,\n+LL | |     };\n+   | |_____^ help: replace it with: `s`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:43:21\n+   |\n+LL |       let _: Choice = match se {\n+   |  _____________________^\n+LL | |         Choice::A => Choice::A,\n+LL | |         Choice::B => Choice::B,\n+LL | |         Choice::C => Choice::C,\n+LL | |         Choice::D => Choice::D,\n+LL | |     };\n+   | |_____^ help: replace it with: `se`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:65:26\n+   |\n+LL |       let _: Option<i32> = match x {\n+   |  __________________________^\n+LL | |         Some(a) => Some(a),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: replace it with: `x`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:81:31\n+   |\n+LL |       let _: Result<i32, i32> = match Ok(1) {\n+   |  _______________________________^\n+LL | |         Ok(a) => Ok(a),\n+LL | |         Err(err) => Err(err),\n+LL | |     };\n+   | |_____^ help: replace it with: `Ok(1)`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:85:31\n+   |\n+LL |       let _: Result<i32, i32> = match func_ret_err(0_i32) {\n+   |  _______________________________^\n+LL | |         Err(err) => Err(err),\n+LL | |         Ok(a) => Ok(a),\n+LL | |     };\n+   | |_____^ help: replace it with: `func_ret_err(0_i32)`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/needless_match.rs:92:5\n+   |\n+LL |     if let Some(a) = Some(1) { Some(a) } else { None }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `Some(1)`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/needless_match.rs:96:30\n+   |\n+LL |     let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/needless_match.rs:97:30\n+   |\n+LL |     let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/needless_match.rs:103:21\n+   |\n+LL |       let _: Choice = if let Choice::A = x {\n+   |  _____________________^\n+LL | |         Choice::A\n+LL | |     } else if let Choice::B = x {\n+LL | |         Choice::B\n+...  |\n+LL | |         x\n+LL | |     };\n+   | |_____^ help: replace it with: `x`\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "5768434f988ebf8b141fc4ee5e67a3971df67f29", "filename": "tests/ui/only_used_in_recursion.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,122 @@\n+#![warn(clippy::only_used_in_recursion)]\n+\n+fn simple(a: usize, b: usize) -> usize {\n+    if a == 0 { 1 } else { simple(a - 1, b) }\n+}\n+\n+fn with_calc(a: usize, b: isize) -> usize {\n+    if a == 0 { 1 } else { with_calc(a - 1, -b + 1) }\n+}\n+\n+fn tuple((a, b): (usize, usize)) -> usize {\n+    if a == 0 { 1 } else { tuple((a - 1, b + 1)) }\n+}\n+\n+fn let_tuple(a: usize, b: usize) -> usize {\n+    let (c, d) = (a, b);\n+    if c == 0 { 1 } else { let_tuple(c - 1, d + 1) }\n+}\n+\n+fn array([a, b]: [usize; 2]) -> usize {\n+    if a == 0 { 1 } else { array([a - 1, b + 1]) }\n+}\n+\n+fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n+    if a == 0 { 1 } else { index(a - 1, b, c + b[0]) }\n+}\n+\n+fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n+    let c = loop {\n+        b += 1;\n+        c += 1;\n+        if c == 10 {\n+            break b;\n+        }\n+    };\n+\n+    if a == 0 { 1 } else { break_(a - 1, c, c) }\n+}\n+\n+// this has a side effect\n+fn mut_ref(a: usize, b: &mut usize) -> usize {\n+    *b = 1;\n+    if a == 0 { 1 } else { mut_ref(a - 1, b) }\n+}\n+\n+fn mut_ref2(a: usize, b: &mut usize) -> usize {\n+    let mut c = *b;\n+    if a == 0 { 1 } else { mut_ref2(a - 1, &mut c) }\n+}\n+\n+fn not_primitive(a: usize, b: String) -> usize {\n+    if a == 0 { 1 } else { not_primitive(a - 1, b) }\n+}\n+\n+// this doesn't have a side effect,\n+// but `String` is not primitive.\n+fn not_primitive_op(a: usize, b: String, c: &str) -> usize {\n+    if a == 1 { 1 } else { not_primitive_op(a, b + c, c) }\n+}\n+\n+struct A;\n+\n+impl A {\n+    fn method(a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { A::method(a - 1, b - 1) }\n+    }\n+\n+    fn method2(&self, a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { self.method2(a - 1, b + 1) }\n+    }\n+}\n+\n+trait B {\n+    fn hello(a: usize, b: usize) -> usize;\n+\n+    fn hello2(&self, a: usize, b: usize) -> usize;\n+}\n+\n+impl B for A {\n+    fn hello(a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { A::hello(a - 1, b + 1) }\n+    }\n+\n+    fn hello2(&self, a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    }\n+}\n+\n+trait C {\n+    fn hello(a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { Self::hello(a - 1, b + 1) }\n+    }\n+\n+    fn hello2(&self, a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    }\n+}\n+\n+fn ignore(a: usize, _: usize) -> usize {\n+    if a == 1 { 1 } else { ignore(a - 1, 0) }\n+}\n+\n+fn ignore2(a: usize, _b: usize) -> usize {\n+    if a == 1 { 1 } else { ignore2(a - 1, _b) }\n+}\n+\n+fn f1(a: u32) -> u32 {\n+    a\n+}\n+\n+fn f2(a: u32) -> u32 {\n+    f1(a)\n+}\n+\n+fn inner_fn(a: u32) -> u32 {\n+    fn inner_fn(a: u32) -> u32 {\n+        a\n+    }\n+    inner_fn(a)\n+}\n+\n+fn main() {}"}, {"sha": "6fe9361bf5feb2eee0d903887ae911f3673f5706", "filename": "tests/ui/only_used_in_recursion.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fonly_used_in_recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fonly_used_in_recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,82 @@\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:3:21\n+   |\n+LL | fn simple(a: usize, b: usize) -> usize {\n+   |                     ^ help: if this is intentional, prefix with an underscore: `_b`\n+   |\n+   = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:7:24\n+   |\n+LL | fn with_calc(a: usize, b: isize) -> usize {\n+   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:11:14\n+   |\n+LL | fn tuple((a, b): (usize, usize)) -> usize {\n+   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:15:24\n+   |\n+LL | fn let_tuple(a: usize, b: usize) -> usize {\n+   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:20:14\n+   |\n+LL | fn array([a, b]: [usize; 2]) -> usize {\n+   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:24:20\n+   |\n+LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n+   |                    ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:24:37\n+   |\n+LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n+   |                                     ^ help: if this is intentional, prefix with an underscore: `_c`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:28:21\n+   |\n+LL | fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n+   |                     ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:46:23\n+   |\n+LL | fn mut_ref2(a: usize, b: &mut usize) -> usize {\n+   |                       ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:51:28\n+   |\n+LL | fn not_primitive(a: usize, b: String) -> usize {\n+   |                            ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:68:33\n+   |\n+LL |     fn method2(&self, a: usize, b: usize) -> usize {\n+   |                                 ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:90:24\n+   |\n+LL |     fn hello(a: usize, b: usize) -> usize {\n+   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:94:32\n+   |\n+LL |     fn hello2(&self, a: usize, b: usize) -> usize {\n+   |                                ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "40d7791df281a67f7700871529ed5d0aa96e8b16", "filename": "tests/ui/range_plus_minus_one.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Frange_plus_minus_one.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Frange_plus_minus_one.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_plus_minus_one.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![allow(unused_parens)]\n-\n+#![allow(clippy::iter_with_drain)]\n fn f() -> usize {\n     42\n }"}, {"sha": "a8ddd9b5f751b36ccb2fb065bd291ee0b2956328", "filename": "tests/ui/range_plus_minus_one.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Frange_plus_minus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Frange_plus_minus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_plus_minus_one.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![allow(unused_parens)]\n-\n+#![allow(clippy::iter_with_drain)]\n fn f() -> usize {\n     42\n }"}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "b425cdd6cbfd441d45b3cacce9a3f2c60daa5b7e", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -25,8 +25,8 @@ fn main() {\n     let slice_ptr = &[0, 1, 2, 3] as *const [i32];\n \n     // ... or pointer_kind(T) = pointer_kind(U_0); ptr-ptr-cast\n-    let _ptr_to_unsized_transmute = unsafe { slice_ptr as *const [u16] };\n-    let _ptr_to_unsized = slice_ptr as *const [u16];\n+    let _ptr_to_unsized_transmute = unsafe { slice_ptr as *const [u32] };\n+    let _ptr_to_unsized = slice_ptr as *const [u32];\n     // TODO: We could try testing vtable casts here too, but maybe\n     // we should wait until std::raw::TraitObject is stabilized?\n "}, {"sha": "8fd57c5965279d96766ee8748195cca562277399", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -25,8 +25,8 @@ fn main() {\n     let slice_ptr = &[0, 1, 2, 3] as *const [i32];\n \n     // ... or pointer_kind(T) = pointer_kind(U_0); ptr-ptr-cast\n-    let _ptr_to_unsized_transmute = unsafe { transmute::<*const [i32], *const [u16]>(slice_ptr) };\n-    let _ptr_to_unsized = slice_ptr as *const [u16];\n+    let _ptr_to_unsized_transmute = unsafe { transmute::<*const [i32], *const [u32]>(slice_ptr) };\n+    let _ptr_to_unsized = slice_ptr as *const [u32];\n     // TODO: We could try testing vtable casts here too, but maybe\n     // we should wait until std::raw::TraitObject is stabilized?\n "}, {"sha": "d9b64a0ed7b02060d55d6b14f13709f5dd87545c", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -17,8 +17,8 @@ LL |     let _ptr_i8_transmute = unsafe { transmute::<*const i32, *const i8>(ptr\n error: transmute from a pointer to a pointer\n   --> $DIR/transmutes_expressible_as_ptr_casts.rs:28:46\n    |\n-LL |     let _ptr_to_unsized_transmute = unsafe { transmute::<*const [i32], *const [u16]>(slice_ptr) };\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `slice_ptr as *const [u16]`\n+LL |     let _ptr_to_unsized_transmute = unsafe { transmute::<*const [i32], *const [u32]>(slice_ptr) };\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `slice_ptr as *const [u32]`\n \n error: transmute from `*const i32` to `usize` which could be expressed as a pointer cast instead\n   --> $DIR/transmutes_expressible_as_ptr_casts.rs:34:50"}, {"sha": "8e01c2674f1671361fc691d9a34c91311ae9d495", "filename": "tests/ui/unnecessary_filter_map.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_filter_map.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,3 +1,5 @@\n+#![allow(dead_code)]\n+\n fn main() {\n     let _ = (0..4).filter_map(|x| if x > 1 { Some(x) } else { None });\n     let _ = (0..4).filter_map(|x| {\n@@ -19,3 +21,130 @@ fn main() {\n fn filter_map_none_changes_item_type() -> impl Iterator<Item = bool> {\n     \"\".chars().filter_map(|_| None)\n }\n+\n+// https://github.com/rust-lang/rust-clippy/issues/4433#issue-483920107\n+mod comment_483920107 {\n+    enum Severity {\n+        Warning,\n+        Other,\n+    }\n+\n+    struct ServerError;\n+\n+    impl ServerError {\n+        fn severity(&self) -> Severity {\n+            Severity::Warning\n+        }\n+    }\n+\n+    struct S {\n+        warnings: Vec<ServerError>,\n+    }\n+\n+    impl S {\n+        fn foo(&mut self, server_errors: Vec<ServerError>) {\n+            #[allow(unused_variables)]\n+            let errors: Vec<ServerError> = server_errors\n+                .into_iter()\n+                .filter_map(|se| match se.severity() {\n+                    Severity::Warning => {\n+                        self.warnings.push(se);\n+                        None\n+                    },\n+                    _ => Some(se),\n+                })\n+                .collect();\n+        }\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/4433#issuecomment-611006622\n+mod comment_611006622 {\n+    struct PendingRequest {\n+        reply_to: u8,\n+        token: u8,\n+        expires: u8,\n+        group_id: u8,\n+    }\n+\n+    enum Value {\n+        Null,\n+    }\n+\n+    struct Node;\n+\n+    impl Node {\n+        fn send_response(&self, _reply_to: u8, _token: u8, _value: Value) -> &Self {\n+            self\n+        }\n+        fn on_error_warn(&self) -> &Self {\n+            self\n+        }\n+    }\n+\n+    struct S {\n+        pending_requests: Vec<PendingRequest>,\n+    }\n+\n+    impl S {\n+        fn foo(&mut self, node: Node, now: u8, group_id: u8) {\n+            // \"drain_filter\"\n+            self.pending_requests = self\n+                .pending_requests\n+                .drain(..)\n+                .filter_map(|pending| {\n+                    if pending.expires <= now {\n+                        return None; // Expired, remove\n+                    }\n+\n+                    if pending.group_id == group_id {\n+                        // Matched - reuse strings and remove\n+                        node.send_response(pending.reply_to, pending.token, Value::Null)\n+                            .on_error_warn();\n+                        None\n+                    } else {\n+                        // Keep waiting\n+                        Some(pending)\n+                    }\n+                })\n+                .collect();\n+        }\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/4433#issuecomment-621925270\n+// This extrapolation doesn't reproduce the false positive. Additional context seems necessary.\n+mod comment_621925270 {\n+    struct Signature(u8);\n+\n+    fn foo(sig_packets: impl Iterator<Item = Result<Signature, ()>>) -> impl Iterator<Item = u8> {\n+        sig_packets.filter_map(|res| match res {\n+            Ok(Signature(sig_packet)) => Some(sig_packet),\n+            _ => None,\n+        })\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/4433#issuecomment-1052978898\n+mod comment_1052978898 {\n+    #![allow(clippy::redundant_closure)]\n+\n+    pub struct S(u8);\n+\n+    impl S {\n+        pub fn consume(self) {\n+            println!(\"yum\");\n+        }\n+    }\n+\n+    pub fn filter_owned() -> impl Iterator<Item = S> {\n+        (0..10).map(|i| S(i)).filter_map(|s| {\n+            if s.0 & 1 == 0 {\n+                s.consume();\n+                None\n+            } else {\n+                Some(s)\n+            }\n+        })\n+    }\n+}"}, {"sha": "5585b10ab903d1c606c5e6084ed448323f371566", "filename": "tests/ui/unnecessary_filter_map.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_filter_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_filter_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_filter_map.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,13 +1,13 @@\n error: this `.filter_map` can be written more simply using `.filter`\n-  --> $DIR/unnecessary_filter_map.rs:2:13\n+  --> $DIR/unnecessary_filter_map.rs:4:13\n    |\n LL |     let _ = (0..4).filter_map(|x| if x > 1 { Some(x) } else { None });\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unnecessary-filter-map` implied by `-D warnings`\n \n error: this `.filter_map` can be written more simply using `.filter`\n-  --> $DIR/unnecessary_filter_map.rs:3:13\n+  --> $DIR/unnecessary_filter_map.rs:5:13\n    |\n LL |       let _ = (0..4).filter_map(|x| {\n    |  _____________^\n@@ -19,7 +19,7 @@ LL | |     });\n    | |______^\n \n error: this `.filter_map` can be written more simply using `.filter`\n-  --> $DIR/unnecessary_filter_map.rs:9:13\n+  --> $DIR/unnecessary_filter_map.rs:11:13\n    |\n LL |       let _ = (0..4).filter_map(|x| match x {\n    |  _____________^\n@@ -29,7 +29,7 @@ LL | |     });\n    | |______^\n \n error: this `.filter_map` can be written more simply using `.map`\n-  --> $DIR/unnecessary_filter_map.rs:14:13\n+  --> $DIR/unnecessary_filter_map.rs:16:13\n    |\n LL |     let _ = (0..4).filter_map(|x| Some(x + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "a52390861b403b8a837ac9d091403bc9ff53a0f4", "filename": "tests/ui/unnecessary_find_map.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_find_map.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,23 @@\n+#![allow(dead_code)]\n+\n+fn main() {\n+    let _ = (0..4).find_map(|x| if x > 1 { Some(x) } else { None });\n+    let _ = (0..4).find_map(|x| {\n+        if x > 1 {\n+            return Some(x);\n+        };\n+        None\n+    });\n+    let _ = (0..4).find_map(|x| match x {\n+        0 | 1 => None,\n+        _ => Some(x),\n+    });\n+\n+    let _ = (0..4).find_map(|x| Some(x + 1));\n+\n+    let _ = (0..4).find_map(i32::checked_abs);\n+}\n+\n+fn find_map_none_changes_item_type() -> Option<bool> {\n+    \"\".chars().find_map(|_| None)\n+}"}, {"sha": "fb33c122fe337e1c802b1aeec31023cedf3064ab", "filename": "tests/ui/unnecessary_find_map.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_find_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_find_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_find_map.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -0,0 +1,38 @@\n+error: this `.find_map` can be written more simply using `.find`\n+  --> $DIR/unnecessary_find_map.rs:4:13\n+   |\n+LL |     let _ = (0..4).find_map(|x| if x > 1 { Some(x) } else { None });\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnecessary-find-map` implied by `-D warnings`\n+\n+error: this `.find_map` can be written more simply using `.find`\n+  --> $DIR/unnecessary_find_map.rs:5:13\n+   |\n+LL |       let _ = (0..4).find_map(|x| {\n+   |  _____________^\n+LL | |         if x > 1 {\n+LL | |             return Some(x);\n+LL | |         };\n+LL | |         None\n+LL | |     });\n+   | |______^\n+\n+error: this `.find_map` can be written more simply using `.find`\n+  --> $DIR/unnecessary_find_map.rs:11:13\n+   |\n+LL |       let _ = (0..4).find_map(|x| match x {\n+   |  _____________^\n+LL | |         0 | 1 => None,\n+LL | |         _ => Some(x),\n+LL | |     });\n+   | |______^\n+\n+error: this `.find_map` can be written more simply using `.map(..).next()`\n+  --> $DIR/unnecessary_find_map.rs:16:13\n+   |\n+LL |     let _ = (0..4).find_map(|x| Some(x + 1));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "21e2da474a8200e05710d508bc52974586262fb7", "filename": "tests/ui/unnecessary_sort_by.fixed", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_sort_by.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_sort_by.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -3,7 +3,6 @@\n #![allow(clippy::stable_sort_primitive)]\n \n use std::cell::Ref;\n-use std::cmp::Reverse;\n \n fn unnecessary_sort_by() {\n     fn id(x: isize) -> isize {\n@@ -18,8 +17,8 @@ fn unnecessary_sort_by() {\n     vec.sort_unstable_by_key(|a| id(-a));\n     // Reverse examples\n     vec.sort_by(|a, b| b.cmp(a)); // not linted to avoid suggesting `Reverse(b)` which would borrow\n-    vec.sort_by_key(|b| Reverse((b + 5).abs()));\n-    vec.sort_unstable_by_key(|b| Reverse(id(-b)));\n+    vec.sort_by_key(|b| std::cmp::Reverse((b + 5).abs()));\n+    vec.sort_unstable_by_key(|b| std::cmp::Reverse(id(-b)));\n     // Negative examples (shouldn't be changed)\n     let c = &7;\n     vec.sort_by(|a, b| (b - a).cmp(&(a - b)));\n@@ -76,7 +75,6 @@ mod issue_5754 {\n \n // The closure parameter is not dereferenced anymore, so non-Copy types can be linted\n mod issue_6001 {\n-    use super::*;\n     struct Test(String);\n \n     impl Test {\n@@ -93,8 +91,8 @@ mod issue_6001 {\n         args.sort_by_key(|a| a.name());\n         args.sort_unstable_by_key(|a| a.name());\n         // Reverse\n-        args.sort_by_key(|b| Reverse(b.name()));\n-        args.sort_unstable_by_key(|b| Reverse(b.name()));\n+        args.sort_by_key(|b| std::cmp::Reverse(b.name()));\n+        args.sort_unstable_by_key(|b| std::cmp::Reverse(b.name()));\n     }\n }\n "}, {"sha": "3365bf6e119e2463528822bb0f25438e485ea58f", "filename": "tests/ui/unnecessary_sort_by.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -3,7 +3,6 @@\n #![allow(clippy::stable_sort_primitive)]\n \n use std::cell::Ref;\n-use std::cmp::Reverse;\n \n fn unnecessary_sort_by() {\n     fn id(x: isize) -> isize {\n@@ -76,7 +75,6 @@ mod issue_5754 {\n \n // The closure parameter is not dereferenced anymore, so non-Copy types can be linted\n mod issue_6001 {\n-    use super::*;\n     struct Test(String);\n \n     impl Test {"}, {"sha": "89da5e7ea8b9bf475bb0a36ee45f29602404888e", "filename": "tests/ui/unnecessary_sort_by.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_sort_by.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Funnecessary_sort_by.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -1,76 +1,76 @@\n error: use Vec::sort here instead\n-  --> $DIR/unnecessary_sort_by.rs:15:5\n+  --> $DIR/unnecessary_sort_by.rs:14:5\n    |\n LL |     vec.sort_by(|a, b| a.cmp(b));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort()`\n    |\n    = note: `-D clippy::unnecessary-sort-by` implied by `-D warnings`\n \n error: use Vec::sort here instead\n-  --> $DIR/unnecessary_sort_by.rs:16:5\n+  --> $DIR/unnecessary_sort_by.rs:15:5\n    |\n LL |     vec.sort_unstable_by(|a, b| a.cmp(b));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:17:5\n+  --> $DIR/unnecessary_sort_by.rs:16:5\n    |\n LL |     vec.sort_by(|a, b| (a + 5).abs().cmp(&(b + 5).abs()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| (a + 5).abs())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:18:5\n+  --> $DIR/unnecessary_sort_by.rs:17:5\n    |\n LL |     vec.sort_unstable_by(|a, b| id(-a).cmp(&id(-b)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|a| id(-a))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:21:5\n+  --> $DIR/unnecessary_sort_by.rs:20:5\n    |\n LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|b| Reverse((b + 5).abs()))`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|b| std::cmp::Reverse((b + 5).abs()))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:22:5\n+  --> $DIR/unnecessary_sort_by.rs:21:5\n    |\n LL |     vec.sort_unstable_by(|a, b| id(-b).cmp(&id(-a)));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|b| Reverse(id(-b)))`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|b| std::cmp::Reverse(id(-b)))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:32:5\n+  --> $DIR/unnecessary_sort_by.rs:31:5\n    |\n LL |     vec.sort_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| (***a).abs())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:33:5\n+  --> $DIR/unnecessary_sort_by.rs:32:5\n    |\n LL |     vec.sort_unstable_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|a| (***a).abs())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:93:9\n+  --> $DIR/unnecessary_sort_by.rs:91:9\n    |\n LL |         args.sort_by(|a, b| a.name().cmp(&b.name()));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_by_key(|a| a.name())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:94:9\n+  --> $DIR/unnecessary_sort_by.rs:92:9\n    |\n LL |         args.sort_unstable_by(|a, b| a.name().cmp(&b.name()));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_unstable_by_key(|a| a.name())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:96:9\n+  --> $DIR/unnecessary_sort_by.rs:94:9\n    |\n LL |         args.sort_by(|a, b| b.name().cmp(&a.name()));\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_by_key(|b| Reverse(b.name()))`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_by_key(|b| std::cmp::Reverse(b.name()))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:97:9\n+  --> $DIR/unnecessary_sort_by.rs:95:9\n    |\n LL |         args.sort_unstable_by(|a, b| b.name().cmp(&a.name()));\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_unstable_by_key(|b| Reverse(b.name()))`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_unstable_by_key(|b| std::cmp::Reverse(b.name()))`\n \n error: aborting due to 12 previous errors\n "}, {"sha": "9d216f56ae60c66b3a22df7158c40a893f424e08", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -2,7 +2,7 @@\n // aux-build:proc_macro_derive.rs\n \n #![warn(clippy::use_self)]\n-#![allow(dead_code)]\n+#![allow(dead_code, unreachable_code)]\n #![allow(\n     clippy::should_implement_trait,\n     clippy::upper_case_acronyms,\n@@ -519,3 +519,26 @@ mod self_is_ty_param {\n         }\n     }\n }\n+\n+mod use_self_in_pat {\n+    enum Foo {\n+        Bar,\n+        Baz,\n+    }\n+\n+    impl Foo {\n+        fn do_stuff(self) {\n+            match self {\n+                Self::Bar => unimplemented!(),\n+                Self::Baz => unimplemented!(),\n+            }\n+            match Some(1) {\n+                Some(_) => unimplemented!(),\n+                None => unimplemented!(),\n+            }\n+            if let Self::Bar = self {\n+                unimplemented!()\n+            }\n+        }\n+    }\n+}"}, {"sha": "5f604fe25e416d93e2fafbf4883b92be539ca0ec", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -2,7 +2,7 @@\n // aux-build:proc_macro_derive.rs\n \n #![warn(clippy::use_self)]\n-#![allow(dead_code)]\n+#![allow(dead_code, unreachable_code)]\n #![allow(\n     clippy::should_implement_trait,\n     clippy::upper_case_acronyms,\n@@ -519,3 +519,26 @@ mod self_is_ty_param {\n         }\n     }\n }\n+\n+mod use_self_in_pat {\n+    enum Foo {\n+        Bar,\n+        Baz,\n+    }\n+\n+    impl Foo {\n+        fn do_stuff(self) {\n+            match self {\n+                Foo::Bar => unimplemented!(),\n+                Foo::Baz => unimplemented!(),\n+            }\n+            match Some(1) {\n+                Some(_) => unimplemented!(),\n+                None => unimplemented!(),\n+            }\n+            if let Foo::Bar = self {\n+                unimplemented!()\n+            }\n+        }\n+    }\n+}"}, {"sha": "34d98618253a6ddcff0ab9e603896326f3a07d92", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -168,5 +168,23 @@ error: unnecessary structure name repetition\n LL |             S2::new()\n    |             ^^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 28 previous errors\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:532:17\n+   |\n+LL |                 Foo::Bar => unimplemented!(),\n+   |                 ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:533:17\n+   |\n+LL |                 Foo::Baz => unimplemented!(),\n+   |                 ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:539:20\n+   |\n+LL |             if let Foo::Bar = self {\n+   |                    ^^^ help: use the applicable keyword: `Self`\n+\n+error: aborting due to 31 previous errors\n "}, {"sha": "97c974003c62fe7ebf6881db8494db8f092314d7", "filename": "util/gh-pages/index.html", "status": "modified", "additions": 211, "deletions": 71, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/d5ab347d5ca8e678297e10ef72ea702e624e7610/util%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/d5ab347d5ca8e678297e10ef72ea702e624e7610/util%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Findex.html?ref=d5ab347d5ca8e678297e10ef72ea702e624e7610", "patch": "@@ -25,7 +25,56 @@\n         blockquote { font-size: 1em; }\n         [ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak { display: none !important; }\n \n-        .form-inline .checkbox { margin-right: 0.6em }\n+        .dropdown-menu {\n+            color: var(--fg);\n+            background: var(--theme-popup-bg);\n+            border: 1px solid var(--theme-popup-border);\n+        }\n+\n+        .dropdown-menu .divider {\n+            background-color: var(--theme-popup-border);\n+        }\n+\n+        .dropdown-menu .checkbox {\n+            display: block;\n+            white-space: nowrap;\n+            margin: 0;\n+        }\n+        .dropdown-menu .checkbox label {\n+            padding: 3px 20px;\n+            width: 100%;\n+        }\n+\n+        .dropdown-menu .checkbox input {\n+            position: relative;\n+            margin: 0 0.5rem 0;\n+            padding: 0;\n+        }\n+\n+        .dropdown-menu .checkbox:hover {\n+            background-color: var(--theme-hover);\n+        }\n+\n+        div.panel div.panel-body button.dropdown-toggle {\n+            background: var(--searchbar-bg);\n+            color: var(--searchbar-fg);\n+            border-color: var(--theme-popup-border);\n+        }\n+\n+        div.panel div.panel-body button.dropdown-toggle:hover {\n+            box-shadow: 0 0 3px var(--searchbar-shadow-color);\n+        }\n+\n+        div.panel div.panel-body .open button.dropdown-toggle {\n+            background: var(--searchbar-bg);\n+            color: var(--searchbar-fg);\n+            border-color: var(--theme-popup-border);\n+            filter: brightness(90%);\n+        }\n+\n+        .dropdown-toggle .badge {\n+            background-color: #777;\n+        }\n \n         .panel-heading { cursor: pointer; }\n \n@@ -38,6 +87,16 @@\n         .panel .panel-title-name .anchor { display: none; }\n         .panel:hover .panel-title-name .anchor { display: inline;}\n \n+        .search-control {\n+            margin-top: 15px;\n+        }\n+\n+        @media (min-width: 992px) {\n+            .search-control {\n+                margin-top: 0;\n+            }\n+        }\n+\n         .label {\n             padding-top: 0.3em;\n             padding-bottom: 0.3em;\n@@ -143,13 +202,17 @@\n             --inline-code-bg: #191f26;\n         }\n \n+        .theme-dropdown {\n+            position: absolute;\n+            margin: 0.7em;\n+            z-index: 10;\n+        }\n+\n         /* Applying the mdBook theme */\n         .theme-icon {\n-            position: absolute;\n             text-align: center;\n             width: 2em;\n             height: 2em;\n-            margin: 0.7em;\n             line-height: 2em;\n             border: solid 1px var(--icons);\n             border-radius: 5px;\n@@ -160,23 +223,28 @@\n             background: var(--theme-hover);\n         }\n         .theme-choice {\n-            position: absolute;\n-            margin-top: calc(2em + 0.7em);\n-            margin-left: 0.7em;\n+            display: none;\n             list-style: none;\n             border: 1px solid var(--theme-popup-border);\n             border-radius: 5px;\n             color: var(--fg);\n             background: var(--theme-popup-bg);\n             padding: 0 0;\n+            overflow: hidden;\n         }\n+\n+        .theme-dropdown.open .theme-choice {\n+            display: block;\n+        }\n+\n         .theme-choice > li {\n             padding: 5px 10px;\n             font-size: 0.8em;\n             user-select: none;\n             cursor: pointer;\n         }\n-        .theme-choice > li:hover {\n+\n+        .theme-choice>li:hover {\n             background: var(--theme-hover);\n         }\n \n@@ -240,17 +308,15 @@\n \n     </style>\n </head>\n-<body>\n-    <div id=\"theme-icon\" class=\"theme-icon\">&#128396;</div>\n-    <ul id=\"theme-menu\" class=\"theme-choice\" style=\"display: none;\">\n-        <li id=\"light\">Light</li>\n-        <li id=\"rust\">Rust</li>\n-        <li id=\"coal\">Coal</li>\n-        <li id=\"navy\">Navy</li>\n-        <li id=\"ayu\">Ayu</li>\n-    </ul>\n-\n-    <div class=\"container\" ng-app=\"clippy\" ng-controller=\"lintList\">\n+<body ng-app=\"clippy\" ng-controller=\"lintList\">\n+    <div theme-dropdown class=\"theme-dropdown\">\n+        <div id=\"theme-icon\" class=\"theme-icon\">&#128396;</div>\n+        <ul id=\"theme-menu\" class=\"theme-choice\">\n+            <li id=\"{{id}}\" ng-repeat=\"(id, name) in themes\" ng-click=\"selectTheme(id)\">{{name}}</li>\n+        </ul>\n+    </div>\n+\n+    <div class=\"container\">\n         <div class=\"page-header\">\n             <h1>Clippy Lints</h1>\n         </div>\n@@ -271,38 +337,62 @@ <h1>Clippy Lints</h1>\n             </div>\n \n             <div class=\"panel panel-default\" ng-show=\"data\">\n-                <div class=\"panel-body row filter-panel\">\n-                    <div class=\"col-md-6 form-inline\">\n-                        <div class=\"form-group form-group-lg\">\n-                            <p class=\"h4\">\n-                                Lint levels\n-                                <a href=\"https://doc.rust-lang.org/rustc/lints/levels.html\">(?)</a>\n-                            </p>\n-                            <div class=\"checkbox\" ng-repeat=\"(level, enabled) in levels\">\n-                                <label class=\"text-capitalize\">\n-                                    <input type=\"checkbox\" ng-model=\"levels[level]\" />\n-                                    {{level}}\n-                                </label>\n-                            </div>\n+                <div class=\"panel-body row\">\n+                    <div class=\"col-12 col-md-4\">\n+                        <div class=\"btn-group\" filter-dropdown>\n+                            <button type=\"button\" class=\"btn btn-default dropdown-toggle\">\n+                                Lint levels <span class=\"badge\">{{selectedValuesCount(levels)}}</span> <span class=\"caret\"></span>\n+                            </button>\n+                            <ul class=\"dropdown-menu\">\n+                                <li class=\"checkbox\">\n+                                    <label ng-click=\"toggleLevels(true)\">\n+                                        <input type=\"checkbox\" class=\"invisible\" />\n+                                        All\n+                                    </label>\n+                                </li>\n+                                <li class=\"checkbox\">\n+                                    <label ng-click=\"toggleLevels(false)\">\n+                                        <input type=\"checkbox\" class=\"invisible\" />\n+                                        None\n+                                    </label>\n+                                </li>\n+                                <li role=\"separator\" class=\"divider\"></li>\n+                                <li class=\"checkbox\" ng-repeat=\"(level, enabled) in levels\">\n+                                    <label class=\"text-capitalize\">\n+                                        <input type=\"checkbox\" ng-model=\"levels[level]\" />\n+                                        {{level}}\n+                                    </label>\n+                                </li>\n+                            </ul>\n                         </div>\n-                    </div>\n-                    <div class=\"col-md-6 form-inline\">\n-                        <div class=\"form-group form-group-lg\">\n-                            <p class=\"h4\">\n-                                Lint groups\n-                                <a href=\"https://github.com/rust-lang/rust-clippy/#clippy\">(?)</a>\n-                            </p>\n-                            <div class=\"checkbox\" ng-repeat=\"(group, enabled) in groups\">\n-                                <label class=\"text-capitalize\">\n-                                    <input type=\"checkbox\" ng-model=\"groups[group]\" />\n-                                    {{group}}\n-                                </label>\n-                            </div>\n+                        <div class=\"btn-group\" filter-dropdown>\n+                            <button type=\"button\" class=\"btn btn-default dropdown-toggle\">\n+                                Lint groups <span class=\"badge\">{{selectedValuesCount(groups)}}</span> <span class=\"caret\"></span>\n+                            </button>\n+                            <ul class=\"dropdown-menu\">\n+                                <li class=\"checkbox\">\n+                                    <label ng-click=\"toggleGroups(true)\">\n+                                        <input type=\"checkbox\" class=\"invisible\" />\n+                                        All\n+                                    </label>\n+                                </li>\n+                                <li class=\"checkbox\">\n+                                    <label ng-click=\"toggleGroups(false)\">\n+                                        <input type=\"checkbox\" class=\"invisible\" />\n+                                        None\n+                                    </label>\n+                                </li>\n+                                <li role=\"separator\" class=\"divider\"></li>\n+                                <li class=\"checkbox\" ng-repeat=\"(group, enabled) in groups\">\n+                                    <label class=\"text-capitalize\">\n+                                        <input type=\"checkbox\" ng-model=\"groups[group]\" />\n+                                        {{group}}\n+                                    </label>\n+                                </li>\n+                            </ul>\n                         </div>\n                     </div>\n-                </div>\n-                <div class=\"panel-body row\">\n-                    <div class=\"col-md-12 form-horizontal\">\n+                    <div class=\"col-12 col-md-8 search-control\">\n                         <div class=\"input-group\">\n                             <label class=\"input-group-addon\" id=\"filter-label\" for=\"filter-input\">Filter:</label>\n                             <input type=\"text\" class=\"form-control\" placeholder=\"Keywords or search string\" id=\"filter-input\" ng-model=\"search\" ng-model-options=\"{debounce: 50}\"/>\n@@ -336,7 +426,7 @@ <h2 class=\"panel-title\">\n                     </h2>\n                 </header>\n \n-                <div class=\"list-group lint-docs\" ng-class=\"{collapse: true, in: open[lint.id]}\">\n+                <div class=\"list-group lint-docs\" ng-if=\"open[lint.id]\" ng-class=\"{collapse: true, in: open[lint.id]}\">\n                     <div class=\"list-group-item lint-doc-md\" ng-bind-html=\"lint.docs | markdown\"></div>\n                     <div class=\"lint-additional-info-container\">\n                         <!-- Applicability -->\n@@ -365,7 +455,7 @@ <h2 class=\"panel-title\">\n     </div>\n \n     <a href=\"https://github.com/rust-lang/rust-clippy\">\n-        <img style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\" alt=\"Fork me on Github\"/>\n+        <img style=\"position: absolute; top: 0; right: 0; border: 0; clip-path: polygon(0% 0%, 100% 0%, 100% 100%);\" src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\" alt=\"Fork me on Github\"/>\n     </a>\n \n     <script src=\"https://cdnjs.cloudflare.com/ajax/libs/markdown-it/12.3.2/markdown-it.min.js\"></script>\n@@ -429,6 +519,46 @@ <h2 class=\"panel-title\">\n                 );\n             };\n         })\n+        .directive('themeDropdown', function ($document) {\n+            return {\n+                restrict: 'A',\n+                link: function ($scope, $element, $attr) {\n+                    $element.bind('click', function () {\n+                        $element.toggleClass('open');\n+                        $element.addClass('open-recent');\n+                    });\n+\n+                    $document.bind('click', function () {\n+                        if (!$element.hasClass('open-recent')) {\n+                            $element.removeClass('open');\n+                        }\n+                        $element.removeClass('open-recent');\n+                    })\n+                }\n+            }\n+        })\n+        .directive('filterDropdown', function ($document) {\n+            return {\n+                restrict: 'A',\n+                link: function ($scope, $element, $attr) {\n+                    $element.bind('click', function (event) {\n+                        if (event.target.closest('button')) {\n+                            $element.toggleClass('open');\n+                        } else {\n+                            $element.addClass('open');\n+                        }\n+                        $element.addClass('open-recent');\n+                    });\n+\n+                    $document.bind('click', function () {\n+                        if (!$element.hasClass('open-recent')) {\n+                            $element.removeClass('open');\n+                        }\n+                        $element.removeClass('open-recent');\n+                    })\n+                }\n+            }\n+        })\n         .directive('onFinishRender', function ($timeout) {\n             return {\n                 restrict: 'A',\n@@ -462,6 +592,38 @@ <h2 class=\"panel-title\">\n                 suspicious: true,\n             };\n             $scope.groups = GROUPS_FILTER_DEFAULT;\n+            const THEMES_DEFAULT = {\n+                light: \"Light\",\n+                rust: \"Rust\",\n+                coal: \"Coal\",\n+                navy: \"Navy\",\n+                ayu: \"Ayu\"\n+            };\n+            $scope.themes = THEMES_DEFAULT;\n+\n+            $scope.selectTheme = function (theme) {\n+                setTheme(theme, true);\n+            }\n+\n+            $scope.toggleLevels = function (value) {\n+                const levels = $scope.levels;\n+                for (const key in levels) {\n+                    if (levels.hasOwnProperty(key)) {\n+                        levels[key] = value;\n+                    }\n+                }\n+            };\n+            $scope.toggleGroups = function (value) {\n+                const groups = $scope.groups;\n+                for (const key in groups) {\n+                    if (groups.hasOwnProperty(key)) {\n+                        groups[key] = value;\n+                    }\n+                }\n+            };\n+            $scope.selectedValuesCount = function (obj) {\n+                return Object.values(obj).filter(x => x).length;\n+            }\n             $scope.byGroups = function (lint) {\n                 return $scope.groups[lint.group];\n             };\n@@ -558,28 +720,6 @@ <h2 class=\"panel-title\">\n         }\n     }\n \n-    function setupListeners() {\n-        let themeIcon = document.getElementById(\"theme-icon\");\n-        let themeMenu = document.getElementById(\"theme-menu\");\n-        themeIcon.addEventListener(\"click\", function(e) {\n-            if (themeMenu.style.display == \"none\") {\n-                themeMenu.style.display = \"block\";\n-            } else {\n-                themeMenu.style.display = \"none\";\n-            }\n-        });\n-\n-        let children = themeMenu.children;\n-        for (let index = 0; index < children.length; index++) {\n-            let child = children[index];\n-            child.addEventListener(\"click\", function(e) {\n-                setTheme(child.id, true);\n-            });\n-        }\n-    }\n-\n-    setupListeners();\n-\n     function setTheme(theme, store) {\n         let enableHighlight = false;\n         let enableNight = false;"}]}