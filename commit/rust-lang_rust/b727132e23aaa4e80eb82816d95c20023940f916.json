{"sha": "b727132e23aaa4e80eb82816d95c20023940f916", "node_id": "C_kwDOAAsO6NoAKGI3MjcxMzJlMjNhYWE0ZTgwZWI4MjgxNmQ5NWMyMDAyMzk0MGY5MTY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-05-02T06:14:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-02T06:14:50Z"}, "message": "Rollup merge of #108161 - WaffleLapkin:const_param_ty, r=BoxyUwU\n\nAdd `ConstParamTy` trait\n\nThis is a bit sketch, but idk.\nr? `@BoxyUwU`\n\nYet to be done:\n- [x] ~~Figure out if it's okay to implement `StructuralEq` for primitives / possibly remove their special casing~~ (it should be okay, but maybe not in this PR...)\n- [ ] Maybe refactor the code a little bit\n- [x] Use a macro to make impls a bit nicer\n\nFuture work:\n- [ ] Actually\u2122 use the trait when checking if a `const` generic type is allowed\n- [ ] _Really_ refactor the surrounding code\n- [ ] Refactor `marker.rs` into multiple modules for each \"theme\" of markers", "tree": {"sha": "95fb9d868e6a15a303950217f2519a381bf5b805", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95fb9d868e6a15a303950217f2519a381bf5b805"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b727132e23aaa4e80eb82816d95c20023940f916", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkUKpaCRBK7hj4Ov3rIwAAmaoIADRZrz/3s3QfUmNasoKZZoKp\neIgYMATnjiyY4I4Oih8cV6/ihxoE//fpFUZ8NS9SdDi5hFrSQJyjg2sDNOROn4zi\nI6goGIkBh+7SrhxJ4VGv4I2311648H4TOT+UoLb/YFQjKBUQxzOXbRZuUJJFcSnM\nCR2avB5RT6tY/91M45qmdDDMzqQRBVfI45nXVAKVDz0gDt9S1SjWwzEcEyU0bHg3\ns8ad8NGjHoEUwg+kzyzxgvGvZWv0FumquoXpdpfgEuYV/RqtJIAUB+ePgGOieYLj\nbXxZW6d6N2cA1aTitbYL5T0EaLppwqxsNz3x9G5ZC4jFx8BXcPCoAaIqzIRz9WE=\n=nXeQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 95fb9d868e6a15a303950217f2519a381bf5b805\nparent f916c44aecfc6c610f2d23cf929644aa08123547\nparent c31754651da17b207fa7fb94c2f3ba2c188aa0b1\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1683008090 +0530\ncommitter GitHub <noreply@github.com> 1683008090 +0530\n\nRollup merge of #108161 - WaffleLapkin:const_param_ty, r=BoxyUwU\n\nAdd `ConstParamTy` trait\n\nThis is a bit sketch, but idk.\nr? `@BoxyUwU`\n\nYet to be done:\n- [x] ~~Figure out if it's okay to implement `StructuralEq` for primitives / possibly remove their special casing~~ (it should be okay, but maybe not in this PR...)\n- [ ] Maybe refactor the code a little bit\n- [x] Use a macro to make impls a bit nicer\n\nFuture work:\n- [ ] Actually\u2122 use the trait when checking if a `const` generic type is allowed\n- [ ] _Really_ refactor the surrounding code\n- [ ] Refactor `marker.rs` into multiple modules for each \"theme\" of markers\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b727132e23aaa4e80eb82816d95c20023940f916", "html_url": "https://github.com/rust-lang/rust/commit/b727132e23aaa4e80eb82816d95c20023940f916", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b727132e23aaa4e80eb82816d95c20023940f916/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f916c44aecfc6c610f2d23cf929644aa08123547", "url": "https://api.github.com/repos/rust-lang/rust/commits/f916c44aecfc6c610f2d23cf929644aa08123547", "html_url": "https://github.com/rust-lang/rust/commit/f916c44aecfc6c610f2d23cf929644aa08123547"}, {"sha": "c31754651da17b207fa7fb94c2f3ba2c188aa0b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c31754651da17b207fa7fb94c2f3ba2c188aa0b1", "html_url": "https://github.com/rust-lang/rust/commit/c31754651da17b207fa7fb94c2f3ba2c188aa0b1"}], "stats": {"total": 852, "additions": 673, "deletions": 179}, "files": [{"sha": "e1c030d3e198aff55f85cac0344993abcd81abca", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -293,6 +293,8 @@ language_item_table! {\n \n     PointerLike,             sym::pointer_like,        pointer_like,               Target::Trait,          GenericRequirement::Exact(0);\n \n+    ConstParamTy,            sym::const_param_ty,      const_param_ty_trait,       Target::Trait,          GenericRequirement::Exact(0);\n+\n     Poll,                    sym::Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n     PollReady,               sym::Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n     PollPending,             sym::Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;"}, {"sha": "e4f225bdad73efbb5df218f518f75377aa4237c3", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -35,6 +35,10 @@ hir_analysis_field_already_declared =\n \n hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n \n+hir_analysis_const_param_ty_impl_on_non_adt =\n+    the trait `ConstParamTy` may not be implemented for this type\n+    .label = type is not a structure or enumeration\n+\n hir_analysis_ambiguous_lifetime_bound =\n     ambiguous lifetime bound, explicit lifetime bound required\n "}, {"sha": "0f450ae67b7a636579818d77ba6ba5f7f7f8c9ff", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 148, "deletions": 107, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -1,9 +1,11 @@\n //! Check properties that are required by built-in traits and set\n //! up data structures required by type-checking/codegen.\n \n-use crate::errors::{CopyImplOnNonAdt, CopyImplOnTypeWithDtor, DropImplOnWrongItem};\n+use crate::errors::{\n+    ConstParamTyImplOnNonAdt, CopyImplOnNonAdt, CopyImplOnTypeWithDtor, DropImplOnWrongItem,\n+};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{struct_span_err, MultiSpan};\n+use rustc_errors::{struct_span_err, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n@@ -14,9 +16,11 @@ use rustc_infer::infer::{DefineOpaqueTypes, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::misc::{\n-    type_allowed_to_implement_copy, CopyImplementationError, InfringingFieldsReason,\n+    type_allowed_to_implement_const_param_ty, type_allowed_to_implement_copy,\n+    ConstParamTyImplementationError, CopyImplementationError, InfringingFieldsReason,\n };\n use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n@@ -27,6 +31,7 @@ pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n         .check(lang_items.drop_trait(), visit_implementation_of_drop)\n         .check(lang_items.copy_trait(), visit_implementation_of_copy)\n+        .check(lang_items.const_param_ty_trait(), visit_implementation_of_const_param_ty)\n         .check(lang_items.coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n         .check(lang_items.dispatch_from_dyn_trait(), visit_implementation_of_dispatch_from_dyn);\n }\n@@ -83,110 +88,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     match type_allowed_to_implement_copy(tcx, param_env, self_type, cause) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfringingFields(fields)) => {\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0204,\n-                \"the trait `Copy` cannot be implemented for this type\"\n-            );\n-\n-            // We'll try to suggest constraining type parameters to fulfill the requirements of\n-            // their `Copy` implementation.\n-            let mut errors: BTreeMap<_, Vec<_>> = Default::default();\n-            let mut bounds = vec![];\n-\n-            let mut seen_tys = FxHashSet::default();\n-\n-            for (field, ty, reason) in fields {\n-                // Only report an error once per type.\n-                if !seen_tys.insert(ty) {\n-                    continue;\n-                }\n-\n-                let field_span = tcx.def_span(field.did);\n-                err.span_label(field_span, \"this field does not implement `Copy`\");\n-\n-                match reason {\n-                    InfringingFieldsReason::Fulfill(fulfillment_errors) => {\n-                        for error in fulfillment_errors {\n-                            let error_predicate = error.obligation.predicate;\n-                            // Only note if it's not the root obligation, otherwise it's trivial and\n-                            // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n-\n-                            // FIXME: This error could be more descriptive, especially if the error_predicate\n-                            // contains a foreign type or if it's a deeply nested type...\n-                            if error_predicate != error.root_obligation.predicate {\n-                                errors\n-                                    .entry((ty.to_string(), error_predicate.to_string()))\n-                                    .or_default()\n-                                    .push(error.obligation.cause.span);\n-                            }\n-                            if let ty::PredicateKind::Clause(ty::Clause::Trait(\n-                                ty::TraitPredicate {\n-                                    trait_ref,\n-                                    polarity: ty::ImplPolarity::Positive,\n-                                    ..\n-                                },\n-                            )) = error_predicate.kind().skip_binder()\n-                            {\n-                                let ty = trait_ref.self_ty();\n-                                if let ty::Param(_) = ty.kind() {\n-                                    bounds.push((\n-                                        format!(\"{ty}\"),\n-                                        trait_ref.print_only_trait_path().to_string(),\n-                                        Some(trait_ref.def_id),\n-                                    ));\n-                                }\n-                            }\n-                        }\n-                    }\n-                    InfringingFieldsReason::Regions(region_errors) => {\n-                        for error in region_errors {\n-                            let ty = ty.to_string();\n-                            match error {\n-                                RegionResolutionError::ConcreteFailure(origin, a, b) => {\n-                                    let predicate = format!(\"{b}: {a}\");\n-                                    errors\n-                                        .entry((ty.clone(), predicate.clone()))\n-                                        .or_default()\n-                                        .push(origin.span());\n-                                    if let ty::RegionKind::ReEarlyBound(ebr) = *b && ebr.has_name() {\n-                                        bounds.push((b.to_string(), a.to_string(), None));\n-                                    }\n-                                }\n-                                RegionResolutionError::GenericBoundFailure(origin, a, b) => {\n-                                    let predicate = format!(\"{a}: {b}\");\n-                                    errors\n-                                        .entry((ty.clone(), predicate.clone()))\n-                                        .or_default()\n-                                        .push(origin.span());\n-                                    if let infer::region_constraints::GenericKind::Param(_) = a {\n-                                        bounds.push((a.to_string(), b.to_string(), None));\n-                                    }\n-                                }\n-                                _ => continue,\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            for ((ty, error_predicate), spans) in errors {\n-                let span: MultiSpan = spans.into();\n-                err.span_note(\n-                    span,\n-                    &format!(\"the `Copy` impl for `{}` requires that `{}`\", ty, error_predicate),\n-                );\n-            }\n-            suggest_constraining_type_params(\n-                tcx,\n-                tcx.hir().get_generics(impl_did).expect(\"impls always have generics\"),\n-                &mut err,\n-                bounds.iter().map(|(param, constraint, def_id)| {\n-                    (param.as_str(), constraint.as_str(), *def_id)\n-                }),\n-                None,\n-            );\n-            err.emit();\n+            infringing_fields_error(tcx, fields, LangItem::Copy, impl_did, span);\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             tcx.sess.emit_err(CopyImplOnNonAdt { span });\n@@ -197,6 +99,29 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     }\n }\n \n+fn visit_implementation_of_const_param_ty(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n+    let self_type = tcx.type_of(impl_did).subst_identity();\n+    assert!(!self_type.has_escaping_bound_vars());\n+\n+    let param_env = tcx.param_env(impl_did);\n+\n+    let span = match tcx.hir().expect_item(impl_did).expect_impl() {\n+        hir::Impl { polarity: hir::ImplPolarity::Negative(_), .. } => return,\n+        impl_ => impl_.self_ty.span,\n+    };\n+\n+    let cause = traits::ObligationCause::misc(span, impl_did);\n+    match type_allowed_to_implement_const_param_ty(tcx, param_env, self_type, cause) {\n+        Ok(()) => {}\n+        Err(ConstParamTyImplementationError::InfrigingFields(fields)) => {\n+            infringing_fields_error(tcx, fields, LangItem::ConstParamTy, impl_did, span);\n+        }\n+        Err(ConstParamTyImplementationError::NotAnAdtOrBuiltinAllowed) => {\n+            tcx.sess.emit_err(ConstParamTyImplOnNonAdt { span });\n+        }\n+    }\n+}\n+\n fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\", impl_did);\n \n@@ -593,3 +518,119 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) -> Coe\n \n     CoerceUnsizedInfo { custom_kind: kind }\n }\n+\n+fn infringing_fields_error(\n+    tcx: TyCtxt<'_>,\n+    fields: Vec<(&ty::FieldDef, Ty<'_>, InfringingFieldsReason<'_>)>,\n+    lang_item: LangItem,\n+    impl_did: LocalDefId,\n+    impl_span: Span,\n+) -> ErrorGuaranteed {\n+    let trait_did = tcx.require_lang_item(lang_item, Some(impl_span));\n+\n+    let trait_name = tcx.def_path_str(trait_did);\n+\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        impl_span,\n+        E0204,\n+        \"the trait `{trait_name}` cannot be implemented for this type\"\n+    );\n+\n+    // We'll try to suggest constraining type parameters to fulfill the requirements of\n+    // their `Copy` implementation.\n+    let mut errors: BTreeMap<_, Vec<_>> = Default::default();\n+    let mut bounds = vec![];\n+\n+    let mut seen_tys = FxHashSet::default();\n+\n+    for (field, ty, reason) in fields {\n+        // Only report an error once per type.\n+        if !seen_tys.insert(ty) {\n+            continue;\n+        }\n+\n+        let field_span = tcx.def_span(field.did);\n+        err.span_label(field_span, format!(\"this field does not implement `{trait_name}`\"));\n+\n+        match reason {\n+            InfringingFieldsReason::Fulfill(fulfillment_errors) => {\n+                for error in fulfillment_errors {\n+                    let error_predicate = error.obligation.predicate;\n+                    // Only note if it's not the root obligation, otherwise it's trivial and\n+                    // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n+\n+                    // FIXME: This error could be more descriptive, especially if the error_predicate\n+                    // contains a foreign type or if it's a deeply nested type...\n+                    if error_predicate != error.root_obligation.predicate {\n+                        errors\n+                            .entry((ty.to_string(), error_predicate.to_string()))\n+                            .or_default()\n+                            .push(error.obligation.cause.span);\n+                    }\n+                    if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+                        trait_ref,\n+                        polarity: ty::ImplPolarity::Positive,\n+                        ..\n+                    })) = error_predicate.kind().skip_binder()\n+                    {\n+                        let ty = trait_ref.self_ty();\n+                        if let ty::Param(_) = ty.kind() {\n+                            bounds.push((\n+                                format!(\"{ty}\"),\n+                                trait_ref.print_only_trait_path().to_string(),\n+                                Some(trait_ref.def_id),\n+                            ));\n+                        }\n+                    }\n+                }\n+            }\n+            InfringingFieldsReason::Regions(region_errors) => {\n+                for error in region_errors {\n+                    let ty = ty.to_string();\n+                    match error {\n+                        RegionResolutionError::ConcreteFailure(origin, a, b) => {\n+                            let predicate = format!(\"{b}: {a}\");\n+                            errors\n+                                .entry((ty.clone(), predicate.clone()))\n+                                .or_default()\n+                                .push(origin.span());\n+                            if let ty::RegionKind::ReEarlyBound(ebr) = *b && ebr.has_name() {\n+                                        bounds.push((b.to_string(), a.to_string(), None));\n+                                    }\n+                        }\n+                        RegionResolutionError::GenericBoundFailure(origin, a, b) => {\n+                            let predicate = format!(\"{a}: {b}\");\n+                            errors\n+                                .entry((ty.clone(), predicate.clone()))\n+                                .or_default()\n+                                .push(origin.span());\n+                            if let infer::region_constraints::GenericKind::Param(_) = a {\n+                                bounds.push((a.to_string(), b.to_string(), None));\n+                            }\n+                        }\n+                        _ => continue,\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    for ((ty, error_predicate), spans) in errors {\n+        let span: MultiSpan = spans.into();\n+        err.span_note(\n+            span,\n+            format!(\"the `{trait_name}` impl for `{ty}` requires that `{error_predicate}`\"),\n+        );\n+    }\n+    suggest_constraining_type_params(\n+        tcx,\n+        tcx.hir().get_generics(impl_did).expect(\"impls always have generics\"),\n+        &mut err,\n+        bounds\n+            .iter()\n+            .map(|(param, constraint, def_id)| (param.as_str(), constraint.as_str(), *def_id)),\n+        None,\n+    );\n+\n+    err.emit()\n+}"}, {"sha": "25ad1bed763506c827aa9d3597339740b2825049", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -107,6 +107,14 @@ pub struct CopyImplOnNonAdt {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_param_ty_impl_on_non_adt)]\n+pub struct ConstParamTyImplOnNonAdt {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(hir_analysis_trait_object_declared_with_no_traits, code = \"E0224\")]\n pub struct TraitObjectDeclaredWithNoTraits {"}, {"sha": "7969b848fd95656a81f62854e1f2894f855c01cf", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -531,6 +531,7 @@ symbols! {\n         const_mut_refs,\n         const_panic,\n         const_panic_fmt,\n+        const_param_ty,\n         const_precise_live_drops,\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,"}, {"sha": "2210ef975e6c82732fa78c72098f3211de3e237e", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 86, "deletions": 15, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -2,13 +2,14 @@\n \n use crate::traits::{self, ObligationCause, ObligationCtxt};\n \n+use hir::LangItem;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::{infer::outlives::env::OutlivesEnvironment, traits::FulfillmentError};\n-use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_middle::ty::{self, AdtDef, GenericArg, List, ParamEnv, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n \n use super::outlives_bounds::InferCtxtExt;\n@@ -19,6 +20,11 @@ pub enum CopyImplementationError<'tcx> {\n     HasDestructor,\n }\n \n+pub enum ConstParamTyImplementationError<'tcx> {\n+    InfrigingFields(Vec<(&'tcx ty::FieldDef, Ty<'tcx>, InfringingFieldsReason<'tcx>)>),\n+    NotAnAdtOrBuiltinAllowed,\n+}\n+\n pub enum InfringingFieldsReason<'tcx> {\n     Fulfill(Vec<FulfillmentError<'tcx>>),\n     Regions(Vec<RegionResolutionError<'tcx>>),\n@@ -27,7 +33,10 @@ pub enum InfringingFieldsReason<'tcx> {\n /// Checks that the fields of the type (an ADT) all implement copy.\n ///\n /// If fields don't implement copy, return an error containing a list of\n-/// those violating fields. If it's not an ADT, returns `Err(NotAnAdt)`.\n+/// those violating fields.\n+///\n+/// If it's not an ADT, int ty, `bool`, float ty, `char`, raw pointer, `!`,\n+/// a reference or an array returns `Err(NotAnAdt)`.\n pub fn type_allowed_to_implement_copy<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -47,12 +56,82 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n         | ty::Ref(_, _, hir::Mutability::Not)\n         | ty::Array(..) => return Ok(()),\n \n-        ty::Adt(adt, substs) => (adt, substs),\n+        &ty::Adt(adt, substs) => (adt, substs),\n \n         _ => return Err(CopyImplementationError::NotAnAdt),\n     };\n \n-    let copy_def_id = tcx.require_lang_item(hir::LangItem::Copy, Some(parent_cause.span));\n+    all_fields_implement_trait(\n+        tcx,\n+        param_env,\n+        self_type,\n+        adt,\n+        substs,\n+        parent_cause,\n+        hir::LangItem::Copy,\n+    )\n+    .map_err(CopyImplementationError::InfringingFields)?;\n+\n+    if adt.has_dtor(tcx) {\n+        return Err(CopyImplementationError::HasDestructor);\n+    }\n+\n+    Ok(())\n+}\n+\n+/// Checks that the fields of the type (an ADT) all implement `ConstParamTy`.\n+///\n+/// If fields don't implement `ConstParamTy`, return an error containing a list of\n+/// those violating fields.\n+///\n+/// If it's not an ADT, int ty, `bool` or `char`, returns `Err(NotAnAdtOrBuiltinAllowed)`.\n+pub fn type_allowed_to_implement_const_param_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    self_type: Ty<'tcx>,\n+    parent_cause: ObligationCause<'tcx>,\n+) -> Result<(), ConstParamTyImplementationError<'tcx>> {\n+    let (adt, substs) = match self_type.kind() {\n+        // `core` provides these impls.\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Char\n+        | ty::Str\n+        | ty::Array(..)\n+        | ty::Slice(_)\n+        | ty::Ref(.., hir::Mutability::Not) => return Ok(()),\n+\n+        &ty::Adt(adt, substs) => (adt, substs),\n+\n+        _ => return Err(ConstParamTyImplementationError::NotAnAdtOrBuiltinAllowed),\n+    };\n+\n+    all_fields_implement_trait(\n+        tcx,\n+        param_env,\n+        self_type,\n+        adt,\n+        substs,\n+        parent_cause,\n+        hir::LangItem::ConstParamTy,\n+    )\n+    .map_err(ConstParamTyImplementationError::InfrigingFields)?;\n+\n+    Ok(())\n+}\n+\n+/// Check that all fields of a given `adt` implement `lang_item` trait.\n+pub fn all_fields_implement_trait<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    self_type: Ty<'tcx>,\n+    adt: AdtDef<'tcx>,\n+    substs: &'tcx List<GenericArg<'tcx>>,\n+    parent_cause: ObligationCause<'tcx>,\n+    lang_item: LangItem,\n+) -> Result<(), Vec<(&'tcx ty::FieldDef, Ty<'tcx>, InfringingFieldsReason<'tcx>)>> {\n+    let trait_def_id = tcx.require_lang_item(lang_item, Some(parent_cause.span));\n \n     let mut infringing = Vec::new();\n     for variant in adt.variants() {\n@@ -93,15 +172,15 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n             // between expected and found const-generic types. Don't report an\n             // additional copy error here, since it's not typically useful.\n             if !normalization_errors.is_empty() || ty.references_error() {\n-                tcx.sess.delay_span_bug(field_span, format!(\"couldn't normalize struct field `{unnormalized_ty}` when checking Copy implementation\"));\n+                tcx.sess.delay_span_bug(field_span, format!(\"couldn't normalize struct field `{unnormalized_ty}` when checking {tr} implementation\", tr = tcx.def_path_str(trait_def_id)));\n                 continue;\n             }\n \n             ocx.register_bound(\n                 ObligationCause::dummy_with_span(field_ty_span),\n                 param_env,\n                 ty,\n-                copy_def_id,\n+                trait_def_id,\n             );\n             let errors = ocx.select_all_or_error();\n             if !errors.is_empty() {\n@@ -124,15 +203,7 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n         }\n     }\n \n-    if !infringing.is_empty() {\n-        return Err(CopyImplementationError::InfringingFields(infringing));\n-    }\n-\n-    if adt.has_dtor(tcx) {\n-        return Err(CopyImplementationError::HasDestructor);\n-    }\n-\n-    Ok(())\n+    if infringing.is_empty() { Ok(()) } else { Err(infringing) }\n }\n \n pub fn check_tys_might_be_eq<'tcx>("}, {"sha": "a535a011aafe2cb355b417d3c82de6b737a251f2", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -162,6 +162,7 @@\n #![feature(const_waker)]\n #![feature(core_panic)]\n #![feature(duration_consts_float)]\n+#![feature(internal_impls_macro)]\n #![feature(ip)]\n #![feature(is_ascii_octdigit)]\n #![feature(maybe_uninit_uninit_array)]"}, {"sha": "52f3d208aba4e591094ad565780b3b34f60fe3b3", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 131, "deletions": 52, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -12,6 +12,60 @@ use crate::fmt::Debug;\n use crate::hash::Hash;\n use crate::hash::Hasher;\n \n+/// Implements a given marker trait for multiple types at the same time.\n+///\n+/// The basic syntax looks like this:\n+/// ```ignore private macro\n+/// marker_impls! { MarkerTrait for u8, i8 }\n+/// ```\n+/// You can also implement `unsafe` traits\n+/// ```ignore private macro\n+/// marker_impls! { unsafe MarkerTrait for u8, i8 }\n+/// ```\n+/// Add attributes to all impls:\n+/// ```ignore private macro\n+/// marker_impls! {\n+///     #[allow(lint)]\n+///     #[unstable(feature = \"marker_trait\", issue = \"none\")]\n+///     MarkerTrait for u8, i8\n+/// }\n+/// ```\n+/// And use generics:\n+/// ```ignore private macro\n+/// marker_impls! {\n+///     MarkerTrait for\n+///         u8, i8,\n+///         {T: ?Sized} *const T,\n+///         {T: ?Sized} *mut T,\n+///         {T: MarkerTrait} PhantomData<T>,\n+///         u32,\n+/// }\n+/// ```\n+#[unstable(feature = \"internal_impls_macro\", issue = \"none\")]\n+macro marker_impls {\n+    ( $(#[$($meta:tt)*])* $Trait:ident for $( $({$($bounds:tt)*})? $T:ty ),+ $(,)?) => {\n+        // This inner macro is needed because... idk macros are weird.\n+        // It allows repeating `meta` on all impls.\n+        #[unstable(feature = \"internal_impls_macro\", issue = \"none\")]\n+        macro _impl {\n+            ( $$({$$($$bounds_:tt)*})? $$T_:ty ) => {\n+                $(#[$($meta)*])* impl<$$($$($$bounds_)*)?> $Trait for $$T_ {}\n+            }\n+        }\n+        $( _impl! { $({$($bounds)*})? $T } )+\n+    },\n+    ( $(#[$($meta:tt)*])* unsafe $Trait:ident for $( $({$($bounds:tt)*})? $T:ty ),+ $(,)?) => {\n+        #[unstable(feature = \"internal_impls_macro\", issue = \"none\")]\n+        macro _impl {\n+            ( $$({$$($$bounds_:tt)*})? $$T_:ty ) => {\n+                $(#[$($meta)*])* unsafe impl<$$($$($$bounds_)*)?> $Trait for $$T_ {}\n+            }\n+        }\n+\n+        $( _impl! { $({$($bounds)*})? $T } )+\n+    },\n+}\n+\n /// Types that can be transferred across thread boundaries.\n ///\n /// This trait is automatically implemented when the compiler determines it's\n@@ -214,6 +268,20 @@ pub trait StructuralEq {\n     // Empty.\n }\n \n+// FIXME: Remove special cases of these types from the compiler pattern checking code and always check `T: StructuralEq` instead\n+marker_impls! {\n+    #[unstable(feature = \"structural_match\", issue = \"31434\")]\n+    StructuralEq for\n+        usize, u8, u16, u32, u64, u128,\n+        isize, i8, i16, i32, i64, i128,\n+        bool,\n+        char,\n+        str /* Technically requires `[u8]: StructuralEq` */,\n+        {T, const N: usize} [T; N],\n+        {T} [T],\n+        {T: ?Sized} &T,\n+}\n+\n /// Types whose values can be duplicated simply by copying bits.\n ///\n /// By default, variable bindings have 'move semantics.' In other\n@@ -401,6 +469,30 @@ pub macro Copy($item:item) {\n     /* compiler built-in */\n }\n \n+// Implementations of `Copy` for primitive types.\n+//\n+// Implementations that cannot be described in Rust\n+// are implemented in `traits::SelectionContext::copy_clone_conditions()`\n+// in `rustc_trait_selection`.\n+marker_impls! {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Copy for\n+        usize, u8, u16, u32, u64, u128,\n+        isize, i8, i16, i32, i64, i128,\n+        f32, f64,\n+        bool, char,\n+        {T: ?Sized} *const T,\n+        {T: ?Sized} *mut T,\n+\n+}\n+\n+#[unstable(feature = \"never_type\", issue = \"35121\")]\n+impl Copy for ! {}\n+\n+/// Shared references can be copied, but mutable references *cannot*!\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Copy for &T {}\n+\n /// Types for which it is safe to share references between threads.\n ///\n /// This trait is automatically implemented when the compiler determines\n@@ -778,11 +870,14 @@ pub trait DiscriminantKind {\n pub(crate) unsafe auto trait Freeze {}\n \n impl<T: ?Sized> !Freeze for UnsafeCell<T> {}\n-unsafe impl<T: ?Sized> Freeze for PhantomData<T> {}\n-unsafe impl<T: ?Sized> Freeze for *const T {}\n-unsafe impl<T: ?Sized> Freeze for *mut T {}\n-unsafe impl<T: ?Sized> Freeze for &T {}\n-unsafe impl<T: ?Sized> Freeze for &mut T {}\n+marker_impls! {\n+    unsafe Freeze for\n+        {T: ?Sized} PhantomData<T>,\n+        {T: ?Sized} *const T,\n+        {T: ?Sized} *mut T,\n+        {T: ?Sized} &T,\n+        {T: ?Sized} &mut T,\n+}\n \n /// Types that can be safely moved after being pinned.\n ///\n@@ -843,17 +938,19 @@ pub struct PhantomPinned;\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl !Unpin for PhantomPinned {}\n \n-#[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<'a, T: ?Sized + 'a> Unpin for &'a T {}\n-\n-#[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<'a, T: ?Sized + 'a> Unpin for &'a mut T {}\n-\n-#[stable(feature = \"pin_raw\", since = \"1.38.0\")]\n-impl<T: ?Sized> Unpin for *const T {}\n+marker_impls! {\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    Unpin for\n+        {T: ?Sized} &T,\n+        {T: ?Sized} &mut T,\n+}\n \n-#[stable(feature = \"pin_raw\", since = \"1.38.0\")]\n-impl<T: ?Sized> Unpin for *mut T {}\n+marker_impls! {\n+    #[stable(feature = \"pin_raw\", since = \"1.38.0\")]\n+    Unpin for\n+        {T: ?Sized} *const T,\n+        {T: ?Sized} *mut T,\n+}\n \n /// A marker for types that can be dropped.\n ///\n@@ -888,43 +985,25 @@ pub trait Tuple {}\n )]\n pub trait PointerLike {}\n \n-/// Implementations of `Copy` for primitive types.\n-///\n-/// Implementations that cannot be described in Rust\n-/// are implemented in `traits::SelectionContext::copy_clone_conditions()`\n-/// in `rustc_trait_selection`.\n-mod copy_impls {\n-\n-    use super::Copy;\n-\n-    macro_rules! impl_copy {\n-        ($($t:ty)*) => {\n-            $(\n-                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                impl Copy for $t {}\n-            )*\n-        }\n-    }\n-\n-    impl_copy! {\n-        usize u8 u16 u32 u64 u128\n-        isize i8 i16 i32 i64 i128\n-        f32 f64\n-        bool char\n-    }\n-\n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    impl Copy for ! {}\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized> Copy for *const T {}\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized> Copy for *mut T {}\n-\n-    /// Shared references can be copied, but mutable references *cannot*!\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized> Copy for &T {}\n+/// A marker for types which can be used as types of `const` generic parameters.\n+#[cfg_attr(not(bootstrap), lang = \"const_param_ty\")]\n+#[unstable(feature = \"adt_const_params\", issue = \"95174\")]\n+#[rustc_on_unimplemented(message = \"`{Self}` can't be used as a const parameter type\")]\n+pub trait ConstParamTy: StructuralEq {}\n+\n+// FIXME(generic_const_parameter_types): handle `ty::FnDef`/`ty::Closure`\n+// FIXME(generic_const_parameter_types): handle `ty::Tuple`\n+marker_impls! {\n+    #[unstable(feature = \"adt_const_params\", issue = \"95174\")]\n+    ConstParamTy for\n+        usize, u8, u16, u32, u64, u128,\n+        isize, i8, i16, i32, i64, i128,\n+        bool,\n+        char,\n+        str /* Technically requires `[u8]: ConstParamTy` */,\n+        {T: ConstParamTy, const N: usize} [T; N],\n+        {T: ConstParamTy} [T],\n+        {T: ?Sized + ConstParamTy} &T,\n }\n \n /// A common trait implemented by all function pointers."}, {"sha": "a4be7af886b458c951588d1370c7a0d622ca6945", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -1385,7 +1385,9 @@ impl<'test> TestCx<'test> {\n         let actual_errors = json::parse_output(&diagnostic_file_name, &proc_res.stderr, proc_res);\n         let mut unexpected = Vec::new();\n         let mut found = vec![false; expected_errors.len()];\n-        for actual_error in &actual_errors {\n+        for mut actual_error in actual_errors {\n+            actual_error.msg = self.normalize_output(&actual_error.msg, &[]);\n+\n             let opt_index =\n                 expected_errors.iter().enumerate().position(|(index, expected_error)| {\n                     !found[index]\n@@ -1404,7 +1406,8 @@ impl<'test> TestCx<'test> {\n \n                 None => {\n                     // If the test is a known bug, don't require that the error is annotated\n-                    if self.is_unexpected_compiler_message(actual_error, expect_help, expect_note) {\n+                    if self.is_unexpected_compiler_message(&actual_error, expect_help, expect_note)\n+                    {\n                         self.error(&format!(\n                             \"{}:{}: unexpected {}: '{}'\",\n                             file_name,"}, {"sha": "0da68ae757351aadad342bc3101feeccfa75f5ee", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_bad.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,13 @@\n+#![allow(incomplete_features)]\n+#![feature(adt_const_params)]\n+\n+fn check(_: impl std::marker::ConstParamTy) {}\n+\n+fn main() {\n+    check(main);               //~ error: `fn() {main}` can't be used as a const parameter type\n+    check(|| {});              //~ error: `[closure@$DIR/const_param_ty_bad.rs:8:11: 8:13]` can't be used as a const parameter type\n+    check(main as fn());       //~ error: `fn()` can't be used as a const parameter type\n+    check(&mut ());            //~ error: `&mut ()` can't be used as a const parameter type\n+    check(&mut () as *mut ()); //~ error: `*mut ()` can't be used as a const parameter type\n+    check(&() as *const ());   //~ error: `*const ()` can't be used as a const parameter type\n+}"}, {"sha": "de5704ee429ede4d9a93327434bf7853c9be7d4f", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_bad.stderr", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad.stderr?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,87 @@\n+error[E0277]: `fn() {main}` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_bad.rs:7:11\n+   |\n+LL |     check(main);\n+   |     ----- ^^^^ the trait `ConstParamTy` is not implemented for fn item `fn() {main}`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_bad.rs:4:18\n+   |\n+LL | fn check(_: impl std::marker::ConstParamTy) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error[E0277]: `[closure@$DIR/const_param_ty_bad.rs:8:11: 8:13]` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_bad.rs:8:11\n+   |\n+LL |     check(|| {});\n+   |     ----- ^^^^^ the trait `ConstParamTy` is not implemented for closure `[closure@$DIR/const_param_ty_bad.rs:8:11: 8:13]`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_bad.rs:4:18\n+   |\n+LL | fn check(_: impl std::marker::ConstParamTy) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error[E0277]: `fn()` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_bad.rs:9:11\n+   |\n+LL |     check(main as fn());\n+   |     ----- ^^^^^^^^^^^^ the trait `ConstParamTy` is not implemented for `fn()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_bad.rs:4:18\n+   |\n+LL | fn check(_: impl std::marker::ConstParamTy) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error[E0277]: `&mut ()` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_bad.rs:10:11\n+   |\n+LL |     check(&mut ());\n+   |     ----- ^^^^^^^ the trait `ConstParamTy` is not implemented for `&mut ()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_bad.rs:4:18\n+   |\n+LL | fn check(_: impl std::marker::ConstParamTy) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error[E0277]: `*mut ()` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_bad.rs:11:11\n+   |\n+LL |     check(&mut () as *mut ());\n+   |     ----- ^^^^^^^^^^^^^^^^^^ the trait `ConstParamTy` is not implemented for `*mut ()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_bad.rs:4:18\n+   |\n+LL | fn check(_: impl std::marker::ConstParamTy) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error[E0277]: `*const ()` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_bad.rs:12:11\n+   |\n+LL |     check(&() as *const ());\n+   |     ----- ^^^^^^^^^^^^^^^^ the trait `ConstParamTy` is not implemented for `*const ()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_bad.rs:4:18\n+   |\n+LL | fn check(_: impl std::marker::ConstParamTy) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "b0e3b13cc1ef94946fdd5ccf9e9672c81e933002", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_bad_empty_array.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad_empty_array.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,12 @@\n+#![allow(incomplete_features)]\n+#![feature(adt_const_params)]\n+\n+#[derive(PartialEq, Eq)]\n+struct NotParam;\n+\n+fn check<T: std::marker::ConstParamTy>() {}\n+\n+fn main() {\n+    check::<[NotParam; 0]>();\n+    //~^ error: `NotParam` can't be used as a const parameter type\n+}"}, {"sha": "ef55242df87421e4a03352a8235b8dbeffd020c2", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_bad_empty_array.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad_empty_array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad_empty_array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_bad_empty_array.stderr?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: `NotParam` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_bad_empty_array.rs:10:13\n+   |\n+LL |     check::<[NotParam; 0]>();\n+   |             ^^^^^^^^^^^^^ the trait `ConstParamTy` is not implemented for `NotParam`\n+   |\n+   = note: required for `[NotParam; 0]` to implement `ConstParamTy`\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_bad_empty_array.rs:7:13\n+   |\n+LL | fn check<T: std::marker::ConstParamTy>() {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "e4dc76703a2d8a4eb34444b036a6c0393e5228d1", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_generic_bounds_do_not_hold.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_generic_bounds_do_not_hold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_generic_bounds_do_not_hold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_generic_bounds_do_not_hold.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,13 @@\n+#![allow(incomplete_features)]\n+#![feature(adt_const_params)]\n+\n+#[derive(PartialEq, Eq)]\n+struct NotParam;\n+\n+fn check<T: std::marker::ConstParamTy + ?Sized>() {}\n+\n+fn main() {\n+    check::<&NotParam>();      //~ error: `NotParam` can't be used as a const parameter type\n+    check::<[NotParam]>();     //~ error: `NotParam` can't be used as a const parameter type\n+    check::<[NotParam; 17]>(); //~ error: `NotParam` can't be used as a const parameter type\n+}"}, {"sha": "86d1c94e87f966ef2c216c197b8631ae6d9c87c9", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_generic_bounds_do_not_hold.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_generic_bounds_do_not_hold.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_generic_bounds_do_not_hold.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_generic_bounds_do_not_hold.stderr?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,42 @@\n+error[E0277]: `NotParam` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_generic_bounds_do_not_hold.rs:10:13\n+   |\n+LL |     check::<&NotParam>();\n+   |             ^^^^^^^^^ the trait `ConstParamTy` is not implemented for `NotParam`\n+   |\n+   = note: required for `&NotParam` to implement `ConstParamTy`\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_generic_bounds_do_not_hold.rs:7:13\n+   |\n+LL | fn check<T: std::marker::ConstParamTy + ?Sized>() {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error[E0277]: `NotParam` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_generic_bounds_do_not_hold.rs:11:13\n+   |\n+LL |     check::<[NotParam]>();\n+   |             ^^^^^^^^^^ the trait `ConstParamTy` is not implemented for `NotParam`\n+   |\n+   = note: required for `[NotParam]` to implement `ConstParamTy`\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_generic_bounds_do_not_hold.rs:7:13\n+   |\n+LL | fn check<T: std::marker::ConstParamTy + ?Sized>() {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error[E0277]: `NotParam` can't be used as a const parameter type\n+  --> $DIR/const_param_ty_generic_bounds_do_not_hold.rs:12:13\n+   |\n+LL |     check::<[NotParam; 17]>();\n+   |             ^^^^^^^^^^^^^^ the trait `ConstParamTy` is not implemented for `NotParam`\n+   |\n+   = note: required for `[NotParam; 17]` to implement `ConstParamTy`\n+note: required by a bound in `check`\n+  --> $DIR/const_param_ty_generic_bounds_do_not_hold.rs:7:13\n+   |\n+LL | fn check<T: std::marker::ConstParamTy + ?Sized>() {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a1b711a3024e33666afb4e9a9e082f6e29f385d3", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_good.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_good.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_good.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_good.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,43 @@\n+// check-pass\n+#![allow(incomplete_features)]\n+#![feature(adt_const_params)]\n+use std::marker::ConstParamTy;\n+\n+#[derive(PartialEq, Eq)]\n+struct S<T> {\n+    field: u8,\n+    gen: T,\n+}\n+\n+impl<T: ConstParamTy> ConstParamTy for S<T> {}\n+\n+fn check<T: ConstParamTy + ?Sized>() {}\n+\n+fn main() {\n+    check::<u8>();\n+    check::<u16>();\n+    check::<u32>();\n+    check::<u64>();\n+    check::<u128>();\n+\n+    check::<i8>();\n+    check::<i16>();\n+    check::<i32>();\n+    check::<i64>();\n+    check::<i128>();\n+\n+    check::<char>();\n+    check::<bool>();\n+    check::<str>();\n+\n+    check::<&u8>();\n+    check::<&str>();\n+    check::<[usize]>();\n+    check::<[u16; 0]>();\n+    check::<[u8; 42]>();\n+\n+    check::<S<u8>>();\n+    check::<S<[&[bool]; 8]>>();\n+\n+    // FIXME: test tuples\n+}"}, {"sha": "07fd243737e2ac8ae026317e7592a3c6ac3927a7", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_impl_bad_field.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_bad_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_bad_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_bad_field.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,13 @@\n+#![allow(incomplete_features)]\n+#![feature(adt_const_params)]\n+\n+#[derive(PartialEq, Eq)]\n+struct NotParam;\n+\n+#[derive(PartialEq, Eq)]\n+struct CantParam(NotParam);\n+\n+impl std::marker::ConstParamTy for CantParam {}\n+//~^ error: the trait `ConstParamTy` cannot be implemented for this type\n+\n+fn main() {}"}, {"sha": "c8e065848b1e0dc481ed4a66d1f06b0b28288bab", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_impl_bad_field.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_bad_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_bad_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_bad_field.stderr?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,12 @@\n+error[E0204]: the trait `ConstParamTy` cannot be implemented for this type\n+  --> $DIR/const_param_ty_impl_bad_field.rs:10:36\n+   |\n+LL | struct CantParam(NotParam);\n+   |                  -------- this field does not implement `ConstParamTy`\n+LL |\n+LL | impl std::marker::ConstParamTy for CantParam {}\n+   |                                    ^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0204`."}, {"sha": "17ef396164efdf6e467c895d509156b59f13c6d2", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_impl_no_structural_eq.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_no_structural_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_no_structural_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_no_structural_eq.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,17 @@\n+#![allow(incomplete_features)]\n+#![feature(adt_const_params)]\n+\n+#[derive(PartialEq, Eq)]\n+struct ImplementsConstParamTy;\n+impl std::marker::ConstParamTy for ImplementsConstParamTy {}\n+\n+struct CantParam(ImplementsConstParamTy);\n+\n+impl std::marker::ConstParamTy for CantParam {}\n+//~^ error: the type `CantParam` does not `#[derive(Eq)]`\n+\n+fn check<T: std::marker::ConstParamTy>() {}\n+\n+fn main() {\n+    check::<ImplementsConstParamTy>();\n+}"}, {"sha": "ca5abf5e25420350cf458cb1a65ec13600c09522", "filename": "tests/ui/const-generics/adt_const_params/const_param_ty_impl_no_structural_eq.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_no_structural_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_no_structural_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fadt_const_params%2Fconst_param_ty_impl_no_structural_eq.stderr?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the type `CantParam` does not `#[derive(Eq)]`\n+  --> $DIR/const_param_ty_impl_no_structural_eq.rs:10:36\n+   |\n+LL | impl std::marker::ConstParamTy for CantParam {}\n+   |                                    ^^^^^^^^^ the trait `StructuralEq` is not implemented for `CantParam`\n+   |\n+note: required by a bound in `ConstParamTy`\n+  --> $SRC_DIR/core/src/marker.rs:LL:COL\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "ff95018065a843faff5f2a93b3cedb68c7726bc0", "filename": "tests/ui/const-generics/nested-type.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fnested-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fconst-generics%2Fnested-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fnested-type.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -3,7 +3,7 @@\n #![cfg_attr(full, feature(adt_const_params))]\n #![cfg_attr(full, allow(incomplete_features))]\n \n-struct Foo<const N: [u8; { //[min]~ ERROR `[u8; _]` is forbidden\n+struct Foo<const N: [u8; {\n     struct Foo<const N: usize>;\n \n     impl<const N: usize> Foo<N> {\n@@ -15,5 +15,9 @@ struct Foo<const N: [u8; { //[min]~ ERROR `[u8; _]` is forbidden\n     Foo::<17>::value()\n     //~^ ERROR cannot call non-const fn\n }]>;\n+//[min]~^^^^^^^^^^^^ ERROR `[u8; {\n+\n+// N.B. it is important that the comment above is not inside the array length,\n+//      otherwise it may check for itself, instead of the actual error\n \n fn main() {}"}, {"sha": "9b436e2c479f27faa818ec50811b836ae8fc84d5", "filename": "tests/ui/fmt/format-string-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Ffmt%2Fformat-string-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Ffmt%2Fformat-string-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fformat-string-error.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     let _ = format!(\"}\");\n     //~^ ERROR invalid format string: unmatched `}` found\n     let _ = format!(\"{\\\\}\");\n-    //~^ ERROR invalid format string: expected `'}'`, found `'\\\\'`\n+    //~^ ERROR invalid format string: expected `'}'`, found `'\\'`\n     let _ = format!(\"\\n\\n\\n{\\n\\n\\n\");\n     //~^ ERROR invalid format string\n     let _ = format!(r###\""}, {"sha": "a55ef5ac7103036b71616d6ae44324a5af1bd588", "filename": "tests/ui/parser/issues/issue-62913.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fparser%2Fissues%2Fissue-62913.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b727132e23aaa4e80eb82816d95c20023940f916/tests%2Fui%2Fparser%2Fissues%2Fissue-62913.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-62913.rs?ref=b727132e23aaa4e80eb82816d95c20023940f916", "patch": "@@ -1,4 +1,4 @@\n \"\\u\\\\\"\n //~^ ERROR incorrect unicode escape sequence\n //~| ERROR invalid trailing slash in literal\n-//~| ERROR expected item, found `\"\\u\\\\\"`\n+//~| ERROR expected item, found `\"\\u\\\"`"}]}