{"sha": "2ebe7516a898ddd44c9021b080cbaf079e32121c", "node_id": "C_kwDOAAsO6NoAKDJlYmU3NTE2YTg5OGRkZDQ0YzkwMjFiMDgwY2JhZjA3OWUzMjEyMWM", "commit": {"author": {"name": "Jaeyong Sung", "email": "jaeyong0201@gmail.com", "date": "2022-02-13T04:32:40Z"}, "committer": {"name": "Jaeyong Sung", "email": "jaeyong0201@gmail.com", "date": "2022-02-13T04:32:40Z"}, "message": "add documentation", "tree": {"sha": "97f36b1c64efd576c50ec8d09985672652235b33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97f36b1c64efd576c50ec8d09985672652235b33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ebe7516a898ddd44c9021b080cbaf079e32121c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEErNAvdl6JhsmcOZwWK4aJjMsqVIYFAmIIiegACgkQK4aJjMsq\nVIaYOQ//bkx9oMg+tFDdSaJt+ZYBWlsTp1qA9rrq/KKh2UkPriSMc2Ys9VBFOQ5S\nZhL+6E5stjQOCMj15ovghrXMHuVkkNCmCwQOUpYa5s02hdu2SuDkra3kvUJZwHs+\nOW7ZV7fKaT3LJ4KczwKj1MNTz1R7RQJgbi0EEkcOGVizSk9LmK0hxxLi+5zX9HKR\ng4wO++dDQ2+siAA2BKS+ODpRj0RsHqPdyl7h/3pg5Zl1YeGBLXBT3Ns24nCxPXS3\nb9Itv/9HnfaKHZcmy5KTGfr8P3vbMoDCjuoEKWRHdhpVkFjRXD0mykl9NQNPX9Oe\nlS1K3ZjCWq2nH/txX7NtnAb9xWLr5GhD+rYc/TqgkN/WlXpMU6D8bDsRO07OCtLR\nDgYUvCCsvD4rQTeysvdeh1AbCEpGsuBkBm6dnJ4uJeICASXclsrFeaGvDFQKgNSN\nfp5xjFeKnZVMOa8jRClbf69sleFfvjOuZH4szMu6aH4pDyMBwGWiVIBrNPJkvUJd\nB63Zer+sGN1s9VgF1lagyrQtAGGjAsTfCODI2EFaPuN8TlF+8ZZyX9kvEL2Row+Y\nTwkMd7p9aUqfVg6y7+LdQbsNhMDpJXEOaOw4p7L+YCUeYbmC/ULVI4aIdigpgVkR\nIN4kDMWQWA7OgB6ADskFpsZIO61d5JjYjRczlYgURlrN4OeVRLA=\n=kIBd\n-----END PGP SIGNATURE-----", "payload": "tree 97f36b1c64efd576c50ec8d09985672652235b33\nparent 2b3e7faf8de5a97ea73f14e31dff218de22b6389\nauthor Jaeyong Sung <jaeyong0201@gmail.com> 1644726760 +0900\ncommitter Jaeyong Sung <jaeyong0201@gmail.com> 1644726760 +0900\n\nadd documentation\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ebe7516a898ddd44c9021b080cbaf079e32121c", "html_url": "https://github.com/rust-lang/rust/commit/2ebe7516a898ddd44c9021b080cbaf079e32121c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ebe7516a898ddd44c9021b080cbaf079e32121c/comments", "author": {"login": "buttercrab", "id": 34997549, "node_id": "MDQ6VXNlcjM0OTk3NTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/34997549?v=4", "gravatar_id": "", "url": "https://api.github.com/users/buttercrab", "html_url": "https://github.com/buttercrab", "followers_url": "https://api.github.com/users/buttercrab/followers", "following_url": "https://api.github.com/users/buttercrab/following{/other_user}", "gists_url": "https://api.github.com/users/buttercrab/gists{/gist_id}", "starred_url": "https://api.github.com/users/buttercrab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/buttercrab/subscriptions", "organizations_url": "https://api.github.com/users/buttercrab/orgs", "repos_url": "https://api.github.com/users/buttercrab/repos", "events_url": "https://api.github.com/users/buttercrab/events{/privacy}", "received_events_url": "https://api.github.com/users/buttercrab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "buttercrab", "id": 34997549, "node_id": "MDQ6VXNlcjM0OTk3NTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/34997549?v=4", "gravatar_id": "", "url": "https://api.github.com/users/buttercrab", "html_url": "https://github.com/buttercrab", "followers_url": "https://api.github.com/users/buttercrab/followers", "following_url": "https://api.github.com/users/buttercrab/following{/other_user}", "gists_url": "https://api.github.com/users/buttercrab/gists{/gist_id}", "starred_url": "https://api.github.com/users/buttercrab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/buttercrab/subscriptions", "organizations_url": "https://api.github.com/users/buttercrab/orgs", "repos_url": "https://api.github.com/users/buttercrab/repos", "events_url": "https://api.github.com/users/buttercrab/events{/privacy}", "received_events_url": "https://api.github.com/users/buttercrab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b3e7faf8de5a97ea73f14e31dff218de22b6389", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3e7faf8de5a97ea73f14e31dff218de22b6389", "html_url": "https://github.com/rust-lang/rust/commit/2b3e7faf8de5a97ea73f14e31dff218de22b6389"}], "stats": {"total": 65, "additions": 51, "deletions": 14}, "files": [{"sha": "b8e0bd8acb3e71e36a5e7df113db0ec4a2994cf4", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2ebe7516a898ddd44c9021b080cbaf079e32121c/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebe7516a898ddd44c9021b080cbaf079e32121c/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=2ebe7516a898ddd44c9021b080cbaf079e32121c", "patch": "@@ -21,7 +21,7 @@ use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for arguments that is only used in recursion with no side-effects.\n+    /// Checks for arguments that are only used in recursion with no side-effects.\n     /// The arguments can be involved in calculations and assignments but as long as\n     /// the calculations have no side-effects (function calls or mutating dereference)\n     /// and the assigned variables are also only in recursion, it is useless.\n@@ -30,7 +30,21 @@ declare_clippy_lint! {\n     /// The could contain a useless calculation and can make function simpler.\n     ///\n     /// ### Known problems\n-    /// It could not catch the variable that has no side effects but only used in recursion.\n+    /// In some cases, this would not catch all useless arguments.\n+    ///\n+    /// ```rust\n+    /// fn foo(a: usize, b: usize) -> usize {\n+    ///     let f = |x| x + 1;\n+    ///\n+    ///     if a == 0 {\n+    ///         1\n+    ///     } else {\n+    ///         foo(a - 1, f(b))\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// For example, the argument `b` is only used in recursion, but the lint would not catch it.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -111,10 +125,12 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n \n             visitor.visit_expr(&body.value);\n             let vars = std::mem::take(&mut visitor.ret_vars);\n+            // this would set the return variables to side effect\n             visitor.add_side_effect(vars);\n \n             let mut queue = visitor.has_side_effect.iter().copied().collect::<VecDeque<_>>();\n \n+            // a simple BFS to check all the variables that have side effect\n             while let Some(id) = queue.pop_front() {\n                 if let Some(next) = visitor.graph.get(&id) {\n                     for i in next {\n@@ -134,6 +150,8 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n \n                     queue.push_back(id);\n \n+                    // a simple BFS to check the graph can reach to itself\n+                    // if it can't, it means the variable is never used in recursion\n                     while let Some(id) = queue.pop_front() {\n                         if let Some(next) = visitor.graph.get(&id) {\n                             for i in next {\n@@ -150,7 +168,7 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n                             cx,\n                             ONLY_USED_IN_RECURSION,\n                             span,\n-                            \"parameter is only used in recursion with no side-effects\",\n+                            \"parameter is only used in recursion\",\n                             \"if this is intentional, prefix with an underscore\",\n                             format!(\"_{}\", ident.name.as_str()),\n                             Applicability::MaybeIncorrect,\n@@ -178,6 +196,21 @@ pub fn is_array(ty: Ty<'_>) -> bool {\n     }\n }\n \n+/// This builds the graph of side effect.\n+/// The edge `a -> b` means if `a` has side effect, `b` will have side effect.\n+///\n+/// There are some exmaple in following code:\n+/// ```rust, ignore\n+/// let b = 1;\n+/// let a = b; // a -> b\n+/// let (c, d) = (a, b); // c -> b, d -> b\n+///\n+/// let e = if a == 0 { // e -> a\n+///     c // e -> c\n+/// } else {\n+///     d // e -> d\n+/// };\n+/// ```\n pub struct SideEffectVisit<'tcx> {\n     graph: FxHashMap<HirId, FxHashSet<HirId>>,\n     has_side_effect: FxHashSet<HirId>,\n@@ -241,6 +274,7 @@ impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n                 self.visit_if(bind, then_expr, else_expr);\n             },\n             ExprKind::Match(expr, arms, _) => self.visit_match(expr, arms),\n+            // since analysing the closure is not easy, just set all variables in it to side-effect\n             ExprKind::Closure(_, _, body_id, _, _) => {\n                 let body = self.ty_ctx.hir().body(body_id);\n                 self.visit_body(body);\n@@ -359,6 +393,9 @@ impl<'tcx> SideEffectVisit<'tcx> {\n         let mut ret_vars = std::mem::take(&mut self.ret_vars);\n         self.visit_expr(rhs);\n         self.ret_vars.append(&mut ret_vars);\n+\n+        // the binary operation between non primitive values are overloaded operators\n+        // so they can have side-effects\n         if !is_primitive(self.ty_res.expr_ty(lhs)) || !is_primitive(self.ty_res.expr_ty(rhs)) {\n             self.ret_vars.iter().for_each(|id| {\n                 self.has_side_effect.insert(id.0);"}, {"sha": "ed942e06f2635f1886c63eec35a2f48d961467ce", "filename": "tests/ui/only_used_in_recursion.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2ebe7516a898ddd44c9021b080cbaf079e32121c/tests%2Fui%2Fonly_used_in_recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ebe7516a898ddd44c9021b080cbaf079e32121c/tests%2Fui%2Fonly_used_in_recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.stderr?ref=2ebe7516a898ddd44c9021b080cbaf079e32121c", "patch": "@@ -1,66 +1,66 @@\n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:3:21\n    |\n LL | fn simple(a: usize, b: usize) -> usize {\n    |                     ^ help: if this is intentional, prefix with an underscore: `_b`\n    |\n    = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:7:24\n    |\n LL | fn with_calc(a: usize, b: isize) -> usize {\n    |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:11:14\n    |\n LL | fn tuple((a, b): (usize, usize)) -> usize {\n    |              ^ help: if this is intentional, prefix with an underscore: `_b`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:15:24\n    |\n LL | fn let_tuple(a: usize, b: usize) -> usize {\n    |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:20:14\n    |\n LL | fn array([a, b]: [usize; 2]) -> usize {\n    |              ^ help: if this is intentional, prefix with an underscore: `_b`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:24:20\n    |\n LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n    |                    ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:24:37\n    |\n LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n    |                                     ^ help: if this is intentional, prefix with an underscore: `_c`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:28:21\n    |\n LL | fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n    |                     ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:46:23\n    |\n LL | fn mut_ref2(a: usize, b: &mut usize) -> usize {\n    |                       ^ help: if this is intentional, prefix with an underscore: `_b`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:51:28\n    |\n LL | fn not_primitive(a: usize, b: String) -> usize {\n    |                            ^ help: if this is intentional, prefix with an underscore: `_b`\n \n-error: parameter is only used in recursion with no side-effects\n+error: parameter is only used in recursion\n   --> $DIR/only_used_in_recursion.rs:64:32\n    |\n LL |     fn method(&self, a: usize, b: usize) -> usize {"}]}