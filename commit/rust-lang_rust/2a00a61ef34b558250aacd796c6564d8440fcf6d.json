{"sha": "2a00a61ef34b558250aacd796c6564d8440fcf6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMDBhNjFlZjM0YjU1ODI1MGFhY2Q3OTZjNjU2NGQ4NDQwZmNmNmQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-29T23:46:07Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-29T23:46:07Z"}, "message": "Thread a 'simplification' flag through unifier, attempt to strip off layers of ignorable types when simplification is permitted.\n\nGets std.rc through typechecking, but assigns some wrong types to lvals (the simplified types, not the correct ones).", "tree": {"sha": "bdc1c4ae849064cc10336fec1b8a23c0adb451a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdc1c4ae849064cc10336fec1b8a23c0adb451a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a00a61ef34b558250aacd796c6564d8440fcf6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a00a61ef34b558250aacd796c6564d8440fcf6d", "html_url": "https://github.com/rust-lang/rust/commit/2a00a61ef34b558250aacd796c6564d8440fcf6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a00a61ef34b558250aacd796c6564d8440fcf6d/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b11a52a37d389dda85cfb810f2b93548c5d2a49", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b11a52a37d389dda85cfb810f2b93548c5d2a49", "html_url": "https://github.com/rust-lang/rust/commit/7b11a52a37d389dda85cfb810f2b93548c5d2a49"}], "stats": {"total": 283, "additions": 149, "deletions": 134}, "files": [{"sha": "7b0a6c7df859b5bed1589405e1976f2b1829faf9", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 149, "deletions": 134, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/2a00a61ef34b558250aacd796c6564d8440fcf6d/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/2a00a61ef34b558250aacd796c6564d8440fcf6d/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=2a00a61ef34b558250aacd796c6564d8440fcf6d", "patch": "@@ -33,23 +33,6 @@ type binopsig =\n   | BINOPSIG_plus_plus_plus     (* plusable a * plusable a -> plusable a *)\n ;;\n \n-\n-(* In some instances we will strip off a layer of mutability or exterior-ness,\n- * as trans is willing to transplant and/or overlook mutability / exterior\n- * differences wrt. many operators.\n- * \n- * Note: there is a secondary mutability-checking pass in effect.ml to ensure\n- * you're not actually mutating the insides of an immutable. That's not the\n- * typechecker's job.\n- *)\n-let simplified t =\n-  match t with\n-      Ast.TY_mutable (Ast.TY_exterior t) -> t\n-    | Ast.TY_mutable t -> t\n-    | Ast.TY_exterior t -> t\n-    | _ -> t\n-;;\n-\n let rec tyspec_to_str (ts:tyspec) : string =\n \n   let fmt = Format.fprintf in\n@@ -214,40 +197,70 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n   let visitor (cx:ctxt) (inner:Walk.visitor) : Walk.visitor =\n \n     let rec unify_slot\n+        (simplify:bool)\n         (slot:Ast.slot)\n         (id_opt:node_id option)\n         (tv:tyvar) : unit =\n       match id_opt with\n-          Some id -> unify_tyvars (Hashtbl.find bindings id) tv\n+          Some id -> unify_tyvars simplify (Hashtbl.find bindings id) tv\n         | None ->\n             match slot.Ast.slot_ty with\n                 None -> bug () \"untyped unidentified slot\"\n-              | Some ty -> unify_ty ty tv\n+              | Some ty -> unify_ty simplify ty tv\n \n     and check_sane_tyvar tv =\n       match !tv with\n           TYSPEC_resolved (_, (Ast.TY_named _)) ->\n             bug () \"named-type in type checker\"\n         | _ -> ()\n \n-    and unify_tyvars  (av:tyvar) (bv:tyvar) : unit =\n-      iflog cx (fun _ ->\n-                  log cx \"unifying types:\";\n-                  log cx \"input tyvar A: %s\" (tyspec_to_str !av);\n-                  log cx \"input tyvar B: %s\" (tyspec_to_str !bv));\n-      check_sane_tyvar av;\n-      check_sane_tyvar bv;\n-\n-      unify_tyvars' av bv;\n-\n-      iflog cx (fun _ ->\n-                  log cx \"unified types:\";\n-                  log cx \"output tyvar A: %s\" (tyspec_to_str !av);\n-                  log cx \"output tyvar B: %s\" (tyspec_to_str !bv));\n-      check_sane_tyvar av;\n-      check_sane_tyvar bv;\n-\n-    and unify_tyvars' (av:tyvar) (bv:tyvar) : unit =\n+    and unify_tyvars (simplify:bool) (av:tyvar) (bv:tyvar) : unit =\n+      let sstr = if simplify then \"w/ simplification\" else \"\" in\n+        iflog cx (fun _ ->\n+                    log cx \"unifying types%s:\" sstr;\n+                    log cx \"input tyvar A: %s\" (tyspec_to_str !av);\n+                    log cx \"input tyvar B: %s\" (tyspec_to_str !bv));\n+        check_sane_tyvar av;\n+        check_sane_tyvar bv;\n+\n+        unify_tyvars' simplify av bv;\n+\n+        iflog cx (fun _ ->\n+                    log cx \"unified types%s:\" sstr;\n+                    log cx \"output tyvar A: %s\" (tyspec_to_str !av);\n+                    log cx \"output tyvar B: %s\" (tyspec_to_str !bv));\n+        check_sane_tyvar av;\n+        check_sane_tyvar bv;\n+\n+\n+    (* In some instances we will strip off a layer of mutability or\n+     * exterior-ness, as trans is willing to transplant and/or overlook\n+     * mutability / exterior differences wrt. many operators.\n+     * \n+     * Note: there is a secondary mutability-checking pass in effect.ml to\n+     * ensure you're not actually mutating the insides of an immutable. That's\n+     * not the typechecker's job.\n+     *)\n+    and unify_tyvars' (simplify:bool) (av:tyvar) (bv:tyvar) : unit =\n+      let (a, b) = ((resolve_tyvar av), (resolve_tyvar bv)) in\n+      let simplified tv =\n+        match !tv with\n+            TYSPEC_resolved (params_a, Ast.TY_mutable ty_a) ->\n+              Some (ref (TYSPEC_resolved (params_a, ty_a)))\n+          | TYSPEC_resolved (params_a, Ast.TY_exterior ty_a) ->\n+              Some (ref (TYSPEC_resolved (params_a, ty_a)))\n+          | _ -> None\n+      in\n+        if simplify\n+        then\n+          match (simplified a, simplified b) with\n+              (Some a', _) -> unify_tyvars' simplify a' bv\n+            | (_, Some b') -> unify_tyvars' simplify av b'\n+            | (None, None) -> unify_tyvars'' av bv\n+        else\n+          unify_tyvars'' av bv\n+\n+    and unify_tyvars'' (av:tyvar) (bv:tyvar) : unit =\n       let (a, b) = ((resolve_tyvar av), (resolve_tyvar bv)) in\n       let fail () =\n         err None \"mismatched types: %s vs. %s\" (tyspec_to_str !av)\n@@ -258,7 +271,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         let c = Hashtbl.create ((Hashtbl.length a) + (Hashtbl.length b)) in\n         let merge ident tv_a =\n           if Hashtbl.mem c ident\n-          then unify_tyvars (Hashtbl.find c ident) tv_a\n+          then unify_tyvars false (Hashtbl.find c ident) tv_a\n           else Hashtbl.add c ident tv_a\n         in\n           Hashtbl.iter (Hashtbl.add c) b;\n@@ -277,7 +290,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         in\n \n         let check_entry ident tv =\n-          unify_ty (find_ty ident) tv\n+          unify_ty false (find_ty ident) tv\n         in\n           Hashtbl.iter check_entry dct\n       in\n@@ -288,7 +301,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         let check_entry (query:Ast.ident) tv : unit =\n           match htab_search fns query with\n               None -> fail ()\n-            | Some fn -> unify_ty (Ast.TY_fn fn) tv\n+            | Some fn -> unify_ty false (Ast.TY_fn fn) tv\n         in\n           Hashtbl.iter check_entry dct\n       in\n@@ -311,13 +324,13 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n       in\n \n       let floating (ty:Ast.ty) : bool =\n-        match simplified ty with\n+        match ty with\n             Ast.TY_mach TY_f32 | Ast.TY_mach TY_f64 -> true\n           | _ -> false\n       in\n \n       let integral (ty:Ast.ty) : bool =\n-        match simplified ty with\n+        match ty with\n             Ast.TY_int | Ast.TY_uint | Ast.TY_mach TY_u8 | Ast.TY_mach TY_u16\n           | Ast.TY_mach TY_u32 | Ast.TY_mach TY_u64 | Ast.TY_mach TY_i8\n           | Ast.TY_mach TY_i16 | Ast.TY_mach TY_i32\n@@ -329,7 +342,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n       let numeric (ty:Ast.ty) : bool = (integral ty) || (floating ty) in\n \n       let plusable (ty:Ast.ty) : bool =\n-        match simplified ty with\n+        match ty with\n             Ast.TY_str -> true\n           | Ast.TY_vec _ -> true\n           | _ -> numeric ty\n@@ -365,7 +378,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | (TYSPEC_callable (out_tv, in_tvs),\n              TYSPEC_resolved (params, ty)) ->\n               let unify_in_slot i in_slot =\n-                unify_slot in_slot None in_tvs.(i)\n+                unify_slot true in_slot None in_tvs.(i)\n               in\n                 begin\n                   match ty with\n@@ -375,7 +388,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                                  }, _) ->\n                         if Array.length in_slots != Array.length in_tvs\n                         then fail ();\n-                        unify_slot out_slot None out_tv;\n+                        unify_slot true out_slot None out_tv;\n                         Array.iteri unify_in_slot in_slots\n                     | _ -> fail ()\n                 end;\n@@ -385,8 +398,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | (TYSPEC_collection tv, TYSPEC_resolved (params, ty)) ->\n               begin\n                 match ty with\n-                    Ast.TY_vec ty -> unify_ty ty tv\n-                  | Ast.TY_str -> unify_ty (Ast.TY_mach TY_u8) tv\n+                    Ast.TY_vec ty -> unify_ty false ty tv\n+                  | Ast.TY_str -> unify_ty false (Ast.TY_mach TY_u8) tv\n                   | _ -> fail ()\n               end;\n               TYSPEC_resolved (params, ty)\n@@ -438,7 +451,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | (TYSPEC_resolved (params, ty), TYSPEC_app (tv, args))\n           | (TYSPEC_app (tv, args), TYSPEC_resolved (params, ty)) ->\n               let ty = rebuild_ty_under_params ty params args false in\n-                unify_ty ty tv;\n+                unify_ty false ty tv;\n                 TYSPEC_resolved ([| |], ty)\n \n           | (TYSPEC_resolved (params, ty), TYSPEC_record dct)\n@@ -460,7 +473,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                       then fail ()\n                       else\n                         let check_elem i tv =\n-                          unify_ty (elem_tys.(i)) tv\n+                          unify_ty false (elem_tys.(i)) tv\n                         in\n                           Array.iteri check_elem tvs\n                   | _ -> fail ()\n@@ -472,7 +485,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               begin\n                 match ty with\n                     Ast.TY_vec ty ->\n-                      unify_ty ty tv;\n+                      unify_ty false ty tv;\n                       TYSPEC_resolved (params, Ast.TY_vec ty)\n                   | _ -> fail ()\n               end\n@@ -481,11 +494,12 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n \n           | (TYSPEC_callable (a_out_tv, a_in_tvs),\n              TYSPEC_callable (b_out_tv, b_in_tvs)) ->\n-              unify_tyvars a_out_tv b_out_tv;\n+              unify_tyvars true a_out_tv b_out_tv;\n               let check_in_tv i a_in_tv =\n-                unify_tyvars a_in_tv b_in_tvs.(i)\n+                unify_tyvars true a_in_tv b_in_tvs.(i)\n               in\n                 Array.iteri check_in_tv a_in_tvs;\n+                unify_tyvars true a_out_tv b_out_tv;\n                 TYSPEC_callable (a_out_tv, a_in_tvs)\n \n           | (TYSPEC_callable _, TYSPEC_collection _)\n@@ -516,7 +530,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           (* collection *)\n \n           | (TYSPEC_collection av, TYSPEC_collection bv) ->\n-              unify_tyvars av bv;\n+              unify_tyvars false av bv;\n               TYSPEC_collection av\n \n           | (TYSPEC_collection av, TYSPEC_comparable)\n@@ -545,7 +559,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n \n           | (TYSPEC_collection av, TYSPEC_vector bv)\n           | (TYSPEC_vector bv, TYSPEC_collection av) ->\n-              unify_tyvars av bv;\n+              unify_tyvars false av bv;\n               TYSPEC_vector av\n \n           (* comparable *)\n@@ -714,7 +728,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               then fail()\n               else\n                 begin\n-                  unify_tyvars tv_a tv_b;\n+                  unify_tyvars false tv_a tv_b;\n                   TYSPEC_app (tv_a, args_a)\n                 end\n \n@@ -747,7 +761,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                 else if i >= len_b\n                 then tvs_a.(i)\n                 else begin\n-                  unify_tyvars tvs_a.(i) tvs_b.(i);\n+                  unify_tyvars false tvs_a.(i) tvs_b.(i);\n                   tvs_a.(i)\n                 end\n               in\n@@ -759,26 +773,27 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           (* vector *)\n \n           | (TYSPEC_vector av, TYSPEC_vector bv) ->\n-              unify_tyvars av bv;\n+              unify_tyvars false av bv;\n               TYSPEC_vector av\n       in\n       let c = ref result in\n         a := TYSPEC_equiv c;\n         b := TYSPEC_equiv c\n \n     and unify_ty_parametric\n+        (simplify:bool)\n         (ty:Ast.ty)\n         (tps:Ast.ty_param array)\n         (tv:tyvar)\n         : unit =\n-      unify_tyvars (ref (TYSPEC_resolved (tps, ty))) tv\n+      unify_tyvars simplify (ref (TYSPEC_resolved (tps, ty))) tv\n \n-    and unify_ty (ty:Ast.ty) (tv:tyvar) : unit =\n-      unify_ty_parametric ty [||] tv\n+    and unify_ty (simplify:bool) (ty:Ast.ty) (tv:tyvar) : unit =\n+      unify_ty_parametric simplify ty [||] tv\n \n     in\n \n-    let rec unify_lit (lit:Ast.lit) (tv:tyvar) : unit =\n+    let rec unify_lit (simplify:bool) (lit:Ast.lit) (tv:tyvar) : unit =\n       let ty =\n         match lit with\n             Ast.LIT_nil -> Ast.TY_nil\n@@ -788,14 +803,14 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | Ast.LIT_uint (_, _) -> Ast.TY_uint\n           | Ast.LIT_char _ -> Ast.TY_char\n       in\n-        unify_ty ty tv\n+        unify_ty simplify ty tv\n \n-    and unify_atom (atom:Ast.atom) (tv:tyvar) : unit =\n+    and unify_atom (simplify:bool) (atom:Ast.atom) (tv:tyvar) : unit =\n       match atom with\n           Ast.ATOM_literal { node = literal; id = _ } ->\n-            unify_lit literal tv\n+            unify_lit simplify literal tv\n         | Ast.ATOM_lval lval ->\n-            unify_lval lval tv\n+            unify_lval simplify lval tv\n \n     and unify_expr (expr:Ast.expr) (tv:tyvar) : unit =\n       match expr with\n@@ -828,64 +843,64 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               begin\n                 match binop_sig with\n                     BINOPSIG_bool_bool_bool ->\n-                      unify_atom lhs\n+                      unify_atom true lhs\n                         (ref (TYSPEC_resolved ([||], Ast.TY_bool)));\n-                      unify_atom rhs\n+                      unify_atom true rhs\n                         (ref (TYSPEC_resolved ([||], Ast.TY_bool)));\n-                      unify_ty Ast.TY_bool tv\n+                      unify_ty true Ast.TY_bool tv\n                   | BINOPSIG_comp_comp_bool ->\n                       let tv_a = ref TYSPEC_comparable in\n-                        unify_atom lhs tv_a;\n-                        unify_atom rhs tv_a;\n-                        unify_ty Ast.TY_bool tv\n+                        unify_atom true lhs tv_a;\n+                        unify_atom true rhs tv_a;\n+                        unify_ty true Ast.TY_bool tv\n                   | BINOPSIG_ord_ord_bool ->\n                       let tv_a = ref TYSPEC_ordered in\n-                        unify_atom lhs tv_a;\n-                        unify_atom rhs tv_a;\n-                        unify_ty Ast.TY_bool tv\n+                        unify_atom true lhs tv_a;\n+                        unify_atom true rhs tv_a;\n+                        unify_ty true Ast.TY_bool tv\n                   | BINOPSIG_integ_integ_integ ->\n                       let tv_a = ref TYSPEC_integral in\n-                        unify_atom lhs tv_a;\n-                        unify_atom rhs tv_a;\n-                        unify_tyvars tv tv_a\n+                        unify_atom true lhs tv_a;\n+                        unify_atom true rhs tv_a;\n+                        unify_tyvars true tv tv_a\n                   | BINOPSIG_num_num_num ->\n                       let tv_a = ref TYSPEC_numeric in\n-                        unify_atom lhs tv_a;\n-                        unify_atom rhs tv_a;\n-                        unify_tyvars tv tv_a\n+                        unify_atom true lhs tv_a;\n+                        unify_atom true rhs tv_a;\n+                        unify_tyvars true tv tv_a\n                   | BINOPSIG_plus_plus_plus ->\n                       let tv_a = ref TYSPEC_plusable in\n-                        unify_atom lhs tv_a;\n-                        unify_atom rhs tv_a;\n-                        unify_tyvars tv tv_a\n+                        unify_atom true lhs tv_a;\n+                        unify_atom true rhs tv_a;\n+                        unify_tyvars true tv tv_a\n               end\n         | Ast.EXPR_unary (unop, atom) ->\n             begin\n               match unop with\n                   Ast.UNOP_not ->\n-                    unify_atom atom\n+                    unify_atom true atom\n                       (ref (TYSPEC_resolved ([||], Ast.TY_bool)));\n-                    unify_ty Ast.TY_bool tv\n+                    unify_ty true Ast.TY_bool tv\n                 | Ast.UNOP_bitnot ->\n                     let tv_a = ref TYSPEC_integral in\n-                      unify_atom atom tv_a;\n-                      unify_tyvars tv tv_a\n+                      unify_atom true atom tv_a;\n+                      unify_tyvars true tv tv_a\n                 | Ast.UNOP_neg ->\n                     let tv_a = ref TYSPEC_numeric in\n-                      unify_atom atom tv_a;\n-                      unify_tyvars tv tv_a\n+                      unify_atom true atom tv_a;\n+                      unify_tyvars true tv tv_a\n                 | Ast.UNOP_cast t ->\n                     (* FIXME (issue #84): check cast-validity in\n                      * post-typecheck pass.  Only some casts make sense.\n                      *)\n                     let tv_a = ref TYSPEC_all in\n                     let t = Hashtbl.find cx.ctxt_all_cast_types t.id in\n-                      unify_atom atom tv_a;\n-                      unify_ty t tv\n+                      unify_atom true atom tv_a;\n+                      unify_ty true t tv\n             end\n-        | Ast.EXPR_atom atom -> unify_atom atom tv\n+        | Ast.EXPR_atom atom -> unify_atom true atom tv\n \n-    and unify_lval' (lval:Ast.lval) (tv:tyvar) : unit =\n+    and unify_lval' (simplify:bool) (lval:Ast.lval) (tv:tyvar) : unit =\n       let note_args args =\n         iflog cx (fun _ -> log cx \"noting lval '%a' type arguments: %a\"\n                     Ast.sprintf_lval lval Ast.sprintf_app_args args);\n@@ -907,7 +922,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                                 log cx \"lval-base slot tyspec for %a = %s\"\n                                   Ast.sprintf_lval lval (tyspec_to_str (!tv));\n                           end;\n-                        unify_slot slot (Some referent) tv\n+                        unify_slot simplify slot (Some referent) tv\n \n                     | _ ->\n                         let spec = (!(Hashtbl.find bindings referent)) in\n@@ -929,7 +944,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                                 ref (TYSPEC_app (tv, args))\n                             | _ -> err None \"bad lval / tyspec combination\"\n                         in\n-                          unify_tyvars (ref spec) tv\n+                          unify_tyvars simplify (ref spec) tv\n                 end\n           | Ast.LVAL_ext (base, comp) ->\n               let base_ts = match comp with\n@@ -950,33 +965,33 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                       TYSPEC_tuple (Array.init (i + 1) init)\n \n                 | Ast.COMP_atom atom ->\n-                    unify_atom atom\n+                    unify_atom simplify atom\n                       (ref (TYSPEC_resolved ([||], Ast.TY_int)));\n                     TYSPEC_collection tv\n               in\n               let base_tv = ref base_ts in\n-                unify_lval' base base_tv;\n+                unify_lval' simplify base base_tv;\n                 match !(resolve_tyvar base_tv) with\n                     TYSPEC_resolved (_, ty) ->\n-                      unify_ty (project_type ty comp) tv\n+                      unify_ty simplify (project_type ty comp) tv\n                   | _ ->\n                       ()\n \n-    and unify_lval (lval:Ast.lval) (tv:tyvar) : unit =\n+    and unify_lval (simplify:bool) (lval:Ast.lval) (tv:tyvar) : unit =\n       let id = lval_base_id lval in\n         (* Fetch lval with type components resolved. *)\n         let lval = Hashtbl.find cx.ctxt_all_lvals id in\n         iflog cx (fun _ -> log cx\n                     \"fetched resolved version of lval #%d = %a\"\n                     (int_of_node id) Ast.sprintf_lval lval);\n           Hashtbl.add lval_tyvars id tv;\n-          unify_lval' lval tv\n+          unify_lval' simplify lval tv\n \n     in\n     let gen_atom_tvs atoms =\n       let gen_atom_tv atom =\n         let tv = ref TYSPEC_all in\n-          unify_atom atom tv;\n+          unify_atom true atom tv;\n           tv\n       in\n         Array.map gen_atom_tv atoms\n@@ -986,72 +1001,72 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n       let check_callable out_tv callee args =\n         let in_tvs = gen_atom_tvs args in\n         let callee_tv = ref (TYSPEC_callable (out_tv, in_tvs)) in\n-          unify_lval callee callee_tv;\n+          unify_lval true callee callee_tv;\n       in\n       match stmt.node with\n           Ast.STMT_spawn (out, _, callee, args) ->\n             let out_tv = ref (TYSPEC_resolved ([||], Ast.TY_nil)) in\n-              unify_lval out (ref (TYSPEC_resolved ([||], Ast.TY_task)));\n+              unify_lval true out (ref (TYSPEC_resolved ([||], Ast.TY_task)));\n               check_callable out_tv callee args\n \n         | Ast.STMT_init_rec (lval, fields, Some base) ->\n             let dct = Hashtbl.create 10 in\n             let tvrec = ref (TYSPEC_record dct) in\n             let add_field (ident, atom) =\n               let tv = ref TYSPEC_all in\n-                unify_atom atom tv;\n+                unify_atom true atom tv;\n                 Hashtbl.add dct ident tv\n             in\n               Array.iter add_field fields;\n               let tvbase = ref TYSPEC_all in\n-                unify_lval base tvbase;\n-                unify_tyvars tvrec tvbase;\n-                unify_lval lval tvrec\n+                unify_lval true base tvbase;\n+                unify_tyvars true tvrec tvbase;\n+                unify_lval true lval tvrec\n \n         | Ast.STMT_init_rec (lval, fields, None) ->\n             let dct = Hashtbl.create 10 in\n             let add_field (ident, atom) =\n               let tv = ref TYSPEC_all in\n-                unify_atom atom tv;\n+                unify_atom true atom tv;\n                 Hashtbl.add dct ident tv\n             in\n               Array.iter add_field fields;\n-              unify_lval lval (ref (TYSPEC_record dct))\n+              unify_lval true lval (ref (TYSPEC_record dct))\n \n         | Ast.STMT_init_tup (lval, members) ->\n             let member_to_tv atom =\n               let tv = ref TYSPEC_all in\n-                unify_atom atom tv;\n+                unify_atom true atom tv;\n                 tv\n             in\n             let member_tvs = Array.map member_to_tv members in\n-              unify_lval lval (ref (TYSPEC_tuple member_tvs))\n+              unify_lval true lval (ref (TYSPEC_tuple member_tvs))\n \n         | Ast.STMT_init_vec (lval, atoms) ->\n             let tv = ref TYSPEC_all in\n-            let unify_with_tv atom = unify_atom atom tv in\n+            let unify_with_tv atom = unify_atom true atom tv in\n               Array.iter unify_with_tv atoms;\n-              unify_lval lval (ref (TYSPEC_vector tv))\n+              unify_lval true lval (ref (TYSPEC_vector tv))\n \n         | Ast.STMT_init_str (lval, _) ->\n-            unify_lval lval (ref (TYSPEC_resolved ([||], Ast.TY_str)))\n+            unify_lval true lval (ref (TYSPEC_resolved ([||], Ast.TY_str)))\n \n         | Ast.STMT_copy (lval, expr) ->\n             let tv = ref TYSPEC_all in\n               unify_expr expr tv;\n-              unify_lval lval tv\n+              unify_lval true lval tv\n \n         | Ast.STMT_copy_binop (lval, binop, at) ->\n             let tv = ref TYSPEC_all in\n               unify_expr (Ast.EXPR_binary (binop, Ast.ATOM_lval lval, at)) tv;\n-              unify_lval lval tv;\n+              unify_lval true lval tv;\n \n         | Ast.STMT_call (out, callee, args) ->\n             let out_tv = ref TYSPEC_all in\n-              unify_lval out out_tv;\n+              unify_lval true out out_tv;\n               check_callable out_tv callee args\n \n-        | Ast.STMT_log atom -> unify_atom atom (ref TYSPEC_loggable)\n+        | Ast.STMT_log atom -> unify_atom true atom (ref TYSPEC_loggable)\n \n         | Ast.STMT_check_expr expr ->\n             unify_expr expr (ref (TYSPEC_resolved ([||], Ast.TY_bool)))\n@@ -1075,8 +1090,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         | Ast.STMT_put atom_opt ->\n             begin\n               match atom_opt with\n-                  None -> unify_ty Ast.TY_nil (retval_tv())\n-                | Some atom -> unify_atom atom (retval_tv())\n+                  None -> unify_ty true Ast.TY_nil (retval_tv())\n+                | Some atom -> unify_atom true atom (retval_tv())\n             end\n \n         | Ast.STMT_be (callee, args) ->\n@@ -1094,7 +1109,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                   begin\n                     match atom_opt with\n                         None -> residue := tv :: (!residue);\n-                      | Some atom -> unify_atom atom tv\n+                      | Some atom -> unify_atom true atom tv\n                   end;\n                   tv\n               in\n@@ -1105,28 +1120,28 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n             let arg_residue_tvs = Array.of_list (List.rev (!residue)) in\n             let callee_tv = ref (TYSPEC_callable (out_tv, in_tvs)) in\n             let bound_tv = ref (TYSPEC_callable (out_tv, arg_residue_tvs)) in\n-              unify_lval callee callee_tv;\n-              unify_lval bound bound_tv\n+              unify_lval true callee callee_tv;\n+              unify_lval true bound bound_tv\n \n         | Ast.STMT_for_each fe ->\n             let out_tv = ref TYSPEC_all in\n             let (si, _) = fe.Ast.for_each_slot in\n             let (callee, args) = fe.Ast.for_each_call in\n-              unify_slot si.node (Some si.id) out_tv;\n+              unify_slot true si.node (Some si.id) out_tv;\n               check_callable out_tv callee args\n \n         | Ast.STMT_for fo ->\n             let mem_tv = ref TYSPEC_all in\n             let seq_tv = ref (TYSPEC_collection mem_tv) in\n             let (si, _) = fo.Ast.for_slot in\n             let (_, seq) = fo.Ast.for_seq in\n-              unify_lval seq seq_tv;\n-              unify_slot si.node (Some si.id) mem_tv\n+              unify_lval true seq seq_tv;\n+              unify_slot true si.node (Some si.id) mem_tv\n \n         | Ast.STMT_alt_tag\n             { Ast.alt_tag_lval = lval; Ast.alt_tag_arms = arms } ->\n             let lval_tv = ref TYSPEC_all in\n-              unify_lval lval lval_tv;\n+              unify_lval true lval lval_tv;\n               Array.iter (fun _ -> push_pat_tv lval_tv) arms\n \n         (* FIXME (issue #52): plenty more to handle here. *)\n@@ -1153,7 +1168,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n     let enter_fn fn retspec =\n       let out = fn.Ast.fn_output_slot in\n         push_retval_tv (ref retspec);\n-        unify_slot out.node (Some out.id) (retval_tv())\n+        unify_slot true out.node (Some out.id) (retval_tv())\n     in\n \n     let visit_obj_fn_pre obj ident fn =\n@@ -1220,12 +1235,12 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n     let visit_pat_pre (pat:Ast.pat) : unit =\n       let expected = pat_tv() in\n         match pat with\n-            Ast.PAT_lit lit -> unify_lit lit expected\n+            Ast.PAT_lit lit -> unify_lit true lit expected\n \n           | Ast.PAT_tag (lval, _) ->\n               let expect ty =\n                 let tv = ref TYSPEC_all in\n-                  unify_ty ty tv;\n+                  unify_ty true ty tv;\n                   push_pat_tv tv;\n               in\n \n@@ -1237,7 +1252,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                * exactly to that function type, rebuilt under any latent type\n                * parameters applied in the lval. *)\n               let lval_tv = ref TYSPEC_all in\n-                unify_lval lval lval_tv;\n+                unify_lval true lval lval_tv;\n                 let tag_ctor_ty =\n                   match !(resolve_tyvar lval_tv) with\n                       TYSPEC_resolved (_, ty) -> ty\n@@ -1249,13 +1264,13 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                 let tag_ty_tup = tag_or_iso_ty_tup_by_name tag_ty lval_nm in\n \n                 let tag_tv = ref TYSPEC_all in\n-                  unify_ty tag_ty tag_tv;\n-                  unify_tyvars expected tag_tv;\n+                  unify_ty true tag_ty tag_tv;\n+                  unify_tyvars true expected tag_tv;\n                   List.iter expect\n                     (List.rev (Array.to_list tag_ty_tup));\n \n           | Ast.PAT_slot (sloti, _) ->\n-              unify_slot sloti.node (Some sloti.id) expected\n+              unify_slot true sloti.node (Some sloti.id) expected\n \n           | Ast.PAT_wild -> ()\n     in"}]}