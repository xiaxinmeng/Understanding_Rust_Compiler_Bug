{"sha": "51555186b680ffc63b1daf362456f7f8ca537763", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNTU1MTg2YjY4MGZmYzYzYjFkYWYzNjI0NTZmN2Y4Y2E1Mzc3NjM=", "commit": {"author": {"name": "Donough Liu", "email": "ldm2993593805@163.com", "date": "2020-06-20T10:29:13Z"}, "committer": {"name": "Donough Liu", "email": "ldm2993593805@163.com", "date": "2020-06-20T10:29:13Z"}, "message": "Decouple `Autoderef` with `FnCtxt` and move `Autoderef` to `librustc_trait_selection`.", "tree": {"sha": "a4886661cd7c6f3453cf28ae8a5b6fff861d57be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4886661cd7c6f3453cf28ae8a5b6fff861d57be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51555186b680ffc63b1daf362456f7f8ca537763", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51555186b680ffc63b1daf362456f7f8ca537763", "html_url": "https://github.com/rust-lang/rust/commit/51555186b680ffc63b1daf362456f7f8ca537763", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51555186b680ffc63b1daf362456f7f8ca537763/comments", "author": {"login": "ldm0", "id": 31354274, "node_id": "MDQ6VXNlcjMxMzU0Mjc0", "avatar_url": "https://avatars.githubusercontent.com/u/31354274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ldm0", "html_url": "https://github.com/ldm0", "followers_url": "https://api.github.com/users/ldm0/followers", "following_url": "https://api.github.com/users/ldm0/following{/other_user}", "gists_url": "https://api.github.com/users/ldm0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ldm0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ldm0/subscriptions", "organizations_url": "https://api.github.com/users/ldm0/orgs", "repos_url": "https://api.github.com/users/ldm0/repos", "events_url": "https://api.github.com/users/ldm0/events{/privacy}", "received_events_url": "https://api.github.com/users/ldm0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ldm0", "id": 31354274, "node_id": "MDQ6VXNlcjMxMzU0Mjc0", "avatar_url": "https://avatars.githubusercontent.com/u/31354274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ldm0", "html_url": "https://github.com/ldm0", "followers_url": "https://api.github.com/users/ldm0/followers", "following_url": "https://api.github.com/users/ldm0/following{/other_user}", "gists_url": "https://api.github.com/users/ldm0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ldm0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ldm0/subscriptions", "organizations_url": "https://api.github.com/users/ldm0/orgs", "repos_url": "https://api.github.com/users/ldm0/repos", "events_url": "https://api.github.com/users/ldm0/events{/privacy}", "received_events_url": "https://api.github.com/users/ldm0/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34c5cd9a64d8537236626c4ccbed39a924cd38e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/34c5cd9a64d8537236626c4ccbed39a924cd38e2", "html_url": "https://github.com/rust-lang/rust/commit/34c5cd9a64d8537236626c4ccbed39a924cd38e2"}], "stats": {"total": 523, "additions": 274, "deletions": 249}, "files": [{"sha": "d542e16d83f10e58a32d39ce5b194624dfb36645", "filename": "src/librustc_trait_selection/autoderef.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_trait_selection%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_trait_selection%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fautoderef.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -0,0 +1,229 @@\n+use crate::traits::query::evaluate_obligation::InferCtxtExt;\n+use crate::traits::{self, TraitEngine};\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_infer::infer::InferCtxt;\n+use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n+use rustc_middle::ty::{ToPredicate, TypeFoldable};\n+use rustc_session::DiagnosticMessageId;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum AutoderefKind {\n+    Builtin,\n+    Overloaded,\n+}\n+\n+struct AutoderefSnapshot<'tcx> {\n+    at_start: bool,\n+    reached_recursion_limit: bool,\n+    steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n+    cur_ty: Ty<'tcx>,\n+    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+}\n+\n+pub struct Autoderef<'a, 'tcx> {\n+    // Meta infos:\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    span: Span,\n+    body_id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+\n+    // Current state:\n+    state: AutoderefSnapshot<'tcx>,\n+\n+    // Configurations:\n+    include_raw_pointers: bool,\n+    silence_errors: bool,\n+}\n+\n+impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n+    type Item = (Ty<'tcx>, usize);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let tcx = self.infcx.tcx;\n+\n+        debug!(\"autoderef: steps={:?}, cur_ty={:?}\", self.state.steps, self.state.cur_ty);\n+        if self.state.at_start {\n+            self.state.at_start = false;\n+            debug!(\"autoderef stage #0 is {:?}\", self.state.cur_ty);\n+            return Some((self.state.cur_ty, 0));\n+        }\n+\n+        // If we have reached the recursion limit, error gracefully.\n+        if !tcx.sess.recursion_limit().value_within_limit(self.state.steps.len()) {\n+            if !self.silence_errors {\n+                report_autoderef_recursion_limit_error(tcx, self.span, self.state.cur_ty);\n+            }\n+            self.state.reached_recursion_limit = true;\n+            return None;\n+        }\n+\n+        if self.state.cur_ty.is_ty_var() {\n+            return None;\n+        }\n+\n+        // Otherwise, deref if type is derefable:\n+        let (kind, new_ty) =\n+            if let Some(mt) = self.state.cur_ty.builtin_deref(self.include_raw_pointers) {\n+                (AutoderefKind::Builtin, mt.ty)\n+            } else if let Some(ty) = self.overloaded_deref_ty(self.state.cur_ty) {\n+                (AutoderefKind::Overloaded, ty)\n+            } else {\n+                return None;\n+            };\n+\n+        if new_ty.references_error() {\n+            return None;\n+        }\n+\n+        self.state.steps.push((self.state.cur_ty, kind));\n+        debug!(\n+            \"autoderef stage #{:?} is {:?} from {:?}\",\n+            self.step_count(),\n+            new_ty,\n+            (self.state.cur_ty, kind)\n+        );\n+        self.state.cur_ty = new_ty;\n+\n+        Some((self.state.cur_ty, self.step_count()))\n+    }\n+}\n+\n+impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n+    pub fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+    ) -> Autoderef<'a, 'tcx> {\n+        Autoderef {\n+            infcx,\n+            span,\n+            body_id,\n+            param_env,\n+            state: AutoderefSnapshot {\n+                steps: vec![],\n+                cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n+                obligations: vec![],\n+                at_start: true,\n+                reached_recursion_limit: false,\n+            },\n+            include_raw_pointers: false,\n+            silence_errors: false,\n+        }\n+    }\n+\n+    fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        debug!(\"overloaded_deref_ty({:?})\", ty);\n+\n+        let tcx = self.infcx.tcx;\n+\n+        // <ty as Deref>\n+        let trait_ref = TraitRef {\n+            def_id: tcx.lang_items().deref_trait()?,\n+            substs: tcx.mk_substs_trait(ty, &[]),\n+        };\n+\n+        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+\n+        let obligation = traits::Obligation::new(\n+            cause.clone(),\n+            self.param_env,\n+            trait_ref.without_const().to_predicate(tcx),\n+        );\n+        if !self.infcx.predicate_may_hold(&obligation) {\n+            debug!(\"overloaded_deref_ty: cannot match obligation\");\n+            return None;\n+        }\n+\n+        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n+        let normalized_ty = fulfillcx.normalize_projection_type(\n+            &self.infcx,\n+            self.param_env,\n+            ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, Ident::from_str(\"Target\")),\n+            cause,\n+        );\n+        if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {\n+            // This shouldn't happen, except for evaluate/fulfill mismatches,\n+            // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n+            // by design).\n+            debug!(\"overloaded_deref_ty: encountered errors {:?} while fulfilling\", e);\n+            return None;\n+        }\n+        let obligations = fulfillcx.pending_obligations();\n+        debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\", ty, normalized_ty, obligations);\n+        self.state.obligations.extend(obligations);\n+\n+        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n+    }\n+\n+    /// Returns the final type we ended up with, which may be an inference\n+    /// variable (we will resolve it first, if we want).\n+    pub fn final_ty(&self, resolve: bool) -> Ty<'tcx> {\n+        if resolve {\n+            self.infcx.resolve_vars_if_possible(&self.state.cur_ty)\n+        } else {\n+            self.state.cur_ty\n+        }\n+    }\n+\n+    pub fn step_count(&self) -> usize {\n+        self.state.steps.len()\n+    }\n+\n+    pub fn into_obligations(self) -> Vec<traits::PredicateObligation<'tcx>> {\n+        self.state.obligations\n+    }\n+\n+    pub fn steps(&self) -> &[(Ty<'tcx>, AutoderefKind)] {\n+        &self.state.steps\n+    }\n+\n+    pub fn span(&self) -> Span {\n+        self.span.clone()\n+    }\n+\n+    pub fn reached_recursion_limit(&self) -> bool {\n+        self.state.reached_recursion_limit\n+    }\n+\n+    /// also dereference through raw pointer types\n+    /// e.g., assuming ptr_to_Foo is the type `*const Foo`\n+    /// fcx.autoderef(span, ptr_to_Foo)  => [*const Foo]\n+    /// fcx.autoderef(span, ptr_to_Foo).include_raw_ptrs() => [*const Foo, Foo]\n+    pub fn include_raw_pointers(mut self) -> Self {\n+        self.include_raw_pointers = true;\n+        self\n+    }\n+\n+    pub fn silence_errors(mut self) -> Self {\n+        self.silence_errors = true;\n+        self\n+    }\n+}\n+\n+pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n+    // We've reached the recursion limit, error gracefully.\n+    let suggested_limit = tcx.sess.recursion_limit() * 2;\n+    let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\", ty);\n+    let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n+    let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+    if fresh {\n+        struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0055,\n+            \"reached the recursion limit while auto-dereferencing `{:?}`\",\n+            ty\n+        )\n+        .span_label(span, \"deref recursion limit reached\")\n+        .help(&format!(\n+            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n+            suggested_limit, tcx.crate_name,\n+        ))\n+        .emit();\n+    }\n+}"}, {"sha": "4692fa04ed58718466a0e8d7cf8cc94eb36edacb", "filename": "src/librustc_trait_selection/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -28,6 +28,7 @@ extern crate log;\n #[macro_use]\n extern crate rustc_middle;\n \n+pub mod autoderef;\n pub mod infer;\n pub mod opaque_types;\n pub mod traits;"}, {"sha": "97d2b3e5a8e45c8b1e121bb5b5654e36c9685a89", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 19, "deletions": 227, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -1,191 +1,46 @@\n+//! Some helper functions for `AutoDeref`\n use super::method::MethodCallee;\n use super::{FnCtxt, PlaceOp};\n \n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::InferOk;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n-use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n-use rustc_middle::ty::{ToPredicate, TypeFoldable};\n-use rustc_session::DiagnosticMessageId;\n-use rustc_span::symbol::Ident;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, TraitEngine};\n+use rustc_trait_selection::autoderef::{Autoderef, AutoderefKind};\n \n use std::iter;\n \n-#[derive(Copy, Clone, Debug)]\n-enum AutoderefKind {\n-    Builtin,\n-    Overloaded,\n-}\n-\n-pub struct Autoderef<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    body_id: hir::HirId,\n-    param_env: ty::ParamEnv<'tcx>,\n-    steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n-    cur_ty: Ty<'tcx>,\n-    obligations: Vec<traits::PredicateObligation<'tcx>>,\n-    at_start: bool,\n-    include_raw_pointers: bool,\n-    span: Span,\n-    silence_errors: bool,\n-    reached_recursion_limit: bool,\n-}\n-\n-impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n-    type Item = (Ty<'tcx>, usize);\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let tcx = self.infcx.tcx;\n-\n-        debug!(\"autoderef: steps={:?}, cur_ty={:?}\", self.steps, self.cur_ty);\n-        if self.at_start {\n-            self.at_start = false;\n-            debug!(\"autoderef stage #0 is {:?}\", self.cur_ty);\n-            return Some((self.cur_ty, 0));\n-        }\n-\n-        if !tcx.sess.recursion_limit().value_within_limit(self.steps.len()) {\n-            if !self.silence_errors {\n-                report_autoderef_recursion_limit_error(tcx, self.span, self.cur_ty);\n-            }\n-            self.reached_recursion_limit = true;\n-            return None;\n-        }\n-\n-        if self.cur_ty.is_ty_var() {\n-            return None;\n-        }\n-\n-        // Otherwise, deref if type is derefable:\n-        let (kind, new_ty) = if let Some(mt) = self.cur_ty.builtin_deref(self.include_raw_pointers)\n-        {\n-            (AutoderefKind::Builtin, mt.ty)\n-        } else {\n-            let ty = self.overloaded_deref_ty(self.cur_ty)?;\n-            (AutoderefKind::Overloaded, ty)\n-        };\n-\n-        if new_ty.references_error() {\n-            return None;\n-        }\n-\n-        self.steps.push((self.cur_ty, kind));\n-        debug!(\n-            \"autoderef stage #{:?} is {:?} from {:?}\",\n-            self.steps.len(),\n-            new_ty,\n-            (self.cur_ty, kind)\n-        );\n-        self.cur_ty = new_ty;\n-\n-        Some((self.cur_ty, self.steps.len()))\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n     }\n-}\n \n-impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n-    pub fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+    pub fn try_overloaded_deref(\n+        &self,\n         span: Span,\n         base_ty: Ty<'tcx>,\n-    ) -> Autoderef<'a, 'tcx> {\n-        Autoderef {\n-            infcx,\n-            body_id,\n-            param_env,\n-            steps: vec![],\n-            cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n-            obligations: vec![],\n-            at_start: true,\n-            include_raw_pointers: false,\n-            silence_errors: false,\n-            reached_recursion_limit: false,\n-            span,\n-        }\n-    }\n-\n-    fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-        debug!(\"overloaded_deref_ty({:?})\", ty);\n-\n-        let tcx = self.infcx.tcx;\n-\n-        // <ty as Deref>\n-        let trait_ref = TraitRef {\n-            def_id: tcx.lang_items().deref_trait()?,\n-            substs: tcx.mk_substs_trait(ty, &[]),\n-        };\n-\n-        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-\n-        let obligation = traits::Obligation::new(\n-            cause.clone(),\n-            self.param_env,\n-            trait_ref.without_const().to_predicate(tcx),\n-        );\n-        if !self.infcx.predicate_may_hold(&obligation) {\n-            debug!(\"overloaded_deref_ty: cannot match obligation\");\n-            return None;\n-        }\n-\n-        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n-        let normalized_ty = fulfillcx.normalize_projection_type(\n-            &self.infcx,\n-            self.param_env,\n-            ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, Ident::from_str(\"Target\")),\n-            cause,\n-        );\n-        if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {\n-            // This shouldn't happen, except for evaluate/fulfill mismatches,\n-            // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n-            // by design).\n-            debug!(\"overloaded_deref_ty: encountered errors {:?} while fulfilling\", e);\n-            return None;\n-        }\n-        let obligations = fulfillcx.pending_obligations();\n-        debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\", ty, normalized_ty, obligations);\n-        self.obligations.extend(obligations);\n-\n-        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n-    }\n-\n-    /// Returns the final type, generating an error if it is an\n-    /// unresolved inference variable.\n-    pub fn unambiguous_final_ty(&self, fcx: &FnCtxt<'a, 'tcx>) -> Ty<'tcx> {\n-        fcx.structurally_resolved_type(self.span, self.cur_ty)\n-    }\n-\n-    /// Returns the final type we ended up with, which may well be an\n-    /// inference variable (we will resolve it first, if possible).\n-    pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.infcx.resolve_vars_if_possible(&self.cur_ty)\n-    }\n-\n-    pub fn step_count(&self) -> usize {\n-        self.steps.len()\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n-        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx))\n+    pub fn adjust_steps(&self, autoderef: &Autoderef<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n+        self.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(autoderef))\n     }\n \n     pub fn adjust_steps_as_infer_ok(\n         &self,\n-        fcx: &FnCtxt<'a, 'tcx>,\n+        autoderef: &Autoderef<'a, 'tcx>,\n     ) -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n-        let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(self.cur_ty));\n-        let steps: Vec<_> = self\n-            .steps\n+        let steps = autoderef.steps();\n+        let targets =\n+            steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(autoderef.final_ty(false)));\n+        let steps: Vec<_> = steps\n             .iter()\n             .map(|&(source, kind)| {\n                 if let AutoderefKind::Overloaded = kind {\n-                    fcx.try_overloaded_deref(self.span, source).and_then(\n+                    self.try_overloaded_deref(autoderef.span(), source).and_then(\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n@@ -205,67 +60,4 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n \n         InferOk { obligations, value: steps }\n     }\n-\n-    /// also dereference through raw pointer types\n-    /// e.g., assuming ptr_to_Foo is the type `*const Foo`\n-    /// fcx.autoderef(span, ptr_to_Foo)  => [*const Foo]\n-    /// fcx.autoderef(span, ptr_to_Foo).include_raw_ptrs() => [*const Foo, Foo]\n-    pub fn include_raw_pointers(mut self) -> Self {\n-        self.include_raw_pointers = true;\n-        self\n-    }\n-\n-    pub fn silence_errors(mut self) -> Self {\n-        self.silence_errors = true;\n-        self\n-    }\n-\n-    pub fn reached_recursion_limit(&self) -> bool {\n-        self.reached_recursion_limit\n-    }\n-\n-    pub fn finalize(self, fcx: &FnCtxt<'a, 'tcx>) {\n-        fcx.register_predicates(self.into_obligations());\n-    }\n-\n-    pub fn into_obligations(self) -> Vec<traits::PredicateObligation<'tcx>> {\n-        self.obligations\n-    }\n-}\n-\n-pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n-    // We've reached the recursion limit, error gracefully.\n-    let suggested_limit = tcx.sess.recursion_limit() * 2;\n-    let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\", ty);\n-    let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n-    let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-    if fresh {\n-        struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0055,\n-            \"reached the recursion limit while auto-dereferencing `{:?}`\",\n-            ty\n-        )\n-        .span_label(span, \"deref recursion limit reached\")\n-        .help(&format!(\n-            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n-            suggested_limit, tcx.crate_name,\n-        ))\n-        .emit();\n-    }\n-}\n-\n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n-        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n-    }\n-\n-    pub fn try_overloaded_deref(\n-        &self,\n-        span: Span,\n-        base_ty: Ty<'tcx>,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n-    }\n }"}, {"sha": "308ed5d8402021864d830170422fc7f86a151430", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -1,4 +1,3 @@\n-use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n@@ -17,6 +16,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n+use rustc_trait_selection::autoderef::Autoderef;\n \n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n@@ -72,7 +72,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_overloaded_call_step(call_expr, callee_expr, arg_exprs, &autoderef);\n         }\n-        autoderef.finalize(self);\n+        self.register_predicates(autoderef.into_obligations());\n \n         let output = match result {\n             None => {\n@@ -106,7 +106,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n         autoderef: &Autoderef<'a, 'tcx>,\n     ) -> Option<CallStep<'tcx>> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        let adjusted_ty =\n+            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n         debug!(\n             \"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n             call_expr, adjusted_ty\n@@ -115,7 +116,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(self);\n+                let adjustments = self.adjust_steps(autoderef);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -135,7 +136,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             &closure_sig,\n                         )\n                         .0;\n-                    let adjustments = autoderef.adjust_steps(self);\n+                    let adjustments = self.adjust_steps(autoderef);\n                     self.record_deferred_call_resolution(\n                         def_id,\n                         DeferredCallResolution {\n@@ -176,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.try_overloaded_call_traits(call_expr, adjusted_ty, Some(arg_exprs))\n             .or_else(|| self.try_overloaded_call_traits(call_expr, adjusted_ty, None))\n             .map(|(autoref, method)| {\n-                let mut adjustments = autoderef.adjust_steps(self);\n+                let mut adjustments = self.adjust_steps(autoderef);\n                 adjustments.extend(autoref);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 CallStep::Overloaded(method)"}, {"sha": "7a2567d8dd2292f5562e5b87da62329476e8836e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -422,7 +422,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n \n         let InferOk { value: mut adjustments, obligations: o } =\n-            autoderef.adjust_steps_as_infer_ok(self);\n+            self.adjust_steps_as_infer_ok(&autoderef);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "1eaa5a6c31e20070466b1d4941f1fe1b4bd815b2", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -1447,9 +1447,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // of error recovery.\n                         self.write_field_index(expr.hir_id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(self);\n+                            let adjustments = self.adjust_steps(&autoderef);\n                             self.apply_adjustments(base, adjustments);\n-                            autoderef.finalize(self);\n+                            self.register_predicates(autoderef.into_obligations());\n \n                             self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span);\n                             return field_ty;\n@@ -1462,9 +1462,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(self);\n+                                let adjustments = self.adjust_steps(&autoderef);\n                                 self.apply_adjustments(base, adjustments);\n-                                autoderef.finalize(self);\n+                                self.register_predicates(autoderef.into_obligations());\n \n                                 self.write_field_index(expr.hir_id, index);\n                                 return field_ty.expect_ty();\n@@ -1475,7 +1475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => {}\n             }\n         }\n-        autoderef.unambiguous_final_ty(self);\n+        self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n \n         if let Some((did, field_ty)) = private_candidate {\n             self.ban_private_field_access(expr, expr_t, field, did);"}, {"sha": "1c3d23a3a241f4bf751ad6490235491317ad26d2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -144,9 +144,10 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(self);\n+        let mut adjustments = self.adjust_steps(&autoderef);\n \n-        let mut target = autoderef.unambiguous_final_ty(self);\n+        let mut target =\n+            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n \n         if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n@@ -176,7 +177,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             assert!(pick.unsize.is_none());\n         }\n \n-        autoderef.finalize(self);\n+        self.register_predicates(autoderef.into_obligations());\n \n         // Write out the final adjustments.\n         self.apply_adjustments(self.self_expr, adjustments);"}, {"sha": "8c4ef24b9455ce8d388ffb5d0bd11b7ff3bc5d08", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -3,7 +3,6 @@ use super::MethodError;\n use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n \n-use crate::check::autoderef::{self, Autoderef};\n use crate::check::FnCtxt;\n use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n@@ -30,6 +29,7 @@ use rustc_session::config::nightly_options;\n use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n+use rustc_trait_selection::autoderef::{self, Autoderef};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n use rustc_trait_selection::traits::query::method_autoderef::{\n@@ -477,7 +477,7 @@ fn method_autoderef_steps<'tcx>(\n             })\n             .collect();\n \n-        let final_ty = autoderef.maybe_ambiguous_final_ty();\n+        let final_ty = autoderef.final_ty(true);\n         let opt_bad_ty = match final_ty.kind {\n             ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n                 reached_raw_pointer,"}, {"sha": "b7c8f310a1414763acb04b1b1b63becfe65704db", "filename": "src/librustc_typeck/check/place_op.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -1,4 +1,3 @@\n-use crate::check::autoderef::Autoderef;\n use crate::check::method::MethodCallee;\n use crate::check::{FnCtxt, PlaceOp};\n use rustc_hir as hir;\n@@ -9,6 +8,7 @@ use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutabili\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n+use rustc_trait_selection::autoderef::Autoderef;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Type-check `*oprnd_expr` with `oprnd_expr` type-checked already.\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_index_step(expr, base_expr, &autoderef, idx_ty);\n         }\n-        autoderef.finalize(self);\n+        self.register_predicates(autoderef.into_obligations());\n         result\n     }\n \n@@ -73,7 +73,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         autoderef: &Autoderef<'a, 'tcx>,\n         index_ty: Ty<'tcx>,\n     ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        let adjusted_ty =\n+            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n         debug!(\n             \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n              index_ty={:?})\",\n@@ -105,7 +106,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 debug!(\"try_index_step: success, using overloaded indexing\");\n                 let method = self.register_infer_ok_obligations(ok);\n \n-                let mut adjustments = autoderef.adjust_steps(self);\n+                let mut adjustments = self.adjust_steps(autoderef);\n                 if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n                     adjustments.push(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),"}, {"sha": "d1a86a7ee89a8af5f7d3e8a6b3d54cf761bdcae6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51555186b680ffc63b1daf362456f7f8ca537763/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=51555186b680ffc63b1daf362456f7f8ca537763", "patch": "@@ -1118,7 +1118,7 @@ fn receiver_is_valid<'fcx, 'tcx>(\n             );\n \n             if can_eq_self(potential_self_ty) {\n-                autoderef.finalize(fcx);\n+                fcx.register_predicates(autoderef.into_obligations());\n \n                 if let Some(mut err) =\n                     fcx.demand_eqtype_with_origin(&cause, self_ty, potential_self_ty)"}]}