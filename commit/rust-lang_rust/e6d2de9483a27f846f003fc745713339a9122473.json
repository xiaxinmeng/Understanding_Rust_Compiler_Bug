{"sha": "e6d2de9483a27f846f003fc745713339a9122473", "node_id": "C_kwDOAAsO6NoAKGU2ZDJkZTk0ODNhMjdmODQ2ZjAwM2ZjNzQ1NzEzMzM5YTkxMjI0NzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-28T13:04:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-28T13:04:27Z"}, "message": "Auto merge of #91230 - eggyal:fallible-type-fold, r=jackh726\n\nMake `TypeFolder::fold_*` return `Result`\n\nImplements rust-lang/compiler-team#432.\n\nInitially this is just a rebase of `@LeSeulArtichaut's` work in #85469 (abandoned; see https://github.com/rust-lang/rust/pull/85485#issuecomment-908781112).  At that time, it caused a regression in performance that required some further exploration... with this rebased PR bors can hopefully report some perf analysis from which we can investigate further (if the regression is indeed still present).\n\nr? `@jackh726` cc `@nikomatsakis`", "tree": {"sha": "df23ef323804678a61bfa79e4e56483f9ad63204", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df23ef323804678a61bfa79e4e56483f9ad63204"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6d2de9483a27f846f003fc745713339a9122473", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d2de9483a27f846f003fc745713339a9122473", "html_url": "https://github.com/rust-lang/rust/commit/e6d2de9483a27f846f003fc745713339a9122473", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6d2de9483a27f846f003fc745713339a9122473/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58f9efd36de5669ab731ec7ebf565999ff17b159", "url": "https://api.github.com/repos/rust-lang/rust/commits/58f9efd36de5669ab731ec7ebf565999ff17b159", "html_url": "https://github.com/rust-lang/rust/commit/58f9efd36de5669ab731ec7ebf565999ff17b159"}, {"sha": "afa6f92c466a554e71a6ce434680196958a8cb59", "url": "https://api.github.com/repos/rust-lang/rust/commits/afa6f92c466a554e71a6ce434680196958a8cb59", "html_url": "https://github.com/rust-lang/rust/commit/afa6f92c466a554e71a6ce434680196958a8cb59"}], "stats": {"total": 1696, "additions": 905, "deletions": 791}, "files": [{"sha": "0d36466f6e3e73153e2498e393c608614cc367da", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(trusted_len)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "0ab077cf2bf404335d81a5488792adf8e2d25065", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -95,7 +95,8 @@ pub fn equal_up_to_regions(\n                 // Leave consts and types unchanged.\n                 ct_op: |ct| ct,\n                 ty_op: |ty| ty,\n-            }),\n+            })\n+            .into_ok(),\n         )\n     };\n     tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())"}, {"sha": "920f7b1ed0a543c15dac3c272f59edad8243464e", "filename": "compiler/rustc_data_structures/src/functor.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -1,45 +1,52 @@\n use rustc_index::vec::{Idx, IndexVec};\n use std::mem;\n-use std::ptr;\n \n-pub trait IdFunctor {\n+pub trait IdFunctor: Sized {\n     type Inner;\n \n-    fn map_id<F>(self, f: F) -> Self\n+    #[inline]\n+    fn map_id<F>(self, mut f: F) -> Self\n+    where\n+        F: FnMut(Self::Inner) -> Self::Inner,\n+    {\n+        self.try_map_id::<_, !>(|value| Ok(f(value))).into_ok()\n+    }\n+\n+    fn try_map_id<F, E>(self, f: F) -> Result<Self, E>\n     where\n-        F: FnMut(Self::Inner) -> Self::Inner;\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>;\n }\n \n impl<T> IdFunctor for Box<T> {\n     type Inner = T;\n \n     #[inline]\n-    fn map_id<F>(self, mut f: F) -> Self\n+    fn try_map_id<F, E>(self, mut f: F) -> Result<Self, E>\n     where\n-        F: FnMut(Self::Inner) -> Self::Inner,\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n     {\n         let raw = Box::into_raw(self);\n-        unsafe {\n+        Ok(unsafe {\n             // SAFETY: The raw pointer points to a valid value of type `T`.\n-            let value = ptr::read(raw);\n+            let value = raw.read();\n             // SAFETY: Converts `Box<T>` to `Box<MaybeUninit<T>>` which is the\n             // inverse of `Box::assume_init()` and should be safe.\n             let mut raw: Box<mem::MaybeUninit<T>> = Box::from_raw(raw.cast());\n             // SAFETY: Write the mapped value back into the `Box`.\n-            raw.write(f(value));\n+            raw.write(f(value)?);\n             // SAFETY: We just initialized `raw`.\n             raw.assume_init()\n-        }\n+        })\n     }\n }\n \n impl<T> IdFunctor for Vec<T> {\n     type Inner = T;\n \n     #[inline]\n-    fn map_id<F>(mut self, mut f: F) -> Self\n+    fn try_map_id<F, E>(mut self, mut f: F) -> Result<Self, E>\n     where\n-        F: FnMut(Self::Inner) -> Self::Inner,\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n     {\n         // FIXME: We don't really care about panics here and leak\n         // far more than we should, but that should be fine for now.\n@@ -49,34 +56,49 @@ impl<T> IdFunctor for Vec<T> {\n             let start = self.as_mut_ptr();\n             for i in 0..len {\n                 let p = start.add(i);\n-                ptr::write(p, f(ptr::read(p)));\n+                match f(p.read()) {\n+                    Ok(val) => p.write(val),\n+                    Err(err) => {\n+                        // drop all other elements in self\n+                        // (current element was \"moved\" into the call to f)\n+                        for j in (0..i).chain(i + 1..len) {\n+                            start.add(j).drop_in_place();\n+                        }\n+\n+                        // returning will drop self, releasing the allocation\n+                        // (len is 0 so elements will not be re-dropped)\n+                        return Err(err);\n+                    }\n+                }\n             }\n+            // Even if we encountered an error, set the len back\n+            // so we don't leak memory.\n             self.set_len(len);\n         }\n-        self\n+        Ok(self)\n     }\n }\n \n impl<T> IdFunctor for Box<[T]> {\n     type Inner = T;\n \n     #[inline]\n-    fn map_id<F>(self, f: F) -> Self\n+    fn try_map_id<F, E>(self, f: F) -> Result<Self, E>\n     where\n-        F: FnMut(Self::Inner) -> Self::Inner,\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n     {\n-        Vec::from(self).map_id(f).into()\n+        Vec::from(self).try_map_id(f).map(Into::into)\n     }\n }\n \n impl<I: Idx, T> IdFunctor for IndexVec<I, T> {\n     type Inner = T;\n \n     #[inline]\n-    fn map_id<F>(self, f: F) -> Self\n+    fn try_map_id<F, E>(self, f: F) -> Result<Self, E>\n     where\n-        F: FnMut(Self::Inner) -> Self::Inner,\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n     {\n-        IndexVec::from_raw(self.raw.map_id(f))\n+        self.raw.try_map_id(f).map(IndexVec::from_raw)\n     }\n }"}, {"sha": "d4eb622e780ce1857af21276d6d4fcb5df8f9a7d", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -25,6 +25,7 @@\n #![feature(once_cell)]\n #![feature(test)]\n #![feature(thread_id_value)]\n+#![feature(unwrap_infallible)]\n #![allow(rustc::default_hash_types)]\n #![deny(unaligned_references)]\n "}, {"sha": "27e73738b7f351bf07bd4bd56298cd90477ecaee", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -278,7 +278,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> Result<ty::Binder<'tcx, T>, Self::Error>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -288,13 +288,13 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(index, ..) => {\n                 if index >= self.binder_index {\n                     bug!(\"escaping late-bound region during canonicalization\");\n                 } else {\n-                    r\n+                    Ok(r)\n                 }\n             }\n \n@@ -311,19 +311,19 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     vid, r\n                 );\n                 let r = self.tcx.reuse_or_mk_region(r, ty::ReVar(resolved_vid));\n-                self.canonicalize_region_mode.canonicalize_free_region(self, r)\n+                Ok(self.canonicalize_region_mode.canonicalize_free_region(self, r))\n             }\n \n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n+            | ty::ReErased => Ok(self.canonicalize_region_mode.canonicalize_free_region(self, r)),\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             ty::Infer(ty::TyVar(vid)) => {\n                 debug!(\"canonical: type var found with vid {:?}\", vid);\n@@ -339,40 +339,40 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     Err(mut ui) => {\n                         // FIXME: perf problem described in #55921.\n                         ui = ty::UniverseIndex::ROOT;\n-                        self.canonicalize_ty_var(\n+                        Ok(self.canonicalize_ty_var(\n                             CanonicalVarInfo {\n                                 kind: CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n                             },\n                             t,\n-                        )\n+                        ))\n                     }\n                 }\n             }\n \n-            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(\n+            ty::Infer(ty::IntVar(_)) => Ok(self.canonicalize_ty_var(\n                 CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int) },\n                 t,\n-            ),\n+            )),\n \n-            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(\n+            ty::Infer(ty::FloatVar(_)) => Ok(self.canonicalize_ty_var(\n                 CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float) },\n                 t,\n-            ),\n+            )),\n \n             ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"encountered a fresh type during canonicalization\")\n             }\n \n-            ty::Placeholder(placeholder) => self.canonicalize_ty_var(\n+            ty::Placeholder(placeholder) => Ok(self.canonicalize_ty_var(\n                 CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderTy(placeholder) },\n                 t,\n-            ),\n+            )),\n \n             ty::Bound(debruijn, _) => {\n                 if debruijn >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n                 } else {\n-                    t\n+                    Ok(t)\n                 }\n             }\n \n@@ -403,13 +403,16 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 if t.flags().intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {\n-                    t\n+                    Ok(t)\n                 }\n             }\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         match ct.val {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 debug!(\"canonical: const var found with vid {:?}\", vid);\n@@ -424,10 +427,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     Err(mut ui) => {\n                         // FIXME: perf problem described in #55921.\n                         ui = ty::UniverseIndex::ROOT;\n-                        return self.canonicalize_const_var(\n+                        return Ok(self.canonicalize_const_var(\n                             CanonicalVarInfo { kind: CanonicalVarKind::Const(ui) },\n                             ct,\n-                        );\n+                        ));\n                     }\n                 }\n             }\n@@ -438,20 +441,20 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 if debruijn >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n                 } else {\n-                    return ct;\n+                    return Ok(ct);\n                 }\n             }\n             ty::ConstKind::Placeholder(placeholder) => {\n-                return self.canonicalize_const_var(\n+                return Ok(self.canonicalize_const_var(\n                     CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderConst(placeholder) },\n                     ct,\n-                );\n+                ));\n             }\n             _ => {}\n         }\n \n         let flags = FlagComputation::for_const(ct);\n-        if flags.intersects(self.needs_canonical_flags) { ct.super_fold_with(self) } else { ct }\n+        if flags.intersects(self.needs_canonical_flags) { ct.super_fold_with(self) } else { Ok(ct) }\n     }\n }\n \n@@ -500,7 +503,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n             indices: FxHashMap::default(),\n             binder_index: ty::INNERMOST,\n         };\n-        let out_value = value.fold_with(&mut canonicalizer);\n+        let out_value = value.fold_with(&mut canonicalizer).into_ok();\n \n         // Once we have canonicalized `out_value`, it should not\n         // contain anything that ties it to this inference context\n@@ -618,7 +621,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         let infcx = self.infcx;\n         let bound_to = infcx.shallow_resolve(ty_var);\n         if bound_to != ty_var {\n-            self.fold_ty(bound_to)\n+            self.fold_ty(bound_to).into_ok()\n         } else {\n             let var = self.canonical_var(info, ty_var.into());\n             self.tcx().mk_ty(ty::Bound(self.binder_index, var.into()))\n@@ -637,12 +640,12 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         let infcx = self.infcx;\n         let bound_to = infcx.shallow_resolve(const_var);\n         if bound_to != const_var {\n-            self.fold_const(bound_to)\n+            self.fold_const(bound_to).into_ok()\n         } else {\n             let var = self.canonical_var(info, const_var.into());\n             self.tcx().mk_const(ty::Const {\n                 val: ty::ConstKind::Bound(self.binder_index, var),\n-                ty: self.fold_ty(const_var.ty),\n+                ty: self.fold_ty(const_var.ty).into_ok(),\n             })\n         }\n     }"}, {"sha": "7599e98167fb5c04e6c8e2839ae394a4f3761c68", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n         F: FnOnce(u32) -> ty::InferTy,\n     {\n         if let Some(ty) = opt_ty {\n-            return ty.fold_with(self);\n+            return ty.fold_with(self).into_ok();\n         }\n \n         match self.ty_freshen_map.entry(key) {\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n         F: FnOnce(u32) -> ty::InferConst<'tcx>,\n     {\n         if let Some(ct) = opt_ct {\n-            return ct.fold_with(self);\n+            return ct.fold_with(self).into_ok();\n         }\n \n         match self.const_freshen_map.entry(key) {\n@@ -119,11 +119,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(..) => {\n                 // leave bound regions alone\n-                r\n+                Ok(r)\n             }\n \n             ty::ReEarlyBound(..)\n@@ -133,32 +133,32 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // replace all free regions with 'erased\n-                self.tcx().lifetimes.re_erased\n+                Ok(self.tcx().lifetimes.re_erased)\n             }\n             ty::ReStatic => {\n                 if self.keep_static {\n-                    r\n+                    Ok(r)\n                 } else {\n-                    self.tcx().lifetimes.re_erased\n+                    Ok(self.tcx().lifetimes.re_erased)\n                 }\n             }\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.needs_infer() && !t.has_erasable_regions(self.tcx()) {\n-            return t;\n+            return Ok(t);\n         }\n \n         let tcx = self.infcx.tcx;\n \n         match *t.kind() {\n             ty::Infer(ty::TyVar(v)) => {\n                 let opt_ty = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n-                self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)\n+                Ok(self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy))\n             }\n \n-            ty::Infer(ty::IntVar(v)) => self.freshen_ty(\n+            ty::Infer(ty::IntVar(v)) => Ok(self.freshen_ty(\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n@@ -167,9 +167,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .map(|v| v.to_type(tcx)),\n                 ty::IntVar(v),\n                 ty::FreshIntTy,\n-            ),\n+            )),\n \n-            ty::Infer(ty::FloatVar(v)) => self.freshen_ty(\n+            ty::Infer(ty::FloatVar(v)) => Ok(self.freshen_ty(\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .map(|v| v.to_type(tcx)),\n                 ty::FloatVar(v),\n                 ty::FreshFloatTy,\n-            ),\n+            )),\n \n             ty::Infer(ty::FreshTy(ct) | ty::FreshIntTy(ct) | ty::FreshFloatTy(ct)) => {\n                 if ct >= self.ty_freshen_count {\n@@ -189,7 +189,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                         self.ty_freshen_count\n                     );\n                 }\n-                t\n+                Ok(t)\n             }\n \n             ty::Generator(..)\n@@ -221,7 +221,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         match ct.val {\n             ty::ConstKind::Infer(ty::InferConst::Var(v)) => {\n                 let opt_ct = self\n@@ -232,12 +235,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .probe_value(v)\n                     .val\n                     .known();\n-                return self.freshen_const(\n+                return Ok(self.freshen_const(\n                     opt_ct,\n                     ty::InferConst::Var(v),\n                     ty::InferConst::Fresh,\n                     ct.ty,\n-                );\n+                ));\n             }\n             ty::ConstKind::Infer(ty::InferConst::Fresh(i)) => {\n                 if i >= self.const_freshen_count {\n@@ -248,7 +251,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                         self.const_freshen_count,\n                     );\n                 }\n-                return ct;\n+                return Ok(ct);\n             }\n \n             ty::ConstKind::Bound(..) | ty::ConstKind::Placeholder(_) => {"}, {"sha": "4e6f1315d102437ecf565992403cf0548181c6a4", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         {\n             Ok(value)\n         } else {\n-            Ok(value.fold_with(&mut fudger))\n+            Ok(value.fold_with(&mut fudger).into_ok())\n         }\n     }\n }\n@@ -180,15 +180,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *ty.kind() {\n             ty::Infer(ty::InferTy::TyVar(vid)) => {\n                 if self.type_vars.0.contains(&vid) {\n                     // This variable was created during the fudging.\n                     // Recreate it with a fresh variable here.\n                     let idx = (vid.as_usize() - self.type_vars.0.start.as_usize()) as usize;\n                     let origin = self.type_vars.1[idx];\n-                    self.infcx.next_ty_var(origin)\n+                    Ok(self.infcx.next_ty_var(origin))\n                 } else {\n                     // This variable was created before the\n                     // \"fudging\". Since we refresh all type\n@@ -198,48 +198,43 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n                     debug_assert!(\n                         self.infcx.inner.borrow_mut().type_variables().probe(vid).is_unknown()\n                     );\n-                    ty\n+                    Ok(ty)\n                 }\n             }\n             ty::Infer(ty::InferTy::IntVar(vid)) => {\n-                if self.int_vars.contains(&vid) {\n-                    self.infcx.next_int_var()\n-                } else {\n-                    ty\n-                }\n+                Ok(if self.int_vars.contains(&vid) { self.infcx.next_int_var() } else { ty })\n             }\n             ty::Infer(ty::InferTy::FloatVar(vid)) => {\n-                if self.float_vars.contains(&vid) {\n-                    self.infcx.next_float_var()\n-                } else {\n-                    ty\n-                }\n+                Ok(if self.float_vars.contains(&vid) { self.infcx.next_float_var() } else { ty })\n             }\n             _ => ty.super_fold_with(self),\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         if let ty::ReVar(vid) = *r {\n             if self.region_vars.0.contains(&vid) {\n                 let idx = vid.index() - self.region_vars.0.start.index();\n                 let origin = self.region_vars.1[idx];\n-                return self.infcx.next_region_var(origin);\n+                return Ok(self.infcx.next_region_var(origin));\n             }\n         }\n-        r\n+        Ok(r)\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if let ty::Const { val: ty::ConstKind::Infer(ty::InferConst::Var(vid)), ty } = ct {\n             if self.const_vars.0.contains(&vid) {\n                 // This variable was created during the fudging.\n                 // Recreate it with a fresh variable here.\n                 let idx = (vid.index - self.const_vars.0.start.index) as usize;\n                 let origin = self.const_vars.1[idx];\n-                self.infcx.next_const_var(ty, origin)\n+                Ok(self.infcx.next_const_var(ty, origin))\n             } else {\n-                ct\n+                Ok(ct)\n             }\n         } else {\n             ct.super_fold_with(self)"}, {"sha": "4a9a63e1c76029357a4f14f033ff386c4560c6f6", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -681,7 +681,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n-        t.fold_with(&mut self.freshener())\n+        t.fold_with(&mut self.freshener()).into_ok()\n     }\n \n     /// Returns the origin of the type variable identified by `vid`, or `None`\n@@ -1381,7 +1381,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        value.fold_with(&mut ShallowResolver { infcx: self })\n+        value.fold_with(&mut ShallowResolver { infcx: self }).into_ok()\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n@@ -1402,7 +1402,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return value; // Avoid duplicated subst-folding.\n         }\n         let mut r = resolve::OpportunisticVarResolver::new(self);\n-        value.fold_with(&mut r)\n+        value.fold_with(&mut r).into_ok()\n     }\n \n     /// Returns the first unresolved variable contained in `T`. In the\n@@ -1745,12 +1745,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.shallow_resolve_ty(ty)\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        Ok(self.infcx.shallow_resolve_ty(ty))\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        Ok(if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n             self.infcx\n                 .inner\n                 .borrow_mut()\n@@ -1761,7 +1764,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n                 .unwrap_or(ct)\n         } else {\n             ct\n-        }\n+        })\n     }\n }\n "}, {"sha": "932f26d5550108df9dcc679cd84ddf5bb547cc2a", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 100, "deletions": 96, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -418,92 +418,94 @@ struct Instantiator<'a, 'tcx> {\n impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n     fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         let tcx = self.infcx.tcx;\n-        value.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            ty_op: |ty| {\n-                if ty.references_error() {\n-                    return tcx.ty_error();\n-                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n-                    // Check that this is `impl Trait` type is\n-                    // declared by `parent_def_id` -- i.e., one whose\n-                    // value we are inferring.  At present, this is\n-                    // always true during the first phase of\n-                    // type-check, but not always true later on during\n-                    // NLL. Once we support named opaque types more fully,\n-                    // this same scenario will be able to arise during all phases.\n-                    //\n-                    // Here is an example using type alias `impl Trait`\n-                    // that indicates the distinction we are checking for:\n-                    //\n-                    // ```rust\n-                    // mod a {\n-                    //   pub type Foo = impl Iterator;\n-                    //   pub fn make_foo() -> Foo { .. }\n-                    // }\n-                    //\n-                    // mod b {\n-                    //   fn foo() -> a::Foo { a::make_foo() }\n-                    // }\n-                    // ```\n-                    //\n-                    // Here, the return type of `foo` references an\n-                    // `Opaque` indeed, but not one whose value is\n-                    // presently being inferred. You can get into a\n-                    // similar situation with closure return types\n-                    // today:\n-                    //\n-                    // ```rust\n-                    // fn foo() -> impl Iterator { .. }\n-                    // fn bar() {\n-                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                    // }\n-                    // ```\n-                    if let Some(def_id) = def_id.as_local() {\n-                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let parent_def_id = self.infcx.defining_use_anchor;\n-                        let def_scope_default = || {\n-                            let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n-                        };\n-                        let (in_definition_scope, origin) =\n-                            match tcx.hir().expect_item(opaque_hir_id).kind {\n-                                // Anonymous `impl Trait`\n-                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                    impl_trait_fn: Some(parent),\n-                                    origin,\n-                                    ..\n-                                }) => (parent == parent_def_id.to_def_id(), origin),\n-                                // Named `type Foo = impl Bar;`\n-                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                    impl_trait_fn: None,\n-                                    origin,\n-                                    ..\n-                                }) => (\n-                                    may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n-                                    origin,\n-                                ),\n-                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n+        value\n+            .fold_with(&mut BottomUpFolder {\n+                tcx,\n+                ty_op: |ty| {\n+                    if ty.references_error() {\n+                        return tcx.ty_error();\n+                    } else if let ty::Opaque(def_id, substs) = ty.kind() {\n+                        // Check that this is `impl Trait` type is\n+                        // declared by `parent_def_id` -- i.e., one whose\n+                        // value we are inferring.  At present, this is\n+                        // always true during the first phase of\n+                        // type-check, but not always true later on during\n+                        // NLL. Once we support named opaque types more fully,\n+                        // this same scenario will be able to arise during all phases.\n+                        //\n+                        // Here is an example using type alias `impl Trait`\n+                        // that indicates the distinction we are checking for:\n+                        //\n+                        // ```rust\n+                        // mod a {\n+                        //   pub type Foo = impl Iterator;\n+                        //   pub fn make_foo() -> Foo { .. }\n+                        // }\n+                        //\n+                        // mod b {\n+                        //   fn foo() -> a::Foo { a::make_foo() }\n+                        // }\n+                        // ```\n+                        //\n+                        // Here, the return type of `foo` references an\n+                        // `Opaque` indeed, but not one whose value is\n+                        // presently being inferred. You can get into a\n+                        // similar situation with closure return types\n+                        // today:\n+                        //\n+                        // ```rust\n+                        // fn foo() -> impl Iterator { .. }\n+                        // fn bar() {\n+                        //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                        // }\n+                        // ```\n+                        if let Some(def_id) = def_id.as_local() {\n+                            let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+                            let parent_def_id = self.infcx.defining_use_anchor;\n+                            let def_scope_default = || {\n+                                let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n+                                parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n                             };\n-                        if in_definition_scope {\n-                            let opaque_type_key =\n-                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n-                        }\n-\n-                        debug!(\n-                            \"instantiate_opaque_types_in_map: \\\n+                            let (in_definition_scope, origin) =\n+                                match tcx.hir().expect_item(opaque_hir_id).kind {\n+                                    // Anonymous `impl Trait`\n+                                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                        impl_trait_fn: Some(parent),\n+                                        origin,\n+                                        ..\n+                                    }) => (parent == parent_def_id.to_def_id(), origin),\n+                                    // Named `type Foo = impl Bar;`\n+                                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                        impl_trait_fn: None,\n+                                        origin,\n+                                        ..\n+                                    }) => (\n+                                        may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n+                                        origin,\n+                                    ),\n+                                    _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n+                                };\n+                            if in_definition_scope {\n+                                let opaque_type_key =\n+                                    OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n+                                return self.fold_opaque_ty(ty, opaque_type_key, origin);\n+                            }\n+\n+                            debug!(\n+                                \"instantiate_opaque_types_in_map: \\\n                              encountered opaque outside its definition scope \\\n                              def_id={:?}\",\n-                            def_id,\n-                        );\n+                                def_id,\n+                            );\n+                        }\n                     }\n-                }\n \n-                ty\n-            },\n-            lt_op: |lt| lt,\n-            ct_op: |ct| ct,\n-        })\n+                    ty\n+                },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            })\n+            .into_ok()\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -556,21 +558,23 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             debug!(?predicate);\n \n             // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n-            let predicate = predicate.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                ty_op: |ty| match ty.kind() {\n-                    ty::Projection(projection_ty) => infcx.infer_projection(\n-                        self.param_env,\n-                        *projection_ty,\n-                        traits::ObligationCause::misc(self.value_span, self.body_id),\n-                        0,\n-                        &mut self.obligations,\n-                    ),\n-                    _ => ty,\n-                },\n-                lt_op: |lt| lt,\n-                ct_op: |ct| ct,\n-            });\n+            let predicate = predicate\n+                .fold_with(&mut BottomUpFolder {\n+                    tcx,\n+                    ty_op: |ty| match ty.kind() {\n+                        ty::Projection(projection_ty) => infcx.infer_projection(\n+                            self.param_env,\n+                            *projection_ty,\n+                            traits::ObligationCause::misc(self.value_span, self.body_id),\n+                            0,\n+                            &mut self.obligations,\n+                        ),\n+                        _ => ty,\n+                    },\n+                    lt_op: |lt| lt,\n+                    ct_op: |ct| ct,\n+                })\n+                .into_ok();\n             debug!(?predicate);\n \n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {"}, {"sha": "cccdfb7452a77fd7db25cda5f59171172640f610", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -30,25 +30,28 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.has_infer_types_or_consts() {\n-            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+            Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             t.super_fold_with(self)\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n+    fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> Result<&'tcx Const<'tcx>, Self::Error> {\n         if !ct.has_infer_types_or_consts() {\n-            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n+            Ok(ct) // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let ct = self.infcx.shallow_resolve(ct);\n             ct.super_fold_with(self)\n         }\n     }\n \n-    fn fold_mir_const(&mut self, constant: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        constant: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         constant.super_fold_with(self)\n     }\n }\n@@ -75,16 +78,16 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.has_infer_regions() {\n-            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+            Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             t.super_fold_with(self)\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        Ok(match *r {\n             ty::ReVar(rid) => {\n                 let resolved = self\n                     .infcx\n@@ -95,12 +98,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n                 self.tcx().reuse_or_mk_region(r, ty::ReVar(resolved))\n             }\n             _ => r,\n-        }\n+        })\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if !ct.has_infer_regions() {\n-            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n+            Ok(ct) // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             ct.super_fold_with(self)\n         }\n@@ -175,44 +181,31 @@ pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>, value: T) -> Fixu\n where\n     T: TypeFoldable<'tcx>,\n {\n-    let mut full_resolver = FullTypeResolver { infcx, err: None };\n-    let result = value.fold_with(&mut full_resolver);\n-    match full_resolver.err {\n-        None => Ok(result),\n-        Some(e) => Err(e),\n-    }\n+    value.fold_with(&mut FullTypeResolver { infcx })\n }\n \n // N.B. This type is not public because the protocol around checking the\n // `err` field is not enforceable otherwise.\n struct FullTypeResolver<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    err: Option<FixupError<'tcx>>,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n+    type Error = FixupError<'tcx>;\n+\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.needs_infer() {\n-            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+            Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match *t.kind() {\n-                ty::Infer(ty::TyVar(vid)) => {\n-                    self.err = Some(FixupError::UnresolvedTy(vid));\n-                    self.tcx().ty_error()\n-                }\n-                ty::Infer(ty::IntVar(vid)) => {\n-                    self.err = Some(FixupError::UnresolvedIntTy(vid));\n-                    self.tcx().ty_error()\n-                }\n-                ty::Infer(ty::FloatVar(vid)) => {\n-                    self.err = Some(FixupError::UnresolvedFloatTy(vid));\n-                    self.tcx().ty_error()\n-                }\n+                ty::Infer(ty::TyVar(vid)) => Err(FixupError::UnresolvedTy(vid)),\n+                ty::Infer(ty::IntVar(vid)) => Err(FixupError::UnresolvedIntTy(vid)),\n+                ty::Infer(ty::FloatVar(vid)) => Err(FixupError::UnresolvedFloatTy(vid)),\n                 ty::Infer(_) => {\n                     bug!(\"Unexpected type in full type resolver: {:?}\", t);\n                 }\n@@ -221,28 +214,30 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n-            ty::ReVar(rid) => self\n+            ty::ReVar(rid) => Ok(self\n                 .infcx\n                 .lexical_region_resolutions\n                 .borrow()\n                 .as_ref()\n                 .expect(\"region resolution not performed\")\n-                .resolve_var(rid),\n-            _ => r,\n+                .resolve_var(rid)),\n+            _ => Ok(r),\n         }\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if !c.needs_infer() {\n-            c // micro-optimize -- if there is nothing in this const that this fold affects...\n+            Ok(c) // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let c = self.infcx.shallow_resolve(c);\n             match c.val {\n                 ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                    self.err = Some(FixupError::UnresolvedConst(vid));\n-                    return self.tcx().const_error(c.ty);\n+                    return Err(FixupError::UnresolvedConst(vid));\n                 }\n                 ty::ConstKind::Infer(InferConst::Fresh(_)) => {\n                     bug!(\"Unexpected const in full const resolver: {:?}\", c);"}, {"sha": "5153427954ccc723f761dbf1f79ab274146b8f1f", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -24,6 +24,7 @@\n #![feature(control_flow_enum)]\n #![feature(min_specialization)]\n #![feature(label_break_value)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "544b89397790a0f6b321228f346771ec6e95e49a", "filename": "compiler/rustc_infer/src/traits/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -60,13 +60,13 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n // TypeFoldable implementations.\n \n impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        traits::Obligation {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(traits::Obligation {\n             cause: self.cause,\n             recursion_depth: self.recursion_depth,\n-            predicate: self.predicate.fold_with(folder),\n-            param_env: self.param_env.fold_with(folder),\n-        }\n+            predicate: self.predicate.fold_with(folder)?,\n+            param_env: self.param_env.fold_with(folder)?,\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {"}, {"sha": "769f009b492067c7141a871334025929f9b912aa", "filename": "compiler/rustc_macros/src/type_foldable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -17,7 +17,7 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n         vi.construct(|_, index| {\n             let bind = &bindings[index];\n             quote! {\n-                ::rustc_middle::ty::fold::TypeFoldable::fold_with(#bind, __folder)\n+                ::rustc_middle::ty::fold::TypeFoldable::fold_with(#bind, __folder)?\n             }\n         })\n     });\n@@ -28,8 +28,8 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n             fn super_fold_with<__F: ::rustc_middle::ty::fold::TypeFolder<'tcx>>(\n                 self,\n                 __folder: &mut __F\n-            ) -> Self {\n-                match self { #body_fold }\n+            ) -> Result<Self, __F::Error> {\n+                Ok(match self { #body_fold })\n             }\n \n             fn super_visit_with<__F: ::rustc_middle::ty::fold::TypeVisitor<'tcx>>("}, {"sha": "b67ad8b770ea1537ca2e8264d2a36a5eeb50cb30", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -56,6 +56,7 @@\n #![feature(try_blocks)]\n #![feature(try_reserve_kind)]\n #![feature(nonzero_ops)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "c0cf265b2287957f1edd0fb8eb5513d00f2c165d", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -55,8 +55,8 @@ macro_rules! TrivialTypeFoldableImpls {\n                 fn super_fold_with<F: $crate::ty::fold::TypeFolder<$tcx>>(\n                     self,\n                     _: &mut F\n-                ) -> $ty {\n-                    self\n+                ) -> ::std::result::Result<$ty, F::Error> {\n+                    Ok(self)\n                 }\n \n                 fn super_visit_with<F: $crate::ty::fold::TypeVisitor<$tcx>>(\n@@ -98,7 +98,7 @@ macro_rules! EnumTypeFoldableImpl {\n             fn super_fold_with<V: $crate::ty::fold::TypeFolder<$tcx>>(\n                 self,\n                 folder: &mut V,\n-            ) -> Self {\n+            ) -> ::std::result::Result<Self, V::Error> {\n                 EnumTypeFoldableImpl!(@FoldVariants(self, folder) input($($variants)*) output())\n             }\n \n@@ -112,9 +112,9 @@ macro_rules! EnumTypeFoldableImpl {\n     };\n \n     (@FoldVariants($this:expr, $folder:expr) input() output($($output:tt)*)) => {\n-        match $this {\n+        Ok(match $this {\n             $($output)*\n-        }\n+        })\n     };\n \n     (@FoldVariants($this:expr, $folder:expr)\n@@ -126,7 +126,7 @@ macro_rules! EnumTypeFoldableImpl {\n                 output(\n                     $variant ( $($variant_arg),* ) => {\n                         $variant (\n-                            $($crate::ty::fold::TypeFoldable::fold_with($variant_arg, $folder)),*\n+                            $($crate::ty::fold::TypeFoldable::fold_with($variant_arg, $folder)?),*\n                         )\n                     }\n                     $($output)*\n@@ -145,7 +145,7 @@ macro_rules! EnumTypeFoldableImpl {\n                         $variant {\n                             $($variant_arg: $crate::ty::fold::TypeFoldable::fold_with(\n                                 $variant_arg, $folder\n-                            )),* }\n+                            )?),* }\n                     }\n                     $($output)*\n                 )"}, {"sha": "a05b8a1da8d7f008a8b9def9e6395eccff64ac93", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -2760,11 +2760,11 @@ impl UserTypeProjection {\n TrivialTypeFoldableAndLiftImpls! { ProjectionKind, }\n \n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        UserTypeProjection {\n-            base: self.base.fold_with(folder),\n-            projs: self.projs.fold_with(folder),\n-        }\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(UserTypeProjection {\n+            base: self.base.fold_with(folder)?,\n+            projs: self.projs.fold_with(folder)?,\n+        })\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>("}, {"sha": "df7c6d9cf66501a41b67d809f66a4999f259af78", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 91, "deletions": 84, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -16,37 +16,39 @@ TrivialTypeFoldableAndLiftImpls! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         use crate::mir::TerminatorKind::*;\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n             SwitchInt { discr, switch_ty, targets } => SwitchInt {\n-                discr: discr.fold_with(folder),\n-                switch_ty: switch_ty.fold_with(folder),\n+                discr: discr.fold_with(folder)?,\n+                switch_ty: switch_ty.fold_with(folder)?,\n                 targets,\n             },\n             Drop { place, target, unwind } => {\n-                Drop { place: place.fold_with(folder), target, unwind }\n+                Drop { place: place.fold_with(folder)?, target, unwind }\n             }\n             DropAndReplace { place, value, target, unwind } => DropAndReplace {\n-                place: place.fold_with(folder),\n-                value: value.fold_with(folder),\n+                place: place.fold_with(folder)?,\n+                value: value.fold_with(folder)?,\n                 target,\n                 unwind,\n             },\n             Yield { value, resume, resume_arg, drop } => Yield {\n-                value: value.fold_with(folder),\n+                value: value.fold_with(folder)?,\n                 resume,\n-                resume_arg: resume_arg.fold_with(folder),\n+                resume_arg: resume_arg.fold_with(folder)?,\n                 drop,\n             },\n             Call { func, args, destination, cleanup, from_hir_call, fn_span } => {\n-                let dest = destination.map(|(loc, dest)| (loc.fold_with(folder), dest));\n+                let dest = destination\n+                    .map(|(loc, dest)| (loc.fold_with(folder).map(|loc| (loc, dest))))\n+                    .transpose()?;\n \n                 Call {\n-                    func: func.fold_with(folder),\n-                    args: args.fold_with(folder),\n+                    func: func.fold_with(folder)?,\n+                    args: args.fold_with(folder)?,\n                     destination: dest,\n                     cleanup,\n                     from_hir_call,\n@@ -57,15 +59,15 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 use AssertKind::*;\n                 let msg = match msg {\n                     BoundsCheck { len, index } => {\n-                        BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n+                        BoundsCheck { len: len.fold_with(folder)?, index: index.fold_with(folder)? }\n                     }\n-                    Overflow(op, l, r) => Overflow(op, l.fold_with(folder), r.fold_with(folder)),\n-                    OverflowNeg(op) => OverflowNeg(op.fold_with(folder)),\n-                    DivisionByZero(op) => DivisionByZero(op.fold_with(folder)),\n-                    RemainderByZero(op) => RemainderByZero(op.fold_with(folder)),\n+                    Overflow(op, l, r) => Overflow(op, l.fold_with(folder)?, r.fold_with(folder)?),\n+                    OverflowNeg(op) => OverflowNeg(op.fold_with(folder)?),\n+                    DivisionByZero(op) => DivisionByZero(op.fold_with(folder)?),\n+                    RemainderByZero(op) => RemainderByZero(op.fold_with(folder)?),\n                     ResumedAfterReturn(_) | ResumedAfterPanic(_) => msg,\n                 };\n-                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n+                Assert { cond: cond.fold_with(folder)?, expected, msg, target, cleanup }\n             }\n             GeneratorDrop => GeneratorDrop,\n             Resume => Resume,\n@@ -78,13 +80,13 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n             InlineAsm { template, operands, options, line_spans, destination } => InlineAsm {\n                 template,\n-                operands: operands.fold_with(folder),\n+                operands: operands.fold_with(folder)?,\n                 options,\n                 line_spans,\n                 destination,\n             },\n         };\n-        Terminator { source_info: self.source_info, kind }\n+        Ok(Terminator { source_info: self.source_info, kind })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -140,8 +142,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -150,8 +152,11 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(Place {\n+            local: self.local.fold_with(folder)?,\n+            projection: self.projection.fold_with(folder)?,\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -161,7 +166,7 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_place_elems(v))\n     }\n \n@@ -171,47 +176,49 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         use crate::mir::Rvalue::*;\n-        match self {\n-            Use(op) => Use(op.fold_with(folder)),\n-            Repeat(op, len) => Repeat(op.fold_with(folder), len.fold_with(folder)),\n-            ThreadLocalRef(did) => ThreadLocalRef(did.fold_with(folder)),\n-            Ref(region, bk, place) => Ref(region.fold_with(folder), bk, place.fold_with(folder)),\n-            AddressOf(mutability, place) => AddressOf(mutability, place.fold_with(folder)),\n-            Len(place) => Len(place.fold_with(folder)),\n-            Cast(kind, op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n+        Ok(match self {\n+            Use(op) => Use(op.fold_with(folder)?),\n+            Repeat(op, len) => Repeat(op.fold_with(folder)?, len.fold_with(folder)?),\n+            ThreadLocalRef(did) => ThreadLocalRef(did.fold_with(folder)?),\n+            Ref(region, bk, place) => Ref(region.fold_with(folder)?, bk, place.fold_with(folder)?),\n+            AddressOf(mutability, place) => AddressOf(mutability, place.fold_with(folder)?),\n+            Len(place) => Len(place.fold_with(folder)?),\n+            Cast(kind, op, ty) => Cast(kind, op.fold_with(folder)?, ty.fold_with(folder)?),\n             BinaryOp(op, box (rhs, lhs)) => {\n-                BinaryOp(op, Box::new((rhs.fold_with(folder), lhs.fold_with(folder))))\n+                BinaryOp(op, Box::new((rhs.fold_with(folder)?, lhs.fold_with(folder)?)))\n             }\n             CheckedBinaryOp(op, box (rhs, lhs)) => {\n-                CheckedBinaryOp(op, Box::new((rhs.fold_with(folder), lhs.fold_with(folder))))\n+                CheckedBinaryOp(op, Box::new((rhs.fold_with(folder)?, lhs.fold_with(folder)?)))\n             }\n-            UnaryOp(op, val) => UnaryOp(op, val.fold_with(folder)),\n-            Discriminant(place) => Discriminant(place.fold_with(folder)),\n-            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n+            UnaryOp(op, val) => UnaryOp(op, val.fold_with(folder)?),\n+            Discriminant(place) => Discriminant(place.fold_with(folder)?),\n+            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)?),\n             Aggregate(kind, fields) => {\n-                let kind = kind.map_id(|kind| match kind {\n-                    AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n-                    AggregateKind::Tuple => AggregateKind::Tuple,\n-                    AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n-                        def,\n-                        v,\n-                        substs.fold_with(folder),\n-                        user_ty.fold_with(folder),\n-                        n,\n-                    ),\n-                    AggregateKind::Closure(id, substs) => {\n-                        AggregateKind::Closure(id, substs.fold_with(folder))\n-                    }\n-                    AggregateKind::Generator(id, substs, movablity) => {\n-                        AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n-                    }\n-                });\n-                Aggregate(kind, fields.fold_with(folder))\n+                let kind = kind.try_map_id(|kind| {\n+                    Ok(match kind {\n+                        AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)?),\n+                        AggregateKind::Tuple => AggregateKind::Tuple,\n+                        AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n+                            def,\n+                            v,\n+                            substs.fold_with(folder)?,\n+                            user_ty.fold_with(folder)?,\n+                            n,\n+                        ),\n+                        AggregateKind::Closure(id, substs) => {\n+                            AggregateKind::Closure(id, substs.fold_with(folder)?)\n+                        }\n+                        AggregateKind::Generator(id, substs, movablity) => {\n+                            AggregateKind::Generator(id, substs.fold_with(folder)?, movablity)\n+                        }\n+                    })\n+                })?;\n+                Aggregate(kind, fields.fold_with(folder)?)\n             }\n-            ShallowInitBox(op, ty) => ShallowInitBox(op.fold_with(folder), ty.fold_with(folder)),\n-        }\n+            ShallowInitBox(op, ty) => ShallowInitBox(op.fold_with(folder)?, ty.fold_with(folder)?),\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -265,12 +272,12 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        match self {\n-            Operand::Copy(place) => Operand::Copy(place.fold_with(folder)),\n-            Operand::Move(place) => Operand::Move(place.fold_with(folder)),\n-            Operand::Constant(c) => Operand::Constant(c.fold_with(folder)),\n-        }\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(match self {\n+            Operand::Copy(place) => Operand::Copy(place.fold_with(folder)?),\n+            Operand::Move(place) => Operand::Move(place.fold_with(folder)?),\n+            Operand::Constant(c) => Operand::Constant(c.fold_with(folder)?),\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -282,19 +289,19 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         use crate::mir::ProjectionElem::*;\n \n-        match self {\n+        Ok(match self {\n             Deref => Deref,\n-            Field(f, ty) => Field(f, ty.fold_with(folder)),\n-            Index(v) => Index(v.fold_with(folder)),\n+            Field(f, ty) => Field(f, ty.fold_with(folder)?),\n+            Index(v) => Index(v.fold_with(folder)?),\n             Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n             ConstantIndex { offset, min_length, from_end } => {\n                 ConstantIndex { offset, min_length, from_end }\n             }\n             Subslice { from, to, from_end } => Subslice { from, to, from_end },\n-        }\n+        })\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(\n@@ -312,39 +319,39 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        Constant {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(Constant {\n             span: self.span,\n-            user_ty: self.user_ty.fold_with(folder),\n-            literal: self.literal.fold_with(folder),\n-        }\n+            user_ty: self.user_ty.fold_with(folder)?,\n+            literal: self.literal.fold_with(folder)?,\n+        })\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         self.literal.visit_with(visitor)?;\n@@ -354,14 +361,14 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ConstantKind<'tcx> {\n     #[inline(always)]\n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_mir_const(self)\n     }\n \n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         match self {\n-            ConstantKind::Ty(c) => ConstantKind::Ty(c.fold_with(folder)),\n-            ConstantKind::Val(v, t) => ConstantKind::Val(v, t.fold_with(folder)),\n+            ConstantKind::Ty(c) => Ok(ConstantKind::Ty(c.fold_with(folder)?)),\n+            ConstantKind::Val(v, t) => Ok(ConstantKind::Val(v, t.fold_with(folder)?)),\n         }\n     }\n "}, {"sha": "25b460cf16d3c7f5cfddbb7775fc1e566a306ed0", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -9,7 +9,7 @@ pub(super) fn provide(providers: &mut ty::query::Providers) {\n fn erase_regions_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     // N.B., use `super_fold_with` here. If we used `fold_with`, it\n     // could invoke the `erase_regions_ty` query recursively.\n-    ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n+    ty.super_fold_with(&mut RegionEraserVisitor { tcx }).into_ok()\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -27,7 +27,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             return value;\n         }\n         debug!(\"erase_regions({:?})\", value);\n-        let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self });\n+        let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self }).into_ok();\n         debug!(\"erase_regions = {:?}\", value1);\n         value1\n     }\n@@ -42,19 +42,19 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.needs_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        if ty.needs_infer() { ty.super_fold_with(self) } else { Ok(self.tcx.erase_regions_ty(ty)) }\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> Result<ty::Binder<'tcx, T>, Self::Error>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         let u = self.tcx.anonymize_late_bound_regions(t);\n         u.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         // because late-bound regions affect subtyping, we can't\n         // erase the bound/free distinction, but we can replace\n         // all free regions with 'erased.\n@@ -64,12 +64,15 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n         // away. In codegen, they will always be erased to 'erased\n         // whenever a substitution occurs.\n         match *r {\n-            ty::ReLateBound(..) => r,\n-            _ => self.tcx.lifetimes.re_erased,\n+            ty::ReLateBound(..) => Ok(r),\n+            _ => Ok(self.tcx.lifetimes.re_erased),\n         }\n     }\n \n-    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        c: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         c.super_fold_with(self)\n     }\n }"}, {"sha": "31055c03a5d36c73e551ddbf76377ef6699f081d", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 79, "deletions": 54, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -46,8 +46,8 @@ use std::ops::ControlFlow;\n ///\n /// To implement this conveniently, use the derive macro located in `rustc_macros`.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self;\n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error>;\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         self.super_fold_with(folder)\n     }\n \n@@ -179,8 +179,8 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n }\n \n impl TypeFoldable<'tcx> for hir::Constness {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE\n@@ -193,32 +193,43 @@ impl TypeFoldable<'tcx> for hir::Constness {\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n pub trait TypeFolder<'tcx>: Sized {\n+    type Error = !;\n+\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T>\n+    fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         c.super_fold_with(self)\n     }\n \n-    fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+    fn fold_predicate(\n+        &mut self,\n+        p: ty::Predicate<'tcx>,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n         p.super_fold_with(self)\n     }\n \n-    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        c: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         bug!(\"most type folders should not be folding MIR datastructures: {:?}\", c)\n     }\n }\n@@ -290,19 +301,22 @@ where\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let t = ty.super_fold_with(self);\n-        (self.ty_op)(t)\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        let t = ty.super_fold_with(self)?;\n+        Ok((self.ty_op)(t))\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        let r = r.super_fold_with(self);\n-        (self.lt_op)(r)\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        let r = r.super_fold_with(self)?;\n+        Ok((self.lt_op)(r))\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        let ct = ct.super_fold_with(self);\n-        (self.ct_op)(ct)\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        let ct = ct.super_fold_with(self)?;\n+        Ok((self.ct_op)(ct))\n     }\n }\n \n@@ -322,7 +336,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n+        value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f)).into_ok()\n     }\n \n     /// Invoke `callback` on every region appearing free in `value`.\n@@ -470,24 +484,24 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(debruijn, _) if debruijn < self.current_index => {\n                 debug!(?self.current_index, \"skipped bound region\");\n                 *self.skipped_regions = true;\n-                r\n+                Ok(r)\n             }\n             _ => {\n                 debug!(?self.current_index, \"folding free region\");\n-                (self.fold_region_fn)(r, self.current_index)\n+                Ok((self.fold_region_fn)(r, self.current_index))\n             }\n         }\n     }\n@@ -528,30 +542,30 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n                 if let Some(fld_t) = self.fld_t.as_mut() {\n                     let ty = fld_t(bound_ty);\n-                    return ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32());\n+                    return Ok(ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32()));\n                 }\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => {\n                 return t.super_fold_with(self);\n             }\n             _ => {}\n         }\n-        t\n+        Ok(t)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n                 if let Some(fld_r) = self.fld_r.as_mut() {\n@@ -562,33 +576,36 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n                         // debruijn index. Then we adjust it to the\n                         // correct depth.\n                         assert_eq!(debruijn1, ty::INNERMOST);\n-                        self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n+                        Ok(self.tcx.mk_region(ty::ReLateBound(debruijn, br)))\n                     } else {\n-                        region\n+                        Ok(region)\n                     };\n                 }\n             }\n             _ => {}\n         }\n-        r\n+        Ok(r)\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         match *ct {\n             ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty }\n                 if debruijn == self.current_index =>\n             {\n                 if let Some(fld_c) = self.fld_c.as_mut() {\n                     let ct = fld_c(bound_const, ty);\n-                    return ty::fold::shift_vars(self.tcx, &ct, self.current_index.as_u32());\n+                    return Ok(ty::fold::shift_vars(self.tcx, &ct, self.current_index.as_u32()));\n                 }\n             }\n             _ if ct.has_vars_bound_at_or_above(self.current_index) => {\n                 return ct.super_fold_with(self);\n             }\n             _ => {}\n         }\n-        ct\n+        Ok(ct)\n     }\n }\n \n@@ -621,7 +638,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             value\n         } else {\n             let mut replacer = BoundVarReplacer::new(self, Some(&mut real_fld_r), None, None);\n-            value.fold_with(&mut replacer)\n+            value.fold_with(&mut replacer).into_ok()\n         };\n         (value, region_map)\n     }\n@@ -647,7 +664,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         } else {\n             let mut replacer =\n                 BoundVarReplacer::new(self, Some(&mut fld_r), Some(&mut fld_t), Some(&mut fld_c));\n-            value.fold_with(&mut replacer)\n+            value.fold_with(&mut replacer).into_ok()\n         }\n     }\n \n@@ -938,50 +955,55 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(debruijn, br) => {\n                 if self.amount == 0 || debruijn < self.current_index {\n-                    r\n+                    Ok(r)\n                 } else {\n                     let debruijn = debruijn.shifted_in(self.amount);\n                     let shifted = ty::ReLateBound(debruijn, br);\n-                    self.tcx.mk_region(shifted)\n+                    Ok(self.tcx.mk_region(shifted))\n                 }\n             }\n-            _ => r,\n+            _ => Ok(r),\n         }\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *ty.kind() {\n             ty::Bound(debruijn, bound_ty) => {\n                 if self.amount == 0 || debruijn < self.current_index {\n-                    ty\n+                    Ok(ty)\n                 } else {\n                     let debruijn = debruijn.shifted_in(self.amount);\n-                    self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n+                    Ok(self.tcx.mk_ty(ty::Bound(debruijn, bound_ty)))\n                 }\n             }\n \n             _ => ty.super_fold_with(self),\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if let ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty } = *ct {\n             if self.amount == 0 || debruijn < self.current_index {\n-                ct\n+                Ok(ct)\n             } else {\n                 let debruijn = debruijn.shifted_in(self.amount);\n-                self.tcx.mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty })\n+                Ok(self\n+                    .tcx\n+                    .mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty }))\n             }\n         } else {\n             ct.super_fold_with(self)\n@@ -1008,7 +1030,7 @@ where\n {\n     debug!(\"shift_vars(value={:?}, amount={})\", value, amount);\n \n-    value.fold_with(&mut Shifter::new(tcx, amount))\n+    value.fold_with(&mut Shifter::new(tcx, amount)).into_ok()\n }\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n@@ -1271,7 +1293,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// FIXME(@lcnr): explain this function a bit more\n     pub fn expose_default_const_substs<T: TypeFoldable<'tcx>>(self, v: T) -> T {\n-        v.fold_with(&mut ExposeDefaultConstSubstsFolder { tcx: self })\n+        v.fold_with(&mut ExposeDefaultConstSubstsFolder { tcx: self }).into_ok()\n     }\n }\n \n@@ -1284,19 +1306,22 @@ impl<'tcx> TypeFolder<'tcx> for ExposeDefaultConstSubstsFolder<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if ty.flags().intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n             ty.super_fold_with(self)\n         } else {\n-            ty\n+            Ok(ty)\n         }\n     }\n \n-    fn fold_predicate(&mut self, pred: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+    fn fold_predicate(\n+        &mut self,\n+        pred: ty::Predicate<'tcx>,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n         if pred.inner.flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n             pred.super_fold_with(self)\n         } else {\n-            pred\n+            Ok(pred)\n         }\n     }\n }"}, {"sha": "15931b8d2c86a85d0129437e207e9255cf26b0e9", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -622,7 +622,7 @@ fn polymorphize<'tcx>(\n             self.tcx\n         }\n \n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n             debug!(\"fold_ty: ty={:?}\", ty);\n             match ty.kind {\n                 ty::Closure(def_id, substs) => {\n@@ -631,23 +631,23 @@ fn polymorphize<'tcx>(\n                         ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n                         substs,\n                     );\n-                    if substs == polymorphized_substs {\n+                    Ok(if substs == polymorphized_substs {\n                         ty\n                     } else {\n                         self.tcx.mk_closure(def_id, polymorphized_substs)\n-                    }\n+                    })\n                 }\n                 ty::Generator(def_id, substs, movability) => {\n                     let polymorphized_substs = polymorphize(\n                         self.tcx,\n                         ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n                         substs,\n                     );\n-                    if substs == polymorphized_substs {\n+                    Ok(if substs == polymorphized_substs {\n                         ty\n                     } else {\n                         self.tcx.mk_generator(def_id, polymorphized_substs, movability)\n-                    }\n+                    })\n                 }\n                 _ => ty.super_fold_with(self),\n             }\n@@ -669,7 +669,7 @@ fn polymorphize<'tcx>(\n                     // ..and polymorphize any closures/generators captured as upvars.\n                     let upvars_ty = upvars_ty.unwrap();\n                     let polymorphized_upvars_ty = upvars_ty.fold_with(\n-                        &mut PolymorphizationFolder { tcx });\n+                        &mut PolymorphizationFolder { tcx }).into_ok();\n                     debug!(\"polymorphize: polymorphized_upvars_ty={:?}\", polymorphized_upvars_ty);\n                     ty::GenericArg::from(polymorphized_upvars_ty)\n                 },"}, {"sha": "2d6926703726c63e146b1d93f3555cdbe35ffd55", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -1260,8 +1260,11 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ParamEnv<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ParamEnv<'tcx> {\n-    fn super_fold_with<F: ty::fold::TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        ParamEnv::new(self.caller_bounds().fold_with(folder), self.reveal().fold_with(folder))\n+    fn super_fold_with<F: ty::fold::TypeFolder<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        Ok(ParamEnv::new(self.caller_bounds().fold_with(folder)?, self.reveal().fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {"}, {"sha": "e6f67adae93daadd92bbce9674bddfe3f5fc844a", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -35,7 +35,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !value.has_projections() {\n             value\n         } else {\n-            value.fold_with(&mut NormalizeAfterErasingRegionsFolder { tcx: self, param_env })\n+            value\n+                .fold_with(&mut NormalizeAfterErasingRegionsFolder { tcx: self, param_env })\n+                .into_ok()\n         }\n     }\n \n@@ -103,18 +105,24 @@ impl TypeFolder<'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.normalize_generic_arg_after_erasing_regions(ty.into()).expect_ty()\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        Ok(self.normalize_generic_arg_after_erasing_regions(ty.into()).expect_ty())\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        self.normalize_generic_arg_after_erasing_regions(c.into()).expect_const()\n+    fn fold_const(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        Ok(self.normalize_generic_arg_after_erasing_regions(c.into()).expect_const())\n     }\n \n     #[inline]\n-    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        c: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         // FIXME: This *probably* needs canonicalization too!\n         let arg = self.param_env.and(c);\n-        self.tcx.normalize_mir_const_after_erasing_regions(arg)\n+        Ok(self.tcx.normalize_mir_const_after_erasing_regions(arg))\n     }\n }"}, {"sha": "f454b95862bab57b319630ac74d2115c083f3abb", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -2016,24 +2016,24 @@ impl<'a, 'tcx> ty::TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             _ if t.has_vars_bound_at_or_above(self.current_index) || t.has_placeholders() => {\n                 return t.super_fold_with(self);\n             }\n             _ => {}\n         }\n-        t\n+        Ok(t)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         let name = &mut self.name;\n         let region = match *r {\n             ty::ReLateBound(_, br) => self.region_map.entry(br).or_insert_with(|| name(br)),\n@@ -2049,13 +2049,13 @@ impl<'a, 'tcx> ty::TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n                     }\n                 }\n             }\n-            _ => return r,\n+            _ => return Ok(r),\n         };\n         if let ty::ReLateBound(debruijn1, br) = *region {\n             assert_eq!(debruijn1, ty::INNERMOST);\n-            self.tcx.mk_region(ty::ReLateBound(self.current_index, br))\n+            Ok(self.tcx.mk_region(ty::ReLateBound(self.current_index, br)))\n         } else {\n-            region\n+            Ok(region)\n         }\n     }\n }\n@@ -2193,7 +2193,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n                 name: &mut name,\n                 region_map: BTreeMap::new(),\n             };\n-            let new_value = value.clone().skip_binder().fold_with(&mut folder);\n+            let new_value = value.clone().skip_binder().fold_with(&mut folder).into_ok();\n             let region_map = folder.region_map;\n             start_or_continue(&mut self, \"\", \"> \");\n             (new_value, region_map)"}, {"sha": "ee6eed0f39b2d33dfe044c3bf3bdcf1b8a866d3c", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -669,8 +669,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n \n /// AdtDefs are basically the same as a DefId.\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -679,8 +679,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> (T, U) {\n-        (self.0.fold_with(folder), self.1.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<(T, U), F::Error> {\n+        Ok((self.0.fold_with(folder)?, self.1.fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -692,8 +692,8 @@ impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for\n impl<'tcx, A: TypeFoldable<'tcx>, B: TypeFoldable<'tcx>, C: TypeFoldable<'tcx>> TypeFoldable<'tcx>\n     for (A, B, C)\n {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> (A, B, C) {\n-        (self.0.fold_with(folder), self.1.fold_with(folder), self.2.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<(A, B, C), F::Error> {\n+        Ok((self.0.fold_with(folder)?, self.1.fold_with(folder)?, self.2.fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -718,9 +718,9 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         // FIXME: Reuse the `Rc` here.\n-        Rc::new((*self).clone().fold_with(folder))\n+        Ok(Rc::new((*self).clone().fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -729,9 +729,9 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         // FIXME: Reuse the `Arc` here.\n-        Arc::new((*self).clone().fold_with(folder))\n+        Ok(Arc::new((*self).clone().fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -740,8 +740,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_id(|value| value.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|value| value.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -750,8 +750,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_id(|t| t.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|t| t.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -760,8 +760,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_id(|t| t.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|t| t.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -770,11 +770,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<'tcx, T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_bound(|ty| ty.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_bound(|ty| ty.fold_with(folder))\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_binder(self)\n     }\n \n@@ -788,7 +788,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<'tcx, T> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_poly_existential_predicates(v))\n     }\n \n@@ -798,7 +798,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::Existentia\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_type_list(v))\n     }\n \n@@ -808,7 +808,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_projs(v))\n     }\n \n@@ -818,24 +818,24 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         use crate::ty::InstanceDef::*;\n-        Self {\n-            substs: self.substs.fold_with(folder),\n+        Ok(Self {\n+            substs: self.substs.fold_with(folder)?,\n             def: match self.def {\n-                Item(def) => Item(def.fold_with(folder)),\n-                VtableShim(did) => VtableShim(did.fold_with(folder)),\n-                ReifyShim(did) => ReifyShim(did.fold_with(folder)),\n-                Intrinsic(did) => Intrinsic(did.fold_with(folder)),\n-                FnPtrShim(did, ty) => FnPtrShim(did.fold_with(folder), ty.fold_with(folder)),\n-                Virtual(did, i) => Virtual(did.fold_with(folder), i),\n+                Item(def) => Item(def.fold_with(folder)?),\n+                VtableShim(did) => VtableShim(did.fold_with(folder)?),\n+                ReifyShim(did) => ReifyShim(did.fold_with(folder)?),\n+                Intrinsic(did) => Intrinsic(did.fold_with(folder)?),\n+                FnPtrShim(did, ty) => FnPtrShim(did.fold_with(folder)?, ty.fold_with(folder)?),\n+                Virtual(did, i) => Virtual(did.fold_with(folder)?, i),\n                 ClosureOnceShim { call_once, track_caller } => {\n-                    ClosureOnceShim { call_once: call_once.fold_with(folder), track_caller }\n+                    ClosureOnceShim { call_once: call_once.fold_with(folder)?, track_caller }\n                 }\n-                DropGlue(did, ty) => DropGlue(did.fold_with(folder), ty.fold_with(folder)),\n-                CloneShim(did, ty) => CloneShim(did.fold_with(folder), ty.fold_with(folder)),\n+                DropGlue(did, ty) => DropGlue(did.fold_with(folder)?, ty.fold_with(folder)?),\n+                CloneShim(did, ty) => CloneShim(did.fold_with(folder)?, ty.fold_with(folder)?),\n             },\n-        }\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -860,8 +860,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        Self { instance: self.instance.fold_with(folder), promoted: self.promoted }\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(Self { instance: self.instance.fold_with(folder)?, promoted: self.promoted })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -870,26 +870,26 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         let kind = match *self.kind() {\n-            ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)),\n-            ty::Array(typ, sz) => ty::Array(typ.fold_with(folder), sz.fold_with(folder)),\n-            ty::Slice(typ) => ty::Slice(typ.fold_with(folder)),\n-            ty::Adt(tid, substs) => ty::Adt(tid, substs.fold_with(folder)),\n+            ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)?),\n+            ty::Array(typ, sz) => ty::Array(typ.fold_with(folder)?, sz.fold_with(folder)?),\n+            ty::Slice(typ) => ty::Slice(typ.fold_with(folder)?),\n+            ty::Adt(tid, substs) => ty::Adt(tid, substs.fold_with(folder)?),\n             ty::Dynamic(trait_ty, region) => {\n-                ty::Dynamic(trait_ty.fold_with(folder), region.fold_with(folder))\n+                ty::Dynamic(trait_ty.fold_with(folder)?, region.fold_with(folder)?)\n             }\n-            ty::Tuple(ts) => ty::Tuple(ts.fold_with(folder)),\n-            ty::FnDef(def_id, substs) => ty::FnDef(def_id, substs.fold_with(folder)),\n-            ty::FnPtr(f) => ty::FnPtr(f.fold_with(folder)),\n-            ty::Ref(r, ty, mutbl) => ty::Ref(r.fold_with(folder), ty.fold_with(folder), mutbl),\n+            ty::Tuple(ts) => ty::Tuple(ts.fold_with(folder)?),\n+            ty::FnDef(def_id, substs) => ty::FnDef(def_id, substs.fold_with(folder)?),\n+            ty::FnPtr(f) => ty::FnPtr(f.fold_with(folder)?),\n+            ty::Ref(r, ty, mutbl) => ty::Ref(r.fold_with(folder)?, ty.fold_with(folder)?, mutbl),\n             ty::Generator(did, substs, movability) => {\n-                ty::Generator(did, substs.fold_with(folder), movability)\n+                ty::Generator(did, substs.fold_with(folder)?, movability)\n             }\n-            ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)),\n-            ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)),\n-            ty::Projection(data) => ty::Projection(data.fold_with(folder)),\n-            ty::Opaque(did, substs) => ty::Opaque(did, substs.fold_with(folder)),\n+            ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)?),\n+            ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)?),\n+            ty::Projection(data) => ty::Projection(data.fold_with(folder)?),\n+            ty::Opaque(did, substs) => ty::Opaque(did, substs.fold_with(folder)?),\n \n             ty::Bool\n             | ty::Char\n@@ -903,13 +903,13 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             | ty::Bound(..)\n             | ty::Placeholder(..)\n             | ty::Never\n-            | ty::Foreign(..) => return self,\n+            | ty::Foreign(..) => return Ok(self),\n         };\n \n-        if *self.kind() == kind { self } else { folder.tcx().mk_ty(kind) }\n+        Ok(if *self.kind() == kind { self } else { folder.tcx().mk_ty(kind) })\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_ty(self)\n     }\n \n@@ -961,11 +961,11 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_region(self)\n     }\n \n@@ -979,13 +979,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_predicate(self)\n     }\n \n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        let new = self.inner.kind.fold_with(folder);\n-        folder.tcx().reuse_or_mk_predicate(self, new)\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        let new = self.inner.kind.fold_with(folder)?;\n+        Ok(folder.tcx().reuse_or_mk_predicate(self, new))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1006,7 +1006,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_predicates(v))\n     }\n \n@@ -1016,8 +1016,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_id(|x| x.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|x| x.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1026,17 +1026,17 @@ impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T>\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        let ty = self.ty.fold_with(folder);\n-        let val = self.val.fold_with(folder);\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        let ty = self.ty.fold_with(folder)?;\n+        let val = self.val.fold_with(folder)?;\n         if ty != self.ty || val != self.val {\n-            folder.tcx().mk_const(ty::Const { ty, val })\n+            Ok(folder.tcx().mk_const(ty::Const { ty, val }))\n         } else {\n-            self\n+            Ok(self)\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_const(self)\n     }\n \n@@ -1051,16 +1051,16 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        match self {\n-            ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.fold_with(folder)),\n-            ty::ConstKind::Param(p) => ty::ConstKind::Param(p.fold_with(folder)),\n-            ty::ConstKind::Unevaluated(uv) => ty::ConstKind::Unevaluated(uv.fold_with(folder)),\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(match self {\n+            ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.fold_with(folder)?),\n+            ty::ConstKind::Param(p) => ty::ConstKind::Param(p.fold_with(folder)?),\n+            ty::ConstKind::Unevaluated(uv) => ty::ConstKind::Unevaluated(uv.fold_with(folder)?),\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(..)\n             | ty::ConstKind::Error(_) => self,\n-        }\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1077,8 +1077,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1087,12 +1087,12 @@ impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        ty::Unevaluated {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(ty::Unevaluated {\n             def: self.def,\n-            substs_: Some(self.substs(folder.tcx()).fold_with(folder)),\n+            substs_: Some(self.substs(folder.tcx()).fold_with(folder)?),\n             promoted: self.promoted,\n-        }\n+        })\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1112,12 +1112,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx, ()> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        ty::Unevaluated {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(ty::Unevaluated {\n             def: self.def,\n-            substs_: Some(self.substs(folder.tcx()).fold_with(folder)),\n+            substs_: Some(self.substs(folder.tcx()).fold_with(folder)?),\n             promoted: self.promoted,\n-        }\n+        })\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {"}, {"sha": "fcbf15b3bca47adbbdf71c79dd693cf89f75b0c0", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -1101,6 +1101,18 @@ impl<'tcx, T> Binder<'tcx, T> {\n         Binder(value, self.1)\n     }\n \n+    pub fn try_map_bound<F, U: TypeFoldable<'tcx>, E>(self, f: F) -> Result<Binder<'tcx, U>, E>\n+    where\n+        F: FnOnce(T) -> Result<U, E>,\n+    {\n+        let value = f(self.0)?;\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(self.1);\n+            value.visit_with(&mut validator);\n+        }\n+        Ok(Binder(value, self.1))\n+    }\n+\n     /// Wraps a `value` in a binder, using the same bound variables as the\n     /// current `Binder`. This should not be used if the new value *changes*\n     /// the bound variables. Note: the (old or new) value itself does not"}, {"sha": "ffa495ce4803fba8217d5a0ddd86eb0dfb227ab6", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -153,11 +153,11 @@ impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         match self.unpack() {\n-            GenericArgKind::Lifetime(lt) => lt.fold_with(folder).into(),\n-            GenericArgKind::Type(ty) => ty.fold_with(folder).into(),\n-            GenericArgKind::Const(ct) => ct.fold_with(folder).into(),\n+            GenericArgKind::Lifetime(lt) => lt.fold_with(folder).map(Into::into),\n+            GenericArgKind::Type(ty) => ty.fold_with(folder).map(Into::into),\n+            GenericArgKind::Const(ct) => ct.fold_with(folder).map(Into::into),\n         }\n     }\n \n@@ -372,7 +372,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n         // The match arms are in order of frequency. The 1, 2, and 0 cases are\n@@ -381,22 +381,27 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n         // calling `intern_substs`.\n         match self.len() {\n             1 => {\n-                let param0 = self[0].fold_with(folder);\n-                if param0 == self[0] { self } else { folder.tcx().intern_substs(&[param0]) }\n+                let param0 = self[0].fold_with(folder)?;\n+                if param0 == self[0] { Ok(self) } else { Ok(folder.tcx().intern_substs(&[param0])) }\n             }\n             2 => {\n-                let param0 = self[0].fold_with(folder);\n-                let param1 = self[1].fold_with(folder);\n+                let param0 = self[0].fold_with(folder)?;\n+                let param1 = self[1].fold_with(folder)?;\n                 if param0 == self[0] && param1 == self[1] {\n-                    self\n+                    Ok(self)\n                 } else {\n-                    folder.tcx().intern_substs(&[param0, param1])\n+                    Ok(folder.tcx().intern_substs(&[param0, param1]))\n                 }\n             }\n-            0 => self,\n+            0 => Ok(self),\n             _ => {\n-                let params: SmallVec<[_; 8]> = self.iter().map(|k| k.fold_with(folder)).collect();\n-                if params[..] == self[..] { self } else { folder.tcx().intern_substs(&params) }\n+                let params: SmallVec<[_; 8]> =\n+                    self.iter().map(|k| k.fold_with(folder)).collect::<Result<_, _>>()?;\n+                if params[..] == self[..] {\n+                    Ok(self)\n+                } else {\n+                    Ok(folder.tcx().intern_substs(&params))\n+                }\n             }\n         }\n     }\n@@ -434,7 +439,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n         span: Option<Span>,\n     ) -> T {\n         let mut folder = SubstFolder { tcx, substs, span, binders_passed: 0 };\n-        self.fold_with(&mut folder)\n+        self.fold_with(&mut folder).into_ok()\n     }\n }\n \n@@ -460,14 +465,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.binders_passed += 1;\n-        let t = t.super_fold_with(self);\n+        let t = t.super_fold_with(self)?;\n         self.binders_passed -= 1;\n-        t\n+        Ok(t)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         // Note: This routine only handles regions that are bound on\n         // type declarations and other outer declarations, not those\n         // bound in *fn types*. Region substitution of the bound\n@@ -477,7 +482,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n             ty::ReEarlyBound(data) => {\n                 let rk = self.substs.get(data.index as usize).map(|k| k.unpack());\n                 match rk {\n-                    Some(GenericArgKind::Lifetime(lt)) => self.shift_region_through_binders(lt),\n+                    Some(GenericArgKind::Lifetime(lt)) => Ok(self.shift_region_through_binders(lt)),\n                     _ => {\n                         let span = self.span.unwrap_or(DUMMY_SP);\n                         let msg = format!(\n@@ -489,31 +494,37 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                     }\n                 }\n             }\n-            _ => r,\n+            _ => Ok(r),\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !t.potentially_needs_subst() {\n-            return t;\n+            return Ok(t);\n         }\n \n         match *t.kind() {\n-            ty::Param(p) => self.ty_for_param(p, t),\n+            ty::Param(p) => Ok(self.ty_for_param(p, t)),\n             _ => t.super_fold_with(self),\n         }\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if let ty::ConstKind::Param(p) = c.val {\n-            self.const_for_param(p, c)\n+            Ok(self.const_for_param(p, c))\n         } else {\n             c.super_fold_with(self)\n         }\n     }\n \n     #[inline]\n-    fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        c: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         c.super_fold_with(self)\n     }\n }"}, {"sha": "5137f9650633a38dcdfc09009a359ee1fcdc98c7", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -574,14 +574,14 @@ impl<'tcx> OpaqueTypeExpander<'tcx> {\n         if self.found_any_recursion {\n             return None;\n         }\n-        let substs = substs.fold_with(self);\n+        let substs = substs.fold_with(self).into_ok();\n         if !self.check_recursion || self.seen_opaque_tys.insert(def_id) {\n             let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n                 Some(expanded_ty) => expanded_ty,\n                 None => {\n                     let generic_ty = self.tcx.type_of(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx, substs);\n-                    let expanded_ty = self.fold_ty(concrete_ty);\n+                    let expanded_ty = self.fold_ty(concrete_ty).into_ok();\n                     self.expanded_cache.insert((def_id, substs), expanded_ty);\n                     expanded_ty\n                 }\n@@ -605,13 +605,13 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if let ty::Opaque(def_id, substs) = t.kind {\n-            self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n+            Ok(self.expand_opaque_ty(def_id, substs).unwrap_or(t))\n         } else if t.has_opaque_types() {\n             t.super_fold_with(self)\n         } else {\n-            t\n+            Ok(t)\n         }\n     }\n }\n@@ -1046,25 +1046,31 @@ pub fn fold_list<'tcx, F, T>(\n     list: &'tcx ty::List<T>,\n     folder: &mut F,\n     intern: impl FnOnce(TyCtxt<'tcx>, &[T]) -> &'tcx ty::List<T>,\n-) -> &'tcx ty::List<T>\n+) -> Result<&'tcx ty::List<T>, F::Error>\n where\n     F: TypeFolder<'tcx>,\n     T: TypeFoldable<'tcx> + PartialEq + Copy,\n {\n     let mut iter = list.iter();\n     // Look for the first element that changed\n-    if let Some((i, new_t)) = iter.by_ref().enumerate().find_map(|(i, t)| {\n-        let new_t = t.fold_with(folder);\n-        if new_t == t { None } else { Some((i, new_t)) }\n+    match iter.by_ref().enumerate().find_map(|(i, t)| match t.fold_with(folder) {\n+        Ok(new_t) if new_t == t => None,\n+        new_t => Some((i, new_t)),\n     }) {\n-        // An element changed, prepare to intern the resulting list\n-        let mut new_list = SmallVec::<[_; 8]>::with_capacity(list.len());\n-        new_list.extend_from_slice(&list[..i]);\n-        new_list.push(new_t);\n-        new_list.extend(iter.map(|t| t.fold_with(folder)));\n-        intern(folder.tcx(), &new_list)\n-    } else {\n-        list\n+        Some((i, Ok(new_t))) => {\n+            // An element changed, prepare to intern the resulting list\n+            let mut new_list = SmallVec::<[_; 8]>::with_capacity(list.len());\n+            new_list.extend_from_slice(&list[..i]);\n+            new_list.push(new_t);\n+            for t in iter {\n+                new_list.push(t.fold_with(folder)?)\n+            }\n+            Ok(intern(folder.tcx(), &new_list))\n+        }\n+        Some((_, Err(err))) => {\n+            return Err(err);\n+        }\n+        None => Ok(list),\n     }\n }\n \n@@ -1086,7 +1092,7 @@ pub fn normalize_opaque_types(\n         check_recursion: false,\n         tcx,\n     };\n-    val.fold_with(&mut visitor)\n+    val.fold_with(&mut visitor).into_ok()\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "ecc352c1a49b5bc5f1de2d98b30ed34212a9ac4b", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -22,6 +22,7 @@\n #![feature(never_type)]\n #![feature(crate_visibility_modifier)]\n #![feature(control_flow_enum)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "9052dff0aaa837514b2eadfe507eb6184c079b4e", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -65,14 +65,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper::new(\n-            self.tcx,\n-            self.is_tainted_by_errors(),\n-            def_id,\n-            map,\n-            instantiated_ty,\n-            span,\n-        ));\n+        let definition_ty = instantiated_ty\n+            .fold_with(&mut ReverseMapper::new(\n+                self.tcx,\n+                self.is_tainted_by_errors(),\n+                def_id,\n+                map,\n+                instantiated_ty,\n+                span,\n+            ))\n+            .into_ok();\n         debug!(?definition_ty);\n \n         definition_ty\n@@ -123,14 +125,14 @@ impl ReverseMapper<'tcx> {\n     ) -> GenericArg<'tcx> {\n         assert!(!self.map_missing_regions_to_empty);\n         self.map_missing_regions_to_empty = true;\n-        let kind = kind.fold_with(self);\n+        let kind = kind.fold_with(self).into_ok();\n         self.map_missing_regions_to_empty = false;\n         kind\n     }\n \n     fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n         assert!(!self.map_missing_regions_to_empty);\n-        kind.fold_with(self)\n+        kind.fold_with(self).into_ok()\n     }\n }\n \n@@ -140,17 +142,17 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match r {\n             // Ignore bound regions and `'static` regions that appear in the\n             // type, we only need to remap regions that reference lifetimes\n             // from the function declaraion.\n             // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) | ty::ReStatic => return r,\n+            ty::ReLateBound(..) | ty::ReStatic => return Ok(r),\n \n             // If regions have been erased (by writeback), don't try to unerase\n             // them.\n-            ty::ReErased => return r,\n+            ty::ReErased => return Ok(r),\n \n             // The regions that we expect from borrow checking.\n             ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n@@ -165,10 +167,10 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n         let generics = self.tcx().generics_of(self.opaque_type_def_id);\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(GenericArgKind::Lifetime(r1)) => r1,\n+            Some(GenericArgKind::Lifetime(r1)) => Ok(r1),\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n             None if self.map_missing_regions_to_empty || self.tainted_by_errors => {\n-                self.tcx.lifetimes.re_root_empty\n+                Ok(self.tcx.lifetimes.re_root_empty)\n             }\n             None if generics.parent.is_some() => {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n@@ -180,7 +182,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n                 }\n-                self.tcx.lifetimes.re_root_empty\n+                Ok(self.tcx.lifetimes.re_root_empty)\n             }\n             None => {\n                 self.tcx\n@@ -196,12 +198,12 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n \n-                self.tcx().lifetimes.re_static\n+                Ok(self.tcx().lifetimes.re_static)\n             }\n         }\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *ty.kind() {\n             ty::Closure(def_id, substs) => {\n                 // I am a horrible monster and I pray for death. When\n@@ -239,7 +241,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     }\n                 }));\n \n-                self.tcx.mk_closure(def_id, substs)\n+                Ok(self.tcx.mk_closure(def_id, substs))\n             }\n \n             ty::Generator(def_id, substs, movability) => {\n@@ -254,15 +256,15 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     }\n                 }));\n \n-                self.tcx.mk_generator(def_id, substs, movability)\n+                Ok(self.tcx.mk_generator(def_id, substs, movability))\n             }\n \n             ty::Param(param) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ty.into()).map(|k| k.unpack()) {\n                     // Found it in the substitution list; replace with the parameter from the\n                     // opaque type.\n-                    Some(GenericArgKind::Type(t1)) => t1,\n+                    Some(GenericArgKind::Type(t1)) => Ok(t1),\n                     Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n                     None => {\n                         debug!(?param, ?self.map);\n@@ -278,7 +280,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                             )\n                             .emit();\n \n-                        self.tcx().ty_error()\n+                        Ok(self.tcx().ty_error())\n                     }\n                 }\n             }\n@@ -287,10 +289,13 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         trace!(\"checking const {:?}\", ct);\n         // Find a const parameter\n-        match ct.val {\n+        Ok(match ct.val {\n             ty::ConstKind::Param(..) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ct.into()).map(|k| k.unpack()) {\n@@ -317,7 +322,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             }\n \n             _ => ct,\n-        }\n+        })\n     }\n }\n "}, {"sha": "7af32b2f3b17462867835e27194859303f7aa1f0", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -860,11 +860,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        (match r {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        Ok((match r {\n             ty::ReVar(vid) => self.vid_to_region.get(vid).cloned(),\n             _ => None,\n         })\n-        .unwrap_or_else(|| r.super_fold_with(self))\n+        .unwrap_or_else(|| r.super_fold_with(self).into_ok()))\n     }\n }"}, {"sha": "866bcde1bfd4f11a4f1c76369cba0f4e779ad2a2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -1898,15 +1898,15 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.infcx.tcx\n             }\n \n-            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n                 if let ty::Param(ty::ParamTy { name, .. }) = *ty.kind() {\n                     let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(|| {\n+                    Ok(self.var_map.entry(ty).or_insert_with(|| {\n                         infcx.next_ty_var(TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n                             span: DUMMY_SP,\n                         })\n-                    })\n+                    }))\n                 } else {\n                     ty.super_fold_with(self)\n                 }\n@@ -1916,8 +1916,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         self.probe(|_| {\n             let mut selcx = SelectionContext::new(self);\n \n-            let cleaned_pred =\n-                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n+            let cleaned_pred = pred\n+                .fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() })\n+                .into_ok();\n \n             let cleaned_pred = super::project::normalize(\n                 &mut selcx,"}, {"sha": "0911b2c529ab25b00bc520c58cf4f1fdad1c4864", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 63, "deletions": 50, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -339,7 +339,7 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         if !needs_normalization(&value, self.param_env.reveal()) {\n             value\n         } else {\n-            value.fold_with(self)\n+            value.fold_with(self).into_ok()\n         }\n     }\n }\n@@ -352,16 +352,16 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.universes.push(None);\n         let t = t.super_fold_with(self);\n         self.universes.pop();\n         t\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !needs_normalization(&ty, self.param_env.reveal()) {\n-            return ty;\n+            return Ok(ty);\n         }\n \n         // We try to be a little clever here as a performance optimization in\n@@ -387,14 +387,14 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         // replace bound vars if the current type is a `Projection` and we need\n         // to make sure we don't forget to fold the substs regardless.\n \n-        match *ty.kind() {\n+        Ok(match *ty.kind() {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n             ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {\n-                    Reveal::UserFacing => ty.super_fold_with(self),\n+                    Reveal::UserFacing => ty.super_fold_with(self)?,\n \n                     Reveal::All => {\n                         let recursion_limit = self.tcx().recursion_limit();\n@@ -408,11 +408,11 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                             self.selcx.infcx().report_overflow_error(&obligation, true);\n                         }\n \n-                        let substs = substs.super_fold_with(self);\n+                        let substs = substs.super_fold_with(self)?;\n                         let generic_ty = self.tcx().type_of(def_id);\n                         let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                         self.depth += 1;\n-                        let folded_ty = self.fold_ty(concrete_ty);\n+                        let folded_ty = self.fold_ty(concrete_ty)?;\n                         self.depth -= 1;\n                         folded_ty\n                     }\n@@ -426,7 +426,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 // register an obligation to *later* project, since we know\n                 // there won't be bound vars there.\n \n-                let data = data.super_fold_with(self);\n+                let data = data.super_fold_with(self)?;\n                 let normalized_ty = normalize_projection_type(\n                     self.selcx,\n                     self.param_env,\n@@ -461,7 +461,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 let infcx = self.selcx.infcx();\n                 let (data, mapped_regions, mapped_types, mapped_consts) =\n                     BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n-                let data = data.super_fold_with(self);\n+                let data = data.super_fold_with(self)?;\n                 let normalized_ty = opt_normalize_projection_type(\n                     self.selcx,\n                     self.param_env,\n@@ -473,16 +473,18 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 .ok()\n                 .flatten()\n                 .map(|normalized_ty| {\n-                    PlaceholderReplacer::replace_placeholders(\n-                        infcx,\n-                        mapped_regions,\n-                        mapped_types,\n-                        mapped_consts,\n-                        &self.universes,\n-                        normalized_ty,\n-                    )\n+                    Ok({\n+                        PlaceholderReplacer::replace_placeholders(\n+                            infcx,\n+                            mapped_regions,\n+                            mapped_types,\n+                            mapped_consts,\n+                            &self.universes,\n+                            normalized_ty,\n+                        )\n+                    })\n                 })\n-                .unwrap_or_else(|| ty.super_fold_with(self));\n+                .unwrap_or_else(|| ty.super_fold_with(self))?;\n \n                 debug!(\n                     ?self.depth,\n@@ -494,16 +496,19 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 normalized_ty\n             }\n \n-            _ => ty.super_fold_with(self),\n-        }\n+            _ => ty.super_fold_with(self)?,\n+        })\n     }\n \n-    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        constant: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if self.selcx.tcx().lazy_normalization() {\n-            constant\n+            Ok(constant)\n         } else {\n-            let constant = constant.super_fold_with(self);\n-            constant.eval(self.selcx.tcx(), self.param_env)\n+            let constant = constant.super_fold_with(self)?;\n+            Ok(constant.eval(self.selcx.tcx(), self.param_env))\n         }\n     }\n }\n@@ -550,7 +555,7 @@ impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n             universe_indices,\n         };\n \n-        let value = value.super_fold_with(&mut replacer);\n+        let value = value.super_fold_with(&mut replacer).into_ok();\n \n         (value, replacer.mapped_regions, replacer.mapped_types, replacer.mapped_consts)\n     }\n@@ -577,14 +582,14 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n             ty::ReLateBound(debruijn, _)\n                 if debruijn.as_usize() + 1\n@@ -596,13 +601,13 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderRegion { universe, name: br.kind };\n                 self.mapped_regions.insert(p, br);\n-                self.infcx.tcx.mk_region(ty::RePlaceholder(p))\n+                Ok(self.infcx.tcx.mk_region(ty::RePlaceholder(p)))\n             }\n-            _ => r,\n+            _ => Ok(r),\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             ty::Bound(debruijn, _)\n                 if debruijn.as_usize() + 1\n@@ -614,14 +619,17 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderType { universe, name: bound_ty.var };\n                 self.mapped_types.insert(p, bound_ty);\n-                self.infcx.tcx.mk_ty(ty::Placeholder(p))\n+                Ok(self.infcx.tcx.mk_ty(ty::Placeholder(p)))\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),\n-            _ => t,\n+            _ => Ok(t),\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         match *ct {\n             ty::Const { val: ty::ConstKind::Bound(debruijn, _), ty: _ }\n                 if debruijn.as_usize() + 1\n@@ -638,10 +646,10 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                     name: ty::BoundConst { var: bound_const, ty },\n                 };\n                 self.mapped_consts.insert(p, bound_const);\n-                self.infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Placeholder(p), ty })\n+                Ok(self.infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Placeholder(p), ty }))\n             }\n             _ if ct.has_vars_bound_at_or_above(self.current_index) => ct.super_fold_with(self),\n-            _ => ct,\n+            _ => Ok(ct),\n         }\n     }\n }\n@@ -673,7 +681,7 @@ impl<'me, 'tcx> PlaceholderReplacer<'me, 'tcx> {\n             universe_indices,\n             current_index: ty::INNERMOST,\n         };\n-        value.super_fold_with(&mut replacer)\n+        value.super_fold_with(&mut replacer).into_ok()\n     }\n }\n \n@@ -685,17 +693,17 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         if !t.has_placeholders() && !t.has_infer_regions() {\n-            return t;\n+            return Ok(t);\n         }\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n         t\n     }\n \n-    fn fold_region(&mut self, r0: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r0: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         let r1 = match r0 {\n             ty::ReVar(_) => self\n                 .infcx\n@@ -729,10 +737,10 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n \n         debug!(?r0, ?r1, ?r2, \"fold_region\");\n \n-        r2\n+        Ok(r2)\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *ty.kind() {\n             ty::Placeholder(p) => {\n                 let replace_var = self.mapped_types.get(&p);\n@@ -746,18 +754,21 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                         let db = ty::DebruijnIndex::from_usize(\n                             self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                         );\n-                        self.tcx().mk_ty(ty::Bound(db, *replace_var))\n+                        Ok(self.tcx().mk_ty(ty::Bound(db, *replace_var)))\n                     }\n-                    None => ty,\n+                    None => Ok(ty),\n                 }\n             }\n \n             _ if ty.has_placeholders() || ty.has_infer_regions() => ty.super_fold_with(self),\n-            _ => ty,\n+            _ => Ok(ty),\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         if let ty::Const { val: ty::ConstKind::Placeholder(p), ty } = *ct {\n             let replace_var = self.mapped_consts.get(&p);\n             match replace_var {\n@@ -770,10 +781,11 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                     let db = ty::DebruijnIndex::from_usize(\n                         self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                     );\n-                    self.tcx()\n-                        .mk_const(ty::Const { val: ty::ConstKind::Bound(db, *replace_var), ty })\n+                    Ok(self\n+                        .tcx()\n+                        .mk_const(ty::Const { val: ty::ConstKind::Bound(db, *replace_var), ty }))\n                 }\n-                None => ct,\n+                None => Ok(ct),\n             }\n         } else {\n             ct.super_fold_with(self)\n@@ -1534,7 +1546,8 @@ fn confirm_candidate<'cx, 'tcx>(\n     // when possible for this to work. See `auto-trait-projection-recursion.rs`\n     // for a case where this matters.\n     if progress.ty.has_infer_regions() {\n-        progress.ty = OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.ty);\n+        progress.ty =\n+            OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.ty).into_ok();\n     }\n     progress\n }"}, {"sha": "af507feffba5b5ed615b24f7dac83074c41166d2", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 59, "deletions": 88, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -61,7 +61,6 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n             cause: self.cause,\n             param_env: self.param_env,\n             obligations: vec![],\n-            error: false,\n             cache: SsoHashMap::new(),\n             anon_depth: 0,\n             universes: vec![],\n@@ -100,11 +99,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n             std::any::type_name::<T>(),\n             normalizer.obligations,\n         );\n-        if normalizer.error {\n-            Err(NoSolution)\n-        } else {\n-            Ok(Normalized { value: result, obligations: normalizer.obligations })\n-        }\n+        result.map(|value| Normalized { value, obligations: normalizer.obligations })\n     }\n }\n \n@@ -171,34 +166,35 @@ struct QueryNormalizer<'cx, 'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n     cache: SsoHashMap<Ty<'tcx>, Ty<'tcx>>,\n-    error: bool,\n     anon_depth: usize,\n     universes: Vec<Option<ty::UniverseIndex>>,\n }\n \n impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n+    type Error = NoSolution;\n+\n     fn tcx<'c>(&'c self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: ty::Binder<'tcx, T>,\n-    ) -> ty::Binder<'tcx, T> {\n+    ) -> Result<ty::Binder<'tcx, T>, Self::Error> {\n         self.universes.push(None);\n         let t = t.super_fold_with(self);\n         self.universes.pop();\n         t\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if !needs_normalization(&ty, self.param_env.reveal()) {\n-            return ty;\n+            return Ok(ty);\n         }\n \n         if let Some(ty) = self.cache.get(&ty) {\n-            return ty;\n+            return Ok(ty);\n         }\n \n         // See note in `rustc_trait_selection::traits::project` about why we\n@@ -215,7 +211,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     Reveal::UserFacing => ty.super_fold_with(self),\n \n                     Reveal::All => {\n-                        let substs = substs.super_fold_with(self);\n+                        let substs = substs.super_fold_with(self)?;\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.anon_depth) {\n                             let obligation = Obligation::with_depth(\n@@ -252,7 +248,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // we don't need to replace them with placeholders (see branch below).\n \n                 let tcx = self.infcx.tcx;\n-                let data = data.super_fold_with(self);\n+                let data = data.super_fold_with(self)?;\n \n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n@@ -262,39 +258,22 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                match tcx.normalize_projection_ty(c_data) {\n-                    Ok(result) => {\n-                        // We don't expect ambiguity.\n-                        if result.is_ambiguous() {\n-                            self.error = true;\n-                            return ty.super_fold_with(self);\n-                        }\n-\n-                        match self.infcx.instantiate_query_response_and_region_obligations(\n-                            self.cause,\n-                            self.param_env,\n-                            &orig_values,\n-                            result,\n-                        ) {\n-                            Ok(InferOk { value: result, obligations }) => {\n-                                debug!(\"QueryNormalizer: result = {:#?}\", result);\n-                                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n-                                self.obligations.extend(obligations);\n-                                result.normalized_ty\n-                            }\n-\n-                            Err(_) => {\n-                                self.error = true;\n-                                ty.super_fold_with(self)\n-                            }\n-                        }\n-                    }\n-\n-                    Err(NoSolution) => {\n-                        self.error = true;\n-                        ty.super_fold_with(self)\n-                    }\n+                let result = tcx.normalize_projection_ty(c_data)?;\n+                // We don't expect ambiguity.\n+                if result.is_ambiguous() {\n+                    return Err(NoSolution);\n                 }\n+                let InferOk { value: result, obligations } =\n+                    self.infcx.instantiate_query_response_and_region_obligations(\n+                        self.cause,\n+                        self.param_env,\n+                        &orig_values,\n+                        result,\n+                    )?;\n+                debug!(\"QueryNormalizer: result = {:#?}\", result);\n+                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n+                self.obligations.extend(obligations);\n+                Ok(result.normalized_ty)\n             }\n \n             ty::Projection(data) => {\n@@ -308,7 +287,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         &mut self.universes,\n                         data,\n                     );\n-                let data = data.super_fold_with(self);\n+                let data = data.super_fold_with(self)?;\n \n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n@@ -318,57 +297,49 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                match tcx.normalize_projection_ty(c_data) {\n-                    Ok(result) => {\n-                        // We don't expect ambiguity.\n-                        if result.is_ambiguous() {\n-                            self.error = true;\n-                            return ty.super_fold_with(self);\n-                        }\n-                        match self.infcx.instantiate_query_response_and_region_obligations(\n-                            self.cause,\n-                            self.param_env,\n-                            &orig_values,\n-                            result,\n-                        ) {\n-                            Ok(InferOk { value: result, obligations }) => {\n-                                debug!(\"QueryNormalizer: result = {:#?}\", result);\n-                                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n-                                self.obligations.extend(obligations);\n-                                crate::traits::project::PlaceholderReplacer::replace_placeholders(\n-                                    infcx,\n-                                    mapped_regions,\n-                                    mapped_types,\n-                                    mapped_consts,\n-                                    &self.universes,\n-                                    result.normalized_ty,\n-                                )\n-                            }\n-                            Err(_) => {\n-                                self.error = true;\n-                                ty.super_fold_with(self)\n-                            }\n-                        }\n-                    }\n-                    Err(NoSolution) => {\n-                        self.error = true;\n-                        ty.super_fold_with(self)\n-                    }\n+                let result = tcx.normalize_projection_ty(c_data)?;\n+                // We don't expect ambiguity.\n+                if result.is_ambiguous() {\n+                    return Err(NoSolution);\n                 }\n+                let InferOk { value: result, obligations } =\n+                    self.infcx.instantiate_query_response_and_region_obligations(\n+                        self.cause,\n+                        self.param_env,\n+                        &orig_values,\n+                        result,\n+                    )?;\n+                debug!(\"QueryNormalizer: result = {:#?}\", result);\n+                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n+                self.obligations.extend(obligations);\n+                Ok(crate::traits::project::PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    &self.universes,\n+                    result.normalized_ty,\n+                ))\n             }\n \n             _ => ty.super_fold_with(self),\n-        })();\n+        })()?;\n         self.cache.insert(ty, res);\n-        res\n+        Ok(res)\n     }\n \n-    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        let constant = constant.super_fold_with(self);\n-        constant.eval(self.infcx.tcx, self.param_env)\n+    fn fold_const(\n+        &mut self,\n+        constant: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        let constant = constant.super_fold_with(self)?;\n+        Ok(constant.eval(self.infcx.tcx, self.param_env))\n     }\n \n-    fn fold_mir_const(&mut self, constant: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n+    fn fold_mir_const(\n+        &mut self,\n+        constant: mir::ConstantKind<'tcx>,\n+    ) -> Result<mir::ConstantKind<'tcx>, Self::Error> {\n         constant.super_fold_with(self)\n     }\n }"}, {"sha": "767cb1618bb67d35239db630af41e98e8bad37e3", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -2222,6 +2222,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .predicate\n             .to_poly_trait_ref()\n             .fold_with(&mut self.freshener)\n+            .into_ok()\n             .with_constness(obligation.predicate.skip_binder().constness);\n \n         let dfn = previous_stack.cache.next_dfn();"}, {"sha": "fdff07302c2407fbe7e8c72c5844870e5f1b715d", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         predicates\n             .iter()\n             .map(|(wc, _)| wc.subst(self.interner.tcx, bound_vars))\n-            .map(|wc| wc.fold_with(&mut regions_substitutor))\n+            .map(|wc| wc.fold_with(&mut regions_substitutor).into_ok())\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect()\n     }\n \n@@ -287,7 +287,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let trait_ref = trait_ref.subst(self.interner.tcx, bound_vars);\n         let mut regions_substitutor =\n             lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n-        let trait_ref = trait_ref.fold_with(&mut regions_substitutor);\n+        let trait_ref = trait_ref.fold_with(&mut regions_substitutor).into_ok();\n \n         let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n@@ -335,7 +335,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             let self_ty = self_ty.subst(self.interner.tcx, bound_vars);\n             let mut regions_substitutor =\n                 lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n-            let self_ty = self_ty.fold_with(&mut regions_substitutor);\n+            let self_ty = self_ty.fold_with(&mut regions_substitutor).into_ok();\n             let lowered_ty = self_ty.lower_into(&self.interner);\n \n             parameters[0].assert_ty_ref(&self.interner).could_match(\n@@ -501,22 +501,24 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 .iter()\n                 .map(|(bound, _)| bound.subst(self.interner.tcx, &bound_vars))\n                 .map(|bound| {\n-                    bound.fold_with(&mut ty::fold::BottomUpFolder {\n-                        tcx: self.interner.tcx,\n-                        ty_op: |ty| {\n-                            if let ty::Opaque(def_id, substs) = *ty.kind() {\n-                                if def_id == opaque_ty_id.0 && substs == identity_substs {\n-                                    return self.interner.tcx.mk_ty(ty::Bound(\n-                                        ty::INNERMOST,\n-                                        ty::BoundTy::from(ty::BoundVar::from_u32(0)),\n-                                    ));\n+                    bound\n+                        .fold_with(&mut ty::fold::BottomUpFolder {\n+                            tcx: self.interner.tcx,\n+                            ty_op: |ty| {\n+                                if let ty::Opaque(def_id, substs) = *ty.kind() {\n+                                    if def_id == opaque_ty_id.0 && substs == identity_substs {\n+                                        return self.interner.tcx.mk_ty(ty::Bound(\n+                                            ty::INNERMOST,\n+                                            ty::BoundTy::from(ty::BoundVar::from_u32(0)),\n+                                        ));\n+                                    }\n                                 }\n-                            }\n-                            ty\n-                        },\n-                        lt_op: |lt| lt,\n-                        ct_op: |ct| ct,\n-                    })\n+                                ty\n+                            },\n+                            lt_op: |lt| lt,\n+                            ct_op: |ct| ct,\n+                        })\n+                        .into_ok()\n                 })\n                 .filter_map(|bound| {\n                     LowerInto::<"}, {"sha": "66073facf4b0c1f10bfa59e3ed2ea39ac1053c25", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -817,7 +817,7 @@ crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n         .collect();\n \n     let mut bound_var_substitutor = NamedBoundVarSubstitutor::new(tcx, &named_parameters);\n-    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor);\n+    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor).into_ok();\n \n     for var in named_parameters.values() {\n         parameters.insert(*var, chalk_ir::VariableKind::Lifetime);\n@@ -943,20 +943,23 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: Binder<'tcx, T>,\n+    ) -> Result<Binder<'tcx, T>, Self::Error> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);\n         result\n     }\n \n-    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n         match r {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br.kind {\n                 ty::BrNamed(def_id, _name) => match self.named_parameters.get(&def_id) {\n                     Some(idx) => {\n                         let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(*idx) };\n-                        return self.tcx.mk_region(RegionKind::ReLateBound(*index, new_br));\n+                        return Ok(self.tcx.mk_region(RegionKind::ReLateBound(*index, new_br)));\n                     }\n                     None => panic!(\"Missing `BrNamed`.\"),\n                 },\n@@ -999,40 +1002,43 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: Binder<'tcx, T>,\n+    ) -> Result<Binder<'tcx, T>, Self::Error> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);\n         result\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match *t.kind() {\n             // FIXME(chalk): currently we convert params to placeholders starting at\n             // index `0`. To support placeholders, we'll actually need to do a\n             // first pass to collect placeholders. Then we can insert params after.\n             ty::Placeholder(_) => unimplemented!(),\n             ty::Param(param) => match self.list.iter().position(|r| r == &param) {\n-                Some(idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                Some(idx) => Ok(self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::from_usize(0),\n                     name: ty::BoundVar::from_usize(idx),\n-                })),\n+                }))),\n                 None => {\n                     self.list.push(param);\n                     let idx = self.list.len() - 1 + self.next_ty_placeholder;\n                     self.params.insert(idx, param);\n-                    self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                    Ok(self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                         universe: ty::UniverseIndex::from_usize(0),\n                         name: ty::BoundVar::from_usize(idx),\n-                    }))\n+                    })))\n                 }\n             },\n \n             _ => t.super_fold_with(self),\n         }\n     }\n \n-    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n         match r {\n             // FIXME(chalk) - jackh726 - this currently isn't hit in any tests.\n             // This covers any region variables in a goal, right?\n@@ -1042,14 +1048,14 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n                         var: ty::BoundVar::from_u32(*idx),\n                         kind: ty::BrAnon(*idx),\n                     };\n-                    self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n+                    Ok(self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br)))\n                 }\n                 None => {\n                     let idx = self.named_regions.len() as u32;\n                     let br =\n                         ty::BoundRegion { var: ty::BoundVar::from_u32(idx), kind: ty::BrAnon(idx) };\n                     self.named_regions.insert(_re.def_id, idx);\n-                    self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n+                    Ok(self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br)))\n                 }\n             },\n \n@@ -1125,11 +1131,11 @@ impl<'tcx> TypeFolder<'tcx> for RegionsSubstitutor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n         match r {\n             ty::ReEmpty(ui) => {\n                 assert_eq!(ui.as_usize(), 0);\n-                self.reempty_placeholder\n+                Ok(self.reempty_placeholder)\n             }\n \n             _ => r.super_fold_with(self),"}, {"sha": "a6f7c4d7988f697ed0fb37dd39c5cdcd5d04b20e", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -49,12 +49,12 @@ crate fn evaluate_goal<'tcx>(\n \n     let mut params_substitutor =\n         ParamsSubstitutor::new(tcx, placeholders_collector.next_ty_placeholder);\n-    let obligation = obligation.fold_with(&mut params_substitutor);\n+    let obligation = obligation.fold_with(&mut params_substitutor).into_ok();\n     // FIXME(chalk): we really should be substituting these back in the solution\n     let _params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n \n     let mut regions_substitutor = RegionsSubstitutor::new(tcx, reempty_placeholder);\n-    let obligation = obligation.fold_with(&mut regions_substitutor);\n+    let obligation = obligation.fold_with(&mut regions_substitutor).into_ok();\n \n     let max_universe = obligation.max_universe.index();\n "}, {"sha": "ea70a8d9e3a0d30fd9504f496e21b3cebee49669", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -4,6 +4,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "1c4e0522bef8fac63307ddb78ce3355b0f507128", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -442,8 +442,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let mut eraser = TypeParamEraser(self, expr.span);\n                             let needs_bound = self\n                                 .lookup_op_method(\n-                                    eraser.fold_ty(lhs_ty),\n-                                    &[eraser.fold_ty(rhs_ty)],\n+                                    eraser.fold_ty(lhs_ty).into_ok(),\n+                                    &[eraser.fold_ty(rhs_ty).into_ok()],\n                                     Op::Binary(op, is_assign),\n                                 )\n                                 .is_ok();\n@@ -1015,12 +1015,12 @@ impl TypeFolder<'tcx> for TypeParamEraser<'_, 'tcx> {\n         self.0.tcx\n     }\n \n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match ty.kind() {\n-            ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n+            ty::Param(_) => Ok(self.0.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::MiscVariable,\n                 span: self.1,\n-            }),\n+            })),\n             _ => ty.super_fold_with(self),\n         }\n     }"}, {"sha": "a5965411020a4a429c4dd6e865b69c2639aa7ecc", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -658,7 +658,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         let mut resolver = Resolver::new(self.fcx, span, self.body);\n-        let x = x.fold_with(&mut resolver);\n+        let x = x.fold_with(&mut resolver).into_ok();\n         if cfg!(debug_assertions) && x.needs_infer() {\n             span_bug!(span.to_span(self.fcx.tcx), \"writeback: `{:?}` has inference variables\", x);\n         }\n@@ -749,15 +749,15 @@ impl<'tcx> TypeFolder<'tcx> for EraseEarlyRegions<'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         if ty.has_type_flags(ty::TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n             ty.super_fold_with(self)\n         } else {\n-            ty\n+            Ok(ty)\n         }\n     }\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        if let ty::ReLateBound(..) = r { r } else { self.tcx.lifetimes.re_erased }\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        Ok(if let ty::ReLateBound(..) = r { r } else { self.tcx.lifetimes.re_erased })\n     }\n }\n \n@@ -766,7 +766,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n         match self.infcx.fully_resolve(t) {\n             Ok(t) => {\n                 // Do not anonymize late-bound regions\n@@ -779,26 +779,29 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 self.report_type_error(t);\n                 self.replaced_with_error = true;\n-                self.tcx().ty_error()\n+                Ok(self.tcx().ty_error())\n             }\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         debug_assert!(!r.is_late_bound(), \"Should not be resolving bound region.\");\n-        self.tcx.lifetimes.re_erased\n+        Ok(self.tcx.lifetimes.re_erased)\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        match self.infcx.fully_resolve(ct) {\n+    fn fold_const(\n+        &mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        Ok(match self.infcx.fully_resolve(ct) {\n             Ok(ct) => self.infcx.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 self.report_const_error(ct);\n                 self.replaced_with_error = true;\n                 self.tcx().const_error(ct.ty)\n             }\n-        }\n+        })\n     }\n }\n "}, {"sha": "1ea379c57389a1035052985f142ba5c71c11bf22", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -729,17 +729,17 @@ fn infer_placeholder_type<'a>(\n             self.tcx\n         }\n \n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n             if !self.success {\n-                return ty;\n+                return Ok(ty);\n             }\n \n             match ty.kind() {\n-                ty::FnDef(def_id, _) => self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id)),\n+                ty::FnDef(def_id, _) => Ok(self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id))),\n                 // FIXME: non-capturing closures should also suggest a function pointer\n                 ty::Closure(..) | ty::Generator(..) => {\n                     self.success = false;\n-                    ty\n+                    Ok(ty)\n                 }\n                 _ => ty.super_fold_with(self),\n             }\n@@ -761,7 +761,7 @@ fn infer_placeholder_type<'a>(\n \n                 // Suggesting unnameable types won't help.\n                 let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty);\n+                let ty = mk_nameable.fold_ty(ty).into_ok();\n                 let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n                 if let Some(sugg_ty) = sugg_ty {\n                     err.span_suggestion(\n@@ -785,7 +785,7 @@ fn infer_placeholder_type<'a>(\n \n             if !ty.references_error() {\n                 let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty);\n+                let ty = mk_nameable.fold_ty(ty).into_ok();\n                 let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n                 if let Some(sugg_ty) = sugg_ty {\n                     diag.span_suggestion("}, {"sha": "f9de6376b0ff5e572964c8edc8c3b7abd6469d4e", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -71,8 +71,11 @@ fn diagnostic_hir_wf_check<'tcx>(\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             self.tcx.infer_ctxt().enter(|infcx| {\n                 let mut fulfill = traits::FulfillmentContext::new();\n-                let tcx_ty =\n-                    self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n+                let tcx_ty = self\n+                    .icx\n+                    .to_ty(ty)\n+                    .fold_with(&mut EraseAllBoundRegions { tcx: self.tcx })\n+                    .into_ok();\n                 let cause = traits::ObligationCause::new(\n                     ty.span,\n                     self.hir_id,\n@@ -183,7 +186,7 @@ impl<'tcx> TypeFolder<'tcx> for EraseAllBoundRegions<'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n-        if let ty::ReLateBound(..) = r { &ty::ReErased } else { r }\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Result<Region<'tcx>, Self::Error> {\n+        if let ty::ReLateBound(..) = r { Ok(&ty::ReErased) } else { Ok(r) }\n     }\n }"}, {"sha": "c0f0b3fe7046ec2c34fe78af4dbf93b43a44b3e7", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -71,6 +71,7 @@ This API is completely unstable and subject to change.\n #![feature(slice_partition_dedup)]\n #![feature(control_flow_enum)]\n #![feature(hash_drain_filter)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "04fe1dccce44bfa8ce56da0cb9e4c4916f187ed8", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         _ => false,\n                     }\n             })\n-            .map(|p| p.fold_with(&mut replacer));\n+            .map(|p| p.fold_with(&mut replacer).into_ok());\n \n         let mut generic_params =\n             (tcx.generics_of(item_def_id), tcx.explicit_predicates_of(item_def_id))\n@@ -714,11 +714,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        (match *r {\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        Ok((match *r {\n             ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n             _ => None,\n         })\n-        .unwrap_or_else(|| r.super_fold_with(self))\n+        .unwrap_or_else(|| r.super_fold_with(self).into_ok()))\n     }\n }"}, {"sha": "6ba56fe01a93505a7306cf628a98c89ad27cbdb9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2de9483a27f846f003fc745713339a9122473/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2de9483a27f846f003fc745713339a9122473/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e6d2de9483a27f846f003fc745713339a9122473", "patch": "@@ -18,6 +18,7 @@\n #![feature(type_ascription)]\n #![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n+#![feature(unwrap_infallible)]\n #![warn(rustc::internal)]\n \n #[macro_use]"}]}