{"sha": "fe1f1f128253f558e6e509dd1fc06310577bc7e7", "node_id": "C_kwDOAAsO6NoAKGZlMWYxZjEyODI1M2Y1NThlNmU1MDlkZDFmYzA2MzEwNTc3YmM3ZTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-24T16:20:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-24T16:20:16Z"}, "message": "Rollup merge of #100922 - GuillaumeGomez:rewrite-error-index, r=notriddle\n\nRewrite error index generator to greatly reduce the size of the pages\n\nFixes https://github.com/rust-lang/rust/issues/100736.\n\nInstead of having all error codes in a same page (making the DOM way too big), I split the output into multiple files and generated a list of links (if there is an explanation) to the error codes' explanation into the already existing file.\n\nI also used this opportunity to greatly simplify the code. Instead of needing a `build.rs`, I simply imported the file we want and wrote the macro which generates a function containing everything we need. We just need to call it to get the error codes and their explanation (if any). Also, considering the implementations between markdown and HTML formats differed even further, the `Formatter` trait was becoming too problematic so I removed it too.\n\nYou can test it [here](https://rustdoc.crud.net/imperio/rewrite-error-index/error-index.html).\n\ncc ``@jsha``\nr? ``@notriddle``", "tree": {"sha": "a23a7abe4de71b16b0380cf55e4ac20f45a9b6c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a23a7abe4de71b16b0380cf55e4ac20f45a9b6c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe1f1f128253f558e6e509dd1fc06310577bc7e7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjBk/ACRBK7hj4Ov3rIwAAbrgIAI0GLABo7sucIeMw/7uNPbJ2\nHIESTTTw1NJlVKtehqQu6Ct98fz+0Z56tX01UtQyuLBEFJTtHOZAzCMHnb0tw67U\nxtHVavJrBNS58L7LkjqhHkXpEFbPPJfaPihy1Fqy30MnBnwI5tKPW1qZVicKb2DM\nS5XLNVZrzwbnEgVpPjDtstg2DInvcggAroPaFAWn+8rFQlmjHzaMLLttV6z0IFnc\nEKn140OXSpr5m/uBfIAUXEK6E02eHA0/lDwGkS+D1W5VZn6wpq4gevcHpWrCQbiC\nJcteTFh0pRiekSJV7DLap+vC3Jzy1V9olak8V3rBi7bZ07MRS2KJQoHmWuMCIWI=\n=RsoF\n-----END PGP SIGNATURE-----\n", "payload": "tree a23a7abe4de71b16b0380cf55e4ac20f45a9b6c0\nparent 8cdf4080c19097ff3fb4e39bb654dd41f61caa24\nparent 4398d9229aea35d5f3b6b8365260ee87304b27b0\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661358016 +0200\ncommitter GitHub <noreply@github.com> 1661358016 +0200\n\nRollup merge of #100922 - GuillaumeGomez:rewrite-error-index, r=notriddle\n\nRewrite error index generator to greatly reduce the size of the pages\n\nFixes https://github.com/rust-lang/rust/issues/100736.\n\nInstead of having all error codes in a same page (making the DOM way too big), I split the output into multiple files and generated a list of links (if there is an explanation) to the error codes' explanation into the already existing file.\n\nI also used this opportunity to greatly simplify the code. Instead of needing a `build.rs`, I simply imported the file we want and wrote the macro which generates a function containing everything we need. We just need to call it to get the error codes and their explanation (if any). Also, considering the implementations between markdown and HTML formats differed even further, the `Formatter` trait was becoming too problematic so I removed it too.\n\nYou can test it [here](https://rustdoc.crud.net/imperio/rewrite-error-index/error-index.html).\n\ncc ``@jsha``\nr? ``@notriddle``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe1f1f128253f558e6e509dd1fc06310577bc7e7", "html_url": "https://github.com/rust-lang/rust/commit/fe1f1f128253f558e6e509dd1fc06310577bc7e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe1f1f128253f558e6e509dd1fc06310577bc7e7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cdf4080c19097ff3fb4e39bb654dd41f61caa24", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cdf4080c19097ff3fb4e39bb654dd41f61caa24", "html_url": "https://github.com/rust-lang/rust/commit/8cdf4080c19097ff3fb4e39bb654dd41f61caa24"}, {"sha": "4398d9229aea35d5f3b6b8365260ee87304b27b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4398d9229aea35d5f3b6b8365260ee87304b27b0", "html_url": "https://github.com/rust-lang/rust/commit/4398d9229aea35d5f3b6b8365260ee87304b27b0"}], "stats": {"total": 354, "additions": 129, "deletions": 225}, "files": [{"sha": "ab673c623b5d6ad29c9596bb1d3dcb97ec43e663", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe1f1f128253f558e6e509dd1fc06310577bc7e7/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1f1f128253f558e6e509dd1fc06310577bc7e7/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=fe1f1f128253f558e6e509dd1fc06310577bc7e7", "patch": "@@ -343,7 +343,7 @@ pub trait StructuralEq {\n /// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get\n /// the error [E0204].\n ///\n-/// [E0204]: ../../error-index.html#E0204\n+/// [E0204]: ../../error_codes/E0204.html\n ///\n /// ## When *should* my type be `Copy`?\n ///"}, {"sha": "de9ddb852df31d8da34a5eda646d42a6bb4fa511", "filename": "library/core/src/ops/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe1f1f128253f558e6e509dd1fc06310577bc7e7/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1f1f128253f558e6e509dd1fc06310577bc7e7/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs?ref=fe1f1f128253f558e6e509dd1fc06310577bc7e7", "patch": "@@ -156,7 +156,7 @@ pub trait Drop {\n     /// handled by the compiler, but when using unsafe code, can sometimes occur\n     /// unintentionally, particularly when using [`ptr::drop_in_place`].\n     ///\n-    /// [E0040]: ../../error-index.html#E0040\n+    /// [E0040]: ../../error_codes/E0040.html\n     /// [`panic!`]: crate::panic!\n     /// [`mem::drop`]: drop\n     /// [`ptr::drop_in_place`]: crate::ptr::drop_in_place"}, {"sha": "70b00b36cf1757ec55fd048a6498b6781548fdcd", "filename": "src/tools/error_index_generator/build.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8cdf4080c19097ff3fb4e39bb654dd41f61caa24/src%2Ftools%2Ferror_index_generator%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdf4080c19097ff3fb4e39bb654dd41f61caa24/src%2Ftools%2Ferror_index_generator%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fbuild.rs?ref=8cdf4080c19097ff3fb4e39bb654dd41f61caa24", "patch": "@@ -1,31 +0,0 @@\n-use std::path::PathBuf;\n-use std::{env, fs};\n-use walkdir::WalkDir;\n-\n-fn main() {\n-    // The src directory (we are in src/tools/error_index_generator)\n-    // Note that we could skip one of the .. but this ensures we at least loosely find the right\n-    // directory.\n-    let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n-\n-    let error_codes_path = \"../../../compiler/rustc_error_codes/src/error_codes.rs\";\n-\n-    println!(\"cargo:rerun-if-changed={}\", error_codes_path);\n-    let file = fs::read_to_string(error_codes_path)\n-        .unwrap()\n-        .replace(\": include_str!(\\\"./error_codes/\", \": include_str!(\\\"./\");\n-    let contents = format!(\"(|| {{\\n{}\\n}})()\", file);\n-    fs::write(&out_dir.join(\"all_error_codes.rs\"), &contents).unwrap();\n-\n-    // We copy the md files as well to the target directory.\n-    for entry in WalkDir::new(\"../../../compiler/rustc_error_codes/src/error_codes\") {\n-        let entry = entry.unwrap();\n-        match entry.path().extension() {\n-            Some(s) if s == \"md\" => {}\n-            _ => continue,\n-        }\n-        println!(\"cargo:rerun-if-changed={}\", entry.path().to_str().unwrap());\n-        let md_content = fs::read_to_string(entry.path()).unwrap();\n-        fs::write(&out_dir.join(entry.file_name()), &md_content).unwrap();\n-    }\n-}"}, {"sha": "68c46700361a8da36dd766f53a69e5720760b6b9", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 127, "deletions": 192, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/fe1f1f128253f558e6e509dd1fc06310577bc7e7/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1f1f128253f558e6e509dd1fc06310577bc7e7/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=fe1f1f128253f558e6e509dd1fc06310577bc7e7", "patch": "@@ -3,11 +3,11 @@\n extern crate rustc_driver;\n extern crate rustc_span;\n \n-use std::cell::RefCell;\n-use std::collections::BTreeMap;\n+use crate::error_codes::error_codes;\n+\n use std::env;\n use std::error::Error;\n-use std::fs::File;\n+use std::fs::{create_dir_all, File};\n use std::io::Write;\n use std::path::Path;\n use std::path::PathBuf;\n@@ -16,49 +16,86 @@ use rustc_span::edition::DEFAULT_EDITION;\n \n use rustdoc::html::markdown::{ErrorCodes, HeadingOffset, IdMap, Markdown, Playground};\n \n-pub struct ErrorMetadata {\n-    pub description: Option<String>,\n+macro_rules! register_diagnostics {\n+    ($($error_code:ident: $message:expr,)+ ; $($undocumented:ident,)* ) => {\n+        pub fn error_codes() -> Vec<(&'static str, Option<&'static str>)> {\n+            let mut errors: Vec<(&str, Option<&str>)> = vec![\n+                $((stringify!($error_code), Some($message)),)+\n+                $((stringify!($undocumented), None),)+\n+            ];\n+            errors.sort();\n+            errors\n+        }\n+    }\n }\n \n-/// Mapping from error codes to metadata that can be (de)serialized.\n-pub type ErrorMetadataMap = BTreeMap<String, ErrorMetadata>;\n+#[path = \"../../../compiler/rustc_error_codes/src/error_codes.rs\"]\n+mod error_codes;\n \n enum OutputFormat {\n     HTML(HTMLFormatter),\n-    Markdown(MarkdownFormatter),\n+    Markdown,\n     Unknown(String),\n }\n \n impl OutputFormat {\n     fn from(format: &str, resource_suffix: &str) -> OutputFormat {\n         match &*format.to_lowercase() {\n-            \"html\" => OutputFormat::HTML(HTMLFormatter(\n-                RefCell::new(IdMap::new()),\n-                resource_suffix.to_owned(),\n-            )),\n-            \"markdown\" => OutputFormat::Markdown(MarkdownFormatter),\n+            \"html\" => OutputFormat::HTML(HTMLFormatter(resource_suffix.to_owned())),\n+            \"markdown\" => OutputFormat::Markdown,\n             s => OutputFormat::Unknown(s.to_owned()),\n         }\n     }\n }\n \n-trait Formatter {\n-    fn header(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n-    fn title(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n-    fn error_code_block(\n+struct HTMLFormatter(String);\n+\n+impl HTMLFormatter {\n+    fn create_error_code_file(\n         &self,\n-        output: &mut dyn Write,\n-        info: &ErrorMetadata,\n         err_code: &str,\n-    ) -> Result<(), Box<dyn Error>>;\n-    fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n-}\n+        explanation: &str,\n+        parent_dir: &Path,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let mut output_file = File::create(parent_dir.join(err_code).with_extension(\"html\"))?;\n+\n+        self.header(&mut output_file, \"../\", \"\")?;\n+        self.title(&mut output_file, &format!(\"Error code {}\", err_code))?;\n+\n+        let mut id_map = IdMap::new();\n+        let playground =\n+            Playground { crate_name: None, url: String::from(\"https://play.rust-lang.org/\") };\n+        write!(\n+            output_file,\n+            \"{}\",\n+            Markdown {\n+                content: explanation,\n+                links: &[],\n+                ids: &mut id_map,\n+                error_codes: ErrorCodes::Yes,\n+                edition: DEFAULT_EDITION,\n+                playground: &Some(playground),\n+                heading_offset: HeadingOffset::H1,\n+            }\n+            .into_string()\n+        )?;\n+        write!(\n+            output_file,\n+            \"<p>\\\n+                <a style='text-align: center;display: block;width: 100%;' \\\n+                   href='../error-index.html'>Back to list of error codes</a>\\\n+             </p>\",\n+        )?;\n \n-struct HTMLFormatter(RefCell<IdMap>, String);\n-struct MarkdownFormatter;\n+        self.footer(&mut output_file)\n+    }\n \n-impl Formatter for HTMLFormatter {\n-    fn header(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n+    fn header(\n+        &self,\n+        output: &mut dyn Write,\n+        extra_path: &str,\n+        extra: &str,\n+    ) -> Result<(), Box<dyn Error>> {\n         write!(\n             output,\n             r##\"<!DOCTYPE html>\n@@ -67,188 +104,106 @@ impl Formatter for HTMLFormatter {\n <title>Rust Compiler Error Index</title>\n <meta charset=\"utf-8\">\n <!-- Include rust.css after light.css so its rules take priority. -->\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"rustdoc{suffix}.css\"/>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"light{suffix}.css\"/>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"rust.css\"/>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"{extra_path}rustdoc{suffix}.css\"/>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"{extra_path}light{suffix}.css\"/>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"{extra_path}rust.css\"/>\n <style>\n .error-undescribed {{\n     display: none;\n }}\n-</style>\n+</style>{extra}\n </head>\n <body>\n \"##,\n-            suffix = self.1\n+            suffix = self.0,\n         )?;\n         Ok(())\n     }\n \n-    fn title(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        write!(output, \"<h1>Rust Compiler Error Index</h1>\\n\")?;\n-        Ok(())\n-    }\n-\n-    fn error_code_block(\n-        &self,\n-        output: &mut dyn Write,\n-        info: &ErrorMetadata,\n-        err_code: &str,\n-    ) -> Result<(), Box<dyn Error>> {\n-        // Enclose each error in a div so they can be shown/hidden en masse.\n-        let desc_desc = match info.description {\n-            Some(_) => \"error-described\",\n-            None => \"error-undescribed\",\n-        };\n-        write!(output, \"<div class=\\\"{}\\\">\", desc_desc)?;\n-\n-        // Error title (with self-link).\n-        write!(\n-            output,\n-            \"<h2 id=\\\"{0}\\\" class=\\\"section-header\\\"><a href=\\\"#{0}\\\">{0}</a></h2>\\n\",\n-            err_code\n-        )?;\n-\n-        // Description rendered as markdown.\n-        match info.description {\n-            Some(ref desc) => {\n-                let mut id_map = self.0.borrow_mut();\n-                let playground = Playground {\n-                    crate_name: None,\n-                    url: String::from(\"https://play.rust-lang.org/\"),\n-                };\n-                write!(\n-                    output,\n-                    \"{}\",\n-                    Markdown {\n-                        content: desc,\n-                        links: &[],\n-                        ids: &mut id_map,\n-                        error_codes: ErrorCodes::Yes,\n-                        edition: DEFAULT_EDITION,\n-                        playground: &Some(playground),\n-                        heading_offset: HeadingOffset::H1,\n-                    }\n-                    .into_string()\n-                )?\n-            }\n-            None => write!(output, \"<p>No description.</p>\\n\")?,\n-        }\n-\n-        write!(output, \"</div>\\n\")?;\n+    fn title(&self, output: &mut dyn Write, title: &str) -> Result<(), Box<dyn Error>> {\n+        write!(output, \"<h1>{}</h1>\\n\", title)?;\n         Ok(())\n     }\n \n     fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        write!(\n-            output,\n-            r##\"<script>\n-function onEach(arr, func) {{\n-    if (arr && arr.length > 0 && func) {{\n-        var length = arr.length;\n-        var i;\n-        for (i = 0; i < length; ++i) {{\n-            if (func(arr[i])) {{\n-                return true;\n-            }}\n-        }}\n-    }}\n-    return false;\n-}}\n-\n-function onEachLazy(lazyArray, func) {{\n-    return onEach(\n-        Array.prototype.slice.call(lazyArray),\n-        func);\n-}}\n-\n-function hasClass(elem, className) {{\n-    return elem && elem.classList && elem.classList.contains(className);\n-}}\n-\n-onEachLazy(document.getElementsByClassName('rust-example-rendered'), function(e) {{\n-    if (hasClass(e, 'compile_fail')) {{\n-        e.addEventListener(\"mouseover\", function(event) {{\n-            e.parentElement.previousElementSibling.childNodes[0].style.color = '#f00';\n-        }});\n-        e.addEventListener(\"mouseout\", function(event) {{\n-            e.parentElement.previousElementSibling.childNodes[0].style.color = '';\n-        }});\n-    }} else if (hasClass(e, 'ignore')) {{\n-        e.addEventListener(\"mouseover\", function(event) {{\n-            e.parentElement.previousElementSibling.childNodes[0].style.color = '#ff9200';\n-        }});\n-        e.addEventListener(\"mouseout\", function(event) {{\n-            e.parentElement.previousElementSibling.childNodes[0].style.color = '';\n-        }});\n-    }}\n-}});\n-</script>\n-</body>\n-</html>\"##\n-        )?;\n+        write!(output, \"</body></html>\")?;\n         Ok(())\n     }\n }\n \n-impl Formatter for MarkdownFormatter {\n-    #[allow(unused_variables)]\n-    fn header(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        Ok(())\n-    }\n+/// Output an HTML page for the errors in `err_map` to `output_path`.\n+fn render_markdown(output_path: &Path) -> Result<(), Box<dyn Error>> {\n+    let mut output_file = File::create(output_path)?;\n \n-    fn title(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        write!(output, \"# Rust Compiler Error Index\\n\")?;\n-        Ok(())\n-    }\n+    write!(output_file, \"# Rust Compiler Error Index\\n\")?;\n \n-    fn error_code_block(\n-        &self,\n-        output: &mut dyn Write,\n-        info: &ErrorMetadata,\n-        err_code: &str,\n-    ) -> Result<(), Box<dyn Error>> {\n-        Ok(match info.description {\n-            Some(ref desc) => write!(output, \"## {}\\n{}\\n\", err_code, desc)?,\n-            None => (),\n-        })\n+    for (err_code, description) in error_codes().iter() {\n+        match description {\n+            Some(ref desc) => write!(output_file, \"## {}\\n{}\\n\", err_code, desc)?,\n+            None => {}\n+        }\n     }\n \n-    #[allow(unused_variables)]\n-    fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        Ok(())\n-    }\n+    Ok(())\n }\n \n-/// Output an HTML page for the errors in `err_map` to `output_path`.\n-fn render_error_page<T: Formatter>(\n-    err_map: &ErrorMetadataMap,\n-    output_path: &Path,\n-    formatter: T,\n-) -> Result<(), Box<dyn Error>> {\n+fn render_html(output_path: &Path, formatter: HTMLFormatter) -> Result<(), Box<dyn Error>> {\n     let mut output_file = File::create(output_path)?;\n \n-    formatter.header(&mut output_file)?;\n-    formatter.title(&mut output_file)?;\n+    let error_codes_dir = \"error_codes\";\n \n-    for (err_code, info) in err_map {\n-        formatter.error_code_block(&mut output_file, info, err_code)?;\n+    let parent = output_path.parent().expect(\"There should have a parent\").join(error_codes_dir);\n+\n+    if !parent.exists() {\n+        create_dir_all(&parent)?;\n     }\n \n+    formatter.header(\n+        &mut output_file,\n+        \"\",\n+        &format!(\n+            r#\"<script>(function() {{\n+    if (window.location.hash) {{\n+        let code = window.location.hash.replace(/^#/, '');\n+        // We have to make sure this pattern matches to avoid inadvertently creating an\n+        // open redirect.\n+        if (/^E[0-9]+$/.test(code)) {{\n+            window.location = './{error_codes_dir}/' + code + '.html';\n+        }}\n+    }}\n+}})()</script>\"#\n+        ),\n+    )?;\n+    formatter.title(&mut output_file, \"Rust Compiler Error Index\")?;\n+\n+    write!(\n+        output_file,\n+        \"<p>This page lists all the error codes emitted by the Rust compiler. If you want a full \\\n+            explanation on an error code, click on it.</p>\\\n+         <ul>\",\n+    )?;\n+    for (err_code, explanation) in error_codes().iter() {\n+        if let Some(explanation) = explanation {\n+            write!(\n+                output_file,\n+                \"<li><a href='./{0}/{1}.html'>{1}</a></li>\",\n+                error_codes_dir, err_code\n+            )?;\n+            formatter.create_error_code_file(err_code, explanation, &parent)?;\n+        } else {\n+            write!(output_file, \"<li>{}</li>\", err_code)?;\n+        }\n+    }\n+    write!(output_file, \"</ul>\")?;\n     formatter.footer(&mut output_file)\n }\n \n fn main_with_result(format: OutputFormat, dst: &Path) -> Result<(), Box<dyn Error>> {\n-    let long_codes = register_all();\n-    let mut err_map = BTreeMap::new();\n-    for (code, desc) in long_codes {\n-        err_map.insert(code.to_string(), ErrorMetadata { description: desc.map(String::from) });\n-    }\n     match format {\n         OutputFormat::Unknown(s) => panic!(\"Unknown output format: {}\", s),\n-        OutputFormat::HTML(h) => render_error_page(&err_map, dst, h)?,\n-        OutputFormat::Markdown(m) => render_error_page(&err_map, dst, m)?,\n+        OutputFormat::HTML(h) => render_html(dst, h),\n+        OutputFormat::Markdown => render_markdown(dst),\n     }\n-    Ok(())\n }\n \n fn parse_args() -> (OutputFormat, PathBuf) {\n@@ -261,7 +216,7 @@ fn parse_args() -> (OutputFormat, PathBuf) {\n         .unwrap_or(OutputFormat::from(\"html\", &resource_suffix));\n     let dst = dst.map(PathBuf::from).unwrap_or_else(|| match format {\n         OutputFormat::HTML(..) => PathBuf::from(\"doc/error-index.html\"),\n-        OutputFormat::Markdown(..) => PathBuf::from(\"doc/error-index.md\"),\n+        OutputFormat::Markdown => PathBuf::from(\"doc/error-index.md\"),\n         OutputFormat::Unknown(..) => PathBuf::from(\"<nul>\"),\n     });\n     (format, dst)\n@@ -276,23 +231,3 @@ fn main() {\n         panic!(\"{}\", e.to_string());\n     }\n }\n-\n-fn register_all() -> Vec<(&'static str, Option<&'static str>)> {\n-    let mut long_codes: Vec<(&'static str, Option<&'static str>)> = Vec::new();\n-    macro_rules! register_diagnostics {\n-        ($($ecode:ident: $message:expr,)* ; $($code:ident,)*) => (\n-            $(\n-                {long_codes.extend([\n-                    (stringify!($ecode), Some($message)),\n-                ].iter());}\n-            )*\n-            $(\n-                {long_codes.extend([\n-                    stringify!($code),\n-                ].iter().cloned().map(|s| (s, None)).collect::<Vec<_>>());}\n-            )*\n-        )\n-    }\n-    include!(concat!(env!(\"OUT_DIR\"), \"/all_error_codes.rs\"));\n-    long_codes\n-}"}]}