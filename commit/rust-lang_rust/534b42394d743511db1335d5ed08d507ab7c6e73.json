{"sha": "534b42394d743511db1335d5ed08d507ab7c6e73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNGI0MjM5NGQ3NDM1MTFkYjEzMzVkNWVkMDhkNTA3YWI3YzZlNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-09T12:14:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-09T12:14:57Z"}, "message": "Auto merge of #63408 - Centril:rollup-skqrez3, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #62672 (Deprecate `try!` macro)\n - #62950 (Check rustbook links on all platforms when running locally)\n - #63114 (Remove gensym in format_args)\n - #63397 (Add tests for some ICEs)\n - #63403 (Improve test output)\n - #63404 (enable flt2dec tests in Miri)\n - #63407 (reduce some test sizes in Miri)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "cc047310c6dacf2211ab80a7087e70a0198d13ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc047310c6dacf2211ab80a7087e70a0198d13ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/534b42394d743511db1335d5ed08d507ab7c6e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/534b42394d743511db1335d5ed08d507ab7c6e73", "html_url": "https://github.com/rust-lang/rust/commit/534b42394d743511db1335d5ed08d507ab7c6e73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/534b42394d743511db1335d5ed08d507ab7c6e73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "813a3a5d4b2be4e2101faa73a067da02a704a598", "url": "https://api.github.com/repos/rust-lang/rust/commits/813a3a5d4b2be4e2101faa73a067da02a704a598", "html_url": "https://github.com/rust-lang/rust/commit/813a3a5d4b2be4e2101faa73a067da02a704a598"}, {"sha": "4e3c209b67c1afe800564fa5ac884e06fde8f378", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3c209b67c1afe800564fa5ac884e06fde8f378", "html_url": "https://github.com/rust-lang/rust/commit/4e3c209b67c1afe800564fa5ac884e06fde8f378"}], "stats": {"total": 637, "additions": 538, "deletions": 99}, "files": [{"sha": "df7eb7c455d0267922fc6bf07fac90c85c02a1f0", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -9,7 +9,7 @@ use build_helper::t;\n use crate::Mode;\n use crate::Compiler;\n use crate::builder::{Step, RunConfig, ShouldRun, Builder};\n-use crate::util::{exe, add_lib_path};\n+use crate::util::{exe, add_lib_path, CiEnv};\n use crate::compile;\n use crate::channel::GitInfo;\n use crate::channel;\n@@ -279,11 +279,26 @@ pub fn prepare_tool_cargo(\n     cargo\n }\n \n+fn rustbook_features() -> Vec<String> {\n+    let mut features = Vec::new();\n+\n+    // Due to CI budged and risk of spurious failures we want to limit jobs running this check.\n+    // At same time local builds should run it regardless of the platform.\n+    // `CiEnv::None` means it's local build and `CHECK_LINKS` is defined in x86_64-gnu-tools to\n+    // explicitly enable it on single job\n+    if CiEnv::current() == CiEnv::None || env::var(\"CHECK_LINKS\").is_ok() {\n+        features.push(\"linkcheck\".to_string());\n+    }\n+\n+    features\n+}\n+\n macro_rules! bootstrap_tool {\n     ($(\n         $name:ident, $path:expr, $tool_name:expr\n         $(,llvm_tools = $llvm:expr)*\n         $(,is_external_tool = $external:expr)*\n+        $(,features = $features:expr)*\n         ;\n     )+) => {\n         #[derive(Copy, PartialEq, Eq, Clone)]\n@@ -350,7 +365,12 @@ macro_rules! bootstrap_tool {\n                     } else {\n                         SourceType::InTree\n                     },\n-                    extra_features: Vec::new(),\n+                    extra_features: {\n+                        // FIXME(#60643): avoid this lint by using `_`\n+                        let mut _tmp = Vec::new();\n+                        $(_tmp.extend($features);)*\n+                        _tmp\n+                    },\n                 }).expect(\"expected to build -- essential tool\")\n             }\n         }\n@@ -359,7 +379,7 @@ macro_rules! bootstrap_tool {\n }\n \n bootstrap_tool!(\n-    Rustbook, \"src/tools/rustbook\", \"rustbook\";\n+    Rustbook, \"src/tools/rustbook\", \"rustbook\", features = rustbook_features();\n     UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\";\n     Tidy, \"src/tools/tidy\", \"tidy\";\n     Linkchecker, \"src/tools/linkchecker\", \"linkchecker\";"}, {"sha": "8035195c6ed0ae5cdee52296fa294ed6fde3c2d5", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -21,6 +21,9 @@ COPY x86_64-gnu-tools/checkregression.py /tmp/\n COPY x86_64-gnu-tools/checktools.sh /tmp/\n COPY x86_64-gnu-tools/repo.sh /tmp/\n \n+# Run rustbook with `linkcheck` feature enabled\n+ENV CHECK_LINKS 1\n+\n ENV RUST_CONFIGURE_ARGS \\\n   --build=x86_64-unknown-linux-gnu \\\n   --save-toolstates=/tmp/toolstates.json"}, {"sha": "266a0d055d5bc1a2a217fa8ccd40a86fcb181875", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -689,7 +689,10 @@ fn test_split_off_empty_left() {\n \n #[test]\n fn test_split_off_large_random_sorted() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let mut data = rand_data(1529);\n+    #[cfg(miri)]\n+    let mut data = rand_data(529);\n     // special case with maximum height.\n     data.sort();\n "}, {"sha": "62ccb53fcea18a936ce3f446489a5de54825adfe", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -10,7 +10,7 @@ fn test_clone_eq() {\n     m.insert(1);\n     m.insert(2);\n \n-    assert!(m.clone() == m);\n+    assert_eq!(m.clone(), m);\n }\n \n #[test]\n@@ -28,7 +28,7 @@ fn test_hash() {\n     y.insert(2);\n     y.insert(1);\n \n-    assert!(hash(&x) == hash(&y));\n+    assert_eq!(hash(&x), hash(&y));\n }\n \n fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n@@ -69,6 +69,11 @@ fn test_intersection() {\n     check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n                        &[2, 11, 77, -9, -42, 5, 3],\n                        &[3, 5, 11, 77]);\n+\n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     let large = (0..1000).collect::<Vec<_>>();\n     check_intersection(&[], &large, &[]);\n     check_intersection(&large, &[], &[]);\n@@ -98,6 +103,11 @@ fn test_difference() {\n     check_difference(&[-5, 11, 22, 33, 40, 42],\n                      &[-12, -5, 14, 23, 34, 38, 39, 50],\n                      &[11, 22, 33, 40, 42]);\n+\n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     let large = (0..1000).collect::<Vec<_>>();\n     check_difference(&[], &large, &[]);\n     check_difference(&[-1], &large, &[-1]);\n@@ -166,6 +176,17 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[1, 2], &[1]), false);\n     assert_eq!(is_subset(&[1, 2], &[1, 2]), true);\n     assert_eq!(is_subset(&[1, 2], &[2, 3]), false);\n+    assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n+                         &[-12, -5, 14, 23, 11, 34, 22, 38, 33, 42, 39, 40]),\n+               true);\n+    assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n+                         &[-12, -5, 14, 23, 34, 38, 22, 11]),\n+               false);\n+\n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     let large = (0..1000).collect::<Vec<_>>();\n     assert_eq!(is_subset(&[], &large), true);\n     assert_eq!(is_subset(&large, &[]), false);\n@@ -371,7 +392,10 @@ fn test_split_off_empty_left() {\n \n #[test]\n fn test_split_off_large_random_sorted() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let mut data = rand_data(1529);\n+    #[cfg(miri)]\n+    let mut data = rand_data(529);\n     // special case with maximum height.\n     data.sort();\n "}, {"sha": "667b35d0f775ac039de111572592d0aa1a4fb469", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -302,6 +302,7 @@ macro_rules! debug_assert_ne {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(since = \"1.39.0\", reason = \"use the `?` operator instead\")]\n #[doc(alias = \"?\")]\n macro_rules! r#try {\n     ($expr:expr) => (match $expr {\n@@ -767,7 +768,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro format_args {\n         ($fmt:expr) => ({ /* compiler built-in */ }),\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -779,7 +779,6 @@ pub(crate) mod builtin {\n                          language use and is subject to change\")]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro format_args_nl {\n         ($fmt:expr) => ({ /* compiler built-in */ }),\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })"}, {"sha": "46eacb4200acc154609d3a6f0aaa945d9d7c2d1a", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -77,6 +77,7 @@ fn infinity() {\n fn zero() {\n     test_literal!(0.0);\n     test_literal!(1e-325);\n+    #[cfg(not(miri))] // Miri is too slow\n     test_literal!(1e-326);\n     #[cfg(not(miri))] // Miri is too slow\n     test_literal!(1e-500);"}, {"sha": "c51451708f3ce132d5e5600b83c7d2da85548f42", "filename": "src/libcore/tests/num/flt2dec/estimator.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -42,7 +42,12 @@ fn test_estimate_scaling_factor() {\n     assert_almost_eq!(estimate_scaling_factor(1, -1074), -323);\n     assert_almost_eq!(estimate_scaling_factor(0x1fffffffffffff, 971), 309);\n \n-    for i in -1074..972 {\n+    #[cfg(not(miri))] // Miri is too slow\n+    let iter = -1074..972;\n+    #[cfg(miri)]\n+    let iter = (-1074..972).step_by(37);\n+\n+    for i in iter {\n         let expected = super::ldexp_f64(1.0, i).log10().ceil();\n         assert_almost_eq!(estimate_scaling_factor(1, i as i16), expected as i16);\n     }"}, {"sha": "c41d35efced6c908d9b3d8fc2057c948f06638e9", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -1,5 +1,3 @@\n-#![cfg(not(miri))] // Miri does not implement ldexp, which most tests here need\n-\n use std::prelude::v1::*;\n use std::{str, i16, f32, f64, fmt};\n \n@@ -257,6 +255,7 @@ pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     check_shortest!(f(minf32) => b\"1\", -44);\n }\n \n+#[cfg(not(miri))] // Miri is too slow\n pub fn f32_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     let minf32 = ldexp_f32(1.0, -149);\n@@ -362,6 +361,7 @@ pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     check_shortest!(f(minf64) => b\"5\", -323);\n }\n \n+#[cfg(not(miri))] // Miri is too slow\n pub fn f64_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     let minf64 = ldexp_f64(1.0, -1074);\n@@ -553,6 +553,10 @@ pub fn to_shortest_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, minf64, Minus, 324, false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, 325, false), format!(\"0.{:0>323}50\", \"\"));\n \n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     // very large output\n     assert_eq!(to_string(f, 1.1, Minus, 80000, false), format!(\"1.1{:0>79999}\", \"\"));\n }\n@@ -807,6 +811,10 @@ pub fn to_exact_exp_str_test<F>(mut f_: F)\n                \"1.401298464324817070923729583289916131280261941876515771757068283\\\n                  8897910826858606014866381883621215820312500000000000000000000000e-45\");\n \n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     assert_eq!(to_string(f, f64::MAX, Minus,   1, false), \"2e308\");\n     assert_eq!(to_string(f, f64::MAX, Minus,   2, false), \"1.8e308\");\n     assert_eq!(to_string(f, f64::MAX, Minus,   4, false), \"1.798e308\");\n@@ -1040,6 +1048,10 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 2, false),\n                \"340282346638528859811704183484516925440.00\");\n \n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     let minf32 = ldexp_f32(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,   0, false), \"0\");\n     assert_eq!(to_string(f, minf32, Minus,   1, false), \"0.0\");"}, {"sha": "d9543793397bfbef336e12b9b0f7a485cd9d4d99", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -109,8 +109,13 @@ pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n #[test]\n fn shortest_random_equivalence_test() {\n     use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n-    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n+    #[cfg(not(miri))] // Miri is too slow\n+    const N: usize = 10_000;\n+    #[cfg(miri)]\n+    const N: usize = 10;\n+\n+    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, N);\n+    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, N);\n }\n \n #[test] #[ignore] // it is too expensive\n@@ -138,17 +143,27 @@ fn shortest_f64_hard_random_equivalence_test() {\n #[test]\n fn exact_f32_random_equivalence_test() {\n     use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n+    #[cfg(not(miri))] // Miri is too slow\n+    const N: usize = 1_000;\n+    #[cfg(miri)]\n+    const N: usize = 3;\n+\n     for k in 1..21 {\n         f32_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n-                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n+                                             |d, buf| fallback(d, buf, i16::MIN), k, N);\n     }\n }\n \n #[test]\n fn exact_f64_random_equivalence_test() {\n     use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n+    #[cfg(not(miri))] // Miri is too slow\n+    const N: usize = 1_000;\n+    #[cfg(miri)]\n+    const N: usize = 3;\n+\n     for k in 1..21 {\n         f64_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n-                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n+                                             |d, buf| fallback(d, buf, i16::MIN), k, N);\n     }\n }"}, {"sha": "dc4d78bfae1096fac4de4641dda8e01c1576112f", "filename": "src/libcore/tests/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -23,6 +23,7 @@ fn shortest_sanity_test() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn exact_sanity_test() {\n     // This test ends up running what I can only assume is some corner-ish case\n     // of the `exp2` library function, defined in whatever C runtime we're"}, {"sha": "f8bdddfe2e4103e346ad6d5df9f75c044007d87d", "filename": "src/libcore/tests/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -36,6 +36,7 @@ fn shortest_sanity_test() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn exact_sanity_test() {\n     // See comments in dragon.rs's exact_sanity_test for why this test is\n     // ignored on MSVC"}, {"sha": "4790152512a396deee39fe8a6a77f21dc3c01963", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -3,19 +3,19 @@ use core::result::Result::{Ok, Err};\n #[test]\n fn test_position() {\n     let b = [1, 2, 3, 5, 5];\n-    assert!(b.iter().position(|&v| v == 9) == None);\n-    assert!(b.iter().position(|&v| v == 5) == Some(3));\n-    assert!(b.iter().position(|&v| v == 3) == Some(2));\n-    assert!(b.iter().position(|&v| v == 0) == None);\n+    assert_eq!(b.iter().position(|&v| v == 9), None);\n+    assert_eq!(b.iter().position(|&v| v == 5), Some(3));\n+    assert_eq!(b.iter().position(|&v| v == 3), Some(2));\n+    assert_eq!(b.iter().position(|&v| v == 0), None);\n }\n \n #[test]\n fn test_rposition() {\n     let b = [1, 2, 3, 5, 5];\n-    assert!(b.iter().rposition(|&v| v == 9) == None);\n-    assert!(b.iter().rposition(|&v| v == 5) == Some(4));\n-    assert!(b.iter().rposition(|&v| v == 3) == Some(2));\n-    assert!(b.iter().rposition(|&v| v == 0) == None);\n+    assert_eq!(b.iter().rposition(|&v| v == 9), None);\n+    assert_eq!(b.iter().rposition(|&v| v == 5), Some(4));\n+    assert_eq!(b.iter().rposition(|&v| v == 3), Some(2));\n+    assert_eq!(b.iter().rposition(|&v| v == 0), None);\n }\n \n #[test]\n@@ -1153,7 +1153,7 @@ fn test_rotate_right() {\n }\n \n #[test]\n-#[cfg(not(miri))]\n+#[cfg(not(miri))] // Miri is too slow\n fn brute_force_rotate_test_0() {\n     // In case of edge cases involving multiple algorithms\n     let n = 300;"}, {"sha": "fac70c468c89d77cf6db8e778e76662e5cfb2d04", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -2,7 +2,7 @@ use core::time::Duration;\n \n #[test]\n fn creation() {\n-    assert!(Duration::from_secs(1) != Duration::from_secs(0));\n+    assert_ne!(Duration::from_secs(1), Duration::from_secs(0));\n     assert_eq!(Duration::from_secs(1) + Duration::from_secs(2),\n                Duration::from_secs(3));\n     assert_eq!(Duration::from_millis(10) + Duration::from_secs(4),"}, {"sha": "3fae3a46ada6b7c20be05f336bdb4d2b82745cb8", "filename": "src/libcore/unicode/tables.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -14,8 +14,8 @@ pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n     micro: 0,\n     _priv: (),\n };\n-pub mod general_category {\n-    pub const Cc_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n+pub(crate) mod general_category {\n+    const Cc_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 0\n         ],\n@@ -28,7 +28,7 @@ pub mod general_category {\n         Cc_table.lookup(c)\n     }\n \n-    pub const N_table: &super::BoolTrie = &super::BoolTrie {\n+    const N_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x03ff000000000000, 0x0000000000000000, 0x720c000000000000, 0x0000000000000000,\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -141,8 +141,8 @@ pub mod general_category {\n \n }\n \n-pub mod derived_property {\n-    pub const Alphabetic_table: &super::BoolTrie = &super::BoolTrie {\n+pub(crate) mod derived_property {\n+    const Alphabetic_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n@@ -327,7 +327,7 @@ pub mod derived_property {\n         Alphabetic_table.lookup(c)\n     }\n \n-    pub const Case_Ignorable_table: &super::BoolTrie = &super::BoolTrie {\n+    const Case_Ignorable_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0400408000000000, 0x0000000140000000, 0x0190a10000000000, 0x0000000000000000,\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -464,7 +464,7 @@ pub mod derived_property {\n         Case_Ignorable_table.lookup(c)\n     }\n \n-    pub const Cased_table: &super::BoolTrie = &super::BoolTrie {\n+    const Cased_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xf7ffffffffffffff, 0xfffffffffffffff0,\n@@ -565,7 +565,7 @@ pub mod derived_property {\n         Cased_table.lookup(c)\n     }\n \n-    pub const Grapheme_Extend_table: &super::BoolTrie = &super::BoolTrie {\n+    const Grapheme_Extend_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -689,7 +689,7 @@ pub mod derived_property {\n         Grapheme_Extend_table.lookup(c)\n     }\n \n-    pub const Lowercase_table: &super::BoolTrie = &super::BoolTrie {\n+    const Lowercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe00000000, 0x0420040000000000, 0xff7fffff80000000,\n             0x55aaaaaaaaaaaaaa, 0xd4aaaaaaaaaaab55, 0xe6512d2a4e243129, 0xaa29aaaab5555240,\n@@ -789,7 +789,7 @@ pub mod derived_property {\n         Lowercase_table.lookup(c)\n     }\n \n-    pub const Uppercase_table: &super::BoolTrie = &super::BoolTrie {\n+    const Uppercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x0000000007fffffe, 0x0000000000000000, 0x000000007f7fffff,\n             0xaa55555555555555, 0x2b555555555554aa, 0x11aed2d5b1dbced6, 0x55d255554aaaa490,\n@@ -890,7 +890,7 @@ pub mod derived_property {\n         Uppercase_table.lookup(c)\n     }\n \n-    pub const XID_Continue_table: &super::BoolTrie = &super::BoolTrie {\n+    const XID_Continue_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x03ff000000000000, 0x07fffffe87fffffe, 0x04a0040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n@@ -1068,7 +1068,7 @@ pub mod derived_property {\n         XID_Continue_table.lookup(c)\n     }\n \n-    pub const XID_Start_table: &super::BoolTrie = &super::BoolTrie {\n+    const XID_Start_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n@@ -1250,8 +1250,8 @@ pub mod derived_property {\n \n }\n \n-pub mod property {\n-    pub const Pattern_White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n+pub(crate) mod property {\n+    const Pattern_White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n@@ -1268,7 +1268,7 @@ pub mod property {\n         Pattern_White_Space_table.lookup(c)\n     }\n \n-    pub const White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n+    const White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n@@ -1290,7 +1290,7 @@ pub mod property {\n \n }\n \n-pub mod conversions {\n+pub(crate) mod conversions {\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n             None        => [c, '\\0', '\\0'],"}, {"sha": "6de5d9e033b9309bd47e336cc6c4a162839ed55f", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -606,7 +606,7 @@ def compute_trie(raw_data, chunk_size):\n     return root, child_data\n \n \n-def generate_bool_trie(name, codepoint_ranges, is_pub=True):\n+def generate_bool_trie(name, codepoint_ranges, is_pub=False):\n     # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n     \"\"\"\n     Generate Rust code for BoolTrie struct.\n@@ -681,7 +681,7 @@ def generate_bool_trie(name, codepoint_ranges, is_pub=True):\n     yield \"    };\\n\\n\"\n \n \n-def generate_small_bool_trie(name, codepoint_ranges, is_pub=True):\n+def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n     # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n     \"\"\"\n     Generate Rust code for `SmallBoolTrie` struct.\n@@ -726,7 +726,7 @@ def generate_property_module(mod, grouped_categories, category_subset):\n     Generate Rust code for module defining properties.\n     \"\"\"\n \n-    yield \"pub mod %s {\\n\" % mod\n+    yield \"pub(crate) mod %s {\\n\" % mod\n     for cat in sorted(category_subset):\n         if cat in (\"Cc\", \"White_Space\", \"Pattern_White_Space\"):\n             generator = generate_small_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n@@ -749,7 +749,7 @@ def generate_conversions_module(unicode_data):\n     Generate Rust code for module defining conversions.\n     \"\"\"\n \n-    yield \"pub mod conversions {\"\n+    yield \"pub(crate) mod conversions {\"\n     yield \"\"\"\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {"}, {"sha": "9dce61492dab55066e1056897c2596ece03df41f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 159, "deletions": 31, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -229,6 +229,13 @@ fn def_id_visibility<'tcx>(\n             let vis = match tcx.hir().get(hir_id) {\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n+                Node::MacroDef(macro_def) => {\n+                    if attr::contains_name(&macro_def.attrs, sym::macro_export) {\n+                        return (ty::Visibility::Public, macro_def.span, \"public\");\n+                    } else {\n+                        &macro_def.vis\n+                    }\n+                },\n                 Node::TraitItem(..) | Node::Variant(..) => {\n                     return def_id_visibility(tcx, tcx.hir().get_parent_did(hir_id));\n                 }\n@@ -433,11 +440,24 @@ impl VisibilityLike for Option<AccessLevel> {\n struct EmbargoVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    // Accessibility levels for reachable nodes.\n+    /// Accessibility levels for reachable nodes.\n     access_levels: AccessLevels,\n-    // Previous accessibility level; `None` means unreachable.\n+    /// A set of pairs corresponding to modules, where the first module is\n+    /// reachable via a macro that's defined in the second module. This cannot\n+    /// be represented as reachable because it can't handle the following case:\n+    ///\n+    /// pub mod n {                         // Should be `Public`\n+    ///     pub(crate) mod p {              // Should *not* be accessible\n+    ///         pub fn f() -> i32 { 12 }    // Must be `Reachable`\n+    ///     }\n+    /// }\n+    /// pub macro m() {\n+    ///     n::p::f()\n+    /// }\n+    macro_reachable: FxHashSet<(hir::HirId, DefId)>,\n+    /// Previous accessibility level; `None` means unreachable.\n     prev_level: Option<AccessLevel>,\n-    // Has something changed in the level map?\n+    /// Has something changed in the level map?\n     changed: bool,\n }\n \n@@ -452,7 +472,7 @@ impl EmbargoVisitor<'tcx> {\n         self.access_levels.map.get(&id).cloned()\n     }\n \n-    // Updates node level and returns the updated level.\n+    /// Updates node level and returns the updated level.\n     fn update(&mut self, id: hir::HirId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n         let old_level = self.get(id);\n         // Accessibility levels can only grow.\n@@ -477,6 +497,127 @@ impl EmbargoVisitor<'tcx> {\n         }\n     }\n \n+    /// Updates the item as being reachable through a macro defined in the given\n+    /// module. Returns `true` if the level has changed.\n+    fn update_macro_reachable(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) -> bool {\n+        if self.macro_reachable.insert((reachable_mod, defining_mod)) {\n+            self.update_macro_reachable_mod(reachable_mod, defining_mod);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn update_macro_reachable_mod(\n+        &mut self,\n+        reachable_mod: hir::HirId,\n+        defining_mod: DefId,\n+    ) {\n+        let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n+        let module = self.tcx.hir().get_module(module_def_id).0;\n+        for item_id in &module.item_ids {\n+            let hir_id = item_id.id;\n+            let item_def_id = self.tcx.hir().local_def_id(hir_id);\n+            if let Some(def_kind) = self.tcx.def_kind(item_def_id) {\n+                let item = self.tcx.hir().expect_item(hir_id);\n+                let vis = ty::Visibility::from_hir(&item.vis, hir_id, self.tcx);\n+                self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n+            }\n+        }\n+\n+        if let Some(exports) = self.tcx.module_exports(module_def_id) {\n+            for export in exports {\n+                if export.vis.is_accessible_from(defining_mod, self.tcx) {\n+                    if let Res::Def(def_kind, def_id) = export.res {\n+                        let vis = def_id_visibility(self.tcx, def_id).0;\n+                        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                            self.update_macro_reachable_def(\n+                                hir_id,\n+                                def_kind,\n+                                vis,\n+                                defining_mod,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn update_macro_reachable_def(\n+        &mut self,\n+        hir_id: hir::HirId,\n+        def_kind: DefKind,\n+        vis: ty::Visibility,\n+        module: DefId,\n+    ) {\n+        let level = Some(AccessLevel::Reachable);\n+        if let ty::Visibility::Public = vis {\n+            self.update(hir_id, level);\n+        }\n+        match def_kind {\n+            // No type privacy, so can be directly marked as reachable.\n+            DefKind::Const\n+            | DefKind::Macro(_)\n+            | DefKind::Static\n+            | DefKind::TraitAlias\n+            | DefKind::TyAlias => {\n+                if vis.is_accessible_from(module, self.tcx) {\n+                    self.update(hir_id, level);\n+                }\n+            },\n+\n+            // We can't use a module name as the final segment of a path, except\n+            // in use statements. Since re-export checking doesn't consider\n+            // hygiene these don't need to be marked reachable. The contents of\n+            // the module, however may be reachable.\n+            DefKind::Mod => {\n+                if vis.is_accessible_from(module, self.tcx) {\n+                    self.update_macro_reachable(hir_id, module);\n+                }\n+            }\n+\n+            DefKind::Struct | DefKind::Union => {\n+                // While structs and unions have type privacy, their fields do\n+                // not.\n+                if let ty::Visibility::Public = vis {\n+                    let item = self.tcx.hir().expect_item(hir_id);\n+                    if let hir::ItemKind::Struct(ref struct_def, _)\n+                        | hir::ItemKind::Union(ref struct_def, _) = item.node\n+                    {\n+                        for field in struct_def.fields() {\n+                            let field_vis = ty::Visibility::from_hir(\n+                                &field.vis,\n+                                field.hir_id,\n+                                self.tcx,\n+                            );\n+                            if field_vis.is_accessible_from(module, self.tcx) {\n+                                self.reach(field.hir_id, level).ty();\n+                            }\n+                        }\n+                    } else {\n+                        bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n+                    }\n+                }\n+            }\n+\n+            // These have type privacy, so are not reachable unless they're\n+            // public\n+            DefKind::AssocConst\n+            | DefKind::AssocTy\n+            | DefKind::AssocOpaqueTy\n+            | DefKind::ConstParam\n+            | DefKind::Ctor(_, _)\n+            | DefKind::Enum\n+            | DefKind::ForeignTy\n+            | DefKind::Fn\n+            | DefKind::OpaqueTy\n+            | DefKind::Method\n+            | DefKind::Trait\n+            | DefKind::TyParam\n+            | DefKind::Variant => (),\n+        }\n+    }\n \n     /// Given the path segments of a `ItemKind::Use`, then we need\n     /// to update the visibility of the intermediate use so that it isn't linted\n@@ -746,40 +887,21 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             return\n         }\n \n-        let module_did = ty::DefIdTree::parent(\n+        let macro_module_def_id = ty::DefIdTree::parent(\n             self.tcx,\n             self.tcx.hir().local_def_id(md.hir_id)\n         ).unwrap();\n-        let mut module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n+        let mut module_id = self.tcx.hir().as_local_hir_id(macro_module_def_id).unwrap();\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n-        let level = self.update(md.hir_id, level);\n-        if level.is_none() {\n+        let new_level = self.update(md.hir_id, level);\n+        if new_level.is_none() {\n             return\n         }\n \n         loop {\n-            let module = if module_id == hir::CRATE_HIR_ID {\n-                &self.tcx.hir().krate().module\n-            } else if let hir::ItemKind::Mod(ref module) =\n-                          self.tcx.hir().expect_item(module_id).node {\n-                module\n-            } else {\n-                unreachable!()\n-            };\n-            for id in &module.item_ids {\n-                self.update(id.id, level);\n-            }\n-            let def_id = self.tcx.hir().local_def_id(module_id);\n-            if let Some(exports) = self.tcx.module_exports(def_id) {\n-                for export in exports.iter() {\n-                    if let Some(hir_id) = self.tcx.hir().as_local_hir_id(export.res.def_id()) {\n-                        self.update(hir_id, level);\n-                    }\n-                }\n-            }\n-\n-            if module_id == hir::CRATE_HIR_ID {\n-                break\n+            let changed_reachability = self.update_macro_reachable(module_id, macro_module_def_id);\n+            if changed_reachability || module_id == hir::CRATE_HIR_ID {\n+                break;\n             }\n             module_id = self.tcx.hir().get_parent_node(module_id);\n         }\n@@ -826,7 +948,12 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> { self.ev.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n-            self.ev.update(hir_id, self.access_level);\n+            if let ((ty::Visibility::Public, ..), _)\n+                | (_, Some(AccessLevel::ReachableFromImplTrait))\n+                = (def_id_visibility(self.tcx(), def_id), self.access_level)\n+            {\n+                self.ev.update(hir_id, self.access_level);\n+            }\n         }\n         false\n     }\n@@ -1865,6 +1992,7 @@ fn privacy_access_levels(tcx: TyCtxt<'_>, krate: CrateNum) -> &AccessLevels {\n     let mut visitor = EmbargoVisitor {\n         tcx,\n         access_levels: Default::default(),\n+        macro_reachable: Default::default(),\n         prev_level: Some(AccessLevel::Public),\n         changed: false,\n     };"}, {"sha": "54abf72d3075a8f2d8880b8e6e2bab4b0d4adc03", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -330,7 +330,11 @@ use prelude::v1::*;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::{assert_eq, assert_ne, debug_assert, debug_assert_eq, debug_assert_ne};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::{unreachable, unimplemented, write, writeln, r#try, todo};\n+pub use core::{unreachable, unimplemented, write, writeln, todo};\n+// FIXME: change this to `#[allow(deprecated)]` when we update nightly compiler.\n+#[allow(deprecated_in_future)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::r#try;\n \n #[allow(unused_imports)] // macros from `alloc` are not used on all platforms\n #[macro_use]"}, {"sha": "2ae13b66e28536d3741ff09db6fb3946f7433e61", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -645,7 +645,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut heads = Vec::with_capacity(self.args.len());\n \n         let names_pos: Vec<_> = (0..self.args.len())\n-            .map(|i| self.ecx.ident_of(&format!(\"arg{}\", i)).gensym())\n+            .map(|i| ast::Ident::from_str_and_span(&format!(\"arg{}\", i), self.macsp))\n             .collect();\n \n         // First, build up the static array which will become our precompiled\n@@ -842,7 +842,7 @@ pub fn expand_preparsed_format_args(\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n \n     let mut macsp = ecx.call_site();\n-    macsp = macsp.apply_mark(ecx.current_expansion.id);\n+    macsp = macsp.with_ctxt(ecx.backtrace());\n \n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;"}, {"sha": "964ddc9b625deb52b2a1c794c23a7b96c917ed0b", "filename": "src/test/ui/associated-types/cache/chrono-scan.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fchrono-scan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fchrono-scan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fchrono-scan.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n \n+#![allow(deprecated)]\n+\n pub type ParseResult<T> = Result<T, ()>;\n \n pub enum Item<'a> {"}, {"sha": "30ba70bdfeb66bc3699c0d74edbe73003adb1f05", "filename": "src/test/ui/definition-reachable/auxiliary/field-method-macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Ffield-method-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Ffield-method-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Ffield-method-macro.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,23 @@\n+#![feature(decl_macro)]\n+\n+mod n {\n+    pub struct B(pub(crate) p::C);\n+    impl B {\n+        pub fn new() -> Self {\n+            B(p::C)\n+        }\n+    }\n+    mod p {\n+        pub struct C;\n+\n+        impl C {\n+            pub fn foo(&self) -> i32 {\n+                33\n+            }\n+        }\n+    }\n+}\n+\n+pub macro m() {\n+    n::B::new().0.foo()\n+}"}, {"sha": "a39e8c986c3911df50ec764a1c49a886f7d38b61", "filename": "src/test/ui/definition-reachable/auxiliary/nested-fn-macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fnested-fn-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fnested-fn-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fnested-fn-macro.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,11 @@\n+#![feature(decl_macro)]\n+\n+mod n {\n+    pub(crate) mod p {\n+        pub fn f() -> i32 { 12 }\n+    }\n+}\n+\n+pub macro m() {\n+    n::p::f()\n+}"}, {"sha": "4f283d9c19c04f55b7533321c0aff385afa04fb4", "filename": "src/test/ui/definition-reachable/auxiliary/private-use-macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fprivate-use-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fprivate-use-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fprivate-use-macro.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,11 @@\n+#![feature(decl_macro)]\n+\n+mod n {\n+    pub static S: i32 = 57;\n+}\n+\n+use n::S;\n+\n+pub macro m() {\n+    S\n+}"}, {"sha": "60e895a2f9a0742db232c47f95de091562c1a320", "filename": "src/test/ui/definition-reachable/field-method.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Ffield-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Ffield-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Ffield-method.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,11 @@\n+// Check that functions accessible through a field visible to a macro are\n+// considered reachable\n+\n+// aux-build:nested-fn-macro.rs\n+// run-pass\n+\n+extern crate nested_fn_macro;\n+\n+fn main() {\n+    assert_eq!(nested_fn_macro::m!(), 12);\n+}"}, {"sha": "b596ba8936a4391142680f3aceccd3970f9819ee", "filename": "src/test/ui/definition-reachable/nested-fn.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fnested-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fnested-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fnested-fn.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,11 @@\n+// Check that functions visible to macros through paths with >2 segements are\n+// considered reachable\n+\n+// aux-build:field-method-macro.rs\n+// run-pass\n+\n+extern crate field_method_macro;\n+\n+fn main() {\n+    assert_eq!(field_method_macro::m!(), 33);\n+}"}, {"sha": "a601dabcb0b3fdfe9643ea4b358ff68aa791340e", "filename": "src/test/ui/definition-reachable/private-non-types.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-non-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-non-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-non-types.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,21 @@\n+// Check that we don't require stability annotations for private modules,\n+// imports and fields that are accessible to opaque macros.\n+\n+// check-pass\n+\n+#![feature(decl_macro, staged_api)]\n+#![stable(feature = \"test\", since = \"1.0.0\")]\n+\n+extern crate std as local_std;\n+use local_std::marker::Copy as LocalCopy;\n+mod private_mod {\n+    #[stable(feature = \"test\", since = \"1.0.0\")]\n+    pub struct A {\n+        pub(crate) f: i32,\n+    }\n+}\n+\n+#[stable(feature = \"test\", since = \"1.0.0\")]\n+pub macro m() {}\n+\n+fn main() {}"}, {"sha": "02c1224f4e142e63ce23836a49e6c3eb382eb8de", "filename": "src/test/ui/definition-reachable/private-types.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-types.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,19 @@\n+// Check that type privacy is taken into account when considering reachability\n+\n+// check-pass\n+\n+#![feature(decl_macro, staged_api)]\n+#![stable(feature = \"test\", since = \"1.0.0\")]\n+\n+// Type privacy should prevent use of these in other crates, so we shouldn't\n+// need a stability annotation.\n+fn private_function() {}\n+struct PrivateStruct { f: () }\n+enum PrivateEnum { V }\n+union PrivateUnion { g: () }\n+trait PrivateTrait {}\n+\n+#[stable(feature = \"test\", since = \"1.0.0\")]\n+pub macro m() {}\n+\n+fn main() {}"}, {"sha": "02cff0475e586447cd657de642cc20db47a1abbd", "filename": "src/test/ui/definition-reachable/private-use.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-use.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,10 @@\n+// Check that private use statements can be used by\n+\n+// run-pass\n+// aux-build:private-use-macro.rs\n+\n+extern crate private_use_macro;\n+\n+fn main() {\n+    assert_eq!(private_use_macro::m!(), 57);\n+}"}, {"sha": "ff619313afb5be53f227836ef027f2254adb8dda", "filename": "src/test/ui/derived-errors/issue-31997.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -1,5 +1,6 @@\n // Test that the resolve failure does not lead to downstream type errors.\n // See issue #31997.\n+#![allow(deprecated)]\n \n trait TheTrait { }\n "}, {"sha": "b53c0cda8de4de3f14bf91351ff566faf64593bf", "filename": "src/test/ui/derived-errors/issue-31997.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997.stderr?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -1,5 +1,5 @@\n error[E0425]: cannot find function `bar` in this scope\n-  --> $DIR/issue-31997.rs:13:21\n+  --> $DIR/issue-31997.rs:14:21\n    |\n LL |     try!(closure(|| bar(core::ptr::null_mut())));\n    |                     ^^^ not found in this scope"}, {"sha": "6bf5ae8beaddb91a9984df5187eab1198443f79e", "filename": "src/test/ui/format-hygiene.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/813a3a5d4b2be4e2101faa73a067da02a704a598/src%2Ftest%2Fui%2Fformat-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/813a3a5d4b2be4e2101faa73a067da02a704a598/src%2Ftest%2Fui%2Fformat-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fformat-hygiene.rs?ref=813a3a5d4b2be4e2101faa73a067da02a704a598", "patch": "@@ -1,8 +0,0 @@\n-// run-pass\n-\n-#![allow(non_upper_case_globals)]\n-pub const arg0: u8 = 1;\n-\n-pub fn main() {\n-    format!(\"{}\", 1);\n-}"}, {"sha": "d74889b95cc12de3a8ce704f6381ada6e564953f", "filename": "src/test/ui/hygiene/format-args.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fhygiene%2Fformat-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fhygiene%2Fformat-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fformat-args.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![allow(non_upper_case_globals)]\n+#![feature(format_args_nl)]\n+\n+static arg0: () = ();\n+\n+fn main() {\n+    static arg1: () = ();\n+    format_args!(\"{} {:?}\", 0, 1);\n+    format_args_nl!(\"{} {:?}\", 0, 1);\n+}"}, {"sha": "b259e9e269d06836ad5447cd5ca074da0f7f260d", "filename": "src/test/ui/issues/issue-43623.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fissues%2Fissue-43623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fissues%2Fissue-43623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43623.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,19 @@\n+pub trait Trait<'a> {\n+    type Assoc;\n+}\n+\n+pub struct Type;\n+\n+impl<'a> Trait<'a> for Type {\n+    type Assoc = ();\n+}\n+\n+pub fn break_me<T, F>(f: F)\n+where T: for<'b> Trait<'b>,\n+      F: for<'b> FnMut(<T as Trait<'b>>::Assoc) {\n+    break_me::<Type, fn(_)>;\n+    //~^ ERROR: type mismatch in function arguments\n+    //~| ERROR: type mismatch resolving\n+}\n+\n+fn main() {}"}, {"sha": "b5674105f75d22e5f432dd5663c046027d0da1d8", "filename": "src/test/ui/issues/issue-43623.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fissues%2Fissue-43623.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fissues%2Fissue-43623.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43623.stderr?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,42 @@\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/issue-43623.rs:14:5\n+   |\n+LL |     break_me::<Type, fn(_)>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected signature of `for<'b> fn(<Type as Trait<'b>>::Assoc) -> _`\n+   |     found signature of `fn(_) -> _`\n+   |\n+note: required by `break_me`\n+  --> $DIR/issue-43623.rs:11:1\n+   |\n+LL | / pub fn break_me<T, F>(f: F)\n+LL | | where T: for<'b> Trait<'b>,\n+LL | |       F: for<'b> FnMut(<T as Trait<'b>>::Assoc) {\n+LL | |     break_me::<Type, fn(_)>;\n+LL | |\n+LL | |\n+LL | | }\n+   | |_^\n+\n+error[E0271]: type mismatch resolving `for<'b> <fn(_) as std::ops::FnOnce<(<Type as Trait<'b>>::Assoc,)>>::Output == ()`\n+  --> $DIR/issue-43623.rs:14:5\n+   |\n+LL |     break_me::<Type, fn(_)>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'b, found concrete lifetime\n+   |\n+note: required by `break_me`\n+  --> $DIR/issue-43623.rs:11:1\n+   |\n+LL | / pub fn break_me<T, F>(f: F)\n+LL | | where T: for<'b> Trait<'b>,\n+LL | |       F: for<'b> FnMut(<T as Trait<'b>>::Assoc) {\n+LL | |     break_me::<Type, fn(_)>;\n+LL | |\n+LL | |\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "d404b9044dd6f9260e2883c01838371ba4b65726", "filename": "src/test/ui/issues/issue-44405.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fissues%2Fissue-44405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fissues%2Fissue-44405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44405.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,22 @@\n+use std::ops::Index;\n+\n+struct Test;\n+struct Container(Test);\n+\n+impl Test {\n+    fn test(&mut self) {}\n+}\n+\n+impl<'a> Index<&'a bool> for Container {\n+    type Output = Test;\n+\n+    fn index(&self, _index: &'a bool) -> &Test {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let container = Container(Test);\n+    let mut val = true;\n+    container[&mut val].test(); //~ ERROR: cannot borrow data\n+}"}, {"sha": "1fd69f6e77799c7738c0d6ca04bcd672690460de", "filename": "src/test/ui/issues/issue-44405.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fissues%2Fissue-44405.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fissues%2Fissue-44405.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44405.stderr?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -0,0 +1,11 @@\n+error[E0596]: cannot borrow data in an index of `Container` as mutable\n+  --> $DIR/issue-44405.rs:21:5\n+   |\n+LL |     container[&mut val].test();\n+   |     ^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n+   |\n+   = help: trait `IndexMut` is required to modify indexed content, but it is not implemented for `Container`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "1b24191a111c2b051322709afdcbc324a76648de", "filename": "src/test/ui/lint/lint-qualification.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Flint%2Flint-qualification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Flint%2Flint-qualification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-qualification.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -1,4 +1,5 @@\n #![deny(unused_qualifications)]\n+#[allow(deprecated)]\n \n mod foo {\n     pub fn bar() {}"}, {"sha": "125aeb3db0366761c561c1ad8a171ea3ab45828c", "filename": "src/test/ui/lint/lint-qualification.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Flint%2Flint-qualification.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Flint%2Flint-qualification.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-qualification.stderr?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -1,5 +1,5 @@\n error: unnecessary qualification\n-  --> $DIR/lint-qualification.rs:9:5\n+  --> $DIR/lint-qualification.rs:10:5\n    |\n LL |     foo::bar();\n    |     ^^^^^^^^"}, {"sha": "50c0ef3451d3d834f5af038eb8bdfd14ef2e2586", "filename": "src/test/ui/macros/macro-comma-support-rpass.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-support-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-support-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-support-rpass.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -15,6 +15,7 @@\n \n #![cfg_attr(core, no_std)]\n \n+#![allow(deprecated)] // for deprecated `try!()` macro\n #![feature(concat_idents)]\n \n #[cfg(std)] use std::fmt;"}, {"sha": "824c77d9de528ade70a8f5dcc5cd2398c98ec43b", "filename": "src/test/ui/macros/try-macro.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fmacros%2Ftry-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Fmacros%2Ftry-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftry-macro.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(deprecated)] // for deprecated `try!()` macro\n use std::num::{ParseFloatError, ParseIntError};\n \n fn main() {"}, {"sha": "a7b7d3faf5ee93ae2c694decddca2d1eb79faca6", "filename": "src/test/ui/rust-2018/try-macro.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.fixed?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -6,6 +6,7 @@\n #![warn(rust_2018_compatibility)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n+#![allow(deprecated)]\n \n fn foo() -> Result<usize, ()> {\n     let x: Result<usize, ()> = Ok(22);"}, {"sha": "986e158eb644e6b839816f9d2acc04af449dc670", "filename": "src/test/ui/rust-2018/try-macro.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -6,6 +6,7 @@\n #![warn(rust_2018_compatibility)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n+#![allow(deprecated)]\n \n fn foo() -> Result<usize, ()> {\n     let x: Result<usize, ()> = Ok(22);"}, {"sha": "fad1bb9f1b06829f5f23fd0c0ccfdb463614f921", "filename": "src/test/ui/rust-2018/try-macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.stderr?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -1,5 +1,5 @@\n warning: `try` is a keyword in the 2018 edition\n-  --> $DIR/try-macro.rs:12:5\n+  --> $DIR/try-macro.rs:13:5\n    |\n LL |     try!(x);\n    |     ^^^ help: you can use a raw identifier to stay compatible: `r#try`"}, {"sha": "a7188f0d11eac264ff3eba66eeffe7e05b4bee2a", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -5,14 +5,15 @@ version = \"0.1.0\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2018\"\n \n+[features]\n+linkcheck = [\"mdbook-linkcheck\"]\n+\n [dependencies]\n clap = \"2.25.0\"\n failure = \"0.1\"\n+mdbook-linkcheck = { version = \"0.3.0\", optional = true }\n \n [dependencies.mdbook]\n version = \"0.3.0\"\n default-features = false\n features = [\"search\"]\n-\n-[target.'cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))'.dependencies]\n-mdbook-linkcheck = \"0.3.0\""}, {"sha": "95530b210afd6cb0ce8cac88994e8424c287d8d3", "filename": "src/tools/rustbook/src/main.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534b42394d743511db1335d5ed08d507ab7c6e73/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs?ref=534b42394d743511db1335d5ed08d507ab7c6e73", "patch": "@@ -8,10 +8,9 @@ use clap::{App, ArgMatches, SubCommand, AppSettings};\n use mdbook::MDBook;\n use mdbook::errors::{Result as Result3};\n \n-#[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))]\n+#[cfg(feature = \"linkcheck\")]\n use mdbook::renderer::RenderContext;\n-\n-#[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))]\n+#[cfg(feature = \"linkcheck\")]\n use mdbook_linkcheck::{self, errors::BrokenLinks};\n use failure::Error;\n \n@@ -52,7 +51,7 @@ fn main() {\n             if let Err(err) = linkcheck(sub_matches) {\n                 eprintln!(\"Error: {}\", err);\n \n-                #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))]\n+                #[cfg(feature = \"linkcheck\")]\n                 {\n                     if let Ok(broken_links) = err.downcast::<BrokenLinks>() {\n                         for cause in broken_links.links().iter() {\n@@ -68,7 +67,7 @@ fn main() {\n     };\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))]\n+#[cfg(feature = \"linkcheck\")]\n pub fn linkcheck(args: &ArgMatches<'_>) -> Result<(), Error> {\n     let book_dir = get_book_dir(args);\n     let book = MDBook::load(&book_dir).unwrap();\n@@ -78,9 +77,9 @@ pub fn linkcheck(args: &ArgMatches<'_>) -> Result<(), Error> {\n     mdbook_linkcheck::check_links(&render_ctx)\n }\n \n-#[cfg(not(all(target_arch = \"x86_64\", target_os = \"linux\")))]\n+#[cfg(not(feature = \"linkcheck\"))]\n pub fn linkcheck(_args: &ArgMatches<'_>) -> Result<(), Error> {\n-    println!(\"mdbook-linkcheck only works on x86_64 linux targets.\");\n+    println!(\"mdbook-linkcheck is disabled.\");\n     Ok(())\n }\n "}]}