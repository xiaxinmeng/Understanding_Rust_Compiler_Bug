{"sha": "22a5125a367eedc9f1d6b49bac6557a4b4864423", "node_id": "C_kwDOAAsO6NoAKDIyYTUxMjVhMzY3ZWVkYzlmMWQ2YjQ5YmFjNjU1N2E0YjQ4NjQ0MjM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-15T01:29:12Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-02-16T04:14:45Z"}, "message": "Remove save-analysis.\n\nMost tests involving save-analysis were removed, but I kept a few where\nthe `-Zsave-analysis` was an add-on to the main thing being tested,\nrather than the main thing being tested.\n\nFor `x.py install`, the `rust-analysis` target has been removed.\n\nFor `x.py dist`, the `rust-analysis` target has been kept in a\ndegenerate form: it just produces a single file `reduced.json`\nindicating that save-analysis has been removed. This is necessary for\nrustup to keep working.\n\nCloses #43606.", "tree": {"sha": "7dcad5a8f0f164618b919e5dea7daad51323b54b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dcad5a8f0f164618b919e5dea7daad51323b54b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22a5125a367eedc9f1d6b49bac6557a4b4864423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22a5125a367eedc9f1d6b49bac6557a4b4864423", "html_url": "https://github.com/rust-lang/rust/commit/22a5125a367eedc9f1d6b49bac6557a4b4864423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22a5125a367eedc9f1d6b49bac6557a4b4864423/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc7a676778706bde3b50ff6d4fe81e2955bd4847", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7a676778706bde3b50ff6d4fe81e2955bd4847", "html_url": "https://github.com/rust-lang/rust/commit/dc7a676778706bde3b50ff6d4fe81e2955bd4847"}], "stats": {"total": 5265, "additions": 50, "deletions": 5215}, "files": [{"sha": "6a1525f7530d8950cce9fb44f368f862258cd595", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -3495,25 +3495,6 @@ dependencies = [\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"rls-data\"\n-version = \"0.19.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a58135eb039f3a3279a33779192f0ee78b56f57ae636e25cec83530e41debb99\"\n-dependencies = [\n- \"rls-span\",\n- \"serde\",\n-]\n-\n-[[package]]\n-name = \"rls-span\"\n-version = \"0.5.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f0eea58478fc06e15f71b03236612173a1b81e9770314edecfa664375e3e4c86\"\n-dependencies = [\n- \"serde\",\n-]\n-\n [[package]]\n name = \"rust-demangler\"\n version = \"0.0.1\"\n@@ -3965,7 +3946,6 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_parse\",\n  \"rustc_plugin_impl\",\n- \"rustc_save_analysis\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4625,27 +4605,6 @@ dependencies = [\n  \"tracing\",\n ]\n \n-[[package]]\n-name = \"rustc_save_analysis\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rls-data\",\n- \"rls-span\",\n- \"rustc_ast\",\n- \"rustc_ast_pretty\",\n- \"rustc_data_structures\",\n- \"rustc_errors\",\n- \"rustc_hir\",\n- \"rustc_hir_pretty\",\n- \"rustc_lexer\",\n- \"rustc_macros\",\n- \"rustc_middle\",\n- \"rustc_session\",\n- \"rustc_span\",\n- \"serde_json\",\n- \"tracing\",\n-]\n-\n [[package]]\n name = \"rustc_serialize\"\n version = \"0.0.0\""}, {"sha": "cdec4f912779cd90926f017751c01b679c92cbef", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -22,7 +22,6 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n-rustc_save_analysis = { path = \"../rustc_save_analysis\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_error_codes = { path = \"../rustc_error_codes\" }"}, {"sha": "1a4fe07b47656af786bca9d5bfecb3fde3225460", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -25,13 +25,10 @@ use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{ErrorGuaranteed, PResult, TerminalUrl};\n use rustc_feature::find_gated_cfg;\n-use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n use rustc_metadata::locator;\n-use rustc_save_analysis as save;\n-use rustc_save_analysis::DumpHandler;\n use rustc_session::config::{nightly_options, CG_OPTIONS, Z_OPTIONS};\n use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n use rustc_session::cstore::MetadataLoader;\n@@ -343,22 +340,7 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            queries.global_ctxt()?.enter(|tcx| {\n-                let result = tcx.analysis(());\n-                if sess.opts.unstable_opts.save_analysis {\n-                    let crate_name = tcx.crate_name(LOCAL_CRATE);\n-                    sess.time(\"save_analysis\", || {\n-                        save::process_crate(\n-                            tcx,\n-                            crate_name,\n-                            &sess.io.input,\n-                            None,\n-                            DumpHandler::new(sess.io.output_dir.as_deref(), crate_name),\n-                        )\n-                    });\n-                }\n-                result\n-            })?;\n+            queries.global_ctxt()?.enter(|tcx| tcx.analysis(()))?;\n \n             if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n                 return early_exit();"}, {"sha": "36c2ff4682301c967c1656e4ac8441d9f6c92196", "filename": "compiler/rustc_error_messages/locales/en-US/save_analysis.ftl", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1 +0,0 @@\n-save_analysis_could_not_open = Could not open `{$file_name}`: `{$err}`"}, {"sha": "579466ed366d86f03a34962d8f2f55963dc29f63", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -67,7 +67,6 @@ fluent_messages! {\n     privacy => \"../locales/en-US/privacy.ftl\",\n     query_system => \"../locales/en-US/query_system.ftl\",\n     resolve => \"../locales/en-US/resolve.ftl\",\n-    save_analysis => \"../locales/en-US/save_analysis.ftl\",\n     session => \"../locales/en-US/session.ftl\",\n     symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\",\n     trait_selection => \"../locales/en-US/trait_selection.ftl\","}, {"sha": "ac32988d3ac6e7543ecd97c0af2c4b471fcfd95a", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -691,7 +691,6 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(proc_macro_execution_strategy, ProcMacroExecutionStrategy::CrossThread);\n     untracked!(profile_closures, true);\n     untracked!(query_dep_graph, true);\n-    untracked!(save_analysis, true);\n     untracked!(self_profile, SwitchWithOptPath::Enabled(None));\n     untracked!(self_profile_events, Some(vec![String::new()]));\n     untracked!(span_debug, true);"}, {"sha": "181e27f334b40219e08be56fb5c3cc5f9b70e4f9", "filename": "compiler/rustc_save_analysis/Cargo.toml", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2FCargo.toml?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,21 +0,0 @@\n-[package]\n-name = \"rustc_save_analysis\"\n-version = \"0.0.0\"\n-edition = \"2021\"\n-\n-[dependencies]\n-tracing = \"0.1\"\n-rustc_middle = { path = \"../rustc_middle\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n-rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n-rustc_data_structures = { path = \"../rustc_data_structures\" }\n-rustc_errors = { path = \"../rustc_errors\" }\n-rustc_hir = { path = \"../rustc_hir\" }\n-rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n-rustc_lexer = { path = \"../rustc_lexer\" }\n-rustc_macros = { path = \"../rustc_macros\" }\n-serde_json = \"1\"\n-rustc_session = { path = \"../rustc_session\" }\n-rustc_span = { path = \"../rustc_span\" }\n-rls-data = \"0.19\"\n-rls-span = \"0.5\""}, {"sha": "3982111e38e08307f6aaacebe270a3c947f2cd78", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "removed", "additions": 0, "deletions": 1465, "changes": 1465, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,1465 +0,0 @@\n-//! Write the output of rustc's analysis to an implementor of Dump.\n-//!\n-//! Dumping the analysis is implemented by walking the AST and getting a bunch of\n-//! info out from all over the place. We use `DefId`s to identify objects. The\n-//! tricky part is getting syntactic (span, source text) and semantic (reference\n-//! `DefId`s) information for parts of expressions which the compiler has discarded.\n-//! E.g., in a path `foo::bar::baz`, the compiler only keeps a span for the whole\n-//! path and a reference to `baz`, but we want spans and references for all three\n-//! idents.\n-//!\n-//! SpanUtils is used to manipulate spans. In particular, to extract sub-spans\n-//! from spans (e.g., the span for `bar` from the above example path).\n-//! DumpVisitor walks the AST and processes it, and Dumper is used for\n-//! recording the output.\n-\n-use rustc_ast as ast;\n-use rustc_ast::walk_list;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind as HirDefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir_pretty::{bounds_to_string, fn_to_string, generic_params_to_string, ty_to_string};\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::span_bug;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n-use rustc_session::config::Input;\n-use rustc_span::symbol::Ident;\n-use rustc_span::*;\n-\n-use std::env;\n-use std::path::Path;\n-\n-use crate::dumper::{Access, Dumper};\n-use crate::sig;\n-use crate::span_utils::SpanUtils;\n-use crate::{\n-    escape, generated_code, id_from_def_id, id_from_hir_id, lower_attributes, PathCollector,\n-    SaveContext,\n-};\n-\n-use rls_data::{\n-    CompilationOptions, CratePreludeData, Def, DefKind, GlobalCrateId, Import, ImportKind, Ref,\n-    RefKind, Relation, RelationKind, SpanData,\n-};\n-\n-#[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5213\n-macro_rules! down_cast_data {\n-    ($id:ident, $kind:ident, $sp:expr) => {\n-        let super::Data::$kind($id) = $id else {\n-            span_bug!($sp, \"unexpected data kind: {:?}\", $id);\n-        };\n-    };\n-}\n-\n-macro_rules! access_from {\n-    ($save_ctxt:expr, $id:expr) => {\n-        Access {\n-            public: $save_ctxt.tcx.visibility($id).is_public(),\n-            reachable: $save_ctxt.effective_visibilities.is_reachable($id),\n-        }\n-    };\n-}\n-\n-pub struct DumpVisitor<'tcx> {\n-    pub save_ctxt: SaveContext<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    dumper: Dumper,\n-\n-    span: SpanUtils<'tcx>,\n-    // Set of macro definition (callee) spans, and the set\n-    // of macro use (callsite) spans. We store these to ensure\n-    // we only write one macro def per unique macro definition, and\n-    // one macro use per unique callsite span.\n-    // mac_defs: FxHashSet<Span>,\n-    // macro_calls: FxHashSet<Span>,\n-}\n-\n-impl<'tcx> DumpVisitor<'tcx> {\n-    pub fn new(save_ctxt: SaveContext<'tcx>) -> DumpVisitor<'tcx> {\n-        let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n-        let dumper = Dumper::new(save_ctxt.config.clone());\n-        DumpVisitor { tcx: save_ctxt.tcx, save_ctxt, dumper, span: span_utils }\n-    }\n-\n-    pub fn analysis(&self) -> &rls_data::Analysis {\n-        self.dumper.analysis()\n-    }\n-\n-    fn nest_typeck_results<F>(&mut self, item_def_id: LocalDefId, f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let typeck_results = if self.tcx.has_typeck_results(item_def_id) {\n-            Some(self.tcx.typeck(item_def_id))\n-        } else {\n-            None\n-        };\n-\n-        let old_maybe_typeck_results = self.save_ctxt.maybe_typeck_results;\n-        self.save_ctxt.maybe_typeck_results = typeck_results;\n-        f(self);\n-        self.save_ctxt.maybe_typeck_results = old_maybe_typeck_results;\n-    }\n-\n-    fn span_from_span(&self, span: Span) -> SpanData {\n-        self.save_ctxt.span_from_span(span)\n-    }\n-\n-    fn lookup_def_id(&self, ref_id: hir::HirId) -> Option<DefId> {\n-        self.save_ctxt.lookup_def_id(ref_id)\n-    }\n-\n-    pub fn dump_crate_info(&mut self, name: Symbol) {\n-        let crate_root = self.tcx.sess.local_crate_source_file().map(|source_file| {\n-            match source_file.file_name() {\n-                Some(_) => source_file.parent().unwrap().display(),\n-                None => source_file.display(),\n-            }\n-            .to_string()\n-        });\n-\n-        let data = CratePreludeData {\n-            crate_id: GlobalCrateId {\n-                name: name.to_string(),\n-                disambiguator: (self.tcx.sess.local_stable_crate_id().to_u64(), 0),\n-            },\n-            crate_root: crate_root.unwrap_or_else(|| \"<no source>\".to_owned()),\n-            external_crates: self.save_ctxt.get_external_crates(),\n-            span: self.span_from_span(self.tcx.def_span(CRATE_DEF_ID)),\n-        };\n-\n-        self.dumper.crate_prelude(data);\n-    }\n-\n-    pub fn dump_compilation_options(&mut self, input: &Input, crate_name: Symbol) {\n-        // Apply possible `remap-path-prefix` remapping to the input source file\n-        // (and don't include remapping args anymore)\n-        let (program, arguments) = {\n-            let remap_arg_indices = {\n-                let mut indices = FxHashSet::default();\n-                // Args are guaranteed to be valid UTF-8 (checked early)\n-                for (i, e) in env::args().enumerate() {\n-                    if e.starts_with(\"--remap-path-prefix=\") {\n-                        indices.insert(i);\n-                    } else if e == \"--remap-path-prefix\" {\n-                        indices.insert(i);\n-                        indices.insert(i + 1);\n-                    }\n-                }\n-                indices\n-            };\n-\n-            let mut args = env::args()\n-                .enumerate()\n-                .filter(|(i, _)| !remap_arg_indices.contains(i))\n-                .map(|(_, arg)| match input {\n-                    Input::File(ref path) if path == Path::new(&arg) => self\n-                        .tcx\n-                        .sess\n-                        .local_crate_source_file()\n-                        .as_ref()\n-                        .unwrap()\n-                        .to_string_lossy()\n-                        .into(),\n-                    _ => arg,\n-                });\n-\n-            (args.next().unwrap(), args.collect())\n-        };\n-\n-        let data = CompilationOptions {\n-            directory: self.tcx.sess.opts.working_dir.remapped_path_if_available().into(),\n-            program,\n-            arguments,\n-            output: self.save_ctxt.compilation_output(crate_name),\n-        };\n-\n-        self.dumper.compilation_opts(data);\n-    }\n-\n-    fn write_segments(&mut self, segments: impl IntoIterator<Item = &'tcx hir::PathSegment<'tcx>>) {\n-        for seg in segments {\n-            if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n-                self.dumper.dump_ref(data);\n-            }\n-        }\n-    }\n-\n-    fn write_sub_paths<R>(&mut self, path: &'tcx hir::Path<'tcx, R>) {\n-        self.write_segments(path.segments)\n-    }\n-\n-    // As write_sub_paths, but does not process the last ident in the path (assuming it\n-    // will be processed elsewhere). See note on write_sub_paths about global.\n-    fn write_sub_paths_truncated<R>(&mut self, path: &'tcx hir::Path<'tcx, R>) {\n-        if let [segments @ .., _] = path.segments {\n-            self.write_segments(segments)\n-        }\n-    }\n-\n-    fn process_formals(&mut self, formals: &'tcx [hir::Param<'tcx>], qualname: &str) {\n-        for arg in formals {\n-            self.visit_pat(&arg.pat);\n-            let mut collector = PathCollector::new(self.tcx);\n-            collector.visit_pat(&arg.pat);\n-\n-            for (hir_id, ident, ..) in collector.collected_idents {\n-                let typ = match self.save_ctxt.typeck_results().node_type_opt(hir_id) {\n-                    Some(s) => s.to_string(),\n-                    None => continue,\n-                };\n-                if !self.span.filter_generated(ident.span) {\n-                    let id = id_from_hir_id(hir_id);\n-                    let span = self.span_from_span(ident.span);\n-\n-                    self.dumper.dump_def(\n-                        &Access { public: false, reachable: false },\n-                        Def {\n-                            kind: DefKind::Local,\n-                            id,\n-                            span,\n-                            name: ident.to_string(),\n-                            qualname: format!(\"{}::{}\", qualname, ident),\n-                            value: typ,\n-                            parent: None,\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: String::new(),\n-                            sig: None,\n-                            attributes: vec![],\n-                        },\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    fn process_method(\n-        &mut self,\n-        sig: &'tcx hir::FnSig<'tcx>,\n-        body: Option<hir::BodyId>,\n-        owner_id: hir::OwnerId,\n-        ident: Ident,\n-        generics: &'tcx hir::Generics<'tcx>,\n-        span: Span,\n-    ) {\n-        debug!(\"process_method: {:?}:{}\", owner_id, ident);\n-\n-        let map = self.tcx.hir();\n-        let hir_id: hir::HirId = owner_id.into();\n-        self.nest_typeck_results(owner_id.def_id, |v| {\n-            if let Some(mut method_data) = v.save_ctxt.get_method_data(owner_id, ident, span) {\n-                if let Some(body) = body {\n-                    v.process_formals(map.body(body).params, &method_data.qualname);\n-                }\n-                v.process_generic_params(&generics, &method_data.qualname, hir_id);\n-\n-                method_data.value =\n-                    fn_to_string(sig.decl, sig.header, Some(ident.name), generics, &[], None);\n-                method_data.sig =\n-                    sig::method_signature(owner_id, ident, generics, sig, &v.save_ctxt);\n-\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, owner_id.def_id), method_data);\n-            }\n-\n-            // walk arg and return types\n-            for arg in sig.decl.inputs {\n-                v.visit_ty(arg);\n-            }\n-\n-            if let hir::FnRetTy::Return(ref ret_ty) = sig.decl.output {\n-                v.visit_ty(ret_ty)\n-            }\n-\n-            // walk the fn body\n-            if let Some(body) = body {\n-                v.visit_expr(&map.body(body).value);\n-            }\n-        });\n-    }\n-\n-    fn process_struct_field_def(\n-        &mut self,\n-        field: &'tcx hir::FieldDef<'tcx>,\n-        parent_id: LocalDefId,\n-    ) {\n-        let field_data = self.save_ctxt.get_field_data(field, parent_id);\n-        if let Some(field_data) = field_data {\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, field.def_id), field_data);\n-        }\n-    }\n-\n-    // Dump generic params bindings, then visit_generics\n-    fn process_generic_params(\n-        &mut self,\n-        generics: &'tcx hir::Generics<'tcx>,\n-        prefix: &str,\n-        id: hir::HirId,\n-    ) {\n-        for param in generics.params {\n-            match param.kind {\n-                hir::GenericParamKind::Lifetime { .. } => {}\n-                hir::GenericParamKind::Type { .. } => {\n-                    let param_ss = param.name.ident().span;\n-                    let name = escape(self.span.snippet(param_ss));\n-                    // Append $id to name to make sure each one is unique.\n-                    let qualname = format!(\"{}::{}${}\", prefix, name, id);\n-                    if !self.span.filter_generated(param_ss) {\n-                        let id = id_from_def_id(param.def_id.to_def_id());\n-                        let span = self.span_from_span(param_ss);\n-\n-                        self.dumper.dump_def(\n-                            &Access { public: false, reachable: false },\n-                            Def {\n-                                kind: DefKind::Type,\n-                                id,\n-                                span,\n-                                name,\n-                                qualname,\n-                                value: String::new(),\n-                                parent: None,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: String::new(),\n-                                sig: None,\n-                                attributes: vec![],\n-                            },\n-                        );\n-                    }\n-                }\n-                hir::GenericParamKind::Const { .. } => {}\n-            }\n-        }\n-\n-        self.visit_generics(generics)\n-    }\n-\n-    fn process_fn(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n-        _header: &'tcx hir::FnHeader,\n-        ty_params: &'tcx hir::Generics<'tcx>,\n-        body: hir::BodyId,\n-    ) {\n-        let map = self.tcx.hir();\n-        self.nest_typeck_results(item.owner_id.def_id, |v| {\n-            let body = map.body(body);\n-            if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n-                down_cast_data!(fn_data, DefData, item.span);\n-                v.process_formals(body.params, &fn_data.qualname);\n-                v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n-\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.owner_id.def_id), fn_data);\n-            }\n-\n-            for arg in decl.inputs {\n-                v.visit_ty(arg)\n-            }\n-\n-            if let hir::FnRetTy::Return(ref ret_ty) = decl.output {\n-                v.visit_ty(ret_ty)\n-            }\n-\n-            v.visit_expr(&body.value);\n-        });\n-    }\n-\n-    fn process_static_or_const_item(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        typ: &'tcx hir::Ty<'tcx>,\n-        expr: &'tcx hir::Expr<'tcx>,\n-    ) {\n-        self.nest_typeck_results(item.owner_id.def_id, |v| {\n-            if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n-                down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.owner_id.def_id), var_data);\n-            }\n-            v.visit_ty(&typ);\n-            v.visit_expr(expr);\n-        });\n-    }\n-\n-    fn process_assoc_const(\n-        &mut self,\n-        owner_id: hir::OwnerId,\n-        ident: Ident,\n-        typ: &'tcx hir::Ty<'tcx>,\n-        expr: Option<&'tcx hir::Expr<'tcx>>,\n-        parent_id: DefId,\n-        attrs: &'tcx [ast::Attribute],\n-    ) {\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(owner_id.to_def_id()));\n-\n-        if !self.span.filter_generated(ident.span) {\n-            let sig = sig::assoc_const_signature(owner_id, ident.name, typ, expr, &self.save_ctxt);\n-            let span = self.span_from_span(ident.span);\n-\n-            self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, owner_id.def_id),\n-                Def {\n-                    kind: DefKind::Const,\n-                    id: id_from_def_id(owner_id.to_def_id()),\n-                    span,\n-                    name: ident.name.to_string(),\n-                    qualname,\n-                    value: ty_to_string(&typ),\n-                    parent: Some(id_from_def_id(parent_id)),\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.save_ctxt.docs_for_attrs(attrs),\n-                    sig,\n-                    attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n-                },\n-            );\n-        }\n-\n-        // walk type and init value\n-        self.nest_typeck_results(owner_id.def_id, |v| {\n-            v.visit_ty(typ);\n-            if let Some(expr) = expr {\n-                v.visit_expr(expr);\n-            }\n-        });\n-    }\n-\n-    // FIXME tuple structs should generate tuple-specific data.\n-    fn process_struct(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        def: &'tcx hir::VariantData<'tcx>,\n-        ty_params: &'tcx hir::Generics<'tcx>,\n-    ) {\n-        debug!(\"process_struct {:?} {:?}\", item, item.span);\n-        let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n-\n-        let kind = match item.kind {\n-            hir::ItemKind::Struct(_, _) => DefKind::Struct,\n-            hir::ItemKind::Union(_, _) => DefKind::Union,\n-            _ => unreachable!(),\n-        };\n-\n-        let (value, fields) = match item.kind {\n-            hir::ItemKind::Struct(hir::VariantData::Struct(ref fields, ..), ..)\n-            | hir::ItemKind::Union(hir::VariantData::Struct(ref fields, ..), ..) => {\n-                let include_priv_fields = !self.save_ctxt.config.pub_only;\n-                let fields_str = fields\n-                    .iter()\n-                    .filter_map(|f| {\n-                        if include_priv_fields {\n-                            return Some(f.ident.to_string());\n-                        }\n-                        if self.save_ctxt.tcx.visibility(f.def_id).is_public() {\n-                            Some(f.ident.to_string())\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .collect::<Vec<_>>()\n-                    .join(\", \");\n-                let value = format!(\"{} {{ {} }}\", name, fields_str);\n-                (value, fields.iter().map(|f| id_from_def_id(f.def_id.to_def_id())).collect())\n-            }\n-            _ => (String::new(), vec![]),\n-        };\n-\n-        if !self.span.filter_generated(item.ident.span) {\n-            let span = self.span_from_span(item.ident.span);\n-            let attrs = self.tcx.hir().attrs(item.hir_id());\n-            self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.owner_id.def_id),\n-                Def {\n-                    kind,\n-                    id: id_from_def_id(item.owner_id.to_def_id()),\n-                    span,\n-                    name,\n-                    qualname: qualname.clone(),\n-                    value,\n-                    parent: None,\n-                    children: fields,\n-                    decl_id: None,\n-                    docs: self.save_ctxt.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, &self.save_ctxt),\n-                    attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                },\n-            );\n-        }\n-\n-        self.nest_typeck_results(item.owner_id.def_id, |v| {\n-            for field in def.fields() {\n-                v.process_struct_field_def(field, item.owner_id.def_id);\n-                v.visit_ty(&field.ty);\n-            }\n-\n-            v.process_generic_params(ty_params, &qualname, item.hir_id());\n-        });\n-    }\n-\n-    fn process_enum(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        enum_definition: &'tcx hir::EnumDef<'tcx>,\n-        ty_params: &'tcx hir::Generics<'tcx>,\n-    ) {\n-        let enum_data = self.save_ctxt.get_item_data(item);\n-        let Some(enum_data) = enum_data else {\n-            return;\n-        };\n-        down_cast_data!(enum_data, DefData, item.span);\n-\n-        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n-\n-        for variant in enum_definition.variants {\n-            let name = variant.ident.name.to_string();\n-            let qualname = format!(\"{}::{}\", enum_data.qualname, name);\n-            let name_span = variant.ident.span;\n-\n-            match variant.data {\n-                hir::VariantData::Struct(ref fields, ..) => {\n-                    let fields_str =\n-                        fields.iter().map(|f| f.ident.to_string()).collect::<Vec<_>>().join(\", \");\n-                    let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n-                    if !self.span.filter_generated(name_span) {\n-                        let span = self.span_from_span(name_span);\n-                        let id = id_from_def_id(variant.def_id.to_def_id());\n-                        let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n-                        let attrs = self.tcx.hir().attrs(variant.hir_id);\n-\n-                        self.dumper.dump_def(\n-                            &access,\n-                            Def {\n-                                kind: DefKind::StructVariant,\n-                                id,\n-                                span,\n-                                name,\n-                                qualname,\n-                                value,\n-                                parent,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(attrs),\n-                                sig: sig::variant_signature(variant, &self.save_ctxt),\n-                                attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                            },\n-                        );\n-                    }\n-                }\n-                ref v => {\n-                    let mut value = format!(\"{}::{}\", enum_data.name, name);\n-                    if let hir::VariantData::Tuple(fields, _, _) = v {\n-                        value.push('(');\n-                        value.push_str(\n-                            &fields\n-                                .iter()\n-                                .map(|f| ty_to_string(&f.ty))\n-                                .collect::<Vec<_>>()\n-                                .join(\", \"),\n-                        );\n-                        value.push(')');\n-                    }\n-                    if !self.span.filter_generated(name_span) {\n-                        let span = self.span_from_span(name_span);\n-                        let id = id_from_def_id(variant.def_id.to_def_id());\n-                        let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n-                        let attrs = self.tcx.hir().attrs(variant.hir_id);\n-\n-                        self.dumper.dump_def(\n-                            &access,\n-                            Def {\n-                                kind: DefKind::TupleVariant,\n-                                id,\n-                                span,\n-                                name,\n-                                qualname,\n-                                value,\n-                                parent,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(attrs),\n-                                sig: sig::variant_signature(variant, &self.save_ctxt),\n-                                attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                            },\n-                        );\n-                    }\n-                }\n-            }\n-\n-            for field in variant.data.fields() {\n-                self.process_struct_field_def(field, variant.def_id);\n-                self.visit_ty(field.ty);\n-            }\n-        }\n-        self.process_generic_params(ty_params, &enum_data.qualname, item.hir_id());\n-        self.dumper.dump_def(&access, enum_data);\n-    }\n-\n-    fn process_impl(&mut self, item: &'tcx hir::Item<'tcx>, impl_: &'tcx hir::Impl<'tcx>) {\n-        if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n-            if !self.span.filter_generated(item.span) {\n-                if let super::Data::RelationData(rel, imp) = impl_data {\n-                    self.dumper.dump_relation(rel);\n-                    self.dumper.dump_impl(imp);\n-                } else {\n-                    span_bug!(item.span, \"unexpected data kind: {:?}\", impl_data);\n-                }\n-            }\n-        }\n-\n-        let map = self.tcx.hir();\n-        self.nest_typeck_results(item.owner_id.def_id, |v| {\n-            v.visit_ty(&impl_.self_ty);\n-            if let Some(trait_ref) = &impl_.of_trait {\n-                v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n-            }\n-            v.process_generic_params(&impl_.generics, \"\", item.hir_id());\n-            for impl_item in impl_.items {\n-                v.process_impl_item(map.impl_item(impl_item.id), item.owner_id.to_def_id());\n-            }\n-        });\n-    }\n-\n-    fn process_trait(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        generics: &'tcx hir::Generics<'tcx>,\n-        trait_refs: hir::GenericBounds<'tcx>,\n-        methods: &'tcx [hir::TraitItemRef],\n-    ) {\n-        let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n-        let mut val = name.clone();\n-        if !generics.params.is_empty() {\n-            val.push_str(&generic_params_to_string(generics.params));\n-        }\n-        if !trait_refs.is_empty() {\n-            val.push_str(\": \");\n-            val.push_str(&bounds_to_string(trait_refs));\n-        }\n-        if !self.span.filter_generated(item.ident.span) {\n-            let id = id_from_def_id(item.owner_id.to_def_id());\n-            let span = self.span_from_span(item.ident.span);\n-            let children =\n-                methods.iter().map(|i| id_from_def_id(i.id.owner_id.to_def_id())).collect();\n-            let attrs = self.tcx.hir().attrs(item.hir_id());\n-            self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.owner_id.def_id),\n-                Def {\n-                    kind: DefKind::Trait,\n-                    id,\n-                    span,\n-                    name,\n-                    qualname: qualname.clone(),\n-                    value: val,\n-                    parent: None,\n-                    children,\n-                    decl_id: None,\n-                    docs: self.save_ctxt.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, &self.save_ctxt),\n-                    attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                },\n-            );\n-        }\n-\n-        // supertraits\n-        for super_bound in trait_refs.iter() {\n-            let (def_id, sub_span) = match *super_bound {\n-                hir::GenericBound::Trait(ref trait_ref, _) => (\n-                    self.lookup_def_id(trait_ref.trait_ref.hir_ref_id),\n-                    trait_ref.trait_ref.path.segments.last().unwrap().ident.span,\n-                ),\n-                hir::GenericBound::LangItemTrait(lang_item, span, _, _) => {\n-                    (Some(self.tcx.require_lang_item(lang_item, Some(span))), span)\n-                }\n-                hir::GenericBound::Outlives(..) => continue,\n-            };\n-\n-            if let Some(id) = def_id {\n-                if !self.span.filter_generated(sub_span) {\n-                    let span = self.span_from_span(sub_span);\n-                    self.dumper.dump_ref(Ref {\n-                        kind: RefKind::Type,\n-                        span: span.clone(),\n-                        ref_id: id_from_def_id(id),\n-                    });\n-\n-                    self.dumper.dump_relation(Relation {\n-                        kind: RelationKind::SuperTrait,\n-                        span,\n-                        from: id_from_def_id(id),\n-                        to: id_from_def_id(item.owner_id.to_def_id()),\n-                    });\n-                }\n-            }\n-        }\n-\n-        // walk generics and methods\n-        self.process_generic_params(generics, &qualname, item.hir_id());\n-        for method in methods {\n-            let map = self.tcx.hir();\n-            self.process_trait_item(map.trait_item(method.id), item.owner_id.to_def_id())\n-        }\n-    }\n-\n-    // `item` is the module in question, represented as an( item.\n-    fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item.owner_id.def_id), mod_data);\n-        }\n-    }\n-\n-    fn dump_path_ref(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n-        let path_data = self.save_ctxt.get_path_data(id, path);\n-        if let Some(path_data) = path_data {\n-            self.dumper.dump_ref(path_data);\n-        }\n-    }\n-\n-    fn dump_path_segment_ref(&mut self, id: hir::HirId, segment: &hir::PathSegment<'tcx>) {\n-        let segment_data = self.save_ctxt.get_path_segment_data_with_id(segment, id);\n-        if let Some(segment_data) = segment_data {\n-            self.dumper.dump_ref(segment_data);\n-        }\n-    }\n-\n-    fn process_path(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n-        if self.span.filter_generated(path.span()) {\n-            return;\n-        }\n-        self.dump_path_ref(id, path);\n-\n-        // Type arguments\n-        let segments = match path {\n-            hir::QPath::Resolved(ty, path) => {\n-                if let Some(ty) = ty {\n-                    self.visit_ty(ty);\n-                }\n-                path.segments\n-            }\n-            hir::QPath::TypeRelative(ty, segment) => {\n-                self.visit_ty(ty);\n-                std::slice::from_ref(*segment)\n-            }\n-            hir::QPath::LangItem(..) => return,\n-        };\n-        for seg in segments {\n-            if let Some(ref generic_args) = seg.args {\n-                for arg in generic_args.args {\n-                    if let hir::GenericArg::Type(ref ty) = arg {\n-                        self.visit_ty(ty);\n-                    }\n-                }\n-            }\n-        }\n-\n-        if let hir::QPath::Resolved(_, path) = path {\n-            self.write_sub_paths_truncated(path);\n-        }\n-    }\n-\n-    fn process_struct_lit(\n-        &mut self,\n-        ex: &'tcx hir::Expr<'tcx>,\n-        path: &'tcx hir::QPath<'tcx>,\n-        fields: &'tcx [hir::ExprField<'tcx>],\n-        variant: &'tcx ty::VariantDef,\n-        rest: Option<&'tcx hir::Expr<'tcx>>,\n-    ) {\n-        if let Some(_ex_res_data) = self.save_ctxt.get_expr_data(ex) {\n-            if let hir::QPath::Resolved(_, path) = path {\n-                self.write_sub_paths_truncated(path);\n-            }\n-            // For MyEnum::MyVariant, get_expr_data gives us MyEnum, not MyVariant.\n-            // For recording the span's ref id, we want MyVariant.\n-            if !generated_code(ex.span) {\n-                let sub_span = path.last_segment_span();\n-                let span = self.save_ctxt.span_from_span(sub_span);\n-                let reff =\n-                    Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(variant.def_id) };\n-                self.dumper.dump_ref(reff);\n-            }\n-\n-            for field in fields {\n-                if let Some(field_data) = self.save_ctxt.get_field_ref_data(field, variant) {\n-                    self.dumper.dump_ref(field_data);\n-                }\n-\n-                self.visit_expr(&field.expr)\n-            }\n-        }\n-\n-        if let Some(base) = rest {\n-            self.visit_expr(&base);\n-        }\n-    }\n-\n-    fn process_method_call(\n-        &mut self,\n-        ex: &'tcx hir::Expr<'tcx>,\n-        seg: &'tcx hir::PathSegment<'tcx>,\n-        receiver: &'tcx hir::Expr<'tcx>,\n-        args: &'tcx [hir::Expr<'tcx>],\n-    ) {\n-        debug!(\"process_method_call {:?} {:?}\", ex, ex.span);\n-        if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n-            down_cast_data!(mcd, RefData, ex.span);\n-            if !generated_code(ex.span) {\n-                self.dumper.dump_ref(mcd);\n-            }\n-        }\n-\n-        // Explicit types in the turbo-fish.\n-        if let Some(generic_args) = seg.args {\n-            for arg in generic_args.args {\n-                if let hir::GenericArg::Type(ty) = arg {\n-                    self.visit_ty(&ty)\n-                };\n-            }\n-        }\n-\n-        // walk receiver and args\n-        self.visit_expr(receiver);\n-        walk_list!(self, visit_expr, args);\n-    }\n-\n-    fn process_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n-        match p.kind {\n-            hir::PatKind::Struct(ref _path, fields, _) => {\n-                // FIXME do something with _path?\n-                let adt = match self.save_ctxt.typeck_results().node_type_opt(p.hir_id) {\n-                    Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n-                    _ => {\n-                        intravisit::walk_pat(self, p);\n-                        return;\n-                    }\n-                };\n-                let variant = adt.variant_of_res(self.save_ctxt.get_path_res(p.hir_id));\n-\n-                for field in fields {\n-                    if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n-                        if !self.span.filter_generated(field.ident.span) {\n-                            let span = self.span_from_span(field.ident.span);\n-                            self.dumper.dump_ref(Ref {\n-                                kind: RefKind::Variable,\n-                                span,\n-                                ref_id: id_from_def_id(variant.fields[index].did),\n-                            });\n-                        }\n-                    }\n-                    self.visit_pat(&field.pat);\n-                }\n-            }\n-            _ => intravisit::walk_pat(self, p),\n-        }\n-    }\n-\n-    fn process_var_decl(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n-        // The pattern could declare multiple new vars,\n-        // we must walk the pattern and collect them all.\n-        let mut collector = PathCollector::new(self.tcx);\n-        collector.visit_pat(&pat);\n-        self.visit_pat(&pat);\n-\n-        // Process collected paths.\n-        for (id, ident, _) in collector.collected_idents {\n-            let res = self.save_ctxt.get_path_res(id);\n-            match res {\n-                Res::Local(hir_id) => {\n-                    let typ = self\n-                        .save_ctxt\n-                        .typeck_results()\n-                        .node_type_opt(hir_id)\n-                        .map(|t| t.to_string())\n-                        .unwrap_or_default();\n-\n-                    // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-                    if !self.span.filter_generated(ident.span) {\n-                        let qualname = format!(\"{}${}\", ident, hir_id);\n-                        let id = id_from_hir_id(hir_id);\n-                        let span = self.span_from_span(ident.span);\n-\n-                        self.dumper.dump_def(\n-                            &Access { public: false, reachable: false },\n-                            Def {\n-                                kind: DefKind::Local,\n-                                id,\n-                                span,\n-                                name: ident.to_string(),\n-                                qualname,\n-                                value: typ,\n-                                parent: None,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: String::new(),\n-                                sig: None,\n-                                attributes: vec![],\n-                            },\n-                        );\n-                    }\n-                }\n-                Res::Def(\n-                    HirDefKind::Ctor(..)\n-                    | HirDefKind::Const\n-                    | HirDefKind::AssocConst\n-                    | HirDefKind::Struct\n-                    | HirDefKind::Variant\n-                    | HirDefKind::TyAlias\n-                    | HirDefKind::AssocTy,\n-                    _,\n-                )\n-                | Res::SelfTyParam { .. }\n-                | Res::SelfTyAlias { .. } => {\n-                    self.dump_path_segment_ref(\n-                        id,\n-                        &hir::PathSegment::new(ident, hir::HirId::INVALID, Res::Err),\n-                    );\n-                }\n-                def => {\n-                    error!(\"unexpected definition kind when processing collected idents: {:?}\", def)\n-                }\n-            }\n-        }\n-\n-        for (id, ref path) in collector.collected_paths {\n-            self.process_path(id, path);\n-        }\n-    }\n-\n-    /// Extracts macro use and definition information from the AST node defined\n-    /// by the given NodeId, using the expansion information from the node's\n-    /// span.\n-    ///\n-    /// If the span is not macro-generated, do nothing, else use callee and\n-    /// callsite spans to record macro definition and use data, using the\n-    /// mac_uses and mac_defs sets to prevent multiples.\n-    fn process_macro_use(&mut self, _span: Span) {\n-        // FIXME if we're not dumping the defs (see below), there is no point\n-        // dumping refs either.\n-        // let source_span = span.source_callsite();\n-        // if !self.macro_calls.insert(source_span) {\n-        //     return;\n-        // }\n-\n-        // let data = match self.save_ctxt.get_macro_use_data(span) {\n-        //     None => return,\n-        //     Some(data) => data,\n-        // };\n-\n-        // self.dumper.macro_use(data);\n-\n-        // FIXME write the macro def\n-        // let mut hasher = DefaultHasher::new();\n-        // data.callee_span.hash(&mut hasher);\n-        // let hash = hasher.finish();\n-        // let qualname = format!(\"{}::{}\", data.name, hash);\n-        // Don't write macro definition for imported macros\n-        // if !self.mac_defs.contains(&data.callee_span)\n-        //     && !data.imported {\n-        //     self.mac_defs.insert(data.callee_span);\n-        //     if let Some(sub_span) = self.span.span_for_macro_def_name(data.callee_span) {\n-        //         self.dumper.macro_data(MacroData {\n-        //             span: sub_span,\n-        //             name: data.name.clone(),\n-        //             qualname: qualname.clone(),\n-        //             // FIXME where do macro docs come from?\n-        //             docs: String::new(),\n-        //         }.lower(self.tcx));\n-        //     }\n-        // }\n-    }\n-\n-    fn process_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>, trait_id: DefId) {\n-        self.process_macro_use(trait_item.span);\n-        match trait_item.kind {\n-            hir::TraitItemKind::Const(ref ty, body) => {\n-                let body = body.map(|b| self.tcx.hir().body(b).value);\n-                let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n-                self.process_assoc_const(\n-                    trait_item.owner_id,\n-                    trait_item.ident,\n-                    &ty,\n-                    body,\n-                    trait_id,\n-                    attrs,\n-                );\n-            }\n-            hir::TraitItemKind::Fn(ref sig, ref trait_fn) => {\n-                let body =\n-                    if let hir::TraitFn::Provided(body) = trait_fn { Some(*body) } else { None };\n-                self.process_method(\n-                    sig,\n-                    body,\n-                    trait_item.owner_id,\n-                    trait_item.ident,\n-                    &trait_item.generics,\n-                    trait_item.span,\n-                );\n-            }\n-            hir::TraitItemKind::Type(ref bounds, ref default_ty) => {\n-                // FIXME do something with _bounds (for type refs)\n-                let name = trait_item.ident.name.to_string();\n-                let qualname =\n-                    format!(\"::{}\", self.tcx.def_path_str(trait_item.owner_id.to_def_id()));\n-\n-                if !self.span.filter_generated(trait_item.ident.span) {\n-                    let span = self.span_from_span(trait_item.ident.span);\n-                    let id = id_from_def_id(trait_item.owner_id.to_def_id());\n-                    let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n-\n-                    self.dumper.dump_def(\n-                        &Access { public: true, reachable: true },\n-                        Def {\n-                            kind: DefKind::Type,\n-                            id,\n-                            span,\n-                            name,\n-                            qualname,\n-                            value: self.span.snippet(trait_item.span),\n-                            parent: Some(id_from_def_id(trait_id)),\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: self.save_ctxt.docs_for_attrs(attrs),\n-                            sig: sig::assoc_type_signature(\n-                                trait_item.owner_id,\n-                                trait_item.ident,\n-                                Some(bounds),\n-                                default_ty.as_deref(),\n-                                &self.save_ctxt,\n-                            ),\n-                            attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                        },\n-                    );\n-                }\n-\n-                if let Some(default_ty) = default_ty {\n-                    self.visit_ty(default_ty)\n-                }\n-            }\n-        }\n-    }\n-\n-    fn process_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>, impl_id: DefId) {\n-        self.process_macro_use(impl_item.span);\n-        match impl_item.kind {\n-            hir::ImplItemKind::Const(ref ty, body) => {\n-                let body = self.tcx.hir().body(body);\n-                let attrs = self.tcx.hir().attrs(impl_item.hir_id());\n-                self.process_assoc_const(\n-                    impl_item.owner_id,\n-                    impl_item.ident,\n-                    &ty,\n-                    Some(&body.value),\n-                    impl_id,\n-                    attrs,\n-                );\n-            }\n-            hir::ImplItemKind::Fn(ref sig, body) => {\n-                self.process_method(\n-                    sig,\n-                    Some(body),\n-                    impl_item.owner_id,\n-                    impl_item.ident,\n-                    &impl_item.generics,\n-                    impl_item.span,\n-                );\n-            }\n-            hir::ImplItemKind::Type(ref ty) => {\n-                // FIXME: uses of the assoc type should ideally point to this\n-                // 'def' and the name here should be a ref to the def in the\n-                // trait.\n-                self.visit_ty(ty)\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn process_crate(&mut self) {\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(CRATE_DEF_ID.to_def_id()));\n-\n-        let sm = self.tcx.sess.source_map();\n-        let krate_mod = self.tcx.hir().root_module();\n-        let filename = sm.span_to_filename(krate_mod.spans.inner_span);\n-        let data_id = id_from_def_id(CRATE_DEF_ID.to_def_id());\n-        let children =\n-            krate_mod.item_ids.iter().map(|i| id_from_def_id(i.owner_id.to_def_id())).collect();\n-        let span = self.span_from_span(krate_mod.spans.inner_span);\n-        let attrs = self.tcx.hir().attrs(hir::CRATE_HIR_ID);\n-\n-        self.dumper.dump_def(\n-            &Access { public: true, reachable: true },\n-            Def {\n-                kind: DefKind::Mod,\n-                id: data_id,\n-                name: String::new(),\n-                qualname,\n-                span,\n-                value: filename.prefer_remapped().to_string(),\n-                children,\n-                parent: None,\n-                decl_id: None,\n-                docs: self.save_ctxt.docs_for_attrs(attrs),\n-                sig: None,\n-                attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n-            },\n-        );\n-        self.tcx.hir().walk_toplevel_module(self);\n-    }\n-\n-    fn process_bounds(&mut self, bounds: hir::GenericBounds<'tcx>) {\n-        for bound in bounds {\n-            if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n-                self.process_path(\n-                    trait_ref.trait_ref.hir_ref_id,\n-                    &hir::QPath::Resolved(None, &trait_ref.trait_ref.path),\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_macro_use(item.span);\n-        match item.kind {\n-            hir::ItemKind::Use(path, hir::UseKind::Single) => {\n-                let sub_span = path.segments.last().unwrap().ident.span;\n-                if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n-                    let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n-                    let span = self.span_from_span(sub_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n-                    self.dumper.import(\n-                        &access,\n-                        Import {\n-                            kind: ImportKind::Use,\n-                            ref_id,\n-                            span,\n-                            alias_span: None,\n-                            name: item.ident.to_string(),\n-                            value: String::new(),\n-                            parent: Some(id_from_def_id(parent.to_def_id())),\n-                        },\n-                    );\n-                    self.write_sub_paths_truncated(&path);\n-                }\n-            }\n-            hir::ItemKind::Use(path, hir::UseKind::Glob) => {\n-                // Make a comma-separated list of names of imported modules.\n-                let names = self.tcx.names_imported_by_glob_use(item.owner_id.def_id);\n-                let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n-\n-                // Otherwise it's a span with wrong macro expansion info, which\n-                // we don't want to track anyway, since it's probably macro-internal `use`\n-                if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n-                    if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n-                        let span = self.span_from_span(sub_span);\n-                        let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n-                        self.dumper.import(\n-                            &access,\n-                            Import {\n-                                kind: ImportKind::GlobUse,\n-                                ref_id: None,\n-                                span,\n-                                alias_span: None,\n-                                name: \"*\".to_owned(),\n-                                value: names.join(\", \"),\n-                                parent: Some(id_from_def_id(parent.to_def_id())),\n-                            },\n-                        );\n-                        self.write_sub_paths(&path);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::ExternCrate(_) => {\n-                let name_span = item.ident.span;\n-                if !self.span.filter_generated(name_span) {\n-                    let span = self.span_from_span(name_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n-                    self.dumper.import(\n-                        &Access { public: false, reachable: false },\n-                        Import {\n-                            kind: ImportKind::ExternCrate,\n-                            ref_id: None,\n-                            span,\n-                            alias_span: None,\n-                            name: item.ident.to_string(),\n-                            value: String::new(),\n-                            parent: Some(id_from_def_id(parent.to_def_id())),\n-                        },\n-                    );\n-                }\n-            }\n-            hir::ItemKind::Fn(ref sig, ref ty_params, body) => {\n-                self.process_fn(item, sig.decl, &sig.header, ty_params, body)\n-            }\n-            hir::ItemKind::Static(ref typ, _, body) => {\n-                let body = self.tcx.hir().body(body);\n-                self.process_static_or_const_item(item, typ, &body.value)\n-            }\n-            hir::ItemKind::Const(ref typ, body) => {\n-                let body = self.tcx.hir().body(body);\n-                self.process_static_or_const_item(item, typ, &body.value)\n-            }\n-            hir::ItemKind::Struct(ref def, ref ty_params)\n-            | hir::ItemKind::Union(ref def, ref ty_params) => {\n-                self.process_struct(item, def, ty_params)\n-            }\n-            hir::ItemKind::Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            hir::ItemKind::Impl(ref impl_) => self.process_impl(item, impl_),\n-            hir::ItemKind::Trait(_, _, ref generics, ref trait_refs, methods) => {\n-                self.process_trait(item, generics, trait_refs, methods)\n-            }\n-            hir::ItemKind::Mod(ref m) => {\n-                self.process_mod(item);\n-                intravisit::walk_mod(self, m, item.hir_id());\n-            }\n-            hir::ItemKind::TyAlias(ty, ref generics) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n-                let value = ty_to_string(&ty);\n-                if !self.span.filter_generated(item.ident.span) {\n-                    let span = self.span_from_span(item.ident.span);\n-                    let id = id_from_def_id(item.owner_id.to_def_id());\n-                    let attrs = self.tcx.hir().attrs(item.hir_id());\n-\n-                    self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item.owner_id.def_id),\n-                        Def {\n-                            kind: DefKind::Type,\n-                            id,\n-                            span,\n-                            name: item.ident.to_string(),\n-                            qualname: qualname.clone(),\n-                            value,\n-                            parent: None,\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: self.save_ctxt.docs_for_attrs(attrs),\n-                            sig: sig::item_signature(item, &self.save_ctxt),\n-                            attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                        },\n-                    );\n-                }\n-\n-                self.visit_ty(ty);\n-                self.process_generic_params(generics, &qualname, item.hir_id());\n-            }\n-            _ => intravisit::walk_item(self, item),\n-        }\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n-        for param in generics.params {\n-            match param.kind {\n-                hir::GenericParamKind::Lifetime { .. } => {}\n-                hir::GenericParamKind::Type { ref default, .. } => {\n-                    if let Some(ref ty) = default {\n-                        self.visit_ty(ty);\n-                    }\n-                }\n-                hir::GenericParamKind::Const { ref ty, ref default } => {\n-                    self.visit_ty(ty);\n-                    if let Some(default) = default {\n-                        self.visit_anon_const(default);\n-                    }\n-                }\n-            }\n-        }\n-        for pred in generics.predicates {\n-            if let hir::WherePredicate::BoundPredicate(ref wbp) = *pred {\n-                self.process_bounds(wbp.bounds);\n-                self.visit_ty(wbp.bounded_ty);\n-            }\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n-        self.process_macro_use(t.span);\n-        match t.kind {\n-            hir::TyKind::Path(ref path) => {\n-                if generated_code(t.span) {\n-                    return;\n-                }\n-\n-                if let Some(id) = self.lookup_def_id(t.hir_id) {\n-                    let sub_span = path.last_segment_span();\n-                    let span = self.span_from_span(sub_span);\n-                    self.dumper.dump_ref(Ref {\n-                        kind: RefKind::Type,\n-                        span,\n-                        ref_id: id_from_def_id(id),\n-                    });\n-                }\n-\n-                if let hir::QPath::Resolved(_, path) = path {\n-                    self.write_sub_paths_truncated(path);\n-                }\n-                intravisit::walk_qpath(self, path, t.hir_id);\n-            }\n-            hir::TyKind::Array(ref ty, ref length) => {\n-                self.visit_ty(ty);\n-                let map = self.tcx.hir();\n-                match length {\n-                    // FIXME(generic_arg_infer): We probably want to\n-                    // output the inferred type here? :shrug:\n-                    hir::ArrayLen::Infer(..) => {}\n-                    hir::ArrayLen::Body(anon_const) => self\n-                        .nest_typeck_results(anon_const.def_id, |v| {\n-                            v.visit_expr(&map.body(anon_const.body).value)\n-                        }),\n-                }\n-            }\n-            hir::TyKind::OpaqueDef(item_id, _, _) => {\n-                let item = self.tcx.hir().item(item_id);\n-                self.nest_typeck_results(item_id.owner_id.def_id, |v| v.visit_item(item));\n-            }\n-            _ => intravisit::walk_ty(self, t),\n-        }\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n-        debug!(\"visit_expr {:?}\", ex.kind);\n-        self.process_macro_use(ex.span);\n-        match ex.kind {\n-            hir::ExprKind::Struct(ref path, ref fields, ref rest) => {\n-                let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.hir_id);\n-                let adt = match self.save_ctxt.typeck_results().expr_ty_opt(&hir_expr) {\n-                    Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n-                    _ => {\n-                        intravisit::walk_expr(self, ex);\n-                        return;\n-                    }\n-                };\n-                let res = self.save_ctxt.get_path_res(hir_expr.hir_id);\n-                self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *rest)\n-            }\n-            hir::ExprKind::MethodCall(ref seg, receiver, args, _) => {\n-                self.process_method_call(ex, seg, receiver, args)\n-            }\n-            hir::ExprKind::Field(ref sub_ex, _) => {\n-                self.visit_expr(&sub_ex);\n-\n-                if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n-                    down_cast_data!(field_data, RefData, ex.span);\n-                    if !generated_code(ex.span) {\n-                        self.dumper.dump_ref(field_data);\n-                    }\n-                }\n-            }\n-            hir::ExprKind::Closure(&hir::Closure { ref fn_decl, body, def_id, .. }) => {\n-                let id = format!(\"${}\", ex.hir_id);\n-\n-                // walk arg and return types\n-                for ty in fn_decl.inputs {\n-                    self.visit_ty(ty);\n-                }\n-\n-                if let hir::FnRetTy::Return(ref ret_ty) = fn_decl.output {\n-                    self.visit_ty(ret_ty);\n-                }\n-\n-                // walk the body\n-                let map = self.tcx.hir();\n-                self.nest_typeck_results(def_id, |v| {\n-                    let body = map.body(body);\n-                    v.process_formals(body.params, &id);\n-                    v.visit_expr(&body.value)\n-                });\n-            }\n-            hir::ExprKind::Repeat(ref expr, ref length) => {\n-                self.visit_expr(expr);\n-                let map = self.tcx.hir();\n-                match length {\n-                    // FIXME(generic_arg_infer): We probably want to\n-                    // output the inferred type here? :shrug:\n-                    hir::ArrayLen::Infer(..) => {}\n-                    hir::ArrayLen::Body(anon_const) => self\n-                        .nest_typeck_results(anon_const.def_id, |v| {\n-                            v.visit_expr(&map.body(anon_const.body).value)\n-                        }),\n-                }\n-            }\n-            // In particular, we take this branch for call and path expressions,\n-            // where we'll index the idents involved just by continuing to walk.\n-            _ => intravisit::walk_expr(self, ex),\n-        }\n-    }\n-\n-    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n-        self.process_macro_use(p.span);\n-        self.process_pat(p);\n-    }\n-\n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n-        self.process_var_decl(&arm.pat);\n-        if let Some(hir::Guard::If(expr)) = &arm.guard {\n-            self.visit_expr(expr);\n-        }\n-        self.visit_expr(&arm.body);\n-    }\n-\n-    fn visit_qpath(&mut self, path: &'tcx hir::QPath<'tcx>, id: hir::HirId, _: Span) {\n-        self.process_path(id, path);\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-        self.process_macro_use(s.span);\n-        intravisit::walk_stmt(self, s)\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.process_macro_use(l.span);\n-        self.process_var_decl(&l.pat);\n-\n-        // Just walk the initializer, the else branch and type (don't want to walk the pattern again).\n-        walk_list!(self, visit_ty, &l.ty);\n-        walk_list!(self, visit_expr, &l.init);\n-        walk_list!(self, visit_block, l.els);\n-    }\n-\n-    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n-\n-        match item.kind {\n-            hir::ForeignItemKind::Fn(decl, _, ref generics) => {\n-                if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n-                    down_cast_data!(fn_data, DefData, item.span);\n-\n-                    self.process_generic_params(generics, &fn_data.qualname, item.hir_id());\n-                    self.dumper.dump_def(&access, fn_data);\n-                }\n-\n-                for ty in decl.inputs {\n-                    self.visit_ty(ty);\n-                }\n-\n-                if let hir::FnRetTy::Return(ref ret_ty) = decl.output {\n-                    self.visit_ty(ret_ty);\n-                }\n-            }\n-            hir::ForeignItemKind::Static(ref ty, _) => {\n-                if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n-                    down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper.dump_def(&access, var_data);\n-                }\n-\n-                self.visit_ty(ty);\n-            }\n-            hir::ForeignItemKind::Type => {\n-                if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n-                    down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper.dump_def(&access, var_data);\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "5a2628287d60d6155fab1ba035988f71b94696ff", "filename": "compiler/rustc_save_analysis/src/dumper.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Fdumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Fdumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdumper.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,91 +0,0 @@\n-use rls_data::config::Config;\n-use rls_data::{\n-    self, Analysis, CompilationOptions, CratePreludeData, Def, DefKind, Impl, Import, MacroRef,\n-    Ref, RefKind, Relation,\n-};\n-use rls_span::{Column, Row};\n-\n-#[derive(Debug)]\n-pub struct Access {\n-    pub reachable: bool,\n-    pub public: bool,\n-}\n-\n-pub struct Dumper {\n-    result: Analysis,\n-    config: Config,\n-}\n-\n-impl Dumper {\n-    pub fn new(config: Config) -> Dumper {\n-        Dumper { config: config.clone(), result: Analysis::new(config) }\n-    }\n-\n-    pub fn analysis(&self) -> &Analysis {\n-        &self.result\n-    }\n-}\n-\n-impl Dumper {\n-    pub fn crate_prelude(&mut self, data: CratePreludeData) {\n-        self.result.prelude = Some(data)\n-    }\n-\n-    pub fn compilation_opts(&mut self, data: CompilationOptions) {\n-        self.result.compilation = Some(data);\n-    }\n-\n-    pub fn _macro_use(&mut self, data: MacroRef) {\n-        if self.config.pub_only || self.config.reachable_only {\n-            return;\n-        }\n-        self.result.macro_refs.push(data);\n-    }\n-\n-    pub fn import(&mut self, access: &Access, import: Import) {\n-        if !access.public && self.config.pub_only || !access.reachable && self.config.reachable_only\n-        {\n-            return;\n-        }\n-        self.result.imports.push(import);\n-    }\n-\n-    pub fn dump_ref(&mut self, data: Ref) {\n-        if self.config.pub_only || self.config.reachable_only {\n-            return;\n-        }\n-        self.result.refs.push(data);\n-    }\n-\n-    pub fn dump_def(&mut self, access: &Access, mut data: Def) {\n-        if !access.public && self.config.pub_only || !access.reachable && self.config.reachable_only\n-        {\n-            return;\n-        }\n-        if data.kind == DefKind::Mod && data.span.file_name.to_str().unwrap() != data.value {\n-            // If the module is an out-of-line definition, then we'll make the\n-            // definition the first character in the module's file and turn\n-            // the declaration into a reference to it.\n-            let rf = Ref { kind: RefKind::Mod, span: data.span, ref_id: data.id };\n-            self.result.refs.push(rf);\n-            data.span = rls_data::SpanData {\n-                file_name: data.value.clone().into(),\n-                byte_start: 0,\n-                byte_end: 0,\n-                line_start: Row::new_one_indexed(1),\n-                line_end: Row::new_one_indexed(1),\n-                column_start: Column::new_one_indexed(1),\n-                column_end: Column::new_one_indexed(1),\n-            }\n-        }\n-        self.result.defs.push(data);\n-    }\n-\n-    pub fn dump_relation(&mut self, data: Relation) {\n-        self.result.relations.push(data);\n-    }\n-\n-    pub fn dump_impl(&mut self, data: Impl) {\n-        self.result.impls.push(data);\n-    }\n-}"}, {"sha": "585aac8c1c3cc034fabcde0ea890a4e7c1ddb32c", "filename": "compiler/rustc_save_analysis/src/errors.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,10 +0,0 @@\n-use rustc_macros::Diagnostic;\n-\n-use std::path::Path;\n-\n-#[derive(Diagnostic)]\n-#[diag(save_analysis_could_not_open)]\n-pub(crate) struct CouldNotOpen<'a> {\n-    pub file_name: &'a Path,\n-    pub err: std::io::Error,\n-}"}, {"sha": "ad151bc2e1bf5f3b4174dde79fe5b54408a355ed", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "removed", "additions": 0, "deletions": 1067, "changes": 1067, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,1067 +0,0 @@\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(if_let_guard)]\n-#![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n-#![feature(never_type)]\n-#![deny(rustc::untranslatable_diagnostic)]\n-#![deny(rustc::diagnostic_outside_of_impl)]\n-\n-#[macro_use]\n-extern crate tracing;\n-\n-mod dump_visitor;\n-mod dumper;\n-#[macro_use]\n-mod span_utils;\n-mod errors;\n-mod sig;\n-\n-use rustc_ast as ast;\n-use rustc_ast::util::comments::beautify_doc_string;\n-use rustc_ast_pretty::pprust::attribute_to_string;\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind as HirDefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::Node;\n-use rustc_hir_pretty::{enum_def_to_string, fn_to_string, ty_to_string};\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::EffectiveVisibilities;\n-use rustc_middle::ty::{self, print::with_no_trimmed_paths, DefIdTree, TyCtxt};\n-use rustc_middle::{bug, span_bug};\n-use rustc_session::config::{CrateType, Input, OutputType};\n-use rustc_session::cstore::ExternCrate;\n-use rustc_session::output::{filename_for_metadata, out_filename};\n-use rustc_span::symbol::Ident;\n-use rustc_span::*;\n-\n-use std::cell::Cell;\n-use std::env;\n-use std::fs::File;\n-use std::io::BufWriter;\n-use std::path::{Path, PathBuf};\n-\n-use dump_visitor::DumpVisitor;\n-use span_utils::SpanUtils;\n-\n-use rls_data::config::Config;\n-use rls_data::{\n-    Analysis, Def, DefKind, ExternalCrateData, GlobalCrateId, Impl, ImplKind, MacroRef, Ref,\n-    RefKind, Relation, RelationKind, SpanData,\n-};\n-\n-pub struct SaveContext<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n-    effective_visibilities: &'tcx EffectiveVisibilities,\n-    span_utils: SpanUtils<'tcx>,\n-    config: Config,\n-    impl_counter: Cell<u32>,\n-}\n-\n-#[derive(Debug)]\n-pub enum Data {\n-    RefData(Ref),\n-    DefData(Def),\n-    RelationData(Relation, Impl),\n-}\n-\n-impl<'tcx> SaveContext<'tcx> {\n-    /// Gets the type-checking results for the current body.\n-    /// As this will ICE if called outside bodies, only call when working with\n-    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n-    #[track_caller]\n-    fn typeck_results(&self) -> &'tcx ty::TypeckResults<'tcx> {\n-        self.maybe_typeck_results.expect(\"`SaveContext::typeck_results` called outside of body\")\n-    }\n-\n-    fn span_from_span(&self, span: Span) -> SpanData {\n-        use rls_span::{Column, Row};\n-\n-        let sm = self.tcx.sess.source_map();\n-        let start = sm.lookup_char_pos(span.lo());\n-        let end = sm.lookup_char_pos(span.hi());\n-\n-        SpanData {\n-            file_name: start.file.name.prefer_remapped().to_string().into(),\n-            byte_start: span.lo().0,\n-            byte_end: span.hi().0,\n-            line_start: Row::new_one_indexed(start.line as u32),\n-            line_end: Row::new_one_indexed(end.line as u32),\n-            column_start: Column::new_one_indexed(start.col.0 as u32 + 1),\n-            column_end: Column::new_one_indexed(end.col.0 as u32 + 1),\n-        }\n-    }\n-\n-    /// Returns path to the compilation output (e.g., libfoo-12345678.rmeta)\n-    pub fn compilation_output(&self, crate_name: Symbol) -> PathBuf {\n-        let sess = &self.tcx.sess;\n-        // Save-analysis is emitted per whole session, not per each crate type\n-        let crate_type = sess.crate_types()[0];\n-        let outputs = &*self.tcx.output_filenames(());\n-\n-        if outputs.outputs.contains_key(&OutputType::Metadata) {\n-            filename_for_metadata(sess, crate_name, outputs)\n-        } else if outputs.outputs.should_codegen() {\n-            out_filename(sess, crate_type, outputs, crate_name)\n-        } else {\n-            // Otherwise it's only a DepInfo, in which case we return early and\n-            // not even reach the analysis stage.\n-            unreachable!()\n-        }\n-    }\n-\n-    /// List external crates used by the current crate.\n-    pub fn get_external_crates(&self) -> Vec<ExternalCrateData> {\n-        let mut result = Vec::with_capacity(self.tcx.crates(()).len());\n-\n-        for &n in self.tcx.crates(()).iter() {\n-            let Some(&ExternCrate { span, .. }) = self.tcx.extern_crate(n.as_def_id()) else {\n-                debug!(\"skipping crate {}, no data\", n);\n-                continue;\n-            };\n-            let lo_loc = self.span_utils.sess.source_map().lookup_char_pos(span.lo());\n-            result.push(ExternalCrateData {\n-                // FIXME: change file_name field to PathBuf in rls-data\n-                // https://github.com/nrc/rls-data/issues/7\n-                file_name: self.span_utils.make_filename_string(&lo_loc.file),\n-                num: n.as_u32(),\n-                id: GlobalCrateId {\n-                    name: self.tcx.crate_name(n).to_string(),\n-                    disambiguator: (\n-                        self.tcx.def_path_hash(n.as_def_id()).stable_crate_id().to_u64(),\n-                        0,\n-                    ),\n-                },\n-            });\n-        }\n-\n-        result\n-    }\n-\n-    pub fn get_extern_item_data(&self, item: &hir::ForeignItem<'_>) -> Option<Data> {\n-        let def_id = item.owner_id.to_def_id();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-        let attrs = self.tcx.hir().attrs(item.hir_id());\n-        match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, arg_names, ref generics) => {\n-                filter!(self.span_utils, item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::ForeignFunction,\n-                    id: id_from_def_id(def_id),\n-                    span: self.span_from_span(item.ident.span),\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: fn_to_string(\n-                        decl,\n-                        hir::FnHeader {\n-                            // functions in extern block are implicitly unsafe\n-                            unsafety: hir::Unsafety::Unsafe,\n-                            // functions in extern block cannot be const\n-                            constness: hir::Constness::NotConst,\n-                            abi: self.tcx.hir().get_foreign_abi(item.hir_id()),\n-                            // functions in extern block cannot be async\n-                            asyncness: hir::IsAsync::NotAsync,\n-                        },\n-                        Some(item.ident.name),\n-                        generics,\n-                        arg_names,\n-                        None,\n-                    ),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::foreign_item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ForeignItemKind::Static(ref ty, _) => {\n-                filter!(self.span_utils, item.ident.span);\n-\n-                let id = id_from_def_id(def_id);\n-                let span = self.span_from_span(item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::ForeignStatic,\n-                    id,\n-                    span,\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: ty_to_string(ty),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::foreign_item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            // FIXME(plietar): needs a new DefKind in rls-data\n-            hir::ForeignItemKind::Type => None,\n-        }\n-    }\n-\n-    pub fn get_item_data(&self, item: &hir::Item<'_>) -> Option<Data> {\n-        let def_id = item.owner_id.to_def_id();\n-        let attrs = self.tcx.hir().attrs(item.hir_id());\n-        match item.kind {\n-            hir::ItemKind::Fn(ref sig, ref generics, _) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-                filter!(self.span_utils, item.ident.span);\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Function,\n-                    id: id_from_def_id(def_id),\n-                    span: self.span_from_span(item.ident.span),\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: fn_to_string(\n-                        sig.decl,\n-                        sig.header,\n-                        Some(item.ident.name),\n-                        generics,\n-                        &[],\n-                        None,\n-                    ),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Static(ref typ, ..) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-\n-                filter!(self.span_utils, item.ident.span);\n-\n-                let id = id_from_def_id(def_id);\n-                let span = self.span_from_span(item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Static,\n-                    id,\n-                    span,\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: ty_to_string(&typ),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Const(ref typ, _) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-                filter!(self.span_utils, item.ident.span);\n-\n-                let id = id_from_def_id(def_id);\n-                let span = self.span_from_span(item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Const,\n-                    id,\n-                    span,\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: ty_to_string(typ),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Mod(ref m) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-\n-                let sm = self.tcx.sess.source_map();\n-                let filename = sm.span_to_filename(m.spans.inner_span);\n-\n-                filter!(self.span_utils, item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Mod,\n-                    id: id_from_def_id(def_id),\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    span: self.span_from_span(item.ident.span),\n-                    value: filename.prefer_remapped().to_string(),\n-                    parent: None,\n-                    children: m\n-                        .item_ids\n-                        .iter()\n-                        .map(|i| id_from_def_id(i.owner_id.to_def_id()))\n-                        .collect(),\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Enum(ref def, ref generics) => {\n-                let name = item.ident.to_string();\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-                filter!(self.span_utils, item.ident.span);\n-                let value =\n-                    enum_def_to_string(def, generics, item.ident.name, item.span);\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Enum,\n-                    id: id_from_def_id(def_id),\n-                    span: self.span_from_span(item.ident.span),\n-                    name,\n-                    qualname,\n-                    value,\n-                    parent: None,\n-                    children: def.variants.iter().map(|v| id_from_def_id(v.def_id.to_def_id())).collect(),\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Impl(hir::Impl { ref of_trait, ref self_ty, ref items, .. })\n-                if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = self_ty.kind =>\n-            {\n-                // Common case impl for a struct or something basic.\n-                if generated_code(path.span) {\n-                    return None;\n-                }\n-                let sub_span = path.segments.last().unwrap().ident.span;\n-                filter!(self.span_utils, sub_span);\n-\n-                let impl_id = self.next_impl_id();\n-                let span = self.span_from_span(sub_span);\n-\n-                let type_data = self.lookup_def_id(self_ty.hir_id);\n-                type_data.map(|type_data| {\n-                    Data::RelationData(\n-                        Relation {\n-                            kind: RelationKind::Impl { id: impl_id },\n-                            span: span.clone(),\n-                            from: id_from_def_id(type_data),\n-                            to: of_trait\n-                                .as_ref()\n-                                .and_then(|t| self.lookup_def_id(t.hir_ref_id))\n-                                .map(id_from_def_id)\n-                                .unwrap_or_else(null_id),\n-                        },\n-                        Impl {\n-                            id: impl_id,\n-                            kind: match *of_trait {\n-                                Some(_) => ImplKind::Direct,\n-                                None => ImplKind::Inherent,\n-                            },\n-                            span,\n-                            value: String::new(),\n-                            parent: None,\n-                            children: items\n-                                .iter()\n-                                .map(|i| id_from_def_id(i.id.owner_id.to_def_id()))\n-                                .collect(),\n-                            docs: String::new(),\n-                            sig: None,\n-                            attributes: vec![],\n-                        },\n-                    )\n-                })\n-            }\n-            hir::ItemKind::Impl(_) => None,\n-            _ => {\n-                // FIXME\n-                bug!();\n-            }\n-        }\n-    }\n-\n-    pub fn get_field_data(&self, field: &hir::FieldDef<'_>, scope: LocalDefId) -> Option<Def> {\n-        let name = field.ident.to_string();\n-        let qualname = format!(\"::{}::{}\", self.tcx.def_path_str(scope.to_def_id()), field.ident);\n-        filter!(self.span_utils, field.ident.span);\n-        let field_def_id = field.def_id.to_def_id();\n-        let typ = self.tcx.type_of(field_def_id).to_string();\n-\n-        let id = id_from_def_id(field_def_id);\n-        let span = self.span_from_span(field.ident.span);\n-        let attrs = self.tcx.hir().attrs(field.hir_id);\n-\n-        Some(Def {\n-            kind: DefKind::Field,\n-            id,\n-            span,\n-            name,\n-            qualname,\n-            value: typ,\n-            parent: Some(id_from_def_id(scope.to_def_id())),\n-            children: vec![],\n-            decl_id: None,\n-            docs: self.docs_for_attrs(attrs),\n-            sig: sig::field_signature(field, self),\n-            attributes: lower_attributes(attrs.to_vec(), self),\n-        })\n-    }\n-\n-    // FIXME would be nice to take a MethodItem here, but the ast provides both\n-    // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, owner_id: hir::OwnerId, ident: Ident, span: Span) -> Option<Def> {\n-        // The qualname for a method is the trait name or name of the struct in an impl in\n-        // which the method is declared in, followed by the method's name.\n-        let (qualname, parent_scope, decl_id, docs, attributes) =\n-            match self.tcx.impl_of_method(owner_id.to_def_id()) {\n-                Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n-                    Some(Node::Item(item)) => match item.kind {\n-                        hir::ItemKind::Impl(hir::Impl { ref self_ty, .. }) => {\n-                            let hir = self.tcx.hir();\n-\n-                            let mut qualname = String::from(\"<\");\n-                            qualname\n-                                .push_str(&rustc_hir_pretty::id_to_string(&hir, self_ty.hir_id));\n-\n-                            let trait_id = self.tcx.trait_id_of_impl(impl_id);\n-                            let mut docs = String::new();\n-                            let mut attrs = vec![];\n-                            if let Some(Node::ImplItem(_)) = hir.find(owner_id.into()) {\n-                                attrs = self.tcx.hir().attrs(owner_id.into()).to_vec();\n-                                docs = self.docs_for_attrs(&attrs);\n-                            }\n-\n-                            let mut decl_id = None;\n-                            if let Some(def_id) = trait_id {\n-                                // A method in a trait impl.\n-                                qualname.push_str(\" as \");\n-                                qualname.push_str(&self.tcx.def_path_str(def_id));\n-\n-                                decl_id = self\n-                                    .tcx\n-                                    .associated_items(def_id)\n-                                    .filter_by_name_unhygienic(ident.name)\n-                                    .next()\n-                                    .map(|item| item.def_id);\n-                            }\n-                            qualname.push('>');\n-\n-                            (qualname, trait_id, decl_id, docs, attrs)\n-                        }\n-                        _ => {\n-                            span_bug!(\n-                                span,\n-                                \"Container {:?} for method {:?} not an impl?\",\n-                                impl_id,\n-                                owner_id,\n-                            );\n-                        }\n-                    },\n-                    r => {\n-                        span_bug!(\n-                            span,\n-                            \"Container {:?} for method {:?} is not a node item {:?}\",\n-                            impl_id,\n-                            owner_id,\n-                            r\n-                        );\n-                    }\n-                },\n-                None => match self.tcx.trait_of_item(owner_id.to_def_id()) {\n-                    Some(def_id) => {\n-                        let mut docs = String::new();\n-                        let mut attrs = vec![];\n-\n-                        if let Some(Node::TraitItem(_)) = self.tcx.hir().find(owner_id.into()) {\n-                            attrs = self.tcx.hir().attrs(owner_id.into()).to_vec();\n-                            docs = self.docs_for_attrs(&attrs);\n-                        }\n-\n-                        (\n-                            format!(\"::{}\", self.tcx.def_path_str(def_id)),\n-                            Some(def_id),\n-                            None,\n-                            docs,\n-                            attrs,\n-                        )\n-                    }\n-                    None => {\n-                        debug!(\"could not find container for method {:?} at {:?}\", owner_id, span);\n-                        // This is not necessarily a bug, if there was a compilation error,\n-                        // the typeck results we need might not exist.\n-                        return None;\n-                    }\n-                },\n-            };\n-\n-        let qualname = format!(\"{}::{}\", qualname, ident.name);\n-\n-        filter!(self.span_utils, ident.span);\n-\n-        Some(Def {\n-            kind: DefKind::Method,\n-            id: id_from_def_id(owner_id.to_def_id()),\n-            span: self.span_from_span(ident.span),\n-            name: ident.name.to_string(),\n-            qualname,\n-            // FIXME you get better data here by using the visitor.\n-            value: String::new(),\n-            parent: parent_scope.map(id_from_def_id),\n-            children: vec![],\n-            decl_id: decl_id.map(id_from_def_id),\n-            docs,\n-            sig: None,\n-            attributes: lower_attributes(attributes, self),\n-        })\n-    }\n-\n-    pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n-        let ty = self.typeck_results().expr_ty_adjusted_opt(expr)?;\n-        if matches!(ty.kind(), ty::Error(_)) {\n-            return None;\n-        }\n-        match expr.kind {\n-            hir::ExprKind::Field(ref sub_ex, ident) => {\n-                match self.typeck_results().expr_ty_adjusted(&sub_ex).kind() {\n-                    ty::Adt(def, _) if !def.is_enum() => {\n-                        let variant = &def.non_enum_variant();\n-                        filter!(self.span_utils, ident.span);\n-                        let span = self.span_from_span(ident.span);\n-                        Some(Data::RefData(Ref {\n-                            kind: RefKind::Variable,\n-                            span,\n-                            ref_id: self\n-                                .tcx\n-                                .find_field_index(ident, variant)\n-                                .map(|index| id_from_def_id(variant.fields[index].did))\n-                                .unwrap_or_else(null_id),\n-                        }))\n-                    }\n-                    ty::Tuple(..) => None,\n-                    _ => {\n-                        debug!(\"expected struct or union type, found {:?}\", ty);\n-                        None\n-                    }\n-                }\n-            }\n-            hir::ExprKind::Struct(qpath, ..) => match ty.kind() {\n-                ty::Adt(def, _) => {\n-                    let sub_span = qpath.last_segment_span();\n-                    filter!(self.span_utils, sub_span);\n-                    let span = self.span_from_span(sub_span);\n-                    Some(Data::RefData(Ref {\n-                        kind: RefKind::Type,\n-                        span,\n-                        ref_id: id_from_def_id(def.did()),\n-                    }))\n-                }\n-                _ => {\n-                    debug!(\"expected adt, found {:?}\", ty);\n-                    None\n-                }\n-            },\n-            hir::ExprKind::MethodCall(ref seg, ..) => {\n-                let Some(method_id) = self.typeck_results().type_dependent_def_id(expr.hir_id) else {\n-                    debug!(\"could not resolve method id for {:?}\", expr);\n-                    return None;\n-                };\n-                let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n-                    ty::ImplContainer => (Some(method_id), None),\n-                    ty::TraitContainer => (None, Some(method_id)),\n-                };\n-                let sub_span = seg.ident.span;\n-                filter!(self.span_utils, sub_span);\n-                let span = self.span_from_span(sub_span);\n-                Some(Data::RefData(Ref {\n-                    kind: RefKind::Function,\n-                    span,\n-                    ref_id: def_id.or(decl_id).map(id_from_def_id).unwrap_or_else(null_id),\n-                }))\n-            }\n-            hir::ExprKind::Path(ref path) => {\n-                self.get_path_data(expr.hir_id, path).map(Data::RefData)\n-            }\n-            _ => {\n-                // FIXME\n-                bug!(\"invalid expression: {:?}\", expr);\n-            }\n-        }\n-    }\n-\n-    pub fn get_path_res(&self, hir_id: hir::HirId) -> Res {\n-        match self.tcx.hir().get(hir_id) {\n-            Node::TraitRef(tr) => tr.path.res,\n-\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Use(path, _), .. }) => {\n-                path.res.get(0).copied().unwrap_or(Res::Err)\n-            }\n-            Node::PathSegment(seg) => {\n-                if seg.res != Res::Err {\n-                    seg.res\n-                } else {\n-                    let parent_node = self.tcx.hir().parent_id(hir_id);\n-                    self.get_path_res(parent_node)\n-                }\n-            }\n-\n-            Node::Expr(&hir::Expr { kind: hir::ExprKind::Struct(ref qpath, ..), .. }) => {\n-                self.typeck_results().qpath_res(qpath, hir_id)\n-            }\n-\n-            Node::Expr(&hir::Expr { kind: hir::ExprKind::Path(ref qpath), .. })\n-            | Node::Pat(&hir::Pat {\n-                kind:\n-                    hir::PatKind::Path(ref qpath)\n-                    | hir::PatKind::Struct(ref qpath, ..)\n-                    | hir::PatKind::TupleStruct(ref qpath, ..),\n-                ..\n-            })\n-            | Node::Ty(&hir::Ty { kind: hir::TyKind::Path(ref qpath), .. }) => match qpath {\n-                hir::QPath::Resolved(_, path) => path.res,\n-                hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => {\n-                    // #75962: `self.typeck_results` may be different from the `hir_id`'s result.\n-                    if self.tcx.has_typeck_results(hir_id.owner.to_def_id()) {\n-                        self.tcx.typeck(hir_id.owner.def_id).qpath_res(qpath, hir_id)\n-                    } else {\n-                        Res::Err\n-                    }\n-                }\n-            },\n-\n-            Node::Pat(&hir::Pat { kind: hir::PatKind::Binding(_, canonical_id, ..), .. }) => {\n-                Res::Local(canonical_id)\n-            }\n-\n-            _ => Res::Err,\n-        }\n-    }\n-\n-    pub fn get_path_data(&self, id: hir::HirId, path: &hir::QPath<'_>) -> Option<Ref> {\n-        let segment = match path {\n-            hir::QPath::Resolved(_, path) => path.segments.last(),\n-            hir::QPath::TypeRelative(_, segment) => Some(*segment),\n-            hir::QPath::LangItem(..) => None,\n-        };\n-        segment.and_then(|seg| {\n-            self.get_path_segment_data(seg).or_else(|| self.get_path_segment_data_with_id(seg, id))\n-        })\n-    }\n-\n-    pub fn get_path_segment_data(&self, path_seg: &hir::PathSegment<'_>) -> Option<Ref> {\n-        self.get_path_segment_data_with_id(path_seg, path_seg.hir_id)\n-    }\n-\n-    pub fn get_path_segment_data_with_id(\n-        &self,\n-        path_seg: &hir::PathSegment<'_>,\n-        id: hir::HirId,\n-    ) -> Option<Ref> {\n-        // Returns true if the path is function type sugar, e.g., `Fn(A) -> B`.\n-        fn fn_type(seg: &hir::PathSegment<'_>) -> bool {\n-            seg.args.map_or(false, |args| args.parenthesized)\n-        }\n-\n-        let res = self.get_path_res(id);\n-        let span = path_seg.ident.span;\n-        filter!(self.span_utils, span);\n-        let span = self.span_from_span(span);\n-\n-        match res {\n-            Res::Local(id) => {\n-                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_hir_id(id) })\n-            }\n-            Res::Def(HirDefKind::Trait, def_id) if fn_type(path_seg) => {\n-                Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(def_id) })\n-            }\n-            Res::Def(\n-                HirDefKind::Struct\n-                | HirDefKind::Variant\n-                | HirDefKind::Union\n-                | HirDefKind::Enum\n-                | HirDefKind::TyAlias\n-                | HirDefKind::ForeignTy\n-                | HirDefKind::TraitAlias\n-                | HirDefKind::AssocTy\n-                | HirDefKind::Trait\n-                | HirDefKind::OpaqueTy\n-                | HirDefKind::ImplTraitPlaceholder\n-                | HirDefKind::TyParam,\n-                def_id,\n-            ) => Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(def_id) }),\n-            Res::Def(HirDefKind::ConstParam, def_id) => {\n-                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(def_id) })\n-            }\n-            Res::Def(HirDefKind::Ctor(..), def_id) => {\n-                // This is a reference to a tuple struct or an enum variant where the def_id points\n-                // to an invisible constructor function. That is not a very useful\n-                // def, so adjust to point to the tuple struct or enum variant itself.\n-                let parent_def_id = self.tcx.parent(def_id);\n-                Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(parent_def_id) })\n-            }\n-            Res::Def(HirDefKind::Static(_) | HirDefKind::Const | HirDefKind::AssocConst, _) => {\n-                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(res.def_id()) })\n-            }\n-            Res::Def(HirDefKind::AssocFn, decl_id) => {\n-                let def_id = if decl_id.is_local() {\n-                    if self.tcx.impl_defaultness(decl_id).has_value() {\n-                        Some(decl_id)\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                };\n-                Some(Ref {\n-                    kind: RefKind::Function,\n-                    span,\n-                    ref_id: id_from_def_id(def_id.unwrap_or(decl_id)),\n-                })\n-            }\n-            Res::Def(HirDefKind::Fn, def_id) => {\n-                Some(Ref { kind: RefKind::Function, span, ref_id: id_from_def_id(def_id) })\n-            }\n-            Res::Def(HirDefKind::Mod, def_id) => {\n-                Some(Ref { kind: RefKind::Mod, span, ref_id: id_from_def_id(def_id) })\n-            }\n-\n-            Res::Def(\n-                HirDefKind::Macro(..)\n-                | HirDefKind::ExternCrate\n-                | HirDefKind::ForeignMod\n-                | HirDefKind::LifetimeParam\n-                | HirDefKind::AnonConst\n-                | HirDefKind::InlineConst\n-                | HirDefKind::Use\n-                | HirDefKind::Field\n-                | HirDefKind::GlobalAsm\n-                | HirDefKind::Impl { .. }\n-                | HirDefKind::Closure\n-                | HirDefKind::Generator,\n-                _,\n-            )\n-            | Res::PrimTy(..)\n-            | Res::SelfTyParam { .. }\n-            | Res::SelfTyAlias { .. }\n-            | Res::ToolMod\n-            | Res::NonMacroAttr(..)\n-            | Res::SelfCtor(..)\n-            | Res::Err => None,\n-        }\n-    }\n-\n-    pub fn get_field_ref_data(\n-        &self,\n-        field_ref: &hir::ExprField<'_>,\n-        variant: &ty::VariantDef,\n-    ) -> Option<Ref> {\n-        filter!(self.span_utils, field_ref.ident.span);\n-        self.tcx.find_field_index(field_ref.ident, variant).map(|index| {\n-            let span = self.span_from_span(field_ref.ident.span);\n-            Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(variant.fields[index].did) }\n-        })\n-    }\n-\n-    /// Attempt to return MacroRef for any AST node.\n-    ///\n-    /// For a given piece of AST defined by the supplied Span and NodeId,\n-    /// returns `None` if the node is not macro-generated or the span is malformed,\n-    /// else uses the expansion callsite and callee to return some MacroRef.\n-    ///\n-    /// FIXME: [`DumpVisitor::process_macro_use`] should actually dump this data\n-    #[allow(dead_code)]\n-    fn get_macro_use_data(&self, span: Span) -> Option<MacroRef> {\n-        if !generated_code(span) {\n-            return None;\n-        }\n-        // Note we take care to use the source callsite/callee, to handle\n-        // nested expansions and ensure we only generate data for source-visible\n-        // macro uses.\n-        let callsite = span.source_callsite();\n-        let callsite_span = self.span_from_span(callsite);\n-        let callee = span.source_callee()?;\n-\n-        let mac_name = match callee.kind {\n-            ExpnKind::Macro(kind, name) => match kind {\n-                MacroKind::Bang => name,\n-\n-                // Ignore attribute macros, their spans are usually mangled\n-                // FIXME(eddyb) is this really the case anymore?\n-                MacroKind::Attr | MacroKind::Derive => return None,\n-            },\n-\n-            // These are not macros.\n-            // FIXME(eddyb) maybe there is a way to handle them usefully?\n-            ExpnKind::Inlined | ExpnKind::Root | ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => {\n-                return None;\n-            }\n-        };\n-\n-        let callee_span = self.span_from_span(callee.def_site);\n-        Some(MacroRef {\n-            span: callsite_span,\n-            qualname: mac_name.to_string(), // FIXME: generate the real qualname\n-            callee_span,\n-        })\n-    }\n-\n-    fn lookup_def_id(&self, ref_id: hir::HirId) -> Option<DefId> {\n-        match self.get_path_res(ref_id) {\n-            Res::PrimTy(_) | Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } | Res::Err => None,\n-            def => def.opt_def_id(),\n-        }\n-    }\n-\n-    fn docs_for_attrs(&self, attrs: &[ast::Attribute]) -> String {\n-        let mut result = String::new();\n-\n-        for attr in attrs {\n-            if let Some((val, kind)) = attr.doc_str_and_comment_kind() {\n-                // FIXME: Should save-analysis beautify doc strings itself or leave it to users?\n-                result.push_str(beautify_doc_string(val, kind).as_str());\n-                result.push('\\n');\n-            }\n-        }\n-\n-        if !self.config.full_docs {\n-            if let Some(index) = result.find(\"\\n\\n\") {\n-                result.truncate(index);\n-            }\n-        }\n-\n-        result\n-    }\n-\n-    fn next_impl_id(&self) -> u32 {\n-        let next = self.impl_counter.get();\n-        self.impl_counter.set(next + 1);\n-        next\n-    }\n-}\n-\n-// An AST visitor for collecting paths (e.g., the names of structs) and formal\n-// variables (idents) from patterns.\n-struct PathCollector<'l> {\n-    tcx: TyCtxt<'l>,\n-    collected_paths: Vec<(hir::HirId, &'l hir::QPath<'l>)>,\n-    collected_idents: Vec<(hir::HirId, Ident, hir::Mutability)>,\n-}\n-\n-impl<'l> PathCollector<'l> {\n-    fn new(tcx: TyCtxt<'l>) -> PathCollector<'l> {\n-        PathCollector { tcx, collected_paths: vec![], collected_idents: vec![] }\n-    }\n-}\n-\n-impl<'l> Visitor<'l> for PathCollector<'l> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-\n-    fn visit_pat(&mut self, p: &'l hir::Pat<'l>) {\n-        match p.kind {\n-            hir::PatKind::Struct(ref path, ..) => {\n-                self.collected_paths.push((p.hir_id, path));\n-            }\n-            hir::PatKind::TupleStruct(ref path, ..) | hir::PatKind::Path(ref path) => {\n-                self.collected_paths.push((p.hir_id, path));\n-            }\n-            hir::PatKind::Binding(hir::BindingAnnotation(_, mutbl), _, ident, _) => {\n-                debug!(\n-                    \"PathCollector, visit ident in pat {}: {:?} {:?}\",\n-                    ident, p.span, ident.span\n-                );\n-                self.collected_idents.push((p.hir_id, ident, mutbl));\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_pat(self, p);\n-    }\n-}\n-\n-/// Defines what to do with the results of saving the analysis.\n-pub trait SaveHandler {\n-    fn save(&mut self, save_ctxt: &SaveContext<'_>, analysis: &Analysis);\n-}\n-\n-/// Dump the save-analysis results to a file.\n-pub struct DumpHandler<'a> {\n-    odir: Option<&'a Path>,\n-    cratename: String,\n-}\n-\n-impl<'a> DumpHandler<'a> {\n-    pub fn new(odir: Option<&'a Path>, cratename: Symbol) -> DumpHandler<'a> {\n-        DumpHandler { odir, cratename: cratename.to_string() }\n-    }\n-\n-    fn output_file(&self, ctx: &SaveContext<'_>) -> (BufWriter<File>, PathBuf) {\n-        let sess = &ctx.tcx.sess;\n-        let file_name = match ctx.config.output_file {\n-            Some(ref s) => PathBuf::from(s),\n-            None => {\n-                let mut root_path = match self.odir {\n-                    Some(val) => val.join(\"save-analysis\"),\n-                    None => PathBuf::from(\"save-analysis-temp\"),\n-                };\n-\n-                if let Err(e) = std::fs::create_dir_all(&root_path) {\n-                    error!(\"Could not create directory {}: {}\", root_path.display(), e);\n-                }\n-\n-                let executable = sess.crate_types().iter().any(|ct| *ct == CrateType::Executable);\n-                let mut out_name = if executable { String::new() } else { \"lib\".to_owned() };\n-                out_name.push_str(&self.cratename);\n-                out_name.push_str(&sess.opts.cg.extra_filename);\n-                out_name.push_str(\".json\");\n-                root_path.push(&out_name);\n-\n-                root_path\n-            }\n-        };\n-\n-        info!(\"Writing output to {}\", file_name.display());\n-\n-        let output_file = BufWriter::new(File::create(&file_name).unwrap_or_else(|e| {\n-            sess.emit_fatal(errors::CouldNotOpen { file_name: file_name.as_path(), err: e })\n-        }));\n-\n-        (output_file, file_name)\n-    }\n-}\n-\n-impl SaveHandler for DumpHandler<'_> {\n-    fn save(&mut self, save_ctxt: &SaveContext<'_>, analysis: &Analysis) {\n-        let sess = &save_ctxt.tcx.sess;\n-        let (output, file_name) = self.output_file(&save_ctxt);\n-        if let Err(e) = serde_json::to_writer(output, &analysis) {\n-            error!(\"Can't serialize save-analysis: {:?}\", e);\n-        }\n-\n-        if sess.opts.json_artifact_notifications {\n-            sess.parse_sess.span_diagnostic.emit_artifact_notification(&file_name, \"save-analysis\");\n-        }\n-    }\n-}\n-\n-/// Call a callback with the results of save-analysis.\n-pub struct CallbackHandler<'b> {\n-    pub callback: &'b mut dyn FnMut(&rls_data::Analysis),\n-}\n-\n-impl SaveHandler for CallbackHandler<'_> {\n-    fn save(&mut self, _: &SaveContext<'_>, analysis: &Analysis) {\n-        (self.callback)(analysis)\n-    }\n-}\n-\n-pub fn process_crate<H: SaveHandler>(\n-    tcx: TyCtxt<'_>,\n-    cratename: Symbol,\n-    input: &Input,\n-    config: Option<Config>,\n-    mut handler: H,\n-) {\n-    with_no_trimmed_paths!({\n-        tcx.dep_graph.with_ignore(|| {\n-            info!(\"Dumping crate {}\", cratename);\n-\n-            // Privacy checking must be done outside of type inference; use a\n-            // fallback in case effective visibilities couldn't have been correctly computed.\n-            let effective_visibilities = match tcx.sess.compile_status() {\n-                Ok(..) => tcx.effective_visibilities(()),\n-                Err(..) => tcx.arena.alloc(EffectiveVisibilities::default()),\n-            };\n-\n-            let save_ctxt = SaveContext {\n-                tcx,\n-                maybe_typeck_results: None,\n-                effective_visibilities: &effective_visibilities,\n-                span_utils: SpanUtils::new(&tcx.sess),\n-                config: find_config(config),\n-                impl_counter: Cell::new(0),\n-            };\n-\n-            let mut visitor = DumpVisitor::new(save_ctxt);\n-\n-            visitor.dump_crate_info(cratename);\n-            visitor.dump_compilation_options(input, cratename);\n-            visitor.process_crate();\n-\n-            handler.save(&visitor.save_ctxt, &visitor.analysis())\n-        })\n-    })\n-}\n-\n-fn find_config(supplied: Option<Config>) -> Config {\n-    if let Some(config) = supplied {\n-        return config;\n-    }\n-\n-    match env::var_os(\"RUST_SAVE_ANALYSIS_CONFIG\") {\n-        None => Config::default(),\n-        Some(config) => config\n-            .to_str()\n-            .ok_or(())\n-            .map_err(|_| error!(\"`RUST_SAVE_ANALYSIS_CONFIG` isn't UTF-8\"))\n-            .and_then(|cfg| {\n-                serde_json::from_str(cfg)\n-                    .map_err(|_| error!(\"Could not deserialize save-analysis config\"))\n-            })\n-            .unwrap_or_default(),\n-    }\n-}\n-\n-// Utility functions for the module.\n-\n-// Helper function to escape quotes in a string\n-fn escape(s: String) -> String {\n-    s.replace('\\\"', \"\\\"\\\"\")\n-}\n-\n-// Helper function to determine if a span came from a\n-// macro expansion or syntax extension.\n-fn generated_code(span: Span) -> bool {\n-    span.from_expansion() || span.is_dummy()\n-}\n-\n-// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n-// we use our own Id which is the same, but without the newtype.\n-fn id_from_def_id(id: DefId) -> rls_data::Id {\n-    rls_data::Id { krate: id.krate.as_u32(), index: id.index.as_u32() }\n-}\n-\n-fn id_from_hir_id(id: hir::HirId) -> rls_data::Id {\n-    // Create a *fake* `DefId` out of a `HirId` by combining the owner\n-    // `local_def_index` and the `local_id`.\n-    // This will work unless you have *billions* of definitions in a single\n-    // crate (very unlikely to actually happen).\n-    rls_data::Id {\n-        krate: LOCAL_CRATE.as_u32(),\n-        index: id.owner.def_id.local_def_index.as_u32() | id.local_id.as_u32().reverse_bits(),\n-    }\n-}\n-\n-fn null_id() -> rls_data::Id {\n-    rls_data::Id { krate: u32::MAX, index: u32::MAX }\n-}\n-\n-fn lower_attributes(attrs: Vec<ast::Attribute>, scx: &SaveContext<'_>) -> Vec<rls_data::Attribute> {\n-    attrs\n-        .into_iter()\n-        // Only retain real attributes. Doc comments are lowered separately.\n-        .filter(|attr| !attr.has_name(sym::doc))\n-        .map(|mut attr| {\n-            // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n-            // attribute. First normalize all inner attribute (#![..]) to outer\n-            // ones (#[..]), then remove the two leading and the one trailing character.\n-            attr.style = ast::AttrStyle::Outer;\n-            let value = attribute_to_string(&attr);\n-            // This str slicing works correctly, because the leading and trailing characters\n-            // are in the ASCII range and thus exactly one byte each.\n-            let value = value[2..value.len() - 1].to_string();\n-\n-            rls_data::Attribute { value, span: scx.span_from_span(attr.span) }\n-        })\n-        .collect()\n-}"}, {"sha": "a50a8178de38bb3af51f44380575ee81c39b3887", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "removed", "additions": 0, "deletions": 931, "changes": 931, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,931 +0,0 @@\n-// A signature is a string representation of an item's type signature, excluding\n-// any body. It also includes ids for any defs or refs in the signature. For\n-// example:\n-//\n-// ```\n-// fn foo(x: String) {\n-//     println!(\"{}\", x);\n-// }\n-// ```\n-// The signature string is something like \"fn foo(x: String) {}\" and the signature\n-// will have defs for `foo` and `x` and a ref for `String`.\n-//\n-// All signature text should parse in the correct context (i.e., in a module or\n-// impl, etc.). Clients may want to trim trailing `{}` or `;`. The text of a\n-// signature is not guaranteed to be stable (it may improve or change as the\n-// syntax changes, or whitespace or punctuation may change). It is also likely\n-// not to be pretty - no attempt is made to prettify the text. It is recommended\n-// that clients run the text through Rustfmt.\n-//\n-// This module generates Signatures for items by walking the AST and looking up\n-// references.\n-//\n-// Signatures do not include visibility info. I'm not sure if this is a feature\n-// or an omission (FIXME).\n-//\n-// FIXME where clauses need implementing, defs/refs in generics are mostly missing.\n-\n-use crate::{id_from_def_id, SaveContext};\n-\n-use rls_data::{SigElement, Signature};\n-\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir_pretty::id_to_string;\n-use rustc_hir_pretty::{bounds_to_string, path_segment_to_string, path_to_string, ty_to_string};\n-use rustc_span::def_id::LocalDefId;\n-use rustc_span::symbol::{Ident, Symbol};\n-\n-pub fn item_signature(item: &hir::Item<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    item.make(0, None, scx).ok()\n-}\n-\n-pub fn foreign_item_signature(\n-    item: &hir::ForeignItem<'_>,\n-    scx: &SaveContext<'_>,\n-) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    item.make(0, None, scx).ok()\n-}\n-\n-/// Signature for a struct or tuple field declaration.\n-/// Does not include a trailing comma.\n-pub fn field_signature(field: &hir::FieldDef<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    field.make(0, None, scx).ok()\n-}\n-\n-/// Does not include a trailing comma.\n-pub fn variant_signature(variant: &hir::Variant<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    variant.make(0, None, scx).ok()\n-}\n-\n-pub fn method_signature(\n-    id: hir::OwnerId,\n-    ident: Ident,\n-    generics: &hir::Generics<'_>,\n-    m: &hir::FnSig<'_>,\n-    scx: &SaveContext<'_>,\n-) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    make_method_signature(id, ident, generics, m, scx).ok()\n-}\n-\n-pub fn assoc_const_signature(\n-    id: hir::OwnerId,\n-    ident: Symbol,\n-    ty: &hir::Ty<'_>,\n-    default: Option<&hir::Expr<'_>>,\n-    scx: &SaveContext<'_>,\n-) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    make_assoc_const_signature(id, ident, ty, default, scx).ok()\n-}\n-\n-pub fn assoc_type_signature(\n-    id: hir::OwnerId,\n-    ident: Ident,\n-    bounds: Option<hir::GenericBounds<'_>>,\n-    default: Option<&hir::Ty<'_>>,\n-    scx: &SaveContext<'_>,\n-) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    make_assoc_type_signature(id, ident, bounds, default, scx).ok()\n-}\n-\n-type Result = std::result::Result<Signature, &'static str>;\n-\n-trait Sig {\n-    type Parent;\n-    fn make(&self, offset: usize, id: Option<Self::Parent>, scx: &SaveContext<'_>) -> Result;\n-}\n-\n-fn extend_sig(\n-    mut sig: Signature,\n-    text: String,\n-    defs: Vec<SigElement>,\n-    refs: Vec<SigElement>,\n-) -> Signature {\n-    sig.text = text;\n-    sig.defs.extend(defs.into_iter());\n-    sig.refs.extend(refs.into_iter());\n-    sig\n-}\n-\n-fn replace_text(mut sig: Signature, text: String) -> Signature {\n-    sig.text = text;\n-    sig\n-}\n-\n-fn merge_sigs(text: String, sigs: Vec<Signature>) -> Signature {\n-    let mut result = Signature { text, defs: vec![], refs: vec![] };\n-\n-    let (defs, refs): (Vec<_>, Vec<_>) = sigs.into_iter().map(|s| (s.defs, s.refs)).unzip();\n-\n-    result.defs.extend(defs.into_iter().flat_map(|ds| ds.into_iter()));\n-    result.refs.extend(refs.into_iter().flat_map(|rs| rs.into_iter()));\n-\n-    result\n-}\n-\n-fn text_sig(text: String) -> Signature {\n-    Signature { text, defs: vec![], refs: vec![] }\n-}\n-\n-impl<'hir> Sig for hir::Ty<'hir> {\n-    type Parent = hir::HirId;\n-    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let id = Some(self.hir_id);\n-        match self.kind {\n-            hir::TyKind::Slice(ref ty) => {\n-                let nested = ty.make(offset + 1, id, scx)?;\n-                let text = format!(\"[{}]\", nested.text);\n-                Ok(replace_text(nested, text))\n-            }\n-            hir::TyKind::Ptr(ref mt) => {\n-                let prefix = match mt.mutbl {\n-                    hir::Mutability::Mut => \"*mut \",\n-                    hir::Mutability::Not => \"*const \",\n-                };\n-                let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n-                let text = format!(\"{}{}\", prefix, nested.text);\n-                Ok(replace_text(nested, text))\n-            }\n-            hir::TyKind::Ref(ref lifetime, ref mt) => {\n-                let mut prefix = \"&\".to_owned();\n-                prefix.push_str(&lifetime.ident.to_string());\n-                prefix.push(' ');\n-                if mt.mutbl.is_mut() {\n-                    prefix.push_str(\"mut \");\n-                };\n-\n-                let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n-                let text = format!(\"{}{}\", prefix, nested.text);\n-                Ok(replace_text(nested, text))\n-            }\n-            hir::TyKind::Never => Ok(text_sig(\"!\".to_owned())),\n-            hir::TyKind::Tup(ts) => {\n-                let mut text = \"(\".to_owned();\n-                let mut defs = vec![];\n-                let mut refs = vec![];\n-                for t in ts {\n-                    let nested = t.make(offset + text.len(), id, scx)?;\n-                    text.push_str(&nested.text);\n-                    text.push(',');\n-                    defs.extend(nested.defs.into_iter());\n-                    refs.extend(nested.refs.into_iter());\n-                }\n-                text.push(')');\n-                Ok(Signature { text, defs, refs })\n-            }\n-            hir::TyKind::BareFn(ref f) => {\n-                let mut text = String::new();\n-                if !f.generic_params.is_empty() {\n-                    // FIXME defs, bounds on lifetimes\n-                    text.push_str(\"for<\");\n-                    text.push_str(\n-                        &f.generic_params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                hir::GenericParamKind::Lifetime { .. } => {\n-                                    Some(param.name.ident().to_string())\n-                                }\n-                                _ => None,\n-                            })\n-                            .collect::<Vec<_>>()\n-                            .join(\", \"),\n-                    );\n-                    text.push('>');\n-                }\n-\n-                if let hir::Unsafety::Unsafe = f.unsafety {\n-                    text.push_str(\"unsafe \");\n-                }\n-                text.push_str(\"fn(\");\n-\n-                let mut defs = vec![];\n-                let mut refs = vec![];\n-                for i in f.decl.inputs {\n-                    let nested = i.make(offset + text.len(), Some(i.hir_id), scx)?;\n-                    text.push_str(&nested.text);\n-                    text.push(',');\n-                    defs.extend(nested.defs.into_iter());\n-                    refs.extend(nested.refs.into_iter());\n-                }\n-                text.push(')');\n-                if let hir::FnRetTy::Return(ref t) = f.decl.output {\n-                    text.push_str(\" -> \");\n-                    let nested = t.make(offset + text.len(), None, scx)?;\n-                    text.push_str(&nested.text);\n-                    text.push(',');\n-                    defs.extend(nested.defs.into_iter());\n-                    refs.extend(nested.refs.into_iter());\n-                }\n-\n-                Ok(Signature { text, defs, refs })\n-            }\n-            hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.make(offset, id, scx),\n-            hir::TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref path)) => {\n-                let nested_ty = qself.make(offset + 1, id, scx)?;\n-                let prefix = format!(\n-                    \"<{} as {}>::\",\n-                    nested_ty.text,\n-                    path_segment_to_string(&path.segments[0])\n-                );\n-\n-                let name = path_segment_to_string(path.segments.last().ok_or(\"Bad path\")?);\n-                let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n-                let id = id_from_def_id(res.def_id());\n-                if path.segments.len() == 2 {\n-                    let start = offset + prefix.len();\n-                    let end = start + name.len();\n-\n-                    Ok(Signature {\n-                        text: prefix + &name,\n-                        defs: vec![],\n-                        refs: vec![SigElement { id, start, end }],\n-                    })\n-                } else {\n-                    let start = offset + prefix.len() + 5;\n-                    let end = start + name.len();\n-                    // FIXME should put the proper path in there, not ellipsis.\n-                    Ok(Signature {\n-                        text: prefix + \"...::\" + &name,\n-                        defs: vec![],\n-                        refs: vec![SigElement { id, start, end }],\n-                    })\n-                }\n-            }\n-            hir::TyKind::Path(hir::QPath::TypeRelative(ty, segment)) => {\n-                let nested_ty = ty.make(offset + 1, id, scx)?;\n-                let prefix = format!(\"<{}>::\", nested_ty.text);\n-\n-                let name = path_segment_to_string(segment);\n-                let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n-                let id = id_from_def_id(res.def_id());\n-\n-                let start = offset + prefix.len();\n-                let end = start + name.len();\n-                Ok(Signature {\n-                    text: prefix + &name,\n-                    defs: vec![],\n-                    refs: vec![SigElement { id, start, end }],\n-                })\n-            }\n-            hir::TyKind::Path(hir::QPath::LangItem(lang_item, _, _)) => {\n-                Ok(text_sig(format!(\"#[lang = \\\"{}\\\"]\", lang_item.name())))\n-            }\n-            hir::TyKind::TraitObject(bounds, ..) => {\n-                // FIXME recurse into bounds\n-                let bounds: Vec<hir::GenericBound<'_>> = bounds\n-                    .iter()\n-                    .map(|hir::PolyTraitRef { bound_generic_params, trait_ref, span }| {\n-                        hir::GenericBound::Trait(\n-                            hir::PolyTraitRef {\n-                                bound_generic_params,\n-                                trait_ref: hir::TraitRef {\n-                                    path: trait_ref.path,\n-                                    hir_ref_id: trait_ref.hir_ref_id,\n-                                },\n-                                span: *span,\n-                            },\n-                            hir::TraitBoundModifier::None,\n-                        )\n-                    })\n-                    .collect();\n-                let nested = bounds_to_string(&bounds);\n-                Ok(text_sig(nested))\n-            }\n-            hir::TyKind::Array(ref ty, ref length) => {\n-                let nested_ty = ty.make(offset + 1, id, scx)?;\n-                let expr = id_to_string(&scx.tcx.hir(), length.hir_id()).replace('\\n', \" \");\n-                let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n-                Ok(replace_text(nested_ty, text))\n-            }\n-            hir::TyKind::OpaqueDef(item_id, _, _) => {\n-                let item = scx.tcx.hir().item(item_id);\n-                item.make(offset, Some(item_id.hir_id()), scx)\n-            }\n-            hir::TyKind::Typeof(_) | hir::TyKind::Infer | hir::TyKind::Err => Err(\"Ty\"),\n-        }\n-    }\n-}\n-\n-impl<'hir> Sig for hir::Item<'hir> {\n-    type Parent = hir::HirId;\n-    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let id = Some(self.hir_id());\n-\n-        match self.kind {\n-            hir::ItemKind::Static(ref ty, m, ref body) => {\n-                let mut text = \"static \".to_owned();\n-                if m.is_mut() {\n-                    text.push_str(\"mut \");\n-                }\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                text.push_str(\": \");\n-\n-                let ty = ty.make(offset + text.len(), id, scx)?;\n-                text.push_str(&ty.text);\n-\n-                text.push_str(\" = \");\n-                let expr = id_to_string(&scx.tcx.hir(), body.hir_id).replace('\\n', \" \");\n-                text.push_str(&expr);\n-\n-                text.push(';');\n-\n-                Ok(extend_sig(ty, text, defs, vec![]))\n-            }\n-            hir::ItemKind::Const(ref ty, ref body) => {\n-                let mut text = \"const \".to_owned();\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                text.push_str(\": \");\n-\n-                let ty = ty.make(offset + text.len(), id, scx)?;\n-                text.push_str(&ty.text);\n-\n-                text.push_str(\" = \");\n-                let expr = id_to_string(&scx.tcx.hir(), body.hir_id).replace('\\n', \" \");\n-                text.push_str(&expr);\n-\n-                text.push(';');\n-\n-                Ok(extend_sig(ty, text, defs, vec![]))\n-            }\n-            hir::ItemKind::Fn(hir::FnSig { ref decl, header, span: _ }, ref generics, _) => {\n-                let mut text = String::new();\n-                if let hir::Constness::Const = header.constness {\n-                    text.push_str(\"const \");\n-                }\n-                if hir::IsAsync::Async == header.asyncness {\n-                    text.push_str(\"async \");\n-                }\n-                if let hir::Unsafety::Unsafe = header.unsafety {\n-                    text.push_str(\"unsafe \");\n-                }\n-                text.push_str(\"fn \");\n-\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                sig.text.push('(');\n-                for i in decl.inputs {\n-                    // FIXME should descend into patterns to add defs.\n-                    sig.text.push_str(\": \");\n-                    let nested = i.make(offset + sig.text.len(), Some(i.hir_id), scx)?;\n-                    sig.text.push_str(&nested.text);\n-                    sig.text.push(',');\n-                    sig.defs.extend(nested.defs.into_iter());\n-                    sig.refs.extend(nested.refs.into_iter());\n-                }\n-                sig.text.push(')');\n-\n-                if let hir::FnRetTy::Return(ref t) = decl.output {\n-                    sig.text.push_str(\" -> \");\n-                    let nested = t.make(offset + sig.text.len(), None, scx)?;\n-                    sig.text.push_str(&nested.text);\n-                    sig.defs.extend(nested.defs.into_iter());\n-                    sig.refs.extend(nested.refs.into_iter());\n-                }\n-                sig.text.push_str(\" {}\");\n-\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Macro(..) => {\n-                let mut text = \"macro\".to_owned();\n-                let name = self.ident.to_string();\n-                text.push_str(&name);\n-                text.push_str(&\"! {}\");\n-\n-                Ok(text_sig(text))\n-            }\n-            hir::ItemKind::Mod(ref _mod) => {\n-                let mut text = \"mod \".to_owned();\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                // Could be either `mod foo;` or `mod foo { ... }`, but we'll just pick one.\n-                text.push(';');\n-\n-                Ok(Signature { text, defs, refs: vec![] })\n-            }\n-            hir::ItemKind::TyAlias(ref ty, ref generics) => {\n-                let text = \"type \".to_owned();\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                sig.text.push_str(\" = \");\n-                let ty = ty.make(offset + sig.text.len(), id, scx)?;\n-                sig.text.push_str(&ty.text);\n-                sig.text.push(';');\n-\n-                Ok(merge_sigs(sig.text.clone(), vec![sig, ty]))\n-            }\n-            hir::ItemKind::Enum(_, ref generics) => {\n-                let text = \"enum \".to_owned();\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-                sig.text.push_str(\" {}\");\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Struct(_, ref generics) => {\n-                let text = \"struct \".to_owned();\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-                sig.text.push_str(\" {}\");\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Union(_, ref generics) => {\n-                let text = \"union \".to_owned();\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-                sig.text.push_str(\" {}\");\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Trait(is_auto, unsafety, ref generics, bounds, _) => {\n-                let mut text = String::new();\n-\n-                if is_auto == hir::IsAuto::Yes {\n-                    text.push_str(\"auto \");\n-                }\n-\n-                if let hir::Unsafety::Unsafe = unsafety {\n-                    text.push_str(\"unsafe \");\n-                }\n-                text.push_str(\"trait \");\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                if !bounds.is_empty() {\n-                    sig.text.push_str(\": \");\n-                    sig.text.push_str(&bounds_to_string(bounds));\n-                }\n-                // FIXME where clause\n-                sig.text.push_str(\" {}\");\n-\n-                Ok(sig)\n-            }\n-            hir::ItemKind::TraitAlias(ref generics, bounds) => {\n-                let mut text = String::new();\n-                text.push_str(\"trait \");\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                if !bounds.is_empty() {\n-                    sig.text.push_str(\" = \");\n-                    sig.text.push_str(&bounds_to_string(bounds));\n-                }\n-                // FIXME where clause\n-                sig.text.push(';');\n-\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Impl(hir::Impl {\n-                unsafety,\n-                polarity,\n-                defaultness,\n-                defaultness_span: _,\n-                constness,\n-                ref generics,\n-                ref of_trait,\n-                ref self_ty,\n-                items: _,\n-            }) => {\n-                let mut text = String::new();\n-                if let hir::Defaultness::Default { .. } = defaultness {\n-                    text.push_str(\"default \");\n-                }\n-                if let hir::Unsafety::Unsafe = unsafety {\n-                    text.push_str(\"unsafe \");\n-                }\n-                text.push_str(\"impl\");\n-                if let hir::Constness::Const = constness {\n-                    text.push_str(\" const\");\n-                }\n-\n-                let generics_sig =\n-                    generics.make(offset + text.len(), Some(self.owner_id.def_id), scx)?;\n-                text.push_str(&generics_sig.text);\n-\n-                text.push(' ');\n-\n-                let trait_sig = if let Some(ref t) = *of_trait {\n-                    if let hir::ImplPolarity::Negative(_) = polarity {\n-                        text.push('!');\n-                    }\n-                    let trait_sig = t.path.make(offset + text.len(), id, scx)?;\n-                    text.push_str(&trait_sig.text);\n-                    text.push_str(\" for \");\n-                    trait_sig\n-                } else {\n-                    text_sig(String::new())\n-                };\n-\n-                let ty_sig = self_ty.make(offset + text.len(), id, scx)?;\n-                text.push_str(&ty_sig.text);\n-\n-                text.push_str(\" {}\");\n-\n-                Ok(merge_sigs(text, vec![generics_sig, trait_sig, ty_sig]))\n-\n-                // FIXME where clause\n-            }\n-            hir::ItemKind::ForeignMod { .. } => Err(\"extern mod\"),\n-            hir::ItemKind::GlobalAsm(_) => Err(\"global asm\"),\n-            hir::ItemKind::ExternCrate(_) => Err(\"extern crate\"),\n-            hir::ItemKind::OpaqueTy(ref opaque) => {\n-                if opaque.in_trait {\n-                    Err(\"opaque type in trait\")\n-                } else {\n-                    Err(\"opaque type\")\n-                }\n-            }\n-            // FIXME should implement this (e.g., pub use).\n-            hir::ItemKind::Use(..) => Err(\"import\"),\n-        }\n-    }\n-}\n-\n-impl<'hir> Sig for hir::Path<'hir> {\n-    type Parent = hir::HirId;\n-    fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n-\n-        let (name, start, end) = match res {\n-            Res::PrimTy(..) | Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } | Res::Err => {\n-                return Ok(Signature { text: path_to_string(self), defs: vec![], refs: vec![] });\n-            }\n-            Res::Def(DefKind::AssocConst | DefKind::Variant | DefKind::Ctor(..), _) => {\n-                let len = self.segments.len();\n-                if len < 2 {\n-                    return Err(\"Bad path\");\n-                }\n-                // FIXME: really we should descend into the generics here and add SigElements for\n-                // them.\n-                // FIXME: would be nice to have a def for the first path segment.\n-                let seg1 = path_segment_to_string(&self.segments[len - 2]);\n-                let seg2 = path_segment_to_string(&self.segments[len - 1]);\n-                let start = offset + seg1.len() + 2;\n-                (format!(\"{}::{}\", seg1, seg2), start, start + seg2.len())\n-            }\n-            _ => {\n-                let name = path_segment_to_string(self.segments.last().ok_or(\"Bad path\")?);\n-                let end = offset + name.len();\n-                (name, offset, end)\n-            }\n-        };\n-\n-        let id = id_from_def_id(res.def_id());\n-        Ok(Signature { text: name, defs: vec![], refs: vec![SigElement { id, start, end }] })\n-    }\n-}\n-\n-// This does not cover the where clause, which must be processed separately.\n-impl<'hir> Sig for hir::Generics<'hir> {\n-    type Parent = LocalDefId;\n-    fn make(&self, offset: usize, _parent_id: Option<LocalDefId>, scx: &SaveContext<'_>) -> Result {\n-        if self.params.is_empty() {\n-            return Ok(text_sig(String::new()));\n-        }\n-\n-        let mut text = \"<\".to_owned();\n-\n-        let mut defs = Vec::with_capacity(self.params.len());\n-        for param in self.params {\n-            let mut param_text = String::new();\n-            if let hir::GenericParamKind::Const { .. } = param.kind {\n-                param_text.push_str(\"const \");\n-            }\n-            param_text.push_str(param.name.ident().as_str());\n-            defs.push(SigElement {\n-                id: id_from_def_id(param.def_id.to_def_id()),\n-                start: offset + text.len(),\n-                end: offset + text.len() + param_text.as_str().len(),\n-            });\n-            if let hir::GenericParamKind::Const { ref ty, default } = param.kind {\n-                param_text.push_str(\": \");\n-                param_text.push_str(&ty_to_string(&ty));\n-                if let Some(default) = default {\n-                    param_text.push_str(\" = \");\n-                    param_text.push_str(&id_to_string(&scx.tcx.hir(), default.hir_id));\n-                }\n-            }\n-            text.push_str(&param_text);\n-            text.push(',');\n-        }\n-\n-        text.push('>');\n-        Ok(Signature { text, defs, refs: vec![] })\n-    }\n-}\n-\n-impl<'hir> Sig for hir::FieldDef<'hir> {\n-    type Parent = LocalDefId;\n-    fn make(&self, offset: usize, _parent_id: Option<LocalDefId>, scx: &SaveContext<'_>) -> Result {\n-        let mut text = String::new();\n-\n-        text.push_str(&self.ident.to_string());\n-        let defs = Some(SigElement {\n-            id: id_from_def_id(self.def_id.to_def_id()),\n-            start: offset,\n-            end: offset + text.len(),\n-        });\n-        text.push_str(\": \");\n-\n-        let mut ty_sig = self.ty.make(offset + text.len(), Some(self.hir_id), scx)?;\n-        text.push_str(&ty_sig.text);\n-        ty_sig.text = text;\n-        ty_sig.defs.extend(defs.into_iter());\n-        Ok(ty_sig)\n-    }\n-}\n-\n-impl<'hir> Sig for hir::Variant<'hir> {\n-    type Parent = LocalDefId;\n-    fn make(&self, offset: usize, parent_id: Option<LocalDefId>, scx: &SaveContext<'_>) -> Result {\n-        let mut text = self.ident.to_string();\n-        match self.data {\n-            hir::VariantData::Struct(fields, r) => {\n-                let id = parent_id.ok_or(\"Missing id for Variant's parent\")?;\n-                let name_def = SigElement {\n-                    id: id_from_def_id(id.to_def_id()),\n-                    start: offset,\n-                    end: offset + text.len(),\n-                };\n-                text.push_str(\" { \");\n-                let mut defs = vec![name_def];\n-                let mut refs = vec![];\n-                if r {\n-                    text.push_str(\"/* parse error */ \");\n-                } else {\n-                    for f in fields {\n-                        let field_sig = f.make(offset + text.len(), Some(id), scx)?;\n-                        text.push_str(&field_sig.text);\n-                        text.push_str(\", \");\n-                        defs.extend(field_sig.defs.into_iter());\n-                        refs.extend(field_sig.refs.into_iter());\n-                    }\n-                }\n-                text.push('}');\n-                Ok(Signature { text, defs, refs })\n-            }\n-            hir::VariantData::Tuple(fields, _, def_id) => {\n-                let name_def = SigElement {\n-                    id: id_from_def_id(def_id.to_def_id()),\n-                    start: offset,\n-                    end: offset + text.len(),\n-                };\n-                text.push('(');\n-                let mut defs = vec![name_def];\n-                let mut refs = vec![];\n-                for f in fields {\n-                    let field_sig = f.make(offset + text.len(), Some(def_id), scx)?;\n-                    text.push_str(&field_sig.text);\n-                    text.push_str(\", \");\n-                    defs.extend(field_sig.defs.into_iter());\n-                    refs.extend(field_sig.refs.into_iter());\n-                }\n-                text.push(')');\n-                Ok(Signature { text, defs, refs })\n-            }\n-            hir::VariantData::Unit(_, def_id) => {\n-                let name_def = SigElement {\n-                    id: id_from_def_id(def_id.to_def_id()),\n-                    start: offset,\n-                    end: offset + text.len(),\n-                };\n-                Ok(Signature { text, defs: vec![name_def], refs: vec![] })\n-            }\n-        }\n-    }\n-}\n-\n-impl<'hir> Sig for hir::ForeignItem<'hir> {\n-    type Parent = hir::HirId;\n-    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let id = Some(self.hir_id());\n-        match self.kind {\n-            hir::ForeignItemKind::Fn(decl, _, ref generics) => {\n-                let mut text = String::new();\n-                text.push_str(\"fn \");\n-\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                sig.text.push('(');\n-                for i in decl.inputs {\n-                    sig.text.push_str(\": \");\n-                    let nested = i.make(offset + sig.text.len(), Some(i.hir_id), scx)?;\n-                    sig.text.push_str(&nested.text);\n-                    sig.text.push(',');\n-                    sig.defs.extend(nested.defs.into_iter());\n-                    sig.refs.extend(nested.refs.into_iter());\n-                }\n-                sig.text.push(')');\n-\n-                if let hir::FnRetTy::Return(ref t) = decl.output {\n-                    sig.text.push_str(\" -> \");\n-                    let nested = t.make(offset + sig.text.len(), None, scx)?;\n-                    sig.text.push_str(&nested.text);\n-                    sig.defs.extend(nested.defs.into_iter());\n-                    sig.refs.extend(nested.refs.into_iter());\n-                }\n-                sig.text.push(';');\n-\n-                Ok(sig)\n-            }\n-            hir::ForeignItemKind::Static(ref ty, m) => {\n-                let mut text = \"static \".to_owned();\n-                text.push_str(m.prefix_str());\n-\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                text.push_str(\": \");\n-\n-                let ty_sig = ty.make(offset + text.len(), id, scx)?;\n-                text.push(';');\n-\n-                Ok(extend_sig(ty_sig, text, defs, vec![]))\n-            }\n-            hir::ForeignItemKind::Type => {\n-                let mut text = \"type \".to_owned();\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                text.push(';');\n-\n-                Ok(Signature { text, defs, refs: vec![] })\n-            }\n-        }\n-    }\n-}\n-\n-fn name_and_generics(\n-    mut text: String,\n-    offset: usize,\n-    generics: &hir::Generics<'_>,\n-    id: hir::OwnerId,\n-    name: Ident,\n-    scx: &SaveContext<'_>,\n-) -> Result {\n-    let name = name.to_string();\n-    let def = SigElement {\n-        id: id_from_def_id(id.to_def_id()),\n-        start: offset + text.len(),\n-        end: offset + text.len() + name.len(),\n-    };\n-    text.push_str(&name);\n-    let generics: Signature = generics.make(offset + text.len(), Some(id.def_id), scx)?;\n-    // FIXME where clause\n-    let text = format!(\"{}{}\", text, generics.text);\n-    Ok(extend_sig(generics, text, vec![def], vec![]))\n-}\n-\n-fn make_assoc_type_signature(\n-    id: hir::OwnerId,\n-    ident: Ident,\n-    bounds: Option<hir::GenericBounds<'_>>,\n-    default: Option<&hir::Ty<'_>>,\n-    scx: &SaveContext<'_>,\n-) -> Result {\n-    let mut text = \"type \".to_owned();\n-    let name = ident.to_string();\n-    let mut defs = vec![SigElement {\n-        id: id_from_def_id(id.to_def_id()),\n-        start: text.len(),\n-        end: text.len() + name.len(),\n-    }];\n-    let mut refs = vec![];\n-    text.push_str(&name);\n-    if let Some(bounds) = bounds {\n-        text.push_str(\": \");\n-        // FIXME should descend into bounds\n-        text.push_str(&bounds_to_string(bounds));\n-    }\n-    if let Some(default) = default {\n-        text.push_str(\" = \");\n-        let ty_sig = default.make(text.len(), Some(id.into()), scx)?;\n-        text.push_str(&ty_sig.text);\n-        defs.extend(ty_sig.defs.into_iter());\n-        refs.extend(ty_sig.refs.into_iter());\n-    }\n-    text.push(';');\n-    Ok(Signature { text, defs, refs })\n-}\n-\n-fn make_assoc_const_signature(\n-    id: hir::OwnerId,\n-    ident: Symbol,\n-    ty: &hir::Ty<'_>,\n-    default: Option<&hir::Expr<'_>>,\n-    scx: &SaveContext<'_>,\n-) -> Result {\n-    let mut text = \"const \".to_owned();\n-    let name = ident.to_string();\n-    let mut defs = vec![SigElement {\n-        id: id_from_def_id(id.to_def_id()),\n-        start: text.len(),\n-        end: text.len() + name.len(),\n-    }];\n-    let mut refs = vec![];\n-    text.push_str(&name);\n-    text.push_str(\": \");\n-\n-    let ty_sig = ty.make(text.len(), Some(id.into()), scx)?;\n-    text.push_str(&ty_sig.text);\n-    defs.extend(ty_sig.defs.into_iter());\n-    refs.extend(ty_sig.refs.into_iter());\n-\n-    if let Some(default) = default {\n-        text.push_str(\" = \");\n-        text.push_str(&id_to_string(&scx.tcx.hir(), default.hir_id));\n-    }\n-    text.push(';');\n-    Ok(Signature { text, defs, refs })\n-}\n-\n-fn make_method_signature(\n-    id: hir::OwnerId,\n-    ident: Ident,\n-    generics: &hir::Generics<'_>,\n-    m: &hir::FnSig<'_>,\n-    scx: &SaveContext<'_>,\n-) -> Result {\n-    // FIXME code dup with function signature\n-    let mut text = String::new();\n-    if let hir::Constness::Const = m.header.constness {\n-        text.push_str(\"const \");\n-    }\n-    if hir::IsAsync::Async == m.header.asyncness {\n-        text.push_str(\"async \");\n-    }\n-    if let hir::Unsafety::Unsafe = m.header.unsafety {\n-        text.push_str(\"unsafe \");\n-    }\n-    text.push_str(\"fn \");\n-\n-    let mut sig = name_and_generics(text, 0, generics, id, ident, scx)?;\n-\n-    sig.text.push('(');\n-    for i in m.decl.inputs {\n-        sig.text.push_str(\": \");\n-        let nested = i.make(sig.text.len(), Some(i.hir_id), scx)?;\n-        sig.text.push_str(&nested.text);\n-        sig.text.push(',');\n-        sig.defs.extend(nested.defs.into_iter());\n-        sig.refs.extend(nested.refs.into_iter());\n-    }\n-    sig.text.push(')');\n-\n-    if let hir::FnRetTy::Return(ref t) = m.decl.output {\n-        sig.text.push_str(\" -> \");\n-        let nested = t.make(sig.text.len(), None, scx)?;\n-        sig.text.push_str(&nested.text);\n-        sig.defs.extend(nested.defs.into_iter());\n-        sig.refs.extend(nested.refs.into_iter());\n-    }\n-    sig.text.push_str(\" {}\");\n-\n-    Ok(sig)\n-}"}, {"sha": "e65d57bb3db3e7737ffbc18b8670df244346be6f", "filename": "compiler/rustc_save_analysis/src/span_utils.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,96 +0,0 @@\n-use crate::generated_code;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_lexer::{tokenize, TokenKind};\n-use rustc_session::Session;\n-use rustc_span::*;\n-\n-#[derive(Clone)]\n-pub struct SpanUtils<'a> {\n-    pub sess: &'a Session,\n-}\n-\n-impl<'a> SpanUtils<'a> {\n-    pub fn new(sess: &'a Session) -> SpanUtils<'a> {\n-        SpanUtils { sess }\n-    }\n-\n-    pub fn make_filename_string(&self, file: &SourceFile) -> String {\n-        match &file.name {\n-            FileName::Real(RealFileName::LocalPath(path)) => {\n-                if path.is_absolute() {\n-                    self.sess.source_map().path_mapping().map_prefix(path).0.display().to_string()\n-                } else {\n-                    self.sess\n-                        .opts\n-                        .working_dir\n-                        .remapped_path_if_available()\n-                        .join(&path)\n-                        .display()\n-                        .to_string()\n-                }\n-            }\n-            filename => filename.prefer_remapped().to_string(),\n-        }\n-    }\n-\n-    pub fn snippet(&self, span: Span) -> String {\n-        match self.sess.source_map().span_to_snippet(span) {\n-            Ok(s) => s,\n-            Err(_) => String::new(),\n-        }\n-    }\n-\n-    /// Finds the span of `*` token withing the larger `span`.\n-    pub fn sub_span_of_star(&self, mut span: Span) -> Option<Span> {\n-        let begin = self.sess.source_map().lookup_byte_offset(span.lo());\n-        let end = self.sess.source_map().lookup_byte_offset(span.hi());\n-        // Make the range zero-length if the span is invalid.\n-        if begin.sf.start_pos != end.sf.start_pos {\n-            span = span.shrink_to_lo();\n-        }\n-\n-        let sf = Lrc::clone(&begin.sf);\n-\n-        self.sess.source_map().ensure_source_file_source_present(Lrc::clone(&sf));\n-        let src =\n-            sf.src.clone().or_else(|| sf.external_src.borrow().get_source().map(Lrc::clone))?;\n-        let to_index = |pos: BytePos| -> usize { (pos - sf.start_pos).0 as usize };\n-        let text = &src[to_index(span.lo())..to_index(span.hi())];\n-        let start_pos = {\n-            let mut pos = 0;\n-            tokenize(text)\n-                .map(|token| {\n-                    let start = pos;\n-                    pos += token.len;\n-                    (start, token)\n-                })\n-                .find(|(_pos, token)| token.kind == TokenKind::Star)?\n-                .0\n-        };\n-        let lo = span.lo() + BytePos(start_pos as u32);\n-        let hi = lo + BytePos(1);\n-        Some(span.with_lo(lo).with_hi(hi))\n-    }\n-\n-    /// Return true if the span is generated code, and\n-    /// it is not a subspan of the root callsite.\n-    ///\n-    /// Used to filter out spans of minimal value,\n-    /// such as references to macro internal variables.\n-    pub fn filter_generated(&self, span: Span) -> bool {\n-        if generated_code(span) {\n-            return true;\n-        }\n-\n-        //If the span comes from a fake source_file, filter it.\n-        !self.sess.source_map().lookup_char_pos(span.lo()).file.is_real_file()\n-    }\n-}\n-\n-macro_rules! filter {\n-    ($util: expr, $parent: expr) => {\n-        if $util.filter_generated($parent) {\n-            return None;\n-        }\n-    };\n-}"}, {"sha": "d9e68320f8ffa5e1fa5247c391294f3b1e4c326b", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1629,9 +1629,6 @@ options! {\n     saturating_float_casts: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"make float->int casts UB-free: numbers outside the integer type's range are clipped to \\\n         the max/min integer respectively, and NaN is mapped to 0 (default: yes)\"),\n-    save_analysis: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in JSON format) information, in \\\n-        addition to normal output (default: no)\"),\n     self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n         parse_switch_with_opt_path, [UNTRACKED],\n         \"run the self profiler and output the raw event data\"),"}, {"sha": "952c70cec1c057007046515372e9bf139f279c42", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -780,7 +780,6 @@ impl<'a> Builder<'a> {\n                 install::Clippy,\n                 install::Miri,\n                 install::LlvmTools,\n-                install::Analysis,\n                 install::Src,\n                 install::Rustc\n             ),\n@@ -1802,16 +1801,6 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        if mode == Mode::Std && self.config.extended && compiler.is_final_stage(self) {\n-            rustflags.arg(\"-Zsave-analysis\");\n-            cargo.env(\n-                \"RUST_SAVE_ANALYSIS_CONFIG\",\n-                \"{\\\"output_file\\\": null,\\\"full_docs\\\": false,\\\n-                       \\\"pub_only\\\": true,\\\"reachable_only\\\": false,\\\n-                       \\\"distro_crate\\\": true,\\\"signatures\\\": false,\\\"borrow_data\\\": false}\",\n-            );\n-        }\n-\n         // If Control Flow Guard is enabled, pass the `control-flow-guard` flag to rustc\n         // when compiling the standard library, since this might be linked into the final outputs\n         // produced by rustc. Since this mitigation is only available on Windows, only enable it"}, {"sha": "9b2b549612d81183f64c027f2a5a182cdd4368d7", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -12,6 +12,7 @@ use std::collections::HashSet;\n use std::env;\n use std::ffi::OsStr;\n use std::fs;\n+use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n@@ -753,22 +754,28 @@ impl Step for Analysis {\n         });\n     }\n \n-    /// Creates a tarball of save-analysis metadata, if available.\n+    /// Creates a tarball of (degenerate) save-analysis metadata, if available.\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         if compiler.host != builder.config.build {\n             return None;\n         }\n \n-        builder.ensure(compile::Std::new(compiler, target));\n         let src = builder\n             .stage_out(compiler, Mode::Std)\n             .join(target.triple)\n             .join(builder.cargo_dir())\n             .join(\"deps\")\n             .join(\"save-analysis\");\n \n+        // Write a file indicating that this component has been removed.\n+        t!(std::fs::create_dir_all(&src));\n+        let mut removed = src.clone();\n+        removed.push(\"removed.json\");\n+        let mut f = t!(std::fs::File::create(removed));\n+        t!(write!(f, r#\"{{ \"warning\": \"The `rust-analysis` component has been removed.\" }}\"#));\n+\n         let mut tarball = Tarball::new(builder, \"rust-analysis\", &target.triple);\n         tarball.include_target_in_component_name(true);\n         tarball.add_dir(src, format!(\"lib/rustlib/{}/analysis\", target.triple));"}, {"sha": "ac3843c3344eb97cf3446c1d4d8d268721f90156", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -243,18 +243,6 @@ install!((self, builder, _config),\n             );\n         }\n     };\n-    Analysis, alias = \"analysis\", Self::should_build(_config), only_hosts: false, {\n-        // `expect` should be safe, only None with host != build, but this\n-        // only uses the `build` compiler\n-        let tarball = builder.ensure(dist::Analysis {\n-            // Find the actual compiler (handling the full bootstrap option) which\n-            // produced the save-analysis data because that data isn't copied\n-            // through the sysroot uplifting.\n-            compiler: builder.compiler_for(builder.top_stage, builder.config.build, self.target),\n-            target: self.target\n-        }).expect(\"missing analysis\");\n-        install_sh(builder, \"analysis\", self.compiler.stage, Some(self.target), &tarball);\n-    };\n     Rustc, path = \"compiler/rustc\", true, only_hosts: true, {\n         let tarball = builder.ensure(dist::Rustc {\n             compiler: builder.compiler(builder.top_stage, self.target),"}, {"sha": "d8843280b844f36755de3e45b41c4d8680ad6815", "filename": "src/doc/rustc/src/json.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -223,7 +223,6 @@ flag][option-emit] documentation.\n        - \"link\": The generated crate as specified by the crate-type.\n        - \"dep-info\": The `.d` file with dependency information in a Makefile-like syntax.\n        - \"metadata\": The Rust `.rmeta` file containing metadata about the crate.\n-       - \"save-analysis\": A JSON file emitted by the `-Zsave-analysis` feature.\n     */\n     \"emit\": \"link\"\n }"}, {"sha": "4c93f8a16b670a2969feed8ae112162c7fbc1789", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -192,8 +192,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"regex-automata\",\n     \"regex-syntax\",\n     \"remove_dir_all\",\n-    \"rls-data\",\n-    \"rls-span\",\n     \"rustc-demangle\",\n     \"rustc-hash\",\n     \"rustc-rayon\","}, {"sha": "e451cb03126ccc4ff036bf590491bce9c961a76f", "filename": "tests/run-make-fulldeps/issues-41478-43796/Makefile", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2FMakefile?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,8 +0,0 @@\n-include ../tools.mk\n-\n-all:\n-\t# Work in /tmp, because we need to create the `save-analysis-temp` folder.\n-\tcp a.rs $(TMPDIR)/\n-\tcd $(TMPDIR) && $(RUSTC) -Zsave-analysis $(TMPDIR)/a.rs 2> $(TMPDIR)/stderr.txt || ( cat $(TMPDIR)/stderr.txt && exit 1 )\n-\t[ ! -s $(TMPDIR)/stderr.txt ] || ( cat $(TMPDIR)/stderr.txt && exit 1 )\n-\t[ -f $(TMPDIR)/save-analysis/liba.json ] || ( ls -la $(TMPDIR) && exit 1 )"}, {"sha": "b072235b5bc5ad21f87ed52d5ca24bd4362ebd3e", "filename": "tests/run-make-fulldeps/issues-41478-43796/a.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2Fa.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,9 +0,0 @@\n-#![crate_type = \"lib\"]\n-pub struct V<S>(#[allow(unused_tuple_struct_fields)] S);\n-pub trait An {\n-    type U;\n-}\n-pub trait F<A> {\n-}\n-impl<A: An> F<A> for V<<A as An>::U> {\n-}"}, {"sha": "69a2b2746948bb9d801ae44862b1062b82a92bd9", "filename": "tests/run-make-fulldeps/save-analysis-fail/Makefile", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FMakefile?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,6 +0,0 @@\n-include ../tools.mk\n-all: code\n-krate2: krate2.rs\n-\t$(RUSTC) $<\n-code: foo.rs krate2\n-\t$(RUSTC) foo.rs -Zsave-analysis || exit 0"}, {"sha": "2c690d5f759d785263aaf0a7c30fdf319a76dcd4", "filename": "tests/run-make-fulldeps/save-analysis-fail/SameDir.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,5 +0,0 @@\n-// sub-module in the same directory as the main crate file\n-\n-pub struct SameStruct {\n-    pub name: String\n-}"}, {"sha": "fab03ee2e3d15d6dc55bea42c2d4abc7dea7fbb8", "filename": "tests/run-make-fulldeps/save-analysis-fail/SameDir3.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir3.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,3 +0,0 @@\n-pub fn hello(x: isize) {\n-    println!(\"macro {} :-(\", x);\n-}"}, {"sha": "511721d92a350f4adede0e99a16c45b9373777d7", "filename": "tests/run-make-fulldeps/save-analysis-fail/SubDir/mod.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSubDir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSubDir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSubDir%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,27 +0,0 @@\n-// sub-module in a sub-directory\n-\n-use sub::sub2 as msalias;\n-use sub::sub2;\n-\n-static yy: usize = 25;\n-\n-mod sub {\n-    pub mod sub2 {\n-        pub mod sub3 {\n-            pub fn hello() {\n-                println!(\"hello from module 3\");\n-            }\n-        }\n-        pub fn hello() {\n-            println!(\"hello from a module\");\n-        }\n-\n-        pub struct nested_struct {\n-            pub field2: u32,\n-        }\n-    }\n-}\n-\n-pub struct SubStruct {\n-    pub name: String\n-}"}, {"sha": "c5a70605e04cb2c9a6839d060947cec8c6182f2c", "filename": "tests/run-make-fulldeps/save-analysis-fail/foo.rs", "status": "removed", "additions": 0, "deletions": 463, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Ffoo.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,463 +0,0 @@\n-#![crate_name = \"test\"]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_graphviz;\n-// A simple rust project\n-\n-extern crate krate2;\n-extern crate krate2 as krate3;\n-\n-use rustc_graphviz::RenderOption;\n-use std::cell::RefCell;\n-use std::collections::{HashMap, HashSet};\n-use std::io::Write;\n-\n-use sub::sub2 as msalias;\n-use sub::sub2;\n-use sub::sub2::nested_struct as sub_struct;\n-\n-use std::mem::size_of;\n-\n-use std::char::from_u32;\n-\n-static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n-static yy: usize = 25;\n-\n-static bob: Option<graphviz::RenderOption> = None;\n-\n-// buglink test - see issue #1337.\n-\n-fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n-    let s = sub_struct { field2: 45u32 };\n-\n-    // import tests\n-    fn foo(x: &Write) {}\n-    let _: Option<_> = from_u32(45);\n-\n-    let x = 42usize;\n-\n-    krate2::hello();\n-    krate3::hello();\n-\n-    let x = (3isize, 4usize);\n-    let y = x.1;\n-}\n-\n-// Issue #37700\n-const LUT_BITS: usize = 3;\n-pub struct HuffmanTable {\n-    ac_lut: Option<[(i16, u8); 1 << LUT_BITS]>,\n-}\n-\n-struct TupStruct(isize, isize, Box<str>);\n-\n-fn test_tup_struct(x: TupStruct) -> isize {\n-    x.1\n-}\n-\n-fn println(s: &str) {\n-    std::io::stdout().write_all(s.as_bytes());\n-}\n-\n-mod sub {\n-    pub mod sub2 {\n-        use std::io::Write;\n-        pub mod sub3 {\n-            use std::io::Write;\n-            pub fn hello() {\n-                ::println(\"hello from module 3\");\n-            }\n-        }\n-        pub fn hello() {\n-            ::println(\"hello from a module\");\n-        }\n-\n-        pub struct nested_struct {\n-            pub field2: u32,\n-        }\n-\n-        pub enum nested_enum {\n-            Nest2 = 2,\n-            Nest3 = 3,\n-        }\n-    }\n-}\n-\n-pub mod SameDir;\n-pub mod SubDir;\n-\n-#[path = \"SameDir3.rs\"]\n-pub mod SameDir2;\n-\n-struct nofields;\n-\n-#[derive(Clone)]\n-struct some_fields {\n-    field1: u32,\n-}\n-\n-type SF = some_fields;\n-\n-trait SuperTrait {\n-    fn qux(&self) {\n-        panic!();\n-    }\n-}\n-\n-trait SomeTrait: SuperTrait {\n-    fn Method(&self, x: u32) -> u32;\n-\n-    fn prov(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n-        42\n-    }\n-    fn provided_method(&self) -> u32 {\n-        42\n-    }\n-}\n-\n-trait SubTrait: SomeTrait {\n-    fn stat2(x: &Self) -> u32 {\n-        32\n-    }\n-}\n-\n-trait SizedTrait: Sized {}\n-\n-fn error(s: &SizedTrait) {\n-    let foo = 42;\n-    println!(\"Hello world! {}\", foo);\n-}\n-\n-impl SomeTrait for some_fields {\n-    fn Method(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n-        self.field1\n-    }\n-}\n-\n-impl SuperTrait for some_fields {}\n-\n-impl SubTrait for some_fields {}\n-\n-impl some_fields {\n-    fn stat(x: u32) -> u32 {\n-        println(&x.to_string());\n-        42\n-    }\n-    fn stat2(x: &some_fields) -> u32 {\n-        42\n-    }\n-\n-    fn align_to<T>(&mut self) {}\n-\n-    fn test(&mut self) {\n-        self.align_to::<bool>();\n-    }\n-}\n-\n-impl SuperTrait for nofields {}\n-impl SomeTrait for nofields {\n-    fn Method(&self, x: u32) -> u32 {\n-        self.Method(x);\n-        43\n-    }\n-\n-    fn provided_method(&self) -> u32 {\n-        21\n-    }\n-}\n-\n-impl SubTrait for nofields {}\n-\n-impl SuperTrait for (Box<nofields>, Box<some_fields>) {}\n-\n-fn f_with_params<T: SomeTrait>(x: &T) {\n-    x.Method(41);\n-}\n-\n-type MyType = Box<some_fields>;\n-\n-enum SomeEnum<'a> {\n-    Ints(isize, isize),\n-    Floats(f64, f64),\n-    Strings(&'a str, &'a str, &'a str),\n-    MyTypes(MyType, MyType),\n-}\n-\n-#[derive(Copy, Clone)]\n-enum SomeOtherEnum {\n-    SomeConst1,\n-    SomeConst2,\n-    SomeConst3,\n-}\n-\n-enum SomeStructEnum {\n-    EnumStruct { a: isize, b: isize },\n-    EnumStruct2 { f1: MyType, f2: MyType },\n-    EnumStruct3 { f1: MyType, f2: MyType, f3: SomeEnum<'static> },\n-}\n-\n-fn matchSomeEnum(val: SomeEnum) {\n-    match val {\n-        SomeEnum::Ints(int1, int2) => {\n-            println(&(int1 + int2).to_string());\n-        }\n-        SomeEnum::Floats(float1, float2) => {\n-            println(&(float2 * float1).to_string());\n-        }\n-        SomeEnum::Strings(.., s3) => {\n-            println(s3);\n-        }\n-        SomeEnum::MyTypes(mt1, mt2) => {\n-            println(&(mt1.field1 - mt2.field1).to_string());\n-        }\n-    }\n-}\n-\n-fn matchSomeStructEnum(se: SomeStructEnum) {\n-    match se {\n-        SomeStructEnum::EnumStruct { a: a, .. } => println(&a.to_string()),\n-        SomeStructEnum::EnumStruct2 { f1: f1, f2: f_2 } => println(&f_2.field1.to_string()),\n-        SomeStructEnum::EnumStruct3 { f1, .. } => println(&f1.field1.to_string()),\n-    }\n-}\n-\n-fn matchSomeStructEnum2(se: SomeStructEnum) {\n-    use SomeStructEnum::*;\n-    match se {\n-        EnumStruct { a: ref aaa, .. } => println(&aaa.to_string()),\n-        EnumStruct2 { f1, f2: f2 } => println(&f1.field1.to_string()),\n-        EnumStruct3 { f1, f3: SomeEnum::Ints(..), f2 } => println(&f1.field1.to_string()),\n-        _ => {}\n-    }\n-}\n-\n-fn matchSomeOtherEnum(val: SomeOtherEnum) {\n-    use SomeOtherEnum::{SomeConst2, SomeConst3};\n-    match val {\n-        SomeOtherEnum::SomeConst1 => {\n-            println(\"I'm const1.\");\n-        }\n-        SomeConst2 | SomeConst3 => {\n-            println(\"I'm const2 or const3.\");\n-        }\n-    }\n-}\n-\n-fn hello<X: SomeTrait>((z, a): (u32, String), ex: X) {\n-    SameDir2::hello(43);\n-\n-    println(&yy.to_string());\n-    let (x, y): (u32, u32) = (5, 3);\n-    println(&x.to_string());\n-    println(&z.to_string());\n-    let x: u32 = x;\n-    println(&x.to_string());\n-    let x = \"hello\";\n-    println(x);\n-\n-    let x = 32.0f32;\n-    let _ = (x + ((x * x) + 1.0).sqrt()).ln();\n-\n-    let s: Box<SomeTrait> = Box::new(some_fields { field1: 43 });\n-    let s2: Box<some_fields> = Box::new(some_fields { field1: 43 });\n-    let s3 = Box::new(nofields);\n-\n-    s.Method(43);\n-    s3.Method(43);\n-    s2.Method(43);\n-\n-    ex.prov(43);\n-\n-    let y: u32 = 56;\n-    // static method on struct\n-    let r = some_fields::stat(y);\n-    // trait static method, calls default\n-    let r = SubTrait::stat2(&*s3);\n-\n-    let s4 = s3 as Box<SomeTrait>;\n-    s4.Method(43);\n-\n-    s4.provided_method();\n-    s2.prov(45);\n-\n-    let closure = |x: u32, s: &SomeTrait| {\n-        s.Method(23);\n-        return x + y;\n-    };\n-\n-    let z = closure(10, &*s);\n-}\n-\n-pub struct blah {\n-    used_link_args: RefCell<[&'static str; 0]>,\n-}\n-\n-#[macro_use]\n-mod macro_use_test {\n-    macro_rules! test_rec {\n-        (q, $src: expr) => {{\n-            print!(\"{}\", $src);\n-            test_rec!($src);\n-        }};\n-        ($src: expr) => {\n-            print!(\"{}\", $src);\n-        };\n-    }\n-\n-    macro_rules! internal_vars {\n-        ($src: ident) => {{\n-            let mut x = $src;\n-            x += 100;\n-        }};\n-    }\n-}\n-\n-fn main() {\n-    // foo\n-    let s = Box::new(some_fields { field1: 43 });\n-    hello((43, \"a\".to_string()), *s);\n-    sub::sub2::hello();\n-    sub2::sub3::hello();\n-\n-    let h = sub2::sub3::hello;\n-    h();\n-\n-    // utf8 chars\n-    let ut = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n-\n-    // For some reason, this pattern of macro_rules foiled our generated code\n-    // avoiding strategy.\n-    macro_rules! variable_str(($name:expr) => (\n-        some_fields {\n-            field1: $name,\n-        }\n-    ));\n-    let vs = variable_str!(32);\n-\n-    let mut candidates: RefCell<HashMap<&'static str, &'static str>> = RefCell::new(HashMap::new());\n-    let _ = blah { used_link_args: RefCell::new([]) };\n-    let s1 = nofields;\n-    let s2 = SF { field1: 55 };\n-    let s3: some_fields = some_fields { field1: 55 };\n-    let s4: msalias::nested_struct = sub::sub2::nested_struct { field2: 55 };\n-    let s4: msalias::nested_struct = sub2::nested_struct { field2: 55 };\n-    println(&s2.field1.to_string());\n-    let s5: MyType = Box::new(some_fields { field1: 55 });\n-    let s = SameDir::SameStruct { name: \"Bob\".to_string() };\n-    let s = SubDir::SubStruct { name: \"Bob\".to_string() };\n-    let s6: SomeEnum = SomeEnum::MyTypes(Box::new(s2.clone()), s5);\n-    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n-    matchSomeEnum(s6);\n-    matchSomeEnum(s7);\n-    let s8: SomeOtherEnum = SomeOtherEnum::SomeConst2;\n-    matchSomeOtherEnum(s8);\n-    let s9: SomeStructEnum =\n-        SomeStructEnum::EnumStruct2 { f1: Box::new(some_fields { field1: 10 }), f2: Box::new(s2) };\n-    matchSomeStructEnum(s9);\n-\n-    for x in &vec![1, 2, 3] {\n-        let _y = x;\n-    }\n-\n-    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n-    if let SomeEnum::Strings(..) = s7 {\n-        println!(\"hello!\");\n-    }\n-\n-    for i in 0..5 {\n-        foo_foo(i);\n-    }\n-\n-    if let Some(x) = None {\n-        foo_foo(x);\n-    }\n-\n-    if false {\n-    } else if let Some(y) = None {\n-        foo_foo(y);\n-    }\n-\n-    while let Some(z) = None {\n-        foo_foo(z);\n-    }\n-\n-    let mut x = 4;\n-    test_rec!(q, \"Hello\");\n-    assert_eq!(x, 4);\n-    internal_vars!(x);\n-}\n-\n-fn foo_foo(_: i32) {}\n-\n-impl Iterator for nofields {\n-    type Item = (usize, usize);\n-\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        panic!()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        panic!()\n-    }\n-}\n-\n-trait Pattern<'a> {\n-    type Searcher;\n-}\n-\n-struct CharEqPattern;\n-\n-impl<'a> Pattern<'a> for CharEqPattern {\n-    type Searcher = CharEqPattern;\n-}\n-\n-struct CharSearcher<'a>(<CharEqPattern as Pattern<'a>>::Searcher);\n-\n-pub trait Error {}\n-\n-impl Error + 'static {\n-    pub fn is<T: Error + 'static>(&self) -> bool {\n-        panic!()\n-    }\n-}\n-\n-impl Error + 'static + Send {\n-    pub fn is<T: Error + 'static>(&self) -> bool {\n-        <Error + 'static>::is::<T>(self)\n-    }\n-}\n-extern crate serialize;\n-#[derive(Clone, Copy, Hash, Encodable, Decodable, PartialEq, Eq, PartialOrd, Ord, Debug, Default)]\n-struct AllDerives(i32);\n-\n-fn test_format_args() {\n-    let x = 1;\n-    let y = 2;\n-    let name = \"Joe Blogg\";\n-    println!(\"Hello {}\", name);\n-    print!(\"Hello {0}\", name);\n-    print!(\"{0} + {} = {}\", x, y);\n-    print!(\"x is {}, y is {1}, name is {n}\", x, y, n = name);\n-}\n-\n-extern \"C\" {\n-    static EXTERN_FOO: u8;\n-    fn extern_foo(a: u8, b: i32) -> String;\n-}\n-\n-struct Rls699 {\n-    f: u32,\n-}\n-\n-fn new(f: u32) -> Rls699 {\n-    Rls699 { fs }\n-}\n-\n-fn invalid_tuple_struct_access() {\n-    bar.0;\n-\n-    struct S;\n-    S.0;\n-}"}, {"sha": "7d787e0c9871f4d760dca5403f17fa42da972932", "filename": "tests/run-make-fulldeps/save-analysis-fail/krate2.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Fkrate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Fkrate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Fkrate2.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,8 +0,0 @@\n-#![ crate_name = \"krate2\" ]\n-#![ crate_type = \"lib\" ]\n-\n-use std::io::Write;\n-\n-pub fn hello() {\n-    std::io::stdout().write_all(b\"hello world!\\n\");\n-}"}, {"sha": "30f57034bba55b5acc1b5882cb6943c0c901c7a8", "filename": "tests/run-make-fulldeps/save-analysis-rfc2126/Makefile", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2FMakefile?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,8 +0,0 @@\n-include ../tools.mk\n-\n-all: extern_absolute_paths.rs krate2\n-\t$(RUSTC) extern_absolute_paths.rs -Zsave-analysis --edition=2018 --extern krate2\n-\tcat $(TMPDIR)/save-analysis/extern_absolute_paths.json | \"$(PYTHON)\" validate_json.py\n-\n-krate2: krate2.rs\n-\t$(RUSTC) $<"}, {"sha": "7a8e3fff098a01042e21b985b2f03718c5442270", "filename": "tests/run-make-fulldeps/save-analysis-rfc2126/extern_absolute_paths.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fextern_absolute_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fextern_absolute_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fextern_absolute_paths.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,6 +0,0 @@\n-use krate2::hello;\n-\n-fn main() {\n-    hello();\n-    ::krate2::hello();\n-}"}, {"sha": "d24c68862b074e905182b72a9c8a101bd9c620e6", "filename": "tests/run-make-fulldeps/save-analysis-rfc2126/krate2.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fkrate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fkrate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fkrate2.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,5 +0,0 @@\n-#![crate_name = \"krate2\"]\n-#![crate_type = \"lib\"]\n-\n-pub fn hello() {\n-}"}, {"sha": "882d29a8beb23a8963a6fa1d2a3d35a03d3e1687", "filename": "tests/run-make-fulldeps/save-analysis-rfc2126/validate_json.py", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fvalidate_json.py", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fvalidate_json.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fvalidate_json.py?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,7 +0,0 @@\n-#!/usr/bin/env python\n-\n-import sys\n-import json\n-\n-crates = json.loads(sys.stdin.readline().strip())[\"prelude\"][\"external_crates\"]\n-assert any(map(lambda c: c[\"id\"][\"name\"] == \"krate2\", crates))"}, {"sha": "b8b6be13dbd768a8375e994ca6d02c4e8780e44e", "filename": "tests/run-make-fulldeps/save-analysis/Makefile", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2FMakefile?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,6 +0,0 @@\n-include ../tools.mk\n-all: code\n-krate2: krate2.rs\n-\t$(RUSTC) $<\n-code: foo.rs krate2\n-\t$(RUSTC) foo.rs -Zsave-analysis"}, {"sha": "2c690d5f759d785263aaf0a7c30fdf319a76dcd4", "filename": "tests/run-make-fulldeps/save-analysis/SameDir.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,5 +0,0 @@\n-// sub-module in the same directory as the main crate file\n-\n-pub struct SameStruct {\n-    pub name: String\n-}"}, {"sha": "fab03ee2e3d15d6dc55bea42c2d4abc7dea7fbb8", "filename": "tests/run-make-fulldeps/save-analysis/SameDir3.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir3.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,3 +0,0 @@\n-pub fn hello(x: isize) {\n-    println!(\"macro {} :-(\", x);\n-}"}, {"sha": "511721d92a350f4adede0e99a16c45b9373777d7", "filename": "tests/run-make-fulldeps/save-analysis/SubDir/mod.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSubDir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSubDir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSubDir%2Fmod.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,27 +0,0 @@\n-// sub-module in a sub-directory\n-\n-use sub::sub2 as msalias;\n-use sub::sub2;\n-\n-static yy: usize = 25;\n-\n-mod sub {\n-    pub mod sub2 {\n-        pub mod sub3 {\n-            pub fn hello() {\n-                println!(\"hello from module 3\");\n-            }\n-        }\n-        pub fn hello() {\n-            println!(\"hello from a module\");\n-        }\n-\n-        pub struct nested_struct {\n-            pub field2: u32,\n-        }\n-    }\n-}\n-\n-pub struct SubStruct {\n-    pub name: String\n-}"}, {"sha": "0605ca517ff3bdfaf4f613ef0a988ed61187a4d9", "filename": "tests/run-make-fulldeps/save-analysis/extra-docs.md", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fextra-docs.md", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fextra-docs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fextra-docs.md?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1 +0,0 @@\n-Extra docs for this struct."}, {"sha": "384589de3b4807b789679eca7020edfdd3006ad1", "filename": "tests/run-make-fulldeps/save-analysis/foo.rs", "status": "removed", "additions": 0, "deletions": 465, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2Ffoo.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,465 +0,0 @@\n-#![crate_name = \"test\"]\n-#![feature(rustc_private)]\n-#![feature(associated_type_defaults)]\n-\n-extern crate rustc_graphviz;\n-// A simple rust project\n-\n-// Necessary to pull in object code as the rest of the rustc crates are shipped only as rmeta\n-// files.\n-#[allow(unused_extern_crates)]\n-extern crate rustc_driver;\n-\n-extern crate krate2;\n-extern crate krate2 as krate3;\n-\n-use rustc_graphviz::RenderOption;\n-use std::cell::RefCell;\n-use std::collections::{HashMap, HashSet};\n-use std::io::Write;\n-\n-use sub::sub2 as msalias;\n-use sub::sub2;\n-use sub::sub2::nested_struct as sub_struct;\n-\n-use std::mem::size_of;\n-\n-use std::char::from_u32;\n-\n-static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n-static yy: usize = 25;\n-\n-static bob: Option<rustc_graphviz::RenderOption> = None;\n-\n-// buglink test - see issue #1337.\n-\n-fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n-    let s = sub_struct { field2: 45u32 };\n-\n-    // import tests\n-    fn foo(x: &Write) {}\n-    let _: Option<_> = from_u32(45);\n-\n-    let x = 42usize;\n-\n-    krate2::hello();\n-    krate3::hello();\n-\n-    let x = (3isize, 4usize);\n-    let y = x.1;\n-}\n-\n-// Issue #37700\n-const LUT_BITS: usize = 3;\n-pub struct HuffmanTable {\n-    ac_lut: Option<[(i16, u8); 1 << LUT_BITS]>,\n-}\n-\n-struct TupStruct(isize, isize, Box<str>);\n-\n-fn test_tup_struct(x: TupStruct) -> isize {\n-    x.1\n-}\n-\n-fn println(s: &str) {\n-    std::io::stdout().write_all(s.as_bytes());\n-}\n-\n-mod sub {\n-    pub mod sub2 {\n-        use std::io::Write;\n-        pub mod sub3 {\n-            use std::io::Write;\n-            pub fn hello() {\n-                ::println(\"hello from module 3\");\n-            }\n-        }\n-        pub fn hello() {\n-            ::println(\"hello from a module\");\n-        }\n-\n-        pub struct nested_struct {\n-            pub field2: u32,\n-        }\n-\n-        pub enum nested_enum {\n-            Nest2 = 2,\n-            Nest3 = 3,\n-        }\n-    }\n-}\n-\n-pub mod SameDir;\n-pub mod SubDir;\n-\n-#[path = \"SameDir3.rs\"]\n-pub mod SameDir2;\n-\n-struct nofields;\n-\n-#[derive(Clone)]\n-struct some_fields {\n-    field1: u32,\n-}\n-\n-type SF = some_fields;\n-\n-trait SuperTrait {\n-    fn qux(&self) {\n-        panic!();\n-    }\n-}\n-\n-trait SomeTrait: SuperTrait {\n-    fn Method(&self, x: u32) -> u32;\n-\n-    fn prov(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n-        42\n-    }\n-    fn provided_method(&self) -> u32 {\n-        42\n-    }\n-}\n-\n-trait SubTrait: SomeTrait {\n-    fn stat2(x: &Self) -> u32 {\n-        32\n-    }\n-}\n-\n-impl SomeTrait for some_fields {\n-    fn Method(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n-        self.field1\n-    }\n-}\n-\n-impl SuperTrait for some_fields {}\n-\n-impl SubTrait for some_fields {}\n-\n-impl some_fields {\n-    fn stat(x: u32) -> u32 {\n-        println(&x.to_string());\n-        42\n-    }\n-    fn stat2(x: &some_fields) -> u32 {\n-        42\n-    }\n-\n-    fn align_to<T>(&mut self) {}\n-\n-    fn test(&mut self) {\n-        self.align_to::<bool>();\n-    }\n-}\n-\n-impl SuperTrait for nofields {}\n-impl SomeTrait for nofields {\n-    fn Method(&self, x: u32) -> u32 {\n-        self.Method(x);\n-        43\n-    }\n-\n-    fn provided_method(&self) -> u32 {\n-        21\n-    }\n-}\n-\n-impl SubTrait for nofields {}\n-\n-impl SuperTrait for (Box<nofields>, Box<some_fields>) {}\n-\n-fn f_with_params<T: SomeTrait>(x: &T) {\n-    x.Method(41);\n-}\n-\n-type MyType = Box<some_fields>;\n-\n-enum SomeEnum<'a> {\n-    Ints(isize, isize),\n-    Floats(f64, f64),\n-    Strings(&'a str, &'a str, &'a str),\n-    MyTypes(MyType, MyType),\n-}\n-\n-#[derive(Copy, Clone)]\n-enum SomeOtherEnum {\n-    SomeConst1,\n-    SomeConst2,\n-    SomeConst3,\n-}\n-\n-enum SomeStructEnum {\n-    EnumStruct { a: isize, b: isize },\n-    EnumStruct2 { f1: MyType, f2: MyType },\n-    EnumStruct3 { f1: MyType, f2: MyType, f3: SomeEnum<'static> },\n-}\n-\n-fn matchSomeEnum(val: SomeEnum) {\n-    match val {\n-        SomeEnum::Ints(int1, int2) => {\n-            println(&(int1 + int2).to_string());\n-        }\n-        SomeEnum::Floats(float1, float2) => {\n-            println(&(float2 * float1).to_string());\n-        }\n-        SomeEnum::Strings(.., s3) => {\n-            println(s3);\n-        }\n-        SomeEnum::MyTypes(mt1, mt2) => {\n-            println(&(mt1.field1 - mt2.field1).to_string());\n-        }\n-    }\n-}\n-\n-fn matchSomeStructEnum(se: SomeStructEnum) {\n-    match se {\n-        SomeStructEnum::EnumStruct { a: a, .. } => println(&a.to_string()),\n-        SomeStructEnum::EnumStruct2 { f1: f1, f2: f_2 } => println(&f_2.field1.to_string()),\n-        SomeStructEnum::EnumStruct3 { f1, .. } => println(&f1.field1.to_string()),\n-    }\n-}\n-\n-fn matchSomeStructEnum2(se: SomeStructEnum) {\n-    use SomeStructEnum::*;\n-    match se {\n-        EnumStruct { a: ref aaa, .. } => println(&aaa.to_string()),\n-        EnumStruct2 { f1, f2: f2 } => println(&f1.field1.to_string()),\n-        EnumStruct3 { f1, f3: SomeEnum::Ints(..), f2 } => println(&f1.field1.to_string()),\n-        _ => {}\n-    }\n-}\n-\n-fn matchSomeOtherEnum(val: SomeOtherEnum) {\n-    use SomeOtherEnum::{SomeConst2, SomeConst3};\n-    match val {\n-        SomeOtherEnum::SomeConst1 => {\n-            println(\"I'm const1.\");\n-        }\n-        SomeConst2 | SomeConst3 => {\n-            println(\"I'm const2 or const3.\");\n-        }\n-    }\n-}\n-\n-fn hello<X: SomeTrait>((z, a): (u32, String), ex: X) {\n-    SameDir2::hello(43);\n-\n-    println(&yy.to_string());\n-    let (x, y): (u32, u32) = (5, 3);\n-    println(&x.to_string());\n-    println(&z.to_string());\n-    let x: u32 = x;\n-    println(&x.to_string());\n-    let x = \"hello\";\n-    println(x);\n-\n-    let x = 32.0f32;\n-    let _ = (x + ((x * x) + 1.0).sqrt()).ln();\n-\n-    let s: Box<SomeTrait> = Box::new(some_fields { field1: 43 });\n-    let s2: Box<some_fields> = Box::new(some_fields { field1: 43 });\n-    let s3 = Box::new(nofields);\n-\n-    s.Method(43);\n-    s3.Method(43);\n-    s2.Method(43);\n-\n-    ex.prov(43);\n-\n-    let y: u32 = 56;\n-    // static method on struct\n-    let r = some_fields::stat(y);\n-    // trait static method, calls default\n-    let r = SubTrait::stat2(&*s3);\n-\n-    let s4 = s3 as Box<SomeTrait>;\n-    s4.Method(43);\n-\n-    s4.provided_method();\n-    s2.prov(45);\n-\n-    let closure = |x: u32, s: &SomeTrait| {\n-        s.Method(23);\n-        return x + y;\n-    };\n-\n-    let z = closure(10, &*s);\n-}\n-\n-pub struct blah {\n-    used_link_args: RefCell<[&'static str; 0]>,\n-}\n-\n-#[macro_use]\n-mod macro_use_test {\n-    macro_rules! test_rec {\n-        (q, $src: expr) => {{\n-            print!(\"{}\", $src);\n-            test_rec!($src);\n-        }};\n-        ($src: expr) => {\n-            print!(\"{}\", $src);\n-        };\n-    }\n-\n-    macro_rules! internal_vars {\n-        ($src: ident) => {{\n-            let mut x = $src;\n-            x += 100;\n-        }};\n-    }\n-}\n-\n-fn main() {\n-    // foo\n-    let s = Box::new(some_fields { field1: 43 });\n-    hello((43, \"a\".to_string()), *s);\n-    sub::sub2::hello();\n-    sub2::sub3::hello();\n-\n-    let h = sub2::sub3::hello;\n-    h();\n-\n-    // utf8 chars\n-    let ut = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n-\n-    // For some reason, this pattern of macro_rules foiled our generated code\n-    // avoiding strategy.\n-    macro_rules! variable_str(($name:expr) => (\n-        some_fields {\n-            field1: $name,\n-        }\n-    ));\n-    let vs = variable_str!(32);\n-\n-    let mut candidates: RefCell<HashMap<&'static str, &'static str>> = RefCell::new(HashMap::new());\n-    let _ = blah { used_link_args: RefCell::new([]) };\n-    let s1 = nofields;\n-    let s2 = SF { field1: 55 };\n-    let s3: some_fields = some_fields { field1: 55 };\n-    let s4: msalias::nested_struct = sub::sub2::nested_struct { field2: 55 };\n-    let s4: msalias::nested_struct = sub2::nested_struct { field2: 55 };\n-    println(&s2.field1.to_string());\n-    let s5: MyType = Box::new(some_fields { field1: 55 });\n-    let s = SameDir::SameStruct { name: \"Bob\".to_string() };\n-    let s = SubDir::SubStruct { name: \"Bob\".to_string() };\n-    let s6: SomeEnum = SomeEnum::MyTypes(Box::new(s2.clone()), s5);\n-    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n-    matchSomeEnum(s6);\n-    matchSomeEnum(s7);\n-    let s8: SomeOtherEnum = SomeOtherEnum::SomeConst2;\n-    matchSomeOtherEnum(s8);\n-    let s9: SomeStructEnum =\n-        SomeStructEnum::EnumStruct2 { f1: Box::new(some_fields { field1: 10 }), f2: Box::new(s2) };\n-    matchSomeStructEnum(s9);\n-\n-    for x in &vec![1, 2, 3] {\n-        let _y = x;\n-    }\n-\n-    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n-    if let SomeEnum::Strings(..) = s7 {\n-        println!(\"hello!\");\n-    }\n-\n-    for i in 0..5 {\n-        foo_foo(i);\n-    }\n-\n-    if let Some(x) = None {\n-        foo_foo(x);\n-    }\n-\n-    if false {\n-    } else if let Some(y) = None {\n-        foo_foo(y);\n-    }\n-\n-    while let Some(z) = None {\n-        foo_foo(z);\n-    }\n-\n-    let mut x = 4;\n-    test_rec!(q, \"Hello\");\n-    assert_eq!(x, 4);\n-    internal_vars!(x);\n-}\n-\n-fn foo_foo(_: i32) {}\n-\n-impl Iterator for nofields {\n-    type Item = (usize, usize);\n-\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        panic!()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        panic!()\n-    }\n-}\n-\n-trait Pattern<'a> {\n-    type Searcher;\n-}\n-\n-struct CharEqPattern;\n-\n-impl<'a> Pattern<'a> for CharEqPattern {\n-    type Searcher = CharEqPattern;\n-}\n-\n-struct CharSearcher<'a>(<CharEqPattern as Pattern<'a>>::Searcher);\n-\n-pub trait Error {}\n-\n-impl Error + 'static {\n-    pub fn is<T: Error + 'static>(&self) -> bool {\n-        panic!()\n-    }\n-}\n-\n-impl Error + 'static + Send {\n-    pub fn is<T: Error + 'static>(&self) -> bool {\n-        <Error + 'static>::is::<T>(self)\n-    }\n-}\n-extern crate rustc_serialize;\n-#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Debug, Default)]\n-struct AllDerives(i32);\n-\n-fn test_format_args() {\n-    let x = 1;\n-    let y = 2;\n-    let name = \"Joe Blogg\";\n-    println!(\"Hello {}\", name);\n-    print!(\"Hello {0}\", name);\n-    print!(\"{0} + {} = {}\", x, y);\n-    print!(\"x is {}, y is {1}, name is {n}\", x, y, n = name);\n-}\n-\n-union TestUnion {\n-    f1: u32,\n-}\n-\n-struct FrameBuffer;\n-\n-struct SilenceGenerator;\n-\n-impl Iterator for SilenceGenerator {\n-    type Item = FrameBuffer;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        panic!();\n-    }\n-}\n-\n-#[doc = include_str!(\"extra-docs.md\")]\n-struct StructWithDocs;\n-\n-trait Foo {\n-    type Bar = FrameBuffer;\n-}"}, {"sha": "7d787e0c9871f4d760dca5403f17fa42da972932", "filename": "tests/run-make-fulldeps/save-analysis/krate2.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fkrate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fkrate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fkrate2.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,8 +0,0 @@\n-#![ crate_name = \"krate2\" ]\n-#![ crate_type = \"lib\" ]\n-\n-use std::io::Write;\n-\n-pub fn hello() {\n-    std::io::stdout().write_all(b\"hello world!\\n\");\n-}"}, {"sha": "8d0155151b8dfa9d5f4ebf782adaf7ae2308f85a", "filename": "tests/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fz-help.stdout?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -146,7 +146,6 @@\n     -Z          sanitizer-memory-track-origins=val -- enable origins tracking in MemorySanitizer\n     -Z                       sanitizer-recover=val -- enable recovery for selected sanitizers\n     -Z                  saturating-float-casts=val -- make float->int casts UB-free: numbers outside the integer type's range are clipped to the max/min integer respectively, and NaN is mapped to 0 (default: yes)\n-    -Z                           save-analysis=val -- write syntax and type analysis (in JSON format) information, in addition to normal output (default: no)\n     -Z                            self-profile=val -- run the self profiler and output the raw event data\n     -Z                    self-profile-counter=val -- counter used by the self profiler (default: `wall-time`), one of:\n         `wall-time` (monotonic clock, i.e. `std::time::Instant`)"}, {"sha": "ac589de2303f9c6f398eedfc3c2d767d9cd62b8c", "filename": "tests/ui/asm/issue-72570.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fasm%2Fissue-72570.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fasm%2Fissue-72570.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fissue-72570.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,6 +1,4 @@\n-// compile-flags: -Zsave-analysis\n // needs-asm-support\n-// Also test for #72960\n \n use std::arch::asm;\n "}, {"sha": "49013a23ced2da7543e91ba1b35cb7e9f0013485", "filename": "tests/ui/asm/issue-72570.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fasm%2Fissue-72570.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fasm%2Fissue-72570.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fissue-72570.stderr?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,5 +1,5 @@\n error: invalid register `invalid`: unknown register\n-  --> $DIR/issue-72570.rs:9:18\n+  --> $DIR/issue-72570.rs:7:18\n    |\n LL |         asm!(\"\", in(\"invalid\") \"\".len());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "82030731cc17d3bb289d094be315e38d4a6c106e", "filename": "tests/ui/const-generics/const-argument-non-static-lifetime.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.min.stderr?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: a non-static lifetime is not allowed in a `const`\n-  --> $DIR/const-argument-non-static-lifetime.rs:15:17\n+  --> $DIR/const-argument-non-static-lifetime.rs:14:17\n    |\n LL |         let _: &'a ();\n    |                 ^^"}, {"sha": "0357e4ed59fdad95580e76b50c64f421cd82f8af", "filename": "tests/ui/const-generics/const-argument-non-static-lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -2,7 +2,6 @@\n // revisions: full min\n \n // regression test for #78180\n-// compile-flags: -Zsave-analysis\n \n #![cfg_attr(full, feature(generic_const_exprs))]\n #![cfg_attr(full, allow(incomplete_features))]"}, {"sha": "b776f2017fae0d92e27c25acd2cb4fdba7251896", "filename": "tests/ui/const-generics/const-param-type-depends-on-type-param-ungated.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,6 +1,3 @@\n-// compile-flags: -Zsave-analysis\n-// Regression test for #69414 ^\n-\n use std::marker::PhantomData;\n \n struct B<T, const N: T>(PhantomData<[T; N]>);"}, {"sha": "9c5c97befd83663ca9d8be52634ec03201faa1ce", "filename": "tests/ui/const-generics/const-param-type-depends-on-type-param-ungated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,5 +1,5 @@\n error[E0770]: the type of const parameters must not depend on other generic parameters\n-  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:6:22\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n    |\n LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n    |                      ^ the type must not depend on the parameter `T`"}, {"sha": "aa7ae90a36373bf1fe1a339f8bd8db3799ca8afc", "filename": "tests/ui/const-generics/issues/issue-73260.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zsave-analysis\n #![feature(generic_const_exprs)]\n #![allow(incomplete_features)]\n struct Arr<const N: usize>"}, {"sha": "f9ff0f28d51d23fd5685497af848b813e8263ba9", "filename": "tests/ui/const-generics/issues/issue-73260.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,13 +1,13 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-73260.rs:16:12\n+  --> $DIR/issue-73260.rs:15:12\n    |\n LL |     let x: Arr<{usize::MAX}> = Arr {};\n    |            ^^^^^^^^^^^^^^^^^ expected `false`, found `true`\n    |\n    = note: expected constant `false`\n               found constant `true`\n note: required by a bound in `Arr`\n-  --> $DIR/issue-73260.rs:6:37\n+  --> $DIR/issue-73260.rs:5:37\n    |\n LL | struct Arr<const N: usize>\n    |        --- required by a bound in this\n@@ -16,15 +16,15 @@ LL |     Assert::<{N < usize::MAX / 2}>: IsTrue,\n    |                                     ^^^^^^ required by this bound in `Arr`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-73260.rs:16:32\n+  --> $DIR/issue-73260.rs:15:32\n    |\n LL |     let x: Arr<{usize::MAX}> = Arr {};\n    |                                ^^^ expected `false`, found `true`\n    |\n    = note: expected constant `false`\n               found constant `true`\n note: required by a bound in `Arr`\n-  --> $DIR/issue-73260.rs:6:37\n+  --> $DIR/issue-73260.rs:5:37\n    |\n LL | struct Arr<const N: usize>\n    |        --- required by a bound in this"}, {"sha": "49fb10e6029599757f64ee086d9196d18631a9c9", "filename": "tests/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,6 +1,3 @@\n-// compile-flags: -Zsave-analysis\n-// This is also a regression test for #69415 and the above flag is needed.\n-\n use std::mem::ManuallyDrop;\n \n trait Tr1 { type As1: Copy; }"}, {"sha": "edbbf7db5657882c3e778047dba50056ccacefc4", "filename": "tests/ui/feature-gates/feature-gate-associated_type_bounds.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:15:22\n+  --> $DIR/feature-gate-associated_type_bounds.rs:12:22\n    |\n LL |     type A: Iterator<Item: Copy>;\n    |                      ^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL |     type A: Iterator<Item: Copy>;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:19:22\n+  --> $DIR/feature-gate-associated_type_bounds.rs:16:22\n    |\n LL |     type B: Iterator<Item: 'static>;\n    |                      ^^^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL |     type B: Iterator<Item: 'static>;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:23:20\n+  --> $DIR/feature-gate-associated_type_bounds.rs:20:20\n    |\n LL | struct _St1<T: Tr1<As1: Tr2>> {\n    |                    ^^^^^^^^\n@@ -26,7 +26,7 @@ LL | struct _St1<T: Tr1<As1: Tr2>> {\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:30:18\n+  --> $DIR/feature-gate-associated_type_bounds.rs:27:18\n    |\n LL | enum _En1<T: Tr1<As1: Tr2>> {\n    |                  ^^^^^^^^\n@@ -35,7 +35,7 @@ LL | enum _En1<T: Tr1<As1: Tr2>> {\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:37:19\n+  --> $DIR/feature-gate-associated_type_bounds.rs:34:19\n    |\n LL | union _Un1<T: Tr1<As1: Tr2>> {\n    |                   ^^^^^^^^\n@@ -44,7 +44,7 @@ LL | union _Un1<T: Tr1<As1: Tr2>> {\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:44:37\n+  --> $DIR/feature-gate-associated_type_bounds.rs:41:37\n    |\n LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n    |                                     ^^^^^^^^^^\n@@ -53,7 +53,7 @@ LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:47:22\n+  --> $DIR/feature-gate-associated_type_bounds.rs:44:22\n    |\n LL | fn _apit(_: impl Tr1<As1: Copy>) {}\n    |                      ^^^^^^^^^\n@@ -62,7 +62,7 @@ LL | fn _apit(_: impl Tr1<As1: Copy>) {}\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:49:26\n+  --> $DIR/feature-gate-associated_type_bounds.rs:46:26\n    |\n LL | fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n    |                          ^^^^^^^^^\n@@ -71,7 +71,7 @@ LL | fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:52:24\n+  --> $DIR/feature-gate-associated_type_bounds.rs:49:24\n    |\n LL | fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n    |                        ^^^^^^^^^\n@@ -80,7 +80,7 @@ LL | fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:55:31\n+  --> $DIR/feature-gate-associated_type_bounds.rs:52:31\n    |\n LL | fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n    |                               ^^^^^^^^^\n@@ -89,7 +89,7 @@ LL | fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:58:23\n+  --> $DIR/feature-gate-associated_type_bounds.rs:55:23\n    |\n LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    |                       ^^^^^^^^^\n@@ -98,7 +98,7 @@ LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:64:24\n+  --> $DIR/feature-gate-associated_type_bounds.rs:61:24\n    |\n LL | static _sdef: impl Tr1<As1: Copy> = S1;\n    |                        ^^^^^^^^^\n@@ -107,7 +107,7 @@ LL | static _sdef: impl Tr1<As1: Copy> = S1;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:71:21\n+  --> $DIR/feature-gate-associated_type_bounds.rs:68:21\n    |\n LL |     let _: impl Tr1<As1: Copy> = S1;\n    |                     ^^^^^^^^^\n@@ -116,25 +116,25 @@ LL |     let _: impl Tr1<As1: Copy> = S1;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n-  --> $DIR/feature-gate-associated_type_bounds.rs:58:14\n+  --> $DIR/feature-gate-associated_type_bounds.rs:55:14\n    |\n LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    |              ^^^^^^^^^^^^^^^^^^^\n \n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n-  --> $DIR/feature-gate-associated_type_bounds.rs:64:15\n+  --> $DIR/feature-gate-associated_type_bounds.rs:61:15\n    |\n LL | static _sdef: impl Tr1<As1: Copy> = S1;\n    |               ^^^^^^^^^^^^^^^^^^^\n \n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in variable binding\n-  --> $DIR/feature-gate-associated_type_bounds.rs:71:12\n+  --> $DIR/feature-gate-associated_type_bounds.rs:68:12\n    |\n LL |     let _: impl Tr1<As1: Copy> = S1;\n    |            ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `<<Self as _Tr3>::A as Iterator>::Item: Copy` is not satisfied\n-  --> $DIR/feature-gate-associated_type_bounds.rs:15:28\n+  --> $DIR/feature-gate-associated_type_bounds.rs:12:28\n    |\n LL |     type A: Iterator<Item: Copy>;\n    |                            ^^^^ the trait `Copy` is not implemented for `<<Self as _Tr3>::A as Iterator>::Item`"}, {"sha": "5613c1916c6cdcd62db21500fa10ba18f14b1095", "filename": "tests/ui/impl-trait/bound-normalization-pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,8 +1,6 @@\n // check-pass\n // edition:2018\n // revisions: default sa\n-//[sa] compile-flags: -Z save-analysis\n-//-^ To make this the regression test for #75962.\n \n #![feature(type_alias_impl_trait)]\n "}, {"sha": "2e72d39cb322b1b60f78722d18eb11f92a649ecf", "filename": "tests/ui/issues/issue-3763.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fissues%2Fissue-3763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fissues%2Fissue-3763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-3763.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,5 +1,4 @@\n-// compile-flags: -Zsave-analysis\n-// Also regression test for #69416\n+// Regression test for #3763\n \n mod my_mod {\n     pub struct MyStruct {"}, {"sha": "a09c8421bb7a174923f82308f17ff469740c1101", "filename": "tests/ui/issues/issue-3763.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fissues%2Fissue-3763.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fissues%2Fissue-3763.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-3763.stderr?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,17 +1,17 @@\n error[E0616]: field `priv_field` of struct `MyStruct` is private\n-  --> $DIR/issue-3763.rs:18:32\n+  --> $DIR/issue-3763.rs:17:32\n    |\n LL |     let _woohoo = (&my_struct).priv_field;\n    |                                ^^^^^^^^^^ private field\n \n error[E0616]: field `priv_field` of struct `MyStruct` is private\n-  --> $DIR/issue-3763.rs:21:41\n+  --> $DIR/issue-3763.rs:20:41\n    |\n LL |     let _woohoo = (Box::new(my_struct)).priv_field;\n    |                                         ^^^^^^^^^^ private field\n \n error[E0624]: associated function `happyfun` is private\n-  --> $DIR/issue-3763.rs:24:18\n+  --> $DIR/issue-3763.rs:23:18\n    |\n LL |         fn happyfun(&self) {}\n    |         ------------------ private associated function defined here\n@@ -20,7 +20,7 @@ LL |     (&my_struct).happyfun();\n    |                  ^^^^^^^^ private associated function\n \n error[E0624]: associated function `happyfun` is private\n-  --> $DIR/issue-3763.rs:26:27\n+  --> $DIR/issue-3763.rs:25:27\n    |\n LL |         fn happyfun(&self) {}\n    |         ------------------ private associated function defined here\n@@ -29,7 +29,7 @@ LL |     (Box::new(my_struct)).happyfun();\n    |                           ^^^^^^^^ private associated function\n \n error[E0616]: field `priv_field` of struct `MyStruct` is private\n-  --> $DIR/issue-3763.rs:27:26\n+  --> $DIR/issue-3763.rs:26:26\n    |\n LL |     let nope = my_struct.priv_field;\n    |                          ^^^^^^^^^^ private field"}, {"sha": "71e40759c848be08a617af489f6875f15d874826", "filename": "tests/ui/methods/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fmethods%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fmethods%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fassign-to-method.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,5 +1,4 @@\n-// compile-flags: -Zsave-analysis\n-// Also regression test for #69409\n+// Regression test for #69409\n \n struct Cat {\n     meows : usize,"}, {"sha": "a1fc57cae21329b4a4d2b5c769596fb4e20c31cc", "filename": "tests/ui/methods/assign-to-method.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fmethods%2Fassign-to-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Fmethods%2Fassign-to-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fassign-to-method.stderr?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,13 +1,13 @@\n error[E0615]: attempted to take value of method `speak` on type `Cat`\n-  --> $DIR/assign-to-method.rs:22:10\n+  --> $DIR/assign-to-method.rs:21:10\n    |\n LL |     nyan.speak = || println!(\"meow\");\n    |          ^^^^^ method, not a field\n    |\n    = help: methods are immutable and cannot be assigned to\n \n error[E0615]: attempted to take value of method `speak` on type `Cat`\n-  --> $DIR/assign-to-method.rs:23:10\n+  --> $DIR/assign-to-method.rs:22:10\n    |\n LL |     nyan.speak += || println!(\"meow\");\n    |          ^^^^^ method, not a field"}, {"sha": "a1a1b8c63dac38cfc04ff8162cc2f536d560c84e", "filename": "tests/ui/save-analysis/emit-notifications.polonius.stderr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Femit-notifications.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Femit-notifications.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Femit-notifications.polonius.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,2 +0,0 @@\n-{\"artifact\":\"$TEST_BUILD_DIR/save-analysis/emit-notifications.polonius/save-analysis/libemit_notifications.json\",\"emit\":\"save-analysis\"}\n-{\"artifact\":\"$TEST_BUILD_DIR/save-analysis/emit-notifications.polonius/libemit_notifications.rlib\",\"emit\":\"link\"}"}, {"sha": "9179944a6201d62cd56e64e303f9473c62d2bc37", "filename": "tests/ui/save-analysis/emit-notifications.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Femit-notifications.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Femit-notifications.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Femit-notifications.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,7 +0,0 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n-// compile-flags: -Zsave-analysis --json artifacts\n-// compile-flags: --crate-type rlib --error-format=json\n-// ignore-pass\n-// ^-- needed because otherwise, the .stderr file changes with --pass check\n-\n-pub fn foo() {}"}, {"sha": "e16f60f8b5faf146b398b2eb897f06fc38a03bfe", "filename": "tests/ui/save-analysis/emit-notifications.stderr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Femit-notifications.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Femit-notifications.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Femit-notifications.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,2 +0,0 @@\n-{\"artifact\":\"$TEST_BUILD_DIR/save-analysis/emit-notifications/save-analysis/libemit_notifications.json\",\"emit\":\"save-analysis\"}\n-{\"artifact\":\"$TEST_BUILD_DIR/save-analysis/emit-notifications/libemit_notifications.rlib\",\"emit\":\"link\"}"}, {"sha": "2ba05a0a47e01dd9590b61f106d840f7f78e8f70", "filename": "tests/ui/save-analysis/issue-26459.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-26459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-26459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-26459.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,8 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-fn main() {\n-    match 'a' {\n-        char{ch} => true\n-        //~^ ERROR expected struct, variant or union type, found builtin type `char`\n-    };\n-}"}, {"sha": "9f594990c6de8315252bb5ff0b718a83d231e70f", "filename": "tests/ui/save-analysis/issue-26459.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-26459.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-26459.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-26459.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,9 +0,0 @@\n-error[E0574]: expected struct, variant or union type, found builtin type `char`\n-  --> $DIR/issue-26459.rs:5:9\n-   |\n-LL |         char{ch} => true\n-   |         ^^^^ not a struct, variant or union type\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0574`."}, {"sha": "55f5c5a9581b12fb21982446dfb20baf062d4f35", "filename": "tests/ui/save-analysis/issue-37323.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-37323.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-37323.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-37323.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,20 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-\n-#![feature(rustc_attrs)]\n-#![allow(warnings)]\n-\n-#[derive(Debug)]\n-struct Point {\n-}\n-\n-struct NestedA<'a, 'b> {\n-    x: &'a NestedB<'b>\n-}\n-\n-struct NestedB<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-}"}, {"sha": "a0871ca18094ed89d5377cb02fa01bbe670a5055", "filename": "tests/ui/save-analysis/issue-59134-0.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,12 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-// Check that this doesn't ICE when processing associated const (field expr).\n-\n-pub fn f() {\n-    trait Trait {}\n-    impl dyn Trait {\n-        const FLAG: u32 = bogus.field; //~ ERROR cannot find value `bogus`\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "4e9b2e6fdeb4d94271d179c9bb6293c23525d7e4", "filename": "tests/ui/save-analysis/issue-59134-0.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,9 +0,0 @@\n-error[E0425]: cannot find value `bogus` in this scope\n-  --> $DIR/issue-59134-0.rs:8:27\n-   |\n-LL |         const FLAG: u32 = bogus.field;\n-   |                           ^^^^^ not found in this scope\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "3cb629777a497297c5945a99c13b89751c4677d8", "filename": "tests/ui/save-analysis/issue-59134-1.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,12 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-// Check that this doesn't ICE when processing associated const (type).\n-\n-fn func() {\n-    trait Trait {\n-        type MyType;\n-        const CONST: Self::MyType = bogus.field; //~ ERROR cannot find value `bogus`\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "bdc335eaac041c0466f11829ff0f3aec301937b2", "filename": "tests/ui/save-analysis/issue-59134-1.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,9 +0,0 @@\n-error[E0425]: cannot find value `bogus` in this scope\n-  --> $DIR/issue-59134-1.rs:8:37\n-   |\n-LL |         const CONST: Self::MyType = bogus.field;\n-   |                                     ^^^^^ not found in this scope\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "92e85884f664dbcc43f88023f439d802f08e6009", "filename": "tests/ui/save-analysis/issue-63663.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-63663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-63663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-63663.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,28 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-\n-pub trait Trait {\n-    type Assoc;\n-}\n-\n-pub struct A;\n-\n-trait Generic<T> {}\n-impl<T> Generic<T> for () {}\n-\n-// Don't ICE when resolving type paths in return type `impl Trait`\n-fn assoc_in_opaque_type_bounds<U: Trait>() -> impl Generic<U::Assoc> {}\n-\n-// Check that this doesn't ICE when processing associated const in formal\n-// argument and return type of functions defined inside function/method scope.\n-pub fn func() {\n-    fn _inner1<U: Trait>(_: U::Assoc) {}\n-    fn _inner2<U: Trait>() -> U::Assoc { unimplemented!() }\n-\n-    impl A {\n-        fn _inner1<U: Trait>(self, _: U::Assoc) {}\n-        fn _inner2<U: Trait>(self) -> U::Assoc { unimplemented!() }\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "a3d88a203778fbc8cda94e16648c117f48a582b2", "filename": "tests/ui/save-analysis/issue-64659.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-64659.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-64659.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-64659.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,10 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-\n-trait Trait { type Assoc; }\n-\n-fn main() {\n-    struct Data<T: Trait> {\n-        x: T::Assoc,\n-    }\n-}"}, {"sha": "9e58b8da5d2717c84ec07f3629065cc4aab31beb", "filename": "tests/ui/save-analysis/issue-65411.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-65411.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-65411.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-65411.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,15 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-\n-trait Trait { type Assoc; }\n-trait GenericTrait<T> {}\n-struct Wrapper<B> { b: B }\n-\n-fn func() {\n-    // Processing associated path in impl block definition inside a function\n-    // body does not ICE\n-    impl<B: Trait> GenericTrait<B::Assoc> for Wrapper<B> {}\n-}\n-\n-\n-fn main() {}"}, {"sha": "27874f8655e56c7bde9c5af7b305c75004c3d85c", "filename": "tests/ui/save-analysis/issue-65590.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-65590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-65590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-65590.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,21 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-// edition:2018\n-\n-// Async desugaring for return types in (associated) functions introduces a\n-// separate definition internally, which we need to take into account\n-// (or else we ICE).\n-trait Trait { type Assoc; }\n-struct Struct;\n-\n-async fn foobar<T: Trait>() -> T::Assoc {\n-    unimplemented!()\n-}\n-\n-impl Struct {\n-    async fn foo<T: Trait>(&self) -> T::Assoc {\n-        unimplemented!()\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "30479580f11a3c0122291b0020d1738bf15406f4", "filename": "tests/ui/save-analysis/issue-68621.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-68621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-68621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-68621.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,17 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-#![feature(type_alias_impl_trait)]\n-\n-trait Trait {}\n-\n-trait Service {\n-    type Future: Trait;\n-}\n-\n-struct Struct;\n-\n-impl Service for Struct {\n-    type Future = impl Trait; //~ ERROR: unconstrained opaque type\n-}\n-\n-fn main() {}"}, {"sha": "4452ee7915baab165d1b91332966d7859114ab24", "filename": "tests/ui/save-analysis/issue-68621.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-68621.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,10 +0,0 @@\n-error: unconstrained opaque type\n-  --> $DIR/issue-68621.rs:14:19\n-   |\n-LL |     type Future = impl Trait;\n-   |                   ^^^^^^^^^^\n-   |\n-   = note: `Future` must be used in combination with a concrete type within the same impl\n-\n-error: aborting due to previous error\n-"}, {"sha": "eea0a7fea0cefcc94b8074dae1c98840e9886000", "filename": "tests/ui/save-analysis/issue-72267.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-72267.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-72267.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-72267.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,7 +0,0 @@\n-// compile-flags: -Z save-analysis\n-\n-fn main() {\n-    let _: Box<(dyn ?Sized)>;\n-    //~^ ERROR `?Trait` is not permitted in trait object types\n-    //~| ERROR at least one trait is required for an object type\n-}"}, {"sha": "76fc6c57cbc36d30954cc2aab0699fdcd9e28784", "filename": "tests/ui/save-analysis/issue-72267.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-72267.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-72267.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-72267.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,15 +0,0 @@\n-error: `?Trait` is not permitted in trait object types\n-  --> $DIR/issue-72267.rs:4:21\n-   |\n-LL |     let _: Box<(dyn ?Sized)>;\n-   |                     ^^^^^^\n-\n-error[E0224]: at least one trait is required for an object type\n-  --> $DIR/issue-72267.rs:4:17\n-   |\n-LL |     let _: Box<(dyn ?Sized)>;\n-   |                 ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0224`."}, {"sha": "87ce0933681c5d571d7a287de7959547aad76ed8", "filename": "tests/ui/save-analysis/issue-73020.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-73020.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-73020.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-73020.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,5 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-use {self}; //~ ERROR E0431\n-\n-fn main () {\n-}"}, {"sha": "5bb3aae99975c9dadb9abb33a22b78fcd84aefa6", "filename": "tests/ui/save-analysis/issue-73020.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-73020.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-73020.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-73020.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,9 +0,0 @@\n-error[E0431]: `self` import can only appear in an import list with a non-empty prefix\n-  --> $DIR/issue-73020.rs:2:6\n-   |\n-LL | use {self};\n-   |      ^^^^ can only appear in an import list with a non-empty prefix\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0431`."}, {"sha": "9ad89a319ba3b0601c54e72819e58b5bf7f46c71", "filename": "tests/ui/save-analysis/issue-73022.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-73022.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-73022.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-73022.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,13 +0,0 @@\n-// build-pass\n-// compile-flags: -Zsave-analysis\n-enum Enum2 {\n-    Variant8 { _field: bool },\n-}\n-\n-impl Enum2 {\n-    fn new_variant8() -> Enum2 {\n-        Self::Variant8 { _field: true }\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "c65e2d73fadec2040203464ab7c71631b26592c0", "filename": "tests/ui/save-analysis/issue-89066.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-89066.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-89066.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-89066.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,28 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-// Check that this does not ICE.\n-// Stolen from tests/ui/const-generics/generic_arg_infer/infer-arg-test.rs\n-\n-#![feature(generic_arg_infer)]\n-\n-struct All<'a, T, const N: usize> {\n-  v: &'a T,\n-}\n-\n-struct BadInfer<_>;\n-//~^ ERROR expected identifier\n-//~| ERROR parameter `_` is never used\n-\n-fn all_fn<'a, T, const N: usize>() {}\n-\n-fn bad_infer_fn<_>() {}\n-//~^ ERROR expected identifier\n-\n-\n-fn main() {\n-  let a: All<_, _, _>;\n-  //~^ ERROR this struct takes 2 generic arguments but 3 generic arguments were supplied\n-  all_fn();\n-  let v: [u8; _];\n-  let v: [u8; 10] = [0; _];\n-}"}, {"sha": "5ef04936ea244b19b874c2005cdff16e87b0b77a", "filename": "tests/ui/save-analysis/issue-89066.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-89066.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/tests%2Fui%2Fsave-analysis%2Fissue-89066.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-89066.stderr?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,39 +0,0 @@\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/issue-89066.rs:12:17\n-   |\n-LL | struct BadInfer<_>;\n-   |                 ^ expected identifier, found reserved identifier\n-\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/issue-89066.rs:18:17\n-   |\n-LL | fn bad_infer_fn<_>() {}\n-   |                 ^ expected identifier, found reserved identifier\n-\n-error[E0392]: parameter `_` is never used\n-  --> $DIR/issue-89066.rs:12:17\n-   |\n-LL | struct BadInfer<_>;\n-   |                 ^ unused parameter\n-   |\n-   = help: consider removing `_`, referring to it in a field, or using a marker such as `PhantomData`\n-   = help: if you intended `_` to be a const parameter, use `const _: usize` instead\n-\n-error[E0107]: this struct takes 2 generic arguments but 3 generic arguments were supplied\n-  --> $DIR/issue-89066.rs:23:10\n-   |\n-LL |   let a: All<_, _, _>;\n-   |          ^^^       - help: remove this generic argument\n-   |          |\n-   |          expected 2 generic arguments\n-   |\n-note: struct defined here, with 2 generic parameters: `T`, `N`\n-  --> $DIR/issue-89066.rs:8:8\n-   |\n-LL | struct All<'a, T, const N: usize> {\n-   |        ^^^     -  --------------\n-\n-error: aborting due to 4 previous errors\n-\n-Some errors have detailed explanations: E0107, E0392.\n-For more information about an error, try `rustc --explain E0107`."}, {"sha": "dcb33b7a90af4f34ca326fc505fbe0e68abc73b0", "filename": "tests/ui/traits/alias/self-in-generics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,9 +1,5 @@\n // astconv uses `FreshTy(0)` as a dummy `Self` type when instanciating trait objects.\n // This `FreshTy(0)` can leak into substs, causing ICEs in several places.\n-// Using `save-analysis` triggers type-checking `f` that would be normally skipped\n-// as `type_of` emitted an error.\n-//\n-// compile-flags: -Zsave-analysis\n \n #![feature(trait_alias)]\n "}, {"sha": "80af4e5aae33647860e45f2948d2ecbfd32ffec8", "filename": "tests/ui/traits/alias/self-in-generics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.stderr?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,5 +1,5 @@\n error[E0038]: the trait alias `SelfInput` cannot be made into an object\n-  --> $DIR/self-in-generics.rs:12:19\n+  --> $DIR/self-in-generics.rs:8:19\n    |\n LL | pub fn f(_f: &dyn SelfInput) {}\n    |                   ^^^^^^^^^"}, {"sha": "0e46745c65cd605f91a4e4aa0626d496dd00867b", "filename": "tests/ui/type-alias-impl-trait/issue-63279.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags: -Zsave-analysis\n-\n #![feature(type_alias_impl_trait)]\n \n type Closure = impl FnOnce();"}, {"sha": "a4f6359b904c622231a2be6756988171ed6a8fce", "filename": "tests/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: expected a `FnOnce<()>` closure, found `()`\n-  --> $DIR/issue-63279.rs:7:11\n+  --> $DIR/issue-63279.rs:5:11\n    |\n LL | fn c() -> Closure {\n    |           ^^^^^^^ expected an `FnOnce<()>` closure, found `()`\n@@ -8,7 +8,7 @@ LL | fn c() -> Closure {\n    = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }`\n \n error[E0277]: expected a `FnOnce<()>` closure, found `()`\n-  --> $DIR/issue-63279.rs:9:11\n+  --> $DIR/issue-63279.rs:7:11\n    |\n LL |     || -> Closure { || () }\n    |           ^^^^^^^ expected an `FnOnce<()>` closure, found `()`\n@@ -17,26 +17,26 @@ LL |     || -> Closure { || () }\n    = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-63279.rs:9:21\n+  --> $DIR/issue-63279.rs:7:21\n    |\n LL |     || -> Closure { || () }\n    |                     ^^^^^ expected `()`, found closure\n    |\n    = note: expected unit type `()`\n-                found closure `[closure@$DIR/issue-63279.rs:9:21: 9:23]`\n+                found closure `[closure@$DIR/issue-63279.rs:7:21: 7:23]`\n help: use parentheses to call this closure\n    |\n LL |     || -> Closure { (|| ())() }\n    |                     +     +++\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-63279.rs:9:5\n+  --> $DIR/issue-63279.rs:7:5\n    |\n LL |     || -> Closure { || () }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found closure\n    |\n    = note: expected unit type `()`\n-                found closure `[closure@$DIR/issue-63279.rs:9:5: 9:18]`\n+                found closure `[closure@$DIR/issue-63279.rs:7:5: 7:18]`\n help: use parentheses to call this closure\n    |\n LL |     (|| -> Closure { || () })()"}, {"sha": "b91cbce3727f6de68be2b453fb44f6b50054d491", "filename": "tests/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a5125a367eedc9f1d6b49bac6557a4b4864423/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs?ref=22a5125a367eedc9f1d6b49bac6557a4b4864423", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zsave-analysis\n // check-pass\n \n #![feature(type_alias_impl_trait, rustc_attrs)]"}]}