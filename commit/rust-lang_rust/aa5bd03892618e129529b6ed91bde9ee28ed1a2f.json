{"sha": "aa5bd03892618e129529b6ed91bde9ee28ed1a2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNWJkMDM4OTI2MThlMTI5NTI5YjZlZDkxYmRlOWVlMjhlZDFhMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-02T01:12:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-02T01:12:36Z"}, "message": "Auto merge of #61299 - eddyb:nicer-llvm-builder, r=rkruppe\n\nrustc_codegen_llvm: a couple builder niceties.\n\nr? @nagisa cc @sunfishcode @rkruppe", "tree": {"sha": "22c4b3087af24ff1cb3322d39a2532fb948bdbfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22c4b3087af24ff1cb3322d39a2532fb948bdbfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa5bd03892618e129529b6ed91bde9ee28ed1a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa5bd03892618e129529b6ed91bde9ee28ed1a2f", "html_url": "https://github.com/rust-lang/rust/commit/aa5bd03892618e129529b6ed91bde9ee28ed1a2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa5bd03892618e129529b6ed91bde9ee28ed1a2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03ee55bb1c8c2379fdabf68e306186b390444f61", "url": "https://api.github.com/repos/rust-lang/rust/commits/03ee55bb1c8c2379fdabf68e306186b390444f61", "html_url": "https://github.com/rust-lang/rust/commit/03ee55bb1c8c2379fdabf68e306186b390444f61"}, {"sha": "25d68344932f740c4f4cbbb454ef65f9e33aca59", "url": "https://api.github.com/repos/rust-lang/rust/commits/25d68344932f740c4f4cbbb454ef65f9e33aca59", "html_url": "https://github.com/rust-lang/rust/commit/25d68344932f740c4f4cbbb454ef65f9e33aca59"}], "stats": {"total": 269, "additions": 85, "deletions": 184}, "files": [{"sha": "f37fd0cb833826d742eb6fe5844c4cacc01d0682", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 84, "deletions": 184, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/aa5bd03892618e129529b6ed91bde9ee28ed1a2f/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5bd03892618e129529b6ed91bde9ee28ed1a2f/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=aa5bd03892618e129529b6ed91bde9ee28ed1a2f", "patch": "@@ -20,6 +20,7 @@ use rustc_codegen_ssa::mir::operand::{OperandValue, OperandRef};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n+use std::ffi::CStr;\n use std::ops::{Deref, Range};\n use std::ptr;\n use std::iter::TrustedLen;\n@@ -39,12 +40,15 @@ impl Drop for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-// This is a really awful way to get a zero-length c-string, but better (and a\n-// lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n-fn noname() -> *const c_char {\n-    static CNULL: c_char = 0;\n-    &CNULL\n-}\n+// FIXME(eddyb) use a checked constructor when they become `const fn`.\n+const EMPTY_C_STR: &CStr = unsafe {\n+    CStr::from_bytes_with_nul_unchecked(b\"\\0\")\n+};\n+\n+/// Empty string, to be used where LLVM expects an instruction name, indicating\n+/// that the instruction is to be left unnamed (i.e. numbered, in textual IR).\n+// FIXME(eddyb) pass `&CStr` directly to FFI once it's a thin pointer.\n+const UNNAMED: *const c_char = EMPTY_C_STR.as_ptr();\n \n impl BackendTypes for Builder<'_, 'll, 'tcx> {\n     type Value = <CodegenCx<'ll, 'tcx> as BackendTypes>::Value;\n@@ -100,6 +104,16 @@ impl HasCodegen<'tcx> for Builder<'_, 'll, 'tcx> {\n     type CodegenCx = CodegenCx<'ll, 'tcx>;\n }\n \n+macro_rules! builder_methods_for_value_instructions {\n+    ($($name:ident($($arg:ident),*) => $llvm_capi:ident),+ $(,)?) => {\n+        $(fn $name(&mut self, $($arg: &'ll Value),*) -> &'ll Value {\n+            unsafe {\n+                llvm::$llvm_capi(self.llbuilder, $($arg,)* UNNAMED)\n+            }\n+        })*\n+    }\n+}\n+\n impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn new_block<'b>(\n         cx: &'a CodegenCx<'ll, 'tcx>,\n@@ -217,7 +231,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                                       then,\n                                       catch,\n                                       bundle,\n-                                      noname())\n+                                      UNNAMED)\n         }\n     }\n \n@@ -227,186 +241,72 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    /* Arithmetic */\n-    fn add(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn fadd(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n-        }\n+    builder_methods_for_value_instructions! {\n+        add(a, b) => LLVMBuildAdd,\n+        fadd(a, b) => LLVMBuildFAdd,\n+        sub(a, b) => LLVMBuildSub,\n+        fsub(a, b) => LLVMBuildFSub,\n+        mul(a, b) => LLVMBuildMul,\n+        fmul(a, b) => LLVMBuildFMul,\n+        udiv(a, b) => LLVMBuildUDiv,\n+        exactudiv(a, b) => LLVMBuildExactUDiv,\n+        sdiv(a, b) => LLVMBuildSDiv,\n+        exactsdiv(a, b) => LLVMBuildExactSDiv,\n+        fdiv(a, b) => LLVMBuildFDiv,\n+        urem(a, b) => LLVMBuildURem,\n+        srem(a, b) => LLVMBuildSRem,\n+        frem(a, b) => LLVMBuildFRem,\n+        shl(a, b) => LLVMBuildShl,\n+        lshr(a, b) => LLVMBuildLShr,\n+        ashr(a, b) => LLVMBuildAShr,\n+        and(a, b) => LLVMBuildAnd,\n+        or(a, b) => LLVMBuildOr,\n+        xor(a, b) => LLVMBuildXor,\n+        neg(x) => LLVMBuildNeg,\n+        fneg(x) => LLVMBuildFNeg,\n+        not(x) => LLVMBuildNot,\n     }\n \n     fn fadd_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n \n-    fn sub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn fsub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n     fn fsub_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n \n-    fn mul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn fmul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n     fn fmul_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n \n-\n-    fn udiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn exactudiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn sdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn exactsdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn fdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n     fn fdiv_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n \n-    fn urem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn srem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn frem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n     fn frem_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n \n-    fn shl(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn lshr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn ashr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn and(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn or(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn xor(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    fn neg(&mut self, v: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n-        }\n-    }\n-\n-    fn fneg(&mut self, v: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n-        }\n-    }\n-\n-    fn not(&mut self, v: &'ll Value) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMBuildNot(self.llbuilder, v, noname())\n-        }\n-    }\n-\n     fn checked_binop(\n         &mut self,\n         oop: OverflowOp,\n@@ -492,7 +392,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         unsafe {\n             let alloca = if name.is_empty() {\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty, noname())\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED)\n             } else {\n                 let name = SmallCStr::new(name);\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty,\n@@ -510,7 +410,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         align: Align) -> &'ll Value {\n         unsafe {\n             let alloca = if name.is_empty() {\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, noname())\n+                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED)\n             } else {\n                 let name = SmallCStr::new(name);\n                 llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len,\n@@ -523,15 +423,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n         unsafe {\n-            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n+            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n             llvm::LLVMSetAlignment(load, align.bytes() as c_uint);\n             load\n         }\n     }\n \n     fn volatile_load(&mut self, ptr: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n+            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n             llvm::LLVMSetVolatile(load, llvm::True);\n             load\n         }\n@@ -547,7 +447,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             let load = llvm::LLVMRustBuildAtomicLoad(\n                 self.llbuilder,\n                 ptr,\n-                noname(),\n+                UNNAMED,\n                 AtomicOrdering::from_generic(order),\n             );\n             // LLVM requires the alignment of atomic loads to be at least the size of the type.\n@@ -750,88 +650,88 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n-                               indices.len() as c_uint, noname())\n+                               indices.len() as c_uint, UNNAMED)\n         }\n     }\n \n     fn inbounds_gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n-                self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n+                self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, UNNAMED)\n         }\n     }\n \n     fn struct_gep(&mut self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n-            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n+            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, UNNAMED)\n         }\n     }\n \n     /* Casts */\n     fn trunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn sext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n+            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,UNNAMED)\n         }\n     }\n \n     fn uitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn sitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn fptrunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn fpext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn ptrtoint(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn inttoptr(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn bitcast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n@@ -844,21 +744,21 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn pointercast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     /* Comparisons */\n     fn icmp(&mut self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         let op = llvm::IntPredicate::from_generic(op);\n         unsafe {\n-            llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n+            llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, UNNAMED)\n         }\n     }\n \n     fn fcmp(&mut self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n+            llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, UNNAMED)\n         }\n     }\n \n@@ -926,20 +826,20 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         else_val: &'ll Value,\n     ) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n+            llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, UNNAMED)\n         }\n     }\n \n     #[allow(dead_code)]\n     fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED)\n         }\n     }\n \n     fn extract_element(&mut self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n+            llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, UNNAMED)\n         }\n     }\n \n@@ -956,7 +856,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn extract_value(&mut self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n-            llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n+            llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, UNNAMED)\n         }\n     }\n \n@@ -965,15 +865,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n-                                       noname())\n+                                       UNNAMED)\n         }\n     }\n \n     fn landing_pad(&mut self, ty: &'ll Type, pers_fn: &'ll Value,\n                        num_clauses: usize) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n-                                      num_clauses as c_uint, noname())\n+                                      num_clauses as c_uint, UNNAMED)\n         }\n     }\n \n@@ -1143,14 +1043,14 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n-                bundle, noname()\n+                bundle, UNNAMED\n             )\n         }\n     }\n \n     fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n@@ -1232,7 +1132,7 @@ impl Builder<'a, 'll, 'tcx> {\n         idx: &'ll Value,\n     ) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n+            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, UNNAMED)\n         }\n     }\n \n@@ -1243,7 +1143,7 @@ impl Builder<'a, 'll, 'tcx> {\n         mask: &'ll Value,\n     ) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n+            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, UNNAMED)\n         }\n     }\n \n@@ -1385,7 +1285,7 @@ impl Builder<'a, 'll, 'tcx> {\n \n     pub fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED)\n         }\n     }\n \n@@ -1408,7 +1308,7 @@ impl Builder<'a, 'll, 'tcx> {\n     fn phi(&mut self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = unsafe {\n-            llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n+            llvm::LLVMBuildPhi(self.llbuilder, ty, UNNAMED)\n         };\n         unsafe {\n             llvm::LLVMAddIncoming(phi, vals.as_ptr(),"}, {"sha": "b13d8df5525e9f40dd115739c4f342924fb118b2", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5bd03892618e129529b6ed91bde9ee28ed1a2f/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5bd03892618e129529b6ed91bde9ee28ed1a2f/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=aa5bd03892618e129529b6ed91bde9ee28ed1a2f", "patch": "@@ -8,6 +8,7 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(const_cstr_unchecked)]\n #![feature(crate_visibility_modifier)]\n #![feature(custom_attribute)]\n #![feature(extern_types)]"}]}