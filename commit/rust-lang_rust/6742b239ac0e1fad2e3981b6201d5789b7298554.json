{"sha": "6742b239ac0e1fad2e3981b6201d5789b7298554", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NDJiMjM5YWMwZTFmYWQyZTM5ODFiNjIwMWQ1Nzg5YjcyOTg1NTQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-05T10:38:26Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:03Z"}, "message": "rustc_metadata: remove all unnecessary tables from astencode.", "tree": {"sha": "36f832e3343392bde8a90da928c22b938cb5d07d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36f832e3343392bde8a90da928c22b938cb5d07d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6742b239ac0e1fad2e3981b6201d5789b7298554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6742b239ac0e1fad2e3981b6201d5789b7298554", "html_url": "https://github.com/rust-lang/rust/commit/6742b239ac0e1fad2e3981b6201d5789b7298554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6742b239ac0e1fad2e3981b6201d5789b7298554/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2ea3daad1372cffa5caf9f20fe36667e334662b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ea3daad1372cffa5caf9f20fe36667e334662b", "html_url": "https://github.com/rust-lang/rust/commit/d2ea3daad1372cffa5caf9f20fe36667e334662b"}], "stats": {"total": 82, "additions": 2, "deletions": 80}, "files": [{"sha": "c687353d437c16e711fff4b9ba9a59a184a94f67", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 80, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6742b239ac0e1fad2e3981b6201d5789b7298554/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6742b239ac0e1fad2e3981b6201d5789b7298554/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=6742b239ac0e1fad2e3981b6201d5789b7298554", "patch": "@@ -19,10 +19,9 @@ use decoder::DecodeContext;\n use encoder::EncodeContext;\n \n use middle::cstore::{InlinedItem, InlinedItemRef};\n-use rustc::ty::adjustment;\n use rustc::hir::def;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n \n use syntax::ast;\n \n@@ -128,12 +127,8 @@ enum Table {\n     Def,\n     NodeType,\n     ItemSubsts,\n-    Freevars,\n-    MethodMap,\n     Adjustment,\n-    UpvarCaptureMap,\n-    ConstQualif,\n-    CastKind\n+    ConstQualif\n }\n \n fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n@@ -156,60 +151,11 @@ fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n         item_substs.substs.encode(ecx).unwrap();\n     }\n \n-    if let Some(fv) = tcx.freevars.borrow().get(&id) {\n-        ecx.entry(Table::Freevars, id);\n-        fv.encode(ecx).unwrap();\n-\n-        for freevar in fv {\n-            ecx.entry(Table::UpvarCaptureMap, id);\n-            let def_id = freevar.def.def_id();\n-            let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n-            let upvar_id = ty::UpvarId {\n-                var_id: var_id,\n-                closure_expr_id: id\n-            };\n-            let upvar_capture = tcx.tables\n-                                    .borrow()\n-                                    .upvar_capture_map\n-                                    .get(&upvar_id)\n-                                    .unwrap()\n-                                    .clone();\n-            var_id.encode(ecx).unwrap();\n-            upvar_capture.encode(ecx).unwrap();\n-        }\n-    }\n-\n-    let method_call = ty::MethodCall::expr(id);\n-    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n-        ecx.entry(Table::MethodMap, id);\n-        method_call.autoderef.encode(ecx).unwrap();\n-        method.encode(ecx).unwrap();\n-    }\n-\n     if let Some(adjustment) = tcx.tables.borrow().adjustments.get(&id) {\n-        match *adjustment {\n-            adjustment::AdjustDerefRef(ref adj) => {\n-                for autoderef in 0..adj.autoderefs {\n-                    let method_call = ty::MethodCall::autoderef(id, autoderef as u32);\n-                    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n-                        ecx.entry(Table::MethodMap, id);\n-                        method_call.autoderef.encode(ecx).unwrap();\n-                        method.encode(ecx).unwrap();\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n         ecx.entry(Table::Adjustment, id);\n         adjustment.encode(ecx).unwrap();\n     }\n \n-    if let Some(cast_kind) = tcx.cast_kinds.borrow().get(&id) {\n-        ecx.entry(Table::CastKind, id);\n-        cast_kind.encode(ecx).unwrap();\n-    }\n-\n     if let Some(qualif) = tcx.const_qualif_map.borrow().get(&id) {\n         ecx.entry(Table::ConstQualif, id);\n         qualif.encode(ecx).unwrap();\n@@ -234,34 +180,10 @@ fn decode_side_tables(dcx: &mut DecodeContext, ast_doc: rbml::Doc) {\n                 let item_substs = Decodable::decode(dcx).unwrap();\n                 dcx.tcx().tables.borrow_mut().item_substs.insert(id, item_substs);\n             }\n-            Table::Freevars => {\n-                let fv_info = Decodable::decode(dcx).unwrap();\n-                dcx.tcx().freevars.borrow_mut().insert(id, fv_info);\n-            }\n-            Table::UpvarCaptureMap => {\n-                let upvar_id = ty::UpvarId {\n-                    var_id: Decodable::decode(dcx).unwrap(),\n-                    closure_expr_id: id\n-                };\n-                let ub = Decodable::decode(dcx).unwrap();\n-                dcx.tcx().tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n-            }\n-            Table::MethodMap => {\n-                let method_call = ty::MethodCall {\n-                    expr_id: id,\n-                    autoderef: Decodable::decode(dcx).unwrap()\n-                };\n-                let method = Decodable::decode(dcx).unwrap();\n-                dcx.tcx().tables.borrow_mut().method_map.insert(method_call, method);\n-            }\n             Table::Adjustment => {\n                 let adj = Decodable::decode(dcx).unwrap();\n                 dcx.tcx().tables.borrow_mut().adjustments.insert(id, adj);\n             }\n-            Table::CastKind => {\n-                let cast_kind = Decodable::decode(dcx).unwrap();\n-                dcx.tcx().cast_kinds.borrow_mut().insert(id, cast_kind);\n-            }\n             Table::ConstQualif => {\n                 let qualif = Decodable::decode(dcx).unwrap();\n                 dcx.tcx().const_qualif_map.borrow_mut().insert(id, qualif);"}]}