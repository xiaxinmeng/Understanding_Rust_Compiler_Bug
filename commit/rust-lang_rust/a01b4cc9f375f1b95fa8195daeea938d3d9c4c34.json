{"sha": "a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "node_id": "C_kwDOAAsO6NoAKGEwMWI0Y2M5ZjM3NWYxYjk1ZmE4MTk1ZGFlZWE5MzhkM2Q5YzRjMzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T12:06:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T12:06:26Z"}, "message": "Auto merge of #109442 - Nilstrieb:rollup-seb5xsa, r=Nilstrieb\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #106434 (Document `Iterator::sum/product` for Option/Result)\n - #108326 (Implement read_buf for a few more types)\n - #108842 (Enforce non-lifetime-binders in supertrait preds are not object safe)\n - #108896 (new solver: make all goal evaluation able to be automatically rerun )\n - #109124 (Add `dist.compression-profile` option to control compression speed)\n - #109240 (Walk un-shifted nested `impl Trait` in trait when setting up default trait method assumptions)\n - #109385 (fix typo)\n - #109386 (add myself to mailmap)\n - #109390 (Custom MIR: Support aggregate expressions)\n - #109408 (not *all* retags might be explicit in Runtime MIR)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6253002cc0f9d198fe8747567aee1dd07636379b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6253002cc0f9d198fe8747567aee1dd07636379b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "html_url": "https://github.com/rust-lang/rust/commit/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef03fda339923e659d3d3ca3321de887316d2807", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef03fda339923e659d3d3ca3321de887316d2807", "html_url": "https://github.com/rust-lang/rust/commit/ef03fda339923e659d3d3ca3321de887316d2807"}, {"sha": "925fbcdf8a1646d5318e82c6d3ffeda41a10a110", "url": "https://api.github.com/repos/rust-lang/rust/commits/925fbcdf8a1646d5318e82c6d3ffeda41a10a110", "html_url": "https://github.com/rust-lang/rust/commit/925fbcdf8a1646d5318e82c6d3ffeda41a10a110"}], "stats": {"total": 1796, "additions": 1234, "deletions": 562}, "files": [{"sha": "9148b79e98016352998379523954214a8f065269", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -29,6 +29,8 @@ Alexander Ronald Altman <alexanderaltman@me.com>\n Alexandre Martin <martin.alex32@hotmail.fr>\n Alexis Beingessner <a.beingessner@gmail.com>\n Alfie John <alfie@alfie.wtf> Alfie John <alfiej@fastmail.fm>\n+Alona Enraght-Moony <code@alona.page> <nixon.emoony@gmail.com>\n+Alona Enraght-Moony <code@alona.page> <nixon@caminus.local>\n Amos Onn <amosonn@gmail.com>\n Ana-Maria Mihalache <mihalacheana.maria@yahoo.com>\n Anatoly Ikorsky <aikorsky@gmail.com>\n@@ -415,7 +417,6 @@ Nicolas Abram <abramlujan@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n Nika Layzell <nika@thelayzells.com> <michael@thelayzells.com>\n-Nixon Enraght-Moony <nixon.emoony@gmail.com>\n NODA Kai <nodakai@gmail.com>\n oliver <16816606+o752d@users.noreply.github.com>\n Oliver Middleton <olliemail27@gmail.com> <ollie27@users.noreply.github.com>"}, {"sha": "7ab7a8c4c1b43dd5c7f95c2a8036a7af5ab6d366", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -605,7 +605,7 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n         found: Option<ty::OpaqueHiddenType<'tcx>>,\n \n         /// In the presence of dead code, typeck may figure out a hidden type\n-        /// while borrowck will now. We collect these cases here and check at\n+        /// while borrowck will not. We collect these cases here and check at\n         /// the end that we actually found a type that matches (modulo regions).\n         typeck_types: Vec<ty::OpaqueHiddenType<'tcx>>,\n     }"}, {"sha": "3a893cdabf67eba0dc23a512dae950637ec71229", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -78,7 +78,8 @@ pub enum MirPhase {\n     ///    MIR, this is UB.\n     ///  - Retags: If `-Zmir-emit-retag` is enabled, analysis MIR has \"implicit\" retags in the same way\n     ///    that Rust itself has them. Where exactly these are is generally subject to change, and so we\n-    ///    don't document this here. Runtime MIR has all retags explicit.\n+    ///    don't document this here. Runtime MIR has most retags explicit (though implicit retags\n+    ///    can still occur at `Rvalue::{Ref,AddrOf}`).\n     ///  - Generator bodies: In analysis MIR, locals may actually be behind a pointer that user code has\n     ///    access to. This occurs in generator bodies. Such locals do not behave like other locals,\n     ///    because they eg may be aliased in surprising ways. Runtime MIR has no such special locals -\n@@ -1165,7 +1166,7 @@ pub enum AggregateKind<'tcx> {\n     Tuple,\n \n     /// The second field is the variant index. It's equal to 0 for struct\n-    /// and union expressions. The fourth field is\n+    /// and union expressions. The last field is the\n     /// active field number and is present only for union expressions\n     /// -- e.g., for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`"}, {"sha": "833402abfc4798a16ebb1cb64e7a11fa5550e5e7", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -897,6 +897,9 @@ pub enum ObjectSafetyViolation {\n     /// (e.g., `trait Foo : Bar<Self>`).\n     SupertraitSelf(SmallVec<[Span; 1]>),\n \n+    // Supertrait has a non-lifetime `for<T>` binder.\n+    SupertraitNonLifetimeBinder(SmallVec<[Span; 1]>),\n+\n     /// Method has something illegal.\n     Method(Symbol, MethodViolationCode, Span),\n \n@@ -919,6 +922,9 @@ impl ObjectSafetyViolation {\n                         .into()\n                 }\n             }\n+            ObjectSafetyViolation::SupertraitNonLifetimeBinder(_) => {\n+                format!(\"where clause cannot reference non-lifetime `for<...>` variables\").into()\n+            }\n             ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod(_), _) => {\n                 format!(\"associated function `{}` has no `self` parameter\", name).into()\n             }\n@@ -969,7 +975,9 @@ impl ObjectSafetyViolation {\n \n     pub fn solution(&self, err: &mut Diagnostic) {\n         match self {\n-            ObjectSafetyViolation::SizedSelf(_) | ObjectSafetyViolation::SupertraitSelf(_) => {}\n+            ObjectSafetyViolation::SizedSelf(_)\n+            | ObjectSafetyViolation::SupertraitSelf(_)\n+            | ObjectSafetyViolation::SupertraitNonLifetimeBinder(..) => {}\n             ObjectSafetyViolation::Method(\n                 name,\n                 MethodViolationCode::StaticMethod(Some((add_self_sugg, make_sized_sugg))),\n@@ -1023,7 +1031,8 @@ impl ObjectSafetyViolation {\n         // diagnostics use a `note` instead of a `span_label`.\n         match self {\n             ObjectSafetyViolation::SupertraitSelf(spans)\n-            | ObjectSafetyViolation::SizedSelf(spans) => spans.clone(),\n+            | ObjectSafetyViolation::SizedSelf(spans)\n+            | ObjectSafetyViolation::SupertraitNonLifetimeBinder(spans) => spans.clone(),\n             ObjectSafetyViolation::AssocConst(_, span)\n             | ObjectSafetyViolation::GAT(_, span)\n             | ObjectSafetyViolation::Method(_, _, span)"}, {"sha": "6205e2bf24dd11bce80c4617b2c75731e8d442b2", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -51,9 +51,7 @@ where\n // Region folder\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Folds the escaping and free regions in `value` using `f`, and\n-    /// sets `skipped_regions` to true if any late-bound region was found\n-    /// and skipped.\n+    /// Folds the escaping and free regions in `value` using `f`.\n     pub fn fold_regions<T>(\n         self,\n         value: T,\n@@ -64,17 +62,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     {\n         value.fold_with(&mut RegionFolder::new(self, &mut f))\n     }\n-\n-    pub fn super_fold_regions<T>(\n-        self,\n-        value: T,\n-        mut f: impl FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n-    ) -> T\n-    where\n-        T: TypeSuperFoldable<TyCtxt<'tcx>>,\n-    {\n-        value.super_fold_with(&mut RegionFolder::new(self, &mut f))\n-    }\n }\n \n /// Folds over the substructure of a type, visiting its component"}, {"sha": "adbd37a7cd9502e0a3877cae4d0abc0aa9d401a2", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -166,6 +166,28 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n                 let cast_kind = mir_cast_kind(source_ty, expr.ty);\n                 Ok(Rvalue::Cast(cast_kind, source, expr.ty))\n             },\n+            ExprKind::Tuple { fields } => Ok(\n+                Rvalue::Aggregate(\n+                    Box::new(AggregateKind::Tuple),\n+                    fields.iter().map(|e| self.parse_operand(*e)).collect::<Result<_, _>>()?\n+                )\n+            ),\n+            ExprKind::Array { fields } => {\n+                let elem_ty = expr.ty.builtin_index().expect(\"ty must be an array\");\n+                Ok(Rvalue::Aggregate(\n+                    Box::new(AggregateKind::Array(elem_ty)),\n+                    fields.iter().map(|e| self.parse_operand(*e)).collect::<Result<_, _>>()?\n+                ))\n+            },\n+            ExprKind::Adt(box AdtExpr{ adt_def, variant_index, substs, fields, .. }) => {\n+                let is_union = adt_def.is_union();\n+                let active_field_index = is_union.then(|| fields[0].name.index());\n+\n+                Ok(Rvalue::Aggregate(\n+                    Box::new(AggregateKind::Adt(adt_def.did(), *variant_index, substs, None, active_field_index)),\n+                    fields.iter().map(|f| self.parse_operand(f.expr)).collect::<Result<_, _>>()?\n+                ))\n+            },\n             _ => self.parse_operand(expr_id).map(Rvalue::Use),\n         )\n     }"}, {"sha": "76cde1a669225247c8d2077e6f988a7b0facb7a9", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -224,7 +224,9 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         if goal.predicate.self_ty().is_ty_var() {\n             return vec![Candidate {\n                 source: CandidateSource::BuiltinImpl,\n-                result: self.make_canonical_response(Certainty::AMBIGUOUS).unwrap(),\n+                result: self\n+                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    .unwrap(),\n             }];\n         }\n \n@@ -261,37 +263,26 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n-        self.probe(|this| {\n-            let normalized_ty = this.next_ty_infer();\n+\n+        self.probe(|ecx| {\n+            let normalized_ty = ecx.next_ty_infer();\n             let normalizes_to_goal = goal.with(\n                 tcx,\n                 ty::Binder::dummy(ty::ProjectionPredicate {\n                     projection_ty,\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty = match this.evaluate_goal(normalizes_to_goal) {\n-                Ok((_, certainty)) => certainty,\n-                Err(NoSolution) => return,\n-            };\n-            let normalized_ty = this.resolve_vars_if_possible(normalized_ty);\n-\n-            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-            // This doesn't work as long as we use `CandidateSource` in winnowing.\n-            let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let normalized_candidates = this.assemble_and_evaluate_candidates(goal);\n-            for mut normalized_candidate in normalized_candidates {\n-                normalized_candidate.result =\n-                    normalized_candidate.result.unchecked_map(|mut response| {\n-                        // FIXME: This currently hides overflow in the normalization step of the self type\n-                        // which is probably wrong. Maybe `unify_and` should actually keep overflow as\n-                        // we treat it as non-fatal anyways.\n-                        response.certainty = response.certainty.unify_and(normalization_certainty);\n-                        response\n-                    });\n-                candidates.push(normalized_candidate);\n+            ecx.add_goal(normalizes_to_goal);\n+            if let Ok(_) = ecx.try_evaluate_added_goals() {\n+                let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+\n+                // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n+                // This doesn't work as long as we use `CandidateSource` in winnowing.\n+                let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+                candidates.extend(ecx.assemble_and_evaluate_candidates(goal));\n             }\n-        })\n+        });\n     }\n \n     fn assemble_impl_candidates<G: GoalKind<'tcx>>(\n@@ -516,7 +507,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 } else {\n                     Certainty::AMBIGUOUS\n                 };\n-                return self.make_canonical_response(certainty);\n+                return self.evaluate_added_goals_and_make_canonical_response(certainty);\n             }\n         }\n \n@@ -538,14 +529,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n-    fn discard_reservation_impl(&self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+    fn discard_reservation_impl(&mut self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n         if let CandidateSource::Impl(def_id) = candidate.source {\n             if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n                 debug!(\"Selected reservation impl\");\n                 // We assemble all candidates inside of a probe so by\n                 // making a new canonical response here our result will\n                 // have no constraints.\n-                candidate.result = self.make_canonical_response(Certainty::AMBIGUOUS).unwrap();\n+                candidate.result = self\n+                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    .unwrap();\n             }\n         }\n "}, {"sha": "9d45e78ebab044b9d2d12e11ae2333cc1dafaf64", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -48,7 +48,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// - `external_constraints`: additional constraints which aren't expressable\n     ///   using simple unification of inference variables.\n     #[instrument(level = \"debug\", skip(self))]\n-    pub(super) fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+    pub(super) fn evaluate_added_goals_and_make_canonical_response(\n+        &mut self,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx> {\n+        let goals_certainty = self.try_evaluate_added_goals()?;\n+        let certainty = certainty.unify_and(goals_certainty);\n+\n         let external_constraints = self.compute_external_query_constraints()?;\n \n         let response = Response { var_values: self.var_values, external_constraints, certainty };\n@@ -209,7 +215,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n             // some point. We can figure out how to deal with this once we actually have\n             // an ICE.\n-            let nested_goals = self.eq(param_env, orig, response)?;\n+            let nested_goals = self.eq_and_get_goals(param_env, orig, response)?;\n             assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n         }\n "}, {"sha": "9541292235795a2d8a4b7e9b72adeefe217fbe79", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 334, "deletions": 7, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -2,8 +2,11 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::infer::{\n+    DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime, TyCtxtInferExt,\n+};\n use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::{\n@@ -13,8 +16,8 @@ use rustc_middle::ty::{\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n-use super::search_graph::SearchGraph;\n-use super::Goal;\n+use super::search_graph::{self, OverflowHandler};\n+use super::{search_graph::SearchGraph, Goal};\n \n pub struct EvalCtxt<'a, 'tcx> {\n     // FIXME: should be private.\n@@ -33,14 +36,305 @@ pub struct EvalCtxt<'a, 'tcx> {\n \n     pub(super) search_graph: &'a mut SearchGraph<'tcx>,\n \n-    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    pub in_projection_eq_hack: bool,\n+    pub(super) nested_goals: NestedGoals<'tcx>,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub(super) enum IsNormalizesToHack {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(super) struct NestedGoals<'tcx> {\n+    pub(super) normalizes_to_hack_goal: Option<Goal<'tcx, ty::ProjectionPredicate<'tcx>>>,\n+    pub(super) goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n+}\n+\n+impl NestedGoals<'_> {\n+    pub(super) fn new() -> Self {\n+        Self { normalizes_to_hack_goal: None, goals: Vec::new() }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.normalizes_to_hack_goal.is_none() && self.goals.is_empty()\n+    }\n+}\n+\n+pub trait InferCtxtEvalExt<'tcx> {\n+    /// Evaluates a goal from **outside** of the trait solver.\n+    ///\n+    /// Using this while inside of the solver is wrong as it uses a new\n+    /// search graph which would break cycle detection.\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution>;\n+}\n+\n+impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n+\n+        let mut ecx = EvalCtxt {\n+            search_graph: &mut search_graph,\n+            infcx: self,\n+            // Only relevant when canonicalizing the response.\n+            max_input_universe: ty::UniverseIndex::ROOT,\n+            var_values: CanonicalVarValues::dummy(),\n+            nested_goals: NestedGoals::new(),\n+        };\n+        let result = ecx.evaluate_goal(IsNormalizesToHack::No, goal);\n+\n+        assert!(\n+            ecx.nested_goals.is_empty(),\n+            \"root `EvalCtxt` should not have any goals added to it\"\n+        );\n+\n+        assert!(search_graph.is_empty());\n+        result\n+    }\n+}\n+\n+impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    /// The entry point of the solver.\n+    ///\n+    /// This function deals with (coinductive) cycles, overflow, and caching\n+    /// and then calls [`EvalCtxt::compute_goal`] which contains the actual\n+    /// logic of the solver.\n+    ///\n+    /// Instead of calling this function directly, use either [EvalCtxt::evaluate_goal]\n+    /// if you're inside of the solver or [InferCtxtEvalExt::evaluate_root_goal] if you're\n+    /// outside of it.\n+    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n+    fn evaluate_canonical_goal(\n+        tcx: TyCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+        canonical_goal: CanonicalGoal<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        // Deal with overflow, caching, and coinduction.\n+        //\n+        // The actual solver logic happens in `ecx.compute_goal`.\n+        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n+            let (ref infcx, goal, var_values) =\n+                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let mut ecx = EvalCtxt {\n+                infcx,\n+                var_values,\n+                max_input_universe: canonical_goal.max_universe,\n+                search_graph,\n+                nested_goals: NestedGoals::new(),\n+            };\n+            ecx.compute_goal(goal)\n+        })\n+    }\n+\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        is_normalizes_to_hack: IsNormalizesToHack,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n+        let canonical_response =\n+            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+\n+        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let certainty = self.instantiate_and_apply_query_response(\n+            goal.param_env,\n+            orig_values,\n+            canonical_response,\n+        )?;\n+\n+        // Check that rerunning this query with its inference constraints applied\n+        // doesn't result in new inference constraints and has the same result.\n+        //\n+        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n+        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n+        // could constrain `U` to `u32` which would cause this check to result in a\n+        // solver cycle.\n+        if cfg!(debug_assertions)\n+            && has_changed\n+            && is_normalizes_to_hack == IsNormalizesToHack::No\n+            && !self.search_graph.in_cycle()\n+        {\n+            debug!(\"rerunning goal to check result is stable\");\n+            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n+            let canonical_response =\n+                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+            if !canonical_response.value.var_values.is_identity() {\n+                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n+            }\n+            assert_eq!(certainty, canonical_response.value.certainty);\n+        }\n+\n+        Ok((has_changed, certainty))\n+    }\n+\n+    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n+        let Goal { param_env, predicate } = goal;\n+        let kind = predicate.kind();\n+        if let Some(kind) = kind.no_bound_vars() {\n+            match kind {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    self.compute_trait_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n+                    self.compute_projection_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n+                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n+                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n+                }\n+                ty::PredicateKind::Subtype(predicate) => {\n+                    self.compute_subtype_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Coerce(predicate) => {\n+                    self.compute_coerce_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n+                    .compute_closure_kind_goal(Goal {\n+                        param_env,\n+                        predicate: (def_id, substs, kind),\n+                    }),\n+                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                    self.compute_object_safe_goal(trait_def_id)\n+                }\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n+                }\n+                ty::PredicateKind::Ambiguous => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                }\n+                // FIXME: implement these predicates :)\n+                ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n+                }\n+                ty::PredicateKind::AliasEq(lhs, rhs) => {\n+                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n+                }\n+            }\n+        } else {\n+            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n+            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n+            self.add_goal(goal);\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        }\n+    }\n+\n+    // Recursively evaluates all the goals added to this `EvalCtxt` to completion, returning\n+    // the certainty of all the goals.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(super) fn try_evaluate_added_goals(&mut self) -> Result<Certainty, NoSolution> {\n+        let mut goals = core::mem::replace(&mut self.nested_goals, NestedGoals::new());\n+        let mut new_goals = NestedGoals::new();\n+\n+        let response = self.repeat_while_none(\n+            |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n+            |this| {\n+                let mut has_changed = Err(Certainty::Yes);\n+\n+                if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n+                    let (_, certainty) = match this.evaluate_goal(\n+                        IsNormalizesToHack::Yes,\n+                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n+                    ) {\n+                        Ok(r) => r,\n+                        Err(NoSolution) => return Some(Err(NoSolution)),\n+                    };\n+\n+                    if goal.predicate.projection_ty\n+                        != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n+                    {\n+                        has_changed = Ok(())\n+                    }\n+\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            let goal = this.resolve_vars_if_possible(goal);\n+\n+                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n+                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n+                            // regardless of the rhs.\n+                            //\n+                            // However it is important not to unconditionally replace the rhs with a new infer var\n+                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n+                            // and never propagate any constraints on the new var back to the original var.\n+                            let term = this\n+                                .term_is_fully_unconstrained(goal)\n+                                .then_some(goal.predicate.term)\n+                                .unwrap_or_else(|| {\n+                                    this.next_term_infer_of_kind(goal.predicate.term)\n+                                });\n+                            let projection_pred = ty::ProjectionPredicate {\n+                                term,\n+                                projection_ty: goal.predicate.projection_ty,\n+                            };\n+                            new_goals.normalizes_to_hack_goal =\n+                                Some(goal.with(this.tcx(), projection_pred));\n+\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n+                    }\n+                }\n+\n+                for nested_goal in goals.goals.drain(..) {\n+                    let (changed, certainty) =\n+                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n+                            Ok(result) => result,\n+                            Err(NoSolution) => return Some(Err(NoSolution)),\n+                        };\n+\n+                    if changed {\n+                        has_changed = Ok(());\n+                    }\n+\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            new_goals.goals.push(nested_goal);\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n+                    }\n+                }\n+\n+                core::mem::swap(&mut new_goals, &mut goals);\n+                match has_changed {\n+                    Ok(()) => None,\n+                    Err(certainty) => Some(Ok(certainty)),\n+                }\n+            },\n+        );\n+\n+        self.nested_goals = goals;\n+        response\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn probe<T>(&mut self, f: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> T) -> T {\n-        self.infcx.probe(|_| f(self))\n+        let mut ecx = EvalCtxt {\n+            infcx: self.infcx,\n+            var_values: self.var_values,\n+            max_input_universe: self.max_input_universe,\n+            search_graph: self.search_graph,\n+            nested_goals: self.nested_goals.clone(),\n+        };\n+        self.infcx.probe(|_| f(&mut ecx))\n     }\n \n     pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -61,6 +355,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         )\n     }\n \n+    /// Returns a ty infer or a const infer depending on whether `kind` is a `Ty` or `Const`.\n+    /// If `kind` is an integer inference variable this will still return a ty infer var.\n+    pub(super) fn next_term_infer_of_kind(&self, kind: ty::Term<'tcx>) -> ty::Term<'tcx> {\n+        match kind.unpack() {\n+            ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n+            ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n+        }\n+    }\n+\n     /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n     ///\n     /// This is the case if the `term` is an inference variable in the innermost universe\n@@ -137,6 +440,30 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self, param_env), ret)]\n     pub(super) fn eq<T: ToTrace<'tcx>>(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<(), NoSolution> {\n+        self.infcx\n+            .at(&ObligationCause::dummy(), param_env)\n+            .eq(DefineOpaqueTypes::No, lhs, rhs)\n+            .map(|InferOk { value: (), obligations }| {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to equate\");\n+                NoSolution\n+            })\n+    }\n+\n+    /// Equates two values returning the nested goals without adding them\n+    /// to the nested goals of the `EvalCtxt`.\n+    ///\n+    /// If possible, try using `eq` instead which automatically handles nested\n+    /// goals correctly.\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    pub(super) fn eq_and_get_goals<T: ToTrace<'tcx>>(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         lhs: T,"}, {"sha": "606c2eaa510518b07595dbd6460773efcc155236", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 49, "deletions": 241, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -15,23 +15,19 @@\n \n // FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n \n-use std::mem;\n-\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n-    Goal, MaybeCause, QueryResult, Response,\n+    Goal, QueryResult, Response,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n-use rustc_span::DUMMY_SP;\n \n-use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n@@ -42,7 +38,7 @@ mod project_goals;\n mod search_graph;\n mod trait_goals;\n \n-pub use eval_ctxt::EvalCtxt;\n+pub use eval_ctxt::{EvalCtxt, InferCtxtEvalExt};\n pub use fulfill::FulfillmentCtxt;\n \n trait CanonicalResponseExt {\n@@ -57,180 +53,18 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     }\n }\n \n-pub trait InferCtxtEvalExt<'tcx> {\n-    /// Evaluates a goal from **outside** of the trait solver.\n-    ///\n-    /// Using this while inside of the solver is wrong as it uses a new\n-    /// search graph which would break cycle detection.\n-    fn evaluate_root_goal(\n-        &self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution>;\n-}\n-\n-impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n-    fn evaluate_root_goal(\n-        &self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n-\n-        let result = EvalCtxt {\n-            search_graph: &mut search_graph,\n-            infcx: self,\n-            // Only relevant when canonicalizing the response.\n-            max_input_universe: ty::UniverseIndex::ROOT,\n-            var_values: CanonicalVarValues::dummy(),\n-            in_projection_eq_hack: false,\n-        }\n-        .evaluate_goal(goal);\n-\n-        assert!(search_graph.is_empty());\n-        result\n-    }\n-}\n-\n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n-    /// The entry point of the solver.\n-    ///\n-    /// This function deals with (coinductive) cycles, overflow, and caching\n-    /// and then calls [`EvalCtxt::compute_goal`] which contains the actual\n-    /// logic of the solver.\n-    ///\n-    /// Instead of calling this function directly, use either [EvalCtxt::evaluate_goal]\n-    /// if you're inside of the solver or [InferCtxtEvalExt::evaluate_root_goal] if you're\n-    /// outside of it.\n-    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n-    fn evaluate_canonical_goal(\n-        tcx: TyCtxt<'tcx>,\n-        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        // Deal with overflow, caching, and coinduction.\n-        //\n-        // The actual solver logic happens in `ecx.compute_goal`.\n-        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n-            let (ref infcx, goal, var_values) =\n-                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx = EvalCtxt {\n-                infcx,\n-                var_values,\n-                max_input_universe: canonical_goal.max_universe,\n-                search_graph,\n-                in_projection_eq_hack: false,\n-            };\n-            ecx.compute_goal(goal)\n-        })\n-    }\n-\n-    /// Recursively evaluates `goal`, returning whether any inference vars have\n-    /// been constrained and the certainty of the result.\n-    fn evaluate_goal(\n-        &mut self,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n-        let canonical_response =\n-            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-\n-        let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty = self.instantiate_and_apply_query_response(\n-            goal.param_env,\n-            orig_values,\n-            canonical_response,\n-        )?;\n-\n-        // Check that rerunning this query with its inference constraints applied\n-        // doesn't result in new inference constraints and has the same result.\n-        //\n-        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n-        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n-        // could constrain `U` to `u32` which would cause this check to result in a\n-        // solver cycle.\n-        if cfg!(debug_assertions)\n-            && has_changed\n-            && !self.in_projection_eq_hack\n-            && !self.search_graph.in_cycle()\n-            && false\n-        {\n-            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n-            let canonical_response =\n-                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-            if !canonical_response.value.var_values.is_identity() {\n-                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n-            }\n-            assert_eq!(certainty, canonical_response.value.certainty);\n-        }\n-\n-        Ok((has_changed, certainty))\n-    }\n-\n-    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n-        let Goal { param_env, predicate } = goal;\n-        let kind = predicate.kind();\n-        if let Some(kind) = kind.no_bound_vars() {\n-            match kind {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n-                    self.compute_trait_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n-                    self.compute_projection_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n-                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n-                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n-                }\n-                ty::PredicateKind::Subtype(predicate) => {\n-                    self.compute_subtype_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::Coerce(predicate) => {\n-                    self.compute_coerce_goal(Goal { param_env, predicate })\n-                }\n-                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n-                    .compute_closure_kind_goal(Goal {\n-                        param_env,\n-                        predicate: (def_id, substs, kind),\n-                    }),\n-                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                    self.compute_object_safe_goal(trait_def_id)\n-                }\n-                ty::PredicateKind::WellFormed(arg) => {\n-                    self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n-                }\n-                ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::AMBIGUOUS),\n-                // FIXME: implement these predicates :)\n-                ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n-                    self.make_canonical_response(Certainty::Yes)\n-                }\n-                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n-                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n-                }\n-                ty::PredicateKind::AliasEq(lhs, rhs) => {\n-                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n-                }\n-            }\n-        } else {\n-            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n-            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n-            let (_, certainty) = self.evaluate_goal(goal)?;\n-            self.make_canonical_response(certainty)\n-        }\n-    }\n-\n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_type_outlives_goal(\n         &mut self,\n         goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n         self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n-        self.make_canonical_response(Certainty::Yes)\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_region_outlives_goal(\n         &mut self,\n         goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n@@ -239,9 +73,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             &ObligationCause::dummy(),\n             ty::Binder::dummy(goal.predicate),\n         );\n-        self.make_canonical_response(Certainty::Yes)\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_coerce_goal(\n         &mut self,\n         goal: Goal<'tcx, CoercePredicate<'tcx>>,\n@@ -256,25 +91,26 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_subtype_goal(\n         &mut self,\n         goal: Goal<'tcx, SubtypePredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.a.is_ty_var() && goal.predicate.b.is_ty_var() {\n             // FIXME: Do we want to register a subtype relation between these vars?\n             // That won't actually reflect in the query response, so it seems moot.\n-            self.make_canonical_response(Certainty::AMBIGUOUS)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n             let InferOk { value: (), obligations } = self\n                 .infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n-            self.evaluate_all_and_make_canonical_response(\n-                obligations.into_iter().map(|pred| pred.into()).collect(),\n-            )\n+            self.add_goals(obligations.into_iter().map(|pred| pred.into()));\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_closure_kind_goal(\n         &mut self,\n         goal: Goal<'tcx, (DefId, ty::SubstsRef<'tcx>, ty::ClosureKind)>,\n@@ -283,23 +119,25 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let found_kind = substs.as_closure().kind_ty().to_opt_closure_kind();\n \n         let Some(found_kind) = found_kind else {\n-            return self.make_canonical_response(Certainty::AMBIGUOUS);\n+            return self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         };\n         if found_kind.extends(expected_kind) {\n-            self.make_canonical_response(Certainty::Yes)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_object_safe_goal(&mut self, trait_def_id: DefId) -> QueryResult<'tcx> {\n         if self.tcx().check_is_object_safe(trait_def_id) {\n-            self.make_canonical_response(Certainty::Yes)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_well_formed_goal(\n         &mut self,\n         goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n@@ -309,10 +147,11 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             goal.param_env,\n             goal.predicate,\n         ) {\n-            Some(obligations) => self.evaluate_all_and_make_canonical_response(\n-                obligations.into_iter().map(|o| o.into()).collect(),\n-            ),\n-            None => self.make_canonical_response(Certainty::AMBIGUOUS),\n+            Some(obligations) => {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n+            None => self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS),\n         }\n     }\n \n@@ -326,14 +165,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n             debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n             let r = ecx.probe(|ecx| {\n-                let (_, certainty) = ecx.evaluate_goal(goal.with(\n+                ecx.add_goal(goal.with(\n                     tcx,\n                     ty::Binder::dummy(ty::ProjectionPredicate {\n                         projection_ty: alias,\n                         term: other,\n                     }),\n-                ))?;\n-                ecx.make_canonical_response(certainty)\n+                ));\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             });\n             debug!(\"evaluate_normalizes_to(..) -> {:?}\", r);\n             r\n@@ -360,10 +199,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 // Evaluate all 3 potential candidates for the alias' being equal\n                 candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n                 candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n-                candidates.push(self.probe(|this| {\n+                candidates.push(self.probe(|ecx| {\n                     debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n-                    let nested_goals = this.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                    this.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }));\n \n                 debug!(?candidates);\n@@ -379,62 +218,31 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, (ty::Const<'tcx>, Ty<'tcx>)>,\n     ) -> QueryResult<'tcx> {\n         let (ct, ty) = goal.predicate;\n-        let nested_goals = self.eq(goal.param_env, ct.ty(), ty)?;\n-        self.evaluate_all_and_make_canonical_response(nested_goals)\n+        self.eq(goal.param_env, ct.ty(), ty)?;\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n-    // Recursively evaluates a list of goals to completion, returning the certainty\n-    // of all of the goals.\n-    fn evaluate_all(\n-        &mut self,\n-        mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> Result<Certainty, NoSolution> {\n-        let mut new_goals = Vec::new();\n-        self.repeat_while_none(\n-            |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n-            |this| {\n-                let mut has_changed = Err(Certainty::Yes);\n-                for goal in goals.drain(..) {\n-                    let (changed, certainty) = match this.evaluate_goal(goal) {\n-                        Ok(result) => result,\n-                        Err(NoSolution) => return Some(Err(NoSolution)),\n-                    };\n-\n-                    if changed {\n-                        has_changed = Ok(());\n-                    }\n-\n-                    match certainty {\n-                        Certainty::Yes => {}\n-                        Certainty::Maybe(_) => {\n-                            new_goals.push(goal);\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n-                        }\n-                    }\n-                }\n-\n-                match has_changed {\n-                    Ok(()) => {\n-                        mem::swap(&mut new_goals, &mut goals);\n-                        None\n-                    }\n-                    Err(certainty) => Some(Ok(certainty)),\n-                }\n-            },\n-        )\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn set_normalizes_to_hack_goal(&mut self, goal: Goal<'tcx, ty::ProjectionPredicate<'tcx>>) {\n+        assert!(\n+            self.nested_goals.normalizes_to_hack_goal.is_none(),\n+            \"attempted to set the projection eq hack goal when one already exists\"\n+        );\n+        self.nested_goals.normalizes_to_hack_goal = Some(goal);\n     }\n \n-    // Recursively evaluates a list of goals to completion, making a query response.\n-    //\n-    // This is just a convenient way of calling [`EvalCtxt::evaluate_all`],\n-    // then [`EvalCtxt::make_canonical_response`].\n-    fn evaluate_all_and_make_canonical_response(\n-        &mut self,\n-        goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> QueryResult<'tcx> {\n-        self.evaluate_all(goals).and_then(|certainty| self.make_canonical_response(certainty))\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn add_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) {\n+        self.nested_goals.goals.push(goal);\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, goals))]\n+    fn add_goals(&mut self, goals: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>) {\n+        let current_len = self.nested_goals.goals.len();\n+        self.nested_goals.goals.extend(goals);\n+        debug!(\"added_goals={:?}\", &self.nested_goals.goals[current_len..]);\n     }\n \n     fn try_merge_responses(\n@@ -466,7 +274,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         });\n         // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n         // responses and use that for the constraints of this ambiguous response.\n-        let response = self.make_canonical_response(certainty);\n+        let response = self.evaluate_added_goals_and_make_canonical_response(certainty);\n         if let Ok(response) = &response {\n             assert!(response.has_no_inference_or_external_constraints());\n         }"}, {"sha": "93d77c39f9580a37e1fc85cabbd9a83a6ed5f0a6", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 55, "deletions": 96, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -20,6 +20,7 @@ use rustc_span::{sym, DUMMY_SP};\n use std::iter;\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn compute_projection_goal(\n         &mut self,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n@@ -36,53 +37,17 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             self.merge_candidates_and_discard_reservation_impls(candidates)\n         } else {\n             let predicate = goal.predicate;\n-            let unconstrained_rhs = match predicate.term.unpack() {\n-                ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n-                ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n-            };\n-            let unconstrained_predicate = ty::Clause::Projection(ProjectionPredicate {\n+            let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n+            let unconstrained_predicate = ProjectionPredicate {\n                 projection_ty: goal.predicate.projection_ty,\n                 term: unconstrained_rhs,\n-            });\n-            let (_has_changed, normalize_certainty) = self.in_projection_eq_hack(|this| {\n-                this.evaluate_goal(goal.with(this.tcx(), unconstrained_predicate))\n-            })?;\n-\n-            let nested_eq_goals = self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n-            let eval_certainty = self.evaluate_all(nested_eq_goals)?;\n-            self.make_canonical_response(normalize_certainty.unify_and(eval_certainty))\n-        }\n-    }\n-\n-    /// This sets a flag used by a debug assert in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    fn in_projection_eq_hack<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n-        self.in_projection_eq_hack = true;\n-        let result = f(self);\n-        self.in_projection_eq_hack = false;\n-        result\n-    }\n-\n-    /// After normalizing the projection to `normalized_alias` with the given\n-    /// `normalization_certainty`, constrain the inference variable `term` to it\n-    /// and return a query response.\n-    fn eq_term_and_make_canonical_response(\n-        &mut self,\n-        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n-        normalization_certainty: Certainty,\n-        normalized_alias: impl Into<ty::Term<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        // The term of our goal should be fully unconstrained, so this should never fail.\n-        //\n-        // It can however be ambiguous when the `normalized_alias` contains a projection.\n-        let nested_goals = self\n-            .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n-            .expect(\"failed to unify with unconstrained term\");\n-\n-        let unify_certainty =\n-            self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n+            };\n \n-        self.make_canonical_response(normalization_certainty.unify_and(unify_certainty))\n+            self.set_normalizes_to_hack_goal(goal.with(self.tcx(), unconstrained_predicate));\n+            self.try_evaluate_added_goals()?;\n+            self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        }\n     }\n }\n \n@@ -111,19 +76,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_projection_pred =\n                     ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n                 )?;\n-                nested_goals.extend(requirements);\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n+                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n+                ecx.add_goals(requirements);\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -139,36 +99,31 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n         {\n             ecx.probe(|ecx| {\n+                let tcx = ecx.tcx();\n+\n                 let assumption_projection_pred =\n                     ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n                 )?;\n \n-                let tcx = ecx.tcx();\n                 let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n                     bug!(\"expected object type in `consider_object_bound_candidate`\");\n                 };\n-                nested_goals.extend(\n+                ecx.add_goals(\n                     structural_traits::predicates_for_object_candidate(\n-                        ecx,\n+                        &ecx,\n                         goal.param_env,\n                         goal.predicate.projection_ty.trait_ref(tcx),\n                         bounds,\n                     )\n                     .into_iter()\n                     .map(|pred| goal.with(tcx, pred)),\n                 );\n-\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n+                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -195,16 +150,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals = ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+            ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n-\n-            nested_goals.extend(where_clause_bounds);\n-            let match_impl_certainty = ecx.evaluate_all(nested_goals)?;\n+            ecx.add_goals(where_clause_bounds);\n \n             // In case the associated item is hidden due to specialization, we have to\n             // return ambiguity this would otherwise be incomplete, resulting in\n@@ -216,7 +170,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                return ecx.make_canonical_response(match_impl_certainty.unify_and(Certainty::AMBIGUOUS));\n+                return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -263,7 +217,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            ecx.eq_term_and_make_canonical_response(goal, match_impl_certainty, term.subst(tcx, substs))\n+            ecx.eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -308,14 +263,18 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        let Some(tupled_inputs_and_output) =\n-        structural_traits::extract_tupled_inputs_and_output_from_callable(\n-            tcx,\n-            goal.predicate.self_ty(),\n-            goal_kind,\n-        )? else {\n-        return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n-    };\n+        let tupled_inputs_and_output =\n+            match structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                tcx,\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )? {\n+                Some(tupled_inputs_and_output) => tupled_inputs_and_output,\n+                None => {\n+                    return ecx\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+            };\n         let output_is_sized_pred = tupled_inputs_and_output\n             .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n \n@@ -380,26 +339,22 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n \n-                    let (_, is_sized_certainty) =\n-                        ecx.evaluate_goal(goal.with(tcx, sized_predicate))?;\n-                    return ecx.eq_term_and_make_canonical_response(\n-                        goal,\n-                        is_sized_certainty,\n-                        tcx.types.unit,\n-                    );\n+                    ecx.add_goal(goal.with(tcx, sized_predicate));\n+                    ecx.eq(goal.param_env, goal.predicate.term, tcx.types.unit.into())?;\n+                    return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                 }\n \n                 ty::Adt(def, substs) if def.is_struct() => {\n                     match def.non_enum_variant().fields.last() {\n                         None => tcx.types.unit,\n                         Some(field_def) => {\n                             let self_ty = field_def.ty(tcx, substs);\n-                            let new_goal = goal.with(\n+                            ecx.add_goal(goal.with(\n                                 tcx,\n                                 ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n-                            );\n-                            let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n-                            return ecx.make_canonical_response(certainty);\n+                            ));\n+                            return ecx\n+                                .evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                         }\n                     }\n                 }\n@@ -408,12 +363,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty::Tuple(elements) => match elements.last() {\n                     None => tcx.types.unit,\n                     Some(&self_ty) => {\n-                        let new_goal = goal.with(\n+                        ecx.add_goal(goal.with(\n                             tcx,\n                             ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n-                        );\n-                        let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n-                        return ecx.make_canonical_response(certainty);\n+                        ));\n+                        return ecx\n+                            .evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                     }\n                 },\n \n@@ -426,7 +381,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ),\n             };\n \n-            ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, metadata_ty)\n+            ecx.eq(goal.param_env, goal.predicate.term, metadata_ty.into())?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -522,7 +478,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         let discriminant = goal.predicate.self_ty().discriminant_ty(ecx.tcx());\n-        ecx.probe(|ecx| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n+        ecx.probe(|ecx| {\n+            ecx.eq(goal.param_env, goal.predicate.term, discriminant.into())?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n     }\n }\n "}, {"sha": "83d77a69c0020e950d7dc24dbb3091fb884f178a", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -39,9 +39,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     }\n \n     pub(super) fn is_empty(&self) -> bool {\n-        self.stack.is_empty()\n-            && self.provisional_cache.is_empty()\n-            && !self.overflow_data.did_overflow()\n+        self.stack.is_empty() && self.provisional_cache.is_empty()\n     }\n \n     /// Whether we're currently in a cycle. This should only be used"}, {"sha": "8ab55c79fc4502ec41a12c8b9bbdbb9df14cb374", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 63, "deletions": 66, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -47,16 +47,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals =\n-                ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n+            ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n-            nested_goals.extend(where_clause_bounds);\n-            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            ecx.add_goals(where_clause_bounds);\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -73,13 +72,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n-                nested_goals.extend(requirements);\n-                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                ecx.add_goals(requirements);\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -98,7 +97,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n@@ -108,18 +107,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n                     bug!(\"expected object type in `consider_object_bound_candidate`\");\n                 };\n-                nested_goals.extend(\n+                ecx.add_goals(\n                     structural_traits::predicates_for_object_candidate(\n-                        ecx,\n+                        &ecx,\n                         goal.param_env,\n                         goal.predicate.trait_ref,\n                         bounds,\n                     )\n                     .into_iter()\n                     .map(|pred| goal.with(tcx, pred)),\n                 );\n-\n-                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -166,9 +164,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let nested_obligations = tcx\n                 .predicates_of(goal.predicate.def_id())\n                 .instantiate(tcx, goal.predicate.trait_ref.substs);\n-            ecx.evaluate_all_and_make_canonical_response(\n-                nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)).collect(),\n-            )\n+            ecx.add_goals(nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)));\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -197,7 +194,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.self_ty().has_non_region_infer() {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+            return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n \n         let tcx = ecx.tcx();\n@@ -209,7 +206,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             && layout.layout.align().abi == usize_layout.align().abi\n         {\n             // FIXME: We could make this faster by making a no-constraints response\n-            ecx.make_canonical_response(Certainty::Yes)\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n@@ -221,14 +218,18 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        let Some(tupled_inputs_and_output) =\n-            structural_traits::extract_tupled_inputs_and_output_from_callable(\n+        let tupled_inputs_and_output =\n+            match structural_traits::extract_tupled_inputs_and_output_from_callable(\n                 tcx,\n                 goal.predicate.self_ty(),\n                 goal_kind,\n-            )? else {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n-        };\n+            )? {\n+                Some(a) => a,\n+                None => {\n+                    return ecx\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+            };\n         let output_is_sized_pred = tupled_inputs_and_output\n             .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n \n@@ -247,7 +248,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if let ty::Tuple(..) = goal.predicate.self_ty().kind() {\n-            ecx.make_canonical_response(Certainty::Yes)\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n@@ -257,7 +258,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         _goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_future_candidate(\n@@ -277,7 +278,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         // Async generator unconditionally implement `Future`\n         // Technically, we need to check that the future output type is Sized,\n         // but that's already proven by the generator being WF.\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_generator_candidate(\n@@ -317,7 +318,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let a_ty = goal.predicate.self_ty();\n         let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n         if b_ty.is_ty_var() {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+            return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n         ecx.probe(|ecx| {\n             match (a_ty.kind(), b_ty.kind()) {\n@@ -326,7 +327,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Dyn upcasting is handled separately, since due to upcasting,\n                     // when there are two supertraits that differ by substs, we\n                     // may return more than one query response.\n-                    return Err(NoSolution);\n+                    Err(NoSolution)\n                 }\n                 // `T` -> `dyn Trait` unsizing\n                 (_, &ty::Dynamic(data, region, ty::Dyn)) => {\n@@ -341,29 +342,26 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     let Some(sized_def_id) = tcx.lang_items().sized_trait() else {\n                         return Err(NoSolution);\n                     };\n-                    let nested_goals: Vec<_> = data\n-                        .iter()\n-                        // Check that the type implements all of the predicates of the def-id.\n-                        // (i.e. the principal, all of the associated types match, and any auto traits)\n-                        .map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty)))\n-                        .chain([\n-                            // The type must be Sized to be unsized.\n-                            goal.with(\n-                                tcx,\n-                                ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty])),\n-                            ),\n-                            // The type must outlive the lifetime of the `dyn` we're unsizing into.\n-                            goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region))),\n-                        ])\n-                        .collect();\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    // Check that the type implements all of the predicates of the def-id.\n+                    // (i.e. the principal, all of the associated types match, and any auto traits)\n+                    ecx.add_goals(\n+                        data.iter().map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty))),\n+                    );\n+                    // The type must be Sized to be unsized.\n+                    ecx.add_goal(\n+                        goal.with(tcx, ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty]))),\n+                    );\n+                    // The type must outlive the lifetime of the `dyn` we're unsizing into.\n+                    ecx.add_goal(\n+                        goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region))),\n+                    );\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // `[T; n]` -> `[T]` unsizing\n                 (&ty::Array(a_elem_ty, ..), &ty::Slice(b_elem_ty)) => {\n                     // We just require that the element type stays the same\n-                    let nested_goals = ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // Struct unsizing `Struct<T>` -> `Struct<U>` where `T: Unsize<U>`\n                 (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n@@ -397,15 +395,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n                     // Finally, we require that `TailA: Unsize<TailB>` for the tail field\n                     // types.\n-                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n-                    nested_goals.push(goal.with(\n+                    ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    ecx.add_goal(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n                             tcx.mk_trait_ref(goal.predicate.def_id(), [a_tail_ty, b_tail_ty]),\n                         ),\n                     ));\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // Tuple unsizing `(.., T)` -> `(.., U)` where `T: Unsize<U>`\n                 (&ty::Tuple(a_tys), &ty::Tuple(b_tys))\n@@ -417,17 +414,16 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Substitute just the tail field of B., and require that they're equal.\n                     let unsized_a_ty =\n                         tcx.mk_tup_from_iter(a_rest_tys.iter().chain([b_last_ty]).copied());\n-                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n \n                     // Similar to ADTs, require that the rest of the fields are equal.\n-                    nested_goals.push(goal.with(\n+                    ecx.add_goal(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n                             tcx.mk_trait_ref(goal.predicate.def_id(), [*a_last_ty, *b_last_ty]),\n                         ),\n                     ));\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 _ => Err(NoSolution),\n             }\n@@ -477,12 +473,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n \n                 // We also require that A's lifetime outlives B's lifetime.\n-                let mut nested_obligations = ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n-                nested_obligations.push(\n+                ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n+                ecx.add_goal(\n                     goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))),\n                 );\n-\n-                ecx.evaluate_all_and_make_canonical_response(nested_obligations)\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         };\n \n@@ -516,7 +511,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         _goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         // `DiscriminantKind` is automatically implemented for every type.\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n }\n \n@@ -530,21 +525,23 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n         constituent_tys: impl Fn(&EvalCtxt<'_, 'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n     ) -> QueryResult<'tcx> {\n-        self.probe(|this| {\n-            this.evaluate_all_and_make_canonical_response(\n-                constituent_tys(this, goal.predicate.self_ty())?\n+        self.probe(|ecx| {\n+            ecx.add_goals(\n+                constituent_tys(ecx, goal.predicate.self_ty())?\n                     .into_iter()\n                     .map(|ty| {\n                         goal.with(\n-                            this.tcx(),\n-                            ty::Binder::dummy(goal.predicate.with_self_ty(this.tcx(), ty)),\n+                            ecx.tcx(),\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(ecx.tcx(), ty)),\n                         )\n                     })\n-                    .collect(),\n-            )\n+                    .collect::<Vec<_>>(),\n+            );\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn compute_trait_goal(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,"}, {"sha": "871e7c2cc5ac139d62caaa4188d0093460f36f7c", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -333,7 +333,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReplaceProjectionWith<'_, 'tcx> {\n             // FIXME: Technically this folder could be fallible?\n             let nested = self\n                 .ecx\n-                .eq(self.param_env, alias_ty, proj.projection_ty)\n+                .eq_and_get_goals(self.param_env, alias_ty, proj.projection_ty)\n                 .expect(\"expected to be able to unify goal projection with dyn's projection\");\n             // FIXME: Technically we could register these too..\n             assert!(nested.is_empty(), \"did not expect unification to have any nested goals\");"}, {"sha": "038f8964471f5c8f2190b93df6b15beacb46709f", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -17,10 +17,10 @@ use rustc_errors::{DelayDm, FatalError, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n-use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::{\n     self, EarlyBinder, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n+use rustc_middle::ty::{ToPredicate, TypeVisitableExt};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -139,6 +139,10 @@ fn object_safety_violations_for_trait(\n     if !spans.is_empty() {\n         violations.push(ObjectSafetyViolation::SupertraitSelf(spans));\n     }\n+    let spans = super_predicates_have_non_lifetime_binders(tcx, trait_def_id);\n+    if !spans.is_empty() {\n+        violations.push(ObjectSafetyViolation::SupertraitNonLifetimeBinder(spans));\n+    }\n \n     violations.extend(\n         tcx.associated_items(trait_def_id)\n@@ -348,6 +352,21 @@ fn predicate_references_self<'tcx>(\n     }\n }\n \n+fn super_predicates_have_non_lifetime_binders(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: DefId,\n+) -> SmallVec<[Span; 1]> {\n+    // If non_lifetime_binders is disabled, then exit early\n+    if !tcx.features().non_lifetime_binders {\n+        return SmallVec::new();\n+    }\n+    tcx.super_predicates_of(trait_def_id)\n+        .predicates\n+        .iter()\n+        .filter_map(|(pred, span)| pred.has_non_region_late_bound().then_some(*span))\n+        .collect()\n+}\n+\n fn trait_has_sized_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n     generics_require_sized_self(tcx, trait_def_id)\n }"}, {"sha": "f53952d25fadd62aac5a7a9f0272def027208fe6", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -7,7 +7,10 @@ use rustc_middle::ty::{\n     TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use rustc_session::config::TraitSolver;\n-use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_span::{\n+    def_id::{DefId, CRATE_DEF_ID},\n+    DUMMY_SP,\n+};\n use rustc_trait_selection::traits;\n \n fn sized_constraint_for_ty<'tcx>(\n@@ -275,16 +278,22 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n-        if let ty::Alias(ty::Projection, alias_ty) = *ty.kind()\n-            && self.tcx.is_impl_trait_in_trait(alias_ty.def_id)\n-            && self.tcx.impl_trait_in_trait_parent_fn(alias_ty.def_id) == self.fn_def_id\n-            && self.seen.insert(alias_ty.def_id)\n+        if let ty::Alias(ty::Projection, unshifted_alias_ty) = *ty.kind()\n+            && self.tcx.is_impl_trait_in_trait(unshifted_alias_ty.def_id)\n+            && self.tcx.impl_trait_in_trait_parent_fn(unshifted_alias_ty.def_id) == self.fn_def_id\n+            && self.seen.insert(unshifted_alias_ty.def_id)\n         {\n             // We have entered some binders as we've walked into the\n             // bounds of the RPITIT. Shift these binders back out when\n             // constructing the top-level projection predicate.\n-            let alias_ty = self.tcx.fold_regions(alias_ty, |re, _| {\n+            let shifted_alias_ty = self.tcx.fold_regions(unshifted_alias_ty, |re, depth| {\n                 if let ty::ReLateBound(index, bv) = re.kind() {\n+                    if depth != ty::INNERMOST {\n+                        return self.tcx.mk_re_error_with_message(\n+                            DUMMY_SP,\n+                            \"we shouldn't walk non-predicate binders with `impl Trait`...\",\n+                        );\n+                    }\n                     self.tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n                 } else {\n                     re\n@@ -295,26 +304,27 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n             // the `type_of` of the trait's associated item. If we're using the old lowering\n             // strategy, then just reinterpret the associated type like an opaque :^)\n             let default_ty = if self.tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n-                self\n-                    .tcx\n-                    .type_of(alias_ty.def_id)\n-                    .subst(self.tcx, alias_ty.substs)\n+                self.tcx.type_of(shifted_alias_ty.def_id).subst(self.tcx, shifted_alias_ty.substs)\n             } else {\n-                self.tcx.mk_alias(ty::Opaque, alias_ty)\n+                self.tcx.mk_alias(ty::Opaque, shifted_alias_ty)\n             };\n \n             self.predicates.push(\n                 ty::Binder::bind_with_vars(\n-                    ty::ProjectionPredicate {\n-                        projection_ty: alias_ty,\n-                        term: default_ty.into(),\n-                    },\n+                    ty::ProjectionPredicate { projection_ty: shifted_alias_ty, term: default_ty.into() },\n                     self.bound_vars,\n                 )\n                 .to_predicate(self.tcx),\n             );\n \n-            for bound in self.tcx.item_bounds(alias_ty.def_id).subst_iter(self.tcx, alias_ty.substs)\n+            // We walk the *un-shifted* alias ty, because we're tracking the de bruijn\n+            // binder depth, and if we were to walk `shifted_alias_ty` instead, we'd\n+            // have to reset `self.depth` back to `ty::INNERMOST` or something. It's\n+            // easier to just do this.\n+            for bound in self\n+                .tcx\n+                .item_bounds(unshifted_alias_ty.def_id)\n+                .subst_iter(self.tcx, unshifted_alias_ty.substs)\n             {\n                 bound.visit_with(self);\n             }"}, {"sha": "32eab76b3695909d16f01126dd867322e1ba6740", "filename": "config.example.toml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/config.example.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/config.example.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.example.toml?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -806,3 +806,9 @@ changelog-seen = 2\n #\n # This list must be non-empty.\n #compression-formats = [\"gz\", \"xz\"]\n+\n+# How much time should be spent compressing the tarballs. The better the\n+# compression profile, the longer compression will take.\n+#\n+# Available options: fast, balanced, best\n+#compression-profile = \"fast\""}, {"sha": "f9c7eb8f9383e24a7e5f50717fd396de866c32bd", "filename": "library/core/src/iter/traits/accum.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -164,12 +164,13 @@ where\n     /// element is encountered:\n     ///\n     /// ```\n+    /// let f = |&x: &i32| if x < 0 { Err(\"Negative element found\") } else { Ok(x) };\n     /// let v = vec![1, 2];\n-    /// let res: Result<i32, &'static str> = v.iter().map(|&x: &i32|\n-    ///     if x < 0 { Err(\"Negative element found\") }\n-    ///     else { Ok(x) }\n-    /// ).sum();\n+    /// let res: Result<i32, _> = v.iter().map(f).sum();\n     /// assert_eq!(res, Ok(3));\n+    /// let v = vec![1, -2];\n+    /// let res: Result<i32, _> = v.iter().map(f).sum();\n+    /// assert_eq!(res, Err(\"Negative element found\"));\n     /// ```\n     fn sum<I>(iter: I) -> Result<T, E>\n     where\n@@ -187,6 +188,20 @@ where\n     /// Takes each element in the [`Iterator`]: if it is an [`Err`], no further\n     /// elements are taken, and the [`Err`] is returned. Should no [`Err`]\n     /// occur, the product of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This multiplies each number in a vector of strings,\n+    /// if a string could not be parsed the operation returns `Err`:\n+    ///\n+    /// ```\n+    /// let nums = vec![\"5\", \"10\", \"1\", \"2\"];\n+    /// let total: Result<usize, _> = nums.iter().map(|w| w.parse::<usize>()).product();\n+    /// assert_eq!(total, Ok(100));\n+    /// let nums = vec![\"5\", \"10\", \"one\", \"2\"];\n+    /// let total: Result<usize, _> = nums.iter().map(|w| w.parse::<usize>()).product();\n+    /// assert!(total.is_err());\n+    /// ```\n     fn product<I>(iter: I) -> Result<T, E>\n     where\n         I: Iterator<Item = Result<U, E>>,\n@@ -213,6 +228,9 @@ where\n     /// let words = vec![\"have\", \"a\", \"great\", \"day\"];\n     /// let total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\n     /// assert_eq!(total, Some(5));\n+    /// let words = vec![\"have\", \"a\", \"good\", \"day\"];\n+    /// let total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\n+    /// assert_eq!(total, None);\n     /// ```\n     fn sum<I>(iter: I) -> Option<T>\n     where\n@@ -230,6 +248,20 @@ where\n     /// Takes each element in the [`Iterator`]: if it is a [`None`], no further\n     /// elements are taken, and the [`None`] is returned. Should no [`None`]\n     /// occur, the product of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This multiplies each number in a vector of strings,\n+    /// if a string could not be parsed the operation returns `None`:\n+    ///\n+    /// ```\n+    /// let nums = vec![\"5\", \"10\", \"1\", \"2\"];\n+    /// let total: Option<usize> = nums.iter().map(|w| w.parse::<usize>().ok()).product();\n+    /// assert_eq!(total, Some(100));\n+    /// let nums = vec![\"5\", \"10\", \"one\", \"2\"];\n+    /// let total: Option<usize> = nums.iter().map(|w| w.parse::<usize>().ok()).product();\n+    /// assert_eq!(total, None);\n+    /// ```\n     fn product<I>(iter: I) -> Option<T>\n     where\n         I: Iterator<Item = Option<U>>,"}, {"sha": "16c9f668b8ea8602768e3e915cbd6410153d67af", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -3448,6 +3448,9 @@ pub trait Iterator {\n     ///\n     /// An empty iterator returns the zero value of the type.\n     ///\n+    /// `sum()` can be used to sum any type implementing [`Sum`][`core::iter::Sum`],\n+    /// including [`Option`][`Option::sum`] and [`Result`][`Result::sum`].\n+    ///\n     /// # Panics\n     ///\n     /// When calling `sum()` and a primitive integer type is being returned, this\n@@ -3478,6 +3481,9 @@ pub trait Iterator {\n     ///\n     /// An empty iterator returns the one value of the type.\n     ///\n+    /// `product()` can be used to multiply any type implementing [`Product`][`core::iter::Product`],\n+    /// including [`Option`][`Option::product`] and [`Result`][`Result::product`].\n+    ///\n     /// # Panics\n     ///\n     /// When calling `product()` and a primitive integer type is being returned,"}, {"sha": "401def1845827d84186941851ef9a70a62d592d7", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -2,7 +2,8 @@ use crate::io::prelude::*;\n \n use crate::env;\n use crate::fs::{self, File, OpenOptions};\n-use crate::io::{ErrorKind, SeekFrom};\n+use crate::io::{BorrowedBuf, ErrorKind, SeekFrom};\n+use crate::mem::MaybeUninit;\n use crate::path::Path;\n use crate::str;\n use crate::sync::Arc;\n@@ -401,6 +402,23 @@ fn file_test_io_seek_read_write() {\n     check!(fs::remove_file(&filename));\n }\n \n+#[test]\n+fn file_test_read_buf() {\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"test\");\n+    check!(fs::write(filename, &[1, 2, 3, 4]));\n+\n+    let mut buf: [MaybeUninit<u8>; 128] = MaybeUninit::uninit_array();\n+    let mut buf = BorrowedBuf::from(buf.as_mut_slice());\n+    let mut file = check!(File::open(filename));\n+    check!(file.read_buf(buf.unfilled()));\n+    assert_eq!(buf.filled(), &[1, 2, 3, 4]);\n+    // File::read_buf should omit buffer initialization.\n+    assert_eq!(buf.init_len(), 4);\n+\n+    check!(fs::remove_file(filename));\n+}\n+\n #[test]\n fn file_test_stat_is_correct_on_is_file() {\n     let tmpdir = tmpdir();"}, {"sha": "0455a00956e6fa5345e3e20ea1217a13d66d6c47", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -8,7 +8,7 @@ use crate::io::prelude::*;\n use crate::cell::{Cell, RefCell};\n use crate::fmt;\n use crate::fs::File;\n-use crate::io::{self, BufReader, IoSlice, IoSliceMut, LineWriter, Lines};\n+use crate::io::{self, BorrowedCursor, BufReader, IoSlice, IoSliceMut, LineWriter, Lines};\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Arc, Mutex, MutexGuard, OnceLock, ReentrantMutex, ReentrantMutexGuard};\n use crate::sys::stdio;\n@@ -97,6 +97,10 @@ impl Read for StdinRaw {\n         handle_ebadf(self.0.read(buf), 0)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        handle_ebadf(self.0.read_buf(buf), ())\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         handle_ebadf(self.0.read_vectored(bufs), 0)\n     }\n@@ -418,6 +422,9 @@ impl Read for Stdin {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.lock().read(buf)\n     }\n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.lock().read_buf(buf)\n+    }\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.lock().read_vectored(bufs)\n     }\n@@ -450,6 +457,10 @@ impl Read for StdinLock<'_> {\n         self.inner.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }"}, {"sha": "3982d3636614e4a4ba1bf0e303b9d0d91fc76729", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -6,7 +6,7 @@ mod tests;\n use crate::io::prelude::*;\n \n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::iter::FusedIterator;\n use crate::net::{Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n@@ -619,6 +619,10 @@ impl Read for TcpStream {\n         self.0.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n     }\n@@ -653,6 +657,10 @@ impl Read for &TcpStream {\n         self.0.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n     }"}, {"sha": "7a3c66e450456ff554c911822ba3f957592bbc61", "filename": "library/std/src/net/tcp/tests.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,6 +1,7 @@\n use crate::fmt;\n use crate::io::prelude::*;\n-use crate::io::{ErrorKind, IoSlice, IoSliceMut};\n+use crate::io::{BorrowedBuf, ErrorKind, IoSlice, IoSliceMut};\n+use crate::mem::MaybeUninit;\n use crate::net::test::{next_test_ip4, next_test_ip6};\n use crate::net::*;\n use crate::sync::mpsc::channel;\n@@ -279,6 +280,31 @@ fn partial_read() {\n     })\n }\n \n+#[test]\n+fn read_buf() {\n+    each_ip(&mut |addr| {\n+        let srv = t!(TcpListener::bind(&addr));\n+        let t = thread::spawn(move || {\n+            let mut s = t!(TcpStream::connect(&addr));\n+            s.write_all(&[1, 2, 3, 4]).unwrap();\n+        });\n+\n+        let mut s = t!(srv.accept()).0;\n+        let mut buf: [MaybeUninit<u8>; 128] = MaybeUninit::uninit_array();\n+        let mut buf = BorrowedBuf::from(buf.as_mut_slice());\n+        t!(s.read_buf(buf.unfilled()));\n+        assert_eq!(buf.filled(), &[1, 2, 3, 4]);\n+\n+        // FIXME: sgx uses default_read_buf that initializes the buffer.\n+        if cfg!(not(target_env = \"sgx\")) {\n+            // TcpStream::read_buf should omit buffer initialization.\n+            assert_eq!(buf.init_len(), 4);\n+        }\n+\n+        t.join().ok().expect(\"thread panicked\");\n+    })\n+}\n+\n #[test]\n fn read_vectored() {\n     each_ip(&mut |addr| {"}, {"sha": "80d73084c4f01091f6868101f8379e1b8ab6c742", "filename": "library/std/src/process.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -110,7 +110,7 @@ use crate::convert::Infallible;\n use crate::ffi::OsStr;\n use crate::fmt;\n use crate::fs;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::num::NonZeroI32;\n use crate::path::Path;\n use crate::str;\n@@ -354,6 +354,10 @@ impl Read for ChildStdout {\n         self.inner.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }\n@@ -419,6 +423,10 @@ impl Read for ChildStderr {\n         self.inner.read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }"}, {"sha": "d7f4d335de3e334f7b8bcf25bbf01968a1240e96", "filename": "library/std/src/process/tests.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,7 +1,8 @@\n use crate::io::prelude::*;\n \n use super::{Command, Output, Stdio};\n-use crate::io::ErrorKind;\n+use crate::io::{BorrowedBuf, ErrorKind};\n+use crate::mem::MaybeUninit;\n use crate::str;\n \n fn known_command() -> Command {\n@@ -119,6 +120,37 @@ fn stdin_works() {\n     assert_eq!(out, \"foobar\\n\");\n }\n \n+#[test]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n+fn child_stdout_read_buf() {\n+    let mut cmd = if cfg!(target_os = \"windows\") {\n+        let mut cmd = Command::new(\"cmd\");\n+        cmd.arg(\"/C\").arg(\"echo abc\");\n+        cmd\n+    } else {\n+        let mut cmd = shell_cmd();\n+        cmd.arg(\"-c\").arg(\"echo abc\");\n+        cmd\n+    };\n+    cmd.stdin(Stdio::null());\n+    cmd.stdout(Stdio::piped());\n+    let child = cmd.spawn().unwrap();\n+\n+    let mut stdout = child.stdout.unwrap();\n+    let mut buf: [MaybeUninit<u8>; 128] = MaybeUninit::uninit_array();\n+    let mut buf = BorrowedBuf::from(buf.as_mut_slice());\n+    stdout.read_buf(buf.unfilled()).unwrap();\n+\n+    // ChildStdout::read_buf should omit buffer initialization.\n+    if cfg!(target_os = \"windows\") {\n+        assert_eq!(buf.filled(), b\"abc\\r\\n\");\n+        assert_eq!(buf.init_len(), 5);\n+    } else {\n+        assert_eq!(buf.filled(), b\"abc\\n\");\n+        assert_eq!(buf.init_len(), 4);\n+    };\n+}\n+\n #[test]\n #[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn test_process_status() {"}, {"sha": "0c02a107691c89fe2fea710c313b0696f2814c87", "filename": "library/std/src/sys/sgx/fd.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffd.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,7 +1,7 @@\n use fortanix_sgx_abi::Fd;\n \n use super::abi::usercalls;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::sys::{AsInner, FromInner, IntoInner};\n \n@@ -30,6 +30,10 @@ impl FileDesc {\n         usercalls::read(self.fd, &mut [IoSliceMut::new(buf)])\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        crate::io::default_read_buf(|b| self.read(b), buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         usercalls::read(self.fd, bufs)\n     }"}, {"sha": "923be5eb944ec09d1d1ba1b4aa0f272090643688", "filename": "library/std/src/sys/sgx/net.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,6 +1,6 @@\n use crate::error;\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sync::Arc;\n use crate::sys::fd::FileDesc;\n@@ -144,6 +144,10 @@ impl TcpStream {\n         self.inner.inner.read(buf)\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.inner.read_buf(buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.inner.read_vectored(bufs)\n     }"}, {"sha": "ce5c048f252a1572deeda25680314173ba808c0d", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -469,6 +469,15 @@ impl<'a> Read for &'a FileDesc {\n     fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         (**self).read_buf(cursor)\n     }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        (**self).read_vectored(bufs)\n+    }\n+\n+    #[inline]\n+    fn is_read_vectored(&self) -> bool {\n+        (**self).is_read_vectored()\n+    }\n }\n \n impl AsInner<OwnedFd> for FileDesc {"}, {"sha": "f84240d268fec3e3620f693346db6751a8bcc7d8", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,6 +1,6 @@\n use crate::cmp;\n use crate::ffi::CStr;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedBuf, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::net::{Shutdown, SocketAddr};\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n@@ -242,19 +242,35 @@ impl Socket {\n         self.0.duplicate().map(Socket)\n     }\n \n-    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n+    fn recv_with_flags(&self, mut buf: BorrowedCursor<'_>, flags: c_int) -> io::Result<()> {\n         let ret = cvt(unsafe {\n-            libc::recv(self.as_raw_fd(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n+            libc::recv(\n+                self.as_raw_fd(),\n+                buf.as_mut().as_mut_ptr() as *mut c_void,\n+                buf.capacity(),\n+                flags,\n+            )\n         })?;\n-        Ok(ret as usize)\n+        unsafe {\n+            buf.advance(ret as usize);\n+        }\n+        Ok(())\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, 0)\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), 0)?;\n+        Ok(buf.len())\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, MSG_PEEK)\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), MSG_PEEK)?;\n+        Ok(buf.len())\n+    }\n+\n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.recv_with_flags(buf, 0)\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {"}, {"sha": "dc17c9fac460a8dd3f0443623e167169614cb1fd", "filename": "library/std/src/sys/unix/pipe.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpipe.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,4 +1,4 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n use crate::sys::fd::FileDesc;\n@@ -49,6 +49,10 @@ impl AnonPipe {\n         self.0.read(buf)\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0.read_buf(buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n     }"}, {"sha": "a26f20795a191eeb40a07d11fbff6e2bba186b3a", "filename": "library/std/src/sys/unix/stdio.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,4 +1,4 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::mem::ManuallyDrop;\n use crate::os::unix::io::FromRawFd;\n use crate::sys::fd::FileDesc;\n@@ -18,6 +18,10 @@ impl io::Read for Stdin {\n         unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read(buf) }\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read_buf(buf) }\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read_vectored(bufs) }\n     }"}, {"sha": "bbc52703f96322dffa18097a8743ee72775e60c3", "filename": "library/std/src/sys/unsupported/net.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,5 +1,5 @@\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::sys::unsupported;\n use crate::time::Duration;\n@@ -39,6 +39,10 @@ impl TcpStream {\n         self.0\n     }\n \n+    pub fn read_buf(&self, _buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0\n+    }\n+\n     pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0\n     }"}, {"sha": "d7d8f297ae586aecd61fd18088c3596adcf54a9e", "filename": "library/std/src/sys/unsupported/pipe.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpipe.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,4 +1,4 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n \n pub struct AnonPipe(!);\n \n@@ -7,6 +7,10 @@ impl AnonPipe {\n         self.0\n     }\n \n+    pub fn read_buf(&self, _buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0\n+    }\n+\n     pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0\n     }"}, {"sha": "191db4b60f72a690b58c6ee36acd0efcab630168", "filename": "library/std/src/sys/wasi/fd.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -2,7 +2,7 @@\n #![allow(dead_code)]\n \n use super::err2io;\n-use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::net::Shutdown;\n use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n@@ -46,6 +46,22 @@ impl WasiFd {\n         unsafe { wasi::fd_read(self.as_raw_fd() as wasi::Fd, iovec(bufs)).map_err(err2io) }\n     }\n \n+    pub fn read_buf(&self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        unsafe {\n+            let bufs = [wasi::Iovec {\n+                buf: buf.as_mut().as_mut_ptr() as *mut u8,\n+                buf_len: buf.capacity(),\n+            }];\n+            match wasi::fd_read(self.as_raw_fd() as wasi::Fd, &bufs) {\n+                Ok(n) => {\n+                    buf.advance(n);\n+                    Ok(())\n+                }\n+                Err(e) => Err(err2io(e)),\n+            }\n+        }\n+    }\n+\n     pub fn write(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         unsafe { wasi::fd_write(self.as_raw_fd() as wasi::Fd, ciovec(bufs)).map_err(err2io) }\n     }"}, {"sha": "3a205267e34689b88671cfadcdef653225641fdc", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -441,7 +441,7 @@ impl File {\n     }\n \n     pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n-        crate::io::default_read_buf(|buf| self.read(buf), cursor)\n+        self.fd.read_buf(cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "59d94a3686dc513e94370cb2ecaa74a2c0b0ba66", "filename": "library/std/src/sys/wasi/net.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -3,7 +3,7 @@\n use super::err2io;\n use super::fd::WasiFd;\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n use crate::sys::unsupported;\n@@ -91,6 +91,10 @@ impl TcpStream {\n         self.read_vectored(&mut [IoSliceMut::new(buf)])\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.socket().as_inner().read_buf(buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.socket().as_inner().read(bufs)\n     }"}, {"sha": "b290f4070e8fdb766adc3b0097906fa5d328cda8", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -327,7 +327,16 @@ impl<'a> Read for &'a Handle {\n         (**self).read(buf)\n     }\n \n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        (**self).read_buf(buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         (**self).read_vectored(bufs)\n     }\n+\n+    #[inline]\n+    fn is_read_vectored(&self) -> bool {\n+        (**self).is_read_vectored()\n+    }\n }"}, {"sha": "ee1f5482b47eedb420be2ccb3dbbb5ca080a248c", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,7 +1,7 @@\n #![unstable(issue = \"none\", feature = \"windows_net\")]\n \n use crate::cmp;\n-use crate::io::{self, IoSlice, IoSliceMut, Read};\n+use crate::io::{self, BorrowedBuf, BorrowedCursor, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::net::{Shutdown, SocketAddr};\n use crate::os::windows::io::{\n@@ -214,28 +214,38 @@ impl Socket {\n         Ok(Self(self.0.try_clone()?))\n     }\n \n-    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n+    fn recv_with_flags(&self, mut buf: BorrowedCursor<'_>, flags: c_int) -> io::Result<()> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        let length = cmp::min(buf.len(), i32::MAX as usize) as i32;\n-        let result =\n-            unsafe { c::recv(self.as_raw_socket(), buf.as_mut_ptr() as *mut _, length, flags) };\n+        let length = cmp::min(buf.capacity(), i32::MAX as usize) as i32;\n+        let result = unsafe {\n+            c::recv(self.as_raw_socket(), buf.as_mut().as_mut_ptr() as *mut _, length, flags)\n+        };\n \n         match result {\n             c::SOCKET_ERROR => {\n                 let error = unsafe { c::WSAGetLastError() };\n \n                 if error == c::WSAESHUTDOWN {\n-                    Ok(0)\n+                    Ok(())\n                 } else {\n                     Err(io::Error::from_raw_os_error(error))\n                 }\n             }\n-            _ => Ok(result as usize),\n+            _ => {\n+                unsafe { buf.advance(result as usize) };\n+                Ok(())\n+            }\n         }\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), 0)?;\n+        Ok(buf.len())\n+    }\n+\n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n         self.recv_with_flags(buf, 0)\n     }\n \n@@ -277,7 +287,9 @@ impl Socket {\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, c::MSG_PEEK)\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), c::MSG_PEEK)?;\n+        Ok(buf.len())\n     }\n \n     fn recv_from_with_flags("}, {"sha": "0780b29584da40f11c285dbf2540b88977993295", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,7 +1,7 @@\n use crate::os::windows::prelude::*;\n \n use crate::ffi::OsStr;\n-use crate::io::{self, IoSlice, IoSliceMut, Read};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::path::Path;\n use crate::ptr;\n@@ -252,6 +252,28 @@ impl AnonPipe {\n         }\n     }\n \n+    pub fn read_buf(&self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        let result = unsafe {\n+            let len = crate::cmp::min(buf.capacity(), c::DWORD::MAX as usize) as c::DWORD;\n+            self.alertable_io_internal(c::ReadFileEx, buf.as_mut().as_mut_ptr() as _, len)\n+        };\n+\n+        match result {\n+            // The special treatment of BrokenPipe is to deal with Windows\n+            // pipe semantics, which yields this error when *reading* from\n+            // a pipe after the other end has closed; we interpret that as\n+            // EOF on the pipe.\n+            Err(ref e) if e.kind() == io::ErrorKind::BrokenPipe => Ok(()),\n+            Err(e) => Err(e),\n+            Ok(n) => {\n+                unsafe {\n+                    buf.advance(n);\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }"}, {"sha": "eb427dbda2393253e495e0ef3548f8309a1ddd17", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -4,7 +4,7 @@ mod tests;\n use crate::cmp;\n use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n+use crate::io::{self, BorrowedCursor, ErrorKind, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::ptr;\n@@ -272,6 +272,10 @@ impl TcpStream {\n         self.inner.read(buf)\n     }\n \n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(buf)\n+    }\n+\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.inner.read_vectored(bufs)\n     }"}, {"sha": "d2c046c39798935b178bd6d79d017ab642be8df5", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -191,6 +191,7 @@ pub struct Config {\n     pub dist_sign_folder: Option<PathBuf>,\n     pub dist_upload_addr: Option<String>,\n     pub dist_compression_formats: Option<Vec<String>>,\n+    pub dist_compression_profile: String,\n     pub dist_include_mingw_linker: bool,\n \n     // libstd features\n@@ -703,6 +704,7 @@ define_config! {\n         src_tarball: Option<bool> = \"src-tarball\",\n         missing_tools: Option<bool> = \"missing-tools\",\n         compression_formats: Option<Vec<String>> = \"compression-formats\",\n+        compression_profile: Option<String> = \"compression-profile\",\n         include_mingw_linker: Option<bool> = \"include-mingw-linker\",\n     }\n }\n@@ -821,6 +823,7 @@ impl Config {\n         config.deny_warnings = true;\n         config.bindir = \"bin\".into();\n         config.dist_include_mingw_linker = true;\n+        config.dist_compression_profile = \"fast\".into();\n \n         // set by build.rs\n         config.build = TargetSelection::from_user(&env!(\"BUILD_TRIPLE\"));\n@@ -1308,6 +1311,7 @@ impl Config {\n             config.dist_sign_folder = t.sign_folder.map(PathBuf::from);\n             config.dist_upload_addr = t.upload_addr;\n             config.dist_compression_formats = t.compression_formats;\n+            set(&mut config.dist_compression_profile, t.compression_profile);\n             set(&mut config.rust_dist_src, t.src_tarball);\n             set(&mut config.missing_tools, t.missing_tools);\n             set(&mut config.dist_include_mingw_linker, t.include_mingw_linker)"}, {"sha": "ee271c3fb519dc58a4278360a3f42ee3f7f43ed0", "filename": "src/bootstrap/defaults/config.user.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -11,3 +11,7 @@ extended = true\n [llvm]\n # Most users installing from source want to build all parts of the project from source, not just rustc itself.\n download-ci-llvm = false\n+\n+[dist]\n+# Use better compression when preparing tarballs.\n+compression-profile = \"balanced\""}, {"sha": "7fa8a4d9d7f8afdf9044ba1195bd1be2bdc8db79", "filename": "src/bootstrap/tarball.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Fbootstrap%2Ftarball.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Fbootstrap%2Ftarball.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftarball.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -318,6 +318,7 @@ impl<'a> Tarball<'a> {\n             assert!(!formats.is_empty(), \"dist.compression-formats can't be empty\");\n             cmd.arg(\"--compression-formats\").arg(formats.join(\",\"));\n         }\n+        cmd.args(&[\"--compression-profile\", &self.builder.config.dist_compression_profile]);\n         self.builder.run(&mut cmd);\n \n         // Ensure there are no symbolic links in the tarball. In particular,"}, {"sha": "8ca22d6e68fd45abe5cea57d6f77e22770a1d825", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -58,6 +58,7 @@ RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-manage-submodules\"\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-locked-deps\"\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-cargo-native-static\"\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.codegen-units-std=1\"\n+RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set dist.compression-profile=best\"\n \n # Only produce xz tarballs on CI. gz tarballs will be generated by the release\n # process by recompressing the existing xz ones. This decreases the storage"}, {"sha": "abcf59cfe36cd39372b6ca1490aeb60fcf5e75ba", "filename": "src/tools/rust-installer/src/combiner.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,7 +1,7 @@\n use super::Scripter;\n use super::Tarballer;\n use crate::{\n-    compression::{CompressionFormat, CompressionFormats},\n+    compression::{CompressionFormat, CompressionFormats, CompressionProfile},\n     util::*,\n };\n use anyhow::{bail, Context, Result};\n@@ -48,6 +48,10 @@ actor! {\n         #[clap(value_name = \"DIR\")]\n         output_dir: String = \"./dist\",\n \n+        /// The profile used to compress the tarball.\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_profile: CompressionProfile,\n+\n         /// The formats used to compress the tarball\n         #[clap(value_name = \"FORMAT\", default_value_t)]\n         compression_formats: CompressionFormats,\n@@ -153,6 +157,7 @@ impl Combiner {\n             .work_dir(self.work_dir)\n             .input(self.package_name)\n             .output(path_to_str(&output)?.into())\n+            .compression_profile(self.compression_profile)\n             .compression_formats(self.compression_formats.clone());\n         tarballer.run()?;\n "}, {"sha": "510c914163c7e754b83485dee4a9328dd68a6782", "filename": "src/tools/rust-installer/src/compression.rs", "status": "modified", "additions": 93, "deletions": 43, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -4,6 +4,37 @@ use rayon::prelude::*;\n use std::{convert::TryFrom, fmt, io::Read, io::Write, path::Path, str::FromStr};\n use xz2::{read::XzDecoder, write::XzEncoder};\n \n+#[derive(Default, Debug, Copy, Clone)]\n+pub enum CompressionProfile {\n+    Fast,\n+    #[default]\n+    Balanced,\n+    Best,\n+}\n+\n+impl FromStr for CompressionProfile {\n+    type Err = Error;\n+\n+    fn from_str(input: &str) -> Result<Self, Error> {\n+        Ok(match input {\n+            \"fast\" => Self::Fast,\n+            \"balanced\" => Self::Balanced,\n+            \"best\" => Self::Best,\n+            other => anyhow::bail!(\"invalid compression profile: {other}\"),\n+        })\n+    }\n+}\n+\n+impl fmt::Display for CompressionProfile {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            CompressionProfile::Fast => f.write_str(\"fast\"),\n+            CompressionProfile::Balanced => f.write_str(\"balanced\"),\n+            CompressionProfile::Best => f.write_str(\"best\"),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone)]\n pub enum CompressionFormat {\n     Gz,\n@@ -26,7 +57,11 @@ impl CompressionFormat {\n         }\n     }\n \n-    pub(crate) fn encode(&self, path: impl AsRef<Path>) -> Result<Box<dyn Encoder>, Error> {\n+    pub(crate) fn encode(\n+        &self,\n+        path: impl AsRef<Path>,\n+        profile: CompressionProfile,\n+    ) -> Result<Box<dyn Encoder>, Error> {\n         let mut os = path.as_ref().as_os_str().to_os_string();\n         os.push(format!(\".{}\", self.extension()));\n         let path = Path::new(&os);\n@@ -37,49 +72,64 @@ impl CompressionFormat {\n         let file = crate::util::create_new_file(path)?;\n \n         Ok(match self {\n-            CompressionFormat::Gz => Box::new(GzEncoder::new(file, flate2::Compression::best())),\n+            CompressionFormat::Gz => Box::new(GzEncoder::new(\n+                file,\n+                match profile {\n+                    CompressionProfile::Fast => flate2::Compression::fast(),\n+                    CompressionProfile::Balanced => flate2::Compression::new(6),\n+                    CompressionProfile::Best => flate2::Compression::best(),\n+                },\n+            )),\n             CompressionFormat::Xz => {\n-                let mut filters = xz2::stream::Filters::new();\n-                // the preset is overridden by the other options so it doesn't matter\n-                let mut lzma_ops = xz2::stream::LzmaOptions::new_preset(9).unwrap();\n-                // This sets the overall dictionary size, which is also how much memory (baseline)\n-                // is needed for decompression.\n-                lzma_ops.dict_size(64 * 1024 * 1024);\n-                // Use the best match finder for compression ratio.\n-                lzma_ops.match_finder(xz2::stream::MatchFinder::BinaryTree4);\n-                lzma_ops.mode(xz2::stream::Mode::Normal);\n-                // Set nice len to the maximum for best compression ratio\n-                lzma_ops.nice_len(273);\n-                // Set depth to a reasonable value, 0 means auto, 1000 is somwhat high but gives\n-                // good results.\n-                lzma_ops.depth(1000);\n-                // 2 is the default and does well for most files\n-                lzma_ops.position_bits(2);\n-                // 0 is the default and does well for most files\n-                lzma_ops.literal_position_bits(0);\n-                // 3 is the default and does well for most files\n-                lzma_ops.literal_context_bits(3);\n-\n-                filters.lzma2(&lzma_ops);\n-\n-                let mut builder = xz2::stream::MtStreamBuilder::new();\n-                builder.filters(filters);\n-\n-                // On 32-bit platforms limit ourselves to 3 threads, otherwise we exceed memory\n-                // usage this process can take. In the future we'll likely only do super-fast\n-                // compression in CI and move this heavyweight processing to promote-release (which\n-                // is always 64-bit and can run on big-memory machines) but for now this lets us\n-                // move forward.\n-                if std::mem::size_of::<usize>() == 4 {\n-                    builder.threads(3);\n-                } else {\n-                    builder.threads(6);\n-                }\n-\n-                let compressor = XzEncoder::new_stream(\n-                    std::io::BufWriter::new(file),\n-                    builder.encoder().unwrap(),\n-                );\n+                let encoder = match profile {\n+                    CompressionProfile::Fast => {\n+                        xz2::stream::MtStreamBuilder::new().threads(6).preset(1).encoder().unwrap()\n+                    }\n+                    CompressionProfile::Balanced => {\n+                        xz2::stream::MtStreamBuilder::new().threads(6).preset(6).encoder().unwrap()\n+                    }\n+                    CompressionProfile::Best => {\n+                        let mut filters = xz2::stream::Filters::new();\n+                        // the preset is overridden by the other options so it doesn't matter\n+                        let mut lzma_ops = xz2::stream::LzmaOptions::new_preset(9).unwrap();\n+                        // This sets the overall dictionary size, which is also how much memory (baseline)\n+                        // is needed for decompression.\n+                        lzma_ops.dict_size(64 * 1024 * 1024);\n+                        // Use the best match finder for compression ratio.\n+                        lzma_ops.match_finder(xz2::stream::MatchFinder::BinaryTree4);\n+                        lzma_ops.mode(xz2::stream::Mode::Normal);\n+                        // Set nice len to the maximum for best compression ratio\n+                        lzma_ops.nice_len(273);\n+                        // Set depth to a reasonable value, 0 means auto, 1000 is somwhat high but gives\n+                        // good results.\n+                        lzma_ops.depth(1000);\n+                        // 2 is the default and does well for most files\n+                        lzma_ops.position_bits(2);\n+                        // 0 is the default and does well for most files\n+                        lzma_ops.literal_position_bits(0);\n+                        // 3 is the default and does well for most files\n+                        lzma_ops.literal_context_bits(3);\n+\n+                        filters.lzma2(&lzma_ops);\n+\n+                        let mut builder = xz2::stream::MtStreamBuilder::new();\n+                        builder.filters(filters);\n+\n+                        // On 32-bit platforms limit ourselves to 3 threads, otherwise we exceed memory\n+                        // usage this process can take. In the future we'll likely only do super-fast\n+                        // compression in CI and move this heavyweight processing to promote-release (which\n+                        // is always 64-bit and can run on big-memory machines) but for now this lets us\n+                        // move forward.\n+                        if std::mem::size_of::<usize>() == 4 {\n+                            builder.threads(3);\n+                        } else {\n+                            builder.threads(6);\n+                        }\n+                        builder.encoder().unwrap()\n+                    }\n+                };\n+\n+                let compressor = XzEncoder::new_stream(std::io::BufWriter::new(file), encoder);\n                 Box::new(compressor)\n             }\n         })"}, {"sha": "ddd1052599d58bff1fc353383aa413a737905b70", "filename": "src/tools/rust-installer/src/generator.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Ftools%2Frust-installer%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Ftools%2Frust-installer%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fgenerator.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -1,6 +1,6 @@\n use super::Scripter;\n use super::Tarballer;\n-use crate::compression::CompressionFormats;\n+use crate::compression::{CompressionFormats, CompressionProfile};\n use crate::util::*;\n use anyhow::{bail, format_err, Context, Result};\n use std::collections::BTreeSet;\n@@ -54,6 +54,10 @@ actor! {\n         #[clap(value_name = \"DIR\")]\n         output_dir: String = \"./dist\",\n \n+        /// The profile used to compress the tarball.\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_profile: CompressionProfile,\n+\n         /// The formats used to compress the tarball\n         #[clap(value_name = \"FORMAT\", default_value_t)]\n         compression_formats: CompressionFormats,\n@@ -113,6 +117,7 @@ impl Generator {\n             .work_dir(self.work_dir)\n             .input(self.package_name)\n             .output(path_to_str(&output)?.into())\n+            .compression_profile(self.compression_profile)\n             .compression_formats(self.compression_formats.clone());\n         tarballer.run()?;\n "}, {"sha": "592eba8f69850aa51e98fe355bc45b8a9bb40849", "filename": "src/tools/rust-installer/src/tarballer.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Ftools%2Frust-installer%2Fsrc%2Ftarballer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/src%2Ftools%2Frust-installer%2Fsrc%2Ftarballer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Ftarballer.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -6,7 +6,7 @@ use tar::{Builder, Header};\n use walkdir::WalkDir;\n \n use crate::{\n-    compression::{CombinedEncoder, CompressionFormats},\n+    compression::{CombinedEncoder, CompressionFormats, CompressionProfile},\n     util::*,\n };\n \n@@ -25,6 +25,10 @@ actor! {\n         #[clap(value_name = \"DIR\")]\n         work_dir: String = \"./workdir\",\n \n+        /// The profile used to compress the tarball.\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_profile: CompressionProfile,\n+\n         /// The formats used to compress the tarball.\n         #[clap(value_name = \"FORMAT\", default_value_t)]\n         compression_formats: CompressionFormats,\n@@ -38,7 +42,7 @@ impl Tarballer {\n         let encoder = CombinedEncoder::new(\n             self.compression_formats\n                 .iter()\n-                .map(|f| f.encode(&tarball_name))\n+                .map(|f| f.encode(&tarball_name, self.compression_profile))\n                 .collect::<Result<Vec<_>>>()?,\n         );\n "}, {"sha": "49e8c812c197a7e3a1d4296272ac50ea472a2d3b", "filename": "tests/mir-opt/building/custom/aggregate_exprs.adt.built.after.mir", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.adt.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.adt.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.adt.built.after.mir?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -0,0 +1,16 @@\n+// MIR for `adt` after built\n+\n+fn adt() -> Onion {\n+    let mut _0: Onion;                   // return place in scope 0 at $DIR/aggregate_exprs.rs:+0:13: +0:18\n+    let mut _1: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _2: Foo;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _3: Bar;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _1 = const 1_i32;                // scope 0 at $DIR/aggregate_exprs.rs:+6:13: +6:20\n+        _2 = Foo { a: const 1_i32, b: const 2_i32 }; // scope 0 at $DIR/aggregate_exprs.rs:+7:13: +10:14\n+        _3 = Bar::Foo(move _2, _1);      // scope 0 at $DIR/aggregate_exprs.rs:+11:13: +11:39\n+        _0 = Onion { neon: ((_3 as variant#0).1: i32) }; // scope 0 at $DIR/aggregate_exprs.rs:+12:13: +12:58\n+        return;                          // scope 0 at $DIR/aggregate_exprs.rs:+13:13: +13:21\n+    }\n+}"}, {"sha": "30d12897331ce87c378a08d0ff791e6b2cd0921d", "filename": "tests/mir-opt/building/custom/aggregate_exprs.array.built.after.mir", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.array.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.array.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.array.built.after.mir?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -0,0 +1,15 @@\n+// MIR for `array` after built\n+\n+fn array() -> [i32; 2] {\n+    let mut _0: [i32; 2];                // return place in scope 0 at $DIR/aggregate_exprs.rs:+0:15: +0:23\n+    let mut _1: [i32; 2];                // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _2: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _1 = [const 42_i32, const 43_i32]; // scope 0 at $DIR/aggregate_exprs.rs:+5:13: +5:25\n+        _2 = const 1_i32;                // scope 0 at $DIR/aggregate_exprs.rs:+6:13: +6:20\n+        _1 = [_2, const 2_i32];          // scope 0 at $DIR/aggregate_exprs.rs:+7:13: +7:25\n+        _0 = move _1;                    // scope 0 at $DIR/aggregate_exprs.rs:+8:13: +8:26\n+        return;                          // scope 0 at $DIR/aggregate_exprs.rs:+9:13: +9:21\n+    }\n+}"}, {"sha": "554c9c03ba4a007fe643068408c9d5de4104e406", "filename": "tests/mir-opt/building/custom/aggregate_exprs.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -0,0 +1,71 @@\n+#![feature(custom_mir, core_intrinsics)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+// EMIT_MIR aggregate_exprs.tuple.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn tuple() -> (i32, bool) {\n+    mir!(\n+        {\n+            RET = (1, true);\n+            Return()\n+        }\n+    )\n+}\n+\n+// EMIT_MIR aggregate_exprs.array.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn array() -> [i32; 2] {\n+    mir!(\n+        let x: [i32; 2];\n+        let one: i32;\n+        {\n+            x = [42, 43];\n+            one = 1;\n+            x = [one, 2];\n+            RET = Move(x);\n+            Return()\n+        }\n+    )\n+}\n+\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+enum Bar {\n+    Foo(Foo, i32),\n+}\n+\n+union Onion {\n+    neon: i32,\n+    noun: f32,\n+}\n+\n+// EMIT_MIR aggregate_exprs.adt.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn adt() -> Onion {\n+    mir!(\n+        let one: i32;\n+        let x: Foo;\n+        let y: Bar;\n+        {\n+            one = 1;\n+            x = Foo {\n+                a: 1,\n+                b: 2,\n+            };\n+            y = Bar::Foo(Move(x), one);\n+            RET = Onion { neon: Field(Variant(y, 0), 1) };\n+            Return()\n+        }\n+    )\n+}\n+\n+fn main() {\n+    assert_eq!(tuple(), (1, true));\n+    assert_eq!(array(), [1, 2]);\n+    assert_eq!(unsafe { adt().neon }, 1);\n+}"}, {"sha": "5fe45ccc90ca641663b165ba7b6d9efba34ee484", "filename": "tests/mir-opt/building/custom/aggregate_exprs.tuple.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.tuple.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.tuple.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Faggregate_exprs.tuple.built.after.mir?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `tuple` after built\n+\n+fn tuple() -> (i32, bool) {\n+    let mut _0: (i32, bool);             // return place in scope 0 at $DIR/aggregate_exprs.rs:+0:15: +0:26\n+\n+    bb0: {\n+        _0 = (const 1_i32, const true);  // scope 0 at $DIR/aggregate_exprs.rs:+3:13: +3:28\n+        return;                          // scope 0 at $DIR/aggregate_exprs.rs:+4:13: +4:21\n+    }\n+}"}, {"sha": "de82544f29338ce529f16cd6dd5e321c25a9587c", "filename": "tests/ui/impl-trait/in-trait/default-method-binder-shifting.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -13,4 +13,10 @@ trait Trait {\n     fn method(&self) -> impl Trait<Type = impl Sized + '_>;\n }\n \n+trait Trait2 {\n+    type Type;\n+\n+    fn method(&self) -> impl Trait2<Type = impl Trait2<Type = impl Sized + '_> + '_>;\n+}\n+\n fn main() {}"}, {"sha": "a635edb4485bd94425a6b5a481c7593b72e99a19", "filename": "tests/ui/traits/non_lifetime_binders/supertrait-object-safety.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.rs?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -0,0 +1,24 @@\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Foo: for<T> Bar<T> {}\n+\n+trait Bar<T: ?Sized> {\n+    fn method(&self) {}\n+}\n+\n+fn needs_bar(x: &(impl Bar<i32> + ?Sized)) {\n+    x.method();\n+}\n+\n+impl Foo for () {}\n+\n+impl<T: ?Sized> Bar<T> for () {}\n+\n+fn main() {\n+    let x: &dyn Foo = &();\n+    //~^ ERROR the trait `Foo` cannot be made into an object\n+    //~| ERROR the trait `Foo` cannot be made into an object\n+    needs_bar(x);\n+    //~^ ERROR the trait `Foo` cannot be made into an object\n+}"}, {"sha": "47fa29b66488b4ec29beada11f8439b1f8d8474c", "filename": "tests/ui/traits/non_lifetime_binders/supertrait-object-safety.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fsupertrait-object-safety.stderr?ref=a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "patch": "@@ -0,0 +1,56 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/supertrait-object-safety.rs:1:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/supertrait-object-safety.rs:19:23\n+   |\n+LL |     let x: &dyn Foo = &();\n+   |                       ^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/supertrait-object-safety.rs:4:12\n+   |\n+LL | trait Foo: for<T> Bar<T> {}\n+   |       ---  ^^^^^^^^^^^^^ ...because where clause cannot reference non-lifetime `for<...>` variables\n+   |       |\n+   |       this trait cannot be made into an object...\n+   = note: required for `&()` to implement `CoerceUnsized<&dyn Foo>`\n+   = note: required by cast to type `&dyn Foo`\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/supertrait-object-safety.rs:19:12\n+   |\n+LL |     let x: &dyn Foo = &();\n+   |            ^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/supertrait-object-safety.rs:4:12\n+   |\n+LL | trait Foo: for<T> Bar<T> {}\n+   |       ---  ^^^^^^^^^^^^^ ...because where clause cannot reference non-lifetime `for<...>` variables\n+   |       |\n+   |       this trait cannot be made into an object...\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/supertrait-object-safety.rs:22:5\n+   |\n+LL |     needs_bar(x);\n+   |     ^^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/supertrait-object-safety.rs:4:12\n+   |\n+LL | trait Foo: for<T> Bar<T> {}\n+   |       ---  ^^^^^^^^^^^^^ ...because where clause cannot reference non-lifetime `for<...>` variables\n+   |       |\n+   |       this trait cannot be made into an object...\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0038`."}]}