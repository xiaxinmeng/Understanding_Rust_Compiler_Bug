{"sha": "0d60918855aefde24ee8d72238b167ef1b09628b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNjA5MTg4NTVhZWZkZTI0ZWU4ZDcyMjM4YjE2N2VmMWIwOTYyOGI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-08T02:13:39Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-08T02:13:56Z"}, "message": "Most of the way through genericizing bind properly with new malloc path. Still getting the thunk call wrong.", "tree": {"sha": "b635665cb95aea7665a04223ec4c64135fc5cdd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b635665cb95aea7665a04223ec4c64135fc5cdd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d60918855aefde24ee8d72238b167ef1b09628b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d60918855aefde24ee8d72238b167ef1b09628b", "html_url": "https://github.com/rust-lang/rust/commit/0d60918855aefde24ee8d72238b167ef1b09628b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d60918855aefde24ee8d72238b167ef1b09628b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3473ff3bff2ed2286080812417068552d6b9df31", "url": "https://api.github.com/repos/rust-lang/rust/commits/3473ff3bff2ed2286080812417068552d6b9df31", "html_url": "https://github.com/rust-lang/rust/commit/3473ff3bff2ed2286080812417068552d6b9df31"}], "stats": {"total": 96, "additions": 56, "deletions": 40}, "files": [{"sha": "fffa325f34e356426c38a4162b8d3de407f21e34", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0d60918855aefde24ee8d72238b167ef1b09628b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d60918855aefde24ee8d72238b167ef1b09628b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0d60918855aefde24ee8d72238b167ef1b09628b", "patch": "@@ -387,6 +387,10 @@ fn T_closure_ptr(type_names tn,\n                  TypeRef lltarget_ty,\n                  TypeRef llbindings_ty,\n                  uint n_ty_params) -> TypeRef {\n+\n+    // NB: keep this in sync with code in trans_bind; we're making\n+    // an LLVM typeref structure that has the same \"shape\" as the ty.t\n+    // it constructs.\n     ret T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc(tn)),\n                                  lltarget_ty,\n                                  llbindings_ty,\n@@ -3322,7 +3326,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                     @ty.t incoming_fty,\n                     @ty.t outgoing_fty,\n                     vec[option.t[@ast.expr]] args,\n-                    TypeRef llclosure_ty,\n+                    @ty.t closure_ty,\n                     vec[@ty.t] bound_tys,\n                     uint ty_param_count) -> ValueRef {\n     // Construct a thunk-call with signature incoming_fty, and that copies\n@@ -3335,21 +3339,15 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     auto fcx = new_fn_ctxt(cx, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n \n-    auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ty);\n-\n-    auto llbody = bcx.build.GEP(llclosure,\n-                                vec(C_int(0),\n-                                    C_int(abi.box_rc_field_body)));\n-\n-    auto lltarget = bcx.build.GEP(llbody,\n-                                  vec(C_int(0),\n-                                      C_int(abi.closure_elt_target)));\n-\n-    auto llbound = bcx.build.GEP(llbody,\n-                                 vec(C_int(0),\n-                                     C_int(abi.closure_elt_bindings)));\n+    auto llclosure_ptr_ty = type_of(cx, plain_ty(ty.ty_box(closure_ty)));\n+    auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n-    auto lltargetclosure = bcx.build.GEP(lltarget,\n+    auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n+                                 vec(0,\n+                                     abi.box_rc_field_body,\n+                                     abi.closure_elt_target));\n+    bcx = lltarget.bcx;\n+    auto lltargetclosure = bcx.build.GEP(lltarget.val,\n                                          vec(C_int(0),\n                                              C_int(abi.fn_field_box)));\n     lltargetclosure = bcx.build.Load(lltargetclosure);\n@@ -3370,10 +3368,13 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     let uint i = 0u;\n     while (i < ty_param_count) {\n         auto lltyparam_ptr =\n-            bcx.build.GEP(llbody, vec(C_int(0),\n-                                      C_int(abi.closure_elt_ty_params),\n-                                      C_int(i as int)));\n-        llargs += vec(bcx.build.Load(lltyparam_ptr));\n+            GEP_tup_like(bcx, closure_ty, llclosure,\n+                         vec(0,\n+                             abi.box_rc_field_body,\n+                             abi.closure_elt_ty_params,\n+                             (i as int)));\n+        bcx = lltyparam_ptr.bcx;\n+        llargs += vec(bcx.build.Load(lltyparam_ptr.val));\n         i += 1u;\n     }\n \n@@ -3385,11 +3386,15 @@ fn trans_bind_thunk(@crate_ctxt cx,\n \n             // Arg provided at binding time; thunk copies it from closure.\n             case (some[@ast.expr](_)) {\n-                let ValueRef bound_arg = bcx.build.GEP(llbound,\n-                                                       vec(C_int(0),\n-                                                           C_int(b)));\n+                auto bound_arg =\n+                    GEP_tup_like(bcx, closure_ty, llclosure,\n+                                 vec(0,\n+                                     abi.box_rc_field_body,\n+                                     abi.closure_elt_bindings,\n+                                     b));\n                 // FIXME: possibly support passing aliases someday.\n-                llargs += bcx.build.Load(bound_arg);\n+                bcx = bound_arg.bcx;\n+                llargs += bcx.build.Load(bound_arg.val);\n                 b += 1;\n             }\n \n@@ -3412,7 +3417,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     }\n \n     // FIXME: turn this call + ret into a tail call.\n-    auto lltargetfn = bcx.build.GEP(lltarget,\n+    auto lltargetfn = bcx.build.GEP(lltarget.val,\n                                     vec(C_int(0),\n                                         C_int(abi.fn_field_code)));\n     lltargetfn = bcx.build.Load(lltargetfn);\n@@ -3479,21 +3484,26 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 i += 1u;\n             }\n \n-            // Get the type of the bound function.\n-            let TypeRef lltarget_ty = type_of(bcx.fcx.ccx, outgoing_fty);\n-\n             // Synthesize a closure type.\n             let @ty.t bindings_ty = plain_ty(ty.ty_tup(bound_tys));\n-            let TypeRef llbindings_ty = type_of(bcx.fcx.ccx, bindings_ty);\n-            let TypeRef llclosure_ty = T_closure_ptr(cx.fcx.ccx.tn,\n-                                                     lltarget_ty,\n-                                                     llbindings_ty,\n-                                                     ty_param_count);\n-\n-            // Malloc a box for the body.\n-            // FIXME: this isn't generic-safe\n-            auto r = trans_raw_malloc(bcx, llclosure_ty,\n-                llsize_of(llvm.LLVMGetElementType(llclosure_ty)));\n+\n+            // NB: keep this in sync with T_closure_ptr; we're making\n+            // a ty.t structure that has the same \"shape\" as the LLVM type\n+            // it constructs.\n+            let @ty.t tydesc_ty = plain_ty(ty.ty_type);\n+\n+            let vec[@ty.t] captured_tys =\n+                _vec.init_elt[@ty.t](tydesc_ty, ty_param_count);\n+\n+            let vec[@ty.t] closure_tys =\n+                vec(tydesc_ty,\n+                    outgoing_fty,\n+                    bindings_ty,\n+                    plain_ty(ty.ty_tup(captured_tys)));\n+\n+            let @ty.t closure_ty = plain_ty(ty.ty_tup(closure_tys));\n+\n+            auto r = trans_malloc_boxed(bcx, closure_ty);\n             auto box = r.val;\n             bcx = r.bcx;\n             auto rc = bcx.build.GEP(box,\n@@ -3561,9 +3571,10 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                                                C_int(abi.fn_field_code)));\n \n             let @ty.t pair_ty = node_ann_type(cx.fcx.ccx, ann);\n+\n             let ValueRef llthunk =\n                 trans_bind_thunk(cx.fcx.ccx, pair_ty, outgoing_fty,\n-                                 args, llclosure_ty, bound_tys,\n+                                 args, closure_ty, bound_tys,\n                                  ty_param_count);\n \n             bcx.build.Store(llthunk, pair_code);"}, {"sha": "5f44bceef4459324eedcb697524fc94d8518a02e", "filename": "src/test/run-pass/generic-bind.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d60918855aefde24ee8d72238b167ef1b09628b/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d60918855aefde24ee8d72238b167ef1b09628b/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs?ref=0d60918855aefde24ee8d72238b167ef1b09628b", "patch": "@@ -3,6 +3,11 @@ fn id[T](&T t) -> T {\n }\n \n fn main() {\n-  auto f = bind id[int](_);\n-  check (f(10) == 10);\n+  auto t = tup(1,2,3,4,5,6,7);\n+  check (t._5 == 6);\n+  // FIXME: this needs to work.\n+  // auto f0 = bind id[tup(int,int,int,int,int,int,int)](t);\n+  auto f1 = bind id[tup(int,int,int,int,int,int,int)](_);\n+  // check (f0()._5 == 6);\n+  check (f1(t)._5 == 6);\n }"}]}