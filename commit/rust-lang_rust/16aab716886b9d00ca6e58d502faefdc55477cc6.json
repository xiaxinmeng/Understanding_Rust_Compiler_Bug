{"sha": "16aab716886b9d00ca6e58d502faefdc55477cc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YWFiNzE2ODg2YjlkMDBjYTZlNThkNTAyZmFlZmRjNTU0NzdjYzY=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-12-02T16:38:31Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-12-02T16:38:31Z"}, "message": "`enum glob use` and `copies` left", "tree": {"sha": "ace5c1c3f1976ecb1d006c1dedba296adff28ca4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ace5c1c3f1976ecb1d006c1dedba296adff28ca4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16aab716886b9d00ca6e58d502faefdc55477cc6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYQaOHAAoJEFbW7qD8Z6xGUR4P/jdeJYrqQ4s2TwZzGUTvQ3co\nYDrqOLHgSiuJo88Oa1OhgO+xyA+vtfz1pYT99ZwwbEI1YVC2wMjDBopfJ+olAheo\n/xYxCsGG87rPefI2lUQGR2oQEgGQPgHlYABIHA+kSLONFIhIp8w75qbvJwopvKNw\na/ixeJwiH/KNr2jYitJ+cIibv1iTq2m0HL3bJPeOfkPfM4S0WRAb7Pzp1Rh76Vq/\nyaX+muMaqVjmr4vmNOBB3TDxyjuCzW3KhyUQDBrpl3poyIDdUcJrycqbbkN7rNBk\n9Lbi8XkF0Q1jnEB9YKosAd59qVGGCQXJ94hgvXPwmjpyXoFLAaPPTBud8Vg7Gyso\nry4+3jkb6zXUvJbZKnv5HIFgHiICQwoGBgb4Sx9ZMMaJyMvp870K1mQ06f3kBw4E\nIfjoZD2P7EI3MP55itG8/mxp7y6JdrXf/Mim+VX+qxlW4mGe0hu8rrkzJP4E9w42\nuOV7VVms3vE+DhXcpFrQCjsImAo7+RSqLbaNY8B7HeRumbjcj+6aSwbgZExYZRA3\nw5TPb6JB5tGyAQICu5lKav9B+VsJuqcACdAGO6AD+eQ53ba8rrqrEm1gpSQ7H7Ah\nydikW9Gco2S04c0E6NzybPA3/hO967hJ572M3Q2/QoGLjolWko9MWeOwv2ajtXy1\ntHJ01hr0fLUJqsAn1C6z\n=hHy2\n-----END PGP SIGNATURE-----", "payload": "tree ace5c1c3f1976ecb1d006c1dedba296adff28ca4\nparent 59b0077565bc056283dad048a237dbc183000c76\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1480696711 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1480696711 +0100\n\n`enum glob use` and `copies` left"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16aab716886b9d00ca6e58d502faefdc55477cc6", "html_url": "https://github.com/rust-lang/rust/commit/16aab716886b9d00ca6e58d502faefdc55477cc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16aab716886b9d00ca6e58d502faefdc55477cc6/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59b0077565bc056283dad048a237dbc183000c76", "url": "https://api.github.com/repos/rust-lang/rust/commits/59b0077565bc056283dad048a237dbc183000c76", "html_url": "https://github.com/rust-lang/rust/commit/59b0077565bc056283dad048a237dbc183000c76"}], "stats": {"total": 224, "additions": 116, "deletions": 108}, "files": [{"sha": "7992c4966b2a34cbddd1cae6316df09182e9d1b7", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -48,6 +48,8 @@ impl EnumGlobUse {\n             return; // re-exports are fine\n         }\n         if let ItemUse(ref path, UseKind::Glob) = item.node {\n+            // FIXME: ask jseyfried why the qpath.def for `use std::cmp::Ordering::*;`\n+            // extracted through `ItemUse(ref qpath, UseKind::Glob)` is a `Mod` and not an `Enum`\n             if let Def::Enum(_) = path.def {\n                 span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n             }"}, {"sha": "6d100317fd8864024c15d1ec802f68de313f00ec", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics};\n use std::collections::{HashSet, HashMap};\n use syntax::codemap::Span;\n-use utils::{in_external_macro, span_lint};\n+use utils::{in_external_macro, span_lint, last_path_segment};\n \n /// **What it does:** Checks for lifetime annotations which can be removed by\n /// relying on lifetime elision.\n@@ -240,26 +240,24 @@ impl<'v, 't> RefVisitor<'v, 't> {\n     }\n \n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n-        if let QPath::Resolved(_, ref path) = *qpath {\n-            let last_path_segment = path.segments.last().map(|s| &s.parameters);\n-            if let Some(&AngleBracketedParameters(ref params)) = last_path_segment {\n-                if params.lifetimes.is_empty() {\n-                    match self.cx.tcx.tables().qpath_def(qpath, ty.id) {\n-                        Def::TyAlias(def_id) |\n-                        Def::Struct(def_id) => {\n-                            let generics = self.cx.tcx.item_generics(def_id);\n-                            for _ in generics.regions.as_slice() {\n-                                self.record(&None);\n-                            }\n+        let last_path_segment = &last_path_segment(qpath).parameters;\n+        if let &AngleBracketedParameters(ref params) = last_path_segment {\n+            if params.lifetimes.is_empty() {\n+                match self.cx.tcx.tables().qpath_def(qpath, ty.id) {\n+                    Def::TyAlias(def_id) |\n+                    Def::Struct(def_id) => {\n+                        let generics = self.cx.tcx.item_generics(def_id);\n+                        for _ in generics.regions.as_slice() {\n+                            self.record(&None);\n                         }\n-                        Def::Trait(def_id) => {\n-                            let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n-                            for _ in &trait_def.generics.regions {\n-                                self.record(&None);\n-                            }\n+                    }\n+                    Def::Trait(def_id) => {\n+                        let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n+                        for _ in &trait_def.generics.regions {\n+                            self.record(&None);\n                         }\n-                        _ => (),\n                     }\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "0d862b76d9bb2fef0006a5dafd1bef88f1965ba4", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -16,7 +16,7 @@ use utils::sugg;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg,\n             in_external_macro, is_refutable, span_help_and_lint, is_integer_literal,\n-            get_enclosing_block, span_lint_and_then, higher, walk_ptrs_ty};\n+            get_enclosing_block, span_lint_and_then, higher, walk_ptrs_ty, last_path_segment};\n use utils::paths;\n \n /// **What it does:** Checks for looping over the range of `0..len` of some\n@@ -369,26 +369,23 @@ impl LateLintPass for Pass {\n             if let (&PatKind::TupleStruct(ref qpath, ref pat_args, _),\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n-                if let QPath::Resolved(_, ref path) = *qpath {\n-                    if let Some(lhs_constructor) = path.segments.last() {\n-                        if &*method_name.node.as_str() == \"next\" &&\n-                           match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                           &*lhs_constructor.name.as_str() == \"Some\" &&\n-                           !is_refutable(cx, &pat_args[0]) &&\n-                           !is_iterator_used_after_while_let(cx, iter_expr) {\n-                            let iterator = snippet(cx, method_args[0].span, \"_\");\n-                            let loop_var = snippet(cx, pat_args[0].span, \"_\");\n-                            span_lint_and_then(cx,\n-                                               WHILE_LET_ON_ITERATOR,\n-                                               expr.span,\n-                                               \"this loop could be written as a `for` loop\",\n-                                               |db| {\n-                            db.span_suggestion(expr.span,\n-                                               \"try\",\n-                                               format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n-                            });\n-                        }\n-                    }\n+                let lhs_constructor = last_path_segment(qpath);\n+                if &*method_name.node.as_str() == \"next\" &&\n+                   match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n+                   &*lhs_constructor.name.as_str() == \"Some\" &&\n+                   !is_refutable(cx, &pat_args[0]) &&\n+                   !is_iterator_used_after_while_let(cx, iter_expr) {\n+                    let iterator = snippet(cx, method_args[0].span, \"_\");\n+                    let loop_var = snippet(cx, pat_args[0].span, \"_\");\n+                    span_lint_and_then(cx,\n+                                       WHILE_LET_ON_ITERATOR,\n+                                       expr.span,\n+                                       \"this loop could be written as a `for` loop\",\n+                                       |db| {\n+                    db.span_suggestion(expr.span,\n+                                       \"try\",\n+                                       format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n+                    });\n                 }\n             }\n         }"}, {"sha": "edcdc74013b0af30a8956c8f65420fd4a3f86efd", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -3,14 +3,16 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::ty;\n+use rustc::hir::def::Def;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use std::borrow::Cow;\n use std::fmt;\n use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path,\n             match_trait_method, match_type, method_chain_args, return_ty, same_tys, snippet,\n-            span_lint, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            span_lint, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth,\n+            last_path_segment, single_segment_path, match_def_path};\n use utils::paths;\n use utils::sugg;\n \n@@ -701,12 +703,8 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n         }\n \n         if name == \"unwrap_or\" {\n-            if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n-                let path: &str = &path.segments\n-                                      .last()\n-                                      .expect(\"A path must have at least one segment\")\n-                                      .name\n-                                      .as_str();\n+            if let hir::ExprPath(ref qpath) = fun.node {\n+                let path: &str = &*last_path_segment(qpath).name.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tcx.tables().expr_ty(arg);\n@@ -878,7 +876,8 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n         let hir::ExprCall(ref fun, ref args) = new.node,\n         args.len() == 1,\n         let hir::ExprPath(ref path) = fun.node,\n-        match_path(path, &paths::CSTRING_NEW),\n+        let Def::Method(did) = cx.tcx.tables().qpath_def(path, fun.id),\n+        match_def_path(cx, did, &paths::CSTRING_NEW)\n     ], {\n         span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n                            \"you are getting the inner pointer of a temporary `CString`\",\n@@ -1188,8 +1187,9 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         let Some(args) = method_chain_args(chain, &[\"chars\", \"next\"]),\n         let hir::ExprCall(ref fun, ref arg_char) = other.node,\n         arg_char.len() == 1,\n-        let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = fun.node,\n-        path.segments.len() == 1 && &*path.segments[0].name.as_str() == \"Some\"\n+        let hir::ExprPath(ref qpath) = fun.node,\n+        let Some(segment) = single_segment_path(qpath),\n+        &*segment.name.as_str() == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tcx.tables().expr_ty_adjusted(&args[0][0]));\n "}, {"sha": "5752e95d0acce4908287881ae4fda4e9ce1ff910", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -10,7 +10,7 @@ use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use utils::{\n     get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path,\n-    snippet, span_lint, span_lint_and_then, walk_ptrs_ty\n+    snippet, span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment\n };\n use utils::sugg::Sugg;\n \n@@ -263,22 +263,14 @@ impl LateLintPass for Pass {\n         }\n         let binding = match expr.node {\n             ExprPath(ref qpath) => {\n-                if let QPath::Resolved(_, ref path) = *qpath {\n-                    let binding = path.segments\n-                        .last()\n-                        .expect(\"path should always have at least one segment\")\n-                        .name\n-                        .as_str();\n-                    if binding.starts_with('_') &&\n-                        !binding.starts_with(\"__\") &&\n-                        &*binding != \"_result\" && // FIXME: #944\n-                        is_used(cx, expr) &&\n-                        // don't lint if the declaration is in a macro\n-                        non_macro_local(cx, &cx.tcx.tables().qpath_def(qpath, expr.id)) {\n-                        Some(binding)\n-                    } else {\n-                        None\n-                    }\n+                let binding = last_path_segment(qpath).name.as_str();\n+                if binding.starts_with('_') &&\n+                    !binding.starts_with(\"__\") &&\n+                    &*binding != \"_result\" && // FIXME: #944\n+                    is_used(cx, expr) &&\n+                    // don't lint if the declaration is in a macro\n+                    non_macro_local(cx, &cx.tcx.tables().qpath_def(qpath, expr.id)) {\n+                    Some(binding)\n                 } else {\n                     None\n                 }"}, {"sha": "b3d03f5dc18f7b24552d769dc62cd4faeaf2ca0f", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -75,17 +75,13 @@ impl LateLintPass for StepByZero {\n                     // .iter() and .len() called on same Path\n                     let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node,\n                     let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node,\n-                    iter_path == len_path\n+                    iter_path.segments == len_path.segments\n                  ], {\n-                     let Path { segments: ref iter_path, .. } = **iter_path;\n-                     let Path { segments: ref len_path, .. } = **len_path;\n-                     if iter_path == len_path {\n-                         span_lint(cx,\n-                                   RANGE_ZIP_WITH_LEN,\n-                                   expr.span,\n-                                   &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n-                                            snippet(cx, iter_args[0].span, \"_\")));\n-                     }\n+                     span_lint(cx,\n+                               RANGE_ZIP_WITH_LEN,\n+                               expr.span,\n+                               &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                        snippet(cx, iter_args[0].span, \"_\")));\n                 }}\n             }\n         }"}, {"sha": "2263390840c13d95624c61a8aa40af706d855d15", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet};\n+use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet, last_path_segment};\n use utils::sugg;\n \n /// **What it does:** Checks for transmutes that can't ever be correct on any\n@@ -191,9 +191,8 @@ impl LateLintPass for Transmute {\n /// the type's `ToString` implementation. In weird cases it could lead to types with invalid `'_`\n /// lifetime, but it should be rare.\n fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: ty::Ty) -> String {\n+    let seg = last_path_segment(path);\n     if_let_chain!{[\n-        let QPath::Resolved(_, ref path) = *path,\n-        let Some(seg) = path.segments.last(),\n         let PathParameters::AngleBracketedParameters(ref ang) = seg.parameters,\n         let Some(to_ty) = ang.types.get(1),\n         let TyRptr(_, ref to_ty) = to_ty.node,"}, {"sha": "15e5f3f58db7b754293a8671e05a43eba7101725", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -7,7 +7,7 @@ use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet,\n-            span_help_and_lint, span_lint, opt_def_id};\n+            span_help_and_lint, span_lint, opt_def_id, last_path_segment};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -78,9 +78,8 @@ impl LateLintPass for TypePass {\n             let def = cx.tcx.tables().qpath_def(qpath, ast_ty.id);\n             if let Some(def_id) = opt_def_id(def) {\n                 if def_id == cx.tcx.lang_items.owned_box().unwrap() {\n+                    let last = last_path_segment(qpath);\n                     if_let_chain! {[\n-                        let QPath::Resolved(_, ref path) = *qpath,\n-                        let Some(ref last) = path.segments.last(),\n                         let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n                         let Some(ref vec) = ag.types.get(0),\n                         let TyPath(ref qpath) = vec.node,"}, {"sha": "6ae4743a368cc8178216af9f1c48d4e8b67a679a", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -163,7 +163,7 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))\n         }\n-        else if match_path(path, &[\"into_vec\"]) && args.len() == 1 {\n+        else if match_def_path(cx, fun_def.def_id(), &paths::SLICE_INTO_VEC) && args.len() == 1 {\n             // `vec![a, b, c]` case\n             if_let_chain!{[\n                 let hir::ExprBox(ref boxed) = args[0].node,"}, {"sha": "be2b59d5ffc08c1fa2a9a943830069d4d63e87d1", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n-use syntax::ast::Name;\n+use syntax::ast::{Name, NodeId};\n use syntax::ptr::P;\n use utils::differing_macro_contexts;\n \n@@ -457,13 +457,13 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             ExprPath(ref qpath) => {\n                 let c: fn(_) -> _ = ExprPath;\n                 c.hash(&mut self.s);\n-                self.hash_qpath(qpath);\n+                self.hash_qpath(qpath, e.id);\n             }\n             ExprStruct(ref path, ref fields, ref expr) => {\n                 let c: fn(_, _, _) -> _ = ExprStruct;\n                 c.hash(&mut self.s);\n \n-                self.hash_qpath(path);\n+                self.hash_qpath(path, e.id);\n \n                 for f in fields {\n                     self.hash_name(&f.name.node);\n@@ -528,21 +528,8 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         n.as_str().hash(&mut self.s);\n     }\n \n-    pub fn hash_qpath(&mut self, p: &QPath) {\n-        match *p {\n-            QPath::Resolved(ref _ty, ref path) => {\n-                let c: fn(_, _) -> _ = QPath::Resolved;\n-                c.hash(&mut self.s);\n-                // self.hash_ty(ty); FIXME\n-                self.hash_path(path);\n-            },\n-            QPath::TypeRelative(ref _ty, ref seg) => {\n-                let c: fn(_, _) -> _ = QPath::TypeRelative;\n-                c.hash(&mut self.s);\n-                // self.hash_ty(ty); FIXME\n-                self.hash_name(&seg.name);\n-            },\n-        }\n+    pub fn hash_qpath(&mut self, p: &QPath, id: NodeId) {\n+        self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n     }\n \n     pub fn hash_path(&mut self, p: &Path) {"}, {"sha": "cb25759b4ae004b088a059268ee912f2b0bce981", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -95,7 +95,16 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n }\n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n-    cx.sess().codemap().with_expn_info(span.expn_id, |info| info.is_some())\n+    cx.sess().codemap().with_expn_info(span.expn_id, |info| match info {\n+        Some(info) => {\n+            match info.callee.format {\n+                // don't treat range expressions desugared to structs as \"in_macro\"\n+                ExpnFormat::CompilerDesugaring(name) => name != \"...\",\n+                _ => true,\n+            }\n+        },\n+        None => false,\n+    })\n }\n \n /// Returns true if the macro that expanded the crate was outside of the current crate or was a\n@@ -150,6 +159,9 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n     let mut apb = AbsolutePathBuffer { names: vec![] };\n \n     cx.tcx.push_item_path(&mut apb, def_id);\n+    if path == paths::VEC_FROM_ELEM {\n+        println!(\"{:#?} == {:#?}\", apb.names, path);\n+    }\n \n     apb.names.len() == path.len() &&\n     apb.names.iter().zip(path.iter()).all(|(a, &b)| &**a == b)\n@@ -197,17 +209,40 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n     }\n }\n \n+pub fn last_path_segment(path: &QPath) -> &PathSegment {\n+    match *path {\n+        QPath::Resolved(_, ref path) => path.segments\n+                                            .last()\n+                                            .expect(\"A path must have at least one segment\"),\n+        QPath::TypeRelative(_, ref seg) => &seg,\n+    }\n+}\n+\n+pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n+    match *path {\n+        QPath::Resolved(_, ref path) if path.segments.len() == 1 => Some(&path.segments[0]),\n+        QPath::Resolved(..) => None,\n+        QPath::TypeRelative(_, ref seg) => Some(&seg),\n+    }\n+}\n+\n /// Match a `Path` against a slice of segment string literals.\n ///\n /// # Examples\n /// ```\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path(path: &QPath, segments: &[&str]) -> bool {\n-    if let QPath::Resolved(_, ref path) = *path {\n-        match_path_old(path, segments)\n-    } else {\n-        false\n+    match *path {\n+        QPath::Resolved(_, ref path) => match_path_old(path, segments),\n+        QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n+            TyPath(ref inner_path) => {\n+                segments.len() > 0 &&\n+                match_path(inner_path, &segments[..(segments.len() - 1)]) &&\n+                segment.name == segments[segments.len() - 1]\n+            },\n+            _ => false,\n+        },\n     }\n }\n "}, {"sha": "402985613aeb8c0fbecb5a5b9c02d572c800ff13", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -12,7 +12,7 @@ pub const CLONE_TRAIT: [&'static str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CMP_MAX: [&'static str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&'static str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n-pub const CSTRING_NEW: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n+pub const CSTRING_NEW: [&'static str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"new\"];\n pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Debug\", \"fmt\"];\n pub const DEFAULT_TRAIT: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n@@ -64,6 +64,7 @@ pub const RESULT: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const RESULT_ERR: [&'static str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n pub const RESULT_OK: [&'static str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n pub const SERDE_DE_VISITOR: [&'static str; 3] = [\"serde\", \"de\", \"Visitor\"];\n+pub const SLICE_INTO_VEC: [&'static str; 4] = [\"collections\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];"}, {"sha": "005129f1b5da542dc558924e331b12d37a1cc409", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -9,6 +9,7 @@\n #![allow(blacklisted_name)]\n #![allow(collapsible_if)]\n #![allow(zero_divided_by_zero, eq_op)]\n+#![allow(path_statements)]\n \n fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }"}, {"sha": "525c166e62afdcaaa8eb932adf4b45d8712ae420", "filename": "tests/compile-fail/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/tests%2Fcompile-fail%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/tests%2Fcompile-fail%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdlist.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -10,5 +10,5 @@ pub fn test(_: LinkedList<u8>) {  //~ ERROR I see you're using a LinkedList!\n }\n \n fn main(){\n-    test(LinkedList::new());\n+    test(LinkedList::new()); //~ ERROR I see you're using a LinkedList!\n }"}, {"sha": "50701ce0ec99562cd713e8b0d40651d2def76cac", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16aab716886b9d00ca6e58d502faefdc55477cc6/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16aab716886b9d00ca6e58d502faefdc55477cc6/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=16aab716886b9d00ca6e58d502faefdc55477cc6", "patch": "@@ -21,6 +21,7 @@ fn run_mode(dir: &'static str, mode: &'static str) {\n \n fn prepare_env() {\n     set_var(\"CLIPPY_DISABLE_WIKI_LINKS\", \"true\");\n+    set_var(\"RUST_BACKTRACE\", \"0\"); // these are riddicously slow right now\n }\n \n #[test]"}]}