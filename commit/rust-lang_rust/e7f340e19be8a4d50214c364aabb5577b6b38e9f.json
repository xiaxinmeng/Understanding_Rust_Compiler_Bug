{"sha": "e7f340e19be8a4d50214c364aabb5577b6b38e9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZjM0MGUxOWJlOGE0ZDUwMjE0YzM2NGFhYmI1NTc3YjZiMzhlOWY=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-02-16T16:13:43Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-03-03T17:06:35Z"}, "message": "BTree: move blocks around in node.rs", "tree": {"sha": "2e5e4e60801bd621a4770a9e67ad54505cc284bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e5e4e60801bd621a4770a9e67ad54505cc284bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7f340e19be8a4d50214c364aabb5577b6b38e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7f340e19be8a4d50214c364aabb5577b6b38e9f", "html_url": "https://github.com/rust-lang/rust/commit/e7f340e19be8a4d50214c364aabb5577b6b38e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7f340e19be8a4d50214c364aabb5577b6b38e9f/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939b14334dfec68d85b01b62c1be0172cee03339", "url": "https://api.github.com/repos/rust-lang/rust/commits/939b14334dfec68d85b01b62c1be0172cee03339", "html_url": "https://github.com/rust-lang/rust/commit/939b14334dfec68d85b01b62c1be0172cee03339"}], "stats": {"total": 332, "additions": 165, "deletions": 167}, "files": [{"sha": "f330a1bb3dcfebd0822d6b485c5937d59a5415cf", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 165, "deletions": 167, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/e7f340e19be8a4d50214c364aabb5577b6b38e9f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7f340e19be8a4d50214c364aabb5577b6b38e9f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=e7f340e19be8a4d50214c364aabb5577b6b38e9f", "patch": "@@ -128,106 +128,6 @@ impl<K, V> InternalNode<K, V> {\n /// is not a separate type and has no destructor.\n type BoxedNode<K, V> = NonNull<LeafNode<K, V>>;\n \n-/// The root node of an owned tree.\n-///\n-/// Note that this does not have a destructor, and must be cleaned up manually.\n-pub type Root<K, V> = NodeRef<marker::Owned, K, V, marker::LeafOrInternal>;\n-\n-impl<K, V> Root<K, V> {\n-    /// Returns a new owned tree, with its own root node that is initially empty.\n-    pub fn new() -> Self {\n-        NodeRef::new_leaf().forget_type()\n-    }\n-}\n-\n-impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n-    fn new_leaf() -> Self {\n-        Self::from_new_leaf(LeafNode::new())\n-    }\n-\n-    fn from_new_leaf(leaf: Box<LeafNode<K, V>>) -> Self {\n-        NodeRef { height: 0, node: NonNull::from(Box::leak(leaf)), _marker: PhantomData }\n-    }\n-}\n-\n-impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n-    fn new_internal(child: Root<K, V>) -> Self {\n-        let mut new_node = unsafe { InternalNode::new() };\n-        new_node.edges[0].write(child.node);\n-        unsafe { NodeRef::from_new_internal(new_node, child.height + 1) }\n-    }\n-\n-    /// # Safety\n-    /// `height` must not be zero.\n-    unsafe fn from_new_internal(internal: Box<InternalNode<K, V>>, height: usize) -> Self {\n-        debug_assert!(height > 0);\n-        let node = NonNull::from(Box::leak(internal)).cast();\n-        let mut this = NodeRef { height, node, _marker: PhantomData };\n-        this.borrow_mut().correct_all_childrens_parent_links();\n-        this\n-    }\n-}\n-\n-impl<K, V, Type> NodeRef<marker::Owned, K, V, Type> {\n-    /// Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n-    /// because the return value cannot be used to destroy the root, and there\n-    /// cannot be other references to the tree.\n-    pub fn borrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {\n-        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n-    }\n-\n-    /// Slightly mutably borrows the owned root node.\n-    pub fn borrow_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, Type> {\n-        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n-    }\n-\n-    /// Irreversibly transitions to a reference that permits traversal and offers\n-    /// destructive methods and little else.\n-    pub fn into_dying(self) -> NodeRef<marker::Dying, K, V, Type> {\n-        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n-    }\n-}\n-\n-impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n-    /// Adds a new internal node with a single edge pointing to the previous root node,\n-    /// make that new node the root node, and return it. This increases the height by 1\n-    /// and is the opposite of `pop_internal_level`.\n-    pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n-        super::mem::take_mut(self, |old_root| NodeRef::new_internal(old_root).forget_type());\n-\n-        // `self.borrow_mut()`, except that we just forgot we're internal now:\n-        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n-    }\n-\n-    /// Removes the internal root node, using its first child as the new root node.\n-    /// As it is intended only to be called when the root node has only one child,\n-    /// no cleanup is done on any of the keys, values and other children.\n-    /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n-    ///\n-    /// Requires exclusive access to the `Root` object but not to the root node;\n-    /// it will not invalidate other handles or references to the root node.\n-    ///\n-    /// Panics if there is no internal level, i.e., if the root node is a leaf.\n-    pub fn pop_internal_level(&mut self) {\n-        assert!(self.height > 0);\n-\n-        let top = self.node;\n-\n-        // SAFETY: we asserted to be internal.\n-        let internal_self = unsafe { self.borrow_mut().cast_to_internal_unchecked() };\n-        // SAFETY: we borrowed `self` exclusively and its borrow type is exclusive.\n-        let internal_node = unsafe { &mut *NodeRef::as_internal_ptr(&internal_self) };\n-        // SAFETY: the first edge is always initialized.\n-        self.node = unsafe { internal_node.edges[0].assume_init_read() };\n-        self.height -= 1;\n-        self.clear_parent_link();\n-\n-        unsafe {\n-            Global.deallocate(top.cast(), Layout::new::<InternalNode<K, V>>());\n-        }\n-    }\n-}\n-\n // N.B. `NodeRef` is always covariant in `K` and `V`, even when the `BorrowType`\n // is `Mut`. This is technically wrong, but cannot result in any unsafety due to\n // internal use of `NodeRef` because we stay completely generic over `K` and `V`.\n@@ -292,6 +192,11 @@ pub struct NodeRef<BorrowType, K, V, Type> {\n     _marker: PhantomData<(BorrowType, Type)>,\n }\n \n+/// The root node of an owned tree.\n+///\n+/// Note that this does not have a destructor, and must be cleaned up manually.\n+pub type Root<K, V> = NodeRef<marker::Owned, K, V, marker::LeafOrInternal>;\n+\n impl<'a, K: 'a, V: 'a, Type> Copy for NodeRef<marker::Immut<'a>, K, V, Type> {}\n impl<'a, K: 'a, V: 'a, Type> Clone for NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn clone(&self) -> Self {\n@@ -307,6 +212,34 @@ unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::ValMu\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Dying, K, V, Type> {}\n \n+impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n+    fn new_leaf() -> Self {\n+        Self::from_new_leaf(LeafNode::new())\n+    }\n+\n+    fn from_new_leaf(leaf: Box<LeafNode<K, V>>) -> Self {\n+        NodeRef { height: 0, node: NonNull::from(Box::leak(leaf)), _marker: PhantomData }\n+    }\n+}\n+\n+impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n+    fn new_internal(child: Root<K, V>) -> Self {\n+        let mut new_node = unsafe { InternalNode::new() };\n+        new_node.edges[0].write(child.node);\n+        unsafe { NodeRef::from_new_internal(new_node, child.height + 1) }\n+    }\n+\n+    /// # Safety\n+    /// `height` must not be zero.\n+    unsafe fn from_new_internal(internal: Box<InternalNode<K, V>>, height: usize) -> Self {\n+        debug_assert!(height > 0);\n+        let node = NonNull::from(Box::leak(internal)).cast();\n+        let mut this = NodeRef { height, node, _marker: PhantomData };\n+        this.borrow_mut().correct_all_childrens_parent_links();\n+        this\n+    }\n+}\n+\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     /// Unpack a node reference that was packed as `NodeRef::parent`.\n     fn from_internal(node: NonNull<InternalNode<K, V>>, height: usize) -> Self {\n@@ -420,6 +353,19 @@ impl<BorrowType: marker::BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type>\n     }\n }\n \n+impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n+    /// Could be a public implementation of PartialEq, but only used in this module.\n+    fn eq(&self, other: &Self) -> bool {\n+        let Self { node, height, _marker } = self;\n+        if node.eq(&other.node) {\n+            debug_assert_eq!(*height, other.height);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     /// Exposes the leaf portion of any leaf or internal node in an immutable tree.\n     fn into_leaf(self) -> &'a LeafNode<K, V> {\n@@ -461,20 +407,6 @@ impl<K, V> NodeRef<marker::Dying, K, V, marker::LeafOrInternal> {\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n-    /// Unsafely asserts to the compiler the static information that this node is a `Leaf`.\n-    unsafe fn cast_to_leaf_unchecked(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n-        debug_assert!(self.height == 0);\n-        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n-    }\n-\n-    /// Unsafely asserts to the compiler the static information that this node is an `Internal`.\n-    unsafe fn cast_to_internal_unchecked(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-        debug_assert!(self.height > 0);\n-        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n-    }\n-}\n-\n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Temporarily takes out another, mutable reference to the same node. Beware, as\n     /// this method is very dangerous, doubly so since it may not immediately appear\n@@ -577,6 +509,22 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n }\n \n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// # Safety\n+    /// Every item returned by `range` is a valid edge index for the node.\n+    unsafe fn correct_childrens_parent_links<R: Iterator<Item = usize>>(&mut self, range: R) {\n+        for i in range {\n+            debug_assert!(i <= self.len());\n+            unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n+        }\n+    }\n+\n+    fn correct_all_childrens_parent_links(&mut self) {\n+        let len = self.len();\n+        unsafe { self.correct_childrens_parent_links(0..=len) };\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Sets the node's link to its parent edge,\n     /// without invalidating other references to the node.\n@@ -596,6 +544,71 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     }\n }\n \n+impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n+    /// Returns a new owned tree, with its own root node that is initially empty.\n+    pub fn new() -> Self {\n+        NodeRef::new_leaf().forget_type()\n+    }\n+\n+    /// Adds a new internal node with a single edge pointing to the previous root node,\n+    /// make that new node the root node, and return it. This increases the height by 1\n+    /// and is the opposite of `pop_internal_level`.\n+    pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n+        super::mem::take_mut(self, |old_root| NodeRef::new_internal(old_root).forget_type());\n+\n+        // `self.borrow_mut()`, except that we just forgot we're internal now:\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+\n+    /// Removes the internal root node, using its first child as the new root node.\n+    /// As it is intended only to be called when the root node has only one child,\n+    /// no cleanup is done on any of the keys, values and other children.\n+    /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n+    ///\n+    /// Requires exclusive access to the `Root` object but not to the root node;\n+    /// it will not invalidate other handles or references to the root node.\n+    ///\n+    /// Panics if there is no internal level, i.e., if the root node is a leaf.\n+    pub fn pop_internal_level(&mut self) {\n+        assert!(self.height > 0);\n+\n+        let top = self.node;\n+\n+        // SAFETY: we asserted to be internal.\n+        let internal_self = unsafe { self.borrow_mut().cast_to_internal_unchecked() };\n+        // SAFETY: we borrowed `self` exclusively and its borrow type is exclusive.\n+        let internal_node = unsafe { &mut *NodeRef::as_internal_ptr(&internal_self) };\n+        // SAFETY: the first edge is always initialized.\n+        self.node = unsafe { internal_node.edges[0].assume_init_read() };\n+        self.height -= 1;\n+        self.clear_parent_link();\n+\n+        unsafe {\n+            Global.deallocate(top.cast(), Layout::new::<InternalNode<K, V>>());\n+        }\n+    }\n+}\n+\n+impl<K, V, Type> NodeRef<marker::Owned, K, V, Type> {\n+    /// Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n+    /// because the return value cannot be used to destroy the root, and there\n+    /// cannot be other references to the tree.\n+    pub fn borrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+\n+    /// Slightly mutably borrows the owned root node.\n+    pub fn borrow_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+\n+    /// Irreversibly transitions to a reference that permits traversal and offers\n+    /// destructive methods and little else.\n+    pub fn into_dying(self) -> NodeRef<marker::Dying, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key-value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n@@ -610,22 +623,6 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// # Safety\n-    /// Every item returned by `range` is a valid edge index for the node.\n-    unsafe fn correct_childrens_parent_links<R: Iterator<Item = usize>>(&mut self, range: R) {\n-        for i in range {\n-            debug_assert!(i <= self.len());\n-            unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n-        }\n-    }\n-\n-    fn correct_all_childrens_parent_links(&mut self) {\n-        let len = self.len();\n-        unsafe { self.correct_childrens_parent_links(0..=len) };\n-    }\n-}\n-\n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     /// Adds a key-value pair, and an edge to go to the right of that pair,\n     /// to the end of the node.\n@@ -645,6 +642,20 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     }\n }\n \n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Leaf> {\n+    /// Removes any static information asserting that this node is a `Leaf` node.\n+    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    /// Removes any static information asserting that this node is an `Internal` node.\n+    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+}\n+\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     /// Checks whether a node is an `Internal` node or a `Leaf` node.\n     pub fn force(\n@@ -669,6 +680,20 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     }\n }\n \n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Unsafely asserts to the compiler the static information that this node is a `Leaf`.\n+    unsafe fn cast_to_leaf_unchecked(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n+        debug_assert!(self.height == 0);\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+\n+    /// Unsafely asserts to the compiler the static information that this node is an `Internal`.\n+    unsafe fn cast_to_internal_unchecked(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+        debug_assert!(self.height > 0);\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+}\n+\n /// A reference to a specific key-value pair or edge within a node. The `Node` parameter\n /// must be a `NodeRef`, while the `Type` can either be `KV` (signifying a handle on a key-value\n /// pair) or `Edge` (signifying a handle on an edge).\n@@ -722,19 +747,6 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n     }\n }\n \n-impl<BorrowType, K, V, NodeType> NodeRef<BorrowType, K, V, NodeType> {\n-    /// Could be a public implementation of PartialEq, but only used in this module.\n-    fn eq(&self, other: &Self) -> bool {\n-        let Self { node, height, _marker } = self;\n-        if node.eq(&other.node) {\n-            debug_assert_eq!(*height, other.height);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n     for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {\n@@ -754,16 +766,6 @@ impl<BorrowType, K, V, NodeType, HandleType>\n     }\n }\n \n-impl<'a, K, V, Type> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, Type> {\n-    /// Unsafely asserts to the compiler the static information that the handle's node is a `Leaf`.\n-    pub unsafe fn cast_to_leaf_unchecked(\n-        self,\n-    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, Type> {\n-        let node = unsafe { self.node.cast_to_leaf_unchecked() };\n-        Handle { node, idx: self.idx, _marker: PhantomData }\n-    }\n-}\n-\n impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n     /// Temporarily takes out another, mutable handle on the same location. Beware, as\n     /// this method is very dangerous, doubly so since it may not immediately appear\n@@ -1466,20 +1468,6 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n     }\n }\n \n-impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Leaf> {\n-    /// Removes any static information asserting that this node is a `Leaf` node.\n-    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n-    }\n-}\n-\n-impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n-    /// Removes any static information asserting that this node is an `Internal` node.\n-    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n-    }\n-}\n-\n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     pub fn forget_node_type(\n         self,\n@@ -1531,6 +1519,16 @@ impl<BorrowType, K, V, Type> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInte\n     }\n }\n \n+impl<'a, K, V, Type> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, Type> {\n+    /// Unsafely asserts to the compiler the static information that the handle's node is a `Leaf`.\n+    pub unsafe fn cast_to_leaf_unchecked(\n+        self,\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, Type> {\n+        let node = unsafe { self.node.cast_to_leaf_unchecked() };\n+        Handle { node, idx: self.idx, _marker: PhantomData }\n+    }\n+}\n+\n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n     /// Move the suffix after `self` from one node to another one. `right` must be empty.\n     /// The first edge of `right` remains unchanged."}]}