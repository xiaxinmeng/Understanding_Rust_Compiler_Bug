{"sha": "3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4OTgzODdmM2JkNTc5YzBjNTQxNWVjYjdjN2IzZDM5MjM5NDdmMmY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-20T17:38:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-20T17:38:27Z"}, "message": "Merge #9346\n\n9346: Refactor / clean up hir_ty tests r=flodiebold a=flodiebold\n\nNotable changes:\r\n - unify `check_types` and `check_mismatches` into `check`, which supports both kinds of annotations (`check_types` still exists because I didn't want to change all the annotations, but uses the same implementation)\r\n - because of that, `check_types` now fails on any type mismatches; also annotations always have to hit the exact range\r\n - there's also `check_no_mismatches` for when we explicitly just want to check that there are no type mismatches without giving any annotations (`check` will fail without annotations)\r\n - test annotations can now be overlapping (they point to the nearest line that has actual code in that range):\r\n```\r\n// ^^^^ annotation\r\n//    ^^^^^^^^^ another annotation\r\n```\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "c30eec53f9330ac571e4f10e3191f7507b2b0fcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c30eec53f9330ac571e4f10e3191f7507b2b0fcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgz30TCRBK7hj4Ov3rIwAA1+QIAAmMtmc256jINqKU9iCP3nHQ\ngiBwtwA4H4+Tde2P2ttP3ZBr2pAjs5DLh3bAh8xOcbr/cslwYwVIPiyo17YoMpcr\nEeAGPjS6UV5FSt8Wsk27EAhUdyTk5ATaYJgvlWcyYi0NEZ3KsOnFtfrsG/l0iKM6\nwIzqBfGYfQp2eRHd4VskglgF71+CIie3izENNr8a7ObWFrlB9IIqEB/JW1I6BUZw\nj3rIqiLBTj+uKUyB1KynatbtPtB0BDH5M938befqOSwlRu96CAuNjEgGWuvGQfaK\nzMBr2/njTvepWcnj02gujVlCLRv0P2CHMfXtYW6o0WzD8jZmlMBvD+k3gZayURw=\n=hRjD\n-----END PGP SIGNATURE-----\n", "payload": "tree c30eec53f9330ac571e4f10e3191f7507b2b0fcf\nparent 8cc2b710db6ea851f0c4b636172861df98ba5ead\nparent a1120b6879afe39f69a04eb0f6ee84d4cb4e03f6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1624210707 +0000\ncommitter GitHub <noreply@github.com> 1624210707 +0000\n\nMerge #9346\n\n9346: Refactor / clean up hir_ty tests r=flodiebold a=flodiebold\n\nNotable changes:\r\n - unify `check_types` and `check_mismatches` into `check`, which supports both kinds of annotations (`check_types` still exists because I didn't want to change all the annotations, but uses the same implementation)\r\n - because of that, `check_types` now fails on any type mismatches; also annotations always have to hit the exact range\r\n - there's also `check_no_mismatches` for when we explicitly just want to check that there are no type mismatches without giving any annotations (`check` will fail without annotations)\r\n - test annotations can now be overlapping (they point to the nearest line that has actual code in that range):\r\n```\r\n// ^^^^ annotation\r\n//    ^^^^^^^^^ another annotation\r\n```\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "html_url": "https://github.com/rust-lang/rust/commit/3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cc2b710db6ea851f0c4b636172861df98ba5ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc2b710db6ea851f0c4b636172861df98ba5ead", "html_url": "https://github.com/rust-lang/rust/commit/8cc2b710db6ea851f0c4b636172861df98ba5ead"}, {"sha": "a1120b6879afe39f69a04eb0f6ee84d4cb4e03f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1120b6879afe39f69a04eb0f6ee84d4cb4e03f6", "html_url": "https://github.com/rust-lang/rust/commit/a1120b6879afe39f69a04eb0f6ee84d4cb4e03f6"}], "stats": {"total": 1553, "additions": 557, "deletions": 996}, "files": [{"sha": "a55b99de0429778212bd19b256c9890fd97ca725", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -2,6 +2,7 @@\n //! about the code that Chalk needs.\n use std::sync::Arc;\n \n+use cov_mark::hit;\n use log::debug;\n \n use chalk_ir::{cast::Cast, fold::shift::Shift, CanonicalVarKinds};\n@@ -106,7 +107,9 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         };\n \n         fn local_impls(db: &dyn HirDatabase, module: ModuleId) -> Option<Arc<TraitImpls>> {\n-            db.trait_impls_in_block(module.containing_block()?)\n+            let block = module.containing_block()?;\n+            hit!(block_local_impls);\n+            db.trait_impls_in_block(block)\n         }\n \n         // Note: Since we're using impls_for_trait, only impls where the trait"}, {"sha": "b99a03492b9ecefd54f274a3429d4a5d28776f32", "filename": "crates/hir_ty/src/test_db.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -86,16 +86,20 @@ impl FileLoader for TestDB {\n }\n \n impl TestDB {\n-    pub(crate) fn module_for_file(&self, file_id: FileId) -> ModuleId {\n+    pub(crate) fn module_for_file_opt(&self, file_id: FileId) -> Option<ModuleId> {\n         for &krate in self.relevant_crates(file_id).iter() {\n             let crate_def_map = self.crate_def_map(krate);\n             for (local_id, data) in crate_def_map.modules() {\n                 if data.origin.file_id() == Some(file_id) {\n-                    return crate_def_map.module_id(local_id);\n+                    return Some(crate_def_map.module_id(local_id));\n                 }\n             }\n         }\n-        panic!(\"Can't find module for file\")\n+        None\n+    }\n+\n+    pub(crate) fn module_for_file(&self, file_id: FileId) -> ModuleId {\n+        self.module_for_file_opt(file_id).unwrap()\n     }\n \n     pub(crate) fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {"}, {"sha": "0651f34ae6cca512f296671d84398e6faae94c6d", "filename": "crates/hir_ty/src/tests.rs", "status": "modified", "additions": 142, "deletions": 93, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -11,23 +11,21 @@ mod incremental;\n \n use std::{collections::HashMap, env, sync::Arc};\n \n-use base_db::{fixture::WithFixture, FileRange, SourceDatabase, SourceDatabaseExt};\n+use base_db::{fixture::WithFixture, FileRange, SourceDatabaseExt};\n use expect_test::Expect;\n use hir_def::{\n     body::{Body, BodySourceMap, SyntheticSyntax},\n-    child_by_source::ChildBySource,\n     db::DefDatabase,\n+    expr::{ExprId, PatId},\n     item_scope::ItemScope,\n-    keys,\n     nameres::DefMap,\n     src::HasSource,\n-    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n+    AssocItemId, DefWithBodyId, HasModule, LocalModuleId, Lookup, ModuleDefId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n use once_cell::race::OnceBool;\n use stdx::format_to;\n use syntax::{\n-    algo,\n     ast::{self, AstNode, NameOwner},\n     SyntaxNode,\n };\n@@ -59,51 +57,55 @@ fn setup_tracing() -> Option<tracing::subscriber::DefaultGuard> {\n }\n \n fn check_types(ra_fixture: &str) {\n-    check_types_impl(ra_fixture, false)\n+    check_impl(ra_fixture, false, true, false)\n }\n \n fn check_types_source_code(ra_fixture: &str) {\n-    check_types_impl(ra_fixture, true)\n-}\n-\n-fn check_types_impl(ra_fixture: &str, display_source: bool) {\n-    let _tracing = setup_tracing();\n-    let db = TestDB::with_files(ra_fixture);\n-    let mut checked_one = false;\n-    for (file_id, annotations) in db.extract_annotations() {\n-        for (range, expected) in annotations {\n-            let ty = type_at_range(&db, FileRange { file_id, range });\n-            let actual = if display_source {\n-                let module = db.module_for_file(file_id);\n-                ty.display_source_code(&db, module).unwrap()\n-            } else {\n-                ty.display_test(&db).to_string()\n-            };\n-            assert_eq!(expected, actual);\n-            checked_one = true;\n-        }\n-    }\n-\n-    assert!(checked_one, \"no `//^` annotations found\");\n+    check_impl(ra_fixture, false, true, true)\n }\n \n fn check_no_mismatches(ra_fixture: &str) {\n-    check_mismatches_impl(ra_fixture, true)\n+    check_impl(ra_fixture, true, false, false)\n }\n \n-#[allow(unused)]\n-fn check_mismatches(ra_fixture: &str) {\n-    check_mismatches_impl(ra_fixture, false)\n+fn check(ra_fixture: &str) {\n+    check_impl(ra_fixture, false, false, false)\n }\n \n-fn check_mismatches_impl(ra_fixture: &str, allow_none: bool) {\n+fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_source: bool) {\n     let _tracing = setup_tracing();\n-    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n-    let module = db.module_for_file(file_id);\n-    let def_map = module.def_map(&db);\n+    let (db, files) = TestDB::with_many_files(ra_fixture);\n+\n+    let mut had_annotations = false;\n+    let mut mismatches = HashMap::new();\n+    let mut types = HashMap::new();\n+    for (file_id, annotations) in db.extract_annotations() {\n+        for (range, expected) in annotations {\n+            let file_range = FileRange { file_id, range };\n+            if only_types {\n+                types.insert(file_range, expected);\n+            } else if expected.starts_with(\"type: \") {\n+                types.insert(file_range, expected.trim_start_matches(\"type: \").to_string());\n+            } else if expected.starts_with(\"expected\") {\n+                mismatches.insert(file_range, expected);\n+            } else {\n+                panic!(\"unexpected annotation: {}\", expected);\n+            }\n+            had_annotations = true;\n+        }\n+    }\n+    assert!(had_annotations || allow_none, \"no `//^` annotations found\");\n \n     let mut defs: Vec<DefWithBodyId> = Vec::new();\n-    visit_module(&db, &def_map, module.local_id, &mut |it| defs.push(it));\n+    for file_id in files {\n+        let module = db.module_for_file_opt(file_id);\n+        let module = match module {\n+            Some(m) => m,\n+            None => continue,\n+        };\n+        let def_map = module.def_map(&db);\n+        visit_module(&db, &def_map, module.local_id, &mut |it| defs.push(it));\n+    }\n     defs.sort_by_key(|def| match def {\n         DefWithBodyId::FunctionId(it) => {\n             let loc = it.lookup(&db);\n@@ -118,37 +120,59 @@ fn check_mismatches_impl(ra_fixture: &str, allow_none: bool) {\n             loc.source(&db).value.syntax().text_range().start()\n         }\n     });\n-    let mut mismatches = HashMap::new();\n-    let mut push_mismatch = |src_ptr: InFile<SyntaxNode>, mismatch: TypeMismatch| {\n-        let range = src_ptr.value.text_range();\n-        if src_ptr.file_id.call_node(&db).is_some() {\n-            panic!(\"type mismatch in macro expansion\");\n-        }\n-        let file_range = FileRange { file_id: src_ptr.file_id.original_file(&db), range };\n-        let actual = format!(\n-            \"expected {}, got {}\",\n-            mismatch.expected.display_test(&db),\n-            mismatch.actual.display_test(&db)\n-        );\n-        mismatches.insert(file_range, actual);\n-    };\n+    let mut unexpected_type_mismatches = String::new();\n     for def in defs {\n         let (_body, body_source_map) = db.body_with_source_map(def);\n         let inference_result = db.infer(def);\n+\n+        for (pat, ty) in inference_result.type_of_pat.iter() {\n+            let node = match pat_node(&body_source_map, pat, &db) {\n+                Some(value) => value,\n+                None => continue,\n+            };\n+            let range = node.as_ref().original_file_range(&db);\n+            if let Some(expected) = types.remove(&range) {\n+                let actual = if display_source {\n+                    ty.display_source_code(&db, def.module(&db)).unwrap()\n+                } else {\n+                    ty.display_test(&db).to_string()\n+                };\n+                assert_eq!(actual, expected);\n+            }\n+        }\n+\n+        for (expr, ty) in inference_result.type_of_expr.iter() {\n+            let node = match expr_node(&body_source_map, expr, &db) {\n+                Some(value) => value,\n+                None => continue,\n+            };\n+            let range = node.as_ref().original_file_range(&db);\n+            if let Some(expected) = types.remove(&range) {\n+                let actual = if display_source {\n+                    ty.display_source_code(&db, def.module(&db)).unwrap()\n+                } else {\n+                    ty.display_test(&db).to_string()\n+                };\n+                assert_eq!(actual, expected);\n+            }\n+        }\n+\n         for (pat, mismatch) in inference_result.pat_type_mismatches() {\n-            let syntax_ptr = match body_source_map.pat_syntax(pat) {\n-                Ok(sp) => {\n-                    let root = db.parse_or_expand(sp.file_id).unwrap();\n-                    sp.map(|ptr| {\n-                        ptr.either(\n-                            |it| it.to_node(&root).syntax().clone(),\n-                            |it| it.to_node(&root).syntax().clone(),\n-                        )\n-                    })\n-                }\n-                Err(SyntheticSyntax) => continue,\n+            let node = match pat_node(&body_source_map, pat, &db) {\n+                Some(value) => value,\n+                None => continue,\n             };\n-            push_mismatch(syntax_ptr, mismatch.clone());\n+            let range = node.as_ref().original_file_range(&db);\n+            let actual = format!(\n+                \"expected {}, got {}\",\n+                mismatch.expected.display_test(&db),\n+                mismatch.actual.display_test(&db)\n+            );\n+            if let Some(annotation) = mismatches.remove(&range) {\n+                assert_eq!(actual, annotation);\n+            } else {\n+                format_to!(unexpected_type_mismatches, \"{:?}: {}\\n\", range.range, actual);\n+            }\n         }\n         for (expr, mismatch) in inference_result.expr_type_mismatches() {\n             let node = match body_source_map.expr_syntax(expr) {\n@@ -158,45 +182,70 @@ fn check_mismatches_impl(ra_fixture: &str, allow_none: bool) {\n                 }\n                 Err(SyntheticSyntax) => continue,\n             };\n-            push_mismatch(node, mismatch.clone());\n-        }\n-    }\n-    let mut checked_one = false;\n-    for (file_id, annotations) in db.extract_annotations() {\n-        for (range, expected) in annotations {\n-            let file_range = FileRange { file_id, range };\n-            if let Some(mismatch) = mismatches.remove(&file_range) {\n-                assert_eq!(mismatch, expected);\n+            let range = node.as_ref().original_file_range(&db);\n+            let actual = format!(\n+                \"expected {}, got {}\",\n+                mismatch.expected.display_test(&db),\n+                mismatch.actual.display_test(&db)\n+            );\n+            if let Some(annotation) = mismatches.remove(&range) {\n+                assert_eq!(actual, annotation);\n             } else {\n-                assert!(false, \"Expected mismatch not encountered: {}\\n\", expected);\n+                format_to!(unexpected_type_mismatches, \"{:?}: {}\\n\", range.range, actual);\n             }\n-            checked_one = true;\n         }\n     }\n+\n     let mut buf = String::new();\n-    for (range, mismatch) in mismatches {\n-        format_to!(buf, \"{:?}: {}\\n\", range.range, mismatch,);\n+    if !unexpected_type_mismatches.is_empty() {\n+        format_to!(buf, \"Unexpected type mismatches:\\n{}\", unexpected_type_mismatches);\n+    }\n+    if !mismatches.is_empty() {\n+        format_to!(buf, \"Unchecked mismatch annotations:\\n\");\n+        for m in mismatches {\n+            format_to!(buf, \"{:?}: {}\\n\", m.0.range, m.1);\n+        }\n     }\n-    assert!(buf.is_empty(), \"Unexpected type mismatches:\\n{}\", buf);\n+    if !types.is_empty() {\n+        format_to!(buf, \"Unchecked type annotations:\\n\");\n+        for t in types {\n+            format_to!(buf, \"{:?}: type {}\\n\", t.0.range, t.1);\n+        }\n+    }\n+    assert!(buf.is_empty(), \"{}\", buf);\n+}\n \n-    assert!(checked_one || allow_none, \"no `//^` annotations found\");\n+fn expr_node(\n+    body_source_map: &BodySourceMap,\n+    expr: ExprId,\n+    db: &TestDB,\n+) -> Option<InFile<SyntaxNode>> {\n+    Some(match body_source_map.expr_syntax(expr) {\n+        Ok(sp) => {\n+            let root = db.parse_or_expand(sp.file_id).unwrap();\n+            sp.map(|ptr| ptr.to_node(&root).syntax().clone())\n+        }\n+        Err(SyntheticSyntax) => return None,\n+    })\n }\n \n-fn type_at_range(db: &TestDB, pos: FileRange) -> Ty {\n-    let file = db.parse(pos.file_id).ok().unwrap();\n-    let expr = algo::find_node_at_range::<ast::Expr>(file.syntax(), pos.range).unwrap();\n-    let fn_def = expr.syntax().ancestors().find_map(ast::Fn::cast).unwrap();\n-    let module = db.module_for_file(pos.file_id);\n-    let func = *module.child_by_source(db)[keys::FUNCTION]\n-        .get(&InFile::new(pos.file_id.into(), fn_def))\n-        .unwrap();\n-\n-    let (_body, source_map) = db.body_with_source_map(func.into());\n-    if let Some(expr_id) = source_map.node_expr(InFile::new(pos.file_id.into(), &expr)) {\n-        let infer = db.infer(func.into());\n-        return infer[expr_id].clone();\n-    }\n-    panic!(\"Can't find expression\")\n+fn pat_node(\n+    body_source_map: &BodySourceMap,\n+    pat: PatId,\n+    db: &TestDB,\n+) -> Option<InFile<SyntaxNode>> {\n+    Some(match body_source_map.pat_syntax(pat) {\n+        Ok(sp) => {\n+            let root = db.parse_or_expand(sp.file_id).unwrap();\n+            sp.map(|ptr| {\n+                ptr.either(\n+                    |it| it.to_node(&root).syntax().clone(),\n+                    |it| it.to_node(&root).syntax().clone(),\n+                )\n+            })\n+        }\n+        Err(SyntheticSyntax) => return None,\n+    })\n }\n \n fn infer(ra_fixture: &str) -> String {"}, {"sha": "87089f09d13fe96c11e965b3af9c0e0556dc6b89", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 119, "deletions": 554, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -1,27 +1,22 @@\n-use expect_test::expect;\n-\n-use super::{check_infer, check_infer_with_mismatches, check_no_mismatches, check_types};\n+use super::{check, check_no_mismatches, check_types};\n \n #[test]\n-fn infer_block_expr_type_mismatch() {\n-    check_infer(\n+fn block_expr_type_mismatch() {\n+    // FIXME fix double type mismatch\n+    check(\n         r\"\n-        fn test() {\n-            let a: i32 = { 1i64 };\n-        }\n+fn test() {\n+    let a: i32 = { 1i64 };\n+              // ^^^^^^^^ expected i32, got i64\n+                // ^^^^ expected i32, got i64\n+}\n         \",\n-        expect![[r\"\n-            10..40 '{     ...4 }; }': ()\n-            20..21 'a': i32\n-            29..37 '{ 1i64 }': i64\n-            31..35 '1i64': i64\n-        \"]],\n     );\n }\n \n #[test]\n fn coerce_places() {\n-    check_infer(\n+    check_no_mismatches(\n         r#\"\n //- minicore: coerce_unsized\n struct S<T> { a: T }\n@@ -46,81 +41,25 @@ fn test2() {\n     let g: (&[_], &[_]) = (arr, arr);\n }\n \"#,\n-        expect![[r#\"\n-            30..31 '_': &[T]\n-            44..55 '{ loop {} }': T\n-            46..53 'loop {}': !\n-            51..53 '{}': ()\n-            64..65 '_': S<&[T]>\n-            81..92 '{ loop {} }': T\n-            83..90 'loop {}': !\n-            88..90 '{}': ()\n-            121..132 '{ loop {} }': *mut [T; 2]\n-            123..130 'loop {}': !\n-            128..130 '{}': ()\n-            159..172 '{     gen() }': *mut [U]\n-            165..168 'gen': fn gen<U>() -> *mut [U; 2]\n-            165..170 'gen()': *mut [U; 2]\n-            185..419 '{     ...rr); }': ()\n-            195..198 'arr': &[u8; 1]\n-            211..215 '&[1]': &[u8; 1]\n-            212..215 '[1]': [u8; 1]\n-            213..214 '1': u8\n-            226..227 'a': &[u8]\n-            236..239 'arr': &[u8; 1]\n-            249..250 'b': u8\n-            253..254 'f': fn f<u8>(&[u8]) -> u8\n-            253..259 'f(arr)': u8\n-            255..258 'arr': &[u8; 1]\n-            269..270 'c': &[u8]\n-            279..286 '{ arr }': &[u8]\n-            281..284 'arr': &[u8; 1]\n-            296..297 'd': u8\n-            300..301 'g': fn g<u8>(S<&[u8]>) -> u8\n-            300..315 'g(S { a: arr })': u8\n-            302..314 'S { a: arr }': S<&[u8]>\n-            309..312 'arr': &[u8; 1]\n-            325..326 'e': [&[u8]; 1]\n-            340..345 '[arr]': [&[u8]; 1]\n-            341..344 'arr': &[u8; 1]\n-            355..356 'f': [&[u8]; 2]\n-            370..378 '[arr; 2]': [&[u8]; 2]\n-            371..374 'arr': &[u8; 1]\n-            376..377 '2': usize\n-            388..389 'g': (&[u8], &[u8])\n-            406..416 '(arr, arr)': (&[u8], &[u8])\n-            407..410 'arr': &[u8; 1]\n-            412..415 'arr': &[u8; 1]\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_let_stmt_coerce() {\n-    check_infer(\n+fn let_stmt_coerce() {\n+    check_no_mismatches(\n         r\"\n-        fn test() {\n-            let x: &[isize] = &[1];\n-            let x: *const [isize] = &[1];\n-        }\n-        \",\n-        expect![[r#\"\n-            10..75 '{     ...[1]; }': ()\n-            20..21 'x': &[isize]\n-            34..38 '&[1]': &[isize; 1]\n-            35..38 '[1]': [isize; 1]\n-            36..37 '1': isize\n-            48..49 'x': *const [isize]\n-            68..72 '&[1]': &[isize; 1]\n-            69..72 '[1]': [isize; 1]\n-            70..71 '1': isize\n-        \"#]],\n+//- minicore: coerce_unsized\n+fn test() {\n+    let x: &[isize] = &[1];\n+    let x: *const [isize] = &[1];\n+}\n+\",\n     );\n }\n \n #[test]\n-fn infer_custom_coerce_unsized() {\n-    check_infer(\n+fn custom_coerce_unsized() {\n+    check(\n         r#\"\n //- minicore: coerce_unsized\n use core::{marker::Unsize, ops::CoerceUnsized};\n@@ -138,46 +77,22 @@ fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n \n fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n     let d = foo1(a);\n+              // ^ expected A<[{unknown}]>, got A<[u8; 2]>\n     let e = foo2(b);\n+     // ^ type: B<[u8]>\n     let f = foo3(c);\n+     // ^ type: C<[u8]>\n }\n \"#,\n-        expect![[r#\"\n-            306..307 'x': A<[T]>\n-            327..332 '{ x }': A<[T]>\n-            329..330 'x': A<[T]>\n-            344..345 'x': B<[T]>\n-            365..370 '{ x }': B<[T]>\n-            367..368 'x': B<[T]>\n-            382..383 'x': C<[T]>\n-            403..408 '{ x }': C<[T]>\n-            405..406 'x': C<[T]>\n-            418..419 'a': A<[u8; 2]>\n-            433..434 'b': B<[u8; 2]>\n-            448..449 'c': C<[u8; 2]>\n-            463..529 '{     ...(c); }': ()\n-            473..474 'd': A<[{unknown}]>\n-            477..481 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n-            477..484 'foo1(a)': A<[{unknown}]>\n-            482..483 'a': A<[u8; 2]>\n-            494..495 'e': B<[u8]>\n-            498..502 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n-            498..505 'foo2(b)': B<[u8]>\n-            503..504 'b': B<[u8; 2]>\n-            515..516 'f': C<[u8]>\n-            519..523 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n-            519..526 'foo3(c)': C<[u8]>\n-            524..525 'c': C<[u8; 2]>\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_if_coerce() {\n-    check_infer(\n+fn if_coerce() {\n+    check_no_mismatches(\n         r#\"\n-//- minicore: unsize\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+//- minicore: coerce_unsized\n+fn foo<T>(x: &[T]) -> &[T] { x }\n fn test() {\n     let x = if true {\n         foo(&[1])\n@@ -186,35 +101,15 @@ fn test() {\n     };\n }\n \"#,\n-        expect![[r#\"\n-            10..11 'x': &[T]\n-            27..38 '{ loop {} }': &[T]\n-            29..36 'loop {}': !\n-            34..36 '{}': ()\n-            49..125 '{     ...  }; }': ()\n-            59..60 'x': &[i32]\n-            63..122 'if tru...     }': &[i32]\n-            66..70 'true': bool\n-            71..96 '{     ...     }': &[i32]\n-            81..84 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-            81..90 'foo(&[1])': &[i32]\n-            85..89 '&[1]': &[i32; 1]\n-            86..89 '[1]': [i32; 1]\n-            87..88 '1': i32\n-            102..122 '{     ...     }': &[i32; 1]\n-            112..116 '&[1]': &[i32; 1]\n-            113..116 '[1]': [i32; 1]\n-            114..115 '1': i32\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_if_else_coerce() {\n-    check_infer(\n+fn if_else_coerce() {\n+    check_no_mismatches(\n         r#\"\n //- minicore: coerce_unsized\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn foo<T>(x: &[T]) -> &[T] { x }\n fn test() {\n     let x = if true {\n         &[1]\n@@ -223,35 +118,15 @@ fn test() {\n     };\n }\n \"#,\n-        expect![[r#\"\n-            10..11 'x': &[T]\n-            27..38 '{ loop {} }': &[T]\n-            29..36 'loop {}': !\n-            34..36 '{}': ()\n-            49..125 '{     ...  }; }': ()\n-            59..60 'x': &[i32]\n-            63..122 'if tru...     }': &[i32]\n-            66..70 'true': bool\n-            71..91 '{     ...     }': &[i32; 1]\n-            81..85 '&[1]': &[i32; 1]\n-            82..85 '[1]': [i32; 1]\n-            83..84 '1': i32\n-            97..122 '{     ...     }': &[i32]\n-            107..110 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-            107..116 'foo(&[1])': &[i32]\n-            111..115 '&[1]': &[i32; 1]\n-            112..115 '[1]': [i32; 1]\n-            113..114 '1': i32\n-        \"#]],\n     )\n }\n \n #[test]\n-fn infer_match_first_coerce() {\n-    check_infer(\n+fn match_first_coerce() {\n+    check_no_mismatches(\n         r#\"\n-//- minicore: unsize\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+//- minicore: coerce_unsized\n+fn foo<T>(x: &[T]) -> &[T] { x }\n fn test(i: i32) {\n     let x = match i {\n         2 => foo(&[2]),\n@@ -260,39 +135,12 @@ fn test(i: i32) {\n     };\n }\n \"#,\n-        expect![[r#\"\n-            10..11 'x': &[T]\n-            27..38 '{ loop {} }': &[T]\n-            29..36 'loop {}': !\n-            34..36 '{}': ()\n-            47..48 'i': i32\n-            55..149 '{     ...  }; }': ()\n-            65..66 'x': &[i32]\n-            69..146 'match ...     }': &[i32]\n-            75..76 'i': i32\n-            87..88 '2': i32\n-            87..88 '2': i32\n-            92..95 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-            92..101 'foo(&[2])': &[i32]\n-            96..100 '&[2]': &[i32; 1]\n-            97..100 '[2]': [i32; 1]\n-            98..99 '2': i32\n-            111..112 '1': i32\n-            111..112 '1': i32\n-            116..120 '&[1]': &[i32; 1]\n-            117..120 '[1]': [i32; 1]\n-            118..119 '1': i32\n-            130..131 '_': i32\n-            135..139 '&[3]': &[i32; 1]\n-            136..139 '[3]': [i32; 1]\n-            137..138 '3': i32\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_match_second_coerce() {\n-    check_infer(\n+fn match_second_coerce() {\n+    check_no_mismatches(\n         r#\"\n //- minicore: coerce_unsized\n fn foo<T>(x: &[T]) -> &[T] { loop {} }\n@@ -304,128 +152,59 @@ fn test(i: i32) {\n     };\n }\n \"#,\n-        expect![[r#\"\n-            10..11 'x': &[T]\n-            27..38 '{ loop {} }': &[T]\n-            29..36 'loop {}': !\n-            34..36 '{}': ()\n-            47..48 'i': i32\n-            55..149 '{     ...  }; }': ()\n-            65..66 'x': &[i32]\n-            69..146 'match ...     }': &[i32]\n-            75..76 'i': i32\n-            87..88 '1': i32\n-            87..88 '1': i32\n-            92..96 '&[1]': &[i32; 1]\n-            93..96 '[1]': [i32; 1]\n-            94..95 '1': i32\n-            106..107 '2': i32\n-            106..107 '2': i32\n-            111..114 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-            111..120 'foo(&[2])': &[i32]\n-            115..119 '&[2]': &[i32; 1]\n-            116..119 '[2]': [i32; 1]\n-            117..118 '2': i32\n-            130..131 '_': i32\n-            135..139 '&[3]': &[i32; 1]\n-            136..139 '[3]': [i32; 1]\n-            137..138 '3': i32\n-        \"#]],\n     );\n }\n \n #[test]\n fn coerce_merge_one_by_one1() {\n     cov_mark::check!(coerce_merge_fail_fallback);\n \n-    check_infer(\n+    check(\n         r\"\n-        fn test() {\n-            let t = &mut 1;\n-            let x = match 1 {\n-                1 => t as *mut i32,\n-                2 => t as &i32,\n-                _ => t as *const i32,\n-            };\n-        }\n+fn test() {\n+    let t = &mut 1;\n+    let x = match 1 {\n+        1 => t as *mut i32,\n+        2 => t as &i32,\n+           //^^^^^^^^^ expected *mut i32, got &i32\n+        _ => t as *const i32,\n+    };\n+    x;\n+  //^ type: *const i32\n+}\n         \",\n-        expect![[r\"\n-            10..144 '{     ...  }; }': ()\n-            20..21 't': &mut i32\n-            24..30 '&mut 1': &mut i32\n-            29..30 '1': i32\n-            40..41 'x': *const i32\n-            44..141 'match ...     }': *const i32\n-            50..51 '1': i32\n-            62..63 '1': i32\n-            62..63 '1': i32\n-            67..68 't': &mut i32\n-            67..80 't as *mut i32': *mut i32\n-            90..91 '2': i32\n-            90..91 '2': i32\n-            95..96 't': &mut i32\n-            95..104 't as &i32': &i32\n-            114..115 '_': i32\n-            119..120 't': &mut i32\n-            119..134 't as *const i32': *const i32\n-    \"]],\n     );\n }\n \n #[test]\n fn return_coerce_unknown() {\n-    check_infer_with_mismatches(\n+    check_types(\n         r\"\n-        fn foo() -> u32 {\n-            return unknown;\n-        }\n+fn foo() -> u32 {\n+    return unknown;\n+         //^^^^^^^ u32\n+}\n         \",\n-        expect![[r\"\n-            16..39 '{     ...own; }': u32\n-            22..36 'return unknown': !\n-            29..36 'unknown': u32\n-        \"]],\n     );\n }\n \n #[test]\n fn coerce_autoderef() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        struct Foo;\n-        fn takes_ref_foo(x: &Foo) {}\n-        fn test() {\n-            takes_ref_foo(&Foo);\n-            takes_ref_foo(&&Foo);\n-            takes_ref_foo(&&&Foo);\n-        }\n-        \",\n-        expect![[r\"\n-            29..30 'x': &Foo\n-            38..40 '{}': ()\n-            51..132 '{     ...oo); }': ()\n-            57..70 'takes_ref_foo': fn takes_ref_foo(&Foo)\n-            57..76 'takes_...(&Foo)': ()\n-            71..75 '&Foo': &Foo\n-            72..75 'Foo': Foo\n-            82..95 'takes_ref_foo': fn takes_ref_foo(&Foo)\n-            82..102 'takes_...&&Foo)': ()\n-            96..101 '&&Foo': &&Foo\n-            97..101 '&Foo': &Foo\n-            98..101 'Foo': Foo\n-            108..121 'takes_ref_foo': fn takes_ref_foo(&Foo)\n-            108..129 'takes_...&&Foo)': ()\n-            122..128 '&&&Foo': &&&Foo\n-            123..128 '&&Foo': &&Foo\n-            124..128 '&Foo': &Foo\n-            125..128 'Foo': Foo\n-        \"]],\n+struct Foo;\n+fn takes_ref_foo(x: &Foo) {}\n+fn test() {\n+    takes_ref_foo(&Foo);\n+    takes_ref_foo(&&Foo);\n+    takes_ref_foo(&&&Foo);\n+}\",\n     );\n }\n \n #[test]\n fn coerce_autoderef_generic() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r#\"\n struct Foo;\n fn takes_ref<T>(x: &T) -> T { *x }\n@@ -435,34 +214,12 @@ fn test() {\n     takes_ref(&&&Foo);\n }\n \"#,\n-        expect![[r\"\n-            28..29 'x': &T\n-            40..46 '{ *x }': T\n-            42..44 '*x': T\n-            43..44 'x': &T\n-            57..126 '{     ...oo); }': ()\n-            63..72 'takes_ref': fn takes_ref<Foo>(&Foo) -> Foo\n-            63..78 'takes_ref(&Foo)': Foo\n-            73..77 '&Foo': &Foo\n-            74..77 'Foo': Foo\n-            84..93 'takes_ref': fn takes_ref<&Foo>(&&Foo) -> &Foo\n-            84..100 'takes_...&&Foo)': &Foo\n-            94..99 '&&Foo': &&Foo\n-            95..99 '&Foo': &Foo\n-            96..99 'Foo': Foo\n-            106..115 'takes_ref': fn takes_ref<&&Foo>(&&&Foo) -> &&Foo\n-            106..123 'takes_...&&Foo)': &&Foo\n-            116..122 '&&&Foo': &&&Foo\n-            117..122 '&&Foo': &&Foo\n-            118..122 '&Foo': &Foo\n-            119..122 'Foo': Foo\n-        \"]],\n     );\n }\n \n #[test]\n fn coerce_autoderef_block() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r#\"\n //- minicore: deref\n struct String {}\n@@ -473,182 +230,95 @@ fn test() {\n     takes_ref_str(&{ returns_string() });\n }\n \"#,\n-        expect![[r#\"\n-            90..91 'x': &str\n-            99..101 '{}': ()\n-            132..143 '{ loop {} }': String\n-            134..141 'loop {}': !\n-            139..141 '{}': ()\n-            154..199 '{     ... }); }': ()\n-            160..173 'takes_ref_str': fn takes_ref_str(&str)\n-            160..196 'takes_...g() })': ()\n-            174..195 '&{ ret...ng() }': &String\n-            175..195 '{ retu...ng() }': String\n-            177..191 'returns_string': fn returns_string() -> String\n-            177..193 'return...ring()': String\n-        \"#]],\n     );\n }\n \n #[test]\n fn closure_return_coerce() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        fn foo() {\n-            let x = || {\n-                if true {\n-                    return &1u32;\n-                }\n-                &&1u32\n-            };\n+fn foo() {\n+    let x = || {\n+        if true {\n+            return &1u32;\n         }\n-        \",\n-        expect![[r\"\n-            9..105 '{     ...  }; }': ()\n-            19..20 'x': || -> &u32\n-            23..102 '|| {  ...     }': || -> &u32\n-            26..102 '{     ...     }': &u32\n-            36..81 'if tru...     }': ()\n-            39..43 'true': bool\n-            44..81 '{     ...     }': ()\n-            58..70 'return &1u32': !\n-            65..70 '&1u32': &u32\n-            66..70 '1u32': u32\n-            90..96 '&&1u32': &&u32\n-            91..96 '&1u32': &u32\n-            92..96 '1u32': u32\n-        \"]],\n+        &&1u32\n+    };\n+}\",\n     );\n }\n \n #[test]\n fn coerce_fn_item_to_fn_ptr() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        fn foo(x: u32) -> isize { 1 }\n-        fn test() {\n-            let f: fn(u32) -> isize = foo;\n-        }\n-        \",\n-        expect![[r\"\n-            7..8 'x': u32\n-            24..29 '{ 1 }': isize\n-            26..27 '1': isize\n-            40..78 '{     ...foo; }': ()\n-            50..51 'f': fn(u32) -> isize\n-            72..75 'foo': fn foo(u32) -> isize\n-        \"]],\n+fn foo(x: u32) -> isize { 1 }\n+fn test() {\n+    let f: fn(u32) -> isize = foo;\n+}\",\n     );\n }\n \n #[test]\n fn coerce_fn_items_in_match_arms() {\n     cov_mark::check!(coerce_fn_reification);\n \n-    check_infer_with_mismatches(\n+    check_types(\n         r\"\n-        fn foo1(x: u32) -> isize { 1 }\n-        fn foo2(x: u32) -> isize { 2 }\n-        fn foo3(x: u32) -> isize { 3 }\n-        fn test() {\n-            let x = match 1 {\n-                1 => foo1,\n-                2 => foo2,\n-                _ => foo3,\n-            };\n-        }\n-        \",\n-        expect![[r\"\n-            8..9 'x': u32\n-            25..30 '{ 1 }': isize\n-            27..28 '1': isize\n-            39..40 'x': u32\n-            56..61 '{ 2 }': isize\n-            58..59 '2': isize\n-            70..71 'x': u32\n-            87..92 '{ 3 }': isize\n-            89..90 '3': isize\n-            103..192 '{     ...  }; }': ()\n-            113..114 'x': fn(u32) -> isize\n-            117..189 'match ...     }': fn(u32) -> isize\n-            123..124 '1': i32\n-            135..136 '1': i32\n-            135..136 '1': i32\n-            140..144 'foo1': fn foo1(u32) -> isize\n-            154..155 '2': i32\n-            154..155 '2': i32\n-            159..163 'foo2': fn foo2(u32) -> isize\n-            173..174 '_': i32\n-            178..182 'foo3': fn foo3(u32) -> isize\n-        \"]],\n+fn foo1(x: u32) -> isize { 1 }\n+fn foo2(x: u32) -> isize { 2 }\n+fn foo3(x: u32) -> isize { 3 }\n+fn test() {\n+    let x = match 1 {\n+        1 => foo1,\n+        2 => foo2,\n+        _ => foo3,\n+    };\n+    x;\n+  //^ fn(u32) -> isize\n+}\",\n     );\n }\n \n #[test]\n fn coerce_closure_to_fn_ptr() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        fn test() {\n-            let f: fn(u32) -> isize = |x| { 1 };\n-        }\n-        \",\n-        expect![[r\"\n-            10..54 '{     ...1 }; }': ()\n-            20..21 'f': fn(u32) -> isize\n-            42..51 '|x| { 1 }': |u32| -> isize\n-            43..44 'x': u32\n-            46..51 '{ 1 }': isize\n-            48..49 '1': isize\n-        \"]],\n+fn test() {\n+    let f: fn(u32) -> isize = |x| { 1 };\n+}\",\n     );\n }\n \n #[test]\n fn coerce_placeholder_ref() {\n     // placeholders should unify, even behind references\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        struct S<T> { t: T }\n-        impl<TT> S<TT> {\n-            fn get(&self) -> &TT {\n-                &self.t\n-            }\n-        }\n-        \",\n-        expect![[r\"\n-            50..54 'self': &S<TT>\n-            63..86 '{     ...     }': &TT\n-            73..80 '&self.t': &TT\n-            74..78 'self': &S<TT>\n-            74..80 'self.t': TT\n-        \"]],\n+struct S<T> { t: T }\n+impl<TT> S<TT> {\n+    fn get(&self) -> &TT {\n+        &self.t\n+    }\n+}\",\n     );\n }\n \n #[test]\n fn coerce_unsize_array() {\n-    check_infer_with_mismatches(\n+    check_types(\n         r#\"\n //- minicore: coerce_unsized\n fn test() {\n     let f: &[usize] = &[1, 2, 3];\n-}\n-        \"#,\n-        expect![[r#\"\n-            10..47 '{     ... 3]; }': ()\n-            20..21 'f': &[usize]\n-            34..44 '&[1, 2, 3]': &[usize; 3]\n-            35..44 '[1, 2, 3]': [usize; 3]\n-            36..37 '1': usize\n-            39..40 '2': usize\n-            42..43 '3': usize\n-        \"#]],\n+                      //^ usize\n+}\"#,\n     );\n }\n \n #[test]\n fn coerce_unsize_trait_object_simple() {\n-    check_infer_with_mismatches(\n+    check_types(\n         r#\"\n //- minicore: coerce_unsized\n trait Foo<T, U> {}\n@@ -662,88 +332,18 @@ impl<T, X> Baz<T, X> for S<T, X> {}\n \n fn test() {\n     let obj: &dyn Baz<i8, i16> = &S;\n+                                //^ S<i8, i16>\n     let obj: &dyn Bar<_, i8, i16> = &S;\n+                                   //^ S<i8, i16>\n     let obj: &dyn Foo<i8, _> = &S;\n-}\n-\"#,\n-        expect![[r#\"\n-            236..351 '{     ... &S; }': ()\n-            246..249 'obj': &dyn Baz<i8, i16>\n-            271..273 '&S': &S<i8, i16>\n-            272..273 'S': S<i8, i16>\n-            283..286 'obj': &dyn Bar<usize, i8, i16>\n-            311..313 '&S': &S<i8, i16>\n-            312..313 'S': S<i8, i16>\n-            323..326 'obj': &dyn Foo<i8, usize>\n-            346..348 '&S': &S<i8, {unknown}>\n-            347..348 'S': S<i8, {unknown}>\n-        \"#]],\n-    );\n-}\n-\n-#[test]\n-fn coerce_unsize_trait_object_to_trait_object() {\n-    // FIXME: The rust reference says this should be possible, but rustc doesn't\n-    // implement it. We used to support it, but Chalk doesn't. Here's the\n-    // correct expect:\n-    //\n-    //     424..609 '{     ...bj2; }': ()\n-    //     434..437 'obj': &dyn Baz<i8, i16>\n-    //     459..461 '&S': &S<i8, i16>\n-    //     460..461 'S': S<i8, i16>\n-    //     471..474 'obj': &dyn Bar<usize, i8, i16>\n-    //     496..499 'obj': &dyn Baz<i8, i16>\n-    //     509..512 'obj': &dyn Foo<i8, usize>\n-    //     531..534 'obj': &dyn Bar<usize, i8, i16>\n-    //     544..548 'obj2': &dyn Baz<i8, i16>\n-    //     570..572 '&S': &S<i8, i16>\n-    //     571..572 'S': S<i8, i16>\n-    //     582..583 '_': &dyn Foo<i8, usize>\n-    //     602..606 'obj2': &dyn Baz<i8, i16>\n-    check_infer_with_mismatches(\n-        r#\"\n-//- minicore: coerce_unsized\n-trait Foo<T, U> {}\n-trait Bar<U, T, X>: Foo<T, U> {}\n-trait Baz<T, X>: Bar<usize, T, X> {}\n-\n-struct S<T, X>;\n-impl<T, X> Foo<T, usize> for S<T, X> {}\n-impl<T, X> Bar<usize, T, X> for S<T, X> {}\n-impl<T, X> Baz<T, X> for S<T, X> {}\n-\n-fn test() {\n-    let obj: &dyn Baz<i8, i16> = &S;\n-    let obj: &dyn Bar<_, _, _> = obj;\n-    let obj: &dyn Foo<_, _> = obj;\n-    let obj2: &dyn Baz<i8, i16> = &S;\n-    let _: &dyn Foo<_, _> = obj2;\n-}\n-\"#,\n-        expect![[r#\"\n-            236..421 '{     ...bj2; }': ()\n-            246..249 'obj': &dyn Baz<i8, i16>\n-            271..273 '&S': &S<i8, i16>\n-            272..273 'S': S<i8, i16>\n-            283..286 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            308..311 'obj': &dyn Baz<i8, i16>\n-            321..324 'obj': &dyn Foo<{unknown}, {unknown}>\n-            343..346 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            356..360 'obj2': &dyn Baz<i8, i16>\n-            382..384 '&S': &S<i8, i16>\n-            383..384 'S': S<i8, i16>\n-            394..395 '_': &dyn Foo<{unknown}, {unknown}>\n-            414..418 'obj2': &dyn Baz<i8, i16>\n-            308..311: expected &dyn Bar<{unknown}, {unknown}, {unknown}>, got &dyn Baz<i8, i16>\n-            343..346: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            414..418: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Baz<i8, i16>\n-        \"#]],\n+                              //^ S<i8, {unknown}>\n+}\"#,\n     );\n }\n \n #[test]\n fn coerce_unsize_super_trait_cycle() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r#\"\n //- minicore: coerce_unsized\n trait A {}\n@@ -762,96 +362,61 @@ fn test() {\n     let obj: &dyn A = &S;\n }\n \"#,\n-        expect![[r#\"\n-            140..195 '{     ... &S; }': ()\n-            150..153 'obj': &dyn D\n-            164..166 '&S': &S\n-            165..166 'S': S\n-            176..179 'obj': &dyn A\n-            190..192 '&S': &S\n-            191..192 'S': S\n-        \"#]],\n     );\n }\n \n #[test]\n fn coerce_unsize_generic() {\n     // FIXME: fix the type mismatches here\n-    check_infer_with_mismatches(\n+    check(\n         r#\"\n //- minicore: coerce_unsized\n struct Foo<T> { t: T };\n struct Bar<T>(Foo<T>);\n \n fn test() {\n     let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n+                                   //^^^^^^^^^ expected [usize], got [usize; 3]\n     let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n+                         //^^^^^^^^^^^^^^^^^^^^^^^^^^ expected &Bar<[usize]>, got &Bar<[i32; 3]>\n }\n \"#,\n-        expect![[r#\"\n-            58..166 '{     ... }); }': ()\n-            68..69 '_': &Foo<[usize]>\n-            87..108 '&Foo {..., 3] }': &Foo<[usize]>\n-            88..108 'Foo { ..., 3] }': Foo<[usize]>\n-            97..106 '[1, 2, 3]': [usize; 3]\n-            98..99 '1': usize\n-            101..102 '2': usize\n-            104..105 '3': usize\n-            118..119 '_': &Bar<[usize]>\n-            137..163 '&Bar(F... 3] })': &Bar<[i32; 3]>\n-            138..141 'Bar': Bar<[i32; 3]>(Foo<[i32; 3]>) -> Bar<[i32; 3]>\n-            138..163 'Bar(Fo... 3] })': Bar<[i32; 3]>\n-            142..162 'Foo { ..., 3] }': Foo<[i32; 3]>\n-            151..160 '[1, 2, 3]': [i32; 3]\n-            152..153 '1': i32\n-            155..156 '2': i32\n-            158..159 '3': i32\n-            97..106: expected [usize], got [usize; 3]\n-            137..163: expected &Bar<[usize]>, got &Bar<[i32; 3]>\n-        \"#]],\n     );\n }\n \n #[test]\n fn coerce_unsize_apit() {\n     // FIXME: #8984\n-    check_infer_with_mismatches(\n+    check(\n         r#\"\n //- minicore: coerce_unsized\n trait Foo {}\n \n fn test(f: impl Foo) {\n     let _: &dyn Foo = &f;\n+                    //^^ expected &dyn Foo, got &impl Foo\n }\n         \"#,\n-        expect![[r#\"\n-            22..23 'f': impl Foo\n-            35..64 '{     ... &f; }': ()\n-            45..46 '_': &dyn Foo\n-            59..61 '&f': &impl Foo\n-            60..61 'f': impl Foo\n-            59..61: expected &dyn Foo, got &impl Foo\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_two_closures_lub() {\n+fn two_closures_lub() {\n     check_types(\n         r#\"\n fn foo(c: i32) {\n     let add = |a: i32, b: i32| a + b;\n     let sub = |a, b| a - b;\n-            //^ |i32, i32| -> i32\n+            //^^^^^^^^^^^^ |i32, i32| -> i32\n     if c > 42 { add } else { sub };\n-  //^ fn(i32, i32) -> i32\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ fn(i32, i32) -> i32\n }\n         \"#,\n     )\n }\n \n #[test]\n-fn infer_match_diverging_branch_1() {\n+fn match_diverging_branch_1() {\n     check_types(\n         r#\"\n enum Result<T> { Ok(T), Err }\n@@ -870,7 +435,7 @@ fn test() -> i32 {\n }\n \n #[test]\n-fn infer_match_diverging_branch_2() {\n+fn match_diverging_branch_2() {\n     // same as 1 except for order of branches\n     check_types(\n         r#\""}, {"sha": "058cd02d7a7aa2f218e77b18bc87b2f7a8077b25", "filename": "crates/hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -10,8 +10,8 @@ mod foo {\n \n fn bar() {\n     let foo: foo::Foo = foo::Foo;\n-    foo\n-}  //^ foo::Foo\n+    foo;\n+} //^^^ foo::Foo\n \n \"#,\n     );\n@@ -25,7 +25,7 @@ struct Foo<T = u8> { t: T }\n fn main() {\n     let foo = Foo { t: 5u8 };\n     foo;\n-}  //^ Foo\n+} //^^^ Foo\n \"#,\n     );\n \n@@ -35,7 +35,7 @@ struct Foo<K, T = u8> { k: K, t: T }\n fn main() {\n     let foo = Foo { k: 400, t: 5u8 };\n     foo;\n-}   //^ Foo<i32>\n+} //^^^ Foo<i32>\n \"#,\n     );\n }\n@@ -50,7 +50,7 @@ fn foo() -> *const (impl Unpin + Sized) { loop {} }\n fn main() {\n     let foo = foo();\n     foo;\n-}   //^ *const (impl Unpin + Sized)\n+} //^^^ *const (impl Unpin + Sized)\n \"#,\n     );\n }"}, {"sha": "2cf41e49e1b6313b50fe26b0f65a4846e47046a5", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -435,11 +435,11 @@ fn processes_impls_generated_by_macros() {\n macro_rules! m {\n     ($ident:ident) => (impl Trait for $ident {})\n }\n-trait Trait { fn foo(self) -> u128 {} }\n+trait Trait { fn foo(self) -> u128 { 0 } }\n struct S;\n m!(S);\n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -457,7 +457,7 @@ impl S {\n }\n \n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -479,7 +479,7 @@ impl S {\n }\n \n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -743,7 +743,7 @@ include!(\"foo.rs\");\n \n fn main() {\n     bar();\n-}     //^ u32\n+} //^^^^^ u32\n \n //- /foo.rs\n fn bar() -> u32 {0}\n@@ -781,7 +781,7 @@ include!(\"f/foo.rs\");\n \n fn main() {\n     bar::bar();\n-}          //^ u32\n+} //^^^^^^^^^^ u32\n \n //- /f/foo.rs\n pub mod bar;\n@@ -853,7 +853,7 @@ include!(\"foo.rs\");\n \n fn main() {\n     RegisterBlock { };\n-                  //^ RegisterBlock\n+  //^^^^^^^^^^^^^^^^^ RegisterBlock\n }\n     \"#;\n     let fixture = format!(\"{}\\n//- /foo.rs\\n{}\", fixture, data);\n@@ -879,7 +879,7 @@ include!(concat!(\"f\", \"oo.rs\"));\n \n fn main() {\n     bar();\n-}     //^ u32\n+} //^^^^^ u32\n \n //- /foo.rs\n fn bar() -> u32 {0}\n@@ -905,7 +905,7 @@ include!(concat!(env!(\"OUT_DIR\"), \"/foo.rs\"));\n \n fn main() {\n     bar();\n-}     //^ {unknown}\n+} //^^^^^ {unknown}\n \n //- /foo.rs\n fn bar() -> u32 {0}\n@@ -923,7 +923,7 @@ macro_rules! include {() => {}}\n include!(\"main.rs\");\n \n fn main() {\n-            0\n+    0;\n } //^ i32\n \"#,\n     );\n@@ -979,7 +979,7 @@ fn infer_derive_clone_simple() {\n struct S;\n fn test() {\n     S.clone();\n-}         //^ S\n+} //^^^^^^^^^ S\n \n //- /lib.rs crate:core\n pub mod prelude {\n@@ -1028,7 +1028,7 @@ pub struct S;\n use core::S;\n fn test() {\n     S.clone();\n-}         //^ S\n+} //^^^^^^^^^ S\n \"#,\n     );\n }\n@@ -1044,7 +1044,8 @@ struct S;\n struct Wrapper<T>(T);\n struct NonClone;\n fn test() {\n-    (Wrapper(S).clone(), Wrapper(NonClone).clone());\n+    let x = (Wrapper(S).clone(), Wrapper(NonClone).clone());\n+    x;\n   //^ (Wrapper<S>, {unknown})\n }\n \n@@ -1079,7 +1080,7 @@ struct S{}\n \n fn test() {\n     S{};\n-}   //^ S\n+} //^^^ S\n \"#,\n     );\n }"}, {"sha": "3f7a37295e4f54f129015dd6d530a61a9e40d32d", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 114, "deletions": 150, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -257,7 +257,7 @@ fn test() {\n mod foo {\n     struct S;\n     impl S {\n-        fn thing() -> i128 {}\n+        fn thing() -> i128 { 0 }\n     }\n }\n \"#,\n@@ -267,164 +267,128 @@ mod foo {\n #[test]\n fn infer_trait_method_simple() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        trait Trait1 {\n-            fn method(&self) -> u32;\n-        }\n-        struct S1;\n-        impl Trait1 for S1 {}\n-        trait Trait2 {\n-            fn method(&self) -> i128;\n-        }\n-        struct S2;\n-        impl Trait2 for S2 {}\n-        fn test() {\n-            S1.method(); // -> u32\n-            S2.method(); // -> i128\n-        }\n+trait Trait1 {\n+    fn method(&self) -> u32;\n+}\n+struct S1;\n+impl Trait1 for S1 {}\n+trait Trait2 {\n+    fn method(&self) -> i128;\n+}\n+struct S2;\n+impl Trait2 for S2 {}\n+fn test() {\n+    S1.method();\n+  //^^^^^^^^^^^ u32\n+    S2.method(); // -> i128\n+  //^^^^^^^^^^^ i128\n+}\n         \"#,\n-        expect![[r#\"\n-            30..34 'self': &Self\n-            109..113 'self': &Self\n-            169..227 '{     ...i128 }': ()\n-            175..177 'S1': S1\n-            175..186 'S1.method()': u32\n-            202..204 'S2': S2\n-            202..213 'S2.method()': i128\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_scoped() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        struct S;\n-        mod foo {\n-            pub trait Trait1 {\n-                fn method(&self) -> u32;\n-            }\n-            impl Trait1 for super::S {}\n-        }\n-        mod bar {\n-            pub trait Trait2 {\n-                fn method(&self) -> i128;\n-            }\n-            impl Trait2 for super::S {}\n-        }\n+struct S;\n+mod foo {\n+    pub trait Trait1 {\n+        fn method(&self) -> u32;\n+    }\n+    impl Trait1 for super::S {}\n+}\n+mod bar {\n+    pub trait Trait2 {\n+        fn method(&self) -> i128;\n+    }\n+    impl Trait2 for super::S {}\n+}\n \n-        mod foo_test {\n-            use super::S;\n-            use super::foo::Trait1;\n-            fn test() {\n-                S.method(); // -> u32\n-            }\n-        }\n+mod foo_test {\n+    use super::S;\n+    use super::foo::Trait1;\n+    fn test() {\n+        S.method();\n+      //^^^^^^^^^^ u32\n+    }\n+}\n \n-        mod bar_test {\n-            use super::S;\n-            use super::bar::Trait2;\n-            fn test() {\n-                S.method(); // -> i128\n-            }\n-        }\n+mod bar_test {\n+    use super::S;\n+    use super::bar::Trait2;\n+    fn test() {\n+        S.method();\n+      //^^^^^^^^^^ i128\n+    }\n+}\n         \"#,\n-        expect![[r#\"\n-            62..66 'self': &Self\n-            168..172 'self': &Self\n-            299..336 '{     ...     }': ()\n-            309..310 'S': S\n-            309..319 'S.method()': u32\n-            415..453 '{     ...     }': ()\n-            425..426 'S': S\n-            425..435 'S.method()': i128\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_generic_1() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        trait Trait<T> {\n-            fn method(&self) -> T;\n-        }\n-        struct S;\n-        impl Trait<u32> for S {}\n-        fn test() {\n-            S.method();\n-        }\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+fn test() {\n+    S.method();\n+  //^^^^^^^^^^ u32\n+}\n         \"#,\n-        expect![[r#\"\n-            32..36 'self': &Self\n-            91..110 '{     ...d(); }': ()\n-            97..98 'S': S\n-            97..107 'S.method()': u32\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_generic_more_params() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        trait Trait<T1, T2, T3> {\n-            fn method1(&self) -> (T1, T2, T3);\n-            fn method2(&self) -> (T3, T2, T1);\n-        }\n-        struct S1;\n-        impl Trait<u8, u16, u32> for S1 {}\n-        struct S2;\n-        impl<T> Trait<i8, i16, T> for S2 {}\n-        fn test() {\n-            S1.method1(); // u8, u16, u32\n-            S1.method2(); // u32, u16, u8\n-            S2.method1(); // i8, i16, {unknown}\n-            S2.method2(); // {unknown}, i16, i8\n-        }\n+trait Trait<T1, T2, T3> {\n+    fn method1(&self) -> (T1, T2, T3);\n+    fn method2(&self) -> (T3, T2, T1);\n+}\n+struct S1;\n+impl Trait<u8, u16, u32> for S1 {}\n+struct S2;\n+impl<T> Trait<i8, i16, T> for S2 {}\n+fn test() {\n+    S1.method1();\n+  //^^^^^^^^^^^^ (u8, u16, u32)\n+    S1.method2();\n+  //^^^^^^^^^^^^ (u32, u16, u8)\n+    S2.method1();\n+  //^^^^^^^^^^^^ (i8, i16, {unknown})\n+    S2.method2();\n+  //^^^^^^^^^^^^ ({unknown}, i16, i8)\n+}\n         \"#,\n-        expect![[r#\"\n-            42..46 'self': &Self\n-            81..85 'self': &Self\n-            209..360 '{     ..., i8 }': ()\n-            215..217 'S1': S1\n-            215..227 'S1.method1()': (u8, u16, u32)\n-            249..251 'S1': S1\n-            249..261 'S1.method2()': (u32, u16, u8)\n-            283..285 'S2': S2\n-            283..295 'S2.method1()': (i8, i16, {unknown})\n-            323..325 'S2': S2\n-            323..335 'S2.method2()': ({unknown}, i16, i8)\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_trait_method_generic_2() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n-    check_infer(\n+    check_types(\n         r#\"\n-        trait Trait<T> {\n-            fn method(&self) -> T;\n-        }\n-        struct S<T>(T);\n-        impl<U> Trait<U> for S<U> {}\n-        fn test() {\n-            S(1u32).method();\n-        }\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn test() {\n+    S(1u32).method();\n+  //^^^^^^^^^^^^^^^^ u32\n+}\n         \"#,\n-        expect![[r#\"\n-            32..36 'self': &Self\n-            101..126 '{     ...d(); }': ()\n-            107..108 'S': S<u32>(u32) -> S<u32>\n-            107..114 'S(1u32)': S<u32>\n-            107..123 'S(1u32...thod()': u32\n-            109..113 '1u32': u32\n-        \"#]],\n     );\n }\n \n@@ -685,10 +649,10 @@ fn method_resolution_unify_impl_self_type() {\n     check_types(\n         r#\"\n struct S<T>;\n-impl S<u32> { fn foo(&self) -> u8 {} }\n-impl S<i32> { fn foo(&self) -> i8 {} }\n+impl S<u32> { fn foo(&self) -> u8 { 0 } }\n+impl S<i32> { fn foo(&self) -> i8 { 0 } }\n fn test() { (S::<u32>.foo(), S::<i32>.foo()); }\n-          //^ (u8, i8)\n+          //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (u8, i8)\n \"#,\n     );\n }\n@@ -702,7 +666,7 @@ struct S;\n impl S { fn foo(&self) -> i8 { 0 } }\n impl Trait for S { fn foo(self) -> u128 { 0 } }\n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -716,7 +680,7 @@ struct S;\n impl Clone for S {}\n impl Clone for &S {}\n fn test() { (S.clone(), (&S).clone(), (&&S).clone()); }\n-          //^ (S, S, &S)\n+          //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (S, S, &S)\n \"#,\n     );\n }\n@@ -730,7 +694,7 @@ struct S;\n impl S { fn foo(self) -> i8 { 0 } }\n impl Trait for &S { fn foo(self) -> u128 { 0 } }\n fn test() { (&S).foo(); }\n-                   //^ u128\n+          //^^^^^^^^^^ u128\n \"#,\n     );\n }\n@@ -744,7 +708,7 @@ struct S;\n impl S { fn foo(self) -> i8 { 0 } }\n impl Trait for S { fn foo(self) -> u128 { 0 } }\n fn test() { S.foo(); }\n-                //^ i8\n+          //^^^^^^^ i8\n \"#,\n     );\n }\n@@ -758,7 +722,7 @@ struct S;\n impl S { fn foo(&self) -> i8 { 0 } }\n impl Trait for &S { fn foo(self) -> u128 { 0 } }\n fn test() { S.foo(); }\n-                //^ i8\n+          //^^^^^^^ i8\n \"#,\n     );\n }\n@@ -771,7 +735,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Trait for S { fn foo(self) -> u128 { 0 } }\n fn test() { (&S).foo(); }\n-                   //^ u128\n+          //^^^^^^^^^^ u128\n \"#,\n     );\n }\n@@ -784,7 +748,7 @@ fn method_resolution_unsize_array() {\n fn test() {\n     let a = [1, 2, 3];\n     a.len();\n-}       //^ usize\n+} //^^^^^^^ usize\n \"#,\n     );\n }\n@@ -799,7 +763,7 @@ impl Clone for S {}\n \n fn test() {\n     S.clone();\n-          //^ S\n+  //^^^^^^^^^ S\n }\n \n //- /lib.rs crate:core\n@@ -823,7 +787,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl<T> Trait for T where T: UnknownTrait {}\n fn test() { (&S).foo(); }\n-                   //^ u128\n+          //^^^^^^^^^^ u128\n \"#,\n     );\n }\n@@ -841,7 +805,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl<T> Trait for T where T: Clone {}\n fn test() { (&S).foo(); }\n-                   //^ {unknown}\n+          //^^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -856,7 +820,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl<T: Clone> Trait for T {}\n fn test() { (&S).foo(); }\n-                   //^ {unknown}\n+          //^^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -871,7 +835,7 @@ struct S;\n impl Clone for S {}\n impl<T> Trait for T where T: Clone {}\n fn test() { S.foo(); }\n-                //^ u128\n+          //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -887,7 +851,7 @@ struct S2;\n impl From<S2> for S1 {}\n impl<T, U> Into<U> for T where U: From<T> {}\n fn test() { S2.into(); }\n-                  //^ {unknown}\n+          //^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -903,7 +867,7 @@ struct S2;\n impl From<S2> for S1 {}\n impl<T, U: From<T>> Into<U> for T {}\n fn test() { S2.into(); }\n-                  //^ {unknown}\n+          //^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -933,7 +897,7 @@ fn main() {\n     let a = Wrapper::<Foo<f32>>::new(1.0);\n     let b = Wrapper::<Bar<f32>>::new(1.0);\n     (a, b);\n-  //^ (Wrapper<Foo<f32>>, Wrapper<Bar<f32>>)\n+  //^^^^^^ (Wrapper<Foo<f32>>, Wrapper<Bar<f32>>)\n }\n \"#,\n     );\n@@ -947,7 +911,7 @@ fn method_resolution_encountering_fn_type() {\n fn foo() {}\n trait FnOnce { fn call(self); }\n fn test() { foo.call(); }\n-                   //^ {unknown}\n+          //^^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -1013,7 +977,7 @@ where\n     Wrapper<T>: a::Foo,\n {\n     t.foo();\n-}       //^ {unknown}\n+} //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -1030,7 +994,7 @@ impl A<i32> {\n \n fn main() {\n     A::from(3);\n-}          //^ A<i32>\n+} //^^^^^^^^^^ A<i32>\n \"#,\n     );\n }\n@@ -1058,7 +1022,7 @@ trait FnX {}\n impl<B, C> Trait for S<B, C> where C: FnX, B: SendX {}\n \n fn test() { (S {}).method(); }\n-                        //^ ()\n+          //^^^^^^^^^^^^^^^ ()\n \"#,\n     );\n }\n@@ -1143,8 +1107,8 @@ impl<T> Slice<T> {\n \n fn main() {\n     let foo: Slice<u32>;\n-    (foo.into_vec()); // we don't actually support arbitrary self types, but we shouldn't crash at least\n-} //^ {unknown}\n+    foo.into_vec(); // we shouldn't crash on this at least\n+} //^^^^^^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -1165,7 +1129,7 @@ impl dyn Foo + '_ {\n fn main() {\n     let f = &42u32 as &dyn Foo;\n     f.dyn_foo();\n-  // ^u32\n+ // ^^^^^^^^^^^ u32\n }\n \"#,\n     );\n@@ -1376,11 +1340,11 @@ pub trait IntoIterator {\n \n impl<T> IntoIterator for [T; 1] {\n     type Out = T;\n-    fn into_iter(self) -> Self::Out {}\n+    fn into_iter(self) -> Self::Out { loop {} }\n }\n impl<'a, T> IntoIterator for &'a [T] {\n     type Out = &'a T;\n-    fn into_iter(self) -> Self::Out {}\n+    fn into_iter(self) -> Self::Out { loop {} }\n }\n     \"#,\n     );"}, {"sha": "47aa30d2e38c8e2dea7b60ef5ef8f5c4f78c4f2a", "filename": "crates/hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_infer_with_mismatches, check_mismatches, check_types};\n+use super::{check, check_infer, check_infer_with_mismatches, check_types};\n \n #[test]\n fn infer_pattern() {\n@@ -518,7 +518,7 @@ fn infer_generics_in_patterns() {\n \n #[test]\n fn infer_const_pattern() {\n-    check_mismatches(\n+    check(\n         r#\"\n enum Option<T> { None }\n use Option::None;"}, {"sha": "8c5e8954c4f8765e83bed7d24ef9ff24dc1daa2b", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_types};\n+use super::{check_infer, check_no_mismatches, check_types};\n \n #[test]\n fn bug_484() {\n@@ -422,20 +422,20 @@ fn issue_2683_chars_impl() {\n pub struct Chars<'a> {}\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> {}\n+    fn next(&mut self) -> Option<char> { loop {} }\n }\n \n fn test() {\n     let chars: Chars<'_>;\n     (chars.next(), chars.nth(1));\n-} //^ (Option<char>, Option<char>)\n+} //^^^^^^^^^^^^^^^^^^^^^^^^^^^^ (Option<char>, Option<char>)\n \"#,\n     );\n }\n \n #[test]\n fn issue_3642_bad_macro_stackover() {\n-    check_types(\n+    check_no_mismatches(\n         r#\"\n #[macro_export]\n macro_rules! match_ast {\n@@ -452,7 +452,6 @@ macro_rules! match_ast {\n \n fn main() {\n     let anchor = match_ast! {\n-       //^ ()\n         match parent {\n             as => {},\n             _ => return None\n@@ -956,7 +955,7 @@ trait IterTrait<'a, T: 'a>: Iterator<Item = &'a T> {\n \n fn clone_iter<T>(s: Iter<T>) {\n     s.inner.clone_box();\n-    //^^^^^^^^^^^^^^^^^^^ ()\n+  //^^^^^^^^^^^^^^^^^^^ ()\n }\n \"#,\n     )"}, {"sha": "b4bcc6d953ec9936c2327a06452e08c4e5badf35", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -60,7 +60,7 @@ enum Nat { Succ(Self), Demo(Nat), Zero }\n fn test() {\n     let foo: Nat = Nat::Zero;\n     if let Nat::Succ(x) = foo {\n-        x\n+        x;\n     } //^ Nat\n }\n \"#,\n@@ -138,7 +138,7 @@ enum Option<T> { Some(T), None }\n fn test() {\n     let foo: Option<f32> = None;\n     while let Option::Some(x) = foo {\n-        x\n+        x;\n     } //^ f32\n }\n \"#,\n@@ -1745,7 +1745,7 @@ impl i32 { fn foo(&self) -> Foo { Foo } }\n fn main() {\n     let x: i32 = i32;\n     x.foo();\n-        //^ Foo\n+  //^^^^^^^ Foo\n }\"#,\n     );\n }\n@@ -1763,7 +1763,7 @@ fn main() {\n     fn inner() {}\n     let x: i32 = i32;\n     x.foo();\n-        //^ Foo\n+  //^^^^^^^ Foo\n }\"#,\n     );\n }\n@@ -1781,7 +1781,7 @@ fn foo() -> &'static str { \"\" }\n \n fn main() {\n     foo();\n-      //^ &str\n+  //^^^^^ &str\n }\"#,\n     );\n }\n@@ -1799,7 +1799,7 @@ fn foo() -> &'static str { \"\" }\n \n fn main() {\n     str::foo();\n-           //^ u32\n+  //^^^^^^^^^^ u32\n }\"#,\n     );\n }\n@@ -1825,9 +1825,9 @@ mod d {\n \n fn main() {\n     d::foo();\n-         //^ u8\n+  //^^^^^^^^ u8\n     d::foo{a:0};\n-           //^ u8\n+  //^^^^^^^^^^^ foo\n }\"#,\n     );\n }\n@@ -2677,7 +2677,7 @@ fn prelude_2015() {\n //- /main.rs edition:2015 crate:main deps:core\n fn f() {\n     Rust;\n-     //^ Rust\n+  //^^^^ Rust\n }\n \n //- /core.rs crate:core"}, {"sha": "a0ddad570d006b22adbf154940cd385544729029", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 91, "deletions": 153, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -1,6 +1,7 @@\n+use cov_mark::check;\n use expect_test::expect;\n \n-use super::{check_infer, check_infer_with_mismatches, check_types};\n+use super::{check, check_infer, check_infer_with_mismatches, check_types};\n \n #[test]\n fn infer_await() {\n@@ -285,107 +286,70 @@ mod ops {\n \n #[test]\n fn infer_from_bound_1() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Trait<T> {}\n struct S<T>(T);\n impl<U> Trait<U> for S<U> {}\n fn foo<T: Trait<u32>>(t: T) {}\n fn test() {\n     let s = S(unknown);\n+           // ^^^^^^^ u32\n     foo(s);\n }\"#,\n-        expect![[r#\"\n-            85..86 't': T\n-            91..93 '{}': ()\n-            104..143 '{     ...(s); }': ()\n-            114..115 's': S<u32>\n-            118..119 'S': S<u32>(u32) -> S<u32>\n-            118..128 'S(unknown)': S<u32>\n-            120..127 'unknown': u32\n-            134..137 'foo': fn foo<S<u32>>(S<u32>)\n-            134..140 'foo(s)': ()\n-            138..139 's': S<u32>\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_from_bound_2() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Trait<T> {}\n struct S<T>(T);\n impl<U> Trait<U> for S<U> {}\n-fn foo<U, T: Trait<U>>(t: T) -> U {}\n+fn foo<U, T: Trait<U>>(t: T) -> U { loop {} }\n fn test() {\n     let s = S(unknown);\n+           // ^^^^^^^ u32\n     let x: u32 = foo(s);\n }\"#,\n-        expect![[r#\"\n-            86..87 't': T\n-            97..99 '{}': ()\n-            110..162 '{     ...(s); }': ()\n-            120..121 's': S<u32>\n-            124..125 'S': S<u32>(u32) -> S<u32>\n-            124..134 'S(unknown)': S<u32>\n-            126..133 'unknown': u32\n-            144..145 'x': u32\n-            153..156 'foo': fn foo<u32, S<u32>>(S<u32>) -> u32\n-            153..159 'foo(s)': u32\n-            157..158 's': S<u32>\n-        \"#]],\n     );\n }\n \n #[test]\n fn trait_default_method_self_bound_implements_trait() {\n     cov_mark::check!(trait_self_implements_self);\n-    check_infer(\n+    check(\n         r#\"\n trait Trait {\n     fn foo(&self) -> i64;\n-    fn bar(&self) -> {\n-        let x = self.foo();\n+    fn bar(&self) -> () {\n+        self.foo();\n+     // ^^^^^^^^^^ type: i64\n     }\n }\"#,\n-        expect![[r#\"\n-            26..30 'self': &Self\n-            52..56 'self': &Self\n-            61..96 '{     ...     }': ()\n-            75..76 'x': i64\n-            79..83 'self': &Self\n-            79..89 'self.foo()': i64\n-        \"#]],\n     );\n }\n \n #[test]\n fn trait_default_method_self_bound_implements_super_trait() {\n-    check_infer(\n+    check(\n         r#\"\n trait SuperTrait {\n     fn foo(&self) -> i64;\n }\n trait Trait: SuperTrait {\n-    fn bar(&self) -> {\n-        let x = self.foo();\n+    fn bar(&self) -> () {\n+        self.foo();\n+     // ^^^^^^^^^^ type: i64\n     }\n }\"#,\n-        expect![[r#\"\n-            31..35 'self': &Self\n-            85..89 'self': &Self\n-            94..129 '{     ...     }': ()\n-            108..109 'x': i64\n-            112..116 'self': &Self\n-            112..122 'self.foo()': i64\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_project_associated_type() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Iterable {\n     type Item;\n@@ -394,89 +358,62 @@ struct S;\n impl Iterable for S { type Item = u32; }\n fn test<T: Iterable>() {\n     let x: <S as Iterable>::Item = 1;\n-    let y: <T as Iterable>::Item = no_matter;\n-    let z: T::Item = no_matter;\n-    let a: <T>::Item = no_matter;\n+                                // ^ u32\n+    let y: <T as Iterable>::Item = u;\n+                                // ^ Iterable::Item<T>\n+    let z: T::Item = u;\n+                  // ^ Iterable::Item<T>\n+    let a: <T>::Item = u;\n+                    // ^ Iterable::Item<T>\n }\"#,\n-        expect![[r#\"\n-            108..261 '{     ...ter; }': ()\n-            118..119 'x': u32\n-            145..146 '1': u32\n-            156..157 'y': Iterable::Item<T>\n-            183..192 'no_matter': Iterable::Item<T>\n-            202..203 'z': Iterable::Item<T>\n-            215..224 'no_matter': Iterable::Item<T>\n-            234..235 'a': Iterable::Item<T>\n-            249..258 'no_matter': Iterable::Item<T>\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_return_associated_type() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Iterable {\n     type Item;\n }\n struct S;\n impl Iterable for S { type Item = u32; }\n-fn foo1<T: Iterable>(t: T) -> T::Item {}\n-fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item {}\n-fn foo3<T: Iterable>(t: T) -> <T>::Item {}\n+fn foo1<T: Iterable>(t: T) -> T::Item { loop {} }\n+fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item { loop {} }\n+fn foo3<T: Iterable>(t: T) -> <T>::Item { loop {} }\n fn test() {\n-    let x = foo1(S);\n-    let y = foo2(S);\n-    let z = foo3(S);\n+    foo1(S);\n+ // ^^^^^^^ u32\n+    foo2(S);\n+ // ^^^^^^^ u32\n+    foo3(S);\n+ // ^^^^^^^ u32\n }\"#,\n-        expect![[r#\"\n-            106..107 't': T\n-            123..125 '{}': ()\n-            147..148 't': T\n-            178..180 '{}': ()\n-            202..203 't': T\n-            221..223 '{}': ()\n-            234..300 '{     ...(S); }': ()\n-            244..245 'x': u32\n-            248..252 'foo1': fn foo1<S>(S) -> <S as Iterable>::Item\n-            248..255 'foo1(S)': u32\n-            253..254 'S': S\n-            265..266 'y': u32\n-            269..273 'foo2': fn foo2<S>(S) -> <S as Iterable>::Item\n-            269..276 'foo2(S)': u32\n-            274..275 'S': S\n-            286..287 'z': u32\n-            290..294 'foo3': fn foo3<S>(S) -> <S as Iterable>::Item\n-            290..297 'foo3(S)': u32\n-            295..296 'S': S\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_associated_type_bound() {\n-    check_infer(\n+    check_types(\n         r#\"\n trait Iterable {\n     type Item;\n }\n fn test<T: Iterable<Item=u32>>() {\n     let y: T::Item = unknown;\n+                  // ^^^^^^^ u32\n }\"#,\n-        expect![[r#\"\n-            67..100 '{     ...own; }': ()\n-            77..78 'y': u32\n-            90..97 'unknown': u32\n-        \"#]],\n     );\n }\n \n #[test]\n fn infer_const_body() {\n+    // FIXME make check_types work with other bodies\n     check_infer(\n         r#\"\n const A: u32 = 1 + 1;\n-static B: u64 = { let x = 1; x };\"#,\n+static B: u64 = { let x = 1; x };\n+\"#,\n         expect![[r#\"\n             15..16 '1': u32\n             15..20 '1 + 1': u32\n@@ -637,12 +574,12 @@ impl<T> core::ops::Deref for Arc<T> {\n \n struct S;\n impl S {\n-    fn foo(&self) -> u128 {}\n+    fn foo(&self) -> u128 { 0 }\n }\n \n fn test(s: Arc<S>) {\n     (*s, s.foo());\n-} //^ (S, u128)\n+} //^^^^^^^^^^^^^ (S, u128)\n \"#,\n     );\n }\n@@ -653,7 +590,7 @@ fn deref_trait_with_inference_var() {\n         r#\"\n //- minicore: deref\n struct Arc<T>;\n-fn new_arc<T>() -> Arc<T> {}\n+fn new_arc<T>() -> Arc<T> { Arc }\n impl<T> core::ops::Deref for Arc<T> {\n     type Target = T;\n }\n@@ -663,8 +600,8 @@ fn foo(a: Arc<S>) {}\n \n fn test() {\n     let a = new_arc();\n-    let b = (*a);\n-          //^ S\n+    let b = *a;\n+          //^^ S\n     foo(a);\n }\n \"#,\n@@ -684,7 +621,7 @@ impl core::ops::Deref for S {\n \n fn test(s: S) {\n     s.foo();\n-}       //^ {unknown}\n+} //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -701,12 +638,12 @@ impl<T: ?Sized> core::ops::Deref for Arc<T> {\n \n struct S;\n impl S {\n-    fn foo(&self) -> u128 {}\n+    fn foo(&self) -> u128 { 0 }\n }\n \n fn test(s: Arc<S>) {\n     (*s, s.foo());\n-} //^ (S, u128)\n+} //^^^^^^^^^^^^^ (S, u128)\n \"#,\n     );\n }\n@@ -720,11 +657,11 @@ struct S;\n trait Trait<T> {}\n impl Trait<u32> for S {}\n \n-fn foo<T: Trait<U>, U>(t: T) -> U {}\n+fn foo<T: Trait<U>, U>(t: T) -> U { loop {} }\n \n fn test(s: S) {\n-    (foo(s));\n-} //^ u32\n+    foo(s);\n+} //^^^^^^ u32\n \"#,\n     );\n }\n@@ -741,12 +678,12 @@ impl Trait<isize> for S {}\n \n struct O;\n impl O {\n-    fn foo<T: Trait<U>, U>(&self, t: T) -> U {}\n+    fn foo<T: Trait<U>, U>(&self, t: T) -> U { loop {} }\n }\n \n fn test() {\n     O.foo(S);\n-}      //^ isize\n+} //^^^^^^^^ isize\n \"#,\n     );\n }\n@@ -761,12 +698,12 @@ trait Trait<T> {}\n impl Trait<i64> for S {}\n \n impl S {\n-    fn foo<U>(&self) -> U where Self: Trait<U> {}\n+    fn foo<U>(&self) -> U where Self: Trait<U> { loop {} }\n }\n \n fn test() {\n     S.foo();\n-}       //^ i64\n+} //^^^^^^^ i64\n \"#,\n     );\n }\n@@ -782,12 +719,12 @@ impl Trait<&str> for S {}\n \n struct O<T>;\n impl<U, T: Trait<U>> O<T> {\n-    fn foo(&self) -> U {}\n+    fn foo(&self) -> U { loop {} }\n }\n \n fn test(o: O<S>) {\n     o.foo();\n-}       //^ &str\n+} //^^^^^^^ &str\n \"#,\n     );\n }\n@@ -802,7 +739,7 @@ struct S;\n impl Clone for S {}\n impl<T> Trait for T where T: Clone {}\n fn test<T: Clone>(t: T) { t.foo(); }\n-                             //^ u128\n+                        //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -818,7 +755,7 @@ struct S;\n impl Clone for S {}\n impl<T> Trait for T where T: Clone {}\n fn test<T>(t: T) { t.foo(); }\n-                       //^ {unknown}\n+                 //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -831,7 +768,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Trait for S {}\n fn test<T: Trait>(t: T) { t.foo(); }\n-                              //^ u128\n+                        //^^^^^^^ u128\n \"#,\n     );\n }\n@@ -844,7 +781,7 @@ trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Trait for S {}\n fn test<T>(t: T) { t.foo(); }\n-                       //^ {unknown}\n+                 //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -858,8 +795,8 @@ trait Trait {}\n impl<T> core::ops::Deref for T where T: Trait {\n     type Target = i128;\n }\n-fn test<T: Trait>(t: T) { (*t); }\n-                        //^ i128\n+fn test<T: Trait>(t: T) { *t; }\n+                        //^^ i128\n \"#,\n     );\n }\n@@ -1380,12 +1317,12 @@ fn error_bound_chalk() {\n     check_types(\n         r#\"\n trait Trait {\n-    fn foo(&self) -> u32 {}\n+    fn foo(&self) -> u32 { 0 }\n }\n \n fn test(x: (impl Trait + UnknownTrait)) {\n     x.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -1476,7 +1413,7 @@ trait Clone {\n fn api_walkthrough() {\n     for node in foo() {\n         node.clone();\n-    }            //^ {unknown}\n+    } //^^^^^^^^^^^^ {unknown}\n }\n \"#,\n     );\n@@ -1513,13 +1450,13 @@ fn where_clause_trait_in_scope_for_method_resolution() {\n         r#\"\n mod foo {\n     trait Trait {\n-        fn foo(&self) -> u32 {}\n+        fn foo(&self) -> u32 { 0 }\n     }\n }\n \n fn test<T: foo::Trait>(x: T) {\n     x.foo();\n-}      //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -1982,7 +1919,7 @@ fn fn_item_fn_trait() {\n //- minicore: fn\n struct S;\n \n-fn foo() -> S {}\n+fn foo() -> S { S }\n \n fn takes_closure<U, F: FnOnce() -> U>(f: F) -> U { f() }\n \n@@ -2009,7 +1946,7 @@ trait Trait2 {\n fn test<T: Trait>() where T::Item: Trait2 {\n     let x: T::Item = no_matter;\n     x.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -2029,7 +1966,7 @@ trait Trait2 {\n fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n     let x: T::Item = no_matter;\n     x.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -2092,7 +2029,7 @@ impl Trait for S {\n \n fn test() {\n     S.f();\n-}     //^ u32\n+} //^^^^^ u32\n \"#,\n     );\n }\n@@ -2120,7 +2057,7 @@ where\n \n fn foo<I: Interner>(interner: &I, t: Ty<I>) {\n     fold(interner, t);\n-}     //^ Ty<I>\n+} //^^^^^^^^^^^^^^^^^ Ty<I>\n \"#,\n     );\n }\n@@ -2139,7 +2076,7 @@ impl Trait<Self> for S {}\n \n fn test() {\n     S.foo();\n-}       //^ ()\n+} //^^^^^^^ ()\n \"#,\n     );\n }\n@@ -2158,7 +2095,7 @@ impl Trait for S<Self> {}\n \n fn test() {\n     S.foo();\n-}       //^ {unknown}\n+} //^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -2176,7 +2113,7 @@ trait Trait2<T> {}\n \n fn test<T: Trait>() where T: Trait2<T::Item> {\n     let x: T::Item = no_matter;\n-}                       //^ {unknown}\n+}                  //^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -2193,7 +2130,7 @@ trait Trait<T> {\n \n fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n     let x: T::Item = no_matter;\n-}                   //^ {unknown}\n+}                  //^^^^^^^^^ {unknown}\n \"#,\n     );\n }\n@@ -2211,7 +2148,7 @@ trait Trait {\n \n fn test<T>() where T: Trait<OtherItem = T::Item> {\n     let x: T::Item = no_matter;\n-}                   //^ Trait::Item<T>\n+}                  //^^^^^^^^^ Trait::Item<T>\n \"#,\n     );\n }\n@@ -2243,7 +2180,7 @@ fn test<T>(t: T) where T: UnificationStoreMut {\n     t.push(x);\n     let y: Key<T>;\n     (x, y);\n-}      //^ (UnificationStoreBase::Key<T>, UnificationStoreBase::Key<T>)\n+} //^^^^^^ (UnificationStoreBase::Key<T>, UnificationStoreBase::Key<T>)\n \"#,\n     );\n }\n@@ -2268,7 +2205,7 @@ impl<T: Iterator> Iterator for S<T> {\n fn test<I: Iterator<Item: OtherTrait<u32>>>() {\n     let x: <S<I> as Iterator>::Item;\n     x.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -2470,7 +2407,7 @@ impl<T: Trait> Trait for S<T> {\n fn test<T: Trait>() {\n     let y: <S<T> as Trait>::Item = no_matter;\n     y.foo();\n-}       //^ u32\n+} //^^^^^^^ u32\n \"#,\n     );\n }\n@@ -2490,7 +2427,7 @@ trait Trait {\n \n fn test(x: Box<dyn Trait>) {\n     x.foo();\n-}       //^ ()\n+} //^^^^^^^ ()\n \"#,\n     );\n }\n@@ -2509,7 +2446,7 @@ impl ToOwned for str {\n }\n fn test() {\n     \"foo\".to_owned();\n-}               //^ String\n+} //^^^^^^^^^^^^^^^^ String\n \"#,\n     );\n }\n@@ -2649,7 +2586,7 @@ impl<T:A> B for T {\n \n fn main() {\n     Bar::foo();\n-}          //^ Foo\n+} //^^^^^^^^^^ Foo\n \"#,\n     );\n }\n@@ -3002,7 +2939,7 @@ fn test() {\n     S.get(1);\n   //^^^^^^^^ u128\n     S.get(1.);\n-  //^^^^^^^^ f32\n+  //^^^^^^^^^ f32\n }\n         \"#,\n     );\n@@ -3477,14 +3414,12 @@ trait Convert {\n     fn new() -> Self;\n }\n impl Convert for u32 {\n-    fn new() -> Self {\n-        0\n-    }\n+    fn new() -> Self { 0 }\n }\n \n async fn get_accounts() -> Result<u32, ()> {\n     let ret = Fooey.collect();\n-    //                      ^ u32\n+    //        ^^^^^^^^^^^^^^^ u32\n     Ok(ret)\n }\n \"#,\n@@ -3493,6 +3428,7 @@ async fn get_accounts() -> Result<u32, ()> {\n \n #[test]\n fn local_impl_1() {\n+    check!(block_local_impls);\n     check_types(\n         r#\"\n trait Trait<T> {\n@@ -3502,7 +3438,7 @@ trait Trait<T> {\n fn test() {\n     struct S;\n     impl Trait<u32> for S {\n-        fn foo(&self) { 0 }\n+        fn foo(&self) -> u32 { 0 }\n     }\n \n     S.foo();\n@@ -3514,6 +3450,7 @@ fn test() {\n \n #[test]\n fn local_impl_2() {\n+    check!(block_local_impls);\n     check_types(\n         r#\"\n struct S;\n@@ -3523,7 +3460,7 @@ fn test() {\n         fn foo(&self) -> T;\n     }\n     impl Trait<u32> for S {\n-        fn foo(&self) { 0 }\n+        fn foo(&self) -> u32 { 0 }\n     }\n \n     S.foo();\n@@ -3535,6 +3472,7 @@ fn test() {\n \n #[test]\n fn local_impl_3() {\n+    check!(block_local_impls);\n     check_types(\n         r#\"\n trait Trait<T> {\n@@ -3547,7 +3485,7 @@ fn test() {\n         struct S2;\n \n         impl Trait<S1> for S2 {\n-            fn foo(&self) { S1 }\n+            fn foo(&self) -> S1 { S1 }\n         }\n \n         S2.foo();"}, {"sha": "d9c22c1803e1d5334864565545defbfce2149658", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3898387f3bd579c0c5415ecb7c7b3d3923947f2f/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=3898387f3bd579c0c5415ecb7c7b3d3923947f2f", "patch": "@@ -11,6 +11,7 @@ mod fixture;\n mod assert_linear;\n \n use std::{\n+    collections::BTreeMap,\n     convert::{TryFrom, TryInto},\n     env, fs,\n     path::{Path, PathBuf},\n@@ -205,14 +206,25 @@ pub fn add_cursor(text: &str, offset: TextSize) -> String {\n ///\n /// // ^^^ first line\n /// //   | second line\n+///\n+/// Annotations point to the last line that actually was long enough for the\n+/// range, not counting annotations themselves. So overlapping annotations are\n+/// possible:\n+/// ```no_run\n+/// // stuff        other stuff\n+/// // ^^ 'st'\n+/// // ^^^^^ 'stuff'\n+/// //              ^^^^^^^^^^^ 'other stuff'\n+/// ```\n pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n     let mut res = Vec::new();\n-    let mut prev_line_start: Option<TextSize> = Some(0.into());\n+    // map from line length to beginning of last line that had that length\n+    let mut line_start_map = BTreeMap::new();\n     let mut line_start: TextSize = 0.into();\n     let mut prev_line_annotations: Vec<(TextSize, usize)> = Vec::new();\n     for line in text.split_inclusive('\\n') {\n         let mut this_line_annotations = Vec::new();\n-        if let Some(idx) = line.find(\"//\") {\n+        let line_length = if let Some(idx) = line.find(\"//\") {\n             let annotation_offset = TextSize::of(&line[..idx + \"//\".len()]);\n             for annotation in extract_line_annotations(&line[idx + \"//\".len()..]) {\n                 match annotation {\n@@ -222,7 +234,9 @@ pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n                         let range = if file {\n                             TextRange::up_to(TextSize::of(text))\n                         } else {\n-                            range + prev_line_start.unwrap()\n+                            let line_start = line_start_map.range(range.end()..).next().unwrap();\n+\n+                            range + line_start.1\n                         };\n                         res.push((range, content))\n                     }\n@@ -238,9 +252,14 @@ pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n                     }\n                 }\n             }\n-        }\n+            idx.try_into().unwrap()\n+        } else {\n+            TextSize::of(line)\n+        };\n+\n+        line_start_map = line_start_map.split_off(&line_length);\n+        line_start_map.insert(line_length, line_start);\n \n-        prev_line_start = Some(line_start);\n         line_start += TextSize::of(line);\n \n         prev_line_annotations = this_line_annotations;\n@@ -296,7 +315,7 @@ fn extract_line_annotations(mut line: &str) -> Vec<LineAnnotation> {\n }\n \n #[test]\n-fn test_extract_annotations() {\n+fn test_extract_annotations_1() {\n     let text = stdx::trim_indent(\n         r#\"\n fn main() {\n@@ -321,6 +340,25 @@ fn main() {\n     assert_eq!(res[3].0.len(), 115);\n }\n \n+#[test]\n+fn test_extract_annotations_2() {\n+    let text = stdx::trim_indent(\n+        r#\"\n+fn main() {\n+    (x,   y);\n+   //^ a\n+      //  ^ b\n+  //^^^^^^^^ c\n+}\"#,\n+    );\n+    let res = extract_annotations(&text)\n+        .into_iter()\n+        .map(|(range, ann)| (&text[range], ann))\n+        .collect::<Vec<_>>();\n+\n+    assert_eq!(res, [(\"x\", \"a\".into()), (\"y\", \"b\".into()), (\"(x,   y)\", \"c\".into())]);\n+}\n+\n /// Returns `false` if slow tests should not run, otherwise returns `true` and\n /// also creates a file at `./target/.slow_tests_cookie` which serves as a flag\n /// that slow tests did run."}]}