{"sha": "a58089e097c4f80af0353e843e264ae634db686b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ODA4OWUwOTdjNGY4MGFmMDM1M2U4NDNlMjY0YWU2MzRkYjY4NmI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-02T09:47:03Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-03T23:04:29Z"}, "message": "BTreeMap/Set: complete the compile-time test cases", "tree": {"sha": "97a031b4fd0b95be983074a66af23db33caa08b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97a031b4fd0b95be983074a66af23db33caa08b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a58089e097c4f80af0353e843e264ae634db686b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a58089e097c4f80af0353e843e264ae634db686b", "html_url": "https://github.com/rust-lang/rust/commit/a58089e097c4f80af0353e843e264ae634db686b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a58089e097c4f80af0353e843e264ae634db686b/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc42fb8e70af6ad63998f4bfbf62451551eda073", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc42fb8e70af6ad63998f4bfbf62451551eda073", "html_url": "https://github.com/rust-lang/rust/commit/fc42fb8e70af6ad63998f4bfbf62451551eda073"}], "stats": {"total": 145, "additions": 118, "deletions": 27}, "files": [{"sha": "118e173bb16dbca66adff1f865b1dd0fff0ac0c9", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a58089e097c4f80af0353e843e264ae634db686b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a58089e097c4f80af0353e843e264ae634db686b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=a58089e097c4f80af0353e843e264ae634db686b", "patch": "@@ -1,12 +1,10 @@\n+use super::super::{navigate::Position, node, DeterministicRng};\n+use super::Entry::{Occupied, Vacant};\n+use super::*;\n use crate::boxed::Box;\n-use crate::collections::btree::navigate::Position;\n-use crate::collections::btree::node;\n-use crate::collections::btree_map::Entry::{Occupied, Vacant};\n-use crate::collections::BTreeMap;\n use crate::fmt::Debug;\n use crate::rc::Rc;\n-use crate::string::String;\n-use crate::string::ToString;\n+use crate::string::{String, ToString};\n use crate::vec::Vec;\n use std::convert::TryFrom;\n use std::iter::FromIterator;\n@@ -16,19 +14,17 @@ use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-use super::super::DeterministicRng;\n-\n // Capacity of a tree with a single level,\n-// i.e. a tree who's root is a leaf node at height 0.\n+// i.e., a tree who's root is a leaf node at height 0.\n const NODE_CAPACITY: usize = node::CAPACITY;\n \n // Minimum number of elements to insert, to guarantee a tree with 2 levels,\n-// i.e. a tree who's root is an internal node at height 1, with edges to leaf nodes.\n+// i.e., a tree who's root is an internal node at height 1, with edges to leaf nodes.\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n \n // Minimum number of elements to insert in ascending order, to guarantee a tree with 3 levels,\n-// i.e. a tree who's root is an internal node at height 2, with edges to more internal nodes.\n+// i.e., a tree who's root is an internal node at height 2, with edges to more internal nodes.\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_2: usize = 89;\n \n@@ -1386,44 +1382,65 @@ fn test_clone_from() {\n     }\n }\n \n-#[test]\n #[allow(dead_code)]\n fn test_variance() {\n-    use std::collections::btree_map::{IntoIter, Iter, Keys, Range, Values};\n-\n     fn map_key<'new>(v: BTreeMap<&'static str, ()>) -> BTreeMap<&'new str, ()> {\n         v\n     }\n     fn map_val<'new>(v: BTreeMap<(), &'static str>) -> BTreeMap<(), &'new str> {\n         v\n     }\n+\n     fn iter_key<'a, 'new>(v: Iter<'a, &'static str, ()>) -> Iter<'a, &'new str, ()> {\n         v\n     }\n     fn iter_val<'a, 'new>(v: Iter<'a, (), &'static str>) -> Iter<'a, (), &'new str> {\n         v\n     }\n+\n     fn into_iter_key<'new>(v: IntoIter<&'static str, ()>) -> IntoIter<&'new str, ()> {\n         v\n     }\n     fn into_iter_val<'new>(v: IntoIter<(), &'static str>) -> IntoIter<(), &'new str> {\n         v\n     }\n+\n+    fn into_keys_key<'new>(v: IntoKeys<&'static str, ()>) -> IntoKeys<&'new str, ()> {\n+        v\n+    }\n+    fn into_keys_val<'new>(v: IntoKeys<(), &'static str>) -> IntoKeys<(), &'new str> {\n+        v\n+    }\n+\n+    fn into_values_key<'new>(v: IntoValues<&'static str, ()>) -> IntoValues<&'new str, ()> {\n+        v\n+    }\n+    fn into_values_val<'new>(v: IntoValues<(), &'static str>) -> IntoValues<(), &'new str> {\n+        v\n+    }\n+\n     fn range_key<'a, 'new>(v: Range<'a, &'static str, ()>) -> Range<'a, &'new str, ()> {\n         v\n     }\n     fn range_val<'a, 'new>(v: Range<'a, (), &'static str>) -> Range<'a, (), &'new str> {\n         v\n     }\n-    fn keys<'a, 'new>(v: Keys<'a, &'static str, ()>) -> Keys<'a, &'new str, ()> {\n+\n+    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, ()>) -> Keys<'a, &'new str, ()> {\n+        v\n+    }\n+    fn keys_val<'a, 'new>(v: Keys<'a, (), &'static str>) -> Keys<'a, (), &'new str> {\n+        v\n+    }\n+\n+    fn values_key<'a, 'new>(v: Values<'a, &'static str, ()>) -> Values<'a, &'new str, ()> {\n         v\n     }\n-    fn vals<'a, 'new>(v: Values<'a, (), &'static str>) -> Values<'a, (), &'new str> {\n+    fn values_val<'a, 'new>(v: Values<'a, (), &'static str>) -> Values<'a, (), &'new str> {\n         v\n     }\n }\n \n-#[test]\n #[allow(dead_code)]\n fn test_sync() {\n     fn map<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n@@ -1493,7 +1510,6 @@ fn test_sync() {\n     }\n }\n \n-#[test]\n #[allow(dead_code)]\n fn test_send() {\n     fn map<T: Send>(v: BTreeMap<T, T>) -> impl Send {\n@@ -1520,7 +1536,7 @@ fn test_send() {\n         v.iter()\n     }\n \n-    fn iter_mut<T: Send + Sync>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+    fn iter_mut<T: Send>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n         v.iter_mut()\n     }\n \n@@ -1532,15 +1548,15 @@ fn test_send() {\n         v.values()\n     }\n \n-    fn values_mut<T: Send + Sync>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+    fn values_mut<T: Send>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n         v.values_mut()\n     }\n \n     fn range<T: Send + Sync + Ord>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n         v.range(..)\n     }\n \n-    fn range_mut<T: Send + Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+    fn range_mut<T: Send + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n         v.range_mut(..)\n     }\n "}, {"sha": "926743572821673bc839b9a43444ffe08dc93ecc", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a58089e097c4f80af0353e843e264ae634db686b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a58089e097c4f80af0353e843e264ae634db686b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=a58089e097c4f80af0353e843e264ae634db686b", "patch": "@@ -1,11 +1,10 @@\n-use crate::collections::BTreeSet;\n+use super::super::DeterministicRng;\n+use super::*;\n use crate::vec::Vec;\n use std::iter::FromIterator;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicU32, Ordering};\n \n-use super::super::DeterministicRng;\n-\n #[test]\n fn test_clone_eq() {\n     let mut m = BTreeSet::new();\n@@ -528,11 +527,8 @@ fn test_recovery() {\n     assert_eq!(s.iter().next(), None);\n }\n \n-#[test]\n #[allow(dead_code)]\n fn test_variance() {\n-    use std::collections::btree_set::{IntoIter, Iter, Range};\n-\n     fn set<'new>(v: BTreeSet<&'static str>) -> BTreeSet<&'new str> {\n         v\n     }\n@@ -545,6 +541,85 @@ fn test_variance() {\n     fn range<'a, 'new>(v: Range<'a, &'static str>) -> Range<'a, &'new str> {\n         v\n     }\n+    // not applied to Difference, Intersection, SymmetricDifference, Union\n+}\n+\n+#[allow(dead_code)]\n+fn test_sync() {\n+    fn set<T: Sync>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v\n+    }\n+\n+    fn iter<T: Sync>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.iter()\n+    }\n+\n+    fn into_iter<T: Sync>(v: BTreeSet<T>) -> impl Sync {\n+        v.into_iter()\n+    }\n+\n+    fn range<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.range(..)\n+    }\n+\n+    fn drain_filter<T: Sync + Ord>(v: &mut BTreeSet<T>) -> impl Sync + '_ {\n+        v.drain_filter(|_| false)\n+    }\n+\n+    fn difference<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.difference(&v)\n+    }\n+\n+    fn intersection<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.intersection(&v)\n+    }\n+\n+    fn symmetric_difference<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.symmetric_difference(&v)\n+    }\n+\n+    fn union<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.union(&v)\n+    }\n+}\n+\n+#[allow(dead_code)]\n+fn test_send() {\n+    fn set<T: Send>(v: BTreeSet<T>) -> impl Send {\n+        v\n+    }\n+\n+    fn iter<T: Send + Sync>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.iter()\n+    }\n+\n+    fn into_iter<T: Send>(v: BTreeSet<T>) -> impl Send {\n+        v.into_iter()\n+    }\n+\n+    fn range<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.range(..)\n+    }\n+\n+    fn drain_filter<T: Send + Ord>(v: &mut BTreeSet<T>) -> impl Send + '_ {\n+        v.drain_filter(|_| false)\n+    }\n+\n+    fn difference<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.difference(&v)\n+    }\n+\n+    fn intersection<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.intersection(&v)\n+    }\n+\n+    fn symmetric_difference<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.symmetric_difference(&v)\n+    }\n+\n+    fn union<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.union(&v)\n+    }\n }\n \n #[test]"}]}